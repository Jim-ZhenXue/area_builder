// Copyright 2020-2024, University of Colorado Boulder
/**
 * IOTypes form a synthetic type system used to describe PhET-iO Elements. A PhET-iO Element is an instrumented PhetioObject
 * that is interoperable from the "wrapper" frame (outside the sim frame). An IOType includes documentation, methods,
 * names, serialization, etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */ import validate from '../../../axon/js/validate.js';
import Validation from '../../../axon/js/Validation.js';
import optionize from '../../../phet-core/js/optionize.js';
import PhetioConstants from '../PhetioConstants.js';
import TandemConstants from '../TandemConstants.js';
import tandemNamespace from '../tandemNamespace.js';
import StateSchema from './StateSchema.js';
// constants
const VALIDATE_OPTIONS_FALSE = {
    validateValidator: false
};
const truthy = (x)=>!!x;
// Global flag that triggers pruning the state object down to only that which gets tracked by the PhET-iO API, see
// apiStateKeys to opt into api state tracking
let GETTING_STATE_FOR_API = false;
let API_STATE_NESTED_COUNT = 0;
/**
 * Estimate the core type name from a given IOType name.
 */ const getCoreTypeName = (ioTypeName)=>{
    const index = ioTypeName.indexOf(PhetioConstants.IO_TYPE_SUFFIX);
    assert && assert(index >= 0, 'IO should be in the type name');
    return ioTypeName.substring(0, index);
};
let IOType = class IOType {
    toStateObject(coreObject) {
        API_STATE_NESTED_COUNT++;
        // validate( coreObject, this.validator, VALIDATE_OPTIONS_FALSE );
        let stateObject;
        // Only do this non-standard toStateObject function if there is a stateSchema but no toStateObject provided
        if (!this.toStateObjectSupplied && this.stateSchemaSupplied && this.stateSchema && this.stateSchema.isComposite()) {
            stateObject = this.defaultToStateObject(coreObject);
        } else {
            assert && !this.toStateObjectOption && assert(this.supertype, 'supertype expected if no toStateObject option is provided');
            stateObject = this.toStateObjectOption ? this.toStateObjectOption(coreObject) : this.supertype.toStateObject(coreObject);
        }
        // Do not validate the api state, which get's pruned based on provided apiStateKeys, only validate the complete state
        if (assert && !GETTING_STATE_FOR_API && // only if this IOType instance has more to validate than the supertype
        (this.toStateObjectSupplied || this.stateSchemaSupplied)) {
            // Only validate the stateObject if it is phetioState:true.
            // This is an n*m algorithm because for each time toStateObject is called and needs validation, this.validateStateObject
            // looks all the way up the IOType hierarchy. This is not efficient, but gains us the ability to make sure that
            // the stateObject doesn't have any superfluous, unexpected keys. The "m" portion is based on how many sub-properties
            // in a state call `toStateObject`, and the "n" portion is based on how many IOTypes in the hierarchy define a
            // toStateObject or stateSchema. In the future we could potentially improve performance by having validateStateObject
            // only check against the schema at this level, but then extra keys in the stateObject would not be caught. From work done in https://github.com/phetsims/phet-io/issues/1774
            this.validateStateObject(stateObject);
        }
        let resolvedStateObject;
        // When getting API state, prune out any state that don't opt in as desired for API tracking, see apiStateKeys
        if (GETTING_STATE_FOR_API && this.isCompositeStateSchema() && // When running a nested toStateObject call while generating api state, values should be opt in, because the
        // element state has asked for these values. For example PropertyIO<RangeIO> wants to see min/max state in
        // its validValues.
        !(API_STATE_NESTED_COUNT > 1 && this.apiStateKeysProvided())) {
            resolvedStateObject = _.pick(stateObject, this.getAllAPIStateKeys());
        } else {
            resolvedStateObject = stateObject;
        }
        API_STATE_NESTED_COUNT--;
        return resolvedStateObject;
    }
    fromStateObject(stateObject) {
        if (this.fromStateObjectOption) {
            return this.fromStateObjectOption(stateObject);
        }
        assert && assert(this.supertype);
        return this.supertype.fromStateObject(stateObject);
    }
    applyState(coreObject, stateObject) {
        validate(coreObject, this.validator, VALIDATE_OPTIONS_FALSE);
        // Validate, but only if this IOType instance has more to validate than the supertype
        if (this.applyStateSupplied || this.stateSchemaSupplied) {
            // Validate that the provided stateObject is of the expected schema
            // NOTE: Cannot use this.validateStateObject because options adopts supertype.applyState, which is bounds to the
            // parent IOType. This prevents correct validation because the supertype doesn't know about the subtype schemas.
            // @ts-expect-error we cannot type check against PhetioObject from this file
            assert && coreObject.phetioType && coreObject.phetioType.validateStateObject(stateObject);
        }
        // Only do this non-standard applyState function from stateSchema if there is a stateSchema but no applyState provided
        if (!this.applyStateSupplied && this.stateSchemaSupplied && this.stateSchema && this.stateSchema.isComposite()) {
            this.defaultApplyState(coreObject, stateObject);
        } else {
            assert && !this.applyStateOption && assert(this.supertype, 'supertype expected if no applyState option is provided');
            this.applyStateOption ? this.applyStateOption(coreObject, stateObject) : this.supertype.applyState(coreObject, stateObject);
        }
    }
    stateObjectToCreateElementArguments(stateObject) {
        if (this.stateObjectToCreateElementArgumentsOption) {
            return this.stateObjectToCreateElementArgumentsOption(stateObject);
        }
        assert && assert(this.supertype);
        return this.supertype.stateObjectToCreateElementArguments(stateObject);
    }
    // Include state from all composite state schemas up and down the type hierarchy (children overriding parents).
    defaultToStateObject(coreObject) {
        let superStateObject = {};
        if (this.supertype) {
            superStateObject = this.supertype.defaultToStateObject(coreObject);
        }
        if (this.stateSchema && this.stateSchema.isComposite()) {
            return _.merge(superStateObject, this.stateSchema.defaultToStateObject(coreObject));
        } else {
            return superStateObject;
        }
    }
    // Include state from all composite state schemas up and down the type hierarchy (children overriding parents).
    defaultApplyState(coreObject, stateObject) {
        if (this.supertype) {
            this.supertype.defaultApplyState(coreObject, stateObject);
        }
        if (this.stateSchema && this.stateSchema.isComposite()) {
            this.stateSchema.defaultApplyState(coreObject, stateObject);
        }
    }
    /**
   * Gets an array of IOTypes of the self type and all the supertype ancestors.
   */ getTypeHierarchy() {
        const array = [];
        let ioType = this; // eslint-disable-line consistent-this, @typescript-eslint/no-this-alias
        while(ioType){
            array.push(ioType);
            ioType = ioType.supertype;
        }
        return array;
    }
    /**
   * Returns true if this IOType is a subtype of the passed-in type (or if they are the same).
   */ extends(type) {
        // memory-based implementation OK since this method is only used in assertions
        return this.getTypeHierarchy().includes(type);
    }
    /**
   * Return all the metadata defaults (for the entire IOType hierarchy)
   */ getAllMetadataDefaults() {
        return _.merge({}, this.supertype ? this.supertype.getAllMetadataDefaults() : {}, this.metadataDefaults);
    }
    /**
   * Return all the data defaults (for the entire IOType hierarchy)
   */ getAllDataDefaults() {
        return _.merge({}, this.supertype ? this.supertype.getAllDataDefaults() : {}, this.dataDefaults);
    }
    /**
   * This cannot be in stateSchema, because some IOTypes do not have stateSchema instances, but their supertype does.
   */ isCompositeStateSchema() {
        var _this_supertype, _this_stateSchema;
        return ((_this_supertype = this.supertype) == null ? void 0 : _this_supertype.isCompositeStateSchema()) || !!((_this_stateSchema = this.stateSchema) == null ? void 0 : _this_stateSchema.compositeSchema);
    }
    /**
   * Return all the apiStateKey option values (for the entire IOType hierarchy)
   * For example:
   *  [ null, null, ['validValues'], null ] if there were three supertypes, and your parent was the only IOType with apiStateKeys
   */ getAllAPIStateKeyValues(apiStateKeysPerLevel = []) {
        var _this_stateSchema;
        this.supertype && this.supertype.getAllAPIStateKeyValues(apiStateKeysPerLevel);
        apiStateKeysPerLevel.push(((_this_stateSchema = this.stateSchema) == null ? void 0 : _this_stateSchema.apiStateKeys) || null);
        return apiStateKeysPerLevel;
    }
    /**
   * See if any IOType up the hierarchy actually supplied apiStateKeys, even in `[]`, meaning "don't opt-in to nested
   * API state.
   */ apiStateKeysProvided() {
        return this.getAllAPIStateKeyValues().filter(truthy).length === 0;
    }
    /**
   * Return all the apiStateKeys (for the entire IOType hierarchy) in one array.
   */ getAllAPIStateKeys() {
        return _.concat(...this.getAllAPIStateKeyValues().map((x)=>x || []));
    }
    /**
   * Get the state object for a PhET-iO Element, but only the entries that should be tracked by the PhET-iO API. See
   * StateSchema.apiStateKeys for details. This implementation sets a global to make sure that nested state also only
   * selects the apiStateKeys for api tracking (PropertyIO<RangeIO> could have validValues of PointIO that shouldn't
   * include non-tracked values of PointIO, if there are any).
   */ toStateObjectForAPI(coreObject) {
        assert && assert(!GETTING_STATE_FOR_API, 'API state cannot nest due to limitation of the global');
        GETTING_STATE_FOR_API = true;
        assert && assert(API_STATE_NESTED_COUNT === 0, 'not nested before getting API state');
        const stateObjectForAPIOnly = this.toStateObject(coreObject);
        assert && assert(API_STATE_NESTED_COUNT === 0, 'not nested after getting API state');
        GETTING_STATE_FOR_API = false;
        return stateObjectForAPIOnly;
    }
    /**
   * @param stateObject - the stateObject to validate against
   * @param toAssert=false - whether to assert when invalid
   * @param schemaKeysPresentInStateObject=[]
   * @returns if the stateObject is valid or not.
   */ isStateObjectValid(stateObject, toAssert = false, schemaKeysPresentInStateObject = []) {
        // Set to false when invalid
        let valid = true;
        // make sure the stateObject has everything the schema requires and nothing more
        if (this.stateSchema) {
            const validSoFar = this.stateSchema.checkStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject);
            // null as a marker to keep checking up the hierarchy, otherwise we reached our based case because the stateSchema was a value, not a composite
            if (validSoFar !== null) {
                return validSoFar;
            }
        }
        if (this.supertype) {
            return valid && this.supertype.isStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject);
        }
        // When we reach the root, make sure there isn't anything in the stateObject that isn't described by a schema
        if (!this.supertype && stateObject && typeof stateObject !== 'string' && !Array.isArray(stateObject)) {
            // Visit the state
            Object.keys(stateObject).forEach((key)=>{
                const keyValid = schemaKeysPresentInStateObject.includes(key);
                if (!keyValid) {
                    valid = false;
                }
                assert && toAssert && assert(keyValid, `stateObject provided a key that is not in the schema: ${key}`);
            });
            return valid;
        }
        return true;
    }
    /**
   * Assert if the provided stateObject is not valid to this IOType's stateSchema
   */ validateStateObject(stateObject) {
        this.isStateObjectValid(stateObject, true);
    }
    toString() {
        return this.typeName;
    }
    /**
   * Return an object that indicates the API type, including documentation, methods & signatures, supertypes, etc.
   * The object is intended for serialization via JSON.stringify().
   *
   * This function could be static, but that doesn't work well with the singleton pattern, so keep in on the prototype.
   */ getAPI() {
        // Enumerate the methods specific to the type (not for supertype).
        const methods = {};
        const methodNames = _.keys(this.methods);
        // iterate over each method
        for(let i = 0; i < methodNames.length; i++){
            const methodName = methodNames[i];
            const method = this.methods[methodName];
            const m = {
                // Return names for parameter types and return types to prevent loops in type graph
                returnType: method.returnType.typeName,
                parameterTypes: method.parameterTypes.map(mapAPIForType),
                documentation: method.documentation
            };
            // invocableForReadOnlyElements===false is opt-in
            if (method.invocableForReadOnlyElements === false) {
                m.invocableForReadOnlyElements = false;
            }
            methods[methodName] = m;
        }
        const supertype = this.supertype;
        // Return all parts of the API as an object
        const phetioType = {
            methods: methods,
            supertype: supertype ? supertype.typeName : supertype,
            typeName: this.typeName,
            documentation: this.documentation,
            events: this.events,
            metadataDefaults: this.metadataDefaults,
            dataDefaults: this.dataDefaults,
            methodOrder: this.methodOrder
        };
        if (this.stateSchema) {
            phetioType.stateSchema = this.stateSchema.getStateSchemaAPI();
            if (this.stateSchema.apiStateKeys && this.stateSchema.apiStateKeys.length > 0) {
                phetioType.apiStateKeys = this.stateSchema.apiStateKeys;
            }
        }
        // This way we don't have this key unless there are parameterTypes possible (empty array allowed)
        if (this.parameterTypes) {
            phetioType.parameterTypes = this.parameterTypes.map(mapAPIForType);
        }
        return phetioType;
    }
    /**
   * @param typeName - The name that this IOType will have in the public PhET-iO API. In general, this should
   *    only be word characters, ending in "IO". Parametric types are a special subset of IOTypes that include their
   *    parameters in their typeName. If an IOType's parameters are other IOType(s), then they should be included within
   *    angle brackets, like "PropertyIO<BooleanIO>". Some other types use a more custom format for displaying their
   *    parameter types, in this case the parameter section of the type name (immediately following "IO") should begin
   *    with an open paren, "(". Thus the schema for a typeName could be defined (using regex) as `[A-Z]\w*IO([(<].*){0,1}`.
   *    Parameterized types should also include a `parameterTypes` field on the IOType.
   * @param providedOptions
   */ constructor(typeName, providedOptions){
        this.typeName = typeName;
        // For reference in the options
        const supertype = providedOptions.supertype || IOType.ObjectIO;
        const toStateObjectSupplied = !!providedOptions.toStateObject;
        const applyStateSupplied = !!providedOptions.applyState;
        const stateSchemaSupplied = !!providedOptions.stateSchema;
        const options = optionize()({
            supertype: IOType.ObjectIO,
            methods: {},
            events: [],
            metadataDefaults: {},
            //  Most likely this will remain PhET-iO internal, and shouldn't need to be used when creating IOTypes outside of tandem/.
            dataDefaults: {},
            methodOrder: [],
            parameterTypes: [],
            documentation: `PhET-iO Type for ${getCoreTypeName(typeName)}`,
            isFunctionType: false,
            /**** STATE ****/ toStateObject: null,
            fromStateObject: null,
            stateObjectToCreateElementArguments: null,
            applyState: null,
            stateSchema: null,
            apiStateKeys: null,
            defaultDeserializationMethod: 'fromStateObject',
            addChildElement: supertype && supertype.addChildElement
        }, providedOptions);
        if (assert && supertype) {
            Object.keys(options.metadataDefaults).forEach((metadataDefaultKey)=>{
                assert && supertype.getAllMetadataDefaults().hasOwnProperty(metadataDefaultKey) && assert(supertype.getAllMetadataDefaults()[metadataDefaultKey] !== options.metadataDefaults[metadataDefaultKey], `${metadataDefaultKey} should not have the same default value as the ancestor metadata default.`);
            });
        }
        this.supertype = supertype;
        this.documentation = options.documentation;
        this.methods = options.methods;
        this.events = options.events;
        this.metadataDefaults = options.metadataDefaults;
        this.dataDefaults = options.dataDefaults;
        this.methodOrder = options.methodOrder;
        this.parameterTypes = options.parameterTypes;
        // Validation
        this.validator = _.pick(options, Validation.VALIDATOR_KEYS);
        this.validator.validationMessage = this.validator.validationMessage || `Validation failed IOType Validator: ${this.typeName}`;
        this.defaultDeserializationMethod = options.defaultDeserializationMethod;
        if (options.stateSchema === null || options.stateSchema instanceof StateSchema) {
            this.stateSchema = options.stateSchema;
        } else {
            const compositeSchema = typeof options.stateSchema === 'function' ? options.stateSchema(this) : options.stateSchema;
            this.stateSchema = new StateSchema({
                compositeSchema: compositeSchema,
                apiStateKeys: options.apiStateKeys
            });
        }
        // Assert that toStateObject method is provided for value StateSchemas. Do this with the following logic:
        // 1. It is acceptable to not provide a stateSchema (for IOTypes that aren't stateful)
        // 2. You must either provide a toStateObject, or have a composite StateSchema. Composite state schemas support default serialization methods.
        assert && assert(!this.stateSchema || toStateObjectSupplied || this.stateSchema.isComposite(), 'toStateObject method must be provided for value StateSchemas');
        this.toStateObjectOption = options.toStateObject;
        this.fromStateObjectOption = options.fromStateObject;
        this.applyStateOption = options.applyState;
        this.stateObjectToCreateElementArgumentsOption = options.stateObjectToCreateElementArguments;
        this.toStateObjectSupplied = toStateObjectSupplied;
        this.applyStateSupplied = applyStateSupplied;
        this.stateSchemaSupplied = stateSchemaSupplied;
        this.isFunctionType = options.isFunctionType;
        this.addChildElement = options.addChildElement;
        if (assert) {
            assert && assert(supertype || this.typeName === 'ObjectIO', 'supertype is required');
            assert && assert(!this.typeName.includes('.'), 'Dots should not appear in type names');
            assert && assert(this.typeName.split(/[<(]/)[0].endsWith(PhetioConstants.IO_TYPE_SUFFIX), `IOType name must end with ${PhetioConstants.IO_TYPE_SUFFIX}`);
            assert && assert(this.hasOwnProperty('typeName'), 'this.typeName is required');
            // assert that each public method adheres to the expected schema
            this.methods && Object.values(this.methods).forEach((methodObject)=>{
                if (typeof methodObject === 'object') {
                    assert && methodObject.invocableForReadOnlyElements && assert(typeof methodObject.invocableForReadOnlyElements === 'boolean', `invocableForReadOnlyElements must be of type boolean: ${methodObject.invocableForReadOnlyElements}`);
                }
            });
            assert && assert(this.documentation.length > 0, 'documentation must be provided');
            this.methods && this.hasOwnProperty('methodOrder') && this.methodOrder.forEach((methodName)=>{
                assert && assert(this.methods[methodName], `methodName not in public methods: ${methodName}`);
            });
            if (supertype) {
                var _this_stateSchema;
                const typeHierarchy = supertype.getTypeHierarchy();
                assert && this.events && this.events.forEach((event)=>{
                    // Make sure events are not listed again
                    assert && assert(!_.some(typeHierarchy, (t)=>t.events.includes(event)), `IOType should not declare event that parent also has: ${event}`);
                });
                if ((_this_stateSchema = this.stateSchema) == null ? void 0 : _this_stateSchema.apiStateKeys) {
                    var _this_stateSchema1;
                    const supertypeAPIKeys = supertype.getAllAPIStateKeys();
                    (_this_stateSchema1 = this.stateSchema) == null ? void 0 : _this_stateSchema1.apiStateKeys.forEach((apiStateKey)=>{
                        assert && assert(!supertypeAPIKeys.includes(apiStateKey), `apiStateKey is already in the super: ${apiStateKey}`);
                    });
                }
            } else {
                // The root IOType must supply all 4 state methods.
                assert && assert(typeof options.toStateObject === 'function', 'toStateObject must be defined');
                assert && assert(typeof options.fromStateObject === 'function', 'fromStateObject must be defined');
                assert && assert(typeof options.stateObjectToCreateElementArguments === 'function', 'stateObjectToCreateElementArguments must be defined');
                assert && assert(typeof options.applyState === 'function', 'applyState must be defined');
            }
        }
    }
};
// StateType is the whole thing, SelfStateType is just at this level
// export default class IOType<T = any, SelfStateType = any, ParentStateType = EmptyParent, StateType extends SelfStateType & ParentStateType = SelfStateType & ParentStateType> { // eslint-disable-line @typescript-eslint/no-explicit-any
export { IOType as default };
const mapAPIForType = (parameterType)=>parameterType.typeName;
// default state value
const DEFAULT_STATE = null;
// This must be declared after the class declaration to avoid a circular dependency with PhetioObject.
// @readonly
IOType.ObjectIO = new IOType(TandemConstants.OBJECT_IO_TYPE_NAME, {
    isValidValue: ()=>true,
    supertype: null,
    documentation: 'The root of the PhET-iO Type hierarchy',
    toStateObject: (coreObject)=>{
        if (phet && phet.tandem && phet.tandem.Tandem.VALIDATION) {
            assert && assert(coreObject.tandem, 'coreObject must be PhET-iO object');
            assert && assert(!coreObject.phetioState, `fell back to root serialization state for ${coreObject.tandem.phetioID}. Potential solutions:
         * mark the type as phetioState: false
         * create a custom toStateObject method in your IOType
         * perhaps you have everything right, but forgot to pass in the IOType via phetioType in the constructor`);
        }
        return DEFAULT_STATE;
    },
    fromStateObject: ()=>{
        throw new Error('ObjectIO.fromStateObject should not be called');
    },
    stateObjectToCreateElementArguments: ()=>[],
    applyState: _.noop,
    metadataDefaults: TandemConstants.PHET_IO_OBJECT_METADATA_DEFAULTS,
    dataDefaults: {
        initialState: DEFAULT_STATE
    },
    stateSchema: null
});
tandemNamespace.register('IOType', IOType);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9JT1R5cGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogSU9UeXBlcyBmb3JtIGEgc3ludGhldGljIHR5cGUgc3lzdGVtIHVzZWQgdG8gZGVzY3JpYmUgUGhFVC1pTyBFbGVtZW50cy4gQSBQaEVULWlPIEVsZW1lbnQgaXMgYW4gaW5zdHJ1bWVudGVkIFBoZXRpb09iamVjdFxuICogdGhhdCBpcyBpbnRlcm9wZXJhYmxlIGZyb20gdGhlIFwid3JhcHBlclwiIGZyYW1lIChvdXRzaWRlIHRoZSBzaW0gZnJhbWUpLiBBbiBJT1R5cGUgaW5jbHVkZXMgZG9jdW1lbnRhdGlvbiwgbWV0aG9kcyxcbiAqIG5hbWVzLCBzZXJpYWxpemF0aW9uLCBldGMuXG4gKlxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcbiAqL1xuXG5pbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy92YWxpZGF0ZS5qcyc7XG5pbXBvcnQgVmFsaWRhdGlvbiwgeyBWYWxpZGF0b3IgfSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1ZhbGlkYXRpb24uanMnO1xuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xuaW1wb3J0IHsgSU9UeXBlTmFtZSwgTWV0aG9kLCBNZXRob2RzLCBQaGV0aW9FbGVtZW50TWV0YWRhdGEsIFBoZXRpb1R5cGUgfSBmcm9tICcuLi9waGV0LWlvLXR5cGVzLmpzJztcbmltcG9ydCBQaGV0aW9Db25zdGFudHMgZnJvbSAnLi4vUGhldGlvQ29uc3RhbnRzLmpzJztcbmltcG9ydCBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBmcm9tICcuLi9QaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lci5qcyc7XG5pbXBvcnQgdHlwZSBQaGV0aW9PYmplY3QgZnJvbSAnLi4vUGhldGlvT2JqZWN0LmpzJztcbmltcG9ydCBUYW5kZW1Db25zdGFudHMgZnJvbSAnLi4vVGFuZGVtQ29uc3RhbnRzLmpzJztcbmltcG9ydCB0YW5kZW1OYW1lc3BhY2UgZnJvbSAnLi4vdGFuZGVtTmFtZXNwYWNlLmpzJztcbmltcG9ydCBTdGF0ZVNjaGVtYSwgeyBBUElTdGF0ZUtleXMsIENvbXBvc2l0ZVNjaGVtYSwgQ29tcG9zaXRlU3RhdGVPYmplY3RUeXBlIH0gZnJvbSAnLi9TdGF0ZVNjaGVtYS5qcyc7XG5cbi8vIGNvbnN0YW50c1xuY29uc3QgVkFMSURBVEVfT1BUSU9OU19GQUxTRSA9IHsgdmFsaWRhdGVWYWxpZGF0b3I6IGZhbHNlIH07XG5cbmNvbnN0IHRydXRoeSA9ICggeDogSW50ZW50aW9uYWxBbnkgKTogYm9vbGVhbiA9PiAhIXg7XG5cbi8vIEdsb2JhbCBmbGFnIHRoYXQgdHJpZ2dlcnMgcHJ1bmluZyB0aGUgc3RhdGUgb2JqZWN0IGRvd24gdG8gb25seSB0aGF0IHdoaWNoIGdldHMgdHJhY2tlZCBieSB0aGUgUGhFVC1pTyBBUEksIHNlZVxuLy8gYXBpU3RhdGVLZXlzIHRvIG9wdCBpbnRvIGFwaSBzdGF0ZSB0cmFja2luZ1xubGV0IEdFVFRJTkdfU1RBVEVfRk9SX0FQSSA9IGZhbHNlO1xubGV0IEFQSV9TVEFURV9ORVNURURfQ09VTlQgPSAwO1xuXG4vKipcbiAqIEVzdGltYXRlIHRoZSBjb3JlIHR5cGUgbmFtZSBmcm9tIGEgZ2l2ZW4gSU9UeXBlIG5hbWUuXG4gKi9cbmNvbnN0IGdldENvcmVUeXBlTmFtZSA9ICggaW9UeXBlTmFtZTogSU9UeXBlTmFtZSApOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpbmRleCA9IGlvVHlwZU5hbWUuaW5kZXhPZiggUGhldGlvQ29uc3RhbnRzLklPX1RZUEVfU1VGRklYICk7XG4gIGFzc2VydCAmJiBhc3NlcnQoIGluZGV4ID49IDAsICdJTyBzaG91bGQgYmUgaW4gdGhlIHR5cGUgbmFtZScgKTtcbiAgcmV0dXJuIGlvVHlwZU5hbWUuc3Vic3RyaW5nKCAwLCBpbmRleCApO1xufTtcblxudHlwZSBBZGRDaGlsZEVsZW1lbnQgPSAoIGdyb3VwOiBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lcjxQaGV0aW9PYmplY3Q+LCBjb21wb25lbnROYW1lOiBzdHJpbmcsIHN0YXRlT2JqZWN0OiB1bmtub3duICkgPT4gUGhldGlvT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBJT1R5cGVNZXRob2QgPSB7XG4gIHJldHVyblR5cGU6IElPVHlwZTtcbiAgcGFyYW1ldGVyVHlwZXM6IElPVHlwZVtdO1xuXG4gIC8vdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuIFRoaXMgZnVuY3Rpb24ncyBwYXJhbWV0ZXJzIHdpbGwgYmUgYmFzZWQgb24gYHBhcmFtZXRlclR5cGVzYCxcbiAgLy8gYW5kIHNob3VsZCByZXR1cm4gdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IGByZXR1cm5UeXBlYFxuICBpbXBsZW1lbnRhdGlvbjogKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkgPT4gdW5rbm93bjtcbiAgZG9jdW1lbnRhdGlvbjogc3RyaW5nO1xuXG4gIC8vIGJ5IGRlZmF1bHQsIGFsbCBtZXRob2RzIGFyZSBpbnZvY2FibGUgZm9yIGFsbCBlbGVtZW50cy4gSG93ZXZlciwgZm9yIHNvbWUgcmVhZC1vbmx5IGVsZW1lbnRzLCBjZXJ0YWluIG1ldGhvZHNcbiAgLy8gc2hvdWxkIG5vdCBiZSBpbnZvY2FibGUuIEluIHRoYXQgY2FzZSwgdGhleSBhcmUgbWFya2VkIGFzIGludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHM6IGZhbHNlLlxuICBpbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzPzogYm9vbGVhbjtcbn07XG5cbnR5cGUgRGVzZXJpYWxpemF0aW9uVHlwZSA9ICdmcm9tU3RhdGVPYmplY3QnIHwgJ2FwcGx5U3RhdGUnO1xuXG50eXBlIFN0YXRlU2NoZW1hT3B0aW9uPFQsIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+ID0gKFxuICAoIGlvVHlwZTogSU9UeXBlPFQsIFN0YXRlVHlwZSwgU2VsZlN0YXRlVHlwZT4gKSA9PiBDb21wb3NpdGVTY2hlbWE8U2VsZlN0YXRlVHlwZT4gKSB8XG4gIFN0YXRlU2NoZW1hPFQsIFN0YXRlVHlwZT4gfFxuICBDb21wb3NpdGVTY2hlbWE8U2VsZlN0YXRlVHlwZT4gfFxuICBudWxsO1xuXG50eXBlIFNlbGZPcHRpb25zPFQsIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+ID0ge1xuXG4gIC8vIElPVHlwZXMgZm9ybSBhbiBvYmplY3QgdHJlZSBsaWtlIGEgdHlwZSBoaWVyYXJjaHkuIElmIHRoZSBzdXBlcnR5cGUgaXMgc3BlY2lmaWVkLCBhdHRyaWJ1dGVzIHN1Y2ggYXNcbiAgLy8gdG9TdGF0ZU9iamVjdCwgZnJvbVN0YXRlT2JqZWN0LCBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cywgYXBwbHlTdGF0ZSwgYWRkQ2hpbGRFbGVtZW50XG4gIC8vIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIHN1cGVydHlwZSAodW5sZXNzIG92ZXJyaWRkZW4pLiAgSXQgaXMgYWxzbyB1c2VkIGluIGZlYXR1cmVzIHN1Y2ggYXMgc2NoZW1hIHZhbGlkYXRpb24sXG4gIC8vIGRhdGEvbWV0YWRhdGEgZGVmYXVsdCBjYWxjdWxhdGlvbnMuXG4gIHN1cGVydHlwZT86IElPVHlwZSB8IG51bGw7XG5cbiAgLy8gVGhlIGxpc3Qgb2YgZXZlbnRzIHRoYXQgY2FuIGJlIGVtaXR0ZWQgYXQgdGhpcyBsZXZlbCAoZG9lcyBub3QgaW5jbHVkZSBldmVudHMgZnJvbSBzdXBlcnR5cGVzKS5cbiAgZXZlbnRzPzogc3RyaW5nW107XG5cbiAgLy8gS2V5L3ZhbHVlIHBhaXJzIGluZGljYXRpbmcgdGhlIGRlZmF1bHRzIGZvciB0aGUgSU9UeXBlIGRhdGEsIGp1c3QgZm9yIHRoaXMgbGV2ZWwgKGRvIG5vdCBzcGVjaWZ5IHBhcmVudCBkZWZhdWx0cylcbiAgZGF0YURlZmF1bHRzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbiAgLy8gS2V5L3ZhbHVlIHBhaXJzIGluZGljYXRpbmcgdGhlIGRlZmF1bHRzIGZvciB0aGUgSU9UeXBlIG1ldGFkYXRhLlxuICAvLyBJZiBhbnl0aGluZyBpcyBwcm92aWRlZCBoZXJlLCB0aGVuIGNvcnJlc3BvbmRpbmcgUGhldGlvT2JqZWN0cyB0aGF0IHVzZSB0aGlzIElPVHlwZSBzaG91bGQgb3ZlcnJpZGVcbiAgLy8gUGhldGlvT2JqZWN0LmdldE1ldGFkYXRhKCkgdG8gYWRkIHdoYXQga2V5cyB0aGV5IG5lZWQgZm9yIHRoZWlyIHNwZWNpZmljIHR5cGUuICBDYW5ub3Qgc3BlY2lmeSByZWR1bmRhbnQgdmFsdWVzXG4gIC8vICh0aGF0IGFuIGFuY2VzdG9yIGFscmVhZHkgc3BlY2lmaWVkKS5cbiAgbWV0YWRhdGFEZWZhdWx0cz86IFBhcnRpYWw8UGhldGlvRWxlbWVudE1ldGFkYXRhPjtcblxuICAvLyBUZXh0IHRoYXQgZGVzY3JpYmVzIHRoZSBJT1R5cGUsIHByZXNlbnRlZCB0byB0aGUgUGhFVC1pTyBDbGllbnQgaW4gU3R1ZGlvLCBzdXBwb3J0cyBIVE1MIG1hcmt1cC5cbiAgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcblxuICAvLyBUaGUgcHVibGljIG1ldGhvZHMgYXZhaWxhYmxlIGZvciB0aGlzIElPVHlwZS4gRWFjaCBtZXRob2QgaXMgbm90IGp1c3QgYSBmdW5jdGlvbixcbiAgLy8gYnV0IGEgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBhYm91dCB0aGUgbWV0aG9kIHRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHBhcmFtZXRlcnMgYW5kIHJldHVybiB0eXBlcyBhbmQgcHJvdmlkZVxuICAvLyBiZXR0ZXIgZG9jdW1lbnRhdGlvbi5cbiAgbWV0aG9kcz86IFJlY29yZDxzdHJpbmcsIElPVHlwZU1ldGhvZD47XG5cbiAgLy8gSU9UeXBlcyBjYW4gc3BlY2lmeSB0aGUgb3JkZXIgdGhhdCBtZXRob2RzIGFwcGVhciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBieSBwdXR0aW5nIHRoZWlyIG5hbWVzIGluIHRoaXNcbiAgLy8gbGlzdC4gVGhpcyBsaXN0IGlzIG9ubHkgZm9yIHRoZSBtZXRob2RzIGRlZmluZWQgYXQgdGhpcyBsZXZlbCBpbiB0aGUgdHlwZSBoaWVyYXJjaHkuIEFmdGVyIHRoZSBtZXRob2RPcmRlclxuICAvLyBzcGVjaWZpZWQsIHRoZSBtZXRob2RzIGZvbGxvdyBpbiB0aGUgb3JkZXIgZGVjbGFyZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uICh3aGljaCBpc24ndCBuZWNlc3NhcmlseSBzdGFibGUpLlxuICBtZXRob2RPcmRlcj86IHN0cmluZ1tdO1xuXG4gIC8vIEZvciBwYXJhbWV0cmljIHR5cGVzLCB0aGV5IG11c3QgaW5kaWNhdGUgdGhlIHR5cGVzIG9mIHRoZSBwYXJhbWV0ZXJzIGhlcmUuIEVtcHR5IGFycmF5IGlmIG5vbi1wYXJhbWV0cmljLlxuICBwYXJhbWV0ZXJUeXBlcz86IElPVHlwZVtdO1xuXG4gIC8vIEZvciBpbnRlcm5hbCBwaGV0LWlvIHVzZSBvbmx5LiBGdW5jdGlvbnMgY2Fubm90IGJlIHNlbnQgZnJvbSBvbmUgaWZyYW1lIHRvIGFub3RoZXIsIHNvIG11c3QgYmUgd3JhcHBlZC4gU2VlXG4gIC8vIHBoZXRpb0NvbW1hbmRQcm9jZXNzb3Iud3JhcEZ1bmN0aW9uXG4gIGlzRnVuY3Rpb25UeXBlPzogYm9vbGVhbjtcblxuICAvLyAqKioqKioqKiBTVEFURSAqKioqKioqKiAvL1xuXG4gIC8vIFRoZSBzcGVjaWZpY2F0aW9uIGZvciBob3cgdGhlIFBoRVQtaU8gc3RhdGUgd2lsbCBsb29rIGZvciBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLiBudWxsIHNwZWNpZmllcyB0aGF0IHRoZSBvYmplY3RcbiAgLy8gaXMgbm90IHNlcmlhbGl6ZWQuIEEgY29tcG9zaXRlIFN0YXRlU2NoZW1hIGNhbiBzdXBwbHkgYSB0b1N0YXRlT2JqZWN0IGFuZCBhcHBseVN0YXRlIHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kuIFRoaXNcbiAgLy8gZGVmYXVsdCBzZXJpYWxpemF0aW9uIHN0cmF0ZWd5IG9ubHkgYXBwbGllcyB0byB0aGlzIGxldmVsLCBhbmQgZG9lcyBub3QgcmVjdXJzZSB0byBwYXJlbnRzLiBJZiB5b3UgbmVlZCB0byBhZGRcbiAgLy8gc2VyaWFsaXphdGlvbiBmcm9tIHBhcmVudCBsZXZlbHMsIHRoaXMgY2FuIGJlIGRvbmUgYnkgbWFudWFsbHkgaW1wbGVtZW50aW5nIGEgY3VzdG9tIHRvU3RhdGVPYmplY3QuIEJ5IGRlZmF1bHQsIGl0XG4gIC8vIHdpbGwgYXNzdW1lIHRoYXQgZWFjaCBjb21wb3NpdGUgY2hpbGQgb2YgdGhpcyBzdGF0ZVNjaGVtYSBkZXNlcmlhbGl6ZXMgdmlhIFwiZnJvbVN0YXRlT2JqZWN0XCIsIGlmIGluc3RlYWQgaXQgdXNlc1xuICAvLyBhcHBseVN0YXRlLCBwbGVhc2Ugc3BlY2lmeSB0aGF0IHBlciBJT1R5cGUgd2l0aCBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kLlxuICAvLyBGb3IgcGhldGlvU3RhdGU6IHRydWUgb2JqZWN0cywgdGhpcyBzaG91bGQgYmUgcmVxdWlyZWQsIGJ1dCBtYXkgYmUgc3BlY2lmaWVkIGluIHRoZSBwYXJlbnQgSU9UeXBlLCBsaWtlIGluIERlcml2ZWRQcm9wZXJ0eUlPXG4gIHN0YXRlU2NoZW1hPzogU3RhdGVTY2hlbWFPcHRpb248VCwgU3RhdGVUeXBlLCBTZWxmU3RhdGVUeXBlPjtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGtleXMgZm91bmQgaW4gdGhpcyBJT1R5cGUncyBjb21wb3NpdGUgc3RhdGUgdGhhdCBzaG91bGQgYmUgQVBJIHRyYWNrZWQuXG4gICAqIEluaXRpYWwgc3RhdGVzIGFyZSB0cmFja2VkIGluIGFwaSBmaWxlIGZvciBlYWNoIHN0YXRlZnVsIGluc3RhbmNlLCB0aGlzIG1lYW5zIHRoYXQgdGhvc2UgdmFsdWUgY2hhbmdlcyBjYW5cbiAgICogdHJpZ2dlciBhcGkgY2hhbmdlcy4gVGhpcyBkb2Vzbid0IG9jY3VyIGJ5IGRlZmF1bHQsIHNvIGluc3RlYWQgeW91IG11c3Qgb3B0IGludG8gdG8gdmFsdWUtYmFzZWQgYXBpIHRyYWNraW5nIGxpa2VcbiAgICogdGhpcy5cbiAgICogVGhpcyBvcHRpb24gaXMgbW9zdGx5IHJlY29nbml6aW5nIHRoYXQgaXQgaXMgbGVzcyB0aGFuIGlkZWFsIHRoZSBtZXRhZGF0YSB0aGUgZGVzY3JpYmVzIHdoYXQga2luZCBvZiB2YWx1ZXNcbiAgICogYSBQaEV0LWlPIEVsZW1lbnQgY291bGQgYmUgYXJlIGluIHN0YXRlLCBldmVuIHRob3VnaCB0aGV5IHByb2JhYmx5IHNob3VsZG4ndCBiZS4gTGlrZSBQcm9wZXJ0eUlPLnZhbGlkVmFsdWVzLiBXZVxuICAgKiBhcmUgbGlrZWx5IG5ldmVyIGdvaW5nIHRvIGNoYW5nZSB0aGF0LCBkdWUgdG8gY29tcGxleGl0eSBhbmQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgbmVlZHMsIHNvIHRoaXMgb3B0aW9uIGFsbG93c1xuICAgKiBBUEkgdHJhY2tpbmcgZm9yIHN0YXRlIGxpa2UgdGhhdCwgd2l0aG91dCBpbmN1cnJpbmcgdGhlIGNvc3Qgb2YgdHJhY2tpbmcgdXNlbGVzcyB2YWx1ZSBjaGFuZ2VzIChQcm9wZXJ0eUlPLnZhbHVlLFxuICAgKiBmb3IgZXhhbXBsZSkuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0YXRlIHVzZWQgYnkgYW5vdGhlciBQaEVULWlPIEVsZW1lbnQgdGhhdCBpcyBvcHRpbmcgaW50byBhcGkgdHJhY2tpbmcgd2lsbCBiZSBhZGRlZCB0byB0aGUgQVBJLiBGb3JcbiAgICogZXhhbXBsZSwgYmVjYXVzZSBQcm9wZXJ0eUlPLnZhbGlkVmFsdWVzIG9wdHMgaW50byBhcGkgdHJhY2tpbmcsIGEgUHJvcGVydHlJTzxSYW5nZUlPPiB3aWxsIHNob3cgdmFsaWRWYWx1ZXMgd2l0aCBmdWxsXG4gICAqIFJhbmdlSU8gc3RhdGUgb2JqZWN0cyBpbiBpdC4gVGhpcyBpcyBiZWNhdXNlIFJhbmdlSU8gZG9lc24ndCBwcm92aWRlIGFueSBhcGlTdGF0ZUtleXMuIFRodXMsIHdlIHNheSB0aGF0IG5lc3RlZFxuICAgKiBzdGF0ZSBvYmplY3RzIGFyZSBcIm9wdCBvdXRcIiBmb3IgdGhpcyBiZWhhdmlvciwgc2luY2UgeW91IGNvdWxkIHJlbW92ZSB0aGUgbWluL21heCBrZXlzIGZyb20gdGhlIGFib3ZlIGV4YW1wbGUgaWZcbiAgICogeW91IHByb3ZpZGVkIGFwaVN0YXRlS2V5czpbXSwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvZiBcIm51bGxcIi5cbiAgICpcbiAgICogTk9URSEgVGhlc2UgYXJlIHN0aWxsIGp1c3QgdmFsdWVzISBUaGV5IHdpbGwgc3RpbGwgYmUgc2V0IGZvciBzdGF0ZSwgYW5kIGl0IGRvZXNuJ3QgZXhjbHVkZSB5b3UgZnJvbSBhbnkgc3RhdGUtbGlrZVxuICAgKiBiZWhhdmlvci4gVGhpcyBvcHRpb24gZG9lc24ndCBjaGFuZ2UgYW55dGhpbmcgZm9yIHN0YXRlLXNldHRpbmcsIGp1c3QgZm9yIHRoZSBsb2dpYyBvZiBBUEkgY29tcGFyaXNvbi9jb21wYXRpYmlsaXR5XG4gICAqIGNoZWNraW5nLlxuICAgKlxuICAgKiBTb2x1dGlvbiBkZXZlbG9wZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE5NTFcbiAgICovXG4gIGFwaVN0YXRlS2V5cz86IEFQSVN0YXRlS2V5cyB8IG51bGw7XG5cbiAgLy8gU2VyaWFsaXplIHRoZSBjb3JlIG9iamVjdC4gTW9zdCBvZnRlbiB0aGlzIGxvb2tzIGxpa2UgYW4gb2JqZWN0IGxpdGVyYWwgdGhhdCBob2xkcyBkYXRhIGFib3V0IHRoZSBQaGV0aW9PYmplY3RcbiAgLy8gaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IHN1cGVyZmx1b3VzIHRvIGp1c3QgcHJvdmlkaW5nIGEgc3RhdGVTY2hlbWEgb2YgY29tcG9zaXRlIGtleS9JT1R5cGUgdmFsdWVzLCB3aGljaCB3aWxsXG4gIC8vIGNyZWF0ZSBhIGRlZmF1bHQgdG9TdGF0ZU9iamVjdCBiYXNlZCBvbiB0aGUgc2NoZW1hLlxuICB0b1N0YXRlT2JqZWN0PzogKCAoIHQ6IFQgKSA9PiBTdGF0ZVR5cGUgKSB8IG51bGw7XG5cbiAgLy8gKioqKioqKiogREVTRVJJQUxJWkFUSU9OICoqKioqKioqIC8vXG5cbiAgLy8gRm9yIERhdGEgVHlwZSBEZXNlcmlhbGl6YXRpb24uIERlY29kZXMgdGhlIG9iamVjdCBmcm9tIGEgc3RhdGUgKHNlZSB0b1N0YXRlT2JqZWN0KSBpbnRvIGFuIGluc3RhbmNlIG9mIHRoZSBjb3JlIHR5cGUuXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9ibG9iL21haW4vZG9jL3BoZXQtaW8taW5zdHJ1bWVudGF0aW9uLXRlY2huaWNhbC1ndWlkZS5tZCN0aHJlZS10eXBlcy1vZi1kZXNlcmlhbGl6YXRpb25cbiAgZnJvbVN0YXRlT2JqZWN0PzogKCAoIHM6IFN0YXRlVHlwZSApID0+IFQgKSB8IG51bGw7XG5cbiAgLy8gRm9yIER5bmFtaWMgRWxlbWVudCBEZXNlcmlhbGl6YXRpb246IGNvbnZlcnRzIHRoZSBzdGF0ZSBvYmplY3QgdG8gYXJndW1lbnRzXG4gIC8vIGZvciBhIGBjcmVhdGVgIGZ1bmN0aW9uIGluIFBoZXRpb0dyb3VwIG9yIG90aGVyIFBoZXRpb0R5bmFtaWNFbGVtZW50Q29udGFpbmVyIGNyZWF0aW9uIGZ1bmN0aW9uLiBOb3RlIHRoYXRcbiAgLy8gb3RoZXIgbm9uLXNlcmlhbGl6ZWQgYXJncyAobm90IGRlYWx0IHdpdGggaGVyZSkgbWF5IGJlIHN1cHBsaWVkIGFzIGNsb3N1cmUgdmFyaWFibGVzLiBUaGlzIGZ1bmN0aW9uIG9ubHkgbmVlZHNcbiAgLy8gdG8gYmUgaW1wbGVtZW50ZWQgb24gSU9UeXBlcyB3aG9zZSBjb3JlIHR5cGUgaXMgcGhldGlvRHluYW1pY0VsZW1lbnQ6IHRydWUsIHN1Y2ggYXMgUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXJcbiAgLy8gZWxlbWVudHMuXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9ibG9iL21haW4vZG9jL3BoZXQtaW8taW5zdHJ1bWVudGF0aW9uLXRlY2huaWNhbC1ndWlkZS5tZCN0aHJlZS10eXBlcy1vZi1kZXNlcmlhbGl6YXRpb25cbiAgc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHM/OiAoICggczogU3RhdGVUeXBlICkgPT4gdW5rbm93bltdICkgfCBudWxsO1xuXG4gIC8vIEZvciBSZWZlcmVuY2UgVHlwZSBEZXNlcmlhbGl6YXRpb246ICBBcHBsaWVzIHRoZSBzdGF0ZSAoc2VlIHRvU3RhdGVPYmplY3QpXG4gIC8vIHZhbHVlIHRvIHRoZSBpbnN0YW5jZS4gV2hlbiBzZXR0aW5nIFBoRVQtaU8gc3RhdGUsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gYW4gaW5zdHJ1bWVudGVkIGluc3RhbmNlIHRvIHNldCB0aGVcbiAgLy8gc3RhdGVPYmplY3QncyB2YWx1ZSB0byBpdC4gU3RhdGVTY2hlbWEgbWFrZXMgdGhpcyBtZXRob2Qgb2Z0ZW4gc3VwZXJmbHVvdXMuIEEgY29tcG9zaXRlIHN0YXRlU2NoZW1hIGNhbiBiZSB1c2VkXG4gIC8vIHRvIGF1dG9tYXRpY2FsbHkgZm9ybXVsYXRlIHRoZSBhcHBseVN0YXRlIGZ1bmN0aW9uLiBJZiB1c2luZyBzdGF0ZVNjaGVtYSBmb3IgdGhlIGFwcGx5U3RhdGUgbWV0aG9kLCBtYWtlIHN1cmUgdGhhdFxuICAvLyBlYWNoIGNvbXBvc2UgSU9UeXBlIGhhcyB0aGUgY29ycmVjdCBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kLiBNb3N0IG9mIHRoZSB0aW1lLCBjb21wb3NpdGUgSU9UeXBlcyB1c2UgZnJvbVN0YXRlT2JqZWN0XG4gIC8vIHRvIGRlc2VyaWFsaXplIGVhY2ggc3ViLWNvbXBvbmVudCwgYnV0IGluIHNvbWUgY2lyY3Vtc3RhbmNlcywgeW91IHdpbGwgd2FudCB5b3VyIGNoaWxkIHRvIGRlc2VyaWFsaXplIGJ5IGFsc28gdXNpbmcgYXBwbHlTdGF0ZS5cbiAgLy8gU2VlIG9wdGlvbnMuZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZCB0byBjb25maWd1cmUgdGhpcyBjYXNlLlxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vYmxvYi9tYWluL2RvYy9waGV0LWlvLWluc3RydW1lbnRhdGlvbi10ZWNobmljYWwtZ3VpZGUubWQjdGhyZWUtdHlwZXMtb2YtZGVzZXJpYWxpemF0aW9uXG4gIGFwcGx5U3RhdGU/OiAoICggdDogVCwgc3RhdGU6IFN0YXRlVHlwZSApID0+IHZvaWQgKSB8IG51bGw7XG5cbiAgLy8gRm9yIHVzZSB3aGVuIHRoaXMgSU9UeXBlIGlzIHBhcnQgb2YgYSBjb21wb3NpdGUgc3RhdGVTY2hlbWEgaW4gYW5vdGhlciBJT1R5cGUuICBXaGVuXG4gIC8vIHVzaW5nIHNlcmlhbGl6YXRpb24gbWV0aG9kcyBieSBzdXBwbHlpbmcgb25seSBzdGF0ZVNjaGVtYSwgdGhlbiBkZXNlcmlhbGl6YXRpb25cbiAgLy8gY2FuIHRha2UgYSB2YXJpZXR5IG9mIGZvcm1zLCBhbmQgdGhpcyB3aWxsIHZhcnkgYmFzZWQgb24gdGhlIElPVHlwZS4gSW4gbW9zdCBjYXNlcyBkZXNlcmlhbGl6YXRpb24gb2YgYSBjb21wb25lbnRcbiAgLy8gaXMgZG9uZSB2aWEgZnJvbVN0YXRlT2JqZWN0LiBJZiBub3QsIHNwZWNpZnkgdGhpcyBvcHRpb24gc28gdGhhdCB0aGUgc3RhdGVTY2hlbWEgd2lsbCBiZSBhYmxlIHRvIGtub3cgdG8gY2FsbFxuICAvLyB0aGUgYXBwcm9wcmlhdGUgZGVzZXJpYWxpemF0aW9uIG1ldGhvZCB3aGVuIGRlc2VyaWFsaXppbmcgc29tZXRoaW5nIG9mIHRoaXMgSU9UeXBlLlxuICBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kPzogRGVzZXJpYWxpemF0aW9uVHlwZTtcblxuICAvLyBGb3IgZHluYW1pYyBlbGVtZW50IGNvbnRhaW5lcnMsIHNlZSBleGFtcGxlcyBpbiBJT1R5cGVzIGZvciBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBjbGFzc2VzXG4gIGFkZENoaWxkRWxlbWVudD86IEFkZENoaWxkRWxlbWVudDtcbn07XG5cbnR5cGUgSU9UeXBlT3B0aW9uczxULCBTdGF0ZVR5cGUgZXh0ZW5kcyBTZWxmU3RhdGVUeXBlLCBTZWxmU3RhdGVUeXBlPiA9IFNlbGZPcHRpb25zPFQsIFN0YXRlVHlwZSwgU2VsZlN0YXRlVHlwZT4gJiBWYWxpZGF0b3I8VD47XG5cbi8vIFN0YXRlVHlwZSBpcyB0aGUgd2hvbGUgdGhpbmcsIFNlbGZTdGF0ZVR5cGUgaXMganVzdCBhdCB0aGlzIGxldmVsXG4vLyBleHBvcnQgZGVmYXVsdCBjbGFzcyBJT1R5cGU8VCA9IGFueSwgU2VsZlN0YXRlVHlwZSA9IGFueSwgUGFyZW50U3RhdGVUeXBlID0gRW1wdHlQYXJlbnQsIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUgJiBQYXJlbnRTdGF0ZVR5cGUgPSBTZWxmU3RhdGVUeXBlICYgUGFyZW50U3RhdGVUeXBlPiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9UeXBlPFQgPSBhbnksIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUgPSBhbnksIFNlbGZTdGF0ZVR5cGUgPSBTdGF0ZVR5cGU+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIC8vIFNlZSBkb2N1bWVudGF0aW9uIGluIG9wdGlvbnMgdHlwZSBkZWNsYXJhdGlvblxuICBwdWJsaWMgcmVhZG9ubHkgc3VwZXJ0eXBlPzogSU9UeXBlO1xuICBwdWJsaWMgcmVhZG9ubHkgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IG1ldGhvZHM/OiBSZWNvcmQ8c3RyaW5nLCBJT1R5cGVNZXRob2Q+O1xuICBwdWJsaWMgcmVhZG9ubHkgZXZlbnRzOiBzdHJpbmdbXTtcbiAgcHVibGljIHJlYWRvbmx5IG1ldGFkYXRhRGVmYXVsdHM/OiBQYXJ0aWFsPFBoZXRpb0VsZW1lbnRNZXRhZGF0YT47XG4gIHB1YmxpYyByZWFkb25seSBkYXRhRGVmYXVsdHM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgcHVibGljIHJlYWRvbmx5IG1ldGhvZE9yZGVyPzogc3RyaW5nW107XG4gIHB1YmxpYyByZWFkb25seSBwYXJhbWV0ZXJUeXBlcz86IElPVHlwZVtdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgdG9TdGF0ZU9iamVjdE9wdGlvbjogKCAoIHQ6IFQgKSA9PiBTdGF0ZVR5cGUgKSB8IG51bGw7XG4gIHB1YmxpYyByZWFkb25seSBmcm9tU3RhdGVPYmplY3RPcHRpb246ICggKCBzdGF0ZTogU3RhdGVUeXBlICkgPT4gVCApIHwgbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBhcHBseVN0YXRlT3B0aW9uOiAoICggdDogVCwgc3RhdGU6IFN0YXRlVHlwZSApID0+IHZvaWQgKSB8IG51bGw7XG5cbiAgLy8gVE9ETzogaW5zdGVhZCBvZiB1bmtub3duIHRoaXMgaXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdHlwZSBmb3IgUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXIuIEhvdz8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3RhbmRlbS9pc3N1ZXMvMjYxXG4gIHB1YmxpYyByZWFkb25seSBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50c09wdGlvbjogKCAoIHM6IFN0YXRlVHlwZSApID0+IHVua25vd25bXSApIHwgbnVsbDtcblxuICBwdWJsaWMgcmVhZG9ubHkgYWRkQ2hpbGRFbGVtZW50OiBBZGRDaGlsZEVsZW1lbnQ7XG4gIHB1YmxpYyByZWFkb25seSB2YWxpZGF0b3I6IFZhbGlkYXRvcjxUPjtcbiAgcHVibGljIHJlYWRvbmx5IGRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2Q6IERlc2VyaWFsaXphdGlvblR5cGU7XG4gIHB1YmxpYyByZWFkb25seSBpc0Z1bmN0aW9uVHlwZTogYm9vbGVhbjtcblxuICAvLyBUaGUgU3RhdGVTY2hlbWEgKHR5cGUpIHRoYXQgdGhlIG9wdGlvbiBpcyBtYWRlIGludG8uIFRoZSBvcHRpb24gaXMgbW9yZSBmbGV4aWJsZSB0aGFuIHRoZSBjbGFzcy5cbiAgcHVibGljIHJlYWRvbmx5IHN0YXRlU2NoZW1hOiBTdGF0ZVNjaGVtYTxULCBTZWxmU3RhdGVUeXBlPiB8IG51bGw7XG5cbiAgLy8gVGhlIGJhc2UgSU9UeXBlIGZvciB0aGUgZW50aXJlIGhpZXJhcmNoeS5cbiAgcHVibGljIHN0YXRpYyBPYmplY3RJTzogSU9UeXBlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgdG9TdGF0ZU9iamVjdFN1cHBsaWVkOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YXRlU2NoZW1hU3VwcGxpZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgYXBwbHlTdGF0ZVN1cHBsaWVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gdHlwZU5hbWUgLSBUaGUgbmFtZSB0aGF0IHRoaXMgSU9UeXBlIHdpbGwgaGF2ZSBpbiB0aGUgcHVibGljIFBoRVQtaU8gQVBJLiBJbiBnZW5lcmFsLCB0aGlzIHNob3VsZFxuICAgKiAgICBvbmx5IGJlIHdvcmQgY2hhcmFjdGVycywgZW5kaW5nIGluIFwiSU9cIi4gUGFyYW1ldHJpYyB0eXBlcyBhcmUgYSBzcGVjaWFsIHN1YnNldCBvZiBJT1R5cGVzIHRoYXQgaW5jbHVkZSB0aGVpclxuICAgKiAgICBwYXJhbWV0ZXJzIGluIHRoZWlyIHR5cGVOYW1lLiBJZiBhbiBJT1R5cGUncyBwYXJhbWV0ZXJzIGFyZSBvdGhlciBJT1R5cGUocyksIHRoZW4gdGhleSBzaG91bGQgYmUgaW5jbHVkZWQgd2l0aGluXG4gICAqICAgIGFuZ2xlIGJyYWNrZXRzLCBsaWtlIFwiUHJvcGVydHlJTzxCb29sZWFuSU8+XCIuIFNvbWUgb3RoZXIgdHlwZXMgdXNlIGEgbW9yZSBjdXN0b20gZm9ybWF0IGZvciBkaXNwbGF5aW5nIHRoZWlyXG4gICAqICAgIHBhcmFtZXRlciB0eXBlcywgaW4gdGhpcyBjYXNlIHRoZSBwYXJhbWV0ZXIgc2VjdGlvbiBvZiB0aGUgdHlwZSBuYW1lIChpbW1lZGlhdGVseSBmb2xsb3dpbmcgXCJJT1wiKSBzaG91bGQgYmVnaW5cbiAgICogICAgd2l0aCBhbiBvcGVuIHBhcmVuLCBcIihcIi4gVGh1cyB0aGUgc2NoZW1hIGZvciBhIHR5cGVOYW1lIGNvdWxkIGJlIGRlZmluZWQgKHVzaW5nIHJlZ2V4KSBhcyBgW0EtWl1cXHcqSU8oWyg8XS4qKXswLDF9YC5cbiAgICogICAgUGFyYW1ldGVyaXplZCB0eXBlcyBzaG91bGQgYWxzbyBpbmNsdWRlIGEgYHBhcmFtZXRlclR5cGVzYCBmaWVsZCBvbiB0aGUgSU9UeXBlLlxuICAgKiBAcGFyYW0gcHJvdmlkZWRPcHRpb25zXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoIHB1YmxpYyByZWFkb25seSB0eXBlTmFtZTogSU9UeXBlTmFtZSwgcHJvdmlkZWRPcHRpb25zOiBJT1R5cGVPcHRpb25zPFQsIFN0YXRlVHlwZSwgU2VsZlN0YXRlVHlwZT4gKSB7XG5cbiAgICAvLyBGb3IgcmVmZXJlbmNlIGluIHRoZSBvcHRpb25zXG4gICAgY29uc3Qgc3VwZXJ0eXBlID0gcHJvdmlkZWRPcHRpb25zLnN1cGVydHlwZSB8fCBJT1R5cGUuT2JqZWN0SU87XG4gICAgY29uc3QgdG9TdGF0ZU9iamVjdFN1cHBsaWVkID0gISEoIHByb3ZpZGVkT3B0aW9ucy50b1N0YXRlT2JqZWN0ICk7XG4gICAgY29uc3QgYXBwbHlTdGF0ZVN1cHBsaWVkID0gISEoIHByb3ZpZGVkT3B0aW9ucy5hcHBseVN0YXRlICk7XG4gICAgY29uc3Qgc3RhdGVTY2hlbWFTdXBwbGllZCA9ICEhKCBwcm92aWRlZE9wdGlvbnMuc3RhdGVTY2hlbWEgKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8SU9UeXBlT3B0aW9uczxULCBTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+LCBTZWxmT3B0aW9uczxULCBTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+PigpKCB7XG5cbiAgICAgIHN1cGVydHlwZTogSU9UeXBlLk9iamVjdElPLFxuICAgICAgbWV0aG9kczoge30sXG4gICAgICBldmVudHM6IFtdLFxuICAgICAgbWV0YWRhdGFEZWZhdWx0czoge30sXG5cbiAgICAgIC8vICBNb3N0IGxpa2VseSB0aGlzIHdpbGwgcmVtYWluIFBoRVQtaU8gaW50ZXJuYWwsIGFuZCBzaG91bGRuJ3QgbmVlZCB0byBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgSU9UeXBlcyBvdXRzaWRlIG9mIHRhbmRlbS8uXG4gICAgICBkYXRhRGVmYXVsdHM6IHt9LFxuICAgICAgbWV0aG9kT3JkZXI6IFtdLFxuICAgICAgcGFyYW1ldGVyVHlwZXM6IFtdLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFBoRVQtaU8gVHlwZSBmb3IgJHtnZXRDb3JlVHlwZU5hbWUoIHR5cGVOYW1lICl9YCxcbiAgICAgIGlzRnVuY3Rpb25UeXBlOiBmYWxzZSxcblxuICAgICAgLyoqKiogU1RBVEUgKioqKi9cblxuICAgICAgdG9TdGF0ZU9iamVjdDogbnVsbCxcbiAgICAgIGZyb21TdGF0ZU9iamVjdDogbnVsbCxcbiAgICAgIHN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzOiBudWxsLFxuICAgICAgYXBwbHlTdGF0ZTogbnVsbCxcblxuICAgICAgc3RhdGVTY2hlbWE6IG51bGwsXG4gICAgICBhcGlTdGF0ZUtleXM6IG51bGwsXG4gICAgICBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kOiAnZnJvbVN0YXRlT2JqZWN0JyxcbiAgICAgIGFkZENoaWxkRWxlbWVudDogc3VwZXJ0eXBlICYmIHN1cGVydHlwZS5hZGRDaGlsZEVsZW1lbnRcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIGlmICggYXNzZXJ0ICYmIHN1cGVydHlwZSApIHtcbiAgICAgICggT2JqZWN0LmtleXMoIG9wdGlvbnMubWV0YWRhdGFEZWZhdWx0cyApIGFzICgga2V5b2YgUGhldGlvRWxlbWVudE1ldGFkYXRhIClbXSApLmZvckVhY2goIG1ldGFkYXRhRGVmYXVsdEtleSA9PiB7XG4gICAgICAgIGFzc2VydCAmJiBzdXBlcnR5cGUuZ2V0QWxsTWV0YWRhdGFEZWZhdWx0cygpLmhhc093blByb3BlcnR5KCBtZXRhZGF0YURlZmF1bHRLZXkgKSAmJlxuICAgICAgICBhc3NlcnQoIHN1cGVydHlwZS5nZXRBbGxNZXRhZGF0YURlZmF1bHRzKClbIG1ldGFkYXRhRGVmYXVsdEtleSBdICE9PSBvcHRpb25zLm1ldGFkYXRhRGVmYXVsdHNbIG1ldGFkYXRhRGVmYXVsdEtleSBdLFxuICAgICAgICAgIGAke21ldGFkYXRhRGVmYXVsdEtleX0gc2hvdWxkIG5vdCBoYXZlIHRoZSBzYW1lIGRlZmF1bHQgdmFsdWUgYXMgdGhlIGFuY2VzdG9yIG1ldGFkYXRhIGRlZmF1bHQuYCApO1xuICAgICAgfSApO1xuICAgIH1cbiAgICB0aGlzLnN1cGVydHlwZSA9IHN1cGVydHlwZTtcbiAgICB0aGlzLmRvY3VtZW50YXRpb24gPSBvcHRpb25zLmRvY3VtZW50YXRpb247XG4gICAgdGhpcy5tZXRob2RzID0gb3B0aW9ucy5tZXRob2RzO1xuICAgIHRoaXMuZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG4gICAgdGhpcy5tZXRhZGF0YURlZmF1bHRzID0gb3B0aW9ucy5tZXRhZGF0YURlZmF1bHRzO1xuICAgIHRoaXMuZGF0YURlZmF1bHRzID0gb3B0aW9ucy5kYXRhRGVmYXVsdHM7XG4gICAgdGhpcy5tZXRob2RPcmRlciA9IG9wdGlvbnMubWV0aG9kT3JkZXI7XG4gICAgdGhpcy5wYXJhbWV0ZXJUeXBlcyA9IG9wdGlvbnMucGFyYW1ldGVyVHlwZXM7XG5cbiAgICAvLyBWYWxpZGF0aW9uXG4gICAgdGhpcy52YWxpZGF0b3IgPSBfLnBpY2soIG9wdGlvbnMsIFZhbGlkYXRpb24uVkFMSURBVE9SX0tFWVMgKTtcbiAgICB0aGlzLnZhbGlkYXRvci52YWxpZGF0aW9uTWVzc2FnZSA9IHRoaXMudmFsaWRhdG9yLnZhbGlkYXRpb25NZXNzYWdlIHx8IGBWYWxpZGF0aW9uIGZhaWxlZCBJT1R5cGUgVmFsaWRhdG9yOiAke3RoaXMudHlwZU5hbWV9YDtcblxuICAgIHRoaXMuZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZCA9IG9wdGlvbnMuZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZDtcblxuICAgIGlmICggb3B0aW9ucy5zdGF0ZVNjaGVtYSA9PT0gbnVsbCB8fCBvcHRpb25zLnN0YXRlU2NoZW1hIGluc3RhbmNlb2YgU3RhdGVTY2hlbWEgKSB7XG4gICAgICB0aGlzLnN0YXRlU2NoZW1hID0gb3B0aW9ucy5zdGF0ZVNjaGVtYSBhcyAoIG51bGwgfCBTdGF0ZVNjaGVtYTxULCBTZWxmU3RhdGVUeXBlPiApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVNjaGVtYSA9IHR5cGVvZiBvcHRpb25zLnN0YXRlU2NoZW1hID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zdGF0ZVNjaGVtYSggdGhpcyApIDogb3B0aW9ucy5zdGF0ZVNjaGVtYTtcblxuICAgICAgdGhpcy5zdGF0ZVNjaGVtYSA9IG5ldyBTdGF0ZVNjaGVtYTxULCBTZWxmU3RhdGVUeXBlPigge1xuICAgICAgICBjb21wb3NpdGVTY2hlbWE6IGNvbXBvc2l0ZVNjaGVtYSxcbiAgICAgICAgYXBpU3RhdGVLZXlzOiBvcHRpb25zLmFwaVN0YXRlS2V5c1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIC8vIEFzc2VydCB0aGF0IHRvU3RhdGVPYmplY3QgbWV0aG9kIGlzIHByb3ZpZGVkIGZvciB2YWx1ZSBTdGF0ZVNjaGVtYXMuIERvIHRoaXMgd2l0aCB0aGUgZm9sbG93aW5nIGxvZ2ljOlxuICAgIC8vIDEuIEl0IGlzIGFjY2VwdGFibGUgdG8gbm90IHByb3ZpZGUgYSBzdGF0ZVNjaGVtYSAoZm9yIElPVHlwZXMgdGhhdCBhcmVuJ3Qgc3RhdGVmdWwpXG4gICAgLy8gMi4gWW91IG11c3QgZWl0aGVyIHByb3ZpZGUgYSB0b1N0YXRlT2JqZWN0LCBvciBoYXZlIGEgY29tcG9zaXRlIFN0YXRlU2NoZW1hLiBDb21wb3NpdGUgc3RhdGUgc2NoZW1hcyBzdXBwb3J0IGRlZmF1bHQgc2VyaWFsaXphdGlvbiBtZXRob2RzLlxuICAgIGFzc2VydCAmJiBhc3NlcnQoICF0aGlzLnN0YXRlU2NoZW1hIHx8ICggdG9TdGF0ZU9iamVjdFN1cHBsaWVkIHx8IHRoaXMuc3RhdGVTY2hlbWEuaXNDb21wb3NpdGUoKSApLFxuICAgICAgJ3RvU3RhdGVPYmplY3QgbWV0aG9kIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZhbHVlIFN0YXRlU2NoZW1hcycgKTtcblxuICAgIHRoaXMudG9TdGF0ZU9iamVjdE9wdGlvbiA9IG9wdGlvbnMudG9TdGF0ZU9iamVjdDtcbiAgICB0aGlzLmZyb21TdGF0ZU9iamVjdE9wdGlvbiA9IG9wdGlvbnMuZnJvbVN0YXRlT2JqZWN0O1xuICAgIHRoaXMuYXBwbHlTdGF0ZU9wdGlvbiA9IG9wdGlvbnMuYXBwbHlTdGF0ZTtcbiAgICB0aGlzLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzT3B0aW9uID0gb3B0aW9ucy5zdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cztcblxuICAgIHRoaXMudG9TdGF0ZU9iamVjdFN1cHBsaWVkID0gdG9TdGF0ZU9iamVjdFN1cHBsaWVkO1xuICAgIHRoaXMuYXBwbHlTdGF0ZVN1cHBsaWVkID0gYXBwbHlTdGF0ZVN1cHBsaWVkO1xuICAgIHRoaXMuc3RhdGVTY2hlbWFTdXBwbGllZCA9IHN0YXRlU2NoZW1hU3VwcGxpZWQ7XG4gICAgdGhpcy5pc0Z1bmN0aW9uVHlwZSA9IG9wdGlvbnMuaXNGdW5jdGlvblR5cGU7XG4gICAgdGhpcy5hZGRDaGlsZEVsZW1lbnQgPSBvcHRpb25zLmFkZENoaWxkRWxlbWVudDtcblxuICAgIGlmICggYXNzZXJ0ICkge1xuXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBzdXBlcnR5cGUgfHwgdGhpcy50eXBlTmFtZSA9PT0gJ09iamVjdElPJywgJ3N1cGVydHlwZSBpcyByZXF1aXJlZCcgKTtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoICF0aGlzLnR5cGVOYW1lLmluY2x1ZGVzKCAnLicgKSwgJ0RvdHMgc2hvdWxkIG5vdCBhcHBlYXIgaW4gdHlwZSBuYW1lcycgKTtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMudHlwZU5hbWUuc3BsaXQoIC9bPChdLyApWyAwIF0uZW5kc1dpdGgoIFBoZXRpb0NvbnN0YW50cy5JT19UWVBFX1NVRkZJWCApLCBgSU9UeXBlIG5hbWUgbXVzdCBlbmQgd2l0aCAke1BoZXRpb0NvbnN0YW50cy5JT19UWVBFX1NVRkZJWH1gICk7XG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmhhc093blByb3BlcnR5KCAndHlwZU5hbWUnICksICd0aGlzLnR5cGVOYW1lIGlzIHJlcXVpcmVkJyApO1xuXG4gICAgICAvLyBhc3NlcnQgdGhhdCBlYWNoIHB1YmxpYyBtZXRob2QgYWRoZXJlcyB0byB0aGUgZXhwZWN0ZWQgc2NoZW1hXG4gICAgICB0aGlzLm1ldGhvZHMgJiYgT2JqZWN0LnZhbHVlcyggdGhpcy5tZXRob2RzICkuZm9yRWFjaCggKCBtZXRob2RPYmplY3Q6IElPVHlwZU1ldGhvZCApID0+IHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbWV0aG9kT2JqZWN0ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICBhc3NlcnQgJiYgbWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgJiYgYXNzZXJ0KCB0eXBlb2YgbWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgPT09ICdib29sZWFuJyxcbiAgICAgICAgICAgIGBpbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzIG11c3QgYmUgb2YgdHlwZSBib29sZWFuOiAke21ldGhvZE9iamVjdC5pbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzfWAgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5kb2N1bWVudGF0aW9uLmxlbmd0aCA+IDAsICdkb2N1bWVudGF0aW9uIG11c3QgYmUgcHJvdmlkZWQnICk7XG5cbiAgICAgIHRoaXMubWV0aG9kcyAmJiB0aGlzLmhhc093blByb3BlcnR5KCAnbWV0aG9kT3JkZXInICkgJiYgdGhpcy5tZXRob2RPcmRlci5mb3JFYWNoKCBtZXRob2ROYW1lID0+IHtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5tZXRob2RzIVsgbWV0aG9kTmFtZSBdLCBgbWV0aG9kTmFtZSBub3QgaW4gcHVibGljIG1ldGhvZHM6ICR7bWV0aG9kTmFtZX1gICk7XG4gICAgICB9ICk7XG5cbiAgICAgIGlmICggc3VwZXJ0eXBlICkge1xuICAgICAgICBjb25zdCB0eXBlSGllcmFyY2h5ID0gc3VwZXJ0eXBlLmdldFR5cGVIaWVyYXJjaHkoKTtcbiAgICAgICAgYXNzZXJ0ICYmIHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzLmZvckVhY2goIGV2ZW50ID0+IHtcblxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBldmVudHMgYXJlIG5vdCBsaXN0ZWQgYWdhaW5cbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhXy5zb21lKCB0eXBlSGllcmFyY2h5LCB0ID0+IHQuZXZlbnRzLmluY2x1ZGVzKCBldmVudCApICksIGBJT1R5cGUgc2hvdWxkIG5vdCBkZWNsYXJlIGV2ZW50IHRoYXQgcGFyZW50IGFsc28gaGFzOiAke2V2ZW50fWAgKTtcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmICggdGhpcy5zdGF0ZVNjaGVtYT8uYXBpU3RhdGVLZXlzICkge1xuICAgICAgICAgIGNvbnN0IHN1cGVydHlwZUFQSUtleXMgPSBzdXBlcnR5cGUuZ2V0QWxsQVBJU3RhdGVLZXlzKCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZVNjaGVtYT8uYXBpU3RhdGVLZXlzLmZvckVhY2goIGFwaVN0YXRlS2V5ID0+IHtcbiAgICAgICAgICAgIGFzc2VydCAmJiBhc3NlcnQoICFzdXBlcnR5cGVBUElLZXlzLmluY2x1ZGVzKCBhcGlTdGF0ZUtleSApLCBgYXBpU3RhdGVLZXkgaXMgYWxyZWFkeSBpbiB0aGUgc3VwZXI6ICR7YXBpU3RhdGVLZXl9YCApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgLy8gVGhlIHJvb3QgSU9UeXBlIG11c3Qgc3VwcGx5IGFsbCA0IHN0YXRlIG1ldGhvZHMuXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLnRvU3RhdGVPYmplY3QgPT09ICdmdW5jdGlvbicsICd0b1N0YXRlT2JqZWN0IG11c3QgYmUgZGVmaW5lZCcgKTtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIG9wdGlvbnMuZnJvbVN0YXRlT2JqZWN0ID09PSAnZnVuY3Rpb24nLCAnZnJvbVN0YXRlT2JqZWN0IG11c3QgYmUgZGVmaW5lZCcgKTtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIG9wdGlvbnMuc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHMgPT09ICdmdW5jdGlvbicsICdzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyBtdXN0IGJlIGRlZmluZWQnICk7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLmFwcGx5U3RhdGUgPT09ICdmdW5jdGlvbicsICdhcHBseVN0YXRlIG11c3QgYmUgZGVmaW5lZCcgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdG9TdGF0ZU9iamVjdCggY29yZU9iamVjdDogVCApOiBTdGF0ZVR5cGUge1xuICAgIEFQSV9TVEFURV9ORVNURURfQ09VTlQrKztcbiAgICAvLyB2YWxpZGF0ZSggY29yZU9iamVjdCwgdGhpcy52YWxpZGF0b3IsIFZBTElEQVRFX09QVElPTlNfRkFMU0UgKTtcblxuICAgIGxldCBzdGF0ZU9iamVjdDtcblxuICAgIC8vIE9ubHkgZG8gdGhpcyBub24tc3RhbmRhcmQgdG9TdGF0ZU9iamVjdCBmdW5jdGlvbiBpZiB0aGVyZSBpcyBhIHN0YXRlU2NoZW1hIGJ1dCBubyB0b1N0YXRlT2JqZWN0IHByb3ZpZGVkXG4gICAgaWYgKCAhdGhpcy50b1N0YXRlT2JqZWN0U3VwcGxpZWQgJiYgdGhpcy5zdGF0ZVNjaGVtYVN1cHBsaWVkICYmIHRoaXMuc3RhdGVTY2hlbWEgJiYgdGhpcy5zdGF0ZVNjaGVtYS5pc0NvbXBvc2l0ZSgpICkge1xuICAgICAgc3RhdGVPYmplY3QgPSB0aGlzLmRlZmF1bHRUb1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0ICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXNzZXJ0ICYmICF0aGlzLnRvU3RhdGVPYmplY3RPcHRpb24gJiYgYXNzZXJ0KCB0aGlzLnN1cGVydHlwZSxcbiAgICAgICAgJ3N1cGVydHlwZSBleHBlY3RlZCBpZiBubyB0b1N0YXRlT2JqZWN0IG9wdGlvbiBpcyBwcm92aWRlZCcgKTtcbiAgICAgIHN0YXRlT2JqZWN0ID0gdGhpcy50b1N0YXRlT2JqZWN0T3B0aW9uID8gdGhpcy50b1N0YXRlT2JqZWN0T3B0aW9uKCBjb3JlT2JqZWN0ICkgOiB0aGlzLnN1cGVydHlwZSEudG9TdGF0ZU9iamVjdCggY29yZU9iamVjdCApO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCB2YWxpZGF0ZSB0aGUgYXBpIHN0YXRlLCB3aGljaCBnZXQncyBwcnVuZWQgYmFzZWQgb24gcHJvdmlkZWQgYXBpU3RhdGVLZXlzLCBvbmx5IHZhbGlkYXRlIHRoZSBjb21wbGV0ZSBzdGF0ZVxuICAgIGlmICggYXNzZXJ0ICYmICFHRVRUSU5HX1NUQVRFX0ZPUl9BUEkgJiZcblxuICAgICAgICAgLy8gb25seSBpZiB0aGlzIElPVHlwZSBpbnN0YW5jZSBoYXMgbW9yZSB0byB2YWxpZGF0ZSB0aGFuIHRoZSBzdXBlcnR5cGVcbiAgICAgICAgICggdGhpcy50b1N0YXRlT2JqZWN0U3VwcGxpZWQgfHwgdGhpcy5zdGF0ZVNjaGVtYVN1cHBsaWVkICkgKSB7XG5cbiAgICAgIC8vIE9ubHkgdmFsaWRhdGUgdGhlIHN0YXRlT2JqZWN0IGlmIGl0IGlzIHBoZXRpb1N0YXRlOnRydWUuXG4gICAgICAvLyBUaGlzIGlzIGFuIG4qbSBhbGdvcml0aG0gYmVjYXVzZSBmb3IgZWFjaCB0aW1lIHRvU3RhdGVPYmplY3QgaXMgY2FsbGVkIGFuZCBuZWVkcyB2YWxpZGF0aW9uLCB0aGlzLnZhbGlkYXRlU3RhdGVPYmplY3RcbiAgICAgIC8vIGxvb2tzIGFsbCB0aGUgd2F5IHVwIHRoZSBJT1R5cGUgaGllcmFyY2h5LiBUaGlzIGlzIG5vdCBlZmZpY2llbnQsIGJ1dCBnYWlucyB1cyB0aGUgYWJpbGl0eSB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgLy8gdGhlIHN0YXRlT2JqZWN0IGRvZXNuJ3QgaGF2ZSBhbnkgc3VwZXJmbHVvdXMsIHVuZXhwZWN0ZWQga2V5cy4gVGhlIFwibVwiIHBvcnRpb24gaXMgYmFzZWQgb24gaG93IG1hbnkgc3ViLXByb3BlcnRpZXNcbiAgICAgIC8vIGluIGEgc3RhdGUgY2FsbCBgdG9TdGF0ZU9iamVjdGAsIGFuZCB0aGUgXCJuXCIgcG9ydGlvbiBpcyBiYXNlZCBvbiBob3cgbWFueSBJT1R5cGVzIGluIHRoZSBoaWVyYXJjaHkgZGVmaW5lIGFcbiAgICAgIC8vIHRvU3RhdGVPYmplY3Qgb3Igc3RhdGVTY2hlbWEuIEluIHRoZSBmdXR1cmUgd2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSBwZXJmb3JtYW5jZSBieSBoYXZpbmcgdmFsaWRhdGVTdGF0ZU9iamVjdFxuICAgICAgLy8gb25seSBjaGVjayBhZ2FpbnN0IHRoZSBzY2hlbWEgYXQgdGhpcyBsZXZlbCwgYnV0IHRoZW4gZXh0cmEga2V5cyBpbiB0aGUgc3RhdGVPYmplY3Qgd291bGQgbm90IGJlIGNhdWdodC4gRnJvbSB3b3JrIGRvbmUgaW4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE3NzRcbiAgICAgIHRoaXMudmFsaWRhdGVTdGF0ZU9iamVjdCggc3RhdGVPYmplY3QgKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZWRTdGF0ZU9iamVjdDogU3RhdGVUeXBlO1xuXG4gICAgLy8gV2hlbiBnZXR0aW5nIEFQSSBzdGF0ZSwgcHJ1bmUgb3V0IGFueSBzdGF0ZSB0aGF0IGRvbid0IG9wdCBpbiBhcyBkZXNpcmVkIGZvciBBUEkgdHJhY2tpbmcsIHNlZSBhcGlTdGF0ZUtleXNcbiAgICBpZiAoIEdFVFRJTkdfU1RBVEVfRk9SX0FQSSAmJiB0aGlzLmlzQ29tcG9zaXRlU3RhdGVTY2hlbWEoKSAmJlxuXG4gICAgICAgICAvLyBXaGVuIHJ1bm5pbmcgYSBuZXN0ZWQgdG9TdGF0ZU9iamVjdCBjYWxsIHdoaWxlIGdlbmVyYXRpbmcgYXBpIHN0YXRlLCB2YWx1ZXMgc2hvdWxkIGJlIG9wdCBpbiwgYmVjYXVzZSB0aGVcbiAgICAgICAgIC8vIGVsZW1lbnQgc3RhdGUgaGFzIGFza2VkIGZvciB0aGVzZSB2YWx1ZXMuIEZvciBleGFtcGxlIFByb3BlcnR5SU88UmFuZ2VJTz4gd2FudHMgdG8gc2VlIG1pbi9tYXggc3RhdGUgaW5cbiAgICAgICAgIC8vIGl0cyB2YWxpZFZhbHVlcy5cbiAgICAgICAgICEoIEFQSV9TVEFURV9ORVNURURfQ09VTlQgPiAxICYmIHRoaXMuYXBpU3RhdGVLZXlzUHJvdmlkZWQoKSApXG4gICAgKSB7XG4gICAgICByZXNvbHZlZFN0YXRlT2JqZWN0ID0gXy5waWNrKCBzdGF0ZU9iamVjdCwgdGhpcy5nZXRBbGxBUElTdGF0ZUtleXMoKSApIGFzIFN0YXRlVHlwZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXNvbHZlZFN0YXRlT2JqZWN0ID0gc3RhdGVPYmplY3Q7XG4gICAgfVxuICAgIEFQSV9TVEFURV9ORVNURURfQ09VTlQtLTtcbiAgICByZXR1cm4gcmVzb2x2ZWRTdGF0ZU9iamVjdDtcbiAgfVxuXG4gIHB1YmxpYyBmcm9tU3RhdGVPYmplY3QoIHN0YXRlT2JqZWN0OiBTdGF0ZVR5cGUgKTogVCB7XG4gICAgaWYgKCB0aGlzLmZyb21TdGF0ZU9iamVjdE9wdGlvbiApIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21TdGF0ZU9iamVjdE9wdGlvbiggc3RhdGVPYmplY3QgKTtcbiAgICB9XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5zdXBlcnR5cGUgKTtcbiAgICByZXR1cm4gdGhpcy5zdXBlcnR5cGUhLmZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3QgKTtcbiAgfVxuXG4gIHB1YmxpYyBhcHBseVN0YXRlKCBjb3JlT2JqZWN0OiBULCBzdGF0ZU9iamVjdDogU3RhdGVUeXBlICk6IHZvaWQge1xuICAgIHZhbGlkYXRlKCBjb3JlT2JqZWN0LCB0aGlzLnZhbGlkYXRvciwgVkFMSURBVEVfT1BUSU9OU19GQUxTRSApO1xuXG4gICAgLy8gVmFsaWRhdGUsIGJ1dCBvbmx5IGlmIHRoaXMgSU9UeXBlIGluc3RhbmNlIGhhcyBtb3JlIHRvIHZhbGlkYXRlIHRoYW4gdGhlIHN1cGVydHlwZVxuICAgIGlmICggdGhpcy5hcHBseVN0YXRlU3VwcGxpZWQgfHwgdGhpcy5zdGF0ZVNjaGVtYVN1cHBsaWVkICkge1xuXG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm92aWRlZCBzdGF0ZU9iamVjdCBpcyBvZiB0aGUgZXhwZWN0ZWQgc2NoZW1hXG4gICAgICAvLyBOT1RFOiBDYW5ub3QgdXNlIHRoaXMudmFsaWRhdGVTdGF0ZU9iamVjdCBiZWNhdXNlIG9wdGlvbnMgYWRvcHRzIHN1cGVydHlwZS5hcHBseVN0YXRlLCB3aGljaCBpcyBib3VuZHMgdG8gdGhlXG4gICAgICAvLyBwYXJlbnQgSU9UeXBlLiBUaGlzIHByZXZlbnRzIGNvcnJlY3QgdmFsaWRhdGlvbiBiZWNhdXNlIHRoZSBzdXBlcnR5cGUgZG9lc24ndCBrbm93IGFib3V0IHRoZSBzdWJ0eXBlIHNjaGVtYXMuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIGNhbm5vdCB0eXBlIGNoZWNrIGFnYWluc3QgUGhldGlvT2JqZWN0IGZyb20gdGhpcyBmaWxlXG4gICAgICBhc3NlcnQgJiYgY29yZU9iamVjdC5waGV0aW9UeXBlICYmIGNvcmVPYmplY3QucGhldGlvVHlwZS52YWxpZGF0ZVN0YXRlT2JqZWN0KCBzdGF0ZU9iamVjdCApO1xuICAgIH1cblxuICAgIC8vIE9ubHkgZG8gdGhpcyBub24tc3RhbmRhcmQgYXBwbHlTdGF0ZSBmdW5jdGlvbiBmcm9tIHN0YXRlU2NoZW1hIGlmIHRoZXJlIGlzIGEgc3RhdGVTY2hlbWEgYnV0IG5vIGFwcGx5U3RhdGUgcHJvdmlkZWRcbiAgICBpZiAoICF0aGlzLmFwcGx5U3RhdGVTdXBwbGllZCAmJiB0aGlzLnN0YXRlU2NoZW1hU3VwcGxpZWQgJiYgdGhpcy5zdGF0ZVNjaGVtYSAmJiB0aGlzLnN0YXRlU2NoZW1hLmlzQ29tcG9zaXRlKCkgKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCBhcyBDb21wb3NpdGVTdGF0ZU9iamVjdFR5cGUgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhc3NlcnQgJiYgIXRoaXMuYXBwbHlTdGF0ZU9wdGlvbiAmJiBhc3NlcnQoIHRoaXMuc3VwZXJ0eXBlLFxuICAgICAgICAnc3VwZXJ0eXBlIGV4cGVjdGVkIGlmIG5vIGFwcGx5U3RhdGUgb3B0aW9uIGlzIHByb3ZpZGVkJyApO1xuICAgICAgdGhpcy5hcHBseVN0YXRlT3B0aW9uID8gdGhpcy5hcHBseVN0YXRlT3B0aW9uKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCApIDogdGhpcy5zdXBlcnR5cGUhLmFwcGx5U3RhdGUoIGNvcmVPYmplY3QsIHN0YXRlT2JqZWN0ICk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzKCBzdGF0ZU9iamVjdDogU3RhdGVUeXBlICk6IHVua25vd25bXSB7XG4gICAgaWYgKCB0aGlzLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzT3B0aW9uICkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHNPcHRpb24oIHN0YXRlT2JqZWN0ICk7XG4gICAgfVxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuc3VwZXJ0eXBlICk7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXJ0eXBlIS5zdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyggc3RhdGVPYmplY3QgKTtcbiAgfVxuXG5cbiAgLy8gSW5jbHVkZSBzdGF0ZSBmcm9tIGFsbCBjb21wb3NpdGUgc3RhdGUgc2NoZW1hcyB1cCBhbmQgZG93biB0aGUgdHlwZSBoaWVyYXJjaHkgKGNoaWxkcmVuIG92ZXJyaWRpbmcgcGFyZW50cykuXG4gIHByaXZhdGUgZGVmYXVsdFRvU3RhdGVPYmplY3QoIGNvcmVPYmplY3Q6IFQgKTogU3RhdGVUeXBlIHtcblxuICAgIGxldCBzdXBlclN0YXRlT2JqZWN0OiBQYXJ0aWFsPFN0YXRlVHlwZT4gPSB7fTtcbiAgICBpZiAoIHRoaXMuc3VwZXJ0eXBlICkge1xuICAgICAgc3VwZXJTdGF0ZU9iamVjdCA9IHRoaXMuc3VwZXJ0eXBlLmRlZmF1bHRUb1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0ICk7XG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnN0YXRlU2NoZW1hICYmIHRoaXMuc3RhdGVTY2hlbWEuaXNDb21wb3NpdGUoKSApIHtcbiAgICAgIHJldHVybiBfLm1lcmdlKCBzdXBlclN0YXRlT2JqZWN0LCB0aGlzLnN0YXRlU2NoZW1hLmRlZmF1bHRUb1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0ICkgKSBhcyBTdGF0ZVR5cGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyU3RhdGVPYmplY3QgYXMgU3RhdGVUeXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluY2x1ZGUgc3RhdGUgZnJvbSBhbGwgY29tcG9zaXRlIHN0YXRlIHNjaGVtYXMgdXAgYW5kIGRvd24gdGhlIHR5cGUgaGllcmFyY2h5IChjaGlsZHJlbiBvdmVycmlkaW5nIHBhcmVudHMpLlxuICBwcml2YXRlIGRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0OiBULCBzdGF0ZU9iamVjdDogQ29tcG9zaXRlU3RhdGVPYmplY3RUeXBlICk6IHZvaWQge1xuXG4gICAgaWYgKCB0aGlzLnN1cGVydHlwZSApIHtcbiAgICAgIHRoaXMuc3VwZXJ0eXBlLmRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCApO1xuICAgIH1cblxuICAgIGlmICggdGhpcy5zdGF0ZVNjaGVtYSAmJiB0aGlzLnN0YXRlU2NoZW1hLmlzQ29tcG9zaXRlKCkgKSB7XG4gICAgICB0aGlzLnN0YXRlU2NoZW1hLmRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IG9mIElPVHlwZXMgb2YgdGhlIHNlbGYgdHlwZSBhbmQgYWxsIHRoZSBzdXBlcnR5cGUgYW5jZXN0b3JzLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRUeXBlSGllcmFyY2h5KCk6IElPVHlwZTxJbnRlbnRpb25hbEFueSwgSW50ZW50aW9uYWxBbnksIEludGVudGlvbmFsQW55PltdIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuXG4gICAgbGV0IGlvVHlwZTogSU9UeXBlID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgd2hpbGUgKCBpb1R5cGUgKSB7XG4gICAgICBhcnJheS5wdXNoKCBpb1R5cGUgKTtcbiAgICAgIGlvVHlwZSA9IGlvVHlwZS5zdXBlcnR5cGUhO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgSU9UeXBlIGlzIGEgc3VidHlwZSBvZiB0aGUgcGFzc2VkLWluIHR5cGUgKG9yIGlmIHRoZXkgYXJlIHRoZSBzYW1lKS5cbiAgICovXG4gIHB1YmxpYyBleHRlbmRzKCB0eXBlOiBJT1R5cGU8dW5rbm93biwgdW5rbm93bj4gKTogYm9vbGVhbiB7XG5cbiAgICAvLyBtZW1vcnktYmFzZWQgaW1wbGVtZW50YXRpb24gT0sgc2luY2UgdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGluIGFzc2VydGlvbnNcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlSGllcmFyY2h5KCkuaW5jbHVkZXMoIHR5cGUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHRoZSBtZXRhZGF0YSBkZWZhdWx0cyAoZm9yIHRoZSBlbnRpcmUgSU9UeXBlIGhpZXJhcmNoeSlcbiAgICovXG4gIHB1YmxpYyBnZXRBbGxNZXRhZGF0YURlZmF1bHRzKCk6IFBhcnRpYWw8UGhldGlvRWxlbWVudE1ldGFkYXRhPiB7XG4gICAgcmV0dXJuIF8ubWVyZ2UoIHt9LCB0aGlzLnN1cGVydHlwZSA/IHRoaXMuc3VwZXJ0eXBlLmdldEFsbE1ldGFkYXRhRGVmYXVsdHMoKSA6IHt9LCB0aGlzLm1ldGFkYXRhRGVmYXVsdHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHRoZSBkYXRhIGRlZmF1bHRzIChmb3IgdGhlIGVudGlyZSBJT1R5cGUgaGllcmFyY2h5KVxuICAgKi9cbiAgcHVibGljIGdldEFsbERhdGFEZWZhdWx0cygpOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gICAgcmV0dXJuIF8ubWVyZ2UoIHt9LCB0aGlzLnN1cGVydHlwZSA/IHRoaXMuc3VwZXJ0eXBlLmdldEFsbERhdGFEZWZhdWx0cygpIDoge30sIHRoaXMuZGF0YURlZmF1bHRzICk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBjYW5ub3QgYmUgaW4gc3RhdGVTY2hlbWEsIGJlY2F1c2Ugc29tZSBJT1R5cGVzIGRvIG5vdCBoYXZlIHN0YXRlU2NoZW1hIGluc3RhbmNlcywgYnV0IHRoZWlyIHN1cGVydHlwZSBkb2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0NvbXBvc2l0ZVN0YXRlU2NoZW1hKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN1cGVydHlwZT8uaXNDb21wb3NpdGVTdGF0ZVNjaGVtYSgpIHx8ICEhdGhpcy5zdGF0ZVNjaGVtYT8uY29tcG9zaXRlU2NoZW1hO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdGhlIGFwaVN0YXRlS2V5IG9wdGlvbiB2YWx1ZXMgKGZvciB0aGUgZW50aXJlIElPVHlwZSBoaWVyYXJjaHkpXG4gICAqIEZvciBleGFtcGxlOlxuICAgKiAgWyBudWxsLCBudWxsLCBbJ3ZhbGlkVmFsdWVzJ10sIG51bGwgXSBpZiB0aGVyZSB3ZXJlIHRocmVlIHN1cGVydHlwZXMsIGFuZCB5b3VyIHBhcmVudCB3YXMgdGhlIG9ubHkgSU9UeXBlIHdpdGggYXBpU3RhdGVLZXlzXG4gICAqL1xuICBwcml2YXRlIGdldEFsbEFQSVN0YXRlS2V5VmFsdWVzKCBhcGlTdGF0ZUtleXNQZXJMZXZlbDogKCBBUElTdGF0ZUtleXMgfCBudWxsIClbXSA9IFtdICk6ICggQVBJU3RhdGVLZXlzIHwgbnVsbCApW10ge1xuICAgIHRoaXMuc3VwZXJ0eXBlICYmIHRoaXMuc3VwZXJ0eXBlLmdldEFsbEFQSVN0YXRlS2V5VmFsdWVzKCBhcGlTdGF0ZUtleXNQZXJMZXZlbCApO1xuICAgIGFwaVN0YXRlS2V5c1BlckxldmVsLnB1c2goIHRoaXMuc3RhdGVTY2hlbWE/LmFwaVN0YXRlS2V5cyB8fCBudWxsICk7XG4gICAgcmV0dXJuIGFwaVN0YXRlS2V5c1BlckxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhbnkgSU9UeXBlIHVwIHRoZSBoaWVyYXJjaHkgYWN0dWFsbHkgc3VwcGxpZWQgYXBpU3RhdGVLZXlzLCBldmVuIGluIGBbXWAsIG1lYW5pbmcgXCJkb24ndCBvcHQtaW4gdG8gbmVzdGVkXG4gICAqIEFQSSBzdGF0ZS5cbiAgICovXG4gIHByaXZhdGUgYXBpU3RhdGVLZXlzUHJvdmlkZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsQVBJU3RhdGVLZXlWYWx1ZXMoKS5maWx0ZXIoIHRydXRoeSApLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHRoZSBhcGlTdGF0ZUtleXMgKGZvciB0aGUgZW50aXJlIElPVHlwZSBoaWVyYXJjaHkpIGluIG9uZSBhcnJheS5cbiAgICovXG4gIHB1YmxpYyBnZXRBbGxBUElTdGF0ZUtleXMoKTogQVBJU3RhdGVLZXlzIHtcbiAgICByZXR1cm4gXy5jb25jYXQoIC4uLnRoaXMuZ2V0QWxsQVBJU3RhdGVLZXlWYWx1ZXMoKS5tYXAoIHggPT4geCB8fCBbXSApICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvYmplY3QgZm9yIGEgUGhFVC1pTyBFbGVtZW50LCBidXQgb25seSB0aGUgZW50cmllcyB0aGF0IHNob3VsZCBiZSB0cmFja2VkIGJ5IHRoZSBQaEVULWlPIEFQSS4gU2VlXG4gICAqIFN0YXRlU2NoZW1hLmFwaVN0YXRlS2V5cyBmb3IgZGV0YWlscy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBzZXRzIGEgZ2xvYmFsIHRvIG1ha2Ugc3VyZSB0aGF0IG5lc3RlZCBzdGF0ZSBhbHNvIG9ubHlcbiAgICogc2VsZWN0cyB0aGUgYXBpU3RhdGVLZXlzIGZvciBhcGkgdHJhY2tpbmcgKFByb3BlcnR5SU88UmFuZ2VJTz4gY291bGQgaGF2ZSB2YWxpZFZhbHVlcyBvZiBQb2ludElPIHRoYXQgc2hvdWxkbid0XG4gICAqIGluY2x1ZGUgbm9uLXRyYWNrZWQgdmFsdWVzIG9mIFBvaW50SU8sIGlmIHRoZXJlIGFyZSBhbnkpLlxuICAgKi9cbiAgcHVibGljIHRvU3RhdGVPYmplY3RGb3JBUEkoIGNvcmVPYmplY3Q6IFQgKTogU3RhdGVUeXBlIHtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhR0VUVElOR19TVEFURV9GT1JfQVBJLCAnQVBJIHN0YXRlIGNhbm5vdCBuZXN0IGR1ZSB0byBsaW1pdGF0aW9uIG9mIHRoZSBnbG9iYWwnICk7XG4gICAgR0VUVElOR19TVEFURV9GT1JfQVBJID0gdHJ1ZTtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBBUElfU1RBVEVfTkVTVEVEX0NPVU5UID09PSAwLCAnbm90IG5lc3RlZCBiZWZvcmUgZ2V0dGluZyBBUEkgc3RhdGUnICk7XG4gICAgY29uc3Qgc3RhdGVPYmplY3RGb3JBUElPbmx5ID0gdGhpcy50b1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0ICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggQVBJX1NUQVRFX05FU1RFRF9DT1VOVCA9PT0gMCwgJ25vdCBuZXN0ZWQgYWZ0ZXIgZ2V0dGluZyBBUEkgc3RhdGUnICk7XG4gICAgR0VUVElOR19TVEFURV9GT1JfQVBJID0gZmFsc2U7XG4gICAgcmV0dXJuIHN0YXRlT2JqZWN0Rm9yQVBJT25seTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gc3RhdGVPYmplY3QgLSB0aGUgc3RhdGVPYmplY3QgdG8gdmFsaWRhdGUgYWdhaW5zdFxuICAgKiBAcGFyYW0gdG9Bc3NlcnQ9ZmFsc2UgLSB3aGV0aGVyIHRvIGFzc2VydCB3aGVuIGludmFsaWRcbiAgICogQHBhcmFtIHNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdD1bXVxuICAgKiBAcmV0dXJucyBpZiB0aGUgc3RhdGVPYmplY3QgaXMgdmFsaWQgb3Igbm90LlxuICAgKi9cbiAgcHVibGljIGlzU3RhdGVPYmplY3RWYWxpZCggc3RhdGVPYmplY3Q6IFN0YXRlVHlwZSwgdG9Bc3NlcnQgPSBmYWxzZSwgc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0OiBzdHJpbmdbXSA9IFtdICk6IGJvb2xlYW4ge1xuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHdoZW4gaW52YWxpZFxuICAgIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHN0YXRlT2JqZWN0IGhhcyBldmVyeXRoaW5nIHRoZSBzY2hlbWEgcmVxdWlyZXMgYW5kIG5vdGhpbmcgbW9yZVxuICAgIGlmICggdGhpcy5zdGF0ZVNjaGVtYSApIHtcbiAgICAgIGNvbnN0IHZhbGlkU29GYXIgPSB0aGlzLnN0YXRlU2NoZW1hLmNoZWNrU3RhdGVPYmplY3RWYWxpZCggc3RhdGVPYmplY3QgYXMgU2VsZlN0YXRlVHlwZSwgdG9Bc3NlcnQsIHNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdCApO1xuXG4gICAgICAvLyBudWxsIGFzIGEgbWFya2VyIHRvIGtlZXAgY2hlY2tpbmcgdXAgdGhlIGhpZXJhcmNoeSwgb3RoZXJ3aXNlIHdlIHJlYWNoZWQgb3VyIGJhc2VkIGNhc2UgYmVjYXVzZSB0aGUgc3RhdGVTY2hlbWEgd2FzIGEgdmFsdWUsIG5vdCBhIGNvbXBvc2l0ZVxuICAgICAgaWYgKCB2YWxpZFNvRmFyICE9PSBudWxsICkge1xuICAgICAgICByZXR1cm4gdmFsaWRTb0ZhcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuc3VwZXJ0eXBlICkge1xuICAgICAgcmV0dXJuIHZhbGlkICYmIHRoaXMuc3VwZXJ0eXBlLmlzU3RhdGVPYmplY3RWYWxpZCggc3RhdGVPYmplY3QsIHRvQXNzZXJ0LCBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QgKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHdlIHJlYWNoIHRoZSByb290LCBtYWtlIHN1cmUgdGhlcmUgaXNuJ3QgYW55dGhpbmcgaW4gdGhlIHN0YXRlT2JqZWN0IHRoYXQgaXNuJ3QgZGVzY3JpYmVkIGJ5IGEgc2NoZW1hXG4gICAgaWYgKCAhdGhpcy5zdXBlcnR5cGUgJiYgc3RhdGVPYmplY3QgJiYgdHlwZW9mIHN0YXRlT2JqZWN0ICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheSggc3RhdGVPYmplY3QgKSApIHtcblxuICAgICAgLy8gVmlzaXQgdGhlIHN0YXRlXG4gICAgICBPYmplY3Qua2V5cyggc3RhdGVPYmplY3QgKS5mb3JFYWNoKCBrZXkgPT4ge1xuICAgICAgICBjb25zdCBrZXlWYWxpZCA9IHNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdC5pbmNsdWRlcygga2V5ICk7XG4gICAgICAgIGlmICggIWtleVZhbGlkICkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0ICYmIHRvQXNzZXJ0ICYmIGFzc2VydCgga2V5VmFsaWQsIGBzdGF0ZU9iamVjdCBwcm92aWRlZCBhIGtleSB0aGF0IGlzIG5vdCBpbiB0aGUgc2NoZW1hOiAke2tleX1gICk7XG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IGlmIHRoZSBwcm92aWRlZCBzdGF0ZU9iamVjdCBpcyBub3QgdmFsaWQgdG8gdGhpcyBJT1R5cGUncyBzdGF0ZVNjaGVtYVxuICAgKi9cbiAgcHVibGljIHZhbGlkYXRlU3RhdGVPYmplY3QoIHN0YXRlT2JqZWN0OiBTdGF0ZVR5cGUgKTogdm9pZCB7XG4gICAgdGhpcy5pc1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0LCB0cnVlICk7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogSU9UeXBlTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZU5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCB0aGF0IGluZGljYXRlcyB0aGUgQVBJIHR5cGUsIGluY2x1ZGluZyBkb2N1bWVudGF0aW9uLCBtZXRob2RzICYgc2lnbmF0dXJlcywgc3VwZXJ0eXBlcywgZXRjLlxuICAgKiBUaGUgb2JqZWN0IGlzIGludGVuZGVkIGZvciBzZXJpYWxpemF0aW9uIHZpYSBKU09OLnN0cmluZ2lmeSgpLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIHN0YXRpYywgYnV0IHRoYXQgZG9lc24ndCB3b3JrIHdlbGwgd2l0aCB0aGUgc2luZ2xldG9uIHBhdHRlcm4sIHNvIGtlZXAgaW4gb24gdGhlIHByb3RvdHlwZS5cbiAgICovXG4gIHB1YmxpYyBnZXRBUEkoKTogUGhldGlvVHlwZSB7XG5cbiAgICAvLyBFbnVtZXJhdGUgdGhlIG1ldGhvZHMgc3BlY2lmaWMgdG8gdGhlIHR5cGUgKG5vdCBmb3Igc3VwZXJ0eXBlKS5cbiAgICBjb25zdCBtZXRob2RzOiBNZXRob2RzID0ge307XG4gICAgY29uc3QgbWV0aG9kTmFtZXMgPSBfLmtleXMoIHRoaXMubWV0aG9kcyApO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggbWV0aG9kXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBjb25zdCBtZXRob2ROYW1lID0gbWV0aG9kTmFtZXNbIGkgXTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kcyFbIG1ldGhvZE5hbWUgXTtcblxuICAgICAgY29uc3QgbTogTWV0aG9kID0ge1xuXG4gICAgICAgIC8vIFJldHVybiBuYW1lcyBmb3IgcGFyYW1ldGVyIHR5cGVzIGFuZCByZXR1cm4gdHlwZXMgdG8gcHJldmVudCBsb29wcyBpbiB0eXBlIGdyYXBoXG4gICAgICAgIHJldHVyblR5cGU6IG1ldGhvZC5yZXR1cm5UeXBlLnR5cGVOYW1lLFxuICAgICAgICBwYXJhbWV0ZXJUeXBlczogbWV0aG9kLnBhcmFtZXRlclR5cGVzLm1hcCggbWFwQVBJRm9yVHlwZSApLFxuICAgICAgICBkb2N1bWVudGF0aW9uOiBtZXRob2QuZG9jdW1lbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgLy8gaW52b2NhYmxlRm9yUmVhZE9ubHlFbGVtZW50cz09PWZhbHNlIGlzIG9wdC1pblxuICAgICAgaWYgKCBtZXRob2QuaW52b2NhYmxlRm9yUmVhZE9ubHlFbGVtZW50cyA9PT0gZmFsc2UgKSB7XG4gICAgICAgIG0uaW52b2NhYmxlRm9yUmVhZE9ubHlFbGVtZW50cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbWV0aG9kc1sgbWV0aG9kTmFtZSBdID0gbTtcbiAgICB9XG5cbiAgICBjb25zdCBzdXBlcnR5cGUgPSB0aGlzLnN1cGVydHlwZTtcblxuICAgIC8vIFJldHVybiBhbGwgcGFydHMgb2YgdGhlIEFQSSBhcyBhbiBvYmplY3RcbiAgICBjb25zdCBwaGV0aW9UeXBlOiBQaGV0aW9UeXBlID0ge1xuICAgICAgbWV0aG9kczogbWV0aG9kcyxcbiAgICAgIHN1cGVydHlwZTogc3VwZXJ0eXBlID8gc3VwZXJ0eXBlLnR5cGVOYW1lIDogc3VwZXJ0eXBlLFxuICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmRvY3VtZW50YXRpb24sXG4gICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgbWV0YWRhdGFEZWZhdWx0czogdGhpcy5tZXRhZGF0YURlZmF1bHRzLFxuICAgICAgZGF0YURlZmF1bHRzOiB0aGlzLmRhdGFEZWZhdWx0cyxcbiAgICAgIG1ldGhvZE9yZGVyOiB0aGlzLm1ldGhvZE9yZGVyXG4gICAgfTtcblxuICAgIGlmICggdGhpcy5zdGF0ZVNjaGVtYSApIHtcbiAgICAgIHBoZXRpb1R5cGUuc3RhdGVTY2hlbWEgPSB0aGlzLnN0YXRlU2NoZW1hLmdldFN0YXRlU2NoZW1hQVBJKCk7XG5cbiAgICAgIGlmICggdGhpcy5zdGF0ZVNjaGVtYS5hcGlTdGF0ZUtleXMgJiYgdGhpcy5zdGF0ZVNjaGVtYS5hcGlTdGF0ZUtleXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgcGhldGlvVHlwZS5hcGlTdGF0ZUtleXMgPSB0aGlzLnN0YXRlU2NoZW1hLmFwaVN0YXRlS2V5cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIHdheSB3ZSBkb24ndCBoYXZlIHRoaXMga2V5IHVubGVzcyB0aGVyZSBhcmUgcGFyYW1ldGVyVHlwZXMgcG9zc2libGUgKGVtcHR5IGFycmF5IGFsbG93ZWQpXG4gICAgaWYgKCB0aGlzLnBhcmFtZXRlclR5cGVzICkge1xuICAgICAgcGhldGlvVHlwZS5wYXJhbWV0ZXJUeXBlcyA9IHRoaXMucGFyYW1ldGVyVHlwZXMubWFwKCBtYXBBUElGb3JUeXBlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoZXRpb1R5cGU7XG4gIH1cbn1cblxuY29uc3QgbWFwQVBJRm9yVHlwZSA9ICggcGFyYW1ldGVyVHlwZTogSU9UeXBlICk6IHN0cmluZyA9PiBwYXJhbWV0ZXJUeXBlLnR5cGVOYW1lO1xuXG4vLyBkZWZhdWx0IHN0YXRlIHZhbHVlXG5jb25zdCBERUZBVUxUX1NUQVRFID0gbnVsbDtcblxuLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFmdGVyIHRoZSBjbGFzcyBkZWNsYXJhdGlvbiB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBQaGV0aW9PYmplY3QuXG4vLyBAcmVhZG9ubHlcbklPVHlwZS5PYmplY3RJTyA9IG5ldyBJT1R5cGU8UGhldGlvT2JqZWN0LCBudWxsPiggVGFuZGVtQ29uc3RhbnRzLk9CSkVDVF9JT19UWVBFX05BTUUsIHtcbiAgaXNWYWxpZFZhbHVlOiAoKSA9PiB0cnVlLFxuICBzdXBlcnR5cGU6IG51bGwsXG4gIGRvY3VtZW50YXRpb246ICdUaGUgcm9vdCBvZiB0aGUgUGhFVC1pTyBUeXBlIGhpZXJhcmNoeScsXG4gIHRvU3RhdGVPYmplY3Q6ICggY29yZU9iamVjdDogUGhldGlvT2JqZWN0ICkgPT4ge1xuXG4gICAgaWYgKCBwaGV0ICYmIHBoZXQudGFuZGVtICYmIHBoZXQudGFuZGVtLlRhbmRlbS5WQUxJREFUSU9OICkge1xuXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBjb3JlT2JqZWN0LnRhbmRlbSwgJ2NvcmVPYmplY3QgbXVzdCBiZSBQaEVULWlPIG9iamVjdCcgKTtcblxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggIWNvcmVPYmplY3QucGhldGlvU3RhdGUsXG4gICAgICAgIGBmZWxsIGJhY2sgdG8gcm9vdCBzZXJpYWxpemF0aW9uIHN0YXRlIGZvciAke2NvcmVPYmplY3QudGFuZGVtLnBoZXRpb0lEfS4gUG90ZW50aWFsIHNvbHV0aW9uczpcbiAgICAgICAgICogbWFyayB0aGUgdHlwZSBhcyBwaGV0aW9TdGF0ZTogZmFsc2VcbiAgICAgICAgICogY3JlYXRlIGEgY3VzdG9tIHRvU3RhdGVPYmplY3QgbWV0aG9kIGluIHlvdXIgSU9UeXBlXG4gICAgICAgICAqIHBlcmhhcHMgeW91IGhhdmUgZXZlcnl0aGluZyByaWdodCwgYnV0IGZvcmdvdCB0byBwYXNzIGluIHRoZSBJT1R5cGUgdmlhIHBoZXRpb1R5cGUgaW4gdGhlIGNvbnN0cnVjdG9yYCApO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9TVEFURTtcbiAgfSxcbiAgZnJvbVN0YXRlT2JqZWN0OiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCAnT2JqZWN0SU8uZnJvbVN0YXRlT2JqZWN0IHNob3VsZCBub3QgYmUgY2FsbGVkJyApO1xuICB9LFxuICBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50czogKCkgPT4gW10sXG4gIGFwcGx5U3RhdGU6IF8ubm9vcCxcbiAgbWV0YWRhdGFEZWZhdWx0czogVGFuZGVtQ29uc3RhbnRzLlBIRVRfSU9fT0JKRUNUX01FVEFEQVRBX0RFRkFVTFRTLFxuICBkYXRhRGVmYXVsdHM6IHtcbiAgICBpbml0aWFsU3RhdGU6IERFRkFVTFRfU1RBVEVcbiAgfSxcbiAgc3RhdGVTY2hlbWE6IG51bGxcbn0gKTtcblxudGFuZGVtTmFtZXNwYWNlLnJlZ2lzdGVyKCAnSU9UeXBlJywgSU9UeXBlICk7Il0sIm5hbWVzIjpbInZhbGlkYXRlIiwiVmFsaWRhdGlvbiIsIm9wdGlvbml6ZSIsIlBoZXRpb0NvbnN0YW50cyIsIlRhbmRlbUNvbnN0YW50cyIsInRhbmRlbU5hbWVzcGFjZSIsIlN0YXRlU2NoZW1hIiwiVkFMSURBVEVfT1BUSU9OU19GQUxTRSIsInZhbGlkYXRlVmFsaWRhdG9yIiwidHJ1dGh5IiwieCIsIkdFVFRJTkdfU1RBVEVfRk9SX0FQSSIsIkFQSV9TVEFURV9ORVNURURfQ09VTlQiLCJnZXRDb3JlVHlwZU5hbWUiLCJpb1R5cGVOYW1lIiwiaW5kZXgiLCJpbmRleE9mIiwiSU9fVFlQRV9TVUZGSVgiLCJhc3NlcnQiLCJzdWJzdHJpbmciLCJJT1R5cGUiLCJ0b1N0YXRlT2JqZWN0IiwiY29yZU9iamVjdCIsInN0YXRlT2JqZWN0IiwidG9TdGF0ZU9iamVjdFN1cHBsaWVkIiwic3RhdGVTY2hlbWFTdXBwbGllZCIsInN0YXRlU2NoZW1hIiwiaXNDb21wb3NpdGUiLCJkZWZhdWx0VG9TdGF0ZU9iamVjdCIsInRvU3RhdGVPYmplY3RPcHRpb24iLCJzdXBlcnR5cGUiLCJ2YWxpZGF0ZVN0YXRlT2JqZWN0IiwicmVzb2x2ZWRTdGF0ZU9iamVjdCIsImlzQ29tcG9zaXRlU3RhdGVTY2hlbWEiLCJhcGlTdGF0ZUtleXNQcm92aWRlZCIsIl8iLCJwaWNrIiwiZ2V0QWxsQVBJU3RhdGVLZXlzIiwiZnJvbVN0YXRlT2JqZWN0IiwiZnJvbVN0YXRlT2JqZWN0T3B0aW9uIiwiYXBwbHlTdGF0ZSIsInZhbGlkYXRvciIsImFwcGx5U3RhdGVTdXBwbGllZCIsInBoZXRpb1R5cGUiLCJkZWZhdWx0QXBwbHlTdGF0ZSIsImFwcGx5U3RhdGVPcHRpb24iLCJzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyIsInN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzT3B0aW9uIiwic3VwZXJTdGF0ZU9iamVjdCIsIm1lcmdlIiwiZ2V0VHlwZUhpZXJhcmNoeSIsImFycmF5IiwiaW9UeXBlIiwicHVzaCIsImV4dGVuZHMiLCJ0eXBlIiwiaW5jbHVkZXMiLCJnZXRBbGxNZXRhZGF0YURlZmF1bHRzIiwibWV0YWRhdGFEZWZhdWx0cyIsImdldEFsbERhdGFEZWZhdWx0cyIsImRhdGFEZWZhdWx0cyIsImNvbXBvc2l0ZVNjaGVtYSIsImdldEFsbEFQSVN0YXRlS2V5VmFsdWVzIiwiYXBpU3RhdGVLZXlzUGVyTGV2ZWwiLCJhcGlTdGF0ZUtleXMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJjb25jYXQiLCJtYXAiLCJ0b1N0YXRlT2JqZWN0Rm9yQVBJIiwic3RhdGVPYmplY3RGb3JBUElPbmx5IiwiaXNTdGF0ZU9iamVjdFZhbGlkIiwidG9Bc3NlcnQiLCJzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QiLCJ2YWxpZCIsInZhbGlkU29GYXIiLCJjaGVja1N0YXRlT2JqZWN0VmFsaWQiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImtleVZhbGlkIiwidG9TdHJpbmciLCJ0eXBlTmFtZSIsImdldEFQSSIsIm1ldGhvZHMiLCJtZXRob2ROYW1lcyIsImkiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwibSIsInJldHVyblR5cGUiLCJwYXJhbWV0ZXJUeXBlcyIsIm1hcEFQSUZvclR5cGUiLCJkb2N1bWVudGF0aW9uIiwiaW52b2NhYmxlRm9yUmVhZE9ubHlFbGVtZW50cyIsImV2ZW50cyIsIm1ldGhvZE9yZGVyIiwiZ2V0U3RhdGVTY2hlbWFBUEkiLCJwcm92aWRlZE9wdGlvbnMiLCJPYmplY3RJTyIsIm9wdGlvbnMiLCJpc0Z1bmN0aW9uVHlwZSIsImRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QiLCJhZGRDaGlsZEVsZW1lbnQiLCJtZXRhZGF0YURlZmF1bHRLZXkiLCJoYXNPd25Qcm9wZXJ0eSIsIlZBTElEQVRPUl9LRVlTIiwidmFsaWRhdGlvbk1lc3NhZ2UiLCJzcGxpdCIsImVuZHNXaXRoIiwidmFsdWVzIiwibWV0aG9kT2JqZWN0IiwidHlwZUhpZXJhcmNoeSIsImV2ZW50Iiwic29tZSIsInQiLCJzdXBlcnR5cGVBUElLZXlzIiwiYXBpU3RhdGVLZXkiLCJwYXJhbWV0ZXJUeXBlIiwiREVGQVVMVF9TVEFURSIsIk9CSkVDVF9JT19UWVBFX05BTUUiLCJpc1ZhbGlkVmFsdWUiLCJwaGV0IiwidGFuZGVtIiwiVGFuZGVtIiwiVkFMSURBVElPTiIsInBoZXRpb1N0YXRlIiwicGhldGlvSUQiLCJFcnJvciIsIm5vb3AiLCJQSEVUX0lPX09CSkVDVF9NRVRBREFUQV9ERUZBVUxUUyIsImluaXRpYWxTdGF0ZSIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7OztDQU1DLEdBRUQsT0FBT0EsY0FBYywrQkFBK0I7QUFDcEQsT0FBT0MsZ0JBQStCLGlDQUFpQztBQUN2RSxPQUFPQyxlQUFlLHFDQUFxQztBQUczRCxPQUFPQyxxQkFBcUIsd0JBQXdCO0FBR3BELE9BQU9DLHFCQUFxQix3QkFBd0I7QUFDcEQsT0FBT0MscUJBQXFCLHdCQUF3QjtBQUNwRCxPQUFPQyxpQkFBOEUsbUJBQW1CO0FBRXhHLFlBQVk7QUFDWixNQUFNQyx5QkFBeUI7SUFBRUMsbUJBQW1CO0FBQU07QUFFMUQsTUFBTUMsU0FBUyxDQUFFQyxJQUFnQyxDQUFDLENBQUNBO0FBRW5ELGtIQUFrSDtBQUNsSCw4Q0FBOEM7QUFDOUMsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLHlCQUF5QjtBQUU3Qjs7Q0FFQyxHQUNELE1BQU1DLGtCQUFrQixDQUFFQztJQUN4QixNQUFNQyxRQUFRRCxXQUFXRSxPQUFPLENBQUViLGdCQUFnQmMsY0FBYztJQUNoRUMsVUFBVUEsT0FBUUgsU0FBUyxHQUFHO0lBQzlCLE9BQU9ELFdBQVdLLFNBQVMsQ0FBRSxHQUFHSjtBQUNsQztBQWtKZSxJQUFBLEFBQU1LLFNBQU4sTUFBTUE7SUErS1pDLGNBQWVDLFVBQWEsRUFBYztRQUMvQ1Y7UUFDQSxrRUFBa0U7UUFFbEUsSUFBSVc7UUFFSiwy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