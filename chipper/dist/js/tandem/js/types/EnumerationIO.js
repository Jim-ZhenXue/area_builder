// Copyright 2022-2024, University of Colorado Boulder
/**
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */ import IOTypeCache from '../IOTypeCache.js';
import tandemNamespace from '../tandemNamespace.js';
import IOType from './IOType.js';
import StateSchema from './StateSchema.js';
// Cache each parameterized IOType so that it is only created once.
const cache = new IOTypeCache();
const joinKeys = (keys)=>keys.join('|');
const EnumerationIO = (enumerationContainer)=>{
    const enumeration = enumerationContainer.enumeration;
    // This caching implementation should be kept in sync with the other parametric IOType caching implementations.
    if (!cache.has(enumeration)) {
        // Enumeration supports additional documentation, so the values can be described.
        const additionalDocs = enumeration.phetioDocumentation ? ` ${enumeration.phetioDocumentation}` : '';
        const keys = enumeration.keys;
        const values = enumeration.values;
        const ioTypeName = `EnumerationIO(${joinKeys(keys)})`;
        assert && assert(!Array.from(cache.values()).find((ioType)=>ioType.typeName === ioTypeName), 'There was already another IOType with the same name: ' + ioTypeName);
        cache.set(enumeration, new IOType(ioTypeName, {
            validValues: values,
            documentation: `Possible values: ${keys.join(', ')}.${additionalDocs}`,
            toStateObject: (value)=>enumeration.getKey(value),
            fromStateObject: (stateObject)=>{
                assert && assert(typeof stateObject === 'string', 'unsupported EnumerationIO value type, expected string'); // eslint-disable-line phet/no-simple-type-checking-assertions
                assert && assert(keys.includes(stateObject), `Unrecognized value: ${stateObject}`);
                return enumeration.getValue(stateObject);
            },
            stateSchema: StateSchema.asValue(`${joinKeys(keys)}`, {
                isValidValue: (key)=>keys.includes(key)
            })
        }));
    }
    return cache.get(enumeration);
};
tandemNamespace.register('EnumerationIO', EnumerationIO);
export default EnumerationIO;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9FbnVtZXJhdGlvbklPLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIyLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKi9cblxuaW1wb3J0IEVudW1lcmF0aW9uVmFsdWUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL0VudW1lcmF0aW9uVmFsdWUuanMnO1xuaW1wb3J0IFRFbnVtZXJhdGlvbiwgeyBFbnVtZXJhdGlvbkNvbnRhaW5lciB9IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9URW51bWVyYXRpb24uanMnO1xuaW1wb3J0IElPVHlwZUNhY2hlIGZyb20gJy4uL0lPVHlwZUNhY2hlLmpzJztcbmltcG9ydCB0YW5kZW1OYW1lc3BhY2UgZnJvbSAnLi4vdGFuZGVtTmFtZXNwYWNlLmpzJztcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi9JT1R5cGUuanMnO1xuaW1wb3J0IFN0YXRlU2NoZW1hIGZyb20gJy4vU3RhdGVTY2hlbWEuanMnO1xuXG4vLyBDYWNoZSBlYWNoIHBhcmFtZXRlcml6ZWQgSU9UeXBlIHNvIHRoYXQgaXQgaXMgb25seSBjcmVhdGVkIG9uY2UuXG5jb25zdCBjYWNoZSA9IG5ldyBJT1R5cGVDYWNoZTxURW51bWVyYXRpb248RW51bWVyYXRpb25WYWx1ZT4+KCk7XG5cbmNvbnN0IGpvaW5LZXlzID0gKCBrZXlzOiBzdHJpbmdbXSApID0+IGtleXMuam9pbiggJ3wnICk7XG5cbmNvbnN0IEVudW1lcmF0aW9uSU8gPSA8VCBleHRlbmRzIEVudW1lcmF0aW9uVmFsdWU+KCBlbnVtZXJhdGlvbkNvbnRhaW5lcjogRW51bWVyYXRpb25Db250YWluZXI8VD4gKTogSU9UeXBlID0+IHtcbiAgY29uc3QgZW51bWVyYXRpb24gPSBlbnVtZXJhdGlvbkNvbnRhaW5lci5lbnVtZXJhdGlvbjtcblxuICAvLyBUaGlzIGNhY2hpbmcgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBvdGhlciBwYXJhbWV0cmljIElPVHlwZSBjYWNoaW5nIGltcGxlbWVudGF0aW9ucy5cbiAgaWYgKCAhY2FjaGUuaGFzKCBlbnVtZXJhdGlvbiApICkge1xuXG4gICAgLy8gRW51bWVyYXRpb24gc3VwcG9ydHMgYWRkaXRpb25hbCBkb2N1bWVudGF0aW9uLCBzbyB0aGUgdmFsdWVzIGNhbiBiZSBkZXNjcmliZWQuXG4gICAgY29uc3QgYWRkaXRpb25hbERvY3MgPSBlbnVtZXJhdGlvbi5waGV0aW9Eb2N1bWVudGF0aW9uID8gYCAke2VudW1lcmF0aW9uLnBoZXRpb0RvY3VtZW50YXRpb259YCA6ICcnO1xuXG4gICAgY29uc3Qga2V5cyA9IGVudW1lcmF0aW9uLmtleXM7XG4gICAgY29uc3QgdmFsdWVzID0gZW51bWVyYXRpb24udmFsdWVzO1xuXG4gICAgY29uc3QgaW9UeXBlTmFtZSA9IGBFbnVtZXJhdGlvbklPKCR7am9pbktleXMoIGtleXMgKX0pYDtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoXG4gICAgICAhQXJyYXkuZnJvbSggY2FjaGUudmFsdWVzKCkgKS5maW5kKCBpb1R5cGUgPT4gaW9UeXBlLnR5cGVOYW1lID09PSBpb1R5cGVOYW1lICksXG4gICAgICAnVGhlcmUgd2FzIGFscmVhZHkgYW5vdGhlciBJT1R5cGUgd2l0aCB0aGUgc2FtZSBuYW1lOiAnICsgaW9UeXBlTmFtZVxuICAgICk7XG5cbiAgICBjYWNoZS5zZXQoIGVudW1lcmF0aW9uLCBuZXcgSU9UeXBlPFQsIHN0cmluZz4oIGlvVHlwZU5hbWUsIHtcbiAgICAgIHZhbGlkVmFsdWVzOiB2YWx1ZXMsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgUG9zc2libGUgdmFsdWVzOiAke2tleXMuam9pbiggJywgJyApfS4ke2FkZGl0aW9uYWxEb2NzfWAsXG4gICAgICB0b1N0YXRlT2JqZWN0OiAoIHZhbHVlOiBUICkgPT4gZW51bWVyYXRpb24uZ2V0S2V5KCB2YWx1ZSApLFxuICAgICAgZnJvbVN0YXRlT2JqZWN0OiAoIHN0YXRlT2JqZWN0OiBzdHJpbmcgKTogVCA9PiB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBzdGF0ZU9iamVjdCA9PT0gJ3N0cmluZycsICd1bnN1cHBvcnRlZCBFbnVtZXJhdGlvbklPIHZhbHVlIHR5cGUsIGV4cGVjdGVkIHN0cmluZycgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwaGV0L25vLXNpbXBsZS10eXBlLWNoZWNraW5nLWFzc2VydGlvbnNcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCgga2V5cy5pbmNsdWRlcyggc3RhdGVPYmplY3QgKSwgYFVucmVjb2duaXplZCB2YWx1ZTogJHtzdGF0ZU9iamVjdH1gICk7XG4gICAgICAgIHJldHVybiBlbnVtZXJhdGlvbi5nZXRWYWx1ZSggc3RhdGVPYmplY3QgKTtcbiAgICAgIH0sXG4gICAgICBzdGF0ZVNjaGVtYTogU3RhdGVTY2hlbWEuYXNWYWx1ZTxFbnVtZXJhdGlvblZhbHVlLCBzdHJpbmc+KCBgJHtqb2luS2V5cygga2V5cyApfWAsIHtcbiAgICAgICAgaXNWYWxpZFZhbHVlOiAoIGtleTogc3RyaW5nICkgPT4ga2V5cy5pbmNsdWRlcygga2V5IClcbiAgICAgIH0gKVxuICAgIH0gKSApO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlLmdldCggZW51bWVyYXRpb24gKSE7XG59O1xuXG50YW5kZW1OYW1lc3BhY2UucmVnaXN0ZXIoICdFbnVtZXJhdGlvbklPJywgRW51bWVyYXRpb25JTyApO1xuZXhwb3J0IGRlZmF1bHQgRW51bWVyYXRpb25JTzsiXSwibmFtZXMiOlsiSU9UeXBlQ2FjaGUiLCJ0YW5kZW1OYW1lc3BhY2UiLCJJT1R5cGUiLCJTdGF0ZVNjaGVtYSIsImNhY2hlIiwiam9pbktleXMiLCJrZXlzIiwiam9pbiIsIkVudW1lcmF0aW9uSU8iLCJlbnVtZXJhdGlvbkNvbnRhaW5lciIsImVudW1lcmF0aW9uIiwiaGFzIiwiYWRkaXRpb25hbERvY3MiLCJwaGV0aW9Eb2N1bWVudGF0aW9uIiwidmFsdWVzIiwiaW9UeXBlTmFtZSIsImFzc2VydCIsIkFycmF5IiwiZnJvbSIsImZpbmQiLCJpb1R5cGUiLCJ0eXBlTmFtZSIsInNldCIsInZhbGlkVmFsdWVzIiwiZG9jdW1lbnRhdGlvbiIsInRvU3RhdGVPYmplY3QiLCJ2YWx1ZSIsImdldEtleSIsImZyb21TdGF0ZU9iamVjdCIsInN0YXRlT2JqZWN0IiwiaW5jbHVkZXMiLCJnZXRWYWx1ZSIsInN0YXRlU2NoZW1hIiwiYXNWYWx1ZSIsImlzVmFsaWRWYWx1ZSIsImtleSIsImdldCIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7OztDQUdDLEdBSUQsT0FBT0EsaUJBQWlCLG9CQUFvQjtBQUM1QyxPQUFPQyxxQkFBcUIsd0JBQXdCO0FBQ3BELE9BQU9DLFlBQVksY0FBYztBQUNqQyxPQUFPQyxpQkFBaUIsbUJBQW1CO0FBRTNDLG1FQUFtRTtBQUNuRSxNQUFNQyxRQUFRLElBQUlKO0FBRWxCLE1BQU1LLFdBQVcsQ0FBRUMsT0FBb0JBLEtBQUtDLElBQUksQ0FBRTtBQUVsRCxNQUFNQyxnQkFBZ0IsQ0FBOEJDO0lBQ2xELE1BQU1DLGNBQWNELHFCQUFxQkMsV0FBVztJQUVwRCwrR0FBK0c7SUFDL0csSUFBSyxDQUFDTixNQUFNTyxHQUFHLENBQUVELGNBQWdCO1FBRS9CLGlGQUFpRjtRQUNqRixNQUFNRSxpQkFBaUJGLFlBQVlHLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxFQUFFSCxZQUFZRyxtQkFBbUIsRUFBRSxHQUFHO1FBRWpHLE1BQU1QLE9BQU9JLFlBQVlKLElBQUk7UUFDN0IsTUFBTVEsU0FBU0osWUFBWUksTUFBTTtRQUVqQyxNQUFNQyxhQUFhLENBQUMsY0FBYyxFQUFFVixTQUFVQyxNQUFPLENBQUMsQ0FBQztRQUV2RFUsVUFBVUEsT0FDUixDQUFDQyxNQUFNQyxJQUFJLENBQUVkLE1BQU1VLE1BQU0sSUFBS0ssSUFBSSxDQUFFQyxDQUFBQSxTQUFVQSxPQUFPQyxRQUFRLEtBQUtOLGFBQ2xFLDBEQUEwREE7UUFHNURYLE1BQU1rQixHQUFHLENBQUVaLGFBQWEsSUFBSVIsT0FBbUJhLFlBQVk7WUFDekRRLGFBQWFUO1lBQ2JVLGVBQWUsQ0FBQyxpQkFBaUIsRUFBRWxCLEtBQUtDLElBQUksQ0FBRSxNQUFPLENBQUMsRUFBRUssZ0JBQWdCO1lBQ3hFYSxlQUFlLENBQUVDLFFBQWNoQixZQUFZaUIsTUFBTSxDQUFFRDtZQUNuREUsaUJBQWlCLENBQUVDO2dCQUNqQmIsVUFBVUEsT0FBUSxPQUFPYSxnQkFBZ0IsVUFBVSwwREFBMkQsOERBQThEO2dCQUM1S2IsVUFBVUEsT0FBUVYsS0FBS3dCLFFBQVEsQ0FBRUQsY0FBZSxDQUFDLG9CQUFvQixFQUFFQSxhQUFhO2dCQUNwRixPQUFPbkIsWUFBWXFCLFFBQVEsQ0FBRUY7WUFDL0I7WUFDQUcsYUFBYTdCLFlBQVk4QixPQUFPLENBQTRCLEdBQUc1QixTQUFVQyxPQUFRLEVBQUU7Z0JBQ2pGNEIsY0FBYyxDQUFFQyxNQUFpQjdCLEtBQUt3QixRQUFRLENBQUVLO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBLE9BQU8vQixNQUFNZ0MsR0FBRyxDQUFFMUI7QUFDcEI7QUFFQVQsZ0JBQWdCb0MsUUFBUSxDQUFFLGlCQUFpQjdCO0FBQzNDLGVBQWVBLGNBQWMifQ==