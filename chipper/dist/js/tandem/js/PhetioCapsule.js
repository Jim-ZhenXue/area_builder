// Copyright 2019-2024, University of Colorado Boulder
/**
 * A PhET-iO class that encapsulates a PhetioObject that is not created during sim startup to provide PhET-iO API
 * validation, API communication (like to view in studio before creation), and to support PhET-iO state if applicable.
 *
 * Constructing a PhetioCapsule creates a container encapsulating a wrapped element that can be of any type.
 *
 * Clients should use myCapsule.getElement() instead of storing the element value itself.
 *
 * NOTE: Be careful about treating the dynamic element as a singleton. When creating the archetype, problems can arise
 * because the capsule creates two instances of the element: one as the archetype and one as the instance. This can
 * result in trouble like in https://github.com/phetsims/joist/issues/821.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */ import optionize from '../../phet-core/js/optionize.js';
import IOTypeCache from './IOTypeCache.js';
import isSettingPhetioStateProperty from './isSettingPhetioStateProperty.js';
import PhetioDynamicElementContainer from './PhetioDynamicElementContainer.js';
import Tandem from './Tandem.js';
import tandemNamespace from './tandemNamespace.js';
import IOType from './types/IOType.js';
// constants
const DEFAULT_CONTAINER_SUFFIX = phetio.PhetioIDUtils.CAPSULE_SUFFIX;
// cache each parameterized IOType so that it is only created once.
const cache = new IOTypeCache();
let PhetioCapsule = class PhetioCapsule extends PhetioDynamicElementContainer {
    /**
   * Dispose the underlying element.  Called by the PhetioStateEngine so the capsule element can be recreated with the
   * correct state.
   */ disposeElement() {
        assert && assert(this.element, 'cannot dispose if element is not defined');
        assert && assert(this.disposeOnClear, 'cannot dispose if element is not disposable');
        super.disposeElement(this.element);
        this.element = null;
    }
    hasElement() {
        return this.element !== null;
    }
    /**
   * Creates the element if it has not been created yet, and returns it.
   */ getElement(...argsForCreateFunction) {
        if (!this.element) {
            this.create(argsForCreateFunction);
        }
        assert && assert(this.element !== null);
        return this.element;
    }
    /**
   * PhetioCapsule will dispose its element, clearing things up and getting ready for setState, unless
   * this.disposeOnClear opts out of this behavior, in which case the element should fully support mutating itself
   * during state setting.
   */ clear(providedOptions) {
        const options = optionize()({
            phetioState: null
        }, providedOptions);
        if (this.element && this.disposeOnClear) {
            var _options_phetioState_hasOwnProperty;
            const appearsInState = options.phetioState && ((_options_phetioState_hasOwnProperty = options.phetioState.hasOwnProperty(this.element.phetioID)) != null ? _options_phetioState_hasOwnProperty : false);
            // This option forces disposal on clear, otherwise we don't clear if the element exists in state
            if (this.disposeCreatedOnStateSet || !appearsInState) {
                this.disposeElement();
            }
        }
    }
    /**
   * Primarily for internal use, clients should usually use getElement().
   * @param argsForCreateFunction
   * @param [fromStateSetting] - used for validation during state setting, see PhetioDynamicElementContainer.disposeElement() for documentation
   * (phet-io)
   */ create(argsForCreateFunction, fromStateSetting = false) {
        assert && assert(this.isPhetioInstrumented(), 'TODO: support uninstrumented PhetioCapsules? see https://github.com/phetsims/tandem/issues/184');
        assert && this.supportsDynamicState && _.hasIn(window, 'phet.joist.sim.') && isSettingPhetioStateProperty.value && assert(fromStateSetting, 'dynamic elements should only be created by the state engine when setting state.');
        // create with default state and substructure, details will need to be set by setter methods.
        this.element = this.createDynamicElement(this.phetioDynamicElementName, argsForCreateFunction, Tandem.PHET_IO_ENABLED ? this.phetioType.parameterTypes[0] : null // Don't access phetioType in PhET brand
        );
        this.notifyElementCreated(this.element);
        return this.element;
    }
    /**
   * @param createElement - function that creates the encapsulated element
   * @param defaultArguments - arguments passed to createElement when creating the archetype
   * @param [providedOptions]
   */ constructor(createElement, defaultArguments, providedOptions){
        const options = optionize()({
            // The capsule's tandem name must have this suffix, and the base tandem name for its wrapped element
            // will consist of the capsule's tandem name with this suffix stripped off.
            containerSuffix: DEFAULT_CONTAINER_SUFFIX,
            disposeOnClear: true,
            disposeCreatedOnStateSet: false
        }, providedOptions);
        super(createElement, defaultArguments, options);
        this.element = null;
        this.disposeOnClear = options.disposeOnClear;
        this.disposeCreatedOnStateSet = options.disposeCreatedOnStateSet;
    }
};
/**
   * Parametric IOType constructor.  Given an element type, this function returns a PhetioCapsule IOType.
   * This caching implementation should be kept in sync with the other parametric IOType caching implementations.
   * @param parameterType
   * @constructor
   */ PhetioCapsule.PhetioCapsuleIO = (parameterType)=>{
    if (!cache.has(parameterType)) {
        cache.set(parameterType, new IOType(`PhetioCapsuleIO<${parameterType.typeName}>`, {
            valueType: PhetioCapsule,
            documentation: 'An array that sends notifications when its values have changed.',
            parameterTypes: [
                parameterType
            ],
            // This is always specified by PhetioCapsule, and will never be this value. Yes, it is odd to have a default value
            // that can never be the actual value, but we thought it would be simplest to reuse the "options" pipeline
            // rather than inventing a new "required" pipeline.
            metadataDefaults: {
                phetioDynamicElementName: null
            },
            // @ts-expect-error The group is a group, not just a PhetioDynamicElementContainer
            addChildElement (capsule, componentName, stateObject) {
                // should throw CouldNotYetDeserializeError if it can't be created yet. Likely that would be because another
                // element in the state needs to be created first, so we will try again on the next iteration of the state
                // setting engine.
                const args = parameterType.stateObjectToCreateElementArguments(stateObject);
                // @ts-expect-error args is of type P, but we can't really communicate that here
                return capsule.create(args, true);
            }
        }));
    }
    return cache.get(parameterType);
};
tandemNamespace.register('PhetioCapsule', PhetioCapsule);
export default PhetioCapsule;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9DYXBzdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIEEgUGhFVC1pTyBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyBhIFBoZXRpb09iamVjdCB0aGF0IGlzIG5vdCBjcmVhdGVkIGR1cmluZyBzaW0gc3RhcnR1cCB0byBwcm92aWRlIFBoRVQtaU8gQVBJXG4gKiB2YWxpZGF0aW9uLCBBUEkgY29tbXVuaWNhdGlvbiAobGlrZSB0byB2aWV3IGluIHN0dWRpbyBiZWZvcmUgY3JlYXRpb24pLCBhbmQgdG8gc3VwcG9ydCBQaEVULWlPIHN0YXRlIGlmIGFwcGxpY2FibGUuXG4gKlxuICogQ29uc3RydWN0aW5nIGEgUGhldGlvQ2Fwc3VsZSBjcmVhdGVzIGEgY29udGFpbmVyIGVuY2Fwc3VsYXRpbmcgYSB3cmFwcGVkIGVsZW1lbnQgdGhhdCBjYW4gYmUgb2YgYW55IHR5cGUuXG4gKlxuICogQ2xpZW50cyBzaG91bGQgdXNlIG15Q2Fwc3VsZS5nZXRFbGVtZW50KCkgaW5zdGVhZCBvZiBzdG9yaW5nIHRoZSBlbGVtZW50IHZhbHVlIGl0c2VsZi5cbiAqXG4gKiBOT1RFOiBCZSBjYXJlZnVsIGFib3V0IHRyZWF0aW5nIHRoZSBkeW5hbWljIGVsZW1lbnQgYXMgYSBzaW5nbGV0b24uIFdoZW4gY3JlYXRpbmcgdGhlIGFyY2hldHlwZSwgcHJvYmxlbXMgY2FuIGFyaXNlXG4gKiBiZWNhdXNlIHRoZSBjYXBzdWxlIGNyZWF0ZXMgdHdvIGluc3RhbmNlcyBvZiB0aGUgZWxlbWVudDogb25lIGFzIHRoZSBhcmNoZXR5cGUgYW5kIG9uZSBhcyB0aGUgaW5zdGFuY2UuIFRoaXMgY2FuXG4gKiByZXN1bHQgaW4gdHJvdWJsZSBsaWtlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9qb2lzdC9pc3N1ZXMvODIxLlxuICpcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKiBAYXV0aG9yIENocmlzIEtsdXNlbmRvcmYgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKi9cblxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xuaW1wb3J0IFN0cmljdE9taXQgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1N0cmljdE9taXQuanMnO1xuaW1wb3J0IElPVHlwZUNhY2hlIGZyb20gJy4vSU9UeXBlQ2FjaGUuanMnO1xuaW1wb3J0IGlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkgZnJvbSAnLi9pc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5LmpzJztcbmltcG9ydCBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciwgeyBDbGVhck9wdGlvbnMsIFBoZXRpb0R5bmFtaWNFbGVtZW50Q29udGFpbmVyT3B0aW9ucyB9IGZyb20gJy4vUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXIuanMnO1xuaW1wb3J0IFBoZXRpb09iamVjdCBmcm9tICcuL1BoZXRpb09iamVjdC5qcyc7XG5pbXBvcnQgVGFuZGVtIGZyb20gJy4vVGFuZGVtLmpzJztcbmltcG9ydCB0YW5kZW1OYW1lc3BhY2UgZnJvbSAnLi90YW5kZW1OYW1lc3BhY2UuanMnO1xuaW1wb3J0IElPVHlwZSBmcm9tICcuL3R5cGVzL0lPVHlwZS5qcyc7XG5cbi8vIGNvbnN0YW50c1xuY29uc3QgREVGQVVMVF9DT05UQUlORVJfU1VGRklYID0gcGhldGlvLlBoZXRpb0lEVXRpbHMuQ0FQU1VMRV9TVUZGSVg7XG5cbi8vIGNhY2hlIGVhY2ggcGFyYW1ldGVyaXplZCBJT1R5cGUgc28gdGhhdCBpdCBpcyBvbmx5IGNyZWF0ZWQgb25jZS5cbmNvbnN0IGNhY2hlID0gbmV3IElPVHlwZUNhY2hlKCk7XG5cbnR5cGUgU2VsZk9wdGlvbnMgPSB7XG5cbiAgLy8gU29tZSBlbGVtZW50cyBsaWtlIEFib3V0RGlhbG9nIGFuZCBQcmVmZXJlbmNlc0RpYWxvZyBwZXJzaXN0IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbSwgYW5kIG9uY2UgY3JlYXRlZFxuICAvLyBhcmUgbmV2ZXIgZGlzcG9zZWQuIFRoaXMgYWxsb3dzIHVzIHRvIGF2b2lkIGV4dGVuc2l2ZSB1bm5lY2Vzc2FyeSB3b3JrIGltcGxlbWVudGluZyBkaXNwb3NlIGZvciB0aGVzZSBlbGVtZW50cy5cbiAgLy8gSWYgdHJ1ZSwgZGlzcG9zZSB0aGUgZWxlbWVudCB3aGVuIGNsZWFyZWQuIElmIHNldCB0byBmYWxzZSwgY2xlYXIoKSB3aWxsIGJhc2ljYWxseSBiZSBhIG5vLW9wLCB3aGljaCBjYW4gYmVcbiAgLy8gdXNlZnVsIGlmIHlvdSB3YW50IHRvIHN1cHBvcnQgbGF6eSBjcmVhdGlvbiwgYnV0IGlmIHRoaXMgaXMgbm90IGEgdHJ1ZSBcImR5bmFtaWMgZWxlbWVudFwiLiBUaGlzIHdpbGwgYWxzbyBjYXVzZSBhblxuICAvLyBhc3NlcnRpb24gaWYgZXZlciB0cnlpbmcgdG8gY2FsbCBkaXNwb3NlRWxlbWVudCBvbiB0aGlzLiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTgxMFxuICBkaXNwb3NlT25DbGVhcj86IGJvb2xlYW47XG5cbiAgLy8gT25seSBhcHBsaWNhYmxlIGlmIGRpc3Bvc2luZyBkdXJpbmcgY2xlYXIuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvIHByZXZlbnQgdGhlIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGVsZW1lbnQgZWFjaFxuICAvLyB0aW1lIFBoRVQtaU8gc3RhdGUgaXMgc2V0LiBEZWZhdWx0cyB0byBmYWxzZS4gVGhpcyBzaG91bGQgb25seSBiZSB0cnVlIGlmIHlvdXIgZHluYW1pYyBlbGVtZW50IGNhbiBiZSBtdXRhdGVkXG4gIC8vIHdpdGggc3RhdGUsIGFuZCBkb2Vzbid0IG5lZWQgY29uc3RydWN0aW9uIHRvIGJlIHJ1biBkdXJpbmcgc3RhdGUgc2V0LiBUaGlzIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSB3aGVuIHN1cHBvcnRpbmdcbiAgLy8gaGV0ZXJvZ2VuZW91cyBjYXBzdWxlcy4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE4MTBcbiAgZGlzcG9zZUNyZWF0ZWRPblN0YXRlU2V0PzogYm9vbGVhbjtcbn07XG5cbi8vIFRoZSBjb250YWluZXIgc3VmZml4IGhhcyB0byBiZSBcIkNhcHN1bGVcIiBvciB3ZSBuZWVkIHRvIGNoYW5nZSBzb21lIGxvZ2ljIGluIFBoZXRpb0lEVXRpbHMuZ2V0QXJjaGV0eXBhbFBoZXRpb0lEXG5leHBvcnQgdHlwZSBQaGV0aW9DYXBzdWxlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgU3RyaWN0T21pdDxQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lck9wdGlvbnMsICdjb250YWluZXJTdWZmaXgnPjtcblxuY2xhc3MgUGhldGlvQ2Fwc3VsZTxUIGV4dGVuZHMgUGhldGlvT2JqZWN0LCBQIGV4dGVuZHMgSW50ZW50aW9uYWxBbnlbXSA9IFtdPiBleHRlbmRzIFBoZXRpb0R5bmFtaWNFbGVtZW50Q29udGFpbmVyPFQsIFA+IHtcbiAgcHJpdmF0ZSBlbGVtZW50OiBUIHwgbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNwb3NlT25DbGVhcjogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNwb3NlQ3JlYXRlZE9uU3RhdGVTZXQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBlbmNhcHN1bGF0ZWQgZWxlbWVudFxuICAgKiBAcGFyYW0gZGVmYXVsdEFyZ3VtZW50cyAtIGFyZ3VtZW50cyBwYXNzZWQgdG8gY3JlYXRlRWxlbWVudCB3aGVuIGNyZWF0aW5nIHRoZSBhcmNoZXR5cGVcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoIGNyZWF0ZUVsZW1lbnQ6ICggdDogVGFuZGVtLCAuLi5wOiBQICkgPT4gVCwgZGVmYXVsdEFyZ3VtZW50czogUCB8ICggKCkgPT4gUCApLCBwcm92aWRlZE9wdGlvbnM/OiBQaGV0aW9DYXBzdWxlT3B0aW9ucyApIHtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8UGhldGlvQ2Fwc3VsZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lck9wdGlvbnM+KCkoIHtcblxuICAgICAgLy8gVGhlIGNhcHN1bGUncyB0YW5kZW0gbmFtZSBtdXN0IGhhdmUgdGhpcyBzdWZmaXgsIGFuZCB0aGUgYmFzZSB0YW5kZW0gbmFtZSBmb3IgaXRzIHdyYXBwZWQgZWxlbWVudFxuICAgICAgLy8gd2lsbCBjb25zaXN0IG9mIHRoZSBjYXBzdWxlJ3MgdGFuZGVtIG5hbWUgd2l0aCB0aGlzIHN1ZmZpeCBzdHJpcHBlZCBvZmYuXG4gICAgICBjb250YWluZXJTdWZmaXg6IERFRkFVTFRfQ09OVEFJTkVSX1NVRkZJWCxcbiAgICAgIGRpc3Bvc2VPbkNsZWFyOiB0cnVlLFxuICAgICAgZGlzcG9zZUNyZWF0ZWRPblN0YXRlU2V0OiBmYWxzZVxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xuXG4gICAgc3VwZXIoIGNyZWF0ZUVsZW1lbnQsIGRlZmF1bHRBcmd1bWVudHMsIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5kaXNwb3NlT25DbGVhciA9IG9wdGlvbnMuZGlzcG9zZU9uQ2xlYXI7XG4gICAgdGhpcy5kaXNwb3NlQ3JlYXRlZE9uU3RhdGVTZXQgPSBvcHRpb25zLmRpc3Bvc2VDcmVhdGVkT25TdGF0ZVNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnQuICBDYWxsZWQgYnkgdGhlIFBoZXRpb1N0YXRlRW5naW5lIHNvIHRoZSBjYXBzdWxlIGVsZW1lbnQgY2FuIGJlIHJlY3JlYXRlZCB3aXRoIHRoZVxuICAgKiBjb3JyZWN0IHN0YXRlLlxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2VFbGVtZW50KCk6IHZvaWQge1xuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuZWxlbWVudCwgJ2Nhbm5vdCBkaXNwb3NlIGlmIGVsZW1lbnQgaXMgbm90IGRlZmluZWQnICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5kaXNwb3NlT25DbGVhciwgJ2Nhbm5vdCBkaXNwb3NlIGlmIGVsZW1lbnQgaXMgbm90IGRpc3Bvc2FibGUnICk7XG4gICAgc3VwZXIuZGlzcG9zZUVsZW1lbnQoIHRoaXMuZWxlbWVudCEgKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIGhhc0VsZW1lbnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudCAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBlbGVtZW50IGlmIGl0IGhhcyBub3QgYmVlbiBjcmVhdGVkIHlldCwgYW5kIHJldHVybnMgaXQuXG4gICAqL1xuICBwdWJsaWMgZ2V0RWxlbWVudCggLi4uYXJnc0ZvckNyZWF0ZUZ1bmN0aW9uOiBQICk6IFQge1xuICAgIGlmICggIXRoaXMuZWxlbWVudCApIHtcbiAgICAgIHRoaXMuY3JlYXRlKCBhcmdzRm9yQ3JlYXRlRnVuY3Rpb24gKTtcbiAgICB9XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5lbGVtZW50ICE9PSBudWxsICk7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudCE7XG4gIH1cblxuICAvKipcbiAgICogUGhldGlvQ2Fwc3VsZSB3aWxsIGRpc3Bvc2UgaXRzIGVsZW1lbnQsIGNsZWFyaW5nIHRoaW5ncyB1cCBhbmQgZ2V0dGluZyByZWFkeSBmb3Igc2V0U3RhdGUsIHVubGVzc1xuICAgKiB0aGlzLmRpc3Bvc2VPbkNsZWFyIG9wdHMgb3V0IG9mIHRoaXMgYmVoYXZpb3IsIGluIHdoaWNoIGNhc2UgdGhlIGVsZW1lbnQgc2hvdWxkIGZ1bGx5IHN1cHBvcnQgbXV0YXRpbmcgaXRzZWxmXG4gICAqIGR1cmluZyBzdGF0ZSBzZXR0aW5nLlxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIGNsZWFyKCBwcm92aWRlZE9wdGlvbnM/OiBDbGVhck9wdGlvbnMgKTogdm9pZCB7XG5cbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPENsZWFyT3B0aW9ucz4oKSgge1xuICAgICAgcGhldGlvU3RhdGU6IG51bGxcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIGlmICggdGhpcy5lbGVtZW50ICYmIHRoaXMuZGlzcG9zZU9uQ2xlYXIgKSB7XG4gICAgICBjb25zdCBhcHBlYXJzSW5TdGF0ZSA9IG9wdGlvbnMucGhldGlvU3RhdGUgJiYgKCBvcHRpb25zLnBoZXRpb1N0YXRlLmhhc093blByb3BlcnR5KCB0aGlzLmVsZW1lbnQucGhldGlvSUQgKSA/PyBmYWxzZSApO1xuXG4gICAgICAvLyBUaGlzIG9wdGlvbiBmb3JjZXMgZGlzcG9zYWwgb24gY2xlYXIsIG90aGVyd2lzZSB3ZSBkb24ndCBjbGVhciBpZiB0aGUgZWxlbWVudCBleGlzdHMgaW4gc3RhdGVcbiAgICAgIGlmICggdGhpcy5kaXNwb3NlQ3JlYXRlZE9uU3RhdGVTZXQgfHwgIWFwcGVhcnNJblN0YXRlICkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VFbGVtZW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLCBjbGllbnRzIHNob3VsZCB1c3VhbGx5IHVzZSBnZXRFbGVtZW50KCkuXG4gICAqIEBwYXJhbSBhcmdzRm9yQ3JlYXRlRnVuY3Rpb25cbiAgICogQHBhcmFtIFtmcm9tU3RhdGVTZXR0aW5nXSAtIHVzZWQgZm9yIHZhbGlkYXRpb24gZHVyaW5nIHN0YXRlIHNldHRpbmcsIHNlZSBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lci5kaXNwb3NlRWxlbWVudCgpIGZvciBkb2N1bWVudGF0aW9uXG4gICAqIChwaGV0LWlvKVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZSggYXJnc0ZvckNyZWF0ZUZ1bmN0aW9uOiBQLCBmcm9tU3RhdGVTZXR0aW5nID0gZmFsc2UgKTogVCB7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5pc1BoZXRpb0luc3RydW1lbnRlZCgpLCAnVE9ETzogc3VwcG9ydCB1bmluc3RydW1lbnRlZCBQaGV0aW9DYXBzdWxlcz8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy90YW5kZW0vaXNzdWVzLzE4NCcgKTtcblxuICAgIGFzc2VydCAmJiB0aGlzLnN1cHBvcnRzRHluYW1pY1N0YXRlICYmIF8uaGFzSW4oIHdpbmRvdywgJ3BoZXQuam9pc3Quc2ltLicgKSAmJlxuICAgIGlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkudmFsdWUgJiYgYXNzZXJ0KCBmcm9tU3RhdGVTZXR0aW5nLFxuICAgICAgJ2R5bmFtaWMgZWxlbWVudHMgc2hvdWxkIG9ubHkgYmUgY3JlYXRlZCBieSB0aGUgc3RhdGUgZW5naW5lIHdoZW4gc2V0dGluZyBzdGF0ZS4nICk7XG5cbiAgICAvLyBjcmVhdGUgd2l0aCBkZWZhdWx0IHN0YXRlIGFuZCBzdWJzdHJ1Y3R1cmUsIGRldGFpbHMgd2lsbCBuZWVkIHRvIGJlIHNldCBieSBzZXR0ZXIgbWV0aG9kcy5cbiAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZUR5bmFtaWNFbGVtZW50KFxuICAgICAgdGhpcy5waGV0aW9EeW5hbWljRWxlbWVudE5hbWUsXG4gICAgICBhcmdzRm9yQ3JlYXRlRnVuY3Rpb24sXG4gICAgICBUYW5kZW0uUEhFVF9JT19FTkFCTEVEID8gdGhpcy5waGV0aW9UeXBlLnBhcmFtZXRlclR5cGVzIVsgMCBdIDogbnVsbCAvLyBEb24ndCBhY2Nlc3MgcGhldGlvVHlwZSBpbiBQaEVUIGJyYW5kXG4gICAgKTtcblxuICAgIHRoaXMubm90aWZ5RWxlbWVudENyZWF0ZWQoIHRoaXMuZWxlbWVudCApO1xuXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJhbWV0cmljIElPVHlwZSBjb25zdHJ1Y3Rvci4gIEdpdmVuIGFuIGVsZW1lbnQgdHlwZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgUGhldGlvQ2Fwc3VsZSBJT1R5cGUuXG4gICAqIFRoaXMgY2FjaGluZyBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIG90aGVyIHBhcmFtZXRyaWMgSU9UeXBlIGNhY2hpbmcgaW1wbGVtZW50YXRpb25zLlxuICAgKiBAcGFyYW0gcGFyYW1ldGVyVHlwZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgUGhldGlvQ2Fwc3VsZUlPID0gPFBhcmFtZXRlclR5cGUgZXh0ZW5kcyBQaGV0aW9PYmplY3QsIFBhcmFtZXRlclN0YXRlVHlwZT4oIHBhcmFtZXRlclR5cGU6IElPVHlwZTxQYXJhbWV0ZXJUeXBlLCBQYXJhbWV0ZXJTdGF0ZVR5cGU+ICk6IElPVHlwZSA9PiB7XG5cbiAgICBpZiAoICFjYWNoZS5oYXMoIHBhcmFtZXRlclR5cGUgKSApIHtcbiAgICAgIGNhY2hlLnNldCggcGFyYW1ldGVyVHlwZSwgbmV3IElPVHlwZTxQaGV0aW9DYXBzdWxlPFBhcmFtZXRlclR5cGU+LCBJbnRlbnRpb25hbEFueT4oIGBQaGV0aW9DYXBzdWxlSU88JHtwYXJhbWV0ZXJUeXBlLnR5cGVOYW1lfT5gLCB7XG4gICAgICAgIHZhbHVlVHlwZTogUGhldGlvQ2Fwc3VsZSxcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ0FuIGFycmF5IHRoYXQgc2VuZHMgbm90aWZpY2F0aW9ucyB3aGVuIGl0cyB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLicsXG4gICAgICAgIHBhcmFtZXRlclR5cGVzOiBbIHBhcmFtZXRlclR5cGUgXSxcblxuICAgICAgICAvLyBUaGlzIGlzIGFsd2F5cyBzcGVjaWZpZWQgYnkgUGhldGlvQ2Fwc3VsZSwgYW5kIHdpbGwgbmV2ZXIgYmUgdGhpcyB2YWx1ZS4gWWVzLCBpdCBpcyBvZGQgdG8gaGF2ZSBhIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgLy8gdGhhdCBjYW4gbmV2ZXIgYmUgdGhlIGFjdHVhbCB2YWx1ZSwgYnV0IHdlIHRob3VnaHQgaXQgd291bGQgYmUgc2ltcGxlc3QgdG8gcmV1c2UgdGhlIFwib3B0aW9uc1wiIHBpcGVsaW5lXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIGludmVudGluZyBhIG5ldyBcInJlcXVpcmVkXCIgcGlwZWxpbmUuXG4gICAgICAgIG1ldGFkYXRhRGVmYXVsdHM6IHsgcGhldGlvRHluYW1pY0VsZW1lbnROYW1lOiBudWxsIH0sXG5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGUgZ3JvdXAgaXMgYSBncm91cCwgbm90IGp1c3QgYSBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lclxuICAgICAgICBhZGRDaGlsZEVsZW1lbnQoIGNhcHN1bGU6IFBoZXRpb0NhcHN1bGU8UGFyYW1ldGVyVHlwZT4sIGNvbXBvbmVudE5hbWU6IHN0cmluZywgc3RhdGVPYmplY3Q6IFBhcmFtZXRlclN0YXRlVHlwZSApIHtcblxuICAgICAgICAgIC8vIHNob3VsZCB0aHJvdyBDb3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IgaWYgaXQgY2FuJ3QgYmUgY3JlYXRlZCB5ZXQuIExpa2VseSB0aGF0IHdvdWxkIGJlIGJlY2F1c2UgYW5vdGhlclxuICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIHN0YXRlIG5lZWRzIHRvIGJlIGNyZWF0ZWQgZmlyc3QsIHNvIHdlIHdpbGwgdHJ5IGFnYWluIG9uIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgc3RhdGVcbiAgICAgICAgICAvLyBzZXR0aW5nIGVuZ2luZS5cbiAgICAgICAgICBjb25zdCBhcmdzID0gcGFyYW1ldGVyVHlwZS5zdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyggc3RhdGVPYmplY3QgKTtcblxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYXJncyBpcyBvZiB0eXBlIFAsIGJ1dCB3ZSBjYW4ndCByZWFsbHkgY29tbXVuaWNhdGUgdGhhdCBoZXJlXG4gICAgICAgICAgcmV0dXJuIGNhcHN1bGUuY3JlYXRlKCBhcmdzLCB0cnVlICk7XG4gICAgICAgIH1cbiAgICAgIH0gKSApO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZS5nZXQoIHBhcmFtZXRlclR5cGUgKSE7XG4gIH07XG59XG5cblxudGFuZGVtTmFtZXNwYWNlLnJlZ2lzdGVyKCAnUGhldGlvQ2Fwc3VsZScsIFBoZXRpb0NhcHN1bGUgKTtcbmV4cG9ydCBkZWZhdWx0IFBoZXRpb0NhcHN1bGU7Il0sIm5hbWVzIjpbIm9wdGlvbml6ZSIsIklPVHlwZUNhY2hlIiwiaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eSIsIlBoZXRpb0R5bmFtaWNFbGVtZW50Q29udGFpbmVyIiwiVGFuZGVtIiwidGFuZGVtTmFtZXNwYWNlIiwiSU9UeXBlIiwiREVGQVVMVF9DT05UQUlORVJfU1VGRklYIiwicGhldGlvIiwiUGhldGlvSURVdGlscyIsIkNBUFNVTEVfU1VGRklYIiwiY2FjaGUiLCJQaGV0aW9DYXBzdWxlIiwiZGlzcG9zZUVsZW1lbnQiLCJhc3NlcnQiLCJlbGVtZW50IiwiZGlzcG9zZU9uQ2xlYXIiLCJoYXNFbGVtZW50IiwiZ2V0RWxlbWVudCIsImFyZ3NGb3JDcmVhdGVGdW5jdGlvbiIsImNyZWF0ZSIsImNsZWFyIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInBoZXRpb1N0YXRlIiwiYXBwZWFyc0luU3RhdGUiLCJoYXNPd25Qcm9wZXJ0eSIsInBoZXRpb0lEIiwiZGlzcG9zZUNyZWF0ZWRPblN0YXRlU2V0IiwiZnJvbVN0YXRlU2V0dGluZyIsImlzUGhldGlvSW5zdHJ1bWVudGVkIiwic3VwcG9ydHNEeW5hbWljU3RhdGUiLCJfIiwiaGFzSW4iLCJ3aW5kb3ciLCJ2YWx1ZSIsImNyZWF0ZUR5bmFtaWNFbGVtZW50IiwicGhldGlvRHluYW1pY0VsZW1lbnROYW1lIiwiUEhFVF9JT19FTkFCTEVEIiwicGhldGlvVHlwZSIsInBhcmFtZXRlclR5cGVzIiwibm90aWZ5RWxlbWVudENyZWF0ZWQiLCJjcmVhdGVFbGVtZW50IiwiZGVmYXVsdEFyZ3VtZW50cyIsImNvbnRhaW5lclN1ZmZpeCIsIlBoZXRpb0NhcHN1bGVJTyIsInBhcmFtZXRlclR5cGUiLCJoYXMiLCJzZXQiLCJ0eXBlTmFtZSIsInZhbHVlVHlwZSIsImRvY3VtZW50YXRpb24iLCJtZXRhZGF0YURlZmF1bHRzIiwiYWRkQ2hpbGRFbGVtZW50IiwiY2Fwc3VsZSIsImNvbXBvbmVudE5hbWUiLCJzdGF0ZU9iamVjdCIsImFyZ3MiLCJzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyIsImdldCIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBRUQsT0FBT0EsZUFBZSxrQ0FBa0M7QUFHeEQsT0FBT0MsaUJBQWlCLG1CQUFtQjtBQUMzQyxPQUFPQyxrQ0FBa0Msb0NBQW9DO0FBQzdFLE9BQU9DLG1DQUEyRixxQ0FBcUM7QUFFdkksT0FBT0MsWUFBWSxjQUFjO0FBQ2pDLE9BQU9DLHFCQUFxQix1QkFBdUI7QUFDbkQsT0FBT0MsWUFBWSxvQkFBb0I7QUFFdkMsWUFBWTtBQUNaLE1BQU1DLDJCQUEyQkMsT0FBT0MsYUFBYSxDQUFDQyxjQUFjO0FBRXBFLG1FQUFtRTtBQUNuRSxNQUFNQyxRQUFRLElBQUlWO0FBcUJsQixJQUFBLEFBQU1XLGdCQUFOLE1BQU1BLHNCQUErRVQ7SUE0Qm5GOzs7R0FH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