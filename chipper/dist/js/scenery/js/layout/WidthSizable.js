// Copyright 2021-2024, University of Colorado Boulder
/**
 * WidthSizable is a trait that provides a minimum and preferred width. The minimum width is set by the component,
 * so that layout containers could know how "small" the component can be made. The preferred width is set by the
 * layout container, and the component should adjust its size so that it takes up that width.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import TinyProperty from '../../../axon/js/TinyProperty.js';
import memoize from '../../../phet-core/js/memoize.js';
import { DelayedMutate, REQUIRES_BOUNDS_OPTION_KEYS, scenery } from '../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
export const WIDTH_SIZABLE_OPTION_KEYS = [
    'preferredWidth',
    'minimumWidth',
    'localPreferredWidth',
    'localMinimumWidth',
    'widthSizable'
];
// IMPORTANT: If you're combining this in, typically don't pass options that WidthSizable would take through the
// constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
// values yet. If you're making something WidthSizable, please use a later mutate() to pass these options through.
// They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
// is yet passing those options through.
const WidthSizable = memoize((Type)=>{
    const WidthSizableTrait = DelayedMutate('WidthSizable', WIDTH_SIZABLE_OPTION_KEYS, class WidthSizableTrait extends Type {
        get preferredWidth() {
            assert && assert(this.preferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            return this.preferredWidthProperty.value;
        }
        set preferredWidth(value) {
            assert && assert(this.preferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'preferredWidth should be null or a non-negative finite number');
            this.preferredWidthProperty.value = value;
        }
        get localPreferredWidth() {
            assert && assert(this.localPreferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            return this.localPreferredWidthProperty.value;
        }
        set localPreferredWidth(value) {
            assert && assert(this.localPreferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'localPreferredWidth should be null or a non-negative finite number');
            this.localPreferredWidthProperty.value = value;
        }
        get minimumWidth() {
            assert && assert(this.minimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            return this.minimumWidthProperty.value;
        }
        set minimumWidth(value) {
            assert && assert(this.minimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value));
            this.minimumWidthProperty.value = value;
        }
        get localMinimumWidth() {
            assert && assert(this.localMinimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            return this.localMinimumWidthProperty.value;
        }
        set localMinimumWidth(value) {
            assert && assert(this.localMinimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value));
            this.localMinimumWidthProperty.value = value;
        }
        get widthSizable() {
            assert && assert(this.isWidthResizableProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            return this.isWidthResizableProperty.value;
        }
        set widthSizable(value) {
            assert && assert(this.isWidthResizableProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
            this.isWidthResizableProperty.value = value;
        }
        get extendsWidthSizable() {
            return true;
        }
        validateLocalPreferredWidth() {
            if (assert) {
                const currentWidth = this.localWidth;
                const effectiveMinimumWidth = this.localMinimumWidth === null ? currentWidth : this.localMinimumWidth;
                const idealWidth = this.localPreferredWidth === null ? effectiveMinimumWidth : this.localPreferredWidth;
                // Handle non-finite values with exact equality
                assert(idealWidth === currentWidth || Math.abs(idealWidth - currentWidth) < 1e-7);
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculateLocalPreferredWidth() {
            return this.matrix.isAligned() && this.preferredWidth !== null ? Math.abs(this.transform.inverseDeltaX(this.preferredWidth)) : null;
        }
        // Provides a hook to Sizable, since we'll need to cross-link this to also try updating the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _onReentrantPreferredWidth() {
            this._updateLocalPreferredWidthListener();
        }
        _updateLocalPreferredWidth() {
            assert && this.auditMaxDimensions();
            if (!this._preferredSizeChanging) {
                this._preferredSizeChanging = true;
                // Since the local "preferred" size is the one that we'll want to continue to update if we experience
                // reentrancy (since we treat the non-local version as the ground truth), we'll loop here until we didn't get
                // an attempt to change it. This will ensure that after changes, we'll have a consistent preferred and
                // localPreferred size.
                do {
                    this._preferredSizeChangeAttemptDuringLock = false;
                    const localPreferredWidth = this._calculateLocalPreferredWidth();
                    if (this.localPreferredWidthProperty.value === null || localPreferredWidth === null || Math.abs(this.localPreferredWidthProperty.value - localPreferredWidth) > CHANGE_POSITION_THRESHOLD) {
                        this.localPreferredWidthProperty.value = localPreferredWidth;
                    }
                }while (this._preferredSizeChangeAttemptDuringLock)
                this._preferredSizeChanging = false;
            } else {
                this._preferredSizeChangeAttemptDuringLock = true;
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculatePreferredWidth() {
            return this.matrix.isAligned() && this.localPreferredWidth !== null ? Math.abs(this.transform.transformDeltaX(this.localPreferredWidth)) : null;
        }
        _updatePreferredWidth() {
            if (!this._preferredSizeChanging) {
                this._preferredSizeChanging = true;
                this._preferredSizeChangeAttemptDuringLock = false;
                const preferredWidth = this._calculatePreferredWidth();
                if (this.preferredWidthProperty.value === null || preferredWidth === null || Math.abs(this.preferredWidthProperty.value - preferredWidth) > CHANGE_POSITION_THRESHOLD) {
                    this.preferredWidthProperty.value = preferredWidth;
                }
                this._preferredSizeChanging = false;
                // Here, in the case of reentrance, we'll actually want to switch to updating the local preferred size, since
                // given any other changes it should be the primary one to change.
                if (this._preferredSizeChangeAttemptDuringLock) {
                    this._onReentrantPreferredWidth();
                }
            } else {
                this._preferredSizeChangeAttemptDuringLock = true;
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculateLocalMinimumWidth() {
            return this.matrix.isAligned() && this.minimumWidth !== null ? Math.abs(this.transform.inverseDeltaX(this.minimumWidth)) : null;
        }
        // @mixin-protected - made public for use in the mixin only
        _onReentrantLocalMinimumWidth() {
            this._updateMinimumWidthListener();
        }
        _updateLocalMinimumWidth() {
            if (!this._minimumSizeChanging) {
                this._minimumSizeChanging = true;
                const localMinimumWidth = this._calculateLocalMinimumWidth();
                this._minimumSizeChangeAttemptDuringLock = false;
                if (this.localMinimumWidthProperty.value === null || localMinimumWidth === null || Math.abs(this.localMinimumWidthProperty.value - localMinimumWidth) > CHANGE_POSITION_THRESHOLD) {
                    this.localMinimumWidthProperty.value = localMinimumWidth;
                }
                this._minimumSizeChanging = false;
                // Here, in the case of reentrance, we'll actually want to switch to updating the non-local minimum size, since
                // given any other changes it should be the primary one to change.
                if (this._minimumSizeChangeAttemptDuringLock) {
                    this._onReentrantLocalMinimumWidth();
                }
            } else {
                this._minimumSizeChangeAttemptDuringLock = true;
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculateMinimumWidth() {
            return this.matrix.isAligned() && this.localMinimumWidth !== null ? Math.abs(this.transform.transformDeltaX(this.localMinimumWidth)) : null;
        }
        _updateMinimumWidth() {
            if (!this._minimumSizeChanging) {
                this._minimumSizeChanging = true;
                // Since the non-local "minimum" size is the one that we'll want to continue to update if we experience
                // reentrancy (since we treat the local version as the ground truth), we'll loop here until we didn't get
                // an attempt to change it. This will ensure that after changes, we'll have a consistent minimum and
                // localMinimum size.
                do {
                    this._minimumSizeChangeAttemptDuringLock = false;
                    const minimumWidth = this._calculateMinimumWidth();
                    if (this.minimumWidthProperty.value === null || minimumWidth === null || Math.abs(this.minimumWidthProperty.value - minimumWidth) > CHANGE_POSITION_THRESHOLD) {
                        this.minimumWidthProperty.value = minimumWidth;
                    }
                }while (this._minimumSizeChangeAttemptDuringLock)
                this._minimumSizeChanging = false;
            } else {
                this._minimumSizeChangeAttemptDuringLock = true;
            }
        }
        mutate(options) {
            return super.mutate(options);
        }
        // IMPORTANT: If you're combining this in, typically don't pass options that WidthSizable would take through the
        // constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
        // values yet. If you're making something WidthSizable, please use a later mutate() to pass these options through.
        // They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
        // is yet passing those options through.
        constructor(...args){
            super(...args), // parent/local preferred/minimum Properties. See the options above for more documentation
            this.preferredWidthProperty = new TinyProperty(null), this.minimumWidthProperty = new TinyProperty(null), this.localPreferredWidthProperty = new TinyProperty(null), this.localMinimumWidthProperty = new TinyProperty(null), this.isWidthResizableProperty = new TinyProperty(true), // Flags so that we can change one (parent/local) value and not enter an infinite loop changing the others.
            // We want to lock out all other local or non-local preferred minimum sizes, whether in HeightSizable or WidthSizable
            // NOTE: We are merging declarations between HeightSizable and WidthSizable. If Sizable is used these flags
            // will be shared by both HeightSizable and WidthSizable.
            // @mixin-protected - made public for use in the mixin only
            this._preferredSizeChanging = false, // @mixin-protected - made public for use in the mixin only
            this._minimumSizeChanging = false, // We'll need to detect reentrancy when setting the dual of the preferred/minimum properties (e.g. local vs parent).
            // If we get a reentrant case, we'll need to detect it and clear things up at the end (updating the minimum size
            // in the parent coordinate frame, and the preferred size in the local coordinate frame).
            // An example is if the minimum size is set, and that triggers a listener that UPDATES something that changes the
            // minimum size, we'll need to make sure that the local minimum size is updated AFTER everything has happened.
            // These locks are used to detect these cases, and then run the appropriate updates afterward to make sure that the
            // local and parent values are in sync (based on the transform used).
            // @mixin-protected - made public for use in the mixin only
            this._preferredSizeChangeAttemptDuringLock = false, // @mixin-protected - made public for use in the mixin only
            this._minimumSizeChangeAttemptDuringLock = false;
            this._updatePreferredWidthListener = this._updatePreferredWidth.bind(this);
            this._updateLocalPreferredWidthListener = this._updateLocalPreferredWidth.bind(this);
            this._updateMinimumWidthListener = this._updateMinimumWidth.bind(this);
            this._updateLocalMinimumWidthListener = this._updateLocalMinimumWidth.bind(this);
            // Update the opposite of parent/local when one changes
            this.preferredWidthProperty.lazyLink(this._updateLocalPreferredWidthListener);
            this.localPreferredWidthProperty.lazyLink(this._updatePreferredWidthListener);
            this.minimumWidthProperty.lazyLink(this._updateLocalMinimumWidthListener);
            this.localMinimumWidthProperty.lazyLink(this._updateMinimumWidthListener);
            // On a transform change, keep our local minimum (presumably unchanged), and our parent preferred size
            this.transformEmitter.addListener(this._updateLocalPreferredWidthListener);
            // On a transform change this should update the minimum
            this.transformEmitter.addListener(this._updateMinimumWidthListener);
        }
    });
    // If we're extending into a Node type, include option keys
    if (WidthSizableTrait.prototype._mutatorKeys) {
        const existingKeys = WidthSizableTrait.prototype._mutatorKeys;
        const newKeys = WIDTH_SIZABLE_OPTION_KEYS;
        const indexOfBoundsBasedOptions = existingKeys.indexOf(REQUIRES_BOUNDS_OPTION_KEYS[0]);
        WidthSizableTrait.prototype._mutatorKeys = [
            ...existingKeys.slice(0, indexOfBoundsBasedOptions),
            ...newKeys,
            ...existingKeys.slice(indexOfBoundsBasedOptions)
        ];
    }
    return WidthSizableTrait;
});
const isWidthSizable = (node)=>{
    return node.widthSizable;
};
const extendsWidthSizable = (node)=>{
    return node.extendsWidthSizable;
};
scenery.register('WidthSizable', WidthSizable);
export default WidthSizable;
export { isWidthSizable, extendsWidthSizable };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbGF5b3V0L1dpZHRoU2l6YWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBXaWR0aFNpemFibGUgaXMgYSB0cmFpdCB0aGF0IHByb3ZpZGVzIGEgbWluaW11bSBhbmQgcHJlZmVycmVkIHdpZHRoLiBUaGUgbWluaW11bSB3aWR0aCBpcyBzZXQgYnkgdGhlIGNvbXBvbmVudCxcbiAqIHNvIHRoYXQgbGF5b3V0IGNvbnRhaW5lcnMgY291bGQga25vdyBob3cgXCJzbWFsbFwiIHRoZSBjb21wb25lbnQgY2FuIGJlIG1hZGUuIFRoZSBwcmVmZXJyZWQgd2lkdGggaXMgc2V0IGJ5IHRoZVxuICogbGF5b3V0IGNvbnRhaW5lciwgYW5kIHRoZSBjb21wb25lbnQgc2hvdWxkIGFkanVzdCBpdHMgc2l6ZSBzbyB0aGF0IGl0IHRha2VzIHVwIHRoYXQgd2lkdGguXG4gKlxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxuICovXG5cbmltcG9ydCBUaW55UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UaW55UHJvcGVydHkuanMnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lbW9pemUuanMnO1xuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9Db25zdHJ1Y3Rvci5qcyc7XG5pbXBvcnQgSW50ZW50aW9uYWxBbnkgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcbmltcG9ydCB7IERlbGF5ZWRNdXRhdGUsIE5vZGUsIFJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUywgc2NlbmVyeSB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xuXG4vLyBQb3NpdGlvbiBjaGFuZ2VzIHNtYWxsZXIgdGhhbiB0aGlzIHdpbGwgYmUgaWdub3JlZFxuY29uc3QgQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCA9IDFlLTk7XG5cbmV4cG9ydCBjb25zdCBXSURUSF9TSVpBQkxFX09QVElPTl9LRVlTID0gW1xuICAncHJlZmVycmVkV2lkdGgnLFxuICAnbWluaW11bVdpZHRoJyxcbiAgJ2xvY2FsUHJlZmVycmVkV2lkdGgnLFxuICAnbG9jYWxNaW5pbXVtV2lkdGgnLFxuICAnd2lkdGhTaXphYmxlJ1xuXTtcblxuZXhwb3J0IHR5cGUgV2lkdGhTaXphYmxlT3B0aW9ucyA9IHtcbiAgLy8gU2V0cyB0aGUgcHJlZmVycmVkIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZS4gTm9kZXMgdGhhdCBpbXBsZW1lbnQgdGhpcyB3aWxsIGF0dGVtcHQgdG8ga2VlcFxuICAvLyB0aGVpciBgbm9kZS53aWR0aGAgYXQgdGhpcyB2YWx1ZS4gSWYgbnVsbCwgdGhlIG5vZGUgd2lsbCBsaWtlbHkgc2V0IGl0cyBjb25maWd1cmF0aW9uIHRvIHRoZSBtaW5pbXVtIHdpZHRoLlxuICAvLyBOT1RFOiBjaGFuZ2luZyB0aGlzIG9yIGxvY2FsUHJlZmVycmVkV2lkdGggd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxuICAvLyBOT1RFOiBwcmVmZXJyZWRXaWR0aCBpcyBub3QgZ3VhcmFudGVlZCBjdXJyZW50bHkuIFRoZSBjb21wb25lbnQgbWF5IGVuZCB1cCBoYXZpbmcgYSBzbWFsbGVyIG9yIGxhcmdlciBzaXplXG4gIHByZWZlcnJlZFdpZHRoPzogbnVtYmVyIHwgbnVsbDtcblxuICAvLyBTZXRzIHRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZS4gVXN1YWxseSBub3QgZGlyZWN0bHkgc2V0IGJ5IGEgY2xpZW50LlxuICAvLyBVc3VhbGx5IGEgcmVzaXphYmxlIE5vZGUgd2lsbCBzZXQgaXRzIGxvY2FsTWluaW11bVdpZHRoIChhbmQgdGhhdCB3aWxsIGdldCB0cmFuc2ZlcnJlZCB0byB0aGlzIHZhbHVlIGluIHRoZVxuICAvLyBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZSkuXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgbG9jYWxNaW5pbXVtV2lkdGggd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxuICAvLyBOT1RFOiB3aGVuIHRoZSBOb2RlJ3MgdHJhbnNmb3JtIGlzIHVwZGF0ZWQsIHRoaXMgdmFsdWUgaXMgcmVjb21wdXRlZCBiYXNlZCBvbiBsb2NhbE1pbmltdW1XaWR0aFxuICBtaW5pbXVtV2lkdGg/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8vIFNldHMgdGhlIHByZWZlcnJlZCB3aWR0aCBvZiB0aGUgTm9kZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZS5cbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBwcmVmZXJyZWRXaWR0aCB3aWxsIGFkanVzdCB0aGUgb3RoZXIuXG4gIC8vIE5PVEU6IHdoZW4gdGhlIE5vZGUncyB0cmFuc2Zvcm0gaXMgdXBkYXRlZCwgdGhpcyB2YWx1ZSBpcyByZWNvbXB1dGVkIGJhc2VkIG9uIHByZWZlcnJlZFdpZHRoXG4gIC8vIE5PVEU6IGxvY2FsUHJlZmVycmVkV2lkdGggaXMgbm90IGd1YXJhbnRlZWQgY3VycmVudGx5LiBUaGUgY29tcG9uZW50IG1heSBlbmQgdXAgaGF2aW5nIGEgc21hbGxlciBvciBsYXJnZXIgc2l6ZVxuICBsb2NhbFByZWZlcnJlZFdpZHRoPzogbnVtYmVyIHwgbnVsbDtcblxuICAvLyBTZXRzIHRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lLiBVc3VhbGx5IHNldCBieSB0aGUgcmVzaXphYmxlIE5vZGUgaXRzZWxmIHRvXG4gIC8vIGluZGljYXRlIHdoYXQgcHJlZmVycmVkIHNpemVzIGFyZSBwb3NzaWJsZS5cbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBtaW5pbXVtV2lkdGggd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxuICBsb2NhbE1pbmltdW1XaWR0aD86IG51bWJlciB8IG51bGw7XG5cbiAgLy8gV2hldGhlciB0aGlzIGNvbXBvbmVudCB3aWxsIGhhdmUgaXRzIHByZWZlcnJlZCBzaXplIHNldCBieSB0aGluZ3MgbGlrZSBsYXlvdXQgY29udGFpbmVycy4gSWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsXG4gIC8vIGl0J3MgcmVjb21tZW5kZWQgdG8gc2V0IHNvbWUgc29ydCBvZiBwcmVmZXJyZWQgc2l6ZSAoc28gdGhhdCBpdCB3b24ndCBnbyB0byAwKVxuICB3aWR0aFNpemFibGU/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgVFdpZHRoU2l6YWJsZSA9IHtcbiAgcmVhZG9ubHkgcHJlZmVycmVkV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+O1xuICByZWFkb25seSBtaW5pbXVtV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+O1xuICByZWFkb25seSBsb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgcmVhZG9ubHkgbG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+O1xuICByZWFkb25seSBpc1dpZHRoUmVzaXphYmxlUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxib29sZWFuPjtcbiAgcHJlZmVycmVkV2lkdGg6IG51bWJlciB8IG51bGw7XG4gIGxvY2FsUHJlZmVycmVkV2lkdGg6IG51bWJlciB8IG51bGw7XG4gIG1pbmltdW1XaWR0aDogbnVtYmVyIHwgbnVsbDtcbiAgbG9jYWxNaW5pbXVtV2lkdGg6IG51bWJlciB8IG51bGw7XG4gIHdpZHRoU2l6YWJsZTogYm9vbGVhbjtcbiAgZ2V0IGV4dGVuZHNXaWR0aFNpemFibGUoKTogYm9vbGVhbjtcbiAgdmFsaWRhdGVMb2NhbFByZWZlcnJlZFdpZHRoKCk6IHZvaWQ7XG5cbiAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgX3ByZWZlcnJlZFNpemVDaGFuZ2luZzogYm9vbGVhbjtcbiAgX21pbmltdW1TaXplQ2hhbmdpbmc6IGJvb2xlYW47XG4gIF9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2s6IGJvb2xlYW47XG4gIF9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrOiBib29sZWFuO1xuICBfdXBkYXRlUHJlZmVycmVkV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBfdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogbnVtYmVyIHwgbnVsbDtcbiAgX29uUmVlbnRyYW50UHJlZmVycmVkV2lkdGgoKTogdm9pZDtcbiAgX2NhbGN1bGF0ZVByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGw7XG4gIF9jYWxjdWxhdGVMb2NhbE1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsO1xuICBfb25SZWVudHJhbnRMb2NhbE1pbmltdW1XaWR0aCgpOiB2b2lkO1xuICBfY2FsY3VsYXRlTWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGw7XG59O1xuXG4vLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IFdpZHRoU2l6YWJsZSB3b3VsZCB0YWtlIHRocm91Z2ggdGhlXG4vLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxuLy8gdmFsdWVzIHlldC4gSWYgeW91J3JlIG1ha2luZyBzb21ldGhpbmcgV2lkdGhTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXG4vLyBUaGV5IFdJTEwgYmUgY2F1Z2h0IGJ5IGFzc2VydGlvbnMgaWYgc29tZW9uZSBhZGRzIG9uZSBvZiB0aG9zZSBvcHRpb25zLCBidXQgaXQgY291bGQgYmUgYSBzaWxlbnQgYnVnIGlmIG5vIG9uZVxuLy8gaXMgeWV0IHBhc3NpbmcgdGhvc2Ugb3B0aW9ucyB0aHJvdWdoLlxuY29uc3QgV2lkdGhTaXphYmxlID0gbWVtb2l6ZSggPFN1cGVyVHlwZSBleHRlbmRzIENvbnN0cnVjdG9yPE5vZGU+PiggVHlwZTogU3VwZXJUeXBlICk6IFN1cGVyVHlwZSAmIENvbnN0cnVjdG9yPFRXaWR0aFNpemFibGU+ID0+IHtcbiAgY29uc3QgV2lkdGhTaXphYmxlVHJhaXQgPSBEZWxheWVkTXV0YXRlKCAnV2lkdGhTaXphYmxlJywgV0lEVEhfU0laQUJMRV9PUFRJT05fS0VZUyxcbiAgICBjbGFzcyBXaWR0aFNpemFibGVUcmFpdCBleHRlbmRzIFR5cGUgaW1wbGVtZW50cyBUV2lkdGhTaXphYmxlIHtcblxuICAgICAgLy8gcGFyZW50L2xvY2FsIHByZWZlcnJlZC9taW5pbXVtIFByb3BlcnRpZXMuIFNlZSB0aGUgb3B0aW9ucyBhYm92ZSBmb3IgbW9yZSBkb2N1bWVudGF0aW9uXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcHJlZmVycmVkV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xuICAgICAgcHVibGljIHJlYWRvbmx5IG1pbmltdW1XaWR0aFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xuICAgICAgcHVibGljIHJlYWRvbmx5IGlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eTogVGlueVByb3BlcnR5PGJvb2xlYW4+ID0gbmV3IFRpbnlQcm9wZXJ0eTxib29sZWFuPiggdHJ1ZSApO1xuXG4gICAgICAvLyBGbGFncyBzbyB0aGF0IHdlIGNhbiBjaGFuZ2Ugb25lIChwYXJlbnQvbG9jYWwpIHZhbHVlIGFuZCBub3QgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBjaGFuZ2luZyB0aGUgb3RoZXJzLlxuICAgICAgLy8gV2Ugd2FudCB0byBsb2NrIG91dCBhbGwgb3RoZXIgbG9jYWwgb3Igbm9uLWxvY2FsIHByZWZlcnJlZCBtaW5pbXVtIHNpemVzLCB3aGV0aGVyIGluIEhlaWdodFNpemFibGUgb3IgV2lkdGhTaXphYmxlXG4gICAgICAvLyBOT1RFOiBXZSBhcmUgbWVyZ2luZyBkZWNsYXJhdGlvbnMgYmV0d2VlbiBIZWlnaHRTaXphYmxlIGFuZCBXaWR0aFNpemFibGUuIElmIFNpemFibGUgaXMgdXNlZCB0aGVzZSBmbGFnc1xuICAgICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgYm90aCBIZWlnaHRTaXphYmxlIGFuZCBXaWR0aFNpemFibGUuXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICAgICAgcHVibGljIF9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX21pbmltdW1TaXplQ2hhbmdpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gV2UnbGwgbmVlZCB0byBkZXRlY3QgcmVlbnRyYW5jeSB3aGVuIHNldHRpbmcgdGhlIGR1YWwgb2YgdGhlIHByZWZlcnJlZC9taW5pbXVtIHByb3BlcnRpZXMgKGUuZy4gbG9jYWwgdnMgcGFyZW50KS5cbiAgICAgIC8vIElmIHdlIGdldCBhIHJlZW50cmFudCBjYXNlLCB3ZSdsbCBuZWVkIHRvIGRldGVjdCBpdCBhbmQgY2xlYXIgdGhpbmdzIHVwIGF0IHRoZSBlbmQgKHVwZGF0aW5nIHRoZSBtaW5pbXVtIHNpemVcbiAgICAgIC8vIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZSwgYW5kIHRoZSBwcmVmZXJyZWQgc2l6ZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZSkuXG4gICAgICAvLyBBbiBleGFtcGxlIGlzIGlmIHRoZSBtaW5pbXVtIHNpemUgaXMgc2V0LCBhbmQgdGhhdCB0cmlnZ2VycyBhIGxpc3RlbmVyIHRoYXQgVVBEQVRFUyBzb21ldGhpbmcgdGhhdCBjaGFuZ2VzIHRoZVxuICAgICAgLy8gbWluaW11bSBzaXplLCB3ZSdsbCBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBsb2NhbCBtaW5pbXVtIHNpemUgaXMgdXBkYXRlZCBBRlRFUiBldmVyeXRoaW5nIGhhcyBoYXBwZW5lZC5cbiAgICAgIC8vIFRoZXNlIGxvY2tzIGFyZSB1c2VkIHRvIGRldGVjdCB0aGVzZSBjYXNlcywgYW5kIHRoZW4gcnVuIHRoZSBhcHByb3ByaWF0ZSB1cGRhdGVzIGFmdGVyd2FyZCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgIC8vIGxvY2FsIGFuZCBwYXJlbnQgdmFsdWVzIGFyZSBpbiBzeW5jIChiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIHVzZWQpLlxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICAgICAgcHVibGljIF9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XG5cbiAgICAgIC8vIEV4cG9zZSBsaXN0ZW5lcnMsIHNvIHRoYXQgd2UnbGwgYmUgYWJsZSB0byBob29rIHRoZW0gdXAgdG8gdGhlIG9wcG9zaXRlIGRpbWVuc2lvbiBpbiBTaXphYmxlXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICAgICAgcHVibGljIF91cGRhdGVQcmVmZXJyZWRXaWR0aExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICAgICAgcHVibGljIF91cGRhdGVMb2NhbE1pbmltdW1XaWR0aExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gICAgICAvLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IFdpZHRoU2l6YWJsZSB3b3VsZCB0YWtlIHRocm91Z2ggdGhlXG4gICAgICAvLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxuICAgICAgLy8gdmFsdWVzIHlldC4gSWYgeW91J3JlIG1ha2luZyBzb21ldGhpbmcgV2lkdGhTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXG4gICAgICAvLyBUaGV5IFdJTEwgYmUgY2F1Z2h0IGJ5IGFzc2VydGlvbnMgaWYgc29tZW9uZSBhZGRzIG9uZSBvZiB0aG9zZSBvcHRpb25zLCBidXQgaXQgY291bGQgYmUgYSBzaWxlbnQgYnVnIGlmIG5vIG9uZVxuICAgICAgLy8gaXMgeWV0IHBhc3NpbmcgdGhvc2Ugb3B0aW9ucyB0aHJvdWdoLlxuICAgICAgcHVibGljIGNvbnN0cnVjdG9yKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkge1xuICAgICAgICBzdXBlciggLi4uYXJncyApO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWZlcnJlZFdpZHRoTGlzdGVuZXIgPSB0aGlzLl91cGRhdGVQcmVmZXJyZWRXaWR0aC5iaW5kKCB0aGlzICk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGhMaXN0ZW5lciA9IHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGguYmluZCggdGhpcyApO1xuICAgICAgICB0aGlzLl91cGRhdGVNaW5pbXVtV2lkdGhMaXN0ZW5lciA9IHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aC5iaW5kKCB0aGlzICk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoTGlzdGVuZXIgPSB0aGlzLl91cGRhdGVMb2NhbE1pbmltdW1XaWR0aC5iaW5kKCB0aGlzICk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBvcHBvc2l0ZSBvZiBwYXJlbnQvbG9jYWwgd2hlbiBvbmUgY2hhbmdlc1xuICAgICAgICB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGhMaXN0ZW5lciApO1xuICAgICAgICB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlUHJlZmVycmVkV2lkdGhMaXN0ZW5lciApO1xuICAgICAgICB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMb2NhbE1pbmltdW1XaWR0aExpc3RlbmVyICk7XG4gICAgICAgIHRoaXMubG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXIgKTtcblxuICAgICAgICAvLyBPbiBhIHRyYW5zZm9ybSBjaGFuZ2UsIGtlZXAgb3VyIGxvY2FsIG1pbmltdW0gKHByZXN1bWFibHkgdW5jaGFuZ2VkKSwgYW5kIG91ciBwYXJlbnQgcHJlZmVycmVkIHNpemVcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIgKTtcbiAgICAgICAgLy8gT24gYSB0cmFuc2Zvcm0gY2hhbmdlIHRoaXMgc2hvdWxkIHVwZGF0ZSB0aGUgbWluaW11bVxuICAgICAgICB0aGlzLnRyYW5zZm9ybUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyICk7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBnZXQgcHJlZmVycmVkV2lkdGgoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eSxcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgc2V0IHByZWZlcnJlZFdpZHRoKCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LFxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxuICAgICAgICAgICdwcmVmZXJyZWRXaWR0aCBzaG91bGQgYmUgbnVsbCBvciBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgbnVtYmVyJyApO1xuXG4gICAgICAgIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgZ2V0IGxvY2FsUHJlZmVycmVkV2lkdGgoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LFxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBzZXQgbG9jYWxQcmVmZXJyZWRXaWR0aCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LFxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxuICAgICAgICAgICdsb2NhbFByZWZlcnJlZFdpZHRoIHNob3VsZCBiZSBudWxsIG9yIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXInICk7XG5cbiAgICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHVibGljIGdldCBtaW5pbXVtV2lkdGgoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubWluaW11bVdpZHRoUHJvcGVydHksXG4gICAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgc2V0IG1pbmltdW1XaWR0aCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubWluaW11bVdpZHRoUHJvcGVydHksXG4gICAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XG5cbiAgICAgICAgdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgZ2V0IGxvY2FsTWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGwge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHksXG4gICAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBzZXQgbG9jYWxNaW5pbXVtV2lkdGgoIHZhbHVlOiBudW1iZXIgfCBudWxsICkge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHksXG4gICAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XG5cbiAgICAgICAgdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgd2lkdGhTaXphYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eSxcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNXaWR0aFJlc2l6YWJsZVByb3BlcnR5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IHdpZHRoU2l6YWJsZSggdmFsdWU6IGJvb2xlYW4gKSB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNXaWR0aFJlc2l6YWJsZVByb3BlcnR5LFxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICB0aGlzLmlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGV4dGVuZHNXaWR0aFNpemFibGUoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgIHB1YmxpYyB2YWxpZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogdm9pZCB7XG4gICAgICAgIGlmICggYXNzZXJ0ICkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRoaXMubG9jYWxXaWR0aDtcbiAgICAgICAgICBjb25zdCBlZmZlY3RpdmVNaW5pbXVtV2lkdGggPSB0aGlzLmxvY2FsTWluaW11bVdpZHRoID09PSBudWxsID8gY3VycmVudFdpZHRoIDogdGhpcy5sb2NhbE1pbmltdW1XaWR0aDtcbiAgICAgICAgICBjb25zdCBpZGVhbFdpZHRoID0gdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoID09PSBudWxsID8gZWZmZWN0aXZlTWluaW11bVdpZHRoIDogdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIG5vbi1maW5pdGUgdmFsdWVzIHdpdGggZXhhY3QgZXF1YWxpdHlcbiAgICAgICAgICBhc3NlcnQoIGlkZWFsV2lkdGggPT09IGN1cnJlbnRXaWR0aCB8fCBNYXRoLmFicyggaWRlYWxXaWR0aCAtIGN1cnJlbnRXaWR0aCApIDwgMWUtNyApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfY2FsY3VsYXRlTG9jYWxQcmVmZXJyZWRXaWR0aCgpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5wcmVmZXJyZWRXaWR0aCAhPT0gbnVsbCApXG4gICAgICAgICAgICAgICA/IE1hdGguYWJzKCB0aGlzLnRyYW5zZm9ybS5pbnZlcnNlRGVsdGFYKCB0aGlzLnByZWZlcnJlZFdpZHRoICkgKVxuICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm92aWRlcyBhIGhvb2sgdG8gU2l6YWJsZSwgc2luY2Ugd2UnbGwgbmVlZCB0byBjcm9zcy1saW5rIHRoaXMgdG8gYWxzbyB0cnkgdXBkYXRpbmcgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfb25SZWVudHJhbnRQcmVmZXJyZWRXaWR0aCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aExpc3RlbmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHByaXZhdGUgX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogdm9pZCB7XG4gICAgICAgIGFzc2VydCAmJiB0aGlzLmF1ZGl0TWF4RGltZW5zaW9ucygpO1xuXG4gICAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gU2luY2UgdGhlIGxvY2FsIFwicHJlZmVycmVkXCIgc2l6ZSBpcyB0aGUgb25lIHRoYXQgd2UnbGwgd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgaWYgd2UgZXhwZXJpZW5jZVxuICAgICAgICAgIC8vIHJlZW50cmFuY3kgKHNpbmNlIHdlIHRyZWF0IHRoZSBub24tbG9jYWwgdmVyc2lvbiBhcyB0aGUgZ3JvdW5kIHRydXRoKSwgd2UnbGwgbG9vcCBoZXJlIHVudGlsIHdlIGRpZG4ndCBnZXRcbiAgICAgICAgICAvLyBhbiBhdHRlbXB0IHRvIGNoYW5nZSBpdC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIGNoYW5nZXMsIHdlJ2xsIGhhdmUgYSBjb25zaXN0ZW50IHByZWZlcnJlZCBhbmRcbiAgICAgICAgICAvLyBsb2NhbFByZWZlcnJlZCBzaXplLlxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFByZWZlcnJlZFdpZHRoID0gdGhpcy5fY2FsY3VsYXRlTG9jYWxQcmVmZXJyZWRXaWR0aCgpO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsUHJlZmVycmVkV2lkdGggPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlIC0gbG9jYWxQcmVmZXJyZWRXaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPSBsb2NhbFByZWZlcnJlZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApO1xuXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZVByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGwge1xuICAgICAgICByZXR1cm4gKCB0aGlzLm1hdHJpeC5pc0FsaWduZWQoKSAmJiB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGggIT09IG51bGwgKVxuICAgICAgICAgICAgICAgPyBNYXRoLmFicyggdGhpcy50cmFuc2Zvcm0udHJhbnNmb3JtRGVsdGFYKCB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGggKSApXG4gICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByaXZhdGUgX3VwZGF0ZVByZWZlcnJlZFdpZHRoKCk6IHZvaWQge1xuICAgICAgICBpZiAoICF0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgKSB7XG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgcHJlZmVycmVkV2lkdGggPSB0aGlzLl9jYWxjdWxhdGVQcmVmZXJyZWRXaWR0aCgpO1xuXG4gICAgICAgICAgaWYgKCB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgIHByZWZlcnJlZFdpZHRoID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlIC0gcHJlZmVycmVkV2lkdGggKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPSBwcmVmZXJyZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBIZXJlLCBpbiB0aGUgY2FzZSBvZiByZWVudHJhbmNlLCB3ZSdsbCBhY3R1YWxseSB3YW50IHRvIHN3aXRjaCB0byB1cGRhdGluZyB0aGUgbG9jYWwgcHJlZmVycmVkIHNpemUsIHNpbmNlXG4gICAgICAgICAgLy8gZ2l2ZW4gYW55IG90aGVyIGNoYW5nZXMgaXQgc2hvdWxkIGJlIHRoZSBwcmltYXJ5IG9uZSB0byBjaGFuZ2UuXG4gICAgICAgICAgaWYgKCB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgKSB7XG4gICAgICAgICAgICB0aGlzLl9vblJlZW50cmFudFByZWZlcnJlZFdpZHRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICAgICAgcHVibGljIF9jYWxjdWxhdGVMb2NhbE1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5taW5pbXVtV2lkdGggIT09IG51bGwgKVxuICAgICAgICAgICAgICAgPyBNYXRoLmFicyggdGhpcy50cmFuc2Zvcm0uaW52ZXJzZURlbHRhWCggdGhpcy5taW5pbXVtV2lkdGggKSApXG4gICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtV2lkdGgoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHByaXZhdGUgX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoKCk6IHZvaWQge1xuICAgICAgICBpZiAoICF0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nICkge1xuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgY29uc3QgbG9jYWxNaW5pbXVtV2lkdGggPSB0aGlzLl9jYWxjdWxhdGVMb2NhbE1pbmltdW1XaWR0aCgpO1xuXG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgIGxvY2FsTWluaW11bVdpZHRoID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlIC0gbG9jYWxNaW5pbXVtV2lkdGggKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgPSBsb2NhbE1pbmltdW1XaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gSGVyZSwgaW4gdGhlIGNhc2Ugb2YgcmVlbnRyYW5jZSwgd2UnbGwgYWN0dWFsbHkgd2FudCB0byBzd2l0Y2ggdG8gdXBkYXRpbmcgdGhlIG5vbi1sb2NhbCBtaW5pbXVtIHNpemUsIHNpbmNlXG4gICAgICAgICAgLy8gZ2l2ZW4gYW55IG90aGVyIGNoYW5nZXMgaXQgc2hvdWxkIGJlIHRoZSBwcmltYXJ5IG9uZSB0byBjaGFuZ2UuXG4gICAgICAgICAgaWYgKCB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICkge1xuICAgICAgICAgICAgdGhpcy5fb25SZWVudHJhbnRMb2NhbE1pbmltdW1XaWR0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZU1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5sb2NhbE1pbmltdW1XaWR0aCAhPT0gbnVsbCApXG4gICAgICAgICAgICAgICA/IE1hdGguYWJzKCB0aGlzLnRyYW5zZm9ybS50cmFuc2Zvcm1EZWx0YVgoIHRoaXMubG9jYWxNaW5pbXVtV2lkdGggKSApXG4gICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByaXZhdGUgX3VwZGF0ZU1pbmltdW1XaWR0aCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCAhdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyApIHtcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFNpbmNlIHRoZSBub24tbG9jYWwgXCJtaW5pbXVtXCIgc2l6ZSBpcyB0aGUgb25lIHRoYXQgd2UnbGwgd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgaWYgd2UgZXhwZXJpZW5jZVxuICAgICAgICAgIC8vIHJlZW50cmFuY3kgKHNpbmNlIHdlIHRyZWF0IHRoZSBsb2NhbCB2ZXJzaW9uIGFzIHRoZSBncm91bmQgdHJ1dGgpLCB3ZSdsbCBsb29wIGhlcmUgdW50aWwgd2UgZGlkbid0IGdldFxuICAgICAgICAgIC8vIGFuIGF0dGVtcHQgdG8gY2hhbmdlIGl0LiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYWZ0ZXIgY2hhbmdlcywgd2UnbGwgaGF2ZSBhIGNvbnNpc3RlbnQgbWluaW11bSBhbmRcbiAgICAgICAgICAvLyBsb2NhbE1pbmltdW0gc2l6ZS5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IG1pbmltdW1XaWR0aCA9IHRoaXMuX2NhbGN1bGF0ZU1pbmltdW1XaWR0aCgpO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMubWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgbWluaW11bVdpZHRoID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlIC0gbWluaW11bVdpZHRoICkgPiBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEICkge1xuICAgICAgICAgICAgICB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID0gbWluaW11bVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgKTtcblxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKCBvcHRpb25zPzogV2lkdGhTaXphYmxlT3B0aW9ucyAmIFBhcmFtZXRlcnM8SW5zdGFuY2VUeXBlPFN1cGVyVHlwZT5bICdtdXRhdGUnIF0+WyAwIF0gKTogdGhpcyB7XG4gICAgICAgIHJldHVybiBzdXBlci5tdXRhdGUoIG9wdGlvbnMgKTtcbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgLy8gSWYgd2UncmUgZXh0ZW5kaW5nIGludG8gYSBOb2RlIHR5cGUsIGluY2x1ZGUgb3B0aW9uIGtleXNcbiAgaWYgKCBXaWR0aFNpemFibGVUcmFpdC5wcm90b3R5cGUuX211dGF0b3JLZXlzICkge1xuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IFdpZHRoU2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXM7XG4gICAgY29uc3QgbmV3S2V5cyA9IFdJRFRIX1NJWkFCTEVfT1BUSU9OX0tFWVM7XG4gICAgY29uc3QgaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyA9IGV4aXN0aW5nS2V5cy5pbmRleE9mKCBSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVNbIDAgXSApO1xuICAgIFdpZHRoU2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXMgPSBbXG4gICAgICAuLi5leGlzdGluZ0tleXMuc2xpY2UoIDAsIGluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMgKSxcbiAgICAgIC4uLm5ld0tleXMsXG4gICAgICAuLi5leGlzdGluZ0tleXMuc2xpY2UoIGluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMgKVxuICAgIF07XG4gIH1cblxuICByZXR1cm4gV2lkdGhTaXphYmxlVHJhaXQ7XG59ICk7XG5cbmNvbnN0IGlzV2lkdGhTaXphYmxlID0gKCBub2RlOiBOb2RlICk6IG5vZGUgaXMgV2lkdGhTaXphYmxlTm9kZSA9PiB7XG4gIHJldHVybiBub2RlLndpZHRoU2l6YWJsZTtcbn07XG5jb25zdCBleHRlbmRzV2lkdGhTaXphYmxlID0gKCBub2RlOiBOb2RlICk6IG5vZGUgaXMgV2lkdGhTaXphYmxlTm9kZSA9PiB7XG4gIHJldHVybiBub2RlLmV4dGVuZHNXaWR0aFNpemFibGU7XG59O1xuXG4vLyBTb21lIHR5cGVzY3JpcHQgZ3ltbmFzdGljcyB0byBwcm92aWRlIGEgdXNlci1kZWZpbmVkIHR5cGUgZ3VhcmQgdGhhdCB0cmVhdHMgc29tZXRoaW5nIGFzIHdpZHRoU2l6YWJsZVxuLy8gV2UgbmVlZCB0byBkZWZpbmUgYW4gdW51c2VkIGZ1bmN0aW9uIHdpdGggYSBjb25jcmV0ZSB0eXBlLCBzbyB0aGF0IHdlIGNhbiBleHRyYWN0IHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgZnVuY3Rpb25cbi8vIGFuZCBwcm92aWRlIGEgdHlwZSBmb3IgYSBOb2RlIHRoYXQgZXh0ZW5kcyB0aGlzIHR5cGUuXG5leHBvcnQgdHlwZSBXaWR0aFNpemFibGVOb2RlID0gTm9kZSAmIFRXaWR0aFNpemFibGU7XG5cbnNjZW5lcnkucmVnaXN0ZXIoICdXaWR0aFNpemFibGUnLCBXaWR0aFNpemFibGUgKTtcbmV4cG9ydCBkZWZhdWx0IFdpZHRoU2l6YWJsZTtcbmV4cG9ydCB7IGlzV2lkdGhTaXphYmxlLCBleHRlbmRzV2lkdGhTaXphYmxlIH07Il0sIm5hbWVzIjpbIlRpbnlQcm9wZXJ0eSIsIm1lbW9pemUiLCJEZWxheWVkTXV0YXRlIiwiUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTIiwic2NlbmVyeSIsIkNIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQiLCJXSURUSF9TSVpBQkxFX09QVElPTl9LRVlTIiwiV2lkdGhTaXphYmxlIiwiVHlwZSIsIldpZHRoU2l6YWJsZVRyYWl0IiwicHJlZmVycmVkV2lkdGgiLCJhc3NlcnQiLCJwcmVmZXJyZWRXaWR0aFByb3BlcnR5IiwidmFsdWUiLCJpc0Zpbml0ZSIsImxvY2FsUHJlZmVycmVkV2lkdGgiLCJsb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkiLCJtaW5pbXVtV2lkdGgiLCJtaW5pbXVtV2lkdGhQcm9wZXJ0eSIsImxvY2FsTWluaW11bVdpZHRoIiwibG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eSIsIndpZHRoU2l6YWJsZSIsImlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eSIsImV4dGVuZHNXaWR0aFNpemFibGUiLCJ2YWxpZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgiLCJjdXJyZW50V2lkdGgiLCJsb2NhbFdpZHRoIiwiZWZmZWN0aXZlTWluaW11bVdpZHRoIiwiaWRlYWxXaWR0aCIsIk1hdGgiLCJhYnMiLCJfY2FsY3VsYXRlTG9jYWxQcmVmZXJyZWRXaWR0aCIsIm1hdHJpeCIsImlzQWxpZ25lZCIsInRyYW5zZm9ybSIsImludmVyc2VEZWx0YVgiLCJfb25SZWVudHJhbnRQcmVmZXJyZWRXaWR0aCIsIl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIiLCJfdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aCIsImF1ZGl0TWF4RGltZW5zaW9ucyIsIl9wcmVmZXJyZWRTaXplQ2hhbmdpbmciLCJfcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrIiwiX2NhbGN1bGF0ZVByZWZlcnJlZFdpZHRoIiwidHJhbnNmb3JtRGVsdGFYIiwiX3VwZGF0ZVByZWZlcnJlZFdpZHRoIiwiX2NhbGN1bGF0ZUxvY2FsTWluaW11bVdpZHRoIiwiX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtV2lkdGgiLCJfdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXIiLCJfdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGgiLCJfbWluaW11bVNpemVDaGFuZ2luZyIsIl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrIiwiX2NhbGN1bGF0ZU1pbmltdW1XaWR0aCIsIl91cGRhdGVNaW5pbXVtV2lkdGgiLCJtdXRhdGUiLCJvcHRpb25zIiwiYXJncyIsIl91cGRhdGVQcmVmZXJyZWRXaWR0aExpc3RlbmVyIiwiYmluZCIsIl91cGRhdGVMb2NhbE1pbmltdW1XaWR0aExpc3RlbmVyIiwibGF6eUxpbmsiLCJ0cmFuc2Zvcm1FbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJleGlzdGluZ0tleXMiLCJuZXdLZXlzIiwiaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyIsImluZGV4T2YiLCJzbGljZSIsImlzV2lkdGhTaXphYmxlIiwibm9kZSIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7OztDQU1DLEdBRUQsT0FBT0Esa0JBQWtCLG1DQUFtQztBQUM1RCxPQUFPQyxhQUFhLG1DQUFtQztBQUd2RCxTQUFTQyxhQUFhLEVBQVFDLDJCQUEyQixFQUFFQyxPQUFPLFFBQVEsZ0JBQWdCO0FBRTFGLHFEQUFxRDtBQUNyRCxNQUFNQyw0QkFBNEI7QUFFbEMsT0FBTyxNQUFNQyw0QkFBNEI7SUFDdkM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQUM7QUErREYsZ0hBQWdIO0FBQ2hILDhHQUE4RztBQUM5RyxrSEFBa0g7QUFDbEgsaUhBQWlIO0FBQ2pILHdDQUF3QztBQUN4QyxNQUFNQyxlQUFlTixRQUFTLENBQXVDTztJQUNuRSxNQUFNQyxvQkFBb0JQLGNBQWUsZ0JBQWdCSSwyQkFDdkQsTUFBTUcsMEJBQTBCRDtRQWlFOUIsSUFBV0UsaUJBQWdDO1lBQ3pDQyxVQUFVQSxPQUFRLElBQUksQ0FBQ0Msc0JBQXNCLEVBQzNDO1lBRUYsT0FBTyxJQUFJLENBQUNBLHNCQUFzQixDQUFDQyxLQUFLO1FBQzFDO1FBRUEsSUFBV0gsZUFBZ0JHLEtBQW9CLEVBQUc7WUFDaERGLFVBQVVBLE9BQVEsSUFBSSxDQUFDQyxzQkFBc0IsRUFDM0M7WUFDRkQsVUFBVUEsT0FBUUUsVUFBVSxRQUFVLE9BQU9BLFVBQVUsWUFBWUMsU0FBVUQsVUFBV0EsU0FBUyxHQUMvRjtZQUVGLElBQUksQ0FBQ0Qsc0JBQXNCLENBQUNDLEtB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