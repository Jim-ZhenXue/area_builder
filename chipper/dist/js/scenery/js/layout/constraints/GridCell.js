// Copyright 2021-2024, University of Colorado Boulder
/**
 * A configurable cell containing a Node used for GridConstraint layout
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import optionize from '../../../../phet-core/js/optionize.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import OrientationPair from '../../../../phet-core/js/OrientationPair.js';
import { GRID_CONFIGURABLE_OPTION_KEYS, GridConfigurable, MarginLayoutCell, scenery } from '../../imports.js';
const GRID_CELL_KEYS = [
    ...GRID_CONFIGURABLE_OPTION_KEYS,
    'row',
    'column',
    'horizontalSpan',
    'verticalSpan'
];
let GridCell = class GridCell extends GridConfigurable(MarginLayoutCell) {
    /**
   * Return the used value, with this cell's value taking precedence over the constraint's default
   * (scenery-internal)
   */ get effectiveXAlign() {
        return this._xAlign !== null ? this._xAlign : this.gridConstraint._xAlign;
    }
    /**
   * Return the used value, with this cell's value taking precedence over the constraint's default
   * (scenery-internal)
   */ get effectiveYAlign() {
        return this._yAlign !== null ? this._yAlign : this.gridConstraint._yAlign;
    }
    /**
   * (scenery-internal)
   */ getEffectiveAlign(orientation) {
        return orientation === Orientation.HORIZONTAL ? this.effectiveXAlign : this.effectiveYAlign;
    }
    /**
   * Return the used value, with this cell's value taking precedence over the constraint's default
   * (scenery-internal)
   */ get effectiveXGrow() {
        return this._xGrow !== null ? this._xGrow : this.gridConstraint._xGrow;
    }
    /**
   * Return the used value, with this cell's value taking precedence over the constraint's default
   * (scenery-internal)
   */ get effectiveYGrow() {
        return this._yGrow !== null ? this._yGrow : this.gridConstraint._yGrow;
    }
    /**
   * (scenery-internal)
   */ getEffectiveGrow(orientation) {
        return orientation === Orientation.HORIZONTAL ? this.effectiveXGrow : this.effectiveYGrow;
    }
    /**
   * Return the used value, with this cell's value taking precedence over the constraint's default
   * (scenery-internal)
   */ get effectiveXStretch() {
        return this._xStretch !== null ? this._xStretch : this.gridConstraint._xStretch;
    }
    /**
   * Return the used value, with this cell's value taking precedence over the constraint's default
   * (scenery-internal)
   */ get effectiveYStretch() {
        return this._yStretch !== null ? this._yStretch : this.gridConstraint._yStretch;
    }
    /**
   * (scenery-internal)
   */ getEffectiveStretch(orientation) {
        return orientation === Orientation.HORIZONTAL ? this.effectiveXStretch : this.effectiveYStretch;
    }
    onLayoutOptionsChange(isInitial = false) {
        this.setOptions(this.node.layoutOptions);
        super.onLayoutOptionsChange();
        if (!isInitial) {
            this.gridConstraint.updateLayoutAutomatically();
        }
    }
    setOptions(providedOptions) {
        // We'll have defaults for cells (the horizontalSpan/verticalSpan are especially relevant)
        const options = optionize()({
            column: 0,
            row: 0,
            horizontalSpan: 1,
            verticalSpan: 1
        }, providedOptions);
        assert && Object.keys(options).forEach((key)=>{
            assert && assert(GRID_CELL_KEYS.includes(key) || key === 'isSeparator', `Cannot provide key ${key} to a GridCell's layoutOptions. Perhaps this is a Flow-style layout option?`);
        });
        assert && assert(typeof options.column === 'number' && Number.isInteger(options.column) && isFinite(options.column) && options.column >= 0);
        assert && assert(typeof options.row === 'number' && Number.isInteger(options.row) && isFinite(options.row) && options.row >= 0);
        assert && assert(typeof options.horizontalSpan === 'number' && Number.isInteger(options.horizontalSpan) && isFinite(options.horizontalSpan) && options.horizontalSpan >= 1);
        assert && assert(typeof options.verticalSpan === 'number' && Number.isInteger(options.verticalSpan) && isFinite(options.verticalSpan) && options.verticalSpan >= 1);
        // Clear options that are not provided in the mutate options (but if they are present, do NOT clear, so we avoid
        // more potential for infinite loops)
        this.setConfigToInherit(options);
        this.position = new OrientationPair(options.column, options.row);
        this.size = new OrientationPair(options.horizontalSpan, options.verticalSpan);
        this.mutateConfigurable(options);
    }
    /**
   * Whether this cell contains the given row/column (based on the orientation). Due to horizontalSpan/verticalSpan of the cell,
   * this could be true for multiple indices.
   * (scenery-internal)
   */ containsIndex(orientation, index) {
        const position = this.position.get(orientation);
        const size = this.size.get(orientation);
        return index >= position && index < position + size;
    }
    /**
   * Whether this cell contains the given row.
   * (scenery-internal)
   */ containsRow(row) {
        return this.containsIndex(Orientation.VERTICAL, row);
    }
    /**
   * Whether this cell contains the given column.
   * (scenery-internal)
   */ containsColumn(column) {
        return this.containsIndex(Orientation.HORIZONTAL, column);
    }
    /**
   * Returns the row/column indices that this cell spans (based on the orientation)
   * (scenery-internal)
   */ getIndices(orientation) {
        const position = this.position.get(orientation);
        const size = this.size.get(orientation);
        return _.range(position, position + size);
    }
    /**
   * (scenery-internal)
   */ constructor(constraint, node, proxy){
        super(constraint, node, proxy);
        this.gridConstraint = constraint;
        this.setOptions(node.layoutOptions);
        this.onLayoutOptionsChange(true);
    }
};
export { GridCell as default };
scenery.register('GridCell', GridCell);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbGF5b3V0L2NvbnN0cmFpbnRzL0dyaWRDZWxsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIEEgY29uZmlndXJhYmxlIGNlbGwgY29udGFpbmluZyBhIE5vZGUgdXNlZCBmb3IgR3JpZENvbnN0cmFpbnQgbGF5b3V0XG4gKlxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxuICovXG5cbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XG5pbXBvcnQgT3JpZW50YXRpb24gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL09yaWVudGF0aW9uLmpzJztcbmltcG9ydCBPcmllbnRhdGlvblBhaXIgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL09yaWVudGF0aW9uUGFpci5qcyc7XG5pbXBvcnQgeyBFeHRlcm5hbEdyaWRDb25maWd1cmFibGVPcHRpb25zLCBHUklEX0NPTkZJR1VSQUJMRV9PUFRJT05fS0VZUywgR3JpZENvbmZpZ3VyYWJsZSwgR3JpZENvbnN0cmFpbnQsIExheW91dEFsaWduLCBMYXlvdXRQcm94eSwgTWFyZ2luTGF5b3V0Q2VsbCwgTm9kZSwgc2NlbmVyeSB9IGZyb20gJy4uLy4uL2ltcG9ydHMuanMnO1xuXG5jb25zdCBHUklEX0NFTExfS0VZUyA9IFtcbiAgLi4uR1JJRF9DT05GSUdVUkFCTEVfT1BUSU9OX0tFWVMsXG4gICdyb3cnLFxuICAnY29sdW1uJyxcbiAgJ2hvcml6b250YWxTcGFuJyxcbiAgJ3ZlcnRpY2FsU3Bhbidcbl07XG5cbnR5cGUgU2VsZk9wdGlvbnMgPSB7XG5cbiAgLy8gRGVmaW5lcyB0aGUgcm93IChvciBpZiBoZWlnaHQ+MSwgdGhlIHRvcC1tb3N0IHJvdykgaW5kZXggb2YgdGhlIGNlbGwuIHJvdzowIGlzIHRoZSB0b3AtbW9zdCByb3dcbiAgcm93PzogbnVtYmVyO1xuXG4gIC8vIERlZmluZXMgdGhlIGNvbHVtbiAob3IgaWYgd2lkdGg+MSwgdGhlIGxlZnQtbW9zdCBjb2x1bW4pIGluZGV4IG9mIHRoZSBjZWxsLiBjb2x1bW46MCBpcyB0aGUgbGVmdC1tb3N0IGNvbHVtbi5cbiAgY29sdW1uPzogbnVtYmVyO1xuXG4gIC8vIEhvdyBtYW55IGNvbHVtbnMgdGhpcyBvbmUgY2VsbCBzcGFucy5cbiAgaG9yaXpvbnRhbFNwYW4/OiBudW1iZXI7XG5cbiAgLy8gSG93IG1hbnkgcm93cyB0aGlzIG9uZSBjZWxsIHNwYW5zXG4gIHZlcnRpY2FsU3Bhbj86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEdyaWRDZWxsT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgRXh0ZXJuYWxHcmlkQ29uZmlndXJhYmxlT3B0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZENlbGwgZXh0ZW5kcyBHcmlkQ29uZmlndXJhYmxlKCBNYXJnaW5MYXlvdXRDZWxsICkge1xuXG4gIC8vIChzY2VuZXJ5LWludGVybmFsKSBUaGVzZSBhcmUgb25seSBzZXQgaW5pdGlhbGx5LCBhbmQgaWdub3JlZCBmb3IgdGhlIGZ1dHVyZVxuICBwdWJsaWMgcG9zaXRpb24hOiBPcmllbnRhdGlvblBhaXI8bnVtYmVyPjtcbiAgcHVibGljIHNpemUhOiBPcmllbnRhdGlvblBhaXI8bnVtYmVyPjtcblxuICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb25zdHJhaW50OiBHcmlkQ29uc3RyYWludDtcblxuICAvKipcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoIGNvbnN0cmFpbnQ6IEdyaWRDb25zdHJhaW50LCBub2RlOiBOb2RlLCBwcm94eTogTGF5b3V0UHJveHkgfCBudWxsICkge1xuXG4gICAgc3VwZXIoIGNvbnN0cmFpbnQsIG5vZGUsIHByb3h5ICk7XG5cbiAgICB0aGlzLmdyaWRDb25zdHJhaW50ID0gY29uc3RyYWludDtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyggbm9kZS5sYXlvdXRPcHRpb25zIGFzIEV4dGVybmFsR3JpZENvbmZpZ3VyYWJsZU9wdGlvbnMgKTtcbiAgICB0aGlzLm9uTGF5b3V0T3B0aW9uc0NoYW5nZSggdHJ1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdXNlZCB2YWx1ZSwgd2l0aCB0aGlzIGNlbGwncyB2YWx1ZSB0YWtpbmcgcHJlY2VkZW5jZSBvdmVyIHRoZSBjb25zdHJhaW50J3MgZGVmYXVsdFxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcbiAgICovXG4gIHB1YmxpYyBnZXQgZWZmZWN0aXZlWEFsaWduKCk6IExheW91dEFsaWduIHtcbiAgICByZXR1cm4gdGhpcy5feEFsaWduICE9PSBudWxsID8gdGhpcy5feEFsaWduIDogdGhpcy5ncmlkQ29uc3RyYWludC5feEFsaWduITtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHVzZWQgdmFsdWUsIHdpdGggdGhpcyBjZWxsJ3MgdmFsdWUgdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgY29uc3RyYWludCdzIGRlZmF1bHRcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqL1xuICBwdWJsaWMgZ2V0IGVmZmVjdGl2ZVlBbGlnbigpOiBMYXlvdXRBbGlnbiB7XG4gICAgcmV0dXJuIHRoaXMuX3lBbGlnbiAhPT0gbnVsbCA/IHRoaXMuX3lBbGlnbiA6IHRoaXMuZ3JpZENvbnN0cmFpbnQuX3lBbGlnbiE7XG4gIH1cblxuICAvKipcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqL1xuICBwdWJsaWMgZ2V0RWZmZWN0aXZlQWxpZ24oIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiBMYXlvdXRBbGlnbiB7XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMID8gdGhpcy5lZmZlY3RpdmVYQWxpZ24gOiB0aGlzLmVmZmVjdGl2ZVlBbGlnbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHVzZWQgdmFsdWUsIHdpdGggdGhpcyBjZWxsJ3MgdmFsdWUgdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgY29uc3RyYWludCdzIGRlZmF1bHRcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqL1xuICBwdWJsaWMgZ2V0IGVmZmVjdGl2ZVhHcm93KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3hHcm93ICE9PSBudWxsID8gdGhpcy5feEdyb3cgOiB0aGlzLmdyaWRDb25zdHJhaW50Ll94R3JvdyE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB1c2VkIHZhbHVlLCB3aXRoIHRoaXMgY2VsbCdzIHZhbHVlIHRha2luZyBwcmVjZWRlbmNlIG92ZXIgdGhlIGNvbnN0cmFpbnQncyBkZWZhdWx0XG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIGdldCBlZmZlY3RpdmVZR3JvdygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl95R3JvdyAhPT0gbnVsbCA/IHRoaXMuX3lHcm93IDogdGhpcy5ncmlkQ29uc3RyYWludC5feUdyb3chO1xuICB9XG5cbiAgLyoqXG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIGdldEVmZmVjdGl2ZUdyb3coIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiBudW1iZXIge1xuICAgIHJldHVybiBvcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCA/IHRoaXMuZWZmZWN0aXZlWEdyb3cgOiB0aGlzLmVmZmVjdGl2ZVlHcm93O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdXNlZCB2YWx1ZSwgd2l0aCB0aGlzIGNlbGwncyB2YWx1ZSB0YWtpbmcgcHJlY2VkZW5jZSBvdmVyIHRoZSBjb25zdHJhaW50J3MgZGVmYXVsdFxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcbiAgICovXG4gIHB1YmxpYyBnZXQgZWZmZWN0aXZlWFN0cmV0Y2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3hTdHJldGNoICE9PSBudWxsID8gdGhpcy5feFN0cmV0Y2ggOiB0aGlzLmdyaWRDb25zdHJhaW50Ll94U3RyZXRjaCE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB1c2VkIHZhbHVlLCB3aXRoIHRoaXMgY2VsbCdzIHZhbHVlIHRha2luZyBwcmVjZWRlbmNlIG92ZXIgdGhlIGNvbnN0cmFpbnQncyBkZWZhdWx0XG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIGdldCBlZmZlY3RpdmVZU3RyZXRjaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5feVN0cmV0Y2ggIT09IG51bGwgPyB0aGlzLl95U3RyZXRjaCA6IHRoaXMuZ3JpZENvbnN0cmFpbnQuX3lTdHJldGNoITtcbiAgfVxuXG4gIC8qKlxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcbiAgICovXG4gIHB1YmxpYyBnZXRFZmZlY3RpdmVTdHJldGNoKCBvcmllbnRhdGlvbjogT3JpZW50YXRpb24gKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMID8gdGhpcy5lZmZlY3RpdmVYU3RyZXRjaCA6IHRoaXMuZWZmZWN0aXZlWVN0cmV0Y2g7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25MYXlvdXRPcHRpb25zQ2hhbmdlKCBpc0luaXRpYWwgPSBmYWxzZSApOiB2b2lkIHtcbiAgICB0aGlzLnNldE9wdGlvbnMoIHRoaXMubm9kZS5sYXlvdXRPcHRpb25zIGFzIEV4dGVybmFsR3JpZENvbmZpZ3VyYWJsZU9wdGlvbnMgKTtcblxuICAgIHN1cGVyLm9uTGF5b3V0T3B0aW9uc0NoYW5nZSgpO1xuXG4gICAgaWYgKCAhaXNJbml0aWFsICkge1xuICAgICAgdGhpcy5ncmlkQ29uc3RyYWludC51cGRhdGVMYXlvdXRBdXRvbWF0aWNhbGx5KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRPcHRpb25zKCBwcm92aWRlZE9wdGlvbnM/OiBFeHRlcm5hbEdyaWRDb25maWd1cmFibGVPcHRpb25zICk6IHZvaWQge1xuXG4gICAgLy8gV2UnbGwgaGF2ZSBkZWZhdWx0cyBmb3IgY2VsbHMgKHRoZSBob3Jpem9udGFsU3Bhbi92ZXJ0aWNhbFNwYW4gYXJlIGVzcGVjaWFsbHkgcmVsZXZhbnQpXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxHcmlkQ2VsbE9wdGlvbnMsIFNlbGZPcHRpb25zLCBFeHRlcm5hbEdyaWRDb25maWd1cmFibGVPcHRpb25zPigpKCB7XG4gICAgICBjb2x1bW46IDAsXG4gICAgICByb3c6IDAsXG4gICAgICBob3Jpem9udGFsU3BhbjogMSxcbiAgICAgIHZlcnRpY2FsU3BhbjogMVxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xuXG4gICAgYXNzZXJ0ICYmIE9iamVjdC5rZXlzKCBvcHRpb25zICkuZm9yRWFjaCgga2V5ID0+IHtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIEdSSURfQ0VMTF9LRVlTLmluY2x1ZGVzKCBrZXkgKSB8fCBrZXkgPT09ICdpc1NlcGFyYXRvcicsXG4gICAgICAgIGBDYW5ub3QgcHJvdmlkZSBrZXkgJHtrZXl9IHRvIGEgR3JpZENlbGwncyBsYXlvdXRPcHRpb25zLiBQZXJoYXBzIHRoaXMgaXMgYSBGbG93LXN0eWxlIGxheW91dCBvcHRpb24/YCApO1xuICAgIH0gKTtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLmNvbHVtbiA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlciggb3B0aW9ucy5jb2x1bW4gKSAmJiBpc0Zpbml0ZSggb3B0aW9ucy5jb2x1bW4gKSAmJiBvcHRpb25zLmNvbHVtbiA+PSAwICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIG9wdGlvbnMucm93ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKCBvcHRpb25zLnJvdyApICYmIGlzRmluaXRlKCBvcHRpb25zLnJvdyApICYmIG9wdGlvbnMucm93ID49IDAgKTtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2Ygb3B0aW9ucy5ob3Jpem9udGFsU3BhbiA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlciggb3B0aW9ucy5ob3Jpem9udGFsU3BhbiApICYmIGlzRmluaXRlKCBvcHRpb25zLmhvcml6b250YWxTcGFuICkgJiYgb3B0aW9ucy5ob3Jpem9udGFsU3BhbiA+PSAxICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIG9wdGlvbnMudmVydGljYWxTcGFuID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKCBvcHRpb25zLnZlcnRpY2FsU3BhbiApICYmIGlzRmluaXRlKCBvcHRpb25zLnZlcnRpY2FsU3BhbiApICYmIG9wdGlvbnMudmVydGljYWxTcGFuID49IDEgKTtcblxuICAgIC8vIENsZWFyIG9wdGlvbnMgdGhhdCBhcmUgbm90IHByb3ZpZGVkIGluIHRoZSBtdXRhdGUgb3B0aW9ucyAoYnV0IGlmIHRoZXkgYXJlIHByZXNlbnQsIGRvIE5PVCBjbGVhciwgc28gd2UgYXZvaWRcbiAgICAvLyBtb3JlIHBvdGVudGlhbCBmb3IgaW5maW5pdGUgbG9vcHMpXG4gICAgdGhpcy5zZXRDb25maWdUb0luaGVyaXQoIG9wdGlvbnMgKTtcblxuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgT3JpZW50YXRpb25QYWlyKCBvcHRpb25zLmNvbHVtbiwgb3B0aW9ucy5yb3cgKTtcbiAgICB0aGlzLnNpemUgPSBuZXcgT3JpZW50YXRpb25QYWlyKCBvcHRpb25zLmhvcml6b250YWxTcGFuLCBvcHRpb25zLnZlcnRpY2FsU3BhbiApO1xuXG4gICAgdGhpcy5tdXRhdGVDb25maWd1cmFibGUoIG9wdGlvbnMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgY2VsbCBjb250YWlucyB0aGUgZ2l2ZW4gcm93L2NvbHVtbiAoYmFzZWQgb24gdGhlIG9yaWVudGF0aW9uKS4gRHVlIHRvIGhvcml6b250YWxTcGFuL3ZlcnRpY2FsU3BhbiBvZiB0aGUgY2VsbCxcbiAgICogdGhpcyBjb3VsZCBiZSB0cnVlIGZvciBtdWx0aXBsZSBpbmRpY2VzLlxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcbiAgICovXG4gIHB1YmxpYyBjb250YWluc0luZGV4KCBvcmllbnRhdGlvbjogT3JpZW50YXRpb24sIGluZGV4OiBudW1iZXIgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmdldCggb3JpZW50YXRpb24gKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplLmdldCggb3JpZW50YXRpb24gKTtcbiAgICByZXR1cm4gaW5kZXggPj0gcG9zaXRpb24gJiYgaW5kZXggPCBwb3NpdGlvbiArIHNpemU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGNlbGwgY29udGFpbnMgdGhlIGdpdmVuIHJvdy5cbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqL1xuICBwdWJsaWMgY29udGFpbnNSb3coIHJvdzogbnVtYmVyICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zSW5kZXgoIE9yaWVudGF0aW9uLlZFUlRJQ0FMLCByb3cgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgY2VsbCBjb250YWlucyB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcbiAgICovXG4gIHB1YmxpYyBjb250YWluc0NvbHVtbiggY29sdW1uOiBudW1iZXIgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNJbmRleCggT3JpZW50YXRpb24uSE9SSVpPTlRBTCwgY29sdW1uICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm93L2NvbHVtbiBpbmRpY2VzIHRoYXQgdGhpcyBjZWxsIHNwYW5zIChiYXNlZCBvbiB0aGUgb3JpZW50YXRpb24pXG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIGdldEluZGljZXMoIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiBudW1iZXJbXSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmdldCggb3JpZW50YXRpb24gKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplLmdldCggb3JpZW50YXRpb24gKTtcbiAgICByZXR1cm4gXy5yYW5nZSggcG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSApO1xuICB9XG59XG5cbnNjZW5lcnkucmVnaXN0ZXIoICdHcmlkQ2VsbCcsIEdyaWRDZWxsICk7Il0sIm5hbWVzIjpbIm9wdGlvbml6ZSIsIk9yaWVudGF0aW9uIiwiT3JpZW50YXRpb25QYWlyIiwiR1JJRF9DT05GSUdVUkFCTEVfT1BUSU9OX0tFWVMiLCJHcmlkQ29uZmlndXJhYmxlIiwiTWFyZ2luTGF5b3V0Q2VsbCIsInNjZW5lcnkiLCJHUklEX0NFTExfS0VZUyIsIkdyaWRDZWxsIiwiZWZmZWN0aXZlWEFsaWduIiwiX3hBbGlnbiIsImdyaWRDb25zdHJhaW50IiwiZWZmZWN0aXZlWUFsaWduIiwiX3lBbGlnbiIsImdldEVmZmVjdGl2ZUFsaWduIiwib3JpZW50YXRpb24iLCJIT1JJWk9OVEFMIiwiZWZmZWN0aXZlWEdyb3ciLCJfeEdyb3ciLCJlZmZlY3RpdmVZR3JvdyIsIl95R3JvdyIsImdldEVmZmVjdGl2ZUdyb3ciLCJlZmZlY3RpdmVYU3RyZXRjaCIsIl94U3RyZXRjaCIsImVmZmVjdGl2ZVlTdHJldGNoIiwiX3lTdHJldGNoIiwiZ2V0RWZmZWN0aXZlU3RyZXRjaCIsIm9uTGF5b3V0T3B0aW9uc0NoYW5nZSIsImlzSW5pdGlhbCIsInNldE9wdGlvbnMiLCJub2RlIiwibGF5b3V0T3B0aW9ucyIsInVwZGF0ZUxheW91dEF1dG9tYXRpY2FsbHkiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiY29sdW1uIiwicm93IiwiaG9yaXpvbnRhbFNwYW4iLCJ2ZXJ0aWNhbFNwYW4iLCJhc3NlcnQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNGaW5pdGUiLCJzZXRDb25maWdUb0luaGVyaXQiLCJwb3NpdGlvbiIsInNpemUiLCJtdXRhdGVDb25maWd1cmFibGUiLCJjb250YWluc0luZGV4IiwiaW5kZXgiLCJnZXQiLCJjb250YWluc1JvdyIsIlZFUlRJQ0FMIiwiY29udGFpbnNDb2x1bW4iLCJnZXRJbmRpY2VzIiwiXyIsInJhbmdlIiwiY29uc3RyYWludCIsInByb3h5IiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7OztDQUlDLEdBRUQsT0FBT0EsZUFBZSx3Q0FBd0M7QUFDOUQsT0FBT0MsaUJBQWlCLDBDQUEwQztBQUNsRSxPQUFPQyxxQkFBcUIsOENBQThDO0FBQzFFLFNBQTBDQyw2QkFBNkIsRUFBRUMsZ0JBQWdCLEVBQTRDQyxnQkFBZ0IsRUFBUUMsT0FBTyxRQUFRLG1CQUFtQjtBQUUvTCxNQUFNQyxpQkFBaUI7T0FDbEJKO0lBQ0g7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQW1CYyxJQUFBLEFBQU1LLFdBQU4sTUFBTUEsaUJBQWlCSixpQkFBa0JDO0lBcUJ0RDs7O0dBR0MsR0FDRCxJQUFXSSxrQkFBK0I7UUFDeEMsT0FBTyxJQUFJLENBQUNDLE9BQU8sS0FBSyxPQUFPLElBQUksQ0FBQ0EsT0FBTyxHQUFHLElBQUksQ0FBQ0MsY0FBYyxDQUFDRCxPQUFPO0lBQzNFO0lBRUE7OztHQUdDLEdBQ0QsSUFBV0Usa0JBQStCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDQyxPQUFPLEtBQUssT0FBTyxJQUFJLENBQUNBLE9BQU8sR0FBRyxJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsT0FBTztJQUMzRTtJQUVBOztHQUVDLEdBQ0QsQUFBT0Ms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