// Copyright 2021-2024, University of Colorado Boulder
/**
 * Like ManualConstraint, but permits layout when not all the nodes are connected (null will be passed through).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import { LayoutCell, LayoutConstraint, Node, scenery } from '../../imports.js';
let RelaxedManualConstraint = class RelaxedManualConstraint extends LayoutConstraint {
    /**
   * (scenery-internal)
   */ layout() {
        super.layout();
        assert && assert(_.every(this.nodes, (node)=>!node.isDisposed));
        // If a cell is disconnected, pass in null
        const proxies = this.cells.map((cell)=>cell.isConnected() ? cell.proxy : null);
        this.layoutCallback.apply(null, proxies);
        this.finishedLayoutEmitter.emit();
    }
    /**
   * Releases references
   */ dispose() {
        this.cells.forEach((cell)=>cell.dispose());
        super.dispose();
    }
    static create(ancestorNode, nodes, layoutCallback) {
        return new RelaxedManualConstraint(ancestorNode, nodes, layoutCallback);
    }
    constructor(ancestorNode, nodes, layoutCallback){
        assert && assert(Array.isArray(nodes) && _.every(nodes, (node)=>node instanceof Node));
        super(ancestorNode);
        // Don't churn updates during construction
        this.lock();
        this.nodes = nodes;
        // Having cells will give us proxy Properties and listening for when it's added for free
        this.cells = nodes.map((node)=>new LayoutCell(this, node, null));
        this.layoutCallback = layoutCallback;
        // Hook up to listen to these nodes (will be handled by LayoutConstraint disposal)
        this.nodes.forEach((node)=>this.addNode(node, false));
        // Run the layout manually at the start
        this.unlock();
        this.updateLayout();
    }
};
export { RelaxedManualConstraint as default };
scenery.register('RelaxedManualConstraint', RelaxedManualConstraint);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbGF5b3V0L2NvbnN0cmFpbnRzL1JlbGF4ZWRNYW51YWxDb25zdHJhaW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIExpa2UgTWFudWFsQ29uc3RyYWludCwgYnV0IHBlcm1pdHMgbGF5b3V0IHdoZW4gbm90IGFsbCB0aGUgbm9kZXMgYXJlIGNvbm5lY3RlZCAobnVsbCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoKS5cbiAqXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XG4gKi9cblxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XG5pbXBvcnQgeyBMYXlvdXRDZWxsLCBMYXlvdXRDb25zdHJhaW50LCBMYXlvdXRQcm94eSwgTm9kZSwgc2NlbmVyeSB9IGZyb20gJy4uLy4uL2ltcG9ydHMuanMnO1xuXG4vLyBUdXJucyBhIHR1cGxlIG9mIHRoaW5ncyBpbnRvIGEgdHVwbGUgb2YgTGF5b3V0UHJveGllcy9udWxsXG50eXBlIExheW91dFByb3h5TWFwPFQ+ID0ge1xuICBbUHJvcGVydHkgaW4ga2V5b2YgVF06IExheW91dFByb3h5IHwgbnVsbFxufTtcbnR5cGUgTGF5b3V0Q2FsbGJhY2s8VCBleHRlbmRzIEludGVudGlvbmFsQW55W10+ID0gKCAuLi5hcmdzOiBMYXlvdXRQcm94eU1hcDxUPiApID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbGF4ZWRNYW51YWxDb25zdHJhaW50PFQgZXh0ZW5kcyBOb2RlW10+IGV4dGVuZHMgTGF5b3V0Q29uc3RyYWludCB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBub2RlczogVDtcblxuICAvLyBDZWxscyBwcm92aWRlIHVzIExheW91dFByb3h5IGFuZCBjb25uZWN0aW9uIHRyYWNraW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgY2VsbHM6IExheW91dENlbGxbXTtcblxuICAvLyBUaGUgdXNlci1zdXBwbGllZCBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgdG8gZG8gbGF5b3V0XG4gIHByaXZhdGUgcmVhZG9ubHkgbGF5b3V0Q2FsbGJhY2s6IExheW91dENhbGxiYWNrPFQ+O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggYW5jZXN0b3JOb2RlOiBOb2RlLCBub2RlczogVCwgbGF5b3V0Q2FsbGJhY2s6IExheW91dENhbGxiYWNrPFQ+ICkge1xuICAgIGFzc2VydCAmJiBhc3NlcnQoIEFycmF5LmlzQXJyYXkoIG5vZGVzICkgJiYgXy5ldmVyeSggbm9kZXMsIG5vZGUgPT4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgKSApO1xuXG4gICAgc3VwZXIoIGFuY2VzdG9yTm9kZSApO1xuXG4gICAgLy8gRG9uJ3QgY2h1cm4gdXBkYXRlcyBkdXJpbmcgY29uc3RydWN0aW9uXG4gICAgdGhpcy5sb2NrKCk7XG5cbiAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG5cbiAgICAvLyBIYXZpbmcgY2VsbHMgd2lsbCBnaXZlIHVzIHByb3h5IFByb3BlcnRpZXMgYW5kIGxpc3RlbmluZyBmb3Igd2hlbiBpdCdzIGFkZGVkIGZvciBmcmVlXG4gICAgdGhpcy5jZWxscyA9IG5vZGVzLm1hcCggbm9kZSA9PiBuZXcgTGF5b3V0Q2VsbCggdGhpcywgbm9kZSwgbnVsbCApICk7XG5cbiAgICB0aGlzLmxheW91dENhbGxiYWNrID0gbGF5b3V0Q2FsbGJhY2s7XG5cbiAgICAvLyBIb29rIHVwIHRvIGxpc3RlbiB0byB0aGVzZSBub2RlcyAod2lsbCBiZSBoYW5kbGVkIGJ5IExheW91dENvbnN0cmFpbnQgZGlzcG9zYWwpXG4gICAgdGhpcy5ub2Rlcy5mb3JFYWNoKCBub2RlID0+IHRoaXMuYWRkTm9kZSggbm9kZSwgZmFsc2UgKSApO1xuXG4gICAgLy8gUnVuIHRoZSBsYXlvdXQgbWFudWFsbHkgYXQgdGhlIHN0YXJ0XG4gICAgdGhpcy51bmxvY2soKTtcbiAgICB0aGlzLnVwZGF0ZUxheW91dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIGxheW91dCgpOiB2b2lkIHtcbiAgICBzdXBlci5sYXlvdXQoKTtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoIF8uZXZlcnkoIHRoaXMubm9kZXMsIG5vZGUgPT4gIW5vZGUuaXNEaXNwb3NlZCApICk7XG5cbiAgICAvLyBJZiBhIGNlbGwgaXMgZGlzY29ubmVjdGVkLCBwYXNzIGluIG51bGxcbiAgICBjb25zdCBwcm94aWVzID0gdGhpcy5jZWxscy5tYXAoIGNlbGwgPT4gY2VsbC5pc0Nvbm5lY3RlZCgpID8gY2VsbC5wcm94eSA6IG51bGwgKTtcblxuICAgIHRoaXMubGF5b3V0Q2FsbGJhY2suYXBwbHkoIG51bGwsIHByb3hpZXMgYXMgTGF5b3V0UHJveHlNYXA8VD4gKTtcblxuICAgIHRoaXMuZmluaXNoZWRMYXlvdXRFbWl0dGVyLmVtaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyByZWZlcmVuY2VzXG4gICAqL1xuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNlbGxzLmZvckVhY2goIGNlbGwgPT4gY2VsbC5kaXNwb3NlKCkgKTtcblxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlPFQgZXh0ZW5kcyBOb2RlW10+KCBhbmNlc3Rvck5vZGU6IE5vZGUsIG5vZGVzOiBULCBsYXlvdXRDYWxsYmFjazogTGF5b3V0Q2FsbGJhY2s8VD4gKTogUmVsYXhlZE1hbnVhbENvbnN0cmFpbnQ8VD4ge1xuICAgIHJldHVybiBuZXcgUmVsYXhlZE1hbnVhbENvbnN0cmFpbnQoIGFuY2VzdG9yTm9kZSwgbm9kZXMsIGxheW91dENhbGxiYWNrICk7XG4gIH1cbn1cblxuc2NlbmVyeS5yZWdpc3RlciggJ1JlbGF4ZWRNYW51YWxDb25zdHJhaW50JywgUmVsYXhlZE1hbnVhbENvbnN0cmFpbnQgKTsiXSwibmFtZXMiOlsiTGF5b3V0Q2VsbCIsIkxheW91dENvbnN0cmFpbnQiLCJOb2RlIiwic2NlbmVyeSIsIlJlbGF4ZWRNYW51YWxDb25zdHJhaW50IiwibGF5b3V0IiwiYXNzZXJ0IiwiXyIsImV2ZXJ5Iiwibm9kZXMiLCJub2RlIiwiaXNEaXNwb3NlZCIsInByb3hpZXMiLCJjZWxscyIsIm1hcCIsImNlbGwiLCJpc0Nvbm5lY3RlZCIsInByb3h5IiwibGF5b3V0Q2FsbGJhY2siLCJhcHBseSIsImZpbmlzaGVkTGF5b3V0RW1pdHRlciIsImVtaXQiLCJkaXNwb3NlIiwiZm9yRWFjaCIsImNyZWF0ZSIsImFuY2VzdG9yTm9kZSIsIkFycmF5IiwiaXNBcnJheSIsImxvY2siLCJhZGROb2RlIiwidW5sb2NrIiwidXBkYXRlTGF5b3V0IiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7OztDQUlDLEdBR0QsU0FBU0EsVUFBVSxFQUFFQyxnQkFBZ0IsRUFBZUMsSUFBSSxFQUFFQyxPQUFPLFFBQVEsbUJBQW1CO0FBUTdFLElBQUEsQUFBTUMsMEJBQU4sTUFBTUEsZ0NBQWtESDtJQWlDckU7O0dBRUMsR0FDRCxBQUFnQkksU0FBZTtRQUM3QixLQUFLLENBQUNBO1FBRU5DLFVBQVVBLE9BQVFDLEVBQUVDLEtBQUssQ0FBRSxJQUFJLENBQUNDLEtBQUssRUFBRUMsQ0FBQUEsT0FBUSxDQUFDQSxLQUFLQyxVQUFVO1FBRS9ELDBDQUEwQztRQUMxQyxNQUFNQyxVQUFVLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUVDLENBQUFBLE9BQVFBLEtBQUtDLFdBQVcsS0FBS0QsS0FBS0UsS0FBSyxHQUFHO1FBRTFFLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxLQUFLLENBQUUsTUFBTVA7UUFFakMsSUFBSSxDQUFDUSxxQkFBcUIsQ0FBQ0MsSUFBSTtJQUNqQztJQUVBOztHQUVDLEdBQ0QsQUFBZ0JDLFVBQWdCO1FBQzlCLElBQUksQ0FBQ1QsS0FBSyxDQUFDVSxPQUFPLENBQUVSLENBQUFBLE9BQVFBLEtBQUtPLE9BQU87UUFFeEMsS0FBSyxDQUFDQTtJQUNSO0lBRUEsT0FBY0UsT0FBMEJDLFlBQWtCLEVBQUVoQixLQUFRLEVBQUVTLGNBQWlDLEVBQStCO1FBQ3BJLE9BQU8sSUFBSWQsd0JBQXlCcUIsY0FBY2hCLE9BQU9TO0lBQzNEO0lBbERBLFlBQW9CTyxZQUFrQixFQUFFaEIsS0FBUSxFQUFFUyxjQUFpQyxDQUFHO1FBQ3BGWixVQUFVQSxPQUFRb0IsTUFBTUMsT0FBTyxDQUFFbEIsVUFBV0YsRUFBRUMsS0FBSyxDQUFFQyxPQUFPQyxDQUFBQSxPQUFRQSxnQkFBZ0JSO1FBRXBGLEtBQUssQ0FBRXVCO1FBRVAsMENBQTBDO1FBQzFDLElBQUksQ0FBQ0csSUFBSTtRQUVULElBQUksQ0FBQ25CLEtBQUssR0FBR0E7UUFFYix3RkFBd0Y7UUFDeEYsSUFBSSxDQUFDSSxLQUFLLEdBQUdKLE1BQU1LLEdBQUcsQ0FBRUosQ0FBQUEsT0FBUSxJQUFJVixXQUFZLElBQUksRUFBRVUsTUFBTTtRQUU1RCxJQUFJLENBQUNRLGNBQWMsR0FBR0E7UUFFdEIsa0ZBQWtGO1FBQ2xGLElBQUksQ0FBQ1QsS0FBSyxDQUFDYyxPQUFPLENBQUViLENBQUFBLE9BQVEsSUFBSSxDQUFDbUIsT0FBTyxDQUFFbkIsTUFBTTtRQUVoRCx1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDb0IsTUFBTTtRQUNYLElBQUksQ0FBQ0MsWUFBWTtJQUNuQjtBQThCRjtBQTdEQSxTQUFxQjNCLHFDQTZEcEI7QUFFREQsUUFBUTZCLFFBQVEsQ0FBRSwyQkFBMkI1QiJ9