// Copyright 2022-2024, University of Colorado Boulder
/**
 * Supertype for LayoutConstraints that are based on an actual Node where the layout takes place. Generally used with
 * layout containers that are subtypes of LayoutNode.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import Property from '../../../../axon/js/Property.js';
import TinyProperty from '../../../../axon/js/TinyProperty.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import optionize from '../../../../phet-core/js/optionize.js';
import { LayoutConstraint, scenery } from '../../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
let NodeLayoutConstraint = class NodeLayoutConstraint extends LayoutConstraint {
    /**
   * Filters out cells to only those that will be involved in layout
   */ filterLayoutCells(cells) {
        // We'll check to make sure cells are disposed in a common place, so it's not duplicated
        assert && assert(_.every(cells, (cell)=>!cell.node.isDisposed), 'A cell\'s node should not be disposed when layout happens');
        return cells.filter((cell)=>{
            return cell.isConnected() && cell.proxy.bounds.isValid() && (!this.excludeInvisible || cell.node.visible);
        });
    }
    get excludeInvisible() {
        return this._excludeInvisible;
    }
    set excludeInvisible(value) {
        if (this._excludeInvisible !== value) {
            this._excludeInvisible = value;
            this.updateLayoutAutomatically();
        }
    }
    /**
   * Sets preferred size of content in a central location (so we could hook in animation in the future)
   * (scenery-internal)
   */ setProxyPreferredSize(orientation, proxy, preferredSize) {
        proxy[orientation.preferredSize] = preferredSize;
    }
    /**
   * Sets position of content in a central location (so we could hook in animation in the future)
   * (scenery-internal)
   */ setProxyMinSide(orientation, proxy, minSide) {
        if (Math.abs(proxy[orientation.minSide] - minSide) > CHANGE_POSITION_THRESHOLD) {
            proxy[orientation.minSide] = minSide;
        }
    }
    /**
   * Sets origin-based position of content in a central location (so we could hook in animation in the future)
   * (scenery-internal)
   */ setProxyOrigin(orientation, proxy, origin) {
        if (Math.abs(proxy[orientation.coordinate] - origin) > CHANGE_POSITION_THRESHOLD) {
            proxy[orientation.coordinate] = origin;
        }
    }
    /**
   * Releases references
   */ dispose() {
        // In case they're from external sources (since these constraints can be used without a dedicated Node that is also
        // being disposed.
        this.preferredWidthProperty.unlink(this._updateLayoutListener);
        this.preferredHeightProperty.unlink(this._updateLayoutListener);
        this.layoutOriginProperty.unlink(this._updateLayoutListener);
        super.dispose();
    }
    /**
   * Recommended for ancestorNode to be the layout container, and that the layout container extends LayoutNode.
   * (scenery-internal)
   */ constructor(ancestorNode, providedOptions){
        // The omitted options are set to proper defaults below
        const options = optionize()({
            // As options, so we could hook into a Node's preferred/minimum sizes if desired
            preferredWidthProperty: new TinyProperty(null),
            preferredHeightProperty: new TinyProperty(null),
            minimumWidthProperty: new TinyProperty(null),
            minimumHeightProperty: new TinyProperty(null),
            layoutOriginProperty: new TinyProperty(Vector2.ZERO)
        }, providedOptions);
        super(ancestorNode), this._excludeInvisible = true;
        this.layoutBoundsProperty = new Property(Bounds2.NOTHING, {
            valueComparisonStrategy: 'equalsFunction'
        });
        this.preferredWidthProperty = options.preferredWidthProperty;
        this.preferredHeightProperty = options.preferredHeightProperty;
        this.minimumWidthProperty = options.minimumWidthProperty;
        this.minimumHeightProperty = options.minimumHeightProperty;
        this.layoutOriginProperty = options.layoutOriginProperty;
        this.preferredWidthProperty.lazyLink(this._updateLayoutListener);
        this.preferredHeightProperty.lazyLink(this._updateLayoutListener);
        this.layoutOriginProperty.lazyLink(this._updateLayoutListener);
    }
};
export { NodeLayoutConstraint as default };
scenery.register('NodeLayoutConstraint', NodeLayoutConstraint);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbGF5b3V0L2NvbnN0cmFpbnRzL05vZGVMYXlvdXRDb25zdHJhaW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIyLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIFN1cGVydHlwZSBmb3IgTGF5b3V0Q29uc3RyYWludHMgdGhhdCBhcmUgYmFzZWQgb24gYW4gYWN0dWFsIE5vZGUgd2hlcmUgdGhlIGxheW91dCB0YWtlcyBwbGFjZS4gR2VuZXJhbGx5IHVzZWQgd2l0aFxuICogbGF5b3V0IGNvbnRhaW5lcnMgdGhhdCBhcmUgc3VidHlwZXMgb2YgTGF5b3V0Tm9kZS5cbiAqXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XG4gKi9cblxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xuaW1wb3J0IFRpbnlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1RpbnlQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgVFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFByb3BlcnR5LmpzJztcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XG5pbXBvcnQgT3JpZW50YXRpb24gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL09yaWVudGF0aW9uLmpzJztcbmltcG9ydCBTdHJpY3RPbWl0IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9TdHJpY3RPbWl0LmpzJztcbmltcG9ydCB7IExheW91dENvbnN0cmFpbnQsIExheW91dFByb3h5LCBNYXJnaW5MYXlvdXRDZWxsLCBOb2RlLCBzY2VuZXJ5IH0gZnJvbSAnLi4vLi4vaW1wb3J0cy5qcyc7XG5cbi8vIFBvc2l0aW9uIGNoYW5nZXMgc21hbGxlciB0aGFuIHRoaXMgd2lsbCBiZSBpZ25vcmVkXG5jb25zdCBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEID0gMWUtOTtcblxudHlwZSBTZWxmT3B0aW9ucyA9IHtcbiAgLy8gV2hldGhlciBpbnZpc2libGUgTm9kZXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGxheW91dC5cbiAgZXhjbHVkZUludmlzaWJsZT86IGJvb2xlYW47XG5cbiAgLy8gSWYgYXZhaWxhYmxlLCB0aGUgbG9jYWwgdmVyc2lvbnMgb2YgdGhlc2UgUHJvcGVydGllcyBmb3IgdGhlIGxheW91dCBjb250YWluZXIgc2hvdWxkIGJlIHBhc3NlZCBpbi4gV2UgZG8gdGhlXG4gIC8vIGxheW91dCBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZSBvZiBlLmcuIEdyaWRCb3gvRmxvd0JveC4gSXQncyBuYW1lZCB0aGlzIHdheSBqdXN0IGZvciBlYXNlLW9mLXVzZSB3aXRoaW5cbiAgLy8gdGhpcyBjb2RlLlxuICBwcmVmZXJyZWRXaWR0aFByb3BlcnR5PzogVFByb3BlcnR5PG51bWJlciB8IG51bGw+O1xuICBwcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eT86IFRQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgbWluaW11bVdpZHRoUHJvcGVydHk/OiBUUHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XG4gIG1pbmltdW1IZWlnaHRQcm9wZXJ0eT86IFRQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcblxuICAvLyBJZiBwcm92aWRlZCwgd2lsbCBwb3NpdGlvbiBjb250ZW50IGF0IGFuIG9mZnNldCBmcm9tIHRoZSBub3JtYWwgb3JpZ2luXG4gIGxheW91dE9yaWdpblByb3BlcnR5PzogVFByb3BlcnR5PFZlY3RvcjI+O1xufTtcblxuZXhwb3J0IHR5cGUgTm9kZUxheW91dENvbnN0cmFpbnRPcHRpb25zID0gU2VsZk9wdGlvbnM7XG5cbi8vIFR5cGUgZXhwb3J0IGRlc2lnbmVkIGZvciB1c2Ugd2l0aCBjbGllbnRzXG5leHBvcnQgdHlwZSBOb2RlTGF5b3V0QXZhaWxhYmxlQ29uc3RyYWludE9wdGlvbnMgPSBQaWNrPE5vZGVMYXlvdXRDb25zdHJhaW50T3B0aW9ucywgJ2V4Y2x1ZGVJbnZpc2libGUnIHwgJ2xheW91dE9yaWdpblByb3BlcnR5Jz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vZGVMYXlvdXRDb25zdHJhaW50IGV4dGVuZHMgTGF5b3V0Q29uc3RyYWludCB7XG5cbiAgcHJpdmF0ZSBfZXhjbHVkZUludmlzaWJsZSA9IHRydWU7XG5cbiAgLy8gUmVwb3J0cyBvdXQgdGhlIHVzZWQgbGF5b3V0IGJvdW5kcyAobWF5IGJlIGxhcmdlciB0aGFuIGFjdHVhbCBib3VuZHMsIHNpbmNlIGl0IHdpbGwgaW5jbHVkZSBtYXJnaW5zLCBldGMuKVxuICAvLyBMYXlvdXQgbm9kZXMgY2FuIHVzZSB0aGlzIHRvIGFkanVzdCB0aGVpciBsb2NhbEJvdW5kcy4gRmxvd0JveC9HcmlkQm94IHVzZXMgdGhpcyBmb3IgdGhlaXIgbG9jYWxCb3VuZHMuXG4gIC8vIChzY2VuZXJ5LWludGVybmFsKVxuICBwdWJsaWMgcmVhZG9ubHkgbGF5b3V0Qm91bmRzUHJvcGVydHk6IFRQcm9wZXJ0eTxCb3VuZHMyPjtcblxuICAvLyAoc2NlbmVyeS1pbnRlcm5hbClcbiAgcHVibGljIHJlYWRvbmx5IHByZWZlcnJlZFdpZHRoUHJvcGVydHk6IFRQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgcHVibGljIHJlYWRvbmx5IHByZWZlcnJlZEhlaWdodFByb3BlcnR5OiBUUHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XG4gIHB1YmxpYyByZWFkb25seSBtaW5pbXVtV2lkdGhQcm9wZXJ0eTogVFByb3BlcnR5PG51bWJlciB8IG51bGw+O1xuICBwdWJsaWMgcmVhZG9ubHkgbWluaW11bUhlaWdodFByb3BlcnR5OiBUUHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XG4gIHB1YmxpYyByZWFkb25seSBsYXlvdXRPcmlnaW5Qcm9wZXJ0eTogVFByb3BlcnR5PFZlY3RvcjI+O1xuXG4gIC8qKlxuICAgKiBSZWNvbW1lbmRlZCBmb3IgYW5jZXN0b3JOb2RlIHRvIGJlIHRoZSBsYXlvdXQgY29udGFpbmVyLCBhbmQgdGhhdCB0aGUgbGF5b3V0IGNvbnRhaW5lciBleHRlbmRzIExheW91dE5vZGUuXG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBhbmNlc3Rvck5vZGU6IE5vZGUsIHByb3ZpZGVkT3B0aW9ucz86IE5vZGVMYXlvdXRDb25zdHJhaW50T3B0aW9ucyApIHtcblxuICAgIC8vIFRoZSBvbWl0dGVkIG9wdGlvbnMgYXJlIHNldCB0byBwcm9wZXIgZGVmYXVsdHMgYmVsb3dcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPE5vZGVMYXlvdXRDb25zdHJhaW50T3B0aW9ucywgU3RyaWN0T21pdDxTZWxmT3B0aW9ucywgJ2V4Y2x1ZGVJbnZpc2libGUnPj4oKSgge1xuICAgICAgLy8gQXMgb3B0aW9ucywgc28gd2UgY291bGQgaG9vayBpbnRvIGEgTm9kZSdzIHByZWZlcnJlZC9taW5pbXVtIHNpemVzIGlmIGRlc2lyZWRcbiAgICAgIHByZWZlcnJlZFdpZHRoUHJvcGVydHk6IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKSxcbiAgICAgIHByZWZlcnJlZEhlaWdodFByb3BlcnR5OiBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICksXG4gICAgICBtaW5pbXVtV2lkdGhQcm9wZXJ0eTogbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApLFxuICAgICAgbWluaW11bUhlaWdodFByb3BlcnR5OiBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICksXG4gICAgICBsYXlvdXRPcmlnaW5Qcm9wZXJ0eTogbmV3IFRpbnlQcm9wZXJ0eTxWZWN0b3IyPiggVmVjdG9yMi5aRVJPIClcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIHN1cGVyKCBhbmNlc3Rvck5vZGUgKTtcblxuICAgIHRoaXMubGF5b3V0Qm91bmRzUHJvcGVydHkgPSBuZXcgUHJvcGVydHkoIEJvdW5kczIuTk9USElORywge1xuICAgICAgdmFsdWVDb21wYXJpc29uU3RyYXRlZ3k6ICdlcXVhbHNGdW5jdGlvbidcbiAgICB9ICk7XG5cbiAgICB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkgPSBvcHRpb25zLnByZWZlcnJlZFdpZHRoUHJvcGVydHk7XG4gICAgdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eSA9IG9wdGlvbnMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHk7XG4gICAgdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eSA9IG9wdGlvbnMubWluaW11bVdpZHRoUHJvcGVydHk7XG4gICAgdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkgPSBvcHRpb25zLm1pbmltdW1IZWlnaHRQcm9wZXJ0eTtcbiAgICB0aGlzLmxheW91dE9yaWdpblByb3BlcnR5ID0gb3B0aW9ucy5sYXlvdXRPcmlnaW5Qcm9wZXJ0eTtcblxuICAgIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTGF5b3V0TGlzdGVuZXIgKTtcbiAgICB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuICAgIHRoaXMubGF5b3V0T3JpZ2luUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxheW91dExpc3RlbmVyICk7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVycyBvdXQgY2VsbHMgdG8gb25seSB0aG9zZSB0aGF0IHdpbGwgYmUgaW52b2x2ZWQgaW4gbGF5b3V0XG4gICAqL1xuICBwcm90ZWN0ZWQgZmlsdGVyTGF5b3V0Q2VsbHM8Q2VsbCBleHRlbmRzIE1hcmdpbkxheW91dENlbGw+KCBjZWxsczogQ2VsbFtdICk6IENlbGxbXSB7XG4gICAgLy8gV2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIGNlbGxzIGFyZSBkaXNwb3NlZCBpbiBhIGNvbW1vbiBwbGFjZSwgc28gaXQncyBub3QgZHVwbGljYXRlZFxuICAgIGFzc2VydCAmJiBhc3NlcnQoIF8uZXZlcnkoIGNlbGxzLCBjZWxsID0+ICFjZWxsLm5vZGUuaXNEaXNwb3NlZCApLCAnQSBjZWxsXFwncyBub2RlIHNob3VsZCBub3QgYmUgZGlzcG9zZWQgd2hlbiBsYXlvdXQgaGFwcGVucycgKTtcblxuICAgIHJldHVybiBjZWxscy5maWx0ZXIoIGNlbGwgPT4ge1xuICAgICAgcmV0dXJuIGNlbGwuaXNDb25uZWN0ZWQoKSAmJiBjZWxsLnByb3h5LmJvdW5kcy5pc1ZhbGlkKCkgJiYgKCAhdGhpcy5leGNsdWRlSW52aXNpYmxlIHx8IGNlbGwubm9kZS52aXNpYmxlICk7XG4gICAgfSApO1xuICB9XG5cbiAgcHVibGljIGdldCBleGNsdWRlSW52aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9leGNsdWRlSW52aXNpYmxlO1xuICB9XG5cbiAgcHVibGljIHNldCBleGNsdWRlSW52aXNpYmxlKCB2YWx1ZTogYm9vbGVhbiApIHtcbiAgICBpZiAoIHRoaXMuX2V4Y2x1ZGVJbnZpc2libGUgIT09IHZhbHVlICkge1xuICAgICAgdGhpcy5fZXhjbHVkZUludmlzaWJsZSA9IHZhbHVlO1xuXG4gICAgICB0aGlzLnVwZGF0ZUxheW91dEF1dG9tYXRpY2FsbHkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBwcmVmZXJyZWQgc2l6ZSBvZiBjb250ZW50IGluIGEgY2VudHJhbCBsb2NhdGlvbiAoc28gd2UgY291bGQgaG9vayBpbiBhbmltYXRpb24gaW4gdGhlIGZ1dHVyZSlcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqL1xuICBwdWJsaWMgc2V0UHJveHlQcmVmZXJyZWRTaXplKCBvcmllbnRhdGlvbjogT3JpZW50YXRpb24sIHByb3h5OiBMYXlvdXRQcm94eSwgcHJlZmVycmVkU2l6ZTogbnVtYmVyIHwgbnVsbCApOiB2b2lkIHtcbiAgICBwcm94eVsgb3JpZW50YXRpb24ucHJlZmVycmVkU2l6ZSBdID0gcHJlZmVycmVkU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHBvc2l0aW9uIG9mIGNvbnRlbnQgaW4gYSBjZW50cmFsIGxvY2F0aW9uIChzbyB3ZSBjb3VsZCBob29rIGluIGFuaW1hdGlvbiBpbiB0aGUgZnV0dXJlKVxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcbiAgICovXG4gIHB1YmxpYyBzZXRQcm94eU1pblNpZGUoIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiwgcHJveHk6IExheW91dFByb3h5LCBtaW5TaWRlOiBudW1iZXIgKTogdm9pZCB7XG4gICAgaWYgKCBNYXRoLmFicyggcHJveHlbIG9yaWVudGF0aW9uLm1pblNpZGUgXSAtIG1pblNpZGUgKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XG4gICAgICBwcm94eVsgb3JpZW50YXRpb24ubWluU2lkZSBdID0gbWluU2lkZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvcmlnaW4tYmFzZWQgcG9zaXRpb24gb2YgY29udGVudCBpbiBhIGNlbnRyYWwgbG9jYXRpb24gKHNvIHdlIGNvdWxkIGhvb2sgaW4gYW5pbWF0aW9uIGluIHRoZSBmdXR1cmUpXG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxuICAgKi9cbiAgcHVibGljIHNldFByb3h5T3JpZ2luKCBvcmllbnRhdGlvbjogT3JpZW50YXRpb24sIHByb3h5OiBMYXlvdXRQcm94eSwgb3JpZ2luOiBudW1iZXIgKTogdm9pZCB7XG4gICAgaWYgKCBNYXRoLmFicyggcHJveHlbIG9yaWVudGF0aW9uLmNvb3JkaW5hdGUgXSAtIG9yaWdpbiApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcbiAgICAgIHByb3h5WyBvcmllbnRhdGlvbi5jb29yZGluYXRlIF0gPSBvcmlnaW47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHJlZmVyZW5jZXNcbiAgICovXG4gIHB1YmxpYyBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xuICAgIC8vIEluIGNhc2UgdGhleSdyZSBmcm9tIGV4dGVybmFsIHNvdXJjZXMgKHNpbmNlIHRoZXNlIGNvbnN0cmFpbnRzIGNhbiBiZSB1c2VkIHdpdGhvdXQgYSBkZWRpY2F0ZWQgTm9kZSB0aGF0IGlzIGFsc29cbiAgICAvLyBiZWluZyBkaXNwb3NlZC5cbiAgICB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuICAgIHRoaXMubGF5b3V0T3JpZ2luUHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbnNjZW5lcnkucmVnaXN0ZXIoICdOb2RlTGF5b3V0Q29uc3RyYWludCcsIE5vZGVMYXlvdXRDb25zdHJhaW50ICk7Il0sIm5hbWVzIjpbIlByb3BlcnR5IiwiVGlueVByb3BlcnR5IiwiQm91bmRzMiIsIlZlY3RvcjIiLCJvcHRpb25pemUiLCJMYXlvdXRDb25zdHJhaW50Iiwic2NlbmVyeSIsIkNIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQiLCJOb2RlTGF5b3V0Q29uc3RyYWludCIsImZpbHRlckxheW91dENlbGxzIiwiY2VsbHMiLCJhc3NlcnQiLCJfIiwiZXZlcnkiLCJjZWxsIiwibm9kZSIsImlzRGlzcG9zZWQiLCJmaWx0ZXIiLCJpc0Nvbm5lY3RlZCIsInByb3h5IiwiYm91bmRzIiwiaXNWYWxpZCIsImV4Y2x1ZGVJbnZpc2libGUiLCJ2aXNpYmxlIiwiX2V4Y2x1ZGVJbnZpc2libGUiLCJ2YWx1ZSIsInVwZGF0ZUxheW91dEF1dG9tYXRpY2FsbHkiLCJzZXRQcm94eVByZWZlcnJlZFNpemUiLCJvcmllbnRhdGlvbiIsInByZWZlcnJlZFNpemUiLCJzZXRQcm94eU1pblNpZGUiLCJtaW5TaWRlIiwiTWF0aCIsImFicyIsInNldFByb3h5T3JpZ2luIiwib3JpZ2luIiwiY29vcmRpbmF0ZSIsImRpc3Bvc2UiLCJwcmVmZXJyZWRXaWR0aFByb3BlcnR5IiwidW5saW5rIiwiX3VwZGF0ZUxheW91dExpc3RlbmVyIiwicHJlZmVycmVkSGVpZ2h0UHJvcGVydHkiLCJsYXlvdXRPcmlnaW5Qcm9wZXJ0eSIsImFuY2VzdG9yTm9kZSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJtaW5pbXVtV2lkdGhQcm9wZXJ0eSIsIm1pbmltdW1IZWlnaHRQcm9wZXJ0eSIsIlpFUk8iLCJsYXlvdXRCb3VuZHNQcm9wZXJ0eSIsIk5PVEhJTkciLCJ2YWx1ZUNvbXBhcmlzb25TdHJhdGVneSIsImxhenlMaW5rIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7Q0FLQyxHQUVELE9BQU9BLGNBQWMsa0NBQWtDO0FBQ3ZELE9BQU9DLGtCQUFrQixzQ0FBc0M7QUFFL0QsT0FBT0MsYUFBYSxnQ0FBZ0M7QUFDcEQsT0FBT0MsYUFBYSxnQ0FBZ0M7QUFDcEQsT0FBT0MsZUFBZSx3Q0FBd0M7QUFHOUQsU0FBU0MsZ0JBQWdCLEVBQXVDQyxPQUFPLFFBQVEsbUJBQW1CO0FBRWxHLHFEQUFxRDtBQUNyRCxNQUFNQyw0QkFBNEI7QUF1Qm5CLElBQUEsQUFBTUMsdUJBQU4sTUFBTUEsNkJBQTZCSDtJQWlEaEQ7O0dBRUMsR0FDRCxBQUFVSSxrQkFBa0RDLEtBQWEsRUFBVztRQUNsRix3RkFBd0Y7UUFDeEZDLFVBQVVBLE9BQVFD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