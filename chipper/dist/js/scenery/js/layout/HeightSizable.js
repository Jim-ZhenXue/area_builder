// Copyright 2021-2024, University of Colorado Boulder
/**
 * HeightSizable is a trait that provides a minimum and preferred height. The minimum height is set by the component,
 * so that layout containers could know how "small" the component can be made. The preferred height is set by the
 * layout container, and the component should adjust its size so that it takes up that height.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import TinyProperty from '../../../axon/js/TinyProperty.js';
import memoize from '../../../phet-core/js/memoize.js';
import { DelayedMutate, REQUIRES_BOUNDS_OPTION_KEYS, scenery } from '../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
export const HEIGHT_SIZABLE_OPTION_KEYS = [
    'preferredHeight',
    'minimumHeight',
    'localPreferredHeight',
    'localMinimumHeight',
    'heightSizable'
];
// IMPORTANT: If you're combining this in, typically don't pass options that HeightSizable would take through the
// constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
// values yet. If you're making something HeightSizable, please use a later mutate() to pass these options through.
// They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
// is yet passing those options through.
const HeightSizable = memoize((Type)=>{
    const HeightSizableTrait = DelayedMutate('HeightSizable', HEIGHT_SIZABLE_OPTION_KEYS, class HeightSizableTrait extends Type {
        get preferredHeight() {
            assert && assert(this.preferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            return this.preferredHeightProperty.value;
        }
        set preferredHeight(value) {
            assert && assert(this.preferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'preferredHeight should be null or a non-negative finite number');
            this.preferredHeightProperty.value = value;
        }
        get localPreferredHeight() {
            assert && assert(this.localPreferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            return this.localPreferredHeightProperty.value;
        }
        set localPreferredHeight(value) {
            assert && assert(this.localPreferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'localPreferredHeight should be null or a non-negative finite number');
            this.localPreferredHeightProperty.value = value;
        }
        get minimumHeight() {
            assert && assert(this.minimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            return this.minimumHeightProperty.value;
        }
        set minimumHeight(value) {
            assert && assert(this.minimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value));
            this.minimumHeightProperty.value = value;
        }
        get localMinimumHeight() {
            assert && assert(this.localMinimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            return this.localMinimumHeightProperty.value;
        }
        set localMinimumHeight(value) {
            assert && assert(this.localMinimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            assert && assert(value === null || typeof value === 'number' && isFinite(value));
            this.localMinimumHeightProperty.value = value;
        }
        get heightSizable() {
            assert && assert(this.isHeightResizableProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            return this.isHeightResizableProperty.value;
        }
        set heightSizable(value) {
            assert && assert(this.isHeightResizableProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
            this.isHeightResizableProperty.value = value;
        }
        get extendsHeightSizable() {
            return true;
        }
        validateLocalPreferredHeight() {
            if (assert) {
                const currentHeight = this.localHeight;
                const effectiveMinimumHeight = this.localMinimumHeight === null ? currentHeight : this.localMinimumHeight;
                const idealHeight = this.localPreferredHeight === null ? effectiveMinimumHeight : this.localPreferredHeight;
                // Handle non-finite values with exact equality
                assert(idealHeight === currentHeight || Math.abs(idealHeight - currentHeight) < 1e-7);
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculateLocalPreferredHeight() {
            return this.matrix.isAligned() && this.preferredHeight !== null ? Math.abs(this.transform.inverseDeltaY(this.preferredHeight)) : null;
        }
        // Provides a hook to Sizable, since we'll need to cross-link this to also try updating the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _onReentrantPreferredHeight() {
            this._updateLocalPreferredHeightListener();
        }
        _updateLocalPreferredHeight() {
            assert && this.auditMaxDimensions();
            if (!this._preferredSizeChanging) {
                this._preferredSizeChanging = true;
                // Since the local "preferred" size is the one that we'll want to continue to update if we experience
                // reentrancy (since we treat the non-local version as the ground truth), we'll loop here until we didn't get
                // an attempt to change it. This will ensure that after changes, we'll have a consistent preferred and
                // localPreferred size.
                do {
                    this._preferredSizeChangeAttemptDuringLock = false;
                    const localPreferredHeight = this._calculateLocalPreferredHeight();
                    if (this.localPreferredHeightProperty.value === null || localPreferredHeight === null || Math.abs(this.localPreferredHeightProperty.value - localPreferredHeight) > CHANGE_POSITION_THRESHOLD) {
                        this.localPreferredHeightProperty.value = localPreferredHeight;
                    }
                }while (this._preferredSizeChangeAttemptDuringLock)
                this._preferredSizeChanging = false;
            } else {
                this._preferredSizeChangeAttemptDuringLock = true;
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculatePreferredHeight() {
            return this.matrix.isAligned() && this.localPreferredHeight !== null ? Math.abs(this.transform.transformDeltaY(this.localPreferredHeight)) : null;
        }
        _updatePreferredHeight() {
            if (!this._preferredSizeChanging) {
                this._preferredSizeChanging = true;
                this._preferredSizeChangeAttemptDuringLock = false;
                const preferredHeight = this._calculatePreferredHeight();
                if (this.preferredHeightProperty.value === null || preferredHeight === null || Math.abs(this.preferredHeightProperty.value - preferredHeight) > CHANGE_POSITION_THRESHOLD) {
                    this.preferredHeightProperty.value = preferredHeight;
                }
                this._preferredSizeChanging = false;
                // Here, in the case of reentrance, we'll actually want to switch to updating the local preferred size, since
                // given any other changes it should be the primary one to change.
                if (this._preferredSizeChangeAttemptDuringLock) {
                    this._onReentrantPreferredHeight();
                }
            } else {
                this._preferredSizeChangeAttemptDuringLock = true;
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculateLocalMinimumHeight() {
            return this.matrix.isAligned() && this.minimumHeight !== null ? Math.abs(this.transform.inverseDeltaY(this.minimumHeight)) : null;
        }
        // @mixin-protected - made public for use in the mixin only
        _onReentrantLocalMinimumHeight() {
            this._updateMinimumHeight();
        }
        _updateLocalMinimumHeight() {
            if (!this._minimumSizeChanging) {
                this._minimumSizeChanging = true;
                this._minimumSizeChangeAttemptDuringLock = false;
                const localMinimumHeight = this._calculateLocalMinimumHeight();
                if (this.localMinimumHeightProperty.value === null || localMinimumHeight === null || Math.abs(this.localMinimumHeightProperty.value - localMinimumHeight) > CHANGE_POSITION_THRESHOLD) {
                    this.localMinimumHeightProperty.value = localMinimumHeight;
                }
                this._minimumSizeChanging = false;
                // Here, in the case of reentrance, we'll actually want to switch to updating the non-local minimum size, since
                // given any other changes it should be the primary one to change.
                if (this._minimumSizeChangeAttemptDuringLock) {
                    this._onReentrantLocalMinimumHeight();
                }
            } else {
                this._minimumSizeChangeAttemptDuringLock = true;
            }
        }
        // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
        // @mixin-protected - made public for use in the mixin only
        _calculateMinimumHeight() {
            return this.matrix.isAligned() && this.localMinimumHeight !== null ? Math.abs(this.transform.transformDeltaY(this.localMinimumHeight)) : null;
        }
        _updateMinimumHeight() {
            if (!this._minimumSizeChanging) {
                this._minimumSizeChanging = true;
                // Since the non-local "minimum" size is the one that we'll want to continue to update if we experience
                // reentrancy (since we treat the local version as the ground truth), we'll loop here until we didn't get
                // an attempt to change it. This will ensure that after changes, we'll have a consistent minimum and
                // localMinimum size.
                do {
                    this._minimumSizeChangeAttemptDuringLock = false;
                    const minimumHeight = this._calculateMinimumHeight();
                    if (this.minimumHeightProperty.value === null || minimumHeight === null || Math.abs(this.minimumHeightProperty.value - minimumHeight) > CHANGE_POSITION_THRESHOLD) {
                        this.minimumHeightProperty.value = minimumHeight;
                    }
                }while (this._minimumSizeChangeAttemptDuringLock)
                this._minimumSizeChanging = false;
            }
        }
        mutate(options) {
            return super.mutate(options);
        }
        // IMPORTANT: If you're combining this in, typically don't pass options that HeightSizable would take through the
        // constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
        // values yet. If you're making something HeightSizable, please use a later mutate() to pass these options through.
        // They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
        // is yet passing those options through.
        constructor(...args){
            super(...args), // parent/local preferred/minimum Properties. See the options above for more documentation
            this.preferredHeightProperty = new TinyProperty(null), this.minimumHeightProperty = new TinyProperty(null), this.localPreferredHeightProperty = new TinyProperty(null), this.localMinimumHeightProperty = new TinyProperty(null), this.isHeightResizableProperty = new TinyProperty(true), // Flags so that we can change one (parent/local) value and not enter an infinite loop changing the others.
            // We want to lock out all other local or non-local preferred minimum sizes, whether in HeightSizable or WidthSizable
            // NOTE: We are merging declarations between HeightSizable and WidthSizable. If Sizable is used these flags
            // will be shared by both HeightSizable and WidthSizable.
            // @mixin-protected - made public for use in the mixin only
            this._preferredSizeChanging = false, // @mixin-protected - made public for use in the mixin only
            this._minimumSizeChanging = false, // We'll need to detect reentrancy when setting the dual of the preferred/minimum properties (e.g. local vs parent).
            // If we get a reentrant case, we'll need to detect it and clear things up at the end (updating the minimum size
            // in the parent coordinate frame, and the preferred size in the local coordinate frame).
            // An example is if the minimum size is set, and that triggers a listener that UPDATES something that changes the
            // minimum size, we'll need to make sure that the local minimum size is updated AFTER everything has happened.
            // These locks are used to detect these cases, and then run the appropriate updates afterward to make sure that the
            // local and parent values are in sync (based on the transform used).
            // @mixin-protected - made public for use in the mixin only
            this._preferredSizeChangeAttemptDuringLock = false, // @mixin-protected - made public for use in the mixin only
            this._minimumSizeChangeAttemptDuringLock = false;
            this._updatePreferredHeightListener = this._updatePreferredHeight.bind(this);
            this._updateLocalPreferredHeightListener = this._updateLocalPreferredHeight.bind(this);
            this._updateMinimumHeightListener = this._updateMinimumHeight.bind(this);
            this._updateLocalMinimumHeightListener = this._updateLocalMinimumHeight.bind(this);
            // Update the opposite of parent/local when one changes
            this.preferredHeightProperty.lazyLink(this._updateLocalPreferredHeightListener);
            this.localPreferredHeightProperty.lazyLink(this._updatePreferredHeightListener);
            this.minimumHeightProperty.lazyLink(this._updateLocalMinimumHeightListener);
            this.localMinimumHeightProperty.lazyLink(this._updateMinimumHeightListener);
            // On a transform change, keep our local minimum (presumably unchanged), and our parent preferred size
            this.transformEmitter.addListener(this._updateLocalPreferredHeightListener);
            // On a transform change this should update the minimum
            this.transformEmitter.addListener(this._updateMinimumHeightListener);
        }
    });
    // If we're extending into a Node type, include option keys
    if (HeightSizableTrait.prototype._mutatorKeys) {
        const existingKeys = HeightSizableTrait.prototype._mutatorKeys;
        const newKeys = HEIGHT_SIZABLE_OPTION_KEYS;
        const indexOfBoundsBasedOptions = existingKeys.indexOf(REQUIRES_BOUNDS_OPTION_KEYS[0]);
        HeightSizableTrait.prototype._mutatorKeys = [
            ...existingKeys.slice(0, indexOfBoundsBasedOptions),
            ...newKeys,
            ...existingKeys.slice(indexOfBoundsBasedOptions)
        ];
    }
    return HeightSizableTrait;
});
const isHeightSizable = (node)=>{
    return node.heightSizable;
};
const extendsHeightSizable = (node)=>{
    return node.extendsHeightSizable;
};
scenery.register('HeightSizable', HeightSizable);
export default HeightSizable;
export { isHeightSizable, extendsHeightSizable };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbGF5b3V0L0hlaWdodFNpemFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogSGVpZ2h0U2l6YWJsZSBpcyBhIHRyYWl0IHRoYXQgcHJvdmlkZXMgYSBtaW5pbXVtIGFuZCBwcmVmZXJyZWQgaGVpZ2h0LiBUaGUgbWluaW11bSBoZWlnaHQgaXMgc2V0IGJ5IHRoZSBjb21wb25lbnQsXG4gKiBzbyB0aGF0IGxheW91dCBjb250YWluZXJzIGNvdWxkIGtub3cgaG93IFwic21hbGxcIiB0aGUgY29tcG9uZW50IGNhbiBiZSBtYWRlLiBUaGUgcHJlZmVycmVkIGhlaWdodCBpcyBzZXQgYnkgdGhlXG4gKiBsYXlvdXQgY29udGFpbmVyLCBhbmQgdGhlIGNvbXBvbmVudCBzaG91bGQgYWRqdXN0IGl0cyBzaXplIHNvIHRoYXQgaXQgdGFrZXMgdXAgdGhhdCBoZWlnaHQuXG4gKlxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxuICovXG5cbmltcG9ydCBUaW55UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UaW55UHJvcGVydHkuanMnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lbW9pemUuanMnO1xuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9Db25zdHJ1Y3Rvci5qcyc7XG5pbXBvcnQgSW50ZW50aW9uYWxBbnkgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcbmltcG9ydCB7IERlbGF5ZWRNdXRhdGUsIE5vZGUsIFJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUywgc2NlbmVyeSB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xuXG4vLyBQb3NpdGlvbiBjaGFuZ2VzIHNtYWxsZXIgdGhhbiB0aGlzIHdpbGwgYmUgaWdub3JlZFxuY29uc3QgQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCA9IDFlLTk7XG5cbmV4cG9ydCBjb25zdCBIRUlHSFRfU0laQUJMRV9PUFRJT05fS0VZUyA9IFtcbiAgJ3ByZWZlcnJlZEhlaWdodCcsXG4gICdtaW5pbXVtSGVpZ2h0JyxcbiAgJ2xvY2FsUHJlZmVycmVkSGVpZ2h0JyxcbiAgJ2xvY2FsTWluaW11bUhlaWdodCcsXG4gICdoZWlnaHRTaXphYmxlJ1xuXTtcblxuZXhwb3J0IHR5cGUgSGVpZ2h0U2l6YWJsZU9wdGlvbnMgPSB7XG4gIC8vIFNldHMgdGhlIHByZWZlcnJlZCBoZWlnaHQgb2YgdGhlIE5vZGUgaW4gdGhlIHBhcmVudCBjb29yZGluYXRlIGZyYW1lLiBOb2RlcyB0aGF0IGltcGxlbWVudCB0aGlzIHdpbGwgYXR0ZW1wdCB0byBrZWVwXG4gIC8vIHRoZWlyIGBub2RlLmhlaWdodGAgYXQgdGhpcyB2YWx1ZS4gSWYgbnVsbCwgdGhlIG5vZGUgd2lsbCBsaWtlbHkgc2V0IGl0cyBjb25maWd1cmF0aW9uIHRvIHRoZSBtaW5pbXVtIGhlaWdodC5cbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBsb2NhbFByZWZlcnJlZEhlaWdodCB3aWxsIGFkanVzdCB0aGUgb3RoZXIuXG4gIC8vIE5PVEU6IHByZWZlcnJlZEhlaWdodCBpcyBub3QgZ3VhcmFudGVlZCBjdXJyZW50bHkuIFRoZSBjb21wb25lbnQgbWF5IGVuZCB1cCBoYXZpbmcgYSBzbWFsbGVyIG9yIGxhcmdlciBzaXplXG4gIHByZWZlcnJlZEhlaWdodD86IG51bWJlciB8IG51bGw7XG5cbiAgLy8gU2V0cyB0aGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIE5vZGUgaW4gdGhlIHBhcmVudCBjb29yZGluYXRlIGZyYW1lLiBVc3VhbGx5IG5vdCBkaXJlY3RseSBzZXQgYnkgYSBjbGllbnQuXG4gIC8vIFVzdWFsbHkgYSByZXNpemFibGUgTm9kZSB3aWxsIHNldCBpdHMgbG9jYWxNaW5pbXVtSGVpZ2h0IChhbmQgdGhhdCB3aWxsIGdldCB0cmFuc2ZlcnJlZCB0byB0aGlzIHZhbHVlIGluIHRoZVxuICAvLyBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZSkuXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgbG9jYWxNaW5pbXVtSGVpZ2h0IHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cbiAgLy8gTk9URTogd2hlbiB0aGUgTm9kZSdzIHRyYW5zZm9ybSBpcyB1cGRhdGVkLCB0aGlzIHZhbHVlIGlzIHJlY29tcHV0ZWQgYmFzZWQgb24gbG9jYWxNaW5pbXVtSGVpZ2h0XG4gIG1pbmltdW1IZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8vIFNldHMgdGhlIHByZWZlcnJlZCBoZWlnaHQgb2YgdGhlIE5vZGUgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUuXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgcHJlZmVycmVkSGVpZ2h0IHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cbiAgLy8gTk9URTogd2hlbiB0aGUgTm9kZSdzIHRyYW5zZm9ybSBpcyB1cGRhdGVkLCB0aGlzIHZhbHVlIGlzIHJlY29tcHV0ZWQgYmFzZWQgb24gcHJlZmVycmVkSGVpZ2h0XG4gIC8vIE5PVEU6IGxvY2FsUHJlZmVycmVkSGVpZ2h0IGlzIG5vdCBndWFyYW50ZWVkIGN1cnJlbnRseS4gVGhlIGNvbXBvbmVudCBtYXkgZW5kIHVwIGhhdmluZyBhIHNtYWxsZXIgb3IgbGFyZ2VyIHNpemVcbiAgbG9jYWxQcmVmZXJyZWRIZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8vIFNldHMgdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSBOb2RlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lLiBVc3VhbGx5IHNldCBieSB0aGUgcmVzaXphYmxlIE5vZGUgaXRzZWxmIHRvXG4gIC8vIGluZGljYXRlIHdoYXQgcHJlZmVycmVkIHNpemVzIGFyZSBwb3NzaWJsZS5cbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBtaW5pbXVtSGVpZ2h0IHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cbiAgbG9jYWxNaW5pbXVtSGVpZ2h0PzogbnVtYmVyIHwgbnVsbDtcblxuICAvLyBXaGV0aGVyIHRoaXMgY29tcG9uZW50IHdpbGwgaGF2ZSBpdHMgcHJlZmVycmVkIHNpemUgc2V0IGJ5IHRoaW5ncyBsaWtlIGxheW91dCBjb250YWluZXJzLiBJZiB0aGlzIGlzIHNldCB0byBmYWxzZSxcbiAgLy8gaXQncyByZWNvbW1lbmRlZCB0byBzZXQgc29tZSBzb3J0IG9mIHByZWZlcnJlZCBzaXplIChzbyB0aGF0IGl0IHdvbid0IGdvIHRvIDApXG4gIGhlaWdodFNpemFibGU/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgVEhlaWdodFNpemFibGUgPSB7XG5cbiAgcmVhZG9ubHkgcHJlZmVycmVkSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgcmVhZG9ubHkgbWluaW11bUhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XG4gIHJlYWRvbmx5IGxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgcmVhZG9ubHkgbG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgcmVhZG9ubHkgaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eTogVGlueVByb3BlcnR5PGJvb2xlYW4+O1xuICBwcmVmZXJyZWRIZWlnaHQ6IG51bWJlciB8IG51bGw7XG4gIGxvY2FsUHJlZmVycmVkSGVpZ2h0OiBudW1iZXIgfCBudWxsO1xuICBtaW5pbXVtSGVpZ2h0OiBudW1iZXIgfCBudWxsO1xuICBsb2NhbE1pbmltdW1IZWlnaHQ6IG51bWJlciB8IG51bGw7XG4gIGhlaWdodFNpemFibGU6IGJvb2xlYW47XG4gIHZhbGlkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogdm9pZDtcblxuICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICBfcHJlZmVycmVkU2l6ZUNoYW5naW5nOiBib29sZWFuO1xuICBfbWluaW11bVNpemVDaGFuZ2luZzogYm9vbGVhbjtcbiAgX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jazogYm9vbGVhbjtcbiAgX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2s6IGJvb2xlYW47XG4gIF91cGRhdGVQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIF91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIF91cGRhdGVMb2NhbE1pbmltdW1IZWlnaHRMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0KCk6IG51bWJlciB8IG51bGw7XG4gIF9vblJlZW50cmFudFByZWZlcnJlZEhlaWdodCgpOiB2b2lkO1xuICBfY2FsY3VsYXRlUHJlZmVycmVkSGVpZ2h0KCk6IG51bWJlciB8IG51bGw7XG4gIF9jYWxjdWxhdGVMb2NhbE1pbmltdW1IZWlnaHQoKTogbnVtYmVyIHwgbnVsbDtcbiAgX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQ7XG4gIF9jYWxjdWxhdGVNaW5pbXVtSGVpZ2h0KCk6IG51bWJlciB8IG51bGw7XG59O1xuXG4vLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IEhlaWdodFNpemFibGUgd291bGQgdGFrZSB0aHJvdWdoIHRoZVxuLy8gY29uc3RydWN0b3IuIEl0IHdpbGwgaGl0IE5vZGUncyBtdXRhdGUoKSBsaWtlbHksIGFuZCB0aGVuIHdpbGwgZmFpbCBiZWNhdXNlIHdlIGhhdmVuJ3QgYmVlbiBhYmxlIHRvIHNldCB0aGVcbi8vIHZhbHVlcyB5ZXQuIElmIHlvdSdyZSBtYWtpbmcgc29tZXRoaW5nIEhlaWdodFNpemFibGUsIHBsZWFzZSB1c2UgYSBsYXRlciBtdXRhdGUoKSB0byBwYXNzIHRoZXNlIG9wdGlvbnMgdGhyb3VnaC5cbi8vIFRoZXkgV0lMTCBiZSBjYXVnaHQgYnkgYXNzZXJ0aW9ucyBpZiBzb21lb25lIGFkZHMgb25lIG9mIHRob3NlIG9wdGlvbnMsIGJ1dCBpdCBjb3VsZCBiZSBhIHNpbGVudCBidWcgaWYgbm8gb25lXG4vLyBpcyB5ZXQgcGFzc2luZyB0aG9zZSBvcHRpb25zIHRocm91Z2guXG5jb25zdCBIZWlnaHRTaXphYmxlID0gbWVtb2l6ZSggPFN1cGVyVHlwZSBleHRlbmRzIENvbnN0cnVjdG9yPE5vZGU+PiggVHlwZTogU3VwZXJUeXBlICk6IFN1cGVyVHlwZSAmIENvbnN0cnVjdG9yPFRIZWlnaHRTaXphYmxlPiA9PiB7XG4gIGNvbnN0IEhlaWdodFNpemFibGVUcmFpdCA9IERlbGF5ZWRNdXRhdGUoICdIZWlnaHRTaXphYmxlJywgSEVJR0hUX1NJWkFCTEVfT1BUSU9OX0tFWVMsXG4gICAgY2xhc3MgSGVpZ2h0U2l6YWJsZVRyYWl0IGV4dGVuZHMgVHlwZSBpbXBsZW1lbnRzIFRIZWlnaHRTaXphYmxlIHtcblxuICAgICAgLy8gcGFyZW50L2xvY2FsIHByZWZlcnJlZC9taW5pbXVtIFByb3BlcnRpZXMuIFNlZSB0aGUgb3B0aW9ucyBhYm92ZSBmb3IgbW9yZSBkb2N1bWVudGF0aW9uXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcHJlZmVycmVkSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcbiAgICAgIHB1YmxpYyByZWFkb25seSBtaW5pbXVtSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcbiAgICAgIHB1YmxpYyByZWFkb25seSBsb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcbiAgICAgIHB1YmxpYyByZWFkb25seSBpc0hlaWdodFJlc2l6YWJsZVByb3BlcnR5OiBUaW55UHJvcGVydHk8Ym9vbGVhbj4gPSBuZXcgVGlueVByb3BlcnR5PGJvb2xlYW4+KCB0cnVlICk7XG5cbiAgICAgIC8vIEZsYWdzIHNvIHRoYXQgd2UgY2FuIGNoYW5nZSBvbmUgKHBhcmVudC9sb2NhbCkgdmFsdWUgYW5kIG5vdCBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGNoYW5naW5nIHRoZSBvdGhlcnMuXG4gICAgICAvLyBXZSB3YW50IHRvIGxvY2sgb3V0IGFsbCBvdGhlciBsb2NhbCBvciBub24tbG9jYWwgcHJlZmVycmVkIG1pbmltdW0gc2l6ZXMsIHdoZXRoZXIgaW4gSGVpZ2h0U2l6YWJsZSBvciBXaWR0aFNpemFibGVcbiAgICAgIC8vIE5PVEU6IFdlIGFyZSBtZXJnaW5nIGRlY2xhcmF0aW9ucyBiZXR3ZWVuIEhlaWdodFNpemFibGUgYW5kIFdpZHRoU2l6YWJsZS4gSWYgU2l6YWJsZSBpcyB1c2VkIHRoZXNlIGZsYWdzXG4gICAgICAvLyB3aWxsIGJlIHNoYXJlZCBieSBib3RoIEhlaWdodFNpemFibGUgYW5kIFdpZHRoU2l6YWJsZS5cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfbWluaW11bVNpemVDaGFuZ2luZyA9IGZhbHNlO1xuXG4gICAgICAvLyBXZSdsbCBuZWVkIHRvIGRldGVjdCByZWVudHJhbmN5IHdoZW4gc2V0dGluZyB0aGUgZHVhbCBvZiB0aGUgcHJlZmVycmVkL21pbmltdW0gcHJvcGVydGllcyAoZS5nLiBsb2NhbCB2cyBwYXJlbnQpLlxuICAgICAgLy8gSWYgd2UgZ2V0IGEgcmVlbnRyYW50IGNhc2UsIHdlJ2xsIG5lZWQgdG8gZGV0ZWN0IGl0IGFuZCBjbGVhciB0aGluZ3MgdXAgYXQgdGhlIGVuZCAodXBkYXRpbmcgdGhlIG1pbmltdW0gc2l6ZVxuICAgICAgLy8gaW4gdGhlIHBhcmVudCBjb29yZGluYXRlIGZyYW1lLCBhbmQgdGhlIHByZWZlcnJlZCBzaXplIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lKS5cbiAgICAgIC8vIEFuIGV4YW1wbGUgaXMgaWYgdGhlIG1pbmltdW0gc2l6ZSBpcyBzZXQsIGFuZCB0aGF0IHRyaWdnZXJzIGEgbGlzdGVuZXIgdGhhdCBVUERBVEVTIHNvbWV0aGluZyB0aGF0IGNoYW5nZXMgdGhlXG4gICAgICAvLyBtaW5pbXVtIHNpemUsIHdlJ2xsIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGxvY2FsIG1pbmltdW0gc2l6ZSBpcyB1cGRhdGVkIEFGVEVSIGV2ZXJ5dGhpbmcgaGFzIGhhcHBlbmVkLlxuICAgICAgLy8gVGhlc2UgbG9ja3MgYXJlIHVzZWQgdG8gZGV0ZWN0IHRoZXNlIGNhc2VzLCBhbmQgdGhlbiBydW4gdGhlIGFwcHJvcHJpYXRlIHVwZGF0ZXMgYWZ0ZXJ3YXJkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZVxuICAgICAgLy8gbG9jYWwgYW5kIHBhcmVudCB2YWx1ZXMgYXJlIGluIHN5bmMgKGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gdXNlZCkuXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxuICAgICAgcHVibGljIF9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcblxuICAgICAgLy8gRXhwb3NlIGxpc3RlbmVycywgc28gdGhhdCB3ZSdsbCBiZSBhYmxlIHRvIGhvb2sgdGhlbSB1cCB0byB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uIGluIFNpemFibGVcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX3VwZGF0ZU1pbmltdW1IZWlnaHRMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gICAgICAvLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IEhlaWdodFNpemFibGUgd291bGQgdGFrZSB0aHJvdWdoIHRoZVxuICAgICAgLy8gY29uc3RydWN0b3IuIEl0IHdpbGwgaGl0IE5vZGUncyBtdXRhdGUoKSBsaWtlbHksIGFuZCB0aGVuIHdpbGwgZmFpbCBiZWNhdXNlIHdlIGhhdmVuJ3QgYmVlbiBhYmxlIHRvIHNldCB0aGVcbiAgICAgIC8vIHZhbHVlcyB5ZXQuIElmIHlvdSdyZSBtYWtpbmcgc29tZXRoaW5nIEhlaWdodFNpemFibGUsIHBsZWFzZSB1c2UgYSBsYXRlciBtdXRhdGUoKSB0byBwYXNzIHRoZXNlIG9wdGlvbnMgdGhyb3VnaC5cbiAgICAgIC8vIFRoZXkgV0lMTCBiZSBjYXVnaHQgYnkgYXNzZXJ0aW9ucyBpZiBzb21lb25lIGFkZHMgb25lIG9mIHRob3NlIG9wdGlvbnMsIGJ1dCBpdCBjb3VsZCBiZSBhIHNpbGVudCBidWcgaWYgbm8gb25lXG4gICAgICAvLyBpcyB5ZXQgcGFzc2luZyB0aG9zZSBvcHRpb25zIHRocm91Z2guXG4gICAgICBwdWJsaWMgY29uc3RydWN0b3IoIC4uLmFyZ3M6IEludGVudGlvbmFsQW55W10gKSB7XG4gICAgICAgIHN1cGVyKCAuLi5hcmdzICk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIgPSB0aGlzLl91cGRhdGVQcmVmZXJyZWRIZWlnaHQuYmluZCggdGhpcyApO1xuICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQuYmluZCggdGhpcyApO1xuICAgICAgICB0aGlzLl91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXIgPSB0aGlzLl91cGRhdGVNaW5pbXVtSGVpZ2h0LmJpbmQoIHRoaXMgKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0TGlzdGVuZXIgPSB0aGlzLl91cGRhdGVMb2NhbE1pbmltdW1IZWlnaHQuYmluZCggdGhpcyApO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgb3Bwb3NpdGUgb2YgcGFyZW50L2xvY2FsIHdoZW4gb25lIGNoYW5nZXNcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lciApO1xuICAgICAgICB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyICk7XG4gICAgICAgIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMb2NhbE1pbmltdW1IZWlnaHRMaXN0ZW5lciApO1xuICAgICAgICB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXIgKTtcblxuICAgICAgICAvLyBPbiBhIHRyYW5zZm9ybSBjaGFuZ2UsIGtlZXAgb3VyIGxvY2FsIG1pbmltdW0gKHByZXN1bWFibHkgdW5jaGFuZ2VkKSwgYW5kIG91ciBwYXJlbnQgcHJlZmVycmVkIHNpemVcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyICk7XG4gICAgICAgIC8vIE9uIGEgdHJhbnNmb3JtIGNoYW5nZSB0aGlzIHNob3VsZCB1cGRhdGUgdGhlIG1pbmltdW1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXIgKTtcbiAgICAgIH1cblxuICAgICAgcHVibGljIGdldCBwcmVmZXJyZWRIZWlnaHQoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHksXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHVibGljIHNldCBwcmVmZXJyZWRIZWlnaHQoIHZhbHVlOiBudW1iZXIgfCBudWxsICkge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09IG51bGwgfHwgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIHZhbHVlID49IDAgKSxcbiAgICAgICAgICAncHJlZmVycmVkSGVpZ2h0IHNob3VsZCBiZSBudWxsIG9yIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXInICk7XG5cbiAgICAgICAgdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgZ2V0IGxvY2FsUHJlZmVycmVkSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHksXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgc2V0IGxvY2FsUHJlZmVycmVkSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09IG51bGwgfHwgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIHZhbHVlID49IDAgKSxcbiAgICAgICAgICAnbG9jYWxQcmVmZXJyZWRIZWlnaHQgc2hvdWxkIGJlIG51bGwgb3IgYSBub24tbmVnYXRpdmUgZmluaXRlIG51bWJlcicgKTtcblxuICAgICAgICB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHVibGljIGdldCBtaW5pbXVtSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLm1pbmltdW1IZWlnaHRQcm9wZXJ0eSxcbiAgICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1IZWlnaHRQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHVibGljIHNldCBtaW5pbXVtSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHksXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgKSApO1xuXG4gICAgICAgIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBnZXQgbG9jYWxNaW5pbXVtSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LFxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBzZXQgbG9jYWxNaW5pbXVtSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eSxcbiAgICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XG5cbiAgICAgICAgdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGhlaWdodFNpemFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eSxcbiAgICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSGVpZ2h0UmVzaXphYmxlUHJvcGVydHkudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpYyBvdmVycmlkZSBzZXQgaGVpZ2h0U2l6YWJsZSggdmFsdWU6IGJvb2xlYW4gKSB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eSxcbiAgICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XG4gICAgICAgIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGV4dGVuZHNIZWlnaHRTaXphYmxlKCk6IGJvb2xlYW4geyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICBwdWJsaWMgdmFsaWRhdGVMb2NhbFByZWZlcnJlZEhlaWdodCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCBhc3NlcnQgKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IHRoaXMubG9jYWxIZWlnaHQ7XG4gICAgICAgICAgY29uc3QgZWZmZWN0aXZlTWluaW11bUhlaWdodCA9IHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0ID09PSBudWxsID8gY3VycmVudEhlaWdodCA6IHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IGlkZWFsSGVpZ2h0ID0gdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodCA9PT0gbnVsbCA/IGVmZmVjdGl2ZU1pbmltdW1IZWlnaHQgOiB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0O1xuXG4gICAgICAgICAgLy8gSGFuZGxlIG5vbi1maW5pdGUgdmFsdWVzIHdpdGggZXhhY3QgZXF1YWxpdHlcbiAgICAgICAgICBhc3NlcnQoIGlkZWFsSGVpZ2h0ID09PSBjdXJyZW50SGVpZ2h0IHx8IE1hdGguYWJzKCBpZGVhbEhlaWdodCAtIGN1cnJlbnRIZWlnaHQgKSA8IDFlLTcgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMucHJlZmVycmVkSGVpZ2h0ICE9PSBudWxsIClcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLmludmVyc2VEZWx0YVkoIHRoaXMucHJlZmVycmVkSGVpZ2h0ICkgKVxuICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm92aWRlcyBhIGhvb2sgdG8gU2l6YWJsZSwgc2luY2Ugd2UnbGwgbmVlZCB0byBjcm9zcy1saW5rIHRoaXMgdG8gYWxzbyB0cnkgdXBkYXRpbmcgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfb25SZWVudHJhbnRQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIoKTtcbiAgICAgIH1cblxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XG4gICAgICAgIGFzc2VydCAmJiB0aGlzLmF1ZGl0TWF4RGltZW5zaW9ucygpO1xuXG4gICAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gU2luY2UgdGhlIGxvY2FsIFwicHJlZmVycmVkXCIgc2l6ZSBpcyB0aGUgb25lIHRoYXQgd2UnbGwgd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgaWYgd2UgZXhwZXJpZW5jZVxuICAgICAgICAgIC8vIHJlZW50cmFuY3kgKHNpbmNlIHdlIHRyZWF0IHRoZSBub24tbG9jYWwgdmVyc2lvbiBhcyB0aGUgZ3JvdW5kIHRydXRoKSwgd2UnbGwgbG9vcCBoZXJlIHVudGlsIHdlIGRpZG4ndCBnZXRcbiAgICAgICAgICAvLyBhbiBhdHRlbXB0IHRvIGNoYW5nZSBpdC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIGNoYW5nZXMsIHdlJ2xsIGhhdmUgYSBjb25zaXN0ZW50IHByZWZlcnJlZCBhbmRcbiAgICAgICAgICAvLyBsb2NhbFByZWZlcnJlZCBzaXplLlxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFByZWZlcnJlZEhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsUHJlZmVycmVkSGVpZ2h0ID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgLSBsb2NhbFByZWZlcnJlZEhlaWdodCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID0gbG9jYWxQcmVmZXJyZWRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICggdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICk7XG5cbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfY2FsY3VsYXRlUHJlZmVycmVkSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHQgIT09IG51bGwgKVxuICAgICAgICAgICAgICAgPyBNYXRoLmFicyggdGhpcy50cmFuc2Zvcm0udHJhbnNmb3JtRGVsdGFZKCB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0ICkgKVxuICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBwcml2YXRlIF91cGRhdGVQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XG4gICAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWRIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVQcmVmZXJyZWRIZWlnaHQoKTtcblxuICAgICAgICAgIGlmICggdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgcHJlZmVycmVkSGVpZ2h0ID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSAtIHByZWZlcnJlZEhlaWdodCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcbiAgICAgICAgICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgPSBwcmVmZXJyZWRIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gSGVyZSwgaW4gdGhlIGNhc2Ugb2YgcmVlbnRyYW5jZSwgd2UnbGwgYWN0dWFsbHkgd2FudCB0byBzd2l0Y2ggdG8gdXBkYXRpbmcgdGhlIGxvY2FsIHByZWZlcnJlZCBzaXplLCBzaW5jZVxuICAgICAgICAgIC8vIGdpdmVuIGFueSBvdGhlciBjaGFuZ2VzIGl0IHNob3VsZCBiZSB0aGUgcHJpbWFyeSBvbmUgdG8gY2hhbmdlLlxuICAgICAgICAgIGlmICggdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICkge1xuICAgICAgICAgICAgdGhpcy5fb25SZWVudHJhbnRQcmVmZXJyZWRIZWlnaHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZUxvY2FsTWluaW11bUhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5taW5pbXVtSGVpZ2h0ICE9PSBudWxsIClcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLmludmVyc2VEZWx0YVkoIHRoaXMubWluaW11bUhlaWdodCApIClcbiAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcbiAgICAgIHB1YmxpYyBfb25SZWVudHJhbnRMb2NhbE1pbmltdW1IZWlnaHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1IZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQge1xuICAgICAgICBpZiAoICF0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nICkge1xuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgbG9jYWxNaW5pbXVtSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk7XG5cbiAgICAgICAgICBpZiAoIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgIGxvY2FsTWluaW11bUhlaWdodCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgLSBsb2NhbE1pbmltdW1IZWlnaHQgKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID0gbG9jYWxNaW5pbXVtSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBIZXJlLCBpbiB0aGUgY2FzZSBvZiByZWVudHJhbmNlLCB3ZSdsbCBhY3R1YWxseSB3YW50IHRvIHN3aXRjaCB0byB1cGRhdGluZyB0aGUgbm9uLWxvY2FsIG1pbmltdW0gc2l6ZSwgc2luY2VcbiAgICAgICAgICAvLyBnaXZlbiBhbnkgb3RoZXIgY2hhbmdlcyBpdCBzaG91bGQgYmUgdGhlIHByaW1hcnkgb25lIHRvIGNoYW5nZS5cbiAgICAgICAgICBpZiAoIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgKSB7XG4gICAgICAgICAgICB0aGlzLl9vblJlZW50cmFudExvY2FsTWluaW11bUhlaWdodCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZU1pbmltdW1IZWlnaHQoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0ICE9PSBudWxsIClcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWSggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHQgKSApXG4gICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByaXZhdGUgX3VwZGF0ZU1pbmltdW1IZWlnaHQoKTogdm9pZCB7XG4gICAgICAgIGlmICggIXRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgKSB7XG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9uLWxvY2FsIFwibWluaW11bVwiIHNpemUgaXMgdGhlIG9uZSB0aGF0IHdlJ2xsIHdhbnQgdG8gY29udGludWUgdG8gdXBkYXRlIGlmIHdlIGV4cGVyaWVuY2VcbiAgICAgICAgICAvLyByZWVudHJhbmN5IChzaW5jZSB3ZSB0cmVhdCB0aGUgbG9jYWwgdmVyc2lvbiBhcyB0aGUgZ3JvdW5kIHRydXRoKSwgd2UnbGwgbG9vcCBoZXJlIHVudGlsIHdlIGRpZG4ndCBnZXRcbiAgICAgICAgICAvLyBhbiBhdHRlbXB0IHRvIGNoYW5nZSBpdC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIGNoYW5nZXMsIHdlJ2xsIGhhdmUgYSBjb25zaXN0ZW50IG1pbmltdW0gYW5kXG4gICAgICAgICAgLy8gbG9jYWxNaW5pbXVtIHNpemUuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBtaW5pbXVtSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlTWluaW11bUhlaWdodCgpO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgIG1pbmltdW1IZWlnaHQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlIC0gbWluaW11bUhlaWdodCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcbiAgICAgICAgICAgICAgdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgPSBtaW5pbXVtSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgKTtcblxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKCBvcHRpb25zPzogSGVpZ2h0U2l6YWJsZU9wdGlvbnMgJiBQYXJhbWV0ZXJzPEluc3RhbmNlVHlwZTxTdXBlclR5cGU+WyAnbXV0YXRlJyBdPlsgMCBdICk6IHRoaXMge1xuICAgICAgICByZXR1cm4gc3VwZXIubXV0YXRlKCBvcHRpb25zICk7XG4gICAgICB9XG4gICAgfSApO1xuXG4gIC8vIElmIHdlJ3JlIGV4dGVuZGluZyBpbnRvIGEgTm9kZSB0eXBlLCBpbmNsdWRlIG9wdGlvbiBrZXlzXG4gIGlmICggSGVpZ2h0U2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXMgKSB7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gSGVpZ2h0U2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXM7XG4gICAgY29uc3QgbmV3S2V5cyA9IEhFSUdIVF9TSVpBQkxFX09QVElPTl9LRVlTO1xuICAgIGNvbnN0IGluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMgPSBleGlzdGluZ0tleXMuaW5kZXhPZiggUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTWyAwIF0gKTtcbiAgICBIZWlnaHRTaXphYmxlVHJhaXQucHJvdG90eXBlLl9tdXRhdG9yS2V5cyA9IFtcbiAgICAgIC4uLmV4aXN0aW5nS2V5cy5zbGljZSggMCwgaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyApLFxuICAgICAgLi4ubmV3S2V5cyxcbiAgICAgIC4uLmV4aXN0aW5nS2V5cy5zbGljZSggaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyApXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiBIZWlnaHRTaXphYmxlVHJhaXQ7XG59ICk7XG5cbi8vIFNvbWUgdHlwZXNjcmlwdCBneW1uYXN0aWNzIHRvIHByb3ZpZGUgYSB1c2VyLWRlZmluZWQgdHlwZSBndWFyZCB0aGF0IHRyZWF0cyBzb21ldGhpbmcgYXMgSGVpZ2h0U2l6YWJsZS5cbi8vIFdlIG5lZWQgdG8gZGVmaW5lIGFuIHVudXNlZCBmdW5jdGlvbiB3aXRoIGEgY29uY3JldGUgdHlwZSwgc28gdGhhdCB3ZSBjYW4gZXh0cmFjdCB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIGZ1bmN0aW9uXG4vLyBhbmQgcHJvdmlkZSBhIHR5cGUgZm9yIGEgTm9kZSB0aGF0IGV4dGVuZHMgdGhpcyB0eXBlLlxuZXhwb3J0IHR5cGUgSGVpZ2h0U2l6YWJsZU5vZGUgPSBOb2RlICYgVEhlaWdodFNpemFibGU7XG5cbmNvbnN0IGlzSGVpZ2h0U2l6YWJsZSA9ICggbm9kZTogTm9kZSApOiBub2RlIGlzIEhlaWdodFNpemFibGVOb2RlID0+IHtcbiAgcmV0dXJuIG5vZGUuaGVpZ2h0U2l6YWJsZTtcbn07XG5jb25zdCBleHRlbmRzSGVpZ2h0U2l6YWJsZSA9ICggbm9kZTogTm9kZSApOiBub2RlIGlzIEhlaWdodFNpemFibGVOb2RlID0+IHtcbiAgcmV0dXJuIG5vZGUuZXh0ZW5kc0hlaWdodFNpemFibGU7XG59O1xuXG5zY2VuZXJ5LnJlZ2lzdGVyKCAnSGVpZ2h0U2l6YWJsZScsIEhlaWdodFNpemFibGUgKTtcbmV4cG9ydCBkZWZhdWx0IEhlaWdodFNpemFibGU7XG5leHBvcnQgeyBpc0hlaWdodFNpemFibGUsIGV4dGVuZHNIZWlnaHRTaXphYmxlIH07Il0sIm5hbWVzIjpbIlRpbnlQcm9wZXJ0eSIsIm1lbW9pemUiLCJEZWxheWVkTXV0YXRlIiwiUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTIiwic2NlbmVyeSIsIkNIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQiLCJIRUlHSFRfU0laQUJMRV9PUFRJT05fS0VZUyIsIkhlaWdodFNpemFibGUiLCJUeXBlIiwiSGVpZ2h0U2l6YWJsZVRyYWl0IiwicHJlZmVycmVkSGVpZ2h0IiwiYXNzZXJ0IiwicHJlZmVycmVkSGVpZ2h0UHJvcGVydHkiLCJ2YWx1ZSIsImlzRmluaXRlIiwibG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJsb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5IiwibWluaW11bUhlaWdodCIsIm1pbmltdW1IZWlnaHRQcm9wZXJ0eSIsImxvY2FsTWluaW11bUhlaWdodCIsImxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5IiwiaGVpZ2h0U2l6YWJsZSIsImlzSGVpZ2h0UmVzaXphYmxlUHJvcGVydHkiLCJleHRlbmRzSGVpZ2h0U2l6YWJsZSIsInZhbGlkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJjdXJyZW50SGVpZ2h0IiwibG9jYWxIZWlnaHQiLCJlZmZlY3RpdmVNaW5pbXVtSGVpZ2h0IiwiaWRlYWxIZWlnaHQiLCJNYXRoIiwiYWJzIiwiX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0IiwibWF0cml4IiwiaXNBbGlnbmVkIiwidHJhbnNmb3JtIiwiaW52ZXJzZURlbHRhWSIsIl9vblJlZW50cmFudFByZWZlcnJlZEhlaWdodCIsIl91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyIiwiX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0IiwiYXVkaXRNYXhEaW1lbnNpb25zIiwiX3ByZWZlcnJlZFNpemVDaGFuZ2luZyIsIl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2siLCJfY2FsY3VsYXRlUHJlZmVycmVkSGVpZ2h0IiwidHJhbnNmb3JtRGVsdGFZIiwiX3VwZGF0ZVByZWZlcnJlZEhlaWdodCIsIl9jYWxjdWxhdGVMb2NhbE1pbmltdW1IZWlnaHQiLCJfb25SZWVudHJhbnRMb2NhbE1pbmltdW1IZWlnaHQiLCJfdXBkYXRlTWluaW11bUhlaWdodCIsIl91cGRhdGVMb2NhbE1pbmltdW1IZWlnaHQiLCJfbWluaW11bVNpemVDaGFuZ2luZyIsIl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrIiwiX2NhbGN1bGF0ZU1pbmltdW1IZWlnaHQiLCJtdXRhdGUiLCJvcHRpb25zIiwiYXJncyIsIl91cGRhdGVQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lciIsImJpbmQiLCJfdXBkYXRlTWluaW11bUhlaWdodExpc3RlbmVyIiwiX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyIiwibGF6eUxpbmsiLCJ0cmFuc2Zvcm1FbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJleGlzdGluZ0tleXMiLCJuZXdLZXlzIiwiaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyIsImluZGV4T2YiLCJzbGljZSIsImlzSGVpZ2h0U2l6YWJsZSIsIm5vZGUiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7Ozs7Q0FNQyxHQUVELE9BQU9BLGtCQUFrQixtQ0FBbUM7QUFDNUQsT0FBT0MsYUFBYSxtQ0FBbUM7QUFHdkQsU0FBU0MsYUFBYSxFQUFRQywyQkFBMkIsRUFBRUMsT0FBTyxRQUFRLGdCQUFnQjtBQUUxRixxREFBcUQ7QUFDckQsTUFBTUMsNEJBQTRCO0FBRWxDLE9BQU8sTUFBTUMsNkJBQTZCO0lBQ3hDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFDO0FBK0RGLGlIQUFpSDtBQUNqSCw4R0FBOEc7QUFDOUcsbUhBQW1IO0FBQ25ILGlIQUFpSDtBQUNqSCx3Q0FBd0M7QUFDeEMsTUFBTUMsZ0JBQWdCTixRQUFTLENBQXVDTztJQUNwRSxNQUFNQyxxQkFBcUJQLGNBQWUsaUJBQWlCSSw0QkFDekQsTUFBTUcsMkJBQTJCRDtRQWlFL0IsSUFBV0Usa0JBQWlDO1lBQzFDQyxVQUFVQSxPQUFRLElBQUksQ0FBQ0MsdUJBQXVCLEVBQzVDO1lBQ0YsT0FBTyxJQUFJLENBQUNBLHVCQUF1QixDQUFDQyxLQUFLO1FBQzNDO1FBRUEsSUFBV0gsZ0JBQWlCRyxLQUFvQixFQUFHO1lBQ2pERixV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