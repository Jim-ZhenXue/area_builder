// Copyright 2013-2023, University of Colorado Boulder
/**
 * An enumeration of different back-end technologies used for rendering. It also essentially represents the API that
 * nodes need to implement to be used with this specified back-end.
 *
 * We use a bitmask to represent renderers currently, in a way that can be logically-ANDed in order to obtain
 * information about "what renderer can support all of these Nodes?"
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import { scenery } from '../imports.js';
// now it's a namespace
const Renderer = {};
scenery.register('Renderer', Renderer);
//OHTWO TODO: rename to take advantage of lack of deprecated names? (remove bitmask prefix) https://github.com/phetsims/scenery/issues/1581
/*---------------------------------------------------------------------------*
 * Renderer bitmask flags
 *---------------------------------------------------------------------------*/ Renderer.numActiveRenderers = 4;
Renderer.bitsPerRenderer = 5;
Renderer.bitmaskRendererArea = 0x00000FF;
Renderer.bitmaskCurrentRendererArea = 0x000000F;
Renderer.bitmaskLacksOffset = 0x10000;
Renderer.bitmaskLacksShift = 16; // number of bits between the main renderer bitmask and the "lacks" variety
Renderer.bitmaskNodeDefault = Renderer.bitmaskRendererArea;
Renderer.bitmaskCanvas = 0x0000001;
Renderer.bitmaskSVG = 0x0000002;
Renderer.bitmaskDOM = 0x0000004;
Renderer.bitmaskWebGL = 0x0000008;
// 10, 20, 40, 80 reserved for future renderers NOTE: update bitmaskCurrentRendererArea/numActiveRenderers if they are added/removed
// summary bits (for RendererSummary):
Renderer.bitmaskSingleCanvas = 0x100;
Renderer.bitmaskSingleSVG = 0x200;
// reserved gap 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000 for future renderer-specific single information
Renderer.bitmaskNotPainted = 0x1000;
Renderer.bitmaskBoundsValid = 0x2000;
Renderer.bitmaskNoPDOM = 0x4000;
// summary bits for whether a renderer could be potentially used to display a Node.
Renderer.bitmaskLacksCanvas = Renderer.bitmaskCanvas << Renderer.bitmaskLacksShift; // 0x10000
Renderer.bitmaskLacksSVG = Renderer.bitmaskSVG << Renderer.bitmaskLacksShift; // 0x20000
Renderer.bitmaskLacksDOM = Renderer.bitmaskDOM << Renderer.bitmaskLacksShift; // 0x40000
Renderer.bitmaskLacksWebGL = Renderer.bitmaskWebGL << Renderer.bitmaskLacksShift; // 0x80000
// reserved gap 0x10000, 0x20000, 0x40000, 0x80000 for future renderers
Renderer.isCanvas = function(bitmask) {
    return (bitmask & Renderer.bitmaskCanvas) !== 0;
};
Renderer.isSVG = function(bitmask) {
    return (bitmask & Renderer.bitmaskSVG) !== 0;
};
Renderer.isDOM = function(bitmask) {
    return (bitmask & Renderer.bitmaskDOM) !== 0;
};
Renderer.isWebGL = function(bitmask) {
    return (bitmask & Renderer.bitmaskWebGL) !== 0;
};
const rendererMap = {
    canvas: Renderer.bitmaskCanvas,
    svg: Renderer.bitmaskSVG,
    dom: Renderer.bitmaskDOM,
    webgl: Renderer.bitmaskWebGL
};
Renderer.fromName = function(name) {
    return rendererMap[name];
};
// returns the part of the bitmask that should contain only Canvas/SVG/DOM/WebGL flags
//OHTWO TODO: use this instead of direct access to bitmaskRendererArea https://github.com/phetsims/scenery/issues/1581
Renderer.stripBitmask = function(bitmask) {
    return bitmask & Renderer.bitmaskRendererArea;
};
Renderer.createOrderBitmask = function(firstRenderer, secondRenderer, thirdRenderer, fourthRenderer) {
    firstRenderer = firstRenderer || 0;
    secondRenderer = secondRenderer || 0;
    thirdRenderer = thirdRenderer || 0;
    fourthRenderer = fourthRenderer || 0;
    // uses 20 bits now with 4 renderers
    return firstRenderer | secondRenderer << 5 | thirdRenderer << 10 | fourthRenderer << 15;
};
// bitmaskOrderN with n=0 is bitmaskOrderFirst, n=1 is bitmaskOrderSecond, etc.
Renderer.bitmaskOrder = function(bitmask, n) {
    // Normally the condition here shouldn't be needed, but Safari seemed to cause a logic error when this function
    // gets inlined elsewhere if n=0. See https://github.com/phetsims/scenery/issues/481 and
    // https://github.com/phetsims/bending-light/issues/259.
    if (n > 0) {
        bitmask = bitmask >> 5 * n;
    }
    return bitmask & Renderer.bitmaskCurrentRendererArea;
};
Renderer.bitmaskOrderFirst = function(bitmask) {
    return bitmask & Renderer.bitmaskCurrentRendererArea;
};
Renderer.bitmaskOrderSecond = function(bitmask) {
    return bitmask >> 5 & Renderer.bitmaskCurrentRendererArea;
};
Renderer.bitmaskOrderThird = function(bitmask) {
    return bitmask >> 10 & Renderer.bitmaskCurrentRendererArea;
};
Renderer.bitmaskOrderFourth = function(bitmask) {
    return bitmask >> 15 & Renderer.bitmaskCurrentRendererArea;
};
Renderer.pushOrderBitmask = function(bitmask, renderer) {
    assert && assert(typeof bitmask === 'number');
    assert && assert(typeof renderer === 'number');
    let rendererToInsert = renderer;
    const totalBits = Renderer.bitsPerRenderer * Renderer.numActiveRenderers;
    for(let i = 0; i <= totalBits; i += Renderer.bitsPerRenderer){
        const currentRenderer = bitmask >> i & Renderer.bitmaskCurrentRendererArea;
        if (currentRenderer === rendererToInsert) {
            return bitmask;
        } else if (currentRenderer === 0) {
            // place the renderer and exit
            bitmask = bitmask | rendererToInsert << i;
            return bitmask;
        } else {
            // clear out that slot
            bitmask = bitmask & ~(Renderer.bitmaskCurrentRendererArea << i);
            // place in the renderer to insert
            bitmask = bitmask | rendererToInsert << i;
            rendererToInsert = currentRenderer;
        }
        // don't walk over and re-place our initial renderer
        if (rendererToInsert === renderer) {
            return bitmask;
        }
    }
    throw new Error('pushOrderBitmask overflow');
};
Renderer.createSelfDrawable = function(instance, node, selfRenderer, fittable) {
    let drawable;
    if (Renderer.isCanvas(selfRenderer)) {
        drawable = node.createCanvasDrawable(selfRenderer, instance);
    } else if (Renderer.isSVG(selfRenderer)) {
        drawable = node.createSVGDrawable(selfRenderer, instance);
    } else if (Renderer.isDOM(selfRenderer)) {
        drawable = node.createDOMDrawable(selfRenderer, instance);
    } else if (Renderer.isWebGL(selfRenderer)) {
        drawable = node.createWebGLDrawable(selfRenderer, instance);
    } else {
        throw new Error(`Unrecognized renderer: ${selfRenderer}`);
    }
    // Check to make sure that all of the drawables have the required mark-dirty methods available.
    if (assert) {
        _.each(node.drawableMarkFlags, (flag)=>{
            const methodName = `markDirty${flag[0].toUpperCase()}${flag.slice(1)}`;
            assert(typeof drawable[methodName] === 'function', `Did not find ${methodName}`);
        });
    }
    // Initialize its fittable flag
    drawable.setFittable(fittable);
    return drawable;
};
/*---------------------------------------------------------------------------*
 * WebGL Renderer type enumeration
 *----------------------------------------------------------------------------*/ Renderer.webglCustom = 0x1;
Renderer.webglTexturedTriangles = 0x2;
Renderer.webglVertexColorPolygons = 0x3;
export default Renderer;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvZGlzcGxheS9SZW5kZXJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMy0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiBkaWZmZXJlbnQgYmFjay1lbmQgdGVjaG5vbG9naWVzIHVzZWQgZm9yIHJlbmRlcmluZy4gSXQgYWxzbyBlc3NlbnRpYWxseSByZXByZXNlbnRzIHRoZSBBUEkgdGhhdFxuICogbm9kZXMgbmVlZCB0byBpbXBsZW1lbnQgdG8gYmUgdXNlZCB3aXRoIHRoaXMgc3BlY2lmaWVkIGJhY2stZW5kLlxuICpcbiAqIFdlIHVzZSBhIGJpdG1hc2sgdG8gcmVwcmVzZW50IHJlbmRlcmVycyBjdXJyZW50bHksIGluIGEgd2F5IHRoYXQgY2FuIGJlIGxvZ2ljYWxseS1BTkRlZCBpbiBvcmRlciB0byBvYnRhaW5cbiAqIGluZm9ybWF0aW9uIGFib3V0IFwid2hhdCByZW5kZXJlciBjYW4gc3VwcG9ydCBhbGwgb2YgdGhlc2UgTm9kZXM/XCJcbiAqXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XG4gKi9cblxuaW1wb3J0IHsgc2NlbmVyeSB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xuXG4vLyBub3cgaXQncyBhIG5hbWVzcGFjZVxuY29uc3QgUmVuZGVyZXIgPSB7fTtcbnNjZW5lcnkucmVnaXN0ZXIoICdSZW5kZXJlcicsIFJlbmRlcmVyICk7XG5cbi8vT0hUV08gVE9ETzogcmVuYW1lIHRvIHRha2UgYWR2YW50YWdlIG9mIGxhY2sgb2YgZGVwcmVjYXRlZCBuYW1lcz8gKHJlbW92ZSBiaXRtYXNrIHByZWZpeCkgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3NjZW5lcnkvaXNzdWVzLzE1ODFcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG4gKiBSZW5kZXJlciBiaXRtYXNrIGZsYWdzXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblJlbmRlcmVyLm51bUFjdGl2ZVJlbmRlcmVycyA9IDQ7XG5SZW5kZXJlci5iaXRzUGVyUmVuZGVyZXIgPSA1O1xuUmVuZGVyZXIuYml0bWFza1JlbmRlcmVyQXJlYSA9IDB4MDAwMDBGRjtcblJlbmRlcmVyLmJpdG1hc2tDdXJyZW50UmVuZGVyZXJBcmVhID0gMHgwMDAwMDBGO1xuUmVuZGVyZXIuYml0bWFza0xhY2tzT2Zmc2V0ID0gMHgxMDAwMDtcblJlbmRlcmVyLmJpdG1hc2tMYWNrc1NoaWZ0ID0gMTY7IC8vIG51bWJlciBvZiBiaXRzIGJldHdlZW4gdGhlIG1haW4gcmVuZGVyZXIgYml0bWFzayBhbmQgdGhlIFwibGFja3NcIiB2YXJpZXR5XG5SZW5kZXJlci5iaXRtYXNrTm9kZURlZmF1bHQgPSBSZW5kZXJlci5iaXRtYXNrUmVuZGVyZXJBcmVhO1xuXG5SZW5kZXJlci5iaXRtYXNrQ2FudmFzID0gMHgwMDAwMDAxO1xuUmVuZGVyZXIuYml0bWFza1NWRyA9IDB4MDAwMDAwMjtcblJlbmRlcmVyLmJpdG1hc2tET00gPSAweDAwMDAwMDQ7XG5SZW5kZXJlci5iaXRtYXNrV2ViR0wgPSAweDAwMDAwMDg7XG4vLyAxMCwgMjAsIDQwLCA4MCByZXNlcnZlZCBmb3IgZnV0dXJlIHJlbmRlcmVycyBOT1RFOiB1cGRhdGUgYml0bWFza0N1cnJlbnRSZW5kZXJlckFyZWEvbnVtQWN0aXZlUmVuZGVyZXJzIGlmIHRoZXkgYXJlIGFkZGVkL3JlbW92ZWRcblxuLy8gc3VtbWFyeSBiaXRzIChmb3IgUmVuZGVyZXJTdW1tYXJ5KTpcblJlbmRlcmVyLmJpdG1hc2tTaW5nbGVDYW52YXMgPSAweDEwMDtcblJlbmRlcmVyLmJpdG1hc2tTaW5nbGVTVkcgPSAweDIwMDtcbi8vIHJlc2VydmVkIGdhcCAweDQwMCwgMHg4MDAsIDB4MTAwMCwgMHgyMDAwLCAweDQwMDAsIDB4ODAwMCBmb3IgZnV0dXJlIHJlbmRlcmVyLXNwZWNpZmljIHNpbmdsZSBpbmZvcm1hdGlvblxuUmVuZGVyZXIuYml0bWFza05vdFBhaW50ZWQgPSAweDEwMDA7XG5SZW5kZXJlci5iaXRtYXNrQm91bmRzVmFsaWQgPSAweDIwMDA7XG5SZW5kZXJlci5iaXRtYXNrTm9QRE9NID0gMHg0MDAwO1xuLy8gc3VtbWFyeSBiaXRzIGZvciB3aGV0aGVyIGEgcmVuZGVyZXIgY291bGQgYmUgcG90ZW50aWFsbHkgdXNlZCB0byBkaXNwbGF5IGEgTm9kZS5cblJlbmRlcmVyLmJpdG1hc2tMYWNrc0NhbnZhcyA9IFJlbmRlcmVyLmJpdG1hc2tDYW52YXMgPDwgUmVuZGVyZXIuYml0bWFza0xhY2tzU2hpZnQ7IC8vIDB4MTAwMDBcblJlbmRlcmVyLmJpdG1hc2tMYWNrc1NWRyA9IFJlbmRlcmVyLmJpdG1hc2tTVkcgPDwgUmVuZGVyZXIuYml0bWFza0xhY2tzU2hpZnQ7IC8vIDB4MjAwMDBcblJlbmRlcmVyLmJpdG1hc2tMYWNrc0RPTSA9IFJlbmRlcmVyLmJpdG1hc2tET00gPDwgUmVuZGVyZXIuYml0bWFza0xhY2tzU2hpZnQ7IC8vIDB4NDAwMDBcblJlbmRlcmVyLmJpdG1hc2tMYWNrc1dlYkdMID0gUmVuZGVyZXIuYml0bWFza1dlYkdMIDw8IFJlbmRlcmVyLmJpdG1hc2tMYWNrc1NoaWZ0OyAvLyAweDgwMDAwXG4vLyByZXNlcnZlZCBnYXAgMHgxMDAwMCwgMHgyMDAwMCwgMHg0MDAwMCwgMHg4MDAwMCBmb3IgZnV0dXJlIHJlbmRlcmVyc1xuXG5SZW5kZXJlci5pc0NhbnZhcyA9IGZ1bmN0aW9uKCBiaXRtYXNrICkge1xuICByZXR1cm4gKCBiaXRtYXNrICYgUmVuZGVyZXIuYml0bWFza0NhbnZhcyApICE9PSAwO1xufTtcblJlbmRlcmVyLmlzU1ZHID0gZnVuY3Rpb24oIGJpdG1hc2sgKSB7XG4gIHJldHVybiAoIGJpdG1hc2sgJiBSZW5kZXJlci5iaXRtYXNrU1ZHICkgIT09IDA7XG59O1xuUmVuZGVyZXIuaXNET00gPSBmdW5jdGlvbiggYml0bWFzayApIHtcbiAgcmV0dXJuICggYml0bWFzayAmIFJlbmRlcmVyLmJpdG1hc2tET00gKSAhPT0gMDtcbn07XG5SZW5kZXJlci5pc1dlYkdMID0gZnVuY3Rpb24oIGJpdG1hc2sgKSB7XG4gIHJldHVybiAoIGJpdG1hc2sgJiBSZW5kZXJlci5iaXRtYXNrV2ViR0wgKSAhPT0gMDtcbn07XG5cbmNvbnN0IHJlbmRlcmVyTWFwID0ge1xuICBjYW52YXM6IFJlbmRlcmVyLmJpdG1hc2tDYW52YXMsXG4gIHN2ZzogUmVuZGVyZXIuYml0bWFza1NWRyxcbiAgZG9tOiBSZW5kZXJlci5iaXRtYXNrRE9NLFxuICB3ZWJnbDogUmVuZGVyZXIuYml0bWFza1dlYkdMXG59O1xuUmVuZGVyZXIuZnJvbU5hbWUgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgcmV0dXJuIHJlbmRlcmVyTWFwWyBuYW1lIF07XG59O1xuXG4vLyByZXR1cm5zIHRoZSBwYXJ0IG9mIHRoZSBiaXRtYXNrIHRoYXQgc2hvdWxkIGNvbnRhaW4gb25seSBDYW52YXMvU1ZHL0RPTS9XZWJHTCBmbGFnc1xuLy9PSFRXTyBUT0RPOiB1c2UgdGhpcyBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgdG8gYml0bWFza1JlbmRlcmVyQXJlYSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS9pc3N1ZXMvMTU4MVxuUmVuZGVyZXIuc3RyaXBCaXRtYXNrID0gZnVuY3Rpb24oIGJpdG1hc2sgKSB7XG4gIHJldHVybiBiaXRtYXNrICYgUmVuZGVyZXIuYml0bWFza1JlbmRlcmVyQXJlYTtcbn07XG5cblJlbmRlcmVyLmNyZWF0ZU9yZGVyQml0bWFzayA9IGZ1bmN0aW9uKCBmaXJzdFJlbmRlcmVyLCBzZWNvbmRSZW5kZXJlciwgdGhpcmRSZW5kZXJlciwgZm91cnRoUmVuZGVyZXIgKSB7XG4gIGZpcnN0UmVuZGVyZXIgPSBmaXJzdFJlbmRlcmVyIHx8IDA7XG4gIHNlY29uZFJlbmRlcmVyID0gc2Vjb25kUmVuZGVyZXIgfHwgMDtcbiAgdGhpcmRSZW5kZXJlciA9IHRoaXJkUmVuZGVyZXIgfHwgMDtcbiAgZm91cnRoUmVuZGVyZXIgPSBmb3VydGhSZW5kZXJlciB8fCAwO1xuXG4gIC8vIHVzZXMgMjAgYml0cyBub3cgd2l0aCA0IHJlbmRlcmVyc1xuICByZXR1cm4gZmlyc3RSZW5kZXJlciB8XG4gICAgICAgICAoIHNlY29uZFJlbmRlcmVyIDw8IDUgKSB8XG4gICAgICAgICAoIHRoaXJkUmVuZGVyZXIgPDwgMTAgKSB8XG4gICAgICAgICAoIGZvdXJ0aFJlbmRlcmVyIDw8IDE1ICk7XG59O1xuLy8gYml0bWFza09yZGVyTiB3aXRoIG49MCBpcyBiaXRtYXNrT3JkZXJGaXJzdCwgbj0xIGlzIGJpdG1hc2tPcmRlclNlY29uZCwgZXRjLlxuUmVuZGVyZXIuYml0bWFza09yZGVyID0gZnVuY3Rpb24oIGJpdG1hc2ssIG4gKSB7XG4gIC8vIE5vcm1hbGx5IHRoZSBjb25kaXRpb24gaGVyZSBzaG91bGRuJ3QgYmUgbmVlZGVkLCBidXQgU2FmYXJpIHNlZW1lZCB0byBjYXVzZSBhIGxvZ2ljIGVycm9yIHdoZW4gdGhpcyBmdW5jdGlvblxuICAvLyBnZXRzIGlubGluZWQgZWxzZXdoZXJlIGlmIG49MC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5L2lzc3Vlcy80ODEgYW5kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9iZW5kaW5nLWxpZ2h0L2lzc3Vlcy8yNTkuXG4gIGlmICggbiA+IDAgKSB7XG4gICAgYml0bWFzayA9IGJpdG1hc2sgPj4gKCA1ICogbiApO1xuICB9XG4gIHJldHVybiBiaXRtYXNrICYgUmVuZGVyZXIuYml0bWFza0N1cnJlbnRSZW5kZXJlckFyZWE7XG59O1xuUmVuZGVyZXIuYml0bWFza09yZGVyRmlyc3QgPSBmdW5jdGlvbiggYml0bWFzayApIHtcbiAgcmV0dXJuIGJpdG1hc2sgJiBSZW5kZXJlci5iaXRtYXNrQ3VycmVudFJlbmRlcmVyQXJlYTtcbn07XG5SZW5kZXJlci5iaXRtYXNrT3JkZXJTZWNvbmQgPSBmdW5jdGlvbiggYml0bWFzayApIHtcbiAgcmV0dXJuICggYml0bWFzayA+PiA1ICkgJiBSZW5kZXJlci5iaXRtYXNrQ3VycmVudFJlbmRlcmVyQXJlYTtcbn07XG5SZW5kZXJlci5iaXRtYXNrT3JkZXJUaGlyZCA9IGZ1bmN0aW9uKCBiaXRtYXNrICkge1xuICByZXR1cm4gKCBiaXRtYXNrID4+IDEwICkgJiBSZW5kZXJlci5iaXRtYXNrQ3VycmVudFJlbmRlcmVyQXJlYTtcbn07XG5SZW5kZXJlci5iaXRtYXNrT3JkZXJGb3VydGggPSBmdW5jdGlvbiggYml0bWFzayApIHtcbiAgcmV0dXJuICggYml0bWFzayA+PiAxNSApICYgUmVuZGVyZXIuYml0bWFza0N1cnJlbnRSZW5kZXJlckFyZWE7XG59O1xuUmVuZGVyZXIucHVzaE9yZGVyQml0bWFzayA9IGZ1bmN0aW9uKCBiaXRtYXNrLCByZW5kZXJlciApIHtcbiAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIGJpdG1hc2sgPT09ICdudW1iZXInICk7XG4gIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByZW5kZXJlciA9PT0gJ251bWJlcicgKTtcbiAgbGV0IHJlbmRlcmVyVG9JbnNlcnQgPSByZW5kZXJlcjtcbiAgY29uc3QgdG90YWxCaXRzID0gUmVuZGVyZXIuYml0c1BlclJlbmRlcmVyICogUmVuZGVyZXIubnVtQWN0aXZlUmVuZGVyZXJzO1xuICBmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdG90YWxCaXRzOyBpICs9IFJlbmRlcmVyLmJpdHNQZXJSZW5kZXJlciApIHtcbiAgICBjb25zdCBjdXJyZW50UmVuZGVyZXIgPSAoIGJpdG1hc2sgPj4gaSApICYgUmVuZGVyZXIuYml0bWFza0N1cnJlbnRSZW5kZXJlckFyZWE7XG4gICAgaWYgKCBjdXJyZW50UmVuZGVyZXIgPT09IHJlbmRlcmVyVG9JbnNlcnQgKSB7XG4gICAgICByZXR1cm4gYml0bWFzaztcbiAgICB9XG4gICAgZWxzZSBpZiAoIGN1cnJlbnRSZW5kZXJlciA9PT0gMCApIHtcbiAgICAgIC8vIHBsYWNlIHRoZSByZW5kZXJlciBhbmQgZXhpdFxuICAgICAgYml0bWFzayA9IGJpdG1hc2sgfCAoIHJlbmRlcmVyVG9JbnNlcnQgPDwgaSApO1xuICAgICAgcmV0dXJuIGJpdG1hc2s7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY2xlYXIgb3V0IHRoYXQgc2xvdFxuICAgICAgYml0bWFzayA9ICggYml0bWFzayAmIH4oIFJlbmRlcmVyLmJpdG1hc2tDdXJyZW50UmVuZGVyZXJBcmVhIDw8IGkgKSApO1xuXG4gICAgICAvLyBwbGFjZSBpbiB0aGUgcmVuZGVyZXIgdG8gaW5zZXJ0XG4gICAgICBiaXRtYXNrID0gYml0bWFzayB8ICggcmVuZGVyZXJUb0luc2VydCA8PCBpICk7XG5cbiAgICAgIHJlbmRlcmVyVG9JbnNlcnQgPSBjdXJyZW50UmVuZGVyZXI7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgd2FsayBvdmVyIGFuZCByZS1wbGFjZSBvdXIgaW5pdGlhbCByZW5kZXJlclxuICAgIGlmICggcmVuZGVyZXJUb0luc2VydCA9PT0gcmVuZGVyZXIgKSB7XG4gICAgICByZXR1cm4gYml0bWFzaztcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoICdwdXNoT3JkZXJCaXRtYXNrIG92ZXJmbG93JyApO1xufTtcblxuUmVuZGVyZXIuY3JlYXRlU2VsZkRyYXdhYmxlID0gZnVuY3Rpb24oIGluc3RhbmNlLCBub2RlLCBzZWxmUmVuZGVyZXIsIGZpdHRhYmxlICkge1xuICBsZXQgZHJhd2FibGU7XG5cbiAgaWYgKCBSZW5kZXJlci5pc0NhbnZhcyggc2VsZlJlbmRlcmVyICkgKSB7XG4gICAgZHJhd2FibGUgPSBub2RlLmNyZWF0ZUNhbnZhc0RyYXdhYmxlKCBzZWxmUmVuZGVyZXIsIGluc3RhbmNlICk7XG4gIH1cbiAgZWxzZSBpZiAoIFJlbmRlcmVyLmlzU1ZHKCBzZWxmUmVuZGVyZXIgKSApIHtcbiAgICBkcmF3YWJsZSA9IG5vZGUuY3JlYXRlU1ZHRHJhd2FibGUoIHNlbGZSZW5kZXJlciwgaW5zdGFuY2UgKTtcbiAgfVxuICBlbHNlIGlmICggUmVuZGVyZXIuaXNET00oIHNlbGZSZW5kZXJlciApICkge1xuICAgIGRyYXdhYmxlID0gbm9kZS5jcmVhdGVET01EcmF3YWJsZSggc2VsZlJlbmRlcmVyLCBpbnN0YW5jZSApO1xuICB9XG4gIGVsc2UgaWYgKCBSZW5kZXJlci5pc1dlYkdMKCBzZWxmUmVuZGVyZXIgKSApIHtcbiAgICBkcmF3YWJsZSA9IG5vZGUuY3JlYXRlV2ViR0xEcmF3YWJsZSggc2VsZlJlbmRlcmVyLCBpbnN0YW5jZSApO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvciggYFVucmVjb2duaXplZCByZW5kZXJlcjogJHtzZWxmUmVuZGVyZXJ9YCApO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIG9mIHRoZSBkcmF3YWJsZXMgaGF2ZSB0aGUgcmVxdWlyZWQgbWFyay1kaXJ0eSBtZXRob2RzIGF2YWlsYWJsZS5cbiAgaWYgKCBhc3NlcnQgKSB7XG4gICAgXy5lYWNoKCBub2RlLmRyYXdhYmxlTWFya0ZsYWdzLCBmbGFnID0+IHtcbiAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgbWFya0RpcnR5JHtmbGFnWyAwIF0udG9VcHBlckNhc2UoKX0ke2ZsYWcuc2xpY2UoIDEgKX1gO1xuICAgICAgYXNzZXJ0KCB0eXBlb2YgZHJhd2FibGVbIG1ldGhvZE5hbWUgXSA9PT0gJ2Z1bmN0aW9uJywgYERpZCBub3QgZmluZCAke21ldGhvZE5hbWV9YCApO1xuICAgIH0gKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgaXRzIGZpdHRhYmxlIGZsYWdcbiAgZHJhd2FibGUuc2V0Rml0dGFibGUoIGZpdHRhYmxlICk7XG5cbiAgcmV0dXJuIGRyYXdhYmxlO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG4gKiBXZWJHTCBSZW5kZXJlciB0eXBlIGVudW1lcmF0aW9uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuUmVuZGVyZXIud2ViZ2xDdXN0b20gPSAweDE7XG5SZW5kZXJlci53ZWJnbFRleHR1cmVkVHJpYW5nbGVzID0gMHgyO1xuUmVuZGVyZXIud2ViZ2xWZXJ0ZXhDb2xvclBvbHlnb25zID0gMHgzO1xuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJlcjsiXSwibmFtZXMiOlsic2NlbmVyeSIsIlJlbmRlcmVyIiwicmVnaXN0ZXIiLCJudW1BY3RpdmVSZW5kZXJlcnMiLCJiaXRzUGVyUmVuZGVyZXIiLCJiaXRtYXNrUmVuZGVyZXJBcmVhIiwiYml0bWFza0N1cnJlbnRSZW5kZXJlckFyZWEiLCJiaXRtYXNrTGFja3NPZmZzZXQiLCJiaXRtYXNrTGFja3NTaGlmdCIsImJpdG1hc2tOb2RlRGVmYXVsdCIsImJpdG1hc2tDYW52YXMiLCJiaXRtYXNrU1ZHIiwiYml0bWFza0RPTSIsImJpdG1hc2tXZWJHTCIsImJpdG1hc2tTaW5nbGVDYW52YXMiLCJiaXRtYXNrU2luZ2xlU1ZHIiwiYml0bWFza05vdFBhaW50ZWQiLCJiaXRtYXNrQm91bmRzVmFsaWQiLCJiaXRtYXNrTm9QRE9NIiwiYml0bWFza0xhY2tzQ2FudmFzIiwiYml0bWFza0xhY2tzU1ZHIiwiYml0bWFza0xhY2tzRE9NIiwiYml0bWFza0xhY2tzV2ViR0wiLCJpc0NhbnZhcyIsImJpdG1hc2siLCJpc1NWRyIsImlzRE9NIiwiaXNXZWJHTCIsInJlbmRlcmVyTWFwIiwiY2FudmFzIiwic3ZnIiwiZG9tIiwid2ViZ2wiLCJmcm9tTmFtZSIsIm5hbWUiLCJzdHJpcEJpdG1hc2siLCJjcmVhdGVPcmRlckJpdG1hc2siLCJmaXJzdFJlbmRlcmVyIiwic2Vjb25kUmVuZGVyZXIiLCJ0aGlyZFJlbmRlcmVyIiwiZm91cnRoUmVuZGVyZXIiLCJiaXRtYXNrT3JkZXIiLCJuIiwiYml0bWFza09yZGVyRmlyc3QiLCJiaXRtYXNrT3JkZXJTZWNvbmQiLCJiaXRtYXNrT3JkZXJUaGlyZCIsImJpdG1hc2tPcmRlckZvdXJ0aCIsInB1c2hPcmRlckJpdG1hc2siLCJyZW5kZXJlciIsImFzc2VydCIsInJlbmRlcmVyVG9JbnNlcnQiLCJ0b3RhbEJpdHMiLCJpIiwiY3VycmVudFJlbmRlcmVyIiwiRXJyb3IiLCJjcmVhdGVTZWxmRHJhd2FibGUiLCJpbnN0YW5jZSIsIm5vZGUiLCJzZWxmUmVuZGVyZXIiLCJmaXR0YWJsZSIsImRyYXdhYmxlIiwiY3JlYXRlQ2FudmFzRHJhd2FibGUiLCJjcmVhdGVTVkdEcmF3YWJsZSIsImNyZWF0ZURPTURyYXdhYmxlIiwiY3JlYXRlV2ViR0xEcmF3YWJsZSIsIl8iLCJlYWNoIiwiZHJhd2FibGVNYXJrRmxhZ3MiLCJmbGFnIiwibWV0aG9kTmFtZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJzZXRGaXR0YWJsZSIsIndlYmdsQ3VzdG9tIiwid2ViZ2xUZXh0dXJlZFRyaWFuZ2xlcyIsIndlYmdsVmVydGV4Q29sb3JQb2x5Z29ucyJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7Ozs7OztDQVFDLEdBRUQsU0FBU0EsT0FBTyxRQUFRLGdCQUFnQjtBQUV4Qyx1QkFBdUI7QUFDdkIsTUFBTUMsV0FBVyxDQUFDO0FBQ2xCRCxRQUFRRSxRQUFRLENBQUUsWUFBWUQ7QUFFOUIsMklBQTJJO0FBRTNJOzs2RUFFNkUsR0FFN0VBLFNBQVNFLGtCQUFrQixHQUFHO0FBQzlCRixTQUFTRyxlQUFlLEdBQUc7QUFDM0JILFNBQVNJLG1CQUFtQixHQUFHO0FBQy9CSixTQUFTSywwQkFBMEIsR0FBRztBQUN0Q0wsU0FBU00sa0JBQWtCLEdBQUc7QUFDOUJOLFNBQVNPLGlCQUFpQixHQUFHLElBQUksMkVBQTJFO0FBQzVHUCxTQUFTUSxrQkFBa0IsR0FBR1IsU0FBU0ksbUJBQW1CO0FBRTFESixTQUFTUyxhQUFhLEdBQUc7QUFDekJULFNBQVNVLFVBQVUsR0FBRztBQUN0QlYsU0FBU1csVUFBVSxHQUFHO0FBQ3RCWCxTQUFTWSxZQUFZLEdBQUc7QUFDeEIsb0lBQW9JO0FBRXBJLHNDQUFzQztBQUN0Q1osU0FBU2EsbUJBQW1CLEdBQUc7QUFDL0JiLFNBQVNjLGdCQUFnQixHQUFHO0FBQzVCLDRHQUE0RztBQUM1R2QsU0FBU2UsaUJBQWlCLEdBQUc7QUFDN0JmLFNBQVNnQixrQkFBa0IsR0FBRztBQUM5QmhCLFNBQVNpQixhQUFhLEdBQUc7QUFDekIsbUZBQW1GO0FBQ25GakIsU0FBU2tCLGtCQUFrQixHQUFHbEIsU0FBU1MsYUFBYSxJQUFJVCxTQUFTTyxpQkFBaUIsRUFBRSxVQUFVO0FBQzlGUCxTQUFTbUIsZUFBZSxHQUFHbkIsU0FBU1UsVUFBVSxJQUFJVixTQUFTTyxpQkFBaUIsRUFBRSxVQUFVO0FBQ3hGUCxTQUFTb0IsZUFBZSxHQUFHcEIsU0FBU1csVUFBVSxJQUFJWCxTQUFTTyxpQkFBaUIsRUFBRSxVQUFVO0FBQ3hGUCxTQUFTcUIsaUJBQWlCLEdBQUdyQixTQUFTWSxZQUFZLElBQUlaLFNBQVNPLGlCQUFpQixFQUFFLFVBQVU7QUFDNUYsdUVBQXVFO0FBRXZFUCxTQUFTc0IsUUFBUSxHQUFHLFNBQVVDLE9BQU87SUFDbkMsT0FBTyxBQUFFQSxDQUFBQSxVQUFVdkIsU0FBU1MsYUFBYSxBQUFELE1BQVE7QUFDbEQ7QUFDQVQsU0FBU3dCLEtBQUssR0FBRyxTQUFVRCxPQUFPO0lBQ2hDLE9BQU8sQUFBRUEsQ0FBQUEsVUFBVXZCLFNBQVNVLFVBQVUsQUFBRCxNQUFRO0FBQy9DO0FBQ0FWLFNBQVN5QixLQUFLLEdBQUcsU0FBVUYsT0FBTztJQUNoQyxPQUFPLEFBQUVBLENBQUFBLFVBQVV2QixTQUFTVyxVQUFVLEFBQUQsTUFBUTtBQUMvQztBQUNBWCxTQUFTMEIsT0FBTyxHQUFHLFNBQVVILE9BQU87SUFDbEMsT0FBTyxBQUFFQSxDQUFBQSxVQUFVdkIsU0FBU1ksWUFBWSxBQUFELE1BQVE7QUFDakQ7QUFFQSxNQUFNZSxjQUFjO0lBQ2xCQyxRQUFRNUIsU0FBU1MsYUFBYTtJQUM5Qm9CLEtBQUs3QixTQUFTVSxVQUFVO0lBQ3hCb0IsS0FBSzlCLFNBQVNXLFVBQVU7SUFDeEJvQixPQUFPL0IsU0FBU1ksWUFBWTtBQUM5QjtBQUNBWixTQUFTZ0MsUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDaEMsT0FBT04sV0FBVyxDQUFFTSxLQUFNO0FBQzVCO0FBRUEsc0ZBQXNGO0FBQ3RGLHNIQUFzSDtBQUN0SGpDLFNBQVNrQyxZQUFZLEdBQUcsU0FBVVgsT0FBTztJQUN2QyxPQUFPQSxVQUFVdkIsU0FBU0ksbUJBQW1CO0FBQy9DO0FBRUFKLFNBQVNtQyxrQkFBa0IsR0FBRyxTQUFVQyxhQUFhLEVBQUVDLGNBQWMsRUFBRUMsYUFBYSxFQUFFQyxjQUFjO0lBQ2xHSCxnQkFBZ0JBLGlCQUFpQjtJQUNqQ0MsaUJBQWlCQSxrQkFBa0I7SUFDbkNDLGdCQUFnQkEsaUJBQWlCO0lBQ2pDQyxpQkFBaUJBLGtCQUFrQjtJQUVuQyxvQ0FBb0M7SUFDcEMsT0FBT0gsZ0JBQ0VDLGtCQUFrQixJQUNsQkMsaUJBQWlCLEtBQ2pCQyxrQkFBa0I7QUFDN0I7QUFDQSwrRUFBK0U7QUFDL0V2QyxTQUFTd0MsWUFBWSxHQUFHLFNBQVVqQixPQUFPLEVBQUVrQixDQUFDO0lBQzFDLCtHQUErRztJQUMvRyx3RkFBd0Y7SUFDeEYsd0RBQXdEO0lBQ3hELElBQUtBLElBQUksR0FBSTtRQUNYbEIsVUFBVUEsV0FBYSxJQUFJa0I7SUFDN0I7SUFDQSxPQUFPbEIsVUFBVXZCLFNBQVNLLDBCQUEwQjtBQUN0RDtBQUNBTCxTQUFTMEMsaUJBQWlCLEdBQUcsU0FBVW5CLE9BQU87SUFDNUMsT0FBT0EsVUFBVXZCLFNBQVNLLDBCQUEwQjtBQUN0RDtBQUNBTCxTQUFTMkMsa0JBQWtCLEdBQUcsU0FBVXBCLE9BQU87SUFDN0MsT0FBTyxBQUFFQSxXQUFXLElBQU12QixTQUFTSywwQkFBMEI7QUFDL0Q7QUFDQUwsU0FBUzRDLGlCQUFpQixHQUFHLFNBQVVyQixPQUFPO0lBQzVDLE9BQU8sQUFBRUEsV0FBVyxLQUFPdkIsU0FBU0ssMEJBQTBCO0FBQ2hFO0FBQ0FMLFNBQVM2QyxrQkFBa0IsR0FBRyxTQUFVdEIsT0FBTztJQUM3QyxPQUFPLEFBQUVBLFdBQVcsS0FBT3ZCLFNBQVNLLDBCQUEwQjtBQUNoRTtBQUNBTCxTQUFTOEMsZ0JBQWdCLEdBQUcsU0FBVXZCLE9BQU8sRUFBRXdCLFFBQVE7SUFDckRDLFVBQVVBLE9BQVEsT0FBT3pCLFlBQVk7SUFDckN5QixVQUFVQSxPQUFRLE9BQU9ELGFBQWE7SUFDdEMsSUFBSUUsbUJBQW1CRjtJQUN2QixNQUFNRyxZQUFZbEQsU0FBU0csZUFBZSxHQUFHSCxTQUFTRSxrQkFBa0I7SUFDeEUsSUFBTSxJQUFJaUQsSUFBSSxHQUFHQSxLQUFLRCxXQUFXQyxLQUFLbkQsU0FBU0csZUFBZSxDQUFHO1FBQy9ELE1BQU1pRCxrQkFBa0IsQUFBRTdCLFdBQVc0QixJQUFNbkQsU0FBU0ssMEJBQTBCO1FBQzlFLElBQUsrQyxvQkFBb0JILGtCQUFtQjtZQUMxQyxPQUFPMUI7UUFDVCxPQUNLLElBQUs2QixvQkFBb0IsR0FBSTtZQUNoQyw4QkFBOEI7WUFDOUI3QixVQUFVQSxVQUFZMEIsb0JBQW9CRTtZQUMxQyxPQUFPNUI7UUFDVCxPQUNLO1lBQ0gsc0JBQXNCO1lBQ3RCQSxVQUFZQSxVQUFVLENBQUd2QixDQUFBQSxTQUFTSywwQkFBMEIsSUFBSThDLENBQUFBO1lBRWhFLGtDQUFrQztZQUNsQzVCLFVBQVVBLFVBQVkwQixvQkFBb0JFO1lBRTFDRixtQkFBbUJHO1FBQ3JCO1FBRUEsb0RBQW9EO1FBQ3BELElBQUtILHFCQUFxQkYsVUFBVztZQUNuQyxPQUFPeEI7UUFDVDtJQUNGO0lBRUEsTUFBTSxJQUFJOEIsTUFBTztBQUNuQjtBQUVBckQsU0FBU3NELGtCQUFrQixHQUFHLFNBQVVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxZQUFZLEVBQUVDLFFBQVE7SUFDNUUsSUFBSUM7SUFFSixJQUFLM0QsU0FBU3NCLFFBQVEsQ0FBRW1DLGVBQWlCO1FBQ3ZDRSxXQUFXSCxLQUFLSSxvQkFBb0IsQ0FBRUgsY0FBY0Y7SUFDdEQsT0FDSyxJQUFLdkQsU0FBU3dCLEtBQUssQ0FBRWlDLGVBQWlCO1FBQ3pDRSxXQUFXSCxLQUFLSyxpQkFBaUIsQ0FBRUosY0FBY0Y7SUFDbkQsT0FDSyxJQUFLdkQsU0FBU3lCLEtBQUssQ0FBRWdDLGVBQWlCO1FBQ3pDRSxXQUFXSCxLQUFLTSxpQkFBaUIsQ0FBRUwsY0FBY0Y7SUFDbkQsT0FDSyxJQUFLdkQsU0FBUzBCLE9BQU8sQ0FBRStCLGVBQWlCO1FBQzNDRSxXQUFXSCxLQUFLTyxtQkFBbUIsQ0FBRU4sY0FBY0Y7SUFDckQsT0FDSztRQUNILE1BQU0sSUFBSUYsTUFBTyxDQUFDLHVCQUF1QixFQUFFSSxjQUFjO0lBQzNEO0lBRUEsK0ZBQStGO0lBQy9GLElBQUtULFFBQVM7UUFDWmdCLEVBQUVDLElBQUksQ0FBRVQsS0FBS1UsaUJBQWlCLEVBQUVDLENBQUFBO1lBQzlCLE1BQU1DLGFBQWEsQ0FBQyxTQUFTLEVBQUVELElBQUksQ0FBRSxFQUFHLENBQUNFLFdBQVcsS0FBS0YsS0FBS0csS0FBSyxDQUFFLElBQUs7WUFDMUV0QixPQUFRLE9BQU9XLFFBQVEsQ0FBRVMsV0FBWSxLQUFLLFlBQVksQ0FBQyxhQUFhLEVBQUVBLFlBQVk7UUFDcEY7SUFDRjtJQUVBLCtCQUErQjtJQUMvQlQsU0FBU1ksV0FBVyxDQUFFYjtJQUV0QixPQUFPQztBQUNUO0FBRUE7OzhFQUU4RSxHQUM5RTNELFNBQVN3RSxXQUFXLEdBQUc7QUFDdkJ4RSxTQUFTeUUsc0JBQXNCLEdBQUc7QUFDbEN6RSxTQUFTMEUsd0JBQXdCLEdBQUc7QUFFcEMsZUFBZTFFLFNBQVMifQ==