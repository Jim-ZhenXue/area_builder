// Copyright 2016-2023, University of Colorado Boulder
/**
 * SVG drawable for Circle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import Poolable from '../../../../phet-core/js/Poolable.js';
import { CircleStatefulDrawable, scenery, svgns, SVGSelfDrawable } from '../../imports.js';
// TODO: change this based on memory and performance characteristics of the platform https://github.com/phetsims/scenery/issues/1581
const keepSVGCircleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
let CircleSVGDrawable = class CircleSVGDrawable extends CircleStatefulDrawable(SVGSelfDrawable) {
    /**
   * @public
   * @override
   *
   * @param {number} renderer
   * @param {Instance} instance
   */ initialize(renderer, instance) {
        super.initialize(renderer, instance, true, keepSVGCircleElements); // usesPaint: true
        // @protected {SVGCircleElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
        this.svgElement = this.svgElement || document.createElementNS(svgns, 'circle');
    }
    /**
   * Updates the SVG elements so that they will appear like the current node's representation.
   * @protected
   *
   * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
   */ updateSVGSelf() {
        const circle = this.svgElement;
        if (this.dirtyRadius) {
            circle.setAttribute('r', this.node._radius);
        }
        // Apply any fill/stroke changes to our element.
        this.updateFillStrokeStyle(circle);
    }
};
scenery.register('CircleSVGDrawable', CircleSVGDrawable);
Poolable.mixInto(CircleSVGDrawable);
export default CircleSVGDrawable;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvZGlzcGxheS9kcmF3YWJsZXMvQ2lyY2xlU1ZHRHJhd2FibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTYtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogU1ZHIGRyYXdhYmxlIGZvciBDaXJjbGUgbm9kZXMuXG4gKlxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxuICovXG5cbmltcG9ydCBQb29sYWJsZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvUG9vbGFibGUuanMnO1xuaW1wb3J0IHsgQ2lyY2xlU3RhdGVmdWxEcmF3YWJsZSwgc2NlbmVyeSwgc3ZnbnMsIFNWR1NlbGZEcmF3YWJsZSB9IGZyb20gJy4uLy4uL2ltcG9ydHMuanMnO1xuXG4vLyBUT0RPOiBjaGFuZ2UgdGhpcyBiYXNlZCBvbiBtZW1vcnkgYW5kIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGUgcGxhdGZvcm0gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3NjZW5lcnkvaXNzdWVzLzE1ODFcbmNvbnN0IGtlZXBTVkdDaXJjbGVFbGVtZW50cyA9IHRydWU7IC8vIHdoZXRoZXIgd2Ugc2hvdWxkIHBvb2wgU1ZHIGVsZW1lbnRzIGZvciB0aGUgU1ZHIHJlbmRlcmluZyBzdGF0ZXMsIG9yIHdoZXRoZXIgd2Ugc2hvdWxkIGZyZWUgdGhlbSB3aGVuIHBvc3NpYmxlIGZvciBtZW1vcnlcblxuY2xhc3MgQ2lyY2xlU1ZHRHJhd2FibGUgZXh0ZW5kcyBDaXJjbGVTdGF0ZWZ1bERyYXdhYmxlKCBTVkdTZWxmRHJhd2FibGUgKSB7XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBvdmVycmlkZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtIHtJbnN0YW5jZX0gaW5zdGFuY2VcbiAgICovXG4gIGluaXRpYWxpemUoIHJlbmRlcmVyLCBpbnN0YW5jZSApIHtcbiAgICBzdXBlci5pbml0aWFsaXplKCByZW5kZXJlciwgaW5zdGFuY2UsIHRydWUsIGtlZXBTVkdDaXJjbGVFbGVtZW50cyApOyAvLyB1c2VzUGFpbnQ6IHRydWVcblxuICAgIC8vIEBwcm90ZWN0ZWQge1NWR0NpcmNsZUVsZW1lbnR9IC0gU29sZSBTVkcgZWxlbWVudCBmb3IgdGhpcyBkcmF3YWJsZSwgaW1wbGVtZW50aW5nIEFQSSBmb3IgU1ZHU2VsZkRyYXdhYmxlXG4gICAgdGhpcy5zdmdFbGVtZW50ID0gdGhpcy5zdmdFbGVtZW50IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggc3ZnbnMsICdjaXJjbGUnICk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBTVkcgZWxlbWVudHMgc28gdGhhdCB0aGV5IHdpbGwgYXBwZWFyIGxpa2UgdGhlIGN1cnJlbnQgbm9kZSdzIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqXG4gICAqIEltcGxlbWVudHMgdGhlIGludGVyZmFjZSBmb3IgU1ZHU2VsZkRyYXdhYmxlIChhbmQgaXMgY2FsbGVkIGZyb20gdGhlIFNWR1NlbGZEcmF3YWJsZSdzIHVwZGF0ZSkuXG4gICAqL1xuICB1cGRhdGVTVkdTZWxmKCkge1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuc3ZnRWxlbWVudDtcblxuICAgIGlmICggdGhpcy5kaXJ0eVJhZGl1cyApIHtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoICdyJywgdGhpcy5ub2RlLl9yYWRpdXMgKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhbnkgZmlsbC9zdHJva2UgY2hhbmdlcyB0byBvdXIgZWxlbWVudC5cbiAgICB0aGlzLnVwZGF0ZUZpbGxTdHJva2VTdHlsZSggY2lyY2xlICk7XG4gIH1cbn1cblxuc2NlbmVyeS5yZWdpc3RlciggJ0NpcmNsZVNWR0RyYXdhYmxlJywgQ2lyY2xlU1ZHRHJhd2FibGUgKTtcblxuUG9vbGFibGUubWl4SW50byggQ2lyY2xlU1ZHRHJhd2FibGUgKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2lyY2xlU1ZHRHJhd2FibGU7Il0sIm5hbWVzIjpbIlBvb2xhYmxlIiwiQ2lyY2xlU3RhdGVmdWxEcmF3YWJsZSIsInNjZW5lcnkiLCJzdmducyIsIlNWR1NlbGZEcmF3YWJsZSIsImtlZXBTVkdDaXJjbGVFbGVtZW50cyIsIkNpcmNsZVNWR0RyYXdhYmxlIiwiaW5pdGlhbGl6ZSIsInJlbmRlcmVyIiwiaW5zdGFuY2UiLCJzdmdFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJ1cGRhdGVTVkdTZWxmIiwiY2lyY2xlIiwiZGlydHlSYWRpdXMiLCJzZXRBdHRyaWJ1dGUiLCJub2RlIiwiX3JhZGl1cyIsInVwZGF0ZUZpbGxTdHJva2VTdHlsZSIsInJlZ2lzdGVyIiwibWl4SW50byJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7O0NBSUMsR0FFRCxPQUFPQSxjQUFjLHVDQUF1QztBQUM1RCxTQUFTQyxzQkFBc0IsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLGVBQWUsUUFBUSxtQkFBbUI7QUFFM0Ysb0lBQW9JO0FBQ3BJLE1BQU1DLHdCQUF3QixNQUFNLDRIQUE0SDtBQUVoSyxJQUFBLEFBQU1DLG9CQUFOLE1BQU1BLDBCQUEwQkwsdUJBQXdCRztJQUN0RDs7Ozs7O0dBTUMsR0FDREcsV0FBWUMsUUFBUSxFQUFFQyxRQUFRLEVBQUc7UUFDL0IsS0FBSyxDQUFDRixXQUFZQyxVQUFVQyxVQUFVLE1BQU1KLHdCQUF5QixrQkFBa0I7UUFFdkYsMkdBQTJHO1FBQzNHLElBQUksQ0FBQ0ssVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVSxJQUFJQyxTQUFTQyxlQUFlLENBQUVULE9BQU87SUFDeEU7SUFHQTs7Ozs7R0FLQyxHQUNEVSxnQkFBZ0I7UUFDZCxNQUFNQyxTQUFTLElBQUksQ0FBQ0osVUFBVTtRQUU5QixJQUFLLElBQUksQ0FBQ0ssV0FBVyxFQUFHO1lBQ3RCRCxPQUFPRSxZQUFZLENBQUUsS0FBSyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsT0FBTztRQUM3QztRQUVBLGdEQUFnRDtRQUNoRCxJQUFJLENBQUNDLHFCQUFxQixDQUFFTDtJQUM5QjtBQUNGO0FBRUFaLFFBQVFrQixRQUFRLENBQUUscUJBQXFCZDtBQUV2Q04sU0FBU3FCLE9BQU8sQ0FBRWY7QUFFbEIsZUFBZUEsa0JBQWtCIn0=