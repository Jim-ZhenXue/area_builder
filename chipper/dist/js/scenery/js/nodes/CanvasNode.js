// Copyright 2013-2024, University of Colorado Boulder
/**
 * An abstract node (should be subtyped) that is drawn by user-provided custom Canvas code.
 *
 * The region that can be drawn in is handled manually, by controlling the canvasBounds property of this CanvasNode.
 * Any regions outside of the canvasBounds will not be guaranteed to be drawn. This can be set with canvasBounds in the
 * constructor, or later with node.canvasBounds = bounds or setCanvasBounds( bounds ).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import { Shape } from '../../../kite/js/imports.js';
import { CanvasNodeDrawable, Node, Renderer, scenery } from '../imports.js';
const CANVAS_NODE_OPTION_KEYS = [
    'canvasBounds'
];
let CanvasNode = class CanvasNode extends Node {
    /**
   * Sets the bounds that are used for layout/repainting.
   *
   * These bounds should always cover at least the area where the CanvasNode will draw in. If this is violated, this
   * node may be partially or completely invisible in Scenery's output.
   */ setCanvasBounds(selfBounds) {
        this.invalidateSelf(selfBounds);
    }
    set canvasBounds(value) {
        this.setCanvasBounds(value);
    }
    get canvasBounds() {
        return this.getCanvasBounds();
    }
    /**
   * Returns the previously-set canvasBounds, or Bounds2.NOTHING if it has not been set yet.
   */ getCanvasBounds() {
        return this.getSelfBounds();
    }
    /**
   * Whether this Node itself is painted (displays something itself).
   */ isPainted() {
        // Always true for CanvasNode
        return true;
    }
    /**
   * Should be called when this node needs to be repainted. When not called, Scenery assumes that this node does
   * NOT need to be repainted (although Scenery may repaint it due to other nodes needing to be repainted).
   *
   * This sets a "dirty" flag, so that it will be repainted the next time it would be displayed.
   */ invalidatePaint() {
        const stateLen = this._drawables.length;
        for(let i = 0; i < stateLen; i++){
            this._drawables[i].markDirty();
        }
    }
    /**
   * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
   * coordinate frame of this node.
   *
   * @param wrapper
   * @param matrix - The transformation matrix already applied to the context.
   */ canvasPaintSelf(wrapper, matrix) {
        this.paintCanvas(wrapper.context);
    }
    /**
   * Computes whether the provided point is "inside" (contained) in this Node's self content, or "outside".
   *
   * If CanvasNode subtypes want to support being picked or hit-tested, it should override this function.
   *
   * @param point - Considered to be in the local coordinate frame
   */ containsPointSelf(point) {
        return false;
    }
    /**
   * Returns a Shape that represents the area covered by containsPointSelf.
   */ getSelfShape() {
        return new Shape();
    }
    /**
   * Creates a Canvas drawable for this CanvasNode. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */ createCanvasDrawable(renderer, instance) {
        // @ts-expect-error
        return CanvasNodeDrawable.createFromPool(renderer, instance);
    }
    mutate(options) {
        return super.mutate(options);
    }
    constructor(options){
        super(options);
        // This shouldn't change, as we only support one renderer
        this.setRendererBitmask(Renderer.bitmaskCanvas);
    }
};
export { CanvasNode as default };
/**
 * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
 * order they will be evaluated in.
 *
 * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
 *       cases that may apply.
 */ CanvasNode.prototype._mutatorKeys = CANVAS_NODE_OPTION_KEYS.concat(Node.prototype._mutatorKeys);
scenery.register('CanvasNode', CanvasNode);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbm9kZXMvQ2FudmFzTm9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMy0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBub2RlIChzaG91bGQgYmUgc3VidHlwZWQpIHRoYXQgaXMgZHJhd24gYnkgdXNlci1wcm92aWRlZCBjdXN0b20gQ2FudmFzIGNvZGUuXG4gKlxuICogVGhlIHJlZ2lvbiB0aGF0IGNhbiBiZSBkcmF3biBpbiBpcyBoYW5kbGVkIG1hbnVhbGx5LCBieSBjb250cm9sbGluZyB0aGUgY2FudmFzQm91bmRzIHByb3BlcnR5IG9mIHRoaXMgQ2FudmFzTm9kZS5cbiAqIEFueSByZWdpb25zIG91dHNpZGUgb2YgdGhlIGNhbnZhc0JvdW5kcyB3aWxsIG5vdCBiZSBndWFyYW50ZWVkIHRvIGJlIGRyYXduLiBUaGlzIGNhbiBiZSBzZXQgd2l0aCBjYW52YXNCb3VuZHMgaW4gdGhlXG4gKiBjb25zdHJ1Y3Rvciwgb3IgbGF0ZXIgd2l0aCBub2RlLmNhbnZhc0JvdW5kcyA9IGJvdW5kcyBvciBzZXRDYW52YXNCb3VuZHMoIGJvdW5kcyApLlxuICpcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cbiAqL1xuXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XG5pbXBvcnQgTWF0cml4MyBmcm9tICcuLi8uLi8uLi9kb3QvanMvTWF0cml4My5qcyc7XG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XG5pbXBvcnQgeyBDYW52YXNDb250ZXh0V3JhcHBlciwgQ2FudmFzTm9kZURyYXdhYmxlLCBDYW52YXNTZWxmRHJhd2FibGUsIEluc3RhbmNlLCBOb2RlLCBOb2RlT3B0aW9ucywgUmVuZGVyZXIsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcblxuY29uc3QgQ0FOVkFTX05PREVfT1BUSU9OX0tFWVMgPSBbXG4gICdjYW52YXNCb3VuZHMnXG5dO1xuXG50eXBlIFNlbGZPcHRpb25zID0ge1xuICBjYW52YXNCb3VuZHM/OiBCb3VuZHMyO1xufTtcblxuZXhwb3J0IHR5cGUgQ2FudmFzTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIE5vZGVPcHRpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggb3B0aW9ucz86IENhbnZhc05vZGVPcHRpb25zICkge1xuICAgIHN1cGVyKCBvcHRpb25zICk7XG5cbiAgICAvLyBUaGlzIHNob3VsZG4ndCBjaGFuZ2UsIGFzIHdlIG9ubHkgc3VwcG9ydCBvbmUgcmVuZGVyZXJcbiAgICB0aGlzLnNldFJlbmRlcmVyQml0bWFzayggUmVuZGVyZXIuYml0bWFza0NhbnZhcyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJvdW5kcyB0aGF0IGFyZSB1c2VkIGZvciBsYXlvdXQvcmVwYWludGluZy5cbiAgICpcbiAgICogVGhlc2UgYm91bmRzIHNob3VsZCBhbHdheXMgY292ZXIgYXQgbGVhc3QgdGhlIGFyZWEgd2hlcmUgdGhlIENhbnZhc05vZGUgd2lsbCBkcmF3IGluLiBJZiB0aGlzIGlzIHZpb2xhdGVkLCB0aGlzXG4gICAqIG5vZGUgbWF5IGJlIHBhcnRpYWxseSBvciBjb21wbGV0ZWx5IGludmlzaWJsZSBpbiBTY2VuZXJ5J3Mgb3V0cHV0LlxuICAgKi9cbiAgcHVibGljIHNldENhbnZhc0JvdW5kcyggc2VsZkJvdW5kczogQm91bmRzMiApOiB2b2lkIHtcbiAgICB0aGlzLmludmFsaWRhdGVTZWxmKCBzZWxmQm91bmRzICk7XG4gIH1cblxuICBwdWJsaWMgc2V0IGNhbnZhc0JvdW5kcyggdmFsdWU6IEJvdW5kczIgKSB7IHRoaXMuc2V0Q2FudmFzQm91bmRzKCB2YWx1ZSApOyB9XG5cbiAgcHVibGljIGdldCBjYW52YXNCb3VuZHMoKTogQm91bmRzMiB7IHJldHVybiB0aGlzLmdldENhbnZhc0JvdW5kcygpOyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzbHktc2V0IGNhbnZhc0JvdW5kcywgb3IgQm91bmRzMi5OT1RISU5HIGlmIGl0IGhhcyBub3QgYmVlbiBzZXQgeWV0LlxuICAgKi9cbiAgcHVibGljIGdldENhbnZhc0JvdW5kcygpOiBCb3VuZHMyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTZWxmQm91bmRzKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIE5vZGUgaXRzZWxmIGlzIHBhaW50ZWQgKGRpc3BsYXlzIHNvbWV0aGluZyBpdHNlbGYpLlxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIGlzUGFpbnRlZCgpOiBib29sZWFuIHtcbiAgICAvLyBBbHdheXMgdHJ1ZSBmb3IgQ2FudmFzTm9kZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHBhaW50Q2FudmFzIHdpdGggYSBmYXN0ZXIgdmVyc2lvbiwgc2luY2UgZmlsbFJlY3QgYW5kIGRyYXdSZWN0IGRvbid0IGFmZmVjdCB0aGUgY3VycmVudCBkZWZhdWx0IHBhdGguXG4gICAqXG4gICAqIElNUE9SVEFOVCBOT1RFOiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcnVuIGZyb20gaW5zaWRlIFNjZW5lcnkncyBEaXNwbGF5LnVwZGF0ZURpc3BsYXkoKSwgc28gaXQgc2hvdWxkIG5vdCBtb2RpZnlcbiAgICogb3IgbXV0YXRlIGFueSBTY2VuZXJ5IG5vZGVzIChwYXJ0aWN1bGFybHkgYW55dGhpbmcgdGhhdCB3b3VsZCBjYXVzZSBzb21ldGhpbmcgdG8gYmUgbWFya2VkIGFzIG5lZWRpbmcgYSByZXBhaW50KS5cbiAgICogSWRlYWxseSwgdGhpcyBmdW5jdGlvbiBzaG91bGQgaGF2ZSBubyBvdXRzaWRlIGVmZmVjdHMgb3RoZXIgdGhhbiBwYWludGluZyB0byB0aGUgQ2FudmFzIHByb3ZpZGVkLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHBhaW50Q2FudmFzKCBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgKTogdm9pZDtcblxuICAvKipcbiAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoaXMgbm9kZSBuZWVkcyB0byBiZSByZXBhaW50ZWQuIFdoZW4gbm90IGNhbGxlZCwgU2NlbmVyeSBhc3N1bWVzIHRoYXQgdGhpcyBub2RlIGRvZXNcbiAgICogTk9UIG5lZWQgdG8gYmUgcmVwYWludGVkIChhbHRob3VnaCBTY2VuZXJ5IG1heSByZXBhaW50IGl0IGR1ZSB0byBvdGhlciBub2RlcyBuZWVkaW5nIHRvIGJlIHJlcGFpbnRlZCkuXG4gICAqXG4gICAqIFRoaXMgc2V0cyBhIFwiZGlydHlcIiBmbGFnLCBzbyB0aGF0IGl0IHdpbGwgYmUgcmVwYWludGVkIHRoZSBuZXh0IHRpbWUgaXQgd291bGQgYmUgZGlzcGxheWVkLlxuICAgKi9cbiAgcHVibGljIGludmFsaWRhdGVQYWludCgpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0ZUxlbiA9IHRoaXMuX2RyYXdhYmxlcy5sZW5ndGg7XG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgc3RhdGVMZW47IGkrKyApIHtcbiAgICAgIHRoaXMuX2RyYXdhYmxlc1sgaSBdLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgY3VycmVudCBOb2RlJ3Mgc2VsZiByZXByZXNlbnRhdGlvbiwgYXNzdW1pbmcgdGhlIHdyYXBwZXIncyBDYW52YXMgY29udGV4dCBpcyBhbHJlYWR5IGluIHRoZSBsb2NhbFxuICAgKiBjb29yZGluYXRlIGZyYW1lIG9mIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHdyYXBwZXJcbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYWxyZWFkeSBhcHBsaWVkIHRvIHRoZSBjb250ZXh0LlxuICAgKi9cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGNhbnZhc1BhaW50U2VsZiggd3JhcHBlcjogQ2FudmFzQ29udGV4dFdyYXBwZXIsIG1hdHJpeDogTWF0cml4MyApOiB2b2lkIHtcbiAgICB0aGlzLnBhaW50Q2FudmFzKCB3cmFwcGVyLmNvbnRleHQgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwb2ludCBpcyBcImluc2lkZVwiIChjb250YWluZWQpIGluIHRoaXMgTm9kZSdzIHNlbGYgY29udGVudCwgb3IgXCJvdXRzaWRlXCIuXG4gICAqXG4gICAqIElmIENhbnZhc05vZGUgc3VidHlwZXMgd2FudCB0byBzdXBwb3J0IGJlaW5nIHBpY2tlZCBvciBoaXQtdGVzdGVkLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHBvaW50IC0gQ29uc2lkZXJlZCB0byBiZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZVxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIGNvbnRhaW5zUG9pbnRTZWxmKCBwb2ludDogVmVjdG9yMiApOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFNoYXBlIHRoYXQgcmVwcmVzZW50cyB0aGUgYXJlYSBjb3ZlcmVkIGJ5IGNvbnRhaW5zUG9pbnRTZWxmLlxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIGdldFNlbGZTaGFwZSgpOiBTaGFwZSB7XG4gICAgcmV0dXJuIG5ldyBTaGFwZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDYW52YXMgZHJhd2FibGUgZm9yIHRoaXMgQ2FudmFzTm9kZS4gKHNjZW5lcnktaW50ZXJuYWwpXG4gICAqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIEluIHRoZSBiaXRtYXNrIGZvcm1hdCBzcGVjaWZpZWQgYnkgUmVuZGVyZXIsIHdoaWNoIG1heSBjb250YWluIGFkZGl0aW9uYWwgYml0IGZsYWdzLlxuICAgKiBAcGFyYW0gaW5zdGFuY2UgLSBJbnN0YW5jZSBvYmplY3QgdGhhdCB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZHJhd2FibGVcbiAgICovXG4gIHB1YmxpYyBvdmVycmlkZSBjcmVhdGVDYW52YXNEcmF3YWJsZSggcmVuZGVyZXI6IG51bWJlciwgaW5zdGFuY2U6IEluc3RhbmNlICk6IENhbnZhc1NlbGZEcmF3YWJsZSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHJldHVybiBDYW52YXNOb2RlRHJhd2FibGUuY3JlYXRlRnJvbVBvb2woIHJlbmRlcmVyLCBpbnN0YW5jZSApO1xuICB9XG5cbiAgcHVibGljIG92ZXJyaWRlIG11dGF0ZSggb3B0aW9ucz86IENhbnZhc05vZGVPcHRpb25zICk6IHRoaXMge1xuICAgIHJldHVybiBzdXBlci5tdXRhdGUoIG9wdGlvbnMgKTtcbiAgfVxufVxuXG4vKipcbiAqIHtBcnJheS48c3RyaW5nPn0gLSBTdHJpbmcga2V5cyBmb3IgYWxsIG9mIHRoZSBhbGxvd2VkIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHNldCBieSBub2RlLm11dGF0ZSggb3B0aW9ucyApLCBpbiB0aGVcbiAqIG9yZGVyIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgaW4uXG4gKlxuICogTk9URTogU2VlIE5vZGUncyBfbXV0YXRvcktleXMgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdGhpcyBvcGVyYXRlcywgYW5kIHBvdGVudGlhbCBzcGVjaWFsXG4gKiAgICAgICBjYXNlcyB0aGF0IG1heSBhcHBseS5cbiAqL1xuQ2FudmFzTm9kZS5wcm90b3R5cGUuX211dGF0b3JLZXlzID0gQ0FOVkFTX05PREVfT1BUSU9OX0tFWVMuY29uY2F0KCBOb2RlLnByb3RvdHlwZS5fbXV0YXRvcktleXMgKTtcblxuc2NlbmVyeS5yZWdpc3RlciggJ0NhbnZhc05vZGUnLCBDYW52YXNOb2RlICk7Il0sIm5hbWVzIjpbIlNoYXBlIiwiQ2FudmFzTm9kZURyYXdhYmxlIiwiTm9kZSIsIlJlbmRlcmVyIiwic2NlbmVyeSIsIkNBTlZBU19OT0RFX09QVElPTl9LRVlTIiwiQ2FudmFzTm9kZSIsInNldENhbnZhc0JvdW5kcyIsInNlbGZCb3VuZHMiLCJpbnZhbGlkYXRlU2VsZiIsImNhbnZhc0JvdW5kcyIsInZhbHVlIiwiZ2V0Q2FudmFzQm91bmRzIiwiZ2V0U2VsZkJvdW5kcyIsImlzUGFpbnRlZCIsImludmFsaWRhdGVQYWludCIsInN0YXRlTGVuIiwiX2RyYXdhYmxlcyIsImxlbmd0aCIsImkiLCJtYXJrRGlydHkiLCJjYW52YXNQYWludFNlbGYiLCJ3cmFwcGVyIiwibWF0cml4IiwicGFpbnRDYW52YXMiLCJjb250ZXh0IiwiY29udGFpbnNQb2ludFNlbGYiLCJwb2ludCIsImdldFNlbGZTaGFwZSIsImNyZWF0ZUNhbnZhc0RyYXdhYmxlIiwicmVuZGVyZXIiLCJpbnN0YW5jZSIsImNyZWF0ZUZyb21Qb29sIiwibXV0YXRlIiwib3B0aW9ucyIsInNldFJlbmRlcmVyQml0bWFzayIsImJpdG1hc2tDYW52YXMiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJjb25jYXQiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7Ozs7OztDQVFDLEdBS0QsU0FBU0EsS0FBSyxRQUFRLDhCQUE4QjtBQUNwRCxTQUErQkMsa0JBQWtCLEVBQWdDQyxJQUFJLEVBQWVDLFFBQVEsRUFBRUMsT0FBTyxRQUFRLGdCQUFnQjtBQUU3SSxNQUFNQywwQkFBMEI7SUFDOUI7Q0FDRDtBQVFjLElBQUEsQUFBZUMsYUFBZixNQUFlQSxtQkFBbUJKO0lBUS9DOzs7OztHQUtDLEdBQ0QsQUFBT0ssZ0JBQWlCQyxVQUFtQixFQUFTO1FBQ2xELElBQUksQ0FBQ0MsY0FBYyxDQUFFRDtJQUN2QjtJQUVBLElBQVdFLGFBQWNDLEtBQWMsRUFBRztRQUFFLElBQUksQ0FBQ0osZUFBZSxDQUFFSTtJQUFTO0lBRTNFLElBQVdELGVBQXdCO1FBQUUsT0FBTyxJQUFJLENBQUNFLGVBQWU7SUFBSTtJQUVwRTs7R0FFQyxHQUNELEFBQU9BLGtCQUEyQjtRQUNoQyxPQUFPLElBQUksQ0FBQ0MsYUFBYTtJQUMzQjtJQUVBOztHQUVDLEdBQ0QsQUFBZ0JDLFlBQXFCO1FBQ25DLDZCQUE2QjtRQUM3QixPQUFPO0lBQ1Q7SUFXQTs7Ozs7R0FLQyxHQUNELEFBQU9DLGtCQUF3QjtRQUM3QixNQUFNQyxXQUFXLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxNQUFNO1FBQ3ZDLElBQU0sSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxVQUFVRyxJQUFNO1lBQ25DLElBQUksQ0FBQ0YsVUFBVSxDQUFFRSxFQUFHLENBQUNDLFNBQVM7UUFDaEM7SUFDRjtJQUVBOzs7Ozs7R0FNQyxHQUNELEFBQW1CQyxnQkFBaUJDLE9BQTZCLEVBQUVDLE1BQWUsRUFBUztRQUN6RixJQUFJLENBQUNDLFdBQVcsQ0FBRUYsUUFBUUcsT0FBTztJQUNuQztJQUVBOzs7Ozs7R0FNQyxHQUNELEFBQWdCQyxrQkFBbUJDLEtBQWMsRUFBWTtRQUMzRCxPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELEFBQWdCQyxlQUFzQjtRQUNwQyxPQUFPLElBQUk1QjtJQUNiO0lBRUE7Ozs7O0dBS0MsR0FDRCxBQUFnQjZCLHFCQUFzQkMsUUFBZ0IsRUFBRUMsUUFBa0IsRUFBdUI7UUFDL0YsbUJBQW1CO1FBQ25CLE9BQU85QixtQkFBbUIrQixjQUFjLENBQUVGLFVBQVVDO0lBQ3REO0lBRWdCRSxPQUFRQyxPQUEyQixFQUFTO1FBQzFELE9BQU8sS0FBSyxDQUFDRCxPQUFRQztJQUN2QjtJQXBHQSxZQUFvQkEsT0FBMkIsQ0FBRztRQUNoRCxLQUFLLENBQUVBO1FBRVAseURBQXlEO1FBQ3pELElBQUksQ0FBQ0Msa0JBQWtCLENBQUVoQyxTQUFTaUMsYUFBYTtJQUNqRDtBQWdHRjtBQXRHQSxTQUE4QjlCLHdCQXNHN0I7QUFFRDs7Ozs7O0NBTUMsR0FDREEsV0FBVytCLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHakMsd0JBQXdCa0MsTUFBTSxDQUFFckMsS0FBS21DLFNBQVMsQ0FBQ0MsWUFBWTtBQUUvRmxDLFFBQVFvQyxRQUFRLENBQUUsY0FBY2xDIn0=