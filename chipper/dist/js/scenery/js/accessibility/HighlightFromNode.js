// Copyright 2017-2024, University of Colorado Boulder
/**
 * A HighlightPath subtype that is based around a Node. The focusHighlight is constructed based on the bounds of
 * the node. The focusHighlight will update as the Node's bounds changes. Handles transformations so that when the
 * source node is transformed, the HighlightFromNode will
 * updated be as well.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */ import { Shape } from '../../../kite/js/imports.js';
import optionize from '../../../phet-core/js/optionize.js';
import { HighlightPath, scenery } from '../imports.js';
let HighlightFromNode = class HighlightFromNode extends HighlightPath {
    /**
   * Update the focusHighlight shape on the path given the node passed in. Depending on options supplied to this
   * HighlightFromNode, the shape will surround the node's bounds or its local bounds, dilated by an amount
   * that is dependent on whether or not this highlight is for group content or for the node itself. See
   * ParallelDOM.setGroupFocusHighlight() for more information on group highlights.
   *
   * node - The Node with a highlight to surround.
   * [trail] - A Trail to use to describe the Node in the global coordinate frame.
   *           Provided by the HighlightOverlay, to support DAG.
   */ setShapeFromNode(node, trail) {
        // cleanup the previous listener
        if (this.observedBoundsProperty) {
            assert && assert(this.boundsListener, 'should be a listener if there is a previous focusHighlightNode');
            this.observedBoundsProperty.unlink(this.boundsListener);
        }
        // The HighlightOverlay updates highlight positioning with a TransformTracker so the local bounds accurately
        // describe the highlight shape. NOTE: This does not update with changes to visible bounds - scenery
        // does not have support for that at this time (requires a visibleBoundsProperty).
        this.observedBoundsProperty = node.localBoundsProperty;
        this.boundsListener = (localBounds)=>{
            // Ignore setting the shape if we don't yet have finite bounds.
            if (!localBounds.isFinite()) {
                return;
            }
            let dilationCoefficient = this.dilationCoefficient;
            // Get the matrix that will transform the node's local bounds to global coordinates.
            // Then apply a pan/zoom correction so that the highlight looks appropriately
            // sized from pan/zoom transformation but other transformations are not applied.
            assert && assert(trail || node.getTrails().length < 2, 'HighlightFromNode requires a unique Trail if using DAG.');
            const trailToUse = trail || node.getUniqueTrail();
            const matrix = trailToUse.getMatrix().timesMatrix(HighlightPath.getCorrectiveScalingMatrix());
            // Figure out how much dilation to apply to the focus highlight around the node, calculated unless specified
            // with options
            if (this.dilationCoefficient === null) {
                dilationCoefficient = this.useGroupDilation ? HighlightPath.getGroupDilationCoefficient(matrix) : HighlightPath.getDilationCoefficient(matrix);
            }
            const visibleBounds = this.useLocalBounds ? node.getVisibleLocalBounds() : node.getVisibleBounds();
            const dilatedVisibleBounds = visibleBounds.dilated(dilationCoefficient);
            // Update the line width of the focus highlight based on the transform of the node
            this.setShape(Shape.bounds(dilatedVisibleBounds));
        };
        this.observedBoundsProperty.link(this.boundsListener);
    }
    /**
   * Remove the listener from the observedBoundsProperty (which belongs to a provided Node).
   */ dispose() {
        if (this.observedBoundsProperty) {
            assert && assert(this.boundsListener, 'should be a listener if there is a previous focusHighlightNode');
            this.observedBoundsProperty.unlink(this.boundsListener);
        }
        super.dispose();
    }
    constructor(node, providedOptions){
        const options = optionize()({
            useLocalBounds: true,
            dilationCoefficient: null,
            useGroupDilation: false
        }, providedOptions);
        options.transformSourceNode = node;
        super(null, options), // Property for a Node's bounds which are currently being observed with the boundsListener. Referenced so that
        // we can remove the listener later.
        this.observedBoundsProperty = null, // Listener that sets the shape of this highlight when the Node bounds change. Referenced so it can be removed later.
        this.boundsListener = null;
        this.useLocalBounds = options.useLocalBounds;
        this.useGroupDilation = options.useGroupDilation;
        this.dilationCoefficient = options.dilationCoefficient;
        if (node) {
            this.setShapeFromNode(node);
        }
    }
};
scenery.register('HighlightFromNode', HighlightFromNode);
export default HighlightFromNode;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvYWNjZXNzaWJpbGl0eS9IaWdobGlnaHRGcm9tTm9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNy0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBBIEhpZ2hsaWdodFBhdGggc3VidHlwZSB0aGF0IGlzIGJhc2VkIGFyb3VuZCBhIE5vZGUuIFRoZSBmb2N1c0hpZ2hsaWdodCBpcyBjb25zdHJ1Y3RlZCBiYXNlZCBvbiB0aGUgYm91bmRzIG9mXG4gKiB0aGUgbm9kZS4gVGhlIGZvY3VzSGlnaGxpZ2h0IHdpbGwgdXBkYXRlIGFzIHRoZSBOb2RlJ3MgYm91bmRzIGNoYW5nZXMuIEhhbmRsZXMgdHJhbnNmb3JtYXRpb25zIHNvIHRoYXQgd2hlbiB0aGVcbiAqIHNvdXJjZSBub2RlIGlzIHRyYW5zZm9ybWVkLCB0aGUgSGlnaGxpZ2h0RnJvbU5vZGUgd2lsbFxuICogdXBkYXRlZCBiZSBhcyB3ZWxsLlxuICpcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICovXG5cbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcbmltcG9ydCBTdHJpY3RPbWl0IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9TdHJpY3RPbWl0LmpzJztcbmltcG9ydCB7IEhpZ2hsaWdodFBhdGgsIEhpZ2hsaWdodFBhdGhPcHRpb25zLCBOb2RlLCBzY2VuZXJ5LCBUcmFpbCB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xuXG50eXBlIFNlbGZPcHRpb25zID0ge1xuXG4gIC8vIGlmIHRydWUsIGhpZ2hsaWdodCB3aWxsIHN1cnJvdW5kIGxvY2FsIGJvdW5kcyBpbnN0ZWFkIG9mIHBhcmVudCBib3VuZHNcbiAgdXNlTG9jYWxCb3VuZHM/OiBib29sZWFuO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWUgaXMgZnVuY3Rpb24gb2Ygbm9kZSB0cmFuc2Zvcm0gKG1pbnVzIHRyYW5zbGF0aW9uKSwgYnV0IGNhbiBiZSBzZXQgZXhwbGljaXRseS5cbiAgLy8gc2VlIEhpZ2hsaWdodFBhdGguZ2V0RGlsYXRpb25Db2VmZmljaWVudCgpLiBBIG51bWJlciBoZXJlIHJlZmVycyB0byB0aGUgYW1vdW50IGluIGdsb2JhbCBjb29yZGluYXRlcyB0b1xuICAvLyBkaWxhdGUgdGhlIGZvY3VzIGhpZ2hsaWdodC5cbiAgZGlsYXRpb25Db2VmZmljaWVudD86IG51bWJlciB8IG51bGw7XG5cbiAgLy8gaWYgdHJ1ZSwgZGlsYXRpb24gZm9yIGJvdW5kcyBhcm91bmQgbm9kZSB3aWxsIGluY3JlYXNlLCBzZWUgc2V0U2hhcGVGcm9tTm9kZSgpXG4gIHVzZUdyb3VwRGlsYXRpb24/OiBib29sZWFuO1xufTtcblxuLy8gVGhlIHRyYW5zZm9ybVNvdXJjZU5vZGUgZm9yIHRoaXMgaGlnaGxpZ2h0IHdpbGwgYmUgdGhlIHByb3ZpZGVkIE5vZGUuXG5leHBvcnQgdHlwZSBIaWdobGlnaHRGcm9tTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFN0cmljdE9taXQ8SGlnaGxpZ2h0UGF0aE9wdGlvbnMsICd0cmFuc2Zvcm1Tb3VyY2VOb2RlJz47XG5cbmNsYXNzIEhpZ2hsaWdodEZyb21Ob2RlIGV4dGVuZHMgSGlnaGxpZ2h0UGF0aCB7XG5cbiAgLy8gU2VlIG9wdGlvbnMgZm9yIGRvY3VtZW50YXRpb24uXG4gIHByaXZhdGUgcmVhZG9ubHkgdXNlTG9jYWxCb3VuZHM6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgdXNlR3JvdXBEaWxhdGlvbjogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBkaWxhdGlvbkNvZWZmaWNpZW50OiBudW1iZXIgfCBudWxsO1xuXG4gIC8vIFByb3BlcnR5IGZvciBhIE5vZGUncyBib3VuZHMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBvYnNlcnZlZCB3aXRoIHRoZSBib3VuZHNMaXN0ZW5lci4gUmVmZXJlbmNlZCBzbyB0aGF0XG4gIC8vIHdlIGNhbiByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyLlxuICBwcml2YXRlIG9ic2VydmVkQm91bmRzUHJvcGVydHk6IG51bGwgfCBUUHJvcGVydHk8Qm91bmRzMj4gPSBudWxsO1xuXG4gIC8vIExpc3RlbmVyIHRoYXQgc2V0cyB0aGUgc2hhcGUgb2YgdGhpcyBoaWdobGlnaHQgd2hlbiB0aGUgTm9kZSBib3VuZHMgY2hhbmdlLiBSZWZlcmVuY2VkIHNvIGl0IGNhbiBiZSByZW1vdmVkIGxhdGVyLlxuICBwcml2YXRlIGJvdW5kc0xpc3RlbmVyOiBudWxsIHwgKCAoIGJvdW5kczogQm91bmRzMiApID0+IHZvaWQgKSA9IG51bGw7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBub2RlOiBOb2RlIHwgbnVsbCwgcHJvdmlkZWRPcHRpb25zPzogSGlnaGxpZ2h0RnJvbU5vZGVPcHRpb25zICkge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxIaWdobGlnaHRGcm9tTm9kZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBIaWdobGlnaHRQYXRoT3B0aW9ucz4oKSgge1xuICAgICAgdXNlTG9jYWxCb3VuZHM6IHRydWUsXG4gICAgICBkaWxhdGlvbkNvZWZmaWNpZW50OiBudWxsLFxuICAgICAgdXNlR3JvdXBEaWxhdGlvbjogZmFsc2VcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIG9wdGlvbnMudHJhbnNmb3JtU291cmNlTm9kZSA9IG5vZGU7XG5cbiAgICBzdXBlciggbnVsbCwgb3B0aW9ucyApO1xuXG4gICAgdGhpcy51c2VMb2NhbEJvdW5kcyA9IG9wdGlvbnMudXNlTG9jYWxCb3VuZHM7XG4gICAgdGhpcy51c2VHcm91cERpbGF0aW9uID0gb3B0aW9ucy51c2VHcm91cERpbGF0aW9uO1xuICAgIHRoaXMuZGlsYXRpb25Db2VmZmljaWVudCA9IG9wdGlvbnMuZGlsYXRpb25Db2VmZmljaWVudDtcblxuICAgIGlmICggbm9kZSApIHtcbiAgICAgIHRoaXMuc2V0U2hhcGVGcm9tTm9kZSggbm9kZSApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZvY3VzSGlnaGxpZ2h0IHNoYXBlIG9uIHRoZSBwYXRoIGdpdmVuIHRoZSBub2RlIHBhc3NlZCBpbi4gRGVwZW5kaW5nIG9uIG9wdGlvbnMgc3VwcGxpZWQgdG8gdGhpc1xuICAgKiBIaWdobGlnaHRGcm9tTm9kZSwgdGhlIHNoYXBlIHdpbGwgc3Vycm91bmQgdGhlIG5vZGUncyBib3VuZHMgb3IgaXRzIGxvY2FsIGJvdW5kcywgZGlsYXRlZCBieSBhbiBhbW91bnRcbiAgICogdGhhdCBpcyBkZXBlbmRlbnQgb24gd2hldGhlciBvciBub3QgdGhpcyBoaWdobGlnaHQgaXMgZm9yIGdyb3VwIGNvbnRlbnQgb3IgZm9yIHRoZSBub2RlIGl0c2VsZi4gU2VlXG4gICAqIFBhcmFsbGVsRE9NLnNldEdyb3VwRm9jdXNIaWdobGlnaHQoKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBncm91cCBoaWdobGlnaHRzLlxuICAgKlxuICAgKiBub2RlIC0gVGhlIE5vZGUgd2l0aCBhIGhpZ2hsaWdodCB0byBzdXJyb3VuZC5cbiAgICogW3RyYWlsXSAtIEEgVHJhaWwgdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBOb2RlIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZS5cbiAgICogICAgICAgICAgIFByb3ZpZGVkIGJ5IHRoZSBIaWdobGlnaHRPdmVybGF5LCB0byBzdXBwb3J0IERBRy5cbiAgICovXG4gIHB1YmxpYyBzZXRTaGFwZUZyb21Ob2RlKCBub2RlOiBOb2RlLCB0cmFpbD86IFRyYWlsICk6IHZvaWQge1xuXG4gICAgLy8gY2xlYW51cCB0aGUgcHJldmlvdXMgbGlzdGVuZXJcbiAgICBpZiAoIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eSApIHtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuYm91bmRzTGlzdGVuZXIsICdzaG91bGQgYmUgYSBsaXN0ZW5lciBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIGZvY3VzSGlnaGxpZ2h0Tm9kZScgKTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eS51bmxpbmsoIHRoaXMuYm91bmRzTGlzdGVuZXIhICk7XG4gICAgfVxuXG4gICAgLy8gVGhlIEhpZ2hsaWdodE92ZXJsYXkgdXBkYXRlcyBoaWdobGlnaHQgcG9zaXRpb25pbmcgd2l0aCBhIFRyYW5zZm9ybVRyYWNrZXIgc28gdGhlIGxvY2FsIGJvdW5kcyBhY2N1cmF0ZWx5XG4gICAgLy8gZGVzY3JpYmUgdGhlIGhpZ2hsaWdodCBzaGFwZS4gTk9URTogVGhpcyBkb2VzIG5vdCB1cGRhdGUgd2l0aCBjaGFuZ2VzIHRvIHZpc2libGUgYm91bmRzIC0gc2NlbmVyeVxuICAgIC8vIGRvZXMgbm90IGhhdmUgc3VwcG9ydCBmb3IgdGhhdCBhdCB0aGlzIHRpbWUgKHJlcXVpcmVzIGEgdmlzaWJsZUJvdW5kc1Byb3BlcnR5KS5cbiAgICB0aGlzLm9ic2VydmVkQm91bmRzUHJvcGVydHkgPSBub2RlLmxvY2FsQm91bmRzUHJvcGVydHk7XG4gICAgdGhpcy5ib3VuZHNMaXN0ZW5lciA9IGxvY2FsQm91bmRzID0+IHtcblxuICAgICAgLy8gSWdub3JlIHNldHRpbmcgdGhlIHNoYXBlIGlmIHdlIGRvbid0IHlldCBoYXZlIGZpbml0ZSBib3VuZHMuXG4gICAgICBpZiAoICFsb2NhbEJvdW5kcy5pc0Zpbml0ZSgpICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkaWxhdGlvbkNvZWZmaWNpZW50ID0gdGhpcy5kaWxhdGlvbkNvZWZmaWNpZW50O1xuXG4gICAgICAvLyBHZXQgdGhlIG1hdHJpeCB0aGF0IHdpbGwgdHJhbnNmb3JtIHRoZSBub2RlJ3MgbG9jYWwgYm91bmRzIHRvIGdsb2JhbCBjb29yZGluYXRlcy5cbiAgICAgIC8vIFRoZW4gYXBwbHkgYSBwYW4vem9vbSBjb3JyZWN0aW9uIHNvIHRoYXQgdGhlIGhpZ2hsaWdodCBsb29rcyBhcHByb3ByaWF0ZWx5XG4gICAgICAvLyBzaXplZCBmcm9tIHBhbi96b29tIHRyYW5zZm9ybWF0aW9uIGJ1dCBvdGhlciB0cmFuc2Zvcm1hdGlvbnMgYXJlIG5vdCBhcHBsaWVkLlxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdHJhaWwgfHwgbm9kZS5nZXRUcmFpbHMoKS5sZW5ndGggPCAyLCAnSGlnaGxpZ2h0RnJvbU5vZGUgcmVxdWlyZXMgYSB1bmlxdWUgVHJhaWwgaWYgdXNpbmcgREFHLicgKTtcbiAgICAgIGNvbnN0IHRyYWlsVG9Vc2UgPSB0cmFpbCB8fCBub2RlLmdldFVuaXF1ZVRyYWlsKCk7XG4gICAgICBjb25zdCBtYXRyaXggPSB0cmFpbFRvVXNlLmdldE1hdHJpeCgpXG4gICAgICAgIC50aW1lc01hdHJpeCggSGlnaGxpZ2h0UGF0aC5nZXRDb3JyZWN0aXZlU2NhbGluZ01hdHJpeCgpICk7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgaG93IG11Y2ggZGlsYXRpb24gdG8gYXBwbHkgdG8gdGhlIGZvY3VzIGhpZ2hsaWdodCBhcm91bmQgdGhlIG5vZGUsIGNhbGN1bGF0ZWQgdW5sZXNzIHNwZWNpZmllZFxuICAgICAgLy8gd2l0aCBvcHRpb25zXG4gICAgICBpZiAoIHRoaXMuZGlsYXRpb25Db2VmZmljaWVudCA9PT0gbnVsbCApIHtcbiAgICAgICAgZGlsYXRpb25Db2VmZmljaWVudCA9ICggdGhpcy51c2VHcm91cERpbGF0aW9uID8gSGlnaGxpZ2h0UGF0aC5nZXRHcm91cERpbGF0aW9uQ29lZmZpY2llbnQoIG1hdHJpeCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0UGF0aC5nZXREaWxhdGlvbkNvZWZmaWNpZW50KCBtYXRyaXggKSApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2aXNpYmxlQm91bmRzID0gdGhpcy51c2VMb2NhbEJvdW5kcyA/IG5vZGUuZ2V0VmlzaWJsZUxvY2FsQm91bmRzKCkgOiBub2RlLmdldFZpc2libGVCb3VuZHMoKTtcbiAgICAgIGNvbnN0IGRpbGF0ZWRWaXNpYmxlQm91bmRzID0gdmlzaWJsZUJvdW5kcy5kaWxhdGVkKCBkaWxhdGlvbkNvZWZmaWNpZW50ISApO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgd2lkdGggb2YgdGhlIGZvY3VzIGhpZ2hsaWdodCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlXG4gICAgICB0aGlzLnNldFNoYXBlKCBTaGFwZS5ib3VuZHMoIGRpbGF0ZWRWaXNpYmxlQm91bmRzICkgKTtcbiAgICB9O1xuICAgIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eS5saW5rKCB0aGlzLmJvdW5kc0xpc3RlbmVyICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBvYnNlcnZlZEJvdW5kc1Byb3BlcnR5ICh3aGljaCBiZWxvbmdzIHRvIGEgcHJvdmlkZWQgTm9kZSkuXG4gICAqL1xuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eSApIHtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuYm91bmRzTGlzdGVuZXIsICdzaG91bGQgYmUgYSBsaXN0ZW5lciBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIGZvY3VzSGlnaGxpZ2h0Tm9kZScgKTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eS51bmxpbmsoIHRoaXMuYm91bmRzTGlzdGVuZXIhICk7XG4gICAgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbnNjZW5lcnkucmVnaXN0ZXIoICdIaWdobGlnaHRGcm9tTm9kZScsIEhpZ2hsaWdodEZyb21Ob2RlICk7XG5cbmV4cG9ydCBkZWZhdWx0IEhpZ2hsaWdodEZyb21Ob2RlOyJdLCJuYW1lcyI6WyJTaGFwZSIsIm9wdGlvbml6ZSIsIkhpZ2hsaWdodFBhdGgiLCJzY2VuZXJ5IiwiSGlnaGxpZ2h0RnJvbU5vZGUiLCJzZXRTaGFwZUZyb21Ob2RlIiwibm9kZSIsInRyYWlsIiwib2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eSIsImFzc2VydCIsImJvdW5kc0xpc3RlbmVyIiwidW5saW5rIiwibG9jYWxCb3VuZHNQcm9wZXJ0eSIsImxvY2FsQm91bmRzIiwiaXNGaW5pdGUiLCJkaWxhdGlvbkNvZWZmaWNpZW50IiwiZ2V0VHJhaWxzIiwibGVuZ3RoIiwidHJhaWxUb1VzZSIsImdldFVuaXF1ZVRyYWlsIiwibWF0cml4IiwiZ2V0TWF0cml4IiwidGltZXNNYXRyaXgiLCJnZXRDb3JyZWN0aXZlU2NhbGluZ01hdHJpeCIsInVzZUdyb3VwRGlsYXRpb24iLCJnZXRHcm91cERpbGF0aW9uQ29lZmZpY2llbnQiLCJnZXREaWxhdGlvbkNvZWZmaWNpZW50IiwidmlzaWJsZUJvdW5kcyIsInVzZUxvY2FsQm91bmRzIiwiZ2V0VmlzaWJsZUxvY2FsQm91bmRzIiwiZ2V0VmlzaWJsZUJvdW5kcyIsImRpbGF0ZWRWaXNpYmxlQm91bmRzIiwiZGlsYXRlZCIsInNldFNoYXBlIiwiYm91bmRzIiwibGluayIsImRpc3Bvc2UiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwidHJhbnNmb3JtU291cmNlTm9kZSIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7Ozs7O0NBUUMsR0FJRCxTQUFTQSxLQUFLLFFBQVEsOEJBQThCO0FBQ3BELE9BQU9D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