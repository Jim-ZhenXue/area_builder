// Copyright 2017-2024, University of Colorado Boulder
/**
 * A MultiListener that is designed to pan and zoom a target Node, where you can provide limiting and
 * describing bounds so that the targetNode is limited to a region.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */ import Property from '../../../axon/js/Property.js';
import Bounds2 from '../../../dot/js/Bounds2.js';
import Matrix3 from '../../../dot/js/Matrix3.js';
import optionize from '../../../phet-core/js/optionize.js';
import ModelViewTransform2 from '../../../phetcommon/js/view/ModelViewTransform2.js';
import isSettingPhetioStateProperty from '../../../tandem/js/isSettingPhetioStateProperty.js';
import { MultiListener, scenery } from '../imports.js';
// constants
// Reusable Matrix3 instance to avoid creating lots of them
const SCRATCH_MATRIX = new Matrix3();
let PanZoomListener = class PanZoomListener extends MultiListener {
    /**
   * If the targetNode is larger than the panBounds specified, keep the panBounds completely filled with
   * targetNode content.
   */ correctReposition() {
        // Save values of the current matrix, so that we only do certain work when the matrix actually changes
        SCRATCH_MATRIX.set(this._targetNode.matrix);
        // the targetBounds transformed by the targetNode's transform, to determine if targetBounds are out of panBounds
        const transformedBounds = this._targetBounds.transformed(this._targetNode.getMatrix());
        // Don't let panning go through if the node is fully contained by the panBounds
        if (transformedBounds.left > this._panBounds.left) {
            this._targetNode.left = this._panBounds.left - (transformedBounds.left - this._targetNode.left);
        }
        if (transformedBounds.top > this._panBounds.top) {
            this._targetNode.top = this._panBounds.top - (transformedBounds.top - this._targetNode.top);
        }
        if (transformedBounds.right < this._panBounds.right) {
            this._targetNode.right = this._panBounds.right + (this._targetNode.right - transformedBounds.right);
        }
        if (transformedBounds.bottom < this._panBounds.bottom) {
            this._targetNode.bottom = this._panBounds.bottom + (this._targetNode.bottom - transformedBounds.bottom);
        }
        // Update Property with matrix once position has been corrected to notify listeners and set PhET-iO state, but
        // only notify when there has been an actual change.
        if (!SCRATCH_MATRIX.equals(this._targetNode.matrix)) {
            this.matrixProperty.set(this._targetNode.matrix.copy());
        }
    }
    /**
   * If the transformed targetBounds are equal to the panBounds, there is no space for us to pan so do not change
   * the pointer cursor.
   */ addPress(press) {
        super.addPress(press);
        // don't show the pressCursor if our bounds are limited by pan bounds, and we cannot pan anywhere
        const transformedBounds = this._targetBounds.transformed(this._targetNode.getMatrix());
        const boundsLimited = transformedBounds.equalsEpsilon(this._panBounds, 1E-8);
        press.pointer.cursor = boundsLimited ? null : this._pressCursor;
    }
    /**
   * Reposition but keep content within this._panBounds.
   */ reposition() {
        super.reposition();
        this.correctReposition();
    }
    /**
   * Reset the transform on the targetNode and follow up by making sure that the content is still within panBounds.
   */ resetTransform() {
        super.resetTransform();
        this.correctReposition();
    }
    /**
   * Set the containing panBounds and then make sure that the targetBounds fully fill the new panBounds.
   */ setPanBounds(panBounds) {
        this._panBounds = panBounds;
        this.sourceFramePanBoundsProperty.set(this._panBounds);
        this.correctReposition();
    }
    /**
   * Set the targetBounds which should totally fill the panBounds at all times. Useful if the targetNode has bounds
   * which don't accurately describe the node. For instance, if an overlay plane is on top of the node and extends
   * beyond the dimensions of the visible node.
   *
   * targetBounds - in the global coordinate frame
   */ setTargetBounds(targetBounds) {
        this._targetBounds = targetBounds;
        this.correctReposition();
    }
    /**
   * Set the representative scale of the target Node. If the targetBounds are different from the targetNode.bounds
   * it may be useful to correct changes to panning and zooming by a scale that is different from the
   * actual scale applied to the targetNode during panning.
   */ setTargetScale(scale) {
        this._targetScale = scale;
    }
    /**
   * Get the targetBounds, in the global coordinate frame.
   */ getTargetBounds() {
        return this._targetBounds;
    }
    /**
   * @param targetNode - The Node that should be transformed by this PanZoomListener.
   * @param [providedOptions].
   */ constructor(targetNode, providedOptions){
        var _options_tandem;
        const options = optionize()({
            panBounds: Bounds2.NOTHING,
            targetBounds: null,
            targetScale: 1,
            // by default, the PanZoomListener does now allow rotation
            allowRotation: false
        }, providedOptions);
        super(targetNode, options);
        this._panBounds = options.panBounds;
        this._targetBounds = options.targetBounds || targetNode.globalBounds.copy();
        this._targetScale = options.targetScale;
        this.sourceFramePanBoundsProperty = new Property(this._panBounds, {
            tandem: (_options_tandem = options.tandem) == null ? void 0 : _options_tandem.createTandem('sourceFramePanBoundsProperty'),
            phetioReadOnly: true,
            phetioValueType: Bounds2.Bounds2IO
        });
        this.sourceFramePanBoundsProperty.lazyLink(()=>{
            if (isSettingPhetioStateProperty.value) {
                // The matrixProperty has transformations relative to the global view coordinates of the source simulation,
                // so it will not be correct if source and destination frames are different sizes. This will map transforamtions
                // if destination frame has different size.
                const sourceDestinationTransform = ModelViewTransform2.createRectangleMapping(this.sourceFramePanBoundsProperty.get(), this._panBounds);
                const newTranslation = this._targetNode.matrix.translation.componentMultiply(sourceDestinationTransform.matrix.getScaleVector());
                const scale = this.matrixProperty.get().getScaleVector();
                this.matrixProperty.set(Matrix3.translationFromVector(newTranslation).timesMatrix(Matrix3.scaling(scale.x, scale.y)));
            }
        }, {
            // so that the listener will be called only after the matrixProperty is up to date in the downstream sim
            phetioDependencies: [
                this.matrixProperty
            ]
        });
    }
};
scenery.register('PanZoomListener', PanZoomListener);
export default PanZoomListener;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvbGlzdGVuZXJzL1Bhblpvb21MaXN0ZW5lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNy0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBBIE11bHRpTGlzdGVuZXIgdGhhdCBpcyBkZXNpZ25lZCB0byBwYW4gYW5kIHpvb20gYSB0YXJnZXQgTm9kZSwgd2hlcmUgeW91IGNhbiBwcm92aWRlIGxpbWl0aW5nIGFuZFxuICogZGVzY3JpYmluZyBib3VuZHMgc28gdGhhdCB0aGUgdGFyZ2V0Tm9kZSBpcyBsaW1pdGVkIHRvIGEgcmVnaW9uLlxuICpcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICovXG5cbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcbmltcG9ydCBNYXRyaXgzIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9NYXRyaXgzLmpzJztcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XG5pbXBvcnQgaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi90YW5kZW0vanMvaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgeyBNdWx0aUxpc3RlbmVyLCBNdWx0aUxpc3RlbmVyT3B0aW9ucywgTXVsdGlMaXN0ZW5lclByZXNzLCBOb2RlLCBzY2VuZXJ5IH0gZnJvbSAnLi4vaW1wb3J0cy5qcyc7XG5cbi8vIGNvbnN0YW50c1xuLy8gUmV1c2FibGUgTWF0cml4MyBpbnN0YW5jZSB0byBhdm9pZCBjcmVhdGluZyBsb3RzIG9mIHRoZW1cbmNvbnN0IFNDUkFUQ0hfTUFUUklYID0gbmV3IE1hdHJpeDMoKTtcblxudHlwZSBTZWxmT3B0aW9ucyA9IHtcblxuICAvLyB0aGVzZSBib3VuZHMgc2hvdWxkIGJlIGZ1bGx5IGZpbGxlZCB3aXRoIGNvbnRlbnQgYXQgYWxsIHRpbWVzLCBpbiB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgZnJhbWVcbiAgcGFuQm91bmRzPzogQm91bmRzMjtcblxuICAvLyBCb3VuZHMgZm9yIHRoZSB0YXJnZXQgbm9kZSB0aGF0IGdldCB0cmFuc2Zvcm1lZCB3aXRoIHRoaXMgbGlzdGVuZXIgYW5kIGZpbGwgcGFuQm91bmRzLFxuICAvLyB1c2VmdWwgaWYgdGhlIHRhcmdldE5vZGUgYm91bmRzIGRvIG5vdCBhY2N1cmF0ZWx5IGRlc2NyaWJlIHRoZSB0YXJnZXROb2RlIChsaWtlIGlmIGludmlzaWJsZSBjb250ZW50XG4gIC8vIGV4dGVuZHMgb2ZmIHNjcmVlbikuIERlZmF1bHRzIHRvIHRhcmdldE5vZGUgYm91bmRzIGlmIG51bGwuIEJvdW5kcyBpbiB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgZnJhbWUgb2YgdGhlXG4gIC8vIHRhcmdldCBOb2RlLlxuICB0YXJnZXRCb3VuZHM/OiBCb3VuZHMyIHwgbnVsbDtcblxuICAvLyBTY2FsZSB0aGF0IGFjY3VyYXRlbHkgZGVzY3JpYmVzIHNjYWxlIG9mIHRoZSB0YXJnZXROb2RlLCBidXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGFjdHVhbCBzY2FsZSBvZiB0aGVcbiAgLy8gdGFyZ2V0Tm9kZSdzIHRyYW5zZm9ybS4gVGhpcyBzY2FsZSBpcyBhcHBsaWVkIHRvIHRyYW5zbGF0aW9uIFZlY3RvcnMgZm9yIHRoZSBUYXJnZXROb2RlIGR1cmluZyBwYW5uaW5nLiBJZlxuICAvLyB0YXJnZXROb2RlIGNoaWxkcmVuIGdldCBzY2FsZWQgdW5pZm9ybWx5IChzdWNoIGFzIGluIHJlc3BvbnNlIHRvIHdpbmRvdyByZXNpemluZyBvciBuYXRpdmUgYnJvd3NlciB6b29tKSwgeW91XG4gIC8vIGxpa2VseSB3YW50IHRoYXQgc2NhbGUgdG8gYmUgYXBwbGllZCBkdXJpbmcgdHJhbnNsYXRpb24gb3BlcmF0aW9ucyBzbyB0aGF0IHBhbi96b29tIGJlaGF2ZXNcbiAgLy8gdGhlIHNhbWUgcmVnYXJkbGVzcyBvZiB3aW5kb3cgc2l6ZSBvciBuYXRpdmUgYnJvd3NlciB6b29tLlxuICB0YXJnZXRTY2FsZT86IG51bWJlcjtcbn07XG5leHBvcnQgdHlwZSBQYW5ab29tTGlzdGVuZXJPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBNdWx0aUxpc3RlbmVyT3B0aW9ucztcblxuY2xhc3MgUGFuWm9vbUxpc3RlbmVyIGV4dGVuZHMgTXVsdGlMaXN0ZW5lciB7XG5cbiAgcHJvdGVjdGVkIF9wYW5Cb3VuZHM6IEJvdW5kczI7XG4gIHByb3RlY3RlZCBfdGFyZ2V0Qm91bmRzOiBCb3VuZHMyO1xuICBwcm90ZWN0ZWQgX3RhcmdldFNjYWxlOiBudW1iZXI7XG5cbiAgLy8gT25seSBuZWVkZWQgZm9yIFBoRVQtaU8gaW5zdHJ1bWVudGVkLiBUaGUgcGFuIGJvdW5kcyBvZiB0aGUgc291cmNlIHNvIGlmIHRoZSBkZXN0aW5hdGlvbiBib3VuZHMgYXJlIGRpZmZlcmVudCBkdWVcbiAgLy8gdG8gYSBkaWZmZXJlbnRseSBzaXplZCBpZnJhbWUgb3Igd2luZG93LCB0aGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhIGNvcnJlY3Rpb24gZm9yIHRoZSBkZXN0aW5hdGlvblxuICAvLyB0YXJnZXROb2RlIHRyYW5zZm9ybS4gVGhpcyBjb3VsZCBiZSByZW1vdmVkIGJ5IHdvcmsgcmVjb21tZW5kZWQgaW5cbiAgcHJvdGVjdGVkIHNvdXJjZUZyYW1lUGFuQm91bmRzUHJvcGVydHk6IFByb3BlcnR5PEJvdW5kczI+O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSBOb2RlIHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIGJ5IHRoaXMgUGFuWm9vbUxpc3RlbmVyLlxuICAgKiBAcGFyYW0gW3Byb3ZpZGVkT3B0aW9uc10uXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoIHRhcmdldE5vZGU6IE5vZGUsIHByb3ZpZGVkT3B0aW9ucz86IFBhblpvb21MaXN0ZW5lck9wdGlvbnMgKSB7XG5cbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFBhblpvb21MaXN0ZW5lck9wdGlvbnMsIFNlbGZPcHRpb25zLCBQYW5ab29tTGlzdGVuZXJPcHRpb25zPigpKCB7XG4gICAgICBwYW5Cb3VuZHM6IEJvdW5kczIuTk9USElORyxcbiAgICAgIHRhcmdldEJvdW5kczogbnVsbCxcbiAgICAgIHRhcmdldFNjYWxlOiAxLFxuXG4gICAgICAvLyBieSBkZWZhdWx0LCB0aGUgUGFuWm9vbUxpc3RlbmVyIGRvZXMgbm93IGFsbG93IHJvdGF0aW9uXG4gICAgICBhbGxvd1JvdGF0aW9uOiBmYWxzZVxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xuXG4gICAgc3VwZXIoIHRhcmdldE5vZGUsIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuX3BhbkJvdW5kcyA9IG9wdGlvbnMucGFuQm91bmRzO1xuICAgIHRoaXMuX3RhcmdldEJvdW5kcyA9IG9wdGlvbnMudGFyZ2V0Qm91bmRzIHx8IHRhcmdldE5vZGUuZ2xvYmFsQm91bmRzLmNvcHkoKTtcbiAgICB0aGlzLl90YXJnZXRTY2FsZSA9IG9wdGlvbnMudGFyZ2V0U2NhbGU7XG5cbiAgICB0aGlzLnNvdXJjZUZyYW1lUGFuQm91bmRzUHJvcGVydHkgPSBuZXcgUHJvcGVydHkoIHRoaXMuX3BhbkJvdW5kcywge1xuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbT8uY3JlYXRlVGFuZGVtKCAnc291cmNlRnJhbWVQYW5Cb3VuZHNQcm9wZXJ0eScgKSxcbiAgICAgIHBoZXRpb1JlYWRPbmx5OiB0cnVlLFxuICAgICAgcGhldGlvVmFsdWVUeXBlOiBCb3VuZHMyLkJvdW5kczJJT1xuICAgIH0gKTtcblxuICAgIHRoaXMuc291cmNlRnJhbWVQYW5Cb3VuZHNQcm9wZXJ0eS5sYXp5TGluayggKCkgPT4ge1xuICAgICAgaWYgKCBpc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5LnZhbHVlICkge1xuXG4gICAgICAgIC8vIFRoZSBtYXRyaXhQcm9wZXJ0eSBoYXMgdHJhbnNmb3JtYXRpb25zIHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgdmlldyBjb29yZGluYXRlcyBvZiB0aGUgc291cmNlIHNpbXVsYXRpb24sXG4gICAgICAgIC8vIHNvIGl0IHdpbGwgbm90IGJlIGNvcnJlY3QgaWYgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBmcmFtZXMgYXJlIGRpZmZlcmVudCBzaXplcy4gVGhpcyB3aWxsIG1hcCB0cmFuc2ZvcmFtdGlvbnNcbiAgICAgICAgLy8gaWYgZGVzdGluYXRpb24gZnJhbWUgaGFzIGRpZmZlcmVudCBzaXplLlxuICAgICAgICBjb25zdCBzb3VyY2VEZXN0aW5hdGlvblRyYW5zZm9ybSA9IE1vZGVsVmlld1RyYW5zZm9ybTIuY3JlYXRlUmVjdGFuZ2xlTWFwcGluZyggdGhpcy5zb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5LmdldCgpLCB0aGlzLl9wYW5Cb3VuZHMgKTtcblxuICAgICAgICBjb25zdCBuZXdUcmFuc2xhdGlvbiA9IHRoaXMuX3RhcmdldE5vZGUubWF0cml4LnRyYW5zbGF0aW9uLmNvbXBvbmVudE11bHRpcGx5KCBzb3VyY2VEZXN0aW5hdGlvblRyYW5zZm9ybS5tYXRyaXguZ2V0U2NhbGVWZWN0b3IoKSApO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMubWF0cml4UHJvcGVydHkuZ2V0KCkuZ2V0U2NhbGVWZWN0b3IoKTtcbiAgICAgICAgdGhpcy5tYXRyaXhQcm9wZXJ0eS5zZXQoIE1hdHJpeDMudHJhbnNsYXRpb25Gcm9tVmVjdG9yKCBuZXdUcmFuc2xhdGlvbiApLnRpbWVzTWF0cml4KCBNYXRyaXgzLnNjYWxpbmcoIHNjYWxlLngsIHNjYWxlLnkgKSApICk7XG4gICAgICB9XG4gICAgfSwge1xuXG4gICAgICAvLyBzbyB0aGF0IHRoZSBsaXN0ZW5lciB3aWxsIGJlIGNhbGxlZCBvbmx5IGFmdGVyIHRoZSBtYXRyaXhQcm9wZXJ0eSBpcyB1cCB0byBkYXRlIGluIHRoZSBkb3duc3RyZWFtIHNpbVxuICAgICAgcGhldGlvRGVwZW5kZW5jaWVzOiBbIHRoaXMubWF0cml4UHJvcGVydHkgXVxuICAgIH0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgdGFyZ2V0Tm9kZSBpcyBsYXJnZXIgdGhhbiB0aGUgcGFuQm91bmRzIHNwZWNpZmllZCwga2VlcCB0aGUgcGFuQm91bmRzIGNvbXBsZXRlbHkgZmlsbGVkIHdpdGhcbiAgICogdGFyZ2V0Tm9kZSBjb250ZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvcnJlY3RSZXBvc2l0aW9uKCk6IHZvaWQge1xuXG4gICAgLy8gU2F2ZSB2YWx1ZXMgb2YgdGhlIGN1cnJlbnQgbWF0cml4LCBzbyB0aGF0IHdlIG9ubHkgZG8gY2VydGFpbiB3b3JrIHdoZW4gdGhlIG1hdHJpeCBhY3R1YWxseSBjaGFuZ2VzXG4gICAgU0NSQVRDSF9NQVRSSVguc2V0KCB0aGlzLl90YXJnZXROb2RlLm1hdHJpeCApO1xuXG4gICAgLy8gdGhlIHRhcmdldEJvdW5kcyB0cmFuc2Zvcm1lZCBieSB0aGUgdGFyZ2V0Tm9kZSdzIHRyYW5zZm9ybSwgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldEJvdW5kcyBhcmUgb3V0IG9mIHBhbkJvdW5kc1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQm91bmRzID0gdGhpcy5fdGFyZ2V0Qm91bmRzLnRyYW5zZm9ybWVkKCB0aGlzLl90YXJnZXROb2RlLmdldE1hdHJpeCgpICk7XG5cbiAgICAvLyBEb24ndCBsZXQgcGFubmluZyBnbyB0aHJvdWdoIGlmIHRoZSBub2RlIGlzIGZ1bGx5IGNvbnRhaW5lZCBieSB0aGUgcGFuQm91bmRzXG4gICAgaWYgKCB0cmFuc2Zvcm1lZEJvdW5kcy5sZWZ0ID4gdGhpcy5fcGFuQm91bmRzLmxlZnQgKSB7XG4gICAgICB0aGlzLl90YXJnZXROb2RlLmxlZnQgPSB0aGlzLl9wYW5Cb3VuZHMubGVmdCAtICggdHJhbnNmb3JtZWRCb3VuZHMubGVmdCAtIHRoaXMuX3RhcmdldE5vZGUubGVmdCApO1xuICAgIH1cbiAgICBpZiAoIHRyYW5zZm9ybWVkQm91bmRzLnRvcCA+IHRoaXMuX3BhbkJvdW5kcy50b3AgKSB7XG4gICAgICB0aGlzLl90YXJnZXROb2RlLnRvcCA9IHRoaXMuX3BhbkJvdW5kcy50b3AgLSAoIHRyYW5zZm9ybWVkQm91bmRzLnRvcCAtIHRoaXMuX3RhcmdldE5vZGUudG9wICk7XG4gICAgfVxuICAgIGlmICggdHJhbnNmb3JtZWRCb3VuZHMucmlnaHQgPCB0aGlzLl9wYW5Cb3VuZHMucmlnaHQgKSB7XG4gICAgICB0aGlzLl90YXJnZXROb2RlLnJpZ2h0ID0gdGhpcy5fcGFuQm91bmRzLnJpZ2h0ICsgKCB0aGlzLl90YXJnZXROb2RlLnJpZ2h0IC0gdHJhbnNmb3JtZWRCb3VuZHMucmlnaHQgKTtcbiAgICB9XG4gICAgaWYgKCB0cmFuc2Zvcm1lZEJvdW5kcy5ib3R0b20gPCB0aGlzLl9wYW5Cb3VuZHMuYm90dG9tICkge1xuICAgICAgdGhpcy5fdGFyZ2V0Tm9kZS5ib3R0b20gPSB0aGlzLl9wYW5Cb3VuZHMuYm90dG9tICsgKCB0aGlzLl90YXJnZXROb2RlLmJvdHRvbSAtIHRyYW5zZm9ybWVkQm91bmRzLmJvdHRvbSApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQcm9wZXJ0eSB3aXRoIG1hdHJpeCBvbmNlIHBvc2l0aW9uIGhhcyBiZWVuIGNvcnJlY3RlZCB0byBub3RpZnkgbGlzdGVuZXJzIGFuZCBzZXQgUGhFVC1pTyBzdGF0ZSwgYnV0XG4gICAgLy8gb25seSBub3RpZnkgd2hlbiB0aGVyZSBoYXMgYmVlbiBhbiBhY3R1YWwgY2hhbmdlLlxuICAgIGlmICggIVNDUkFUQ0hfTUFUUklYLmVxdWFscyggdGhpcy5fdGFyZ2V0Tm9kZS5tYXRyaXggKSApIHtcbiAgICAgIHRoaXMubWF0cml4UHJvcGVydHkuc2V0KCB0aGlzLl90YXJnZXROb2RlLm1hdHJpeC5jb3B5KCkgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHRyYW5zZm9ybWVkIHRhcmdldEJvdW5kcyBhcmUgZXF1YWwgdG8gdGhlIHBhbkJvdW5kcywgdGhlcmUgaXMgbm8gc3BhY2UgZm9yIHVzIHRvIHBhbiBzbyBkbyBub3QgY2hhbmdlXG4gICAqIHRoZSBwb2ludGVyIGN1cnNvci5cbiAgICovXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhZGRQcmVzcyggcHJlc3M6IE11bHRpTGlzdGVuZXJQcmVzcyApOiB2b2lkIHtcbiAgICBzdXBlci5hZGRQcmVzcyggcHJlc3MgKTtcblxuICAgIC8vIGRvbid0IHNob3cgdGhlIHByZXNzQ3Vyc29yIGlmIG91ciBib3VuZHMgYXJlIGxpbWl0ZWQgYnkgcGFuIGJvdW5kcywgYW5kIHdlIGNhbm5vdCBwYW4gYW55d2hlcmVcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJvdW5kcyA9IHRoaXMuX3RhcmdldEJvdW5kcy50cmFuc2Zvcm1lZCggdGhpcy5fdGFyZ2V0Tm9kZS5nZXRNYXRyaXgoKSApO1xuICAgIGNvbnN0IGJvdW5kc0xpbWl0ZWQgPSB0cmFuc2Zvcm1lZEJvdW5kcy5lcXVhbHNFcHNpbG9uKCB0aGlzLl9wYW5Cb3VuZHMsIDFFLTggKTtcbiAgICBwcmVzcy5wb2ludGVyLmN1cnNvciA9IGJvdW5kc0xpbWl0ZWQgPyBudWxsIDogdGhpcy5fcHJlc3NDdXJzb3I7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3NpdGlvbiBidXQga2VlcCBjb250ZW50IHdpdGhpbiB0aGlzLl9wYW5Cb3VuZHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgcmVwb3NpdGlvbigpOiB2b2lkIHtcbiAgICBzdXBlci5yZXBvc2l0aW9uKCk7XG4gICAgdGhpcy5jb3JyZWN0UmVwb3NpdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0cmFuc2Zvcm0gb24gdGhlIHRhcmdldE5vZGUgYW5kIGZvbGxvdyB1cCBieSBtYWtpbmcgc3VyZSB0aGF0IHRoZSBjb250ZW50IGlzIHN0aWxsIHdpdGhpbiBwYW5Cb3VuZHMuXG4gICAqL1xuICBwdWJsaWMgb3ZlcnJpZGUgcmVzZXRUcmFuc2Zvcm0oKTogdm9pZCB7XG4gICAgc3VwZXIucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmNvcnJlY3RSZXBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb250YWluaW5nIHBhbkJvdW5kcyBhbmQgdGhlbiBtYWtlIHN1cmUgdGhhdCB0aGUgdGFyZ2V0Qm91bmRzIGZ1bGx5IGZpbGwgdGhlIG5ldyBwYW5Cb3VuZHMuXG4gICAqL1xuICBwdWJsaWMgc2V0UGFuQm91bmRzKCBwYW5Cb3VuZHM6IEJvdW5kczIgKTogdm9pZCB7XG4gICAgdGhpcy5fcGFuQm91bmRzID0gcGFuQm91bmRzO1xuXG4gICAgdGhpcy5zb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5LnNldCggdGhpcy5fcGFuQm91bmRzICk7XG4gICAgdGhpcy5jb3JyZWN0UmVwb3NpdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGFyZ2V0Qm91bmRzIHdoaWNoIHNob3VsZCB0b3RhbGx5IGZpbGwgdGhlIHBhbkJvdW5kcyBhdCBhbGwgdGltZXMuIFVzZWZ1bCBpZiB0aGUgdGFyZ2V0Tm9kZSBoYXMgYm91bmRzXG4gICAqIHdoaWNoIGRvbid0IGFjY3VyYXRlbHkgZGVzY3JpYmUgdGhlIG5vZGUuIEZvciBpbnN0YW5jZSwgaWYgYW4gb3ZlcmxheSBwbGFuZSBpcyBvbiB0b3Agb2YgdGhlIG5vZGUgYW5kIGV4dGVuZHNcbiAgICogYmV5b25kIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB2aXNpYmxlIG5vZGUuXG4gICAqXG4gICAqIHRhcmdldEJvdW5kcyAtIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZVxuICAgKi9cbiAgcHVibGljIHNldFRhcmdldEJvdW5kcyggdGFyZ2V0Qm91bmRzOiBCb3VuZHMyICk6IHZvaWQge1xuICAgIHRoaXMuX3RhcmdldEJvdW5kcyA9IHRhcmdldEJvdW5kcztcbiAgICB0aGlzLmNvcnJlY3RSZXBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXByZXNlbnRhdGl2ZSBzY2FsZSBvZiB0aGUgdGFyZ2V0IE5vZGUuIElmIHRoZSB0YXJnZXRCb3VuZHMgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXROb2RlLmJvdW5kc1xuICAgKiBpdCBtYXkgYmUgdXNlZnVsIHRvIGNvcnJlY3QgY2hhbmdlcyB0byBwYW5uaW5nIGFuZCB6b29taW5nIGJ5IGEgc2NhbGUgdGhhdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICogYWN0dWFsIHNjYWxlIGFwcGxpZWQgdG8gdGhlIHRhcmdldE5vZGUgZHVyaW5nIHBhbm5pbmcuXG4gICAqL1xuICBwdWJsaWMgc2V0VGFyZ2V0U2NhbGUoIHNjYWxlOiBudW1iZXIgKTogdm9pZCB7XG4gICAgdGhpcy5fdGFyZ2V0U2NhbGUgPSBzY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhcmdldEJvdW5kcywgaW4gdGhlIGdsb2JhbCBjb29yZGluYXRlIGZyYW1lLlxuICAgKi9cbiAgcHVibGljIGdldFRhcmdldEJvdW5kcygpOiBCb3VuZHMyIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0Qm91bmRzO1xuICB9XG59XG5cbnNjZW5lcnkucmVnaXN0ZXIoICdQYW5ab29tTGlzdGVuZXInLCBQYW5ab29tTGlzdGVuZXIgKTtcbmV4cG9ydCBkZWZhdWx0IFBhblpvb21MaXN0ZW5lcjsiXSwibmFtZXMiOlsiUHJvcGVydHkiLCJCb3VuZHMyIiwiTWF0cml4MyIsIm9wdGlvbml6ZSIsIk1vZGVsVmlld1RyYW5zZm9ybTIiLCJpc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5IiwiTXVsdGlMaXN0ZW5lciIsInNjZW5lcnkiLCJTQ1JBVENIX01BVFJJWCIsIlBhblpvb21MaXN0ZW5lciIsImNvcnJlY3RSZXBvc2l0aW9uIiwic2V0IiwiX3RhcmdldE5vZGUiLCJtYXRyaXgiLCJ0cmFuc2Zvcm1lZEJvdW5kcyIsIl90YXJnZXRCb3VuZHMiLCJ0cmFuc2Zvcm1lZCIsImdldE1hdHJpeCIsImxlZnQiLCJfcGFuQm91bmRzIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJlcXVhbHMiLCJtYXRyaXhQcm9wZXJ0eSIsImNvcHkiLCJhZGRQcmVzcyIsInByZXNzIiwiYm91bmRzTGltaXRlZCIsImVxdWFsc0Vwc2lsb24iLCJwb2ludGVyIiwiY3Vyc29yIiwiX3ByZXNzQ3Vyc29yIiwicmVwb3NpdGlvbiIsInJlc2V0VHJhbnNmb3JtIiwic2V0UGFuQm91bmRzIiwicGFuQm91bmRzIiwic291cmNlRnJhbWVQYW5Cb3VuZHNQcm9wZXJ0eSIsInNldFRhcmdldEJvdW5kcyIsInRhcmdldEJvdW5kcyIsInNldFRhcmdldFNjYWxlIiwic2NhbGUiLCJfdGFyZ2V0U2NhbGUiLCJnZXRUYXJnZXRCb3VuZHMiLCJ0YXJnZXROb2RlIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsIk5PVEhJTkciLCJ0YXJnZXRTY2FsZSIsImFsbG93Um90YXRpb24iLCJnbG9iYWxCb3VuZHMiLCJ0YW5kZW0iLCJjcmVhdGVUYW5kZW0iLCJwaGV0aW9SZWFkT25seSIsInBoZXRpb1ZhbHVlVHlwZSIsIkJvdW5kczJJTyIsImxhenlMaW5rIiwidmFsdWUiLCJzb3VyY2VEZXN0aW5hdGlvblRyYW5zZm9ybSIsImNyZWF0ZVJlY3RhbmdsZU1hcHBpbmciLCJnZXQiLCJuZXdUcmFuc2xhdGlvbiIsInRyYW5zbGF0aW9uIiwiY29tcG9uZW50TXVsdGlwbHkiLCJnZXRTY2FsZVZlY3RvciIsInRyYW5zbGF0aW9uRnJvbVZlY3RvciIsInRpbWVzTWF0cml4Iiwic2NhbGluZyIsIngiLCJ5IiwicGhldGlvRGVwZW5kZW5jaWVzIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7O0NBTUMsR0FFRCxPQUFPQSxjQUFjLCtCQUErQjtBQUNwRCxPQUFPQyxhQUFhLDZCQUE2QjtBQUNqRCxPQUFPQyxhQUFhLDZCQUE2QjtBQUNqRCxPQUFPQyxlQUFlLHFDQUFxQztBQUMzRCxPQUFPQyx5QkFBeUIscURBQXFEO0FBQ3JGLE9BQU9DLGtDQUFrQyxxREFBcUQ7QUFDOUYsU0FBU0MsYUFBYSxFQUFrREMsT0FBTyxRQUFRLGdCQUFnQjtBQUV2RyxZQUFZO0FBQ1osMkRBQTJEO0FBQzNELE1BQU1DLGlCQUFpQixJQUFJTjtBQXNCM0IsSUFBQSxBQUFNTyxrQkFBTixNQUFNQSx3QkFBd0JIO0lBeUQ1Qjs7O0dBR0MsR0FDRCxBQUFVSSxvQkFBMEI7UUFFbEMsc0dBQXNHO1FBQ3RHRixlQUFlRyxHQUFHLENBQUUsSUFBSSxDQUFDQyxXQUFXLENBQUNDLE1BQU07UUFFM0MsZ0hBQWdIO1FBQ2hILE1BQU1DLG9CQUFvQixJQUFJLENBQUNDLGFBQWEsQ0FBQ0MsV0FBVyxDQUFFLElBQUksQ0FBQ0osV0FBVyxDQUFDSyxTQUFTO1FBRXBGLCtFQUErRTtRQUMvRSxJQUFLSCxrQkFBa0JJLElBQUksR0FBRyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0QsSUFBSSxFQUFHO1lBQ25ELElBQUksQ0FBQ04sV0FBVyxDQUFDTSxJQUFJLEdBQUcsSUFBSSxDQUFDQyxVQUFVLENBQUNELElBQUksR0FBS0osQ0FBQUEsa0JBQWtCSSxJQUFJLEdBQUcsSUFBSSxDQUFDTixXQUFXLENBQUNNLElBQUksQUFBRDtRQUNoRztRQUNBLElBQUtKLGtCQUFrQk0sR0FBRyxHQUFHLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxHQUFHLEVBQUc7WUFDakQsSUFBSSxDQUFDUixXQUFXLENBQUNRLEdBQUcsR0FBRyxJQUFJLENBQUNELFVBQVUsQ0FBQ0MsR0FBRyxH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