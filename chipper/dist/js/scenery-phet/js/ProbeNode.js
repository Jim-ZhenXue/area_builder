// Copyright 2015-2024, University of Colorado Boulder
/**
 * ProbeNode is a physical-looking probe with a handle and a circular sensor region. It is used in simulations like
 * Bending Light and Beer's Law Lab to show how much light is being received. It is typically connected to a body
 * with readouts via a wire. The origin is in the center of the sensor.
 *
 * This code was generalized from Bending Light, see https://github.com/phetsims/bending-light/issues/165
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chandrashekar Bemagoni (Actual Concepts)
 * @author Chris Malley (PixelZoom, Inc.)
 */ import DerivedProperty from '../../axon/js/DerivedProperty.js';
import Ray2 from '../../dot/js/Ray2.js';
import Vector2 from '../../dot/js/Vector2.js';
import { EllipticalArc, Shape } from '../../kite/js/imports.js';
import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import optionize, { optionize3 } from '../../phet-core/js/optionize.js';
import { Circle, Line, LinearGradient, Node, PaintColorProperty, Path, RadialGradient } from '../../scenery/js/imports.js';
import sceneryPhet from './sceneryPhet.js';
const DEFAULT_OPTIONS = {
    radius: 50,
    innerRadius: 35,
    handleWidth: 50,
    handleHeight: 30,
    handleCornerRadius: 10,
    lightAngle: 1.35 * Math.PI,
    color: '#008541',
    sensorTypeFunction: glass()
};
assert && Object.freeze(DEFAULT_OPTIONS);
let ProbeNode = class ProbeNode extends Node {
    dispose() {
        this.brighter5Property.dispose();
        this.brighter4Property.dispose();
        this.brighter3Property.dispose();
        this.brighter2Property.dispose();
        this.darker2Property.dispose();
        this.darker3Property.dispose();
        super.dispose();
    }
    constructor(providedOptions){
        var _window_phet_chipper_queryParameters, _window_phet_chipper, _window_phet;
        const options = optionize3()({}, DEFAULT_OPTIONS, providedOptions);
        super();
        // To improve readability
        const radius = options.radius;
        // y coordinate of the bottom of the handle, relative to the origin (center of the sensor)
        const handleBottom = radius + options.handleHeight;
        // Constants that determine the outer Shape of the probe
        const arcExtent = 0.8;
        const handleWidth = options.handleWidth;
        const innerRadius = Math.min(options.innerRadius, options.radius);
        const cornerRadius = options.handleCornerRadius;
        const neckCornerRadius = 10;
        // We must know where the elliptical arc begins, so create an explicit EllipticalArc for that
        // Note: This elliptical arc must match the ellipticalArc call below
        const ellipticalArcStart = new EllipticalArc(new Vector2(0, 0), radius, radius, 0, Math.PI * arcExtent, Math.PI * (1 - arcExtent), false).start;
        // Creates the Shape for the outside edge of the probe, circular at top with handle at the bottom.
        function createOuterProbeShape() {
            return new Shape()// start in the bottom center
            .moveTo(0, handleBottom)// Kite Shape automatically lineTo's to the first point of an arc, so no need to lineTo ourselves
            .arc(-handleWidth / 2 + cornerRadius, handleBottom - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false).lineTo(-handleWidth / 2, radius + neckCornerRadius).quadraticCurveTo(-handleWidth / 2, radius, ellipticalArcStart.x, ellipticalArcStart.y)// Top arc
            // Note: his elliptical arc must match the EllipticalArc above
            .ellipticalArc(0, 0, radius, radius, 0, Math.PI * arcExtent, Math.PI * (1 - arcExtent), false).quadraticCurveTo(handleWidth / 2, radius, +handleWidth / 2, radius + neckCornerRadius).arc(handleWidth / 2 - cornerRadius, handleBottom - cornerRadius, cornerRadius, 0, Math.PI / 2, false).close();
        }
        // Start with the outer Shape of the probe, and cut out the sensor area.
        const probeShape = createOuterProbeShape().moveTo(innerRadius, 0).arc(0, 0, innerRadius, Math.PI * 2, 0, true).close();
        // The light angle is variable so that you can create a probe node that is pointing up or to the side
        const lightAngle = options.lightAngle;
        const center = probeShape.bounds.center;
        const v1 = Vector2.createPolar(1, lightAngle);
        const intersections = probeShape.intersection(new Ray2(center, v1));
        // take last intersection or zero point, see https://github.com/phetsims/scenery-phet/issues/294
        const lastIntersection = intersections[intersections.length - 1];
        const lastIntersectionPoint = lastIntersection ? lastIntersection.point : Vector2.ZERO;
        const gradientSource = lastIntersectionPoint.plus(v1.timesScalar(1));
        const v2 = Vector2.createPolar(1, lightAngle + Math.PI);
        const intersections2 = probeShape.intersection(new Ray2(center, v2));
        // take last intersection or zero point, see https://github.com/phetsims/scenery-phet/issues/294
        const lastIntersection2 = intersections2[intersections2.length - 1];
        const lastIntersectionPoint2 = lastIntersection2 ? lastIntersection2.point : Vector2.ZERO;
        const gradientDestination = lastIntersectionPoint2.plus(v2.timesScalar(1));
        this.brighter5Property = new PaintColorProperty(options.color, {
            luminanceFactor: 0.5
        });
        this.brighter4Property = new PaintColorProperty(options.color, {
            luminanceFactor: 0.4
        });
        this.brighter3Property = new PaintColorProperty(options.color, {
            luminanceFactor: 0.3
        });
        this.brighter2Property = new PaintColorProperty(options.color, {
            luminanceFactor: 0.2
        });
        this.darker2Property = new PaintColorProperty(options.color, {
            luminanceFactor: -0.2
        });
        this.darker3Property = new PaintColorProperty(options.color, {
            luminanceFactor: -0.3
        });
        // The main path of the probe
        const mainPath = new Path(probeShape, {
            stroke: new LinearGradient(gradientSource.x, gradientSource.y, gradientDestination.x, gradientDestination.y).addColorStop(0.0, this.brighter2Property) // highlight
            .addColorStop(1.0, this.darker2Property),
            fill: new LinearGradient(gradientSource.x, gradientSource.y, gradientDestination.x, gradientDestination.y).addColorStop(0.0, this.brighter5Property) // highlight
            .addColorStop(0.03, this.brighter4Property).addColorStop(0.07, this.brighter4Property).addColorStop(0.11, this.brighter2Property).addColorStop(0.3, options.color).addColorStop(0.8, this.darker2Property) // shadows
            .addColorStop(1.0, this.darker3Property),
            lineWidth: 2
        });
        // The front flat "surface" of the probe, makes it look 3d by giving the probe a beveled appearance and putting
        // a shiny glare on the top edge.
        const frontPath = new Path(probeShape, {
            fill: options.color,
            // y scale is an empirical function of handle height, to keep bevel at bottom of handle from changing size
            scale: new Vector2(0.9, 0.93 + 0.01 * options.handleHeight / DEFAULT_OPTIONS.handleHeight),
            centerX: mainPath.centerX,
            stroke: new DerivedProperty([
                this.brighter3Property
            ], (color)=>{
                return color.withAlpha(0.5);
            }),
            lineWidth: 1.2,
            y: 2 // Shift it down a bit to make the face look a bit more 3d
        });
        const children = [];
        if (options.sensorTypeFunction) {
            children.push(options.sensorTypeFunction(radius));
        }
        children.push(mainPath, frontPath);
        // Allow the client to add child nodes
        options.children = children.concat(options.children || []);
        // Allow the client to override mouse and touch area, but fall back to the outline
        const outline = createOuterProbeShape();
        options.mouseArea = options.mouseArea || outline;
        options.touchArea = options.touchArea || outline;
        this.mutate(options);
        // support for binder documentation, stripped out in builds and only runs when ?binder is specified
        assert && ((_window_phet = window.phet) == null ? void 0 : (_window_phet_chipper = _window_phet.chipper) == null ? void 0 : (_window_phet_chipper_queryParameters = _window_phet_chipper.queryParameters) == null ? void 0 : _window_phet_chipper_queryParameters.binder) && InstanceRegistry.registerDataURL('scenery-phet', 'ProbeNode', this);
    }
};
ProbeNode.DEFAULT_PROBE_NODE_OPTIONS = DEFAULT_OPTIONS;
ProbeNode.glass = glass;
ProbeNode.crosshairs = crosshairs;
export { ProbeNode as default };
/**
 * Creates a value for options.sensorTypeFunction. Shows a shiny reflective interior in the sensor area.
 */ function glass(providedOptions) {
    const options = optionize()({
        centerColor: 'white',
        middleColor: '#E6F5FF',
        edgeColor: '#C2E7FF' // slightly darker blue, like glass
    }, providedOptions);
    return (radius)=>{
        return new Circle(radius, {
            fill: new RadialGradient(-radius * 0.15, -radius * 0.15, 0, -radius * 0.15, -radius * 0.20, radius * 0.60).addColorStop(0, options.centerColor).addColorStop(0.4, options.middleColor).addColorStop(1, options.edgeColor)
        });
    };
}
/**
 * Creates a value for options.sensorTypeFunction. Shows a crosshairs in the sensor area.
 */ function crosshairs(providedOptions) {
    const options = optionize()({
        stroke: 'black',
        lineWidth: 3,
        intersectionRadius: 8
    }, providedOptions);
    return (radius)=>{
        const lineOptions = {
            stroke: options.stroke,
            lineWidth: options.lineWidth
        };
        return new Node({
            children: [
                new Line(-radius, 0, -options.intersectionRadius, 0, lineOptions),
                new Line(+radius, 0, +options.intersectionRadius, 0, lineOptions),
                new Line(0, -radius, 0, -options.intersectionRadius, lineOptions),
                new Line(0, +radius, 0, +options.intersectionRadius, lineOptions)
            ]
        });
    };
}
sceneryPhet.register('ProbeNode', ProbeNode);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9Qcm9iZU5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogUHJvYmVOb2RlIGlzIGEgcGh5c2ljYWwtbG9va2luZyBwcm9iZSB3aXRoIGEgaGFuZGxlIGFuZCBhIGNpcmN1bGFyIHNlbnNvciByZWdpb24uIEl0IGlzIHVzZWQgaW4gc2ltdWxhdGlvbnMgbGlrZVxuICogQmVuZGluZyBMaWdodCBhbmQgQmVlcidzIExhdyBMYWIgdG8gc2hvdyBob3cgbXVjaCBsaWdodCBpcyBiZWluZyByZWNlaXZlZC4gSXQgaXMgdHlwaWNhbGx5IGNvbm5lY3RlZCB0byBhIGJvZHlcbiAqIHdpdGggcmVhZG91dHMgdmlhIGEgd2lyZS4gVGhlIG9yaWdpbiBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBzZW5zb3IuXG4gKlxuICogVGhpcyBjb2RlIHdhcyBnZW5lcmFsaXplZCBmcm9tIEJlbmRpbmcgTGlnaHQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvYmVuZGluZy1saWdodC9pc3N1ZXMvMTY1XG4gKlxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcbiAqIEBhdXRob3IgQ2hhbmRyYXNoZWthciBCZW1hZ29uaSAoQWN0dWFsIENvbmNlcHRzKVxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcbiAqL1xuXG5pbXBvcnQgRGVyaXZlZFByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvRGVyaXZlZFByb3BlcnR5LmpzJztcbmltcG9ydCBSYXkyIGZyb20gJy4uLy4uL2RvdC9qcy9SYXkyLmpzJztcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcbmltcG9ydCB7IEVsbGlwdGljYWxBcmMsIFNoYXBlIH0gZnJvbSAnLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcbmltcG9ydCBJbnN0YW5jZVJlZ2lzdHJ5IGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9kb2N1bWVudGF0aW9uL0luc3RhbmNlUmVnaXN0cnkuanMnO1xuaW1wb3J0IG9wdGlvbml6ZSwgeyBFbXB0eVNlbGZPcHRpb25zLCBvcHRpb25pemUzIH0gZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XG5pbXBvcnQgeyBDaXJjbGUsIExpbmUsIExpbmVhckdyYWRpZW50LCBOb2RlLCBOb2RlT3B0aW9ucywgUGFpbnRDb2xvclByb3BlcnR5LCBQYXRoLCBSYWRpYWxHcmFkaWVudCwgVENvbG9yIH0gZnJvbSAnLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcbmltcG9ydCBzY2VuZXJ5UGhldCBmcm9tICcuL3NjZW5lcnlQaGV0LmpzJztcblxuLy8gb3B0aW9ucyBmb3IgUHJvYmVOb2RlLmdsYXNzXG50eXBlIEdsYXNzT3B0aW9ucyA9IHtcbiAgY2VudGVyQ29sb3I/OiBUQ29sb3I7XG4gIG1pZGRsZUNvbG9yPzogVENvbG9yO1xuICBlZGdlQ29sb3I/OiBUQ29sb3I7XG59O1xuXG4vLyBvcHRpb25zIGZvciBQcm9iZU5vZGUuY3Jvc3NoYWlyc1xudHlwZSBDcm9zc2hhaXJzT3B0aW9ucyA9IHtcbiAgc3Ryb2tlPzogVENvbG9yO1xuICBsaW5lV2lkdGg/OiBudW1iZXI7XG4gIGludGVyc2VjdGlvblJhZGl1cz86IG51bWJlcjsgLy8gVGhlIGFtb3VudCBvZiBibGFuayBzcGFjZSB2aXNpYmxlIGF0IHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIDIgY3Jvc3NoYWlycyBsaW5lc1xufTtcblxuLy8gdHlwZSBvZiBTZWxmT3B0aW9ucy5zZW5zb3JUeXBlRnVuY3Rpb25cbnR5cGUgU2Vuc29yVHlwZUZ1bmN0aW9uID0gKCByYWRpdXM6IG51bWJlciApID0+IE5vZGU7XG5cbi8vIG9wdGlvbnMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gUHJvYmVOb2RlXG50eXBlIFNlbGZPcHRpb25zID0ge1xuICByYWRpdXM/OiBudW1iZXI7XG4gIGlubmVyUmFkaXVzPzogbnVtYmVyO1xuICBoYW5kbGVXaWR0aD86IG51bWJlcjtcbiAgaGFuZGxlSGVpZ2h0PzogbnVtYmVyO1xuICBoYW5kbGVDb3JuZXJSYWRpdXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGluIHJhZGlhbnMsIHRoZSBhbmdsZSBvZiB0aGUgaW5jb21pbmcgbGlnaHQuICAwIGlzIGZyb20gdGhlIHJpZ2h0LCBQSS8yIGZyb20gdGhlIGJvdHRvbSwgUEkgZnJvbSB0aGUgbGVmdCwgZXRjLlxuICAgKiBUaGUgZGVmYXVsdCBpcyBmcm9tIHRoZSB1cHBlci1sZWZ0LiAgR2VuZXJhbGx5LCBpdCBpcyBkaWZmaWN1bHQgdG8ga25vdyB0aGUgZ2xvYmFsIHJvdGF0aW9uIG9mIHRoZSBQcm9iZU5vZGVcbiAgICogYW5kIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRoZSBsaWdodEFuZ2xlIHdoZW4gdGhlIGdsb2JhbCByb3RhdGlvbiBjaGFuZ2VzLCBzbyB0aGlzIGlzIHVwIHRvIHRoZSBkZXZlbG9wZXJcbiAgICogdG8gc2V0IHByb3Blcmx5LiAgVGhlIGxpZ2h0IGluIFBoRVQgc2ltdWxhdGlvbnMgb2Z0ZW4gY29tZXMgZnJvbSB0aGUgdG9wLWxlZnQsIHNvIHBsZWFzZSBzZXQgdGhpcyB2YWx1ZVxuICAgKiBhY2NvcmRpbmdseSBkZXBlbmRpbmcgb24gdGhlIGNvbnRleHQgb2YgaG93IHRoZSBwcm9iZSBpcyBlbWJlZGRlZCBpbiB0aGUgc2ltdWxhdGlvbi5cbiAgICovXG4gIGxpZ2h0QW5nbGU/OiBudW1iZXI7XG4gIGNvbG9yPzogVENvbG9yO1xuXG4gIC8vIERldGVybWluZXMgd2hhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIHNlbnNvciBhcmVhLCB0aGUgY2lyY3VsYXIgY3V0LW91dCBwYXJ0IG9mIHRoZSBQcm9iZU5vZGUuXG4gIC8vIFNldCB0aGlzIHRvIG51bGwgdG8gZGlzcGxheSBub3RoaW5nIGluIHRoZSBzZW5zb3IuXG4gIHNlbnNvclR5cGVGdW5jdGlvbj86IFNlbnNvclR5cGVGdW5jdGlvbiB8IG51bGw7XG59O1xuXG5leHBvcnQgdHlwZSBQcm9iZU5vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBOb2RlT3B0aW9ucztcblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBSZXF1aXJlZDxTZWxmT3B0aW9ucz4gPSB7XG4gIHJhZGl1czogNTAsXG4gIGlubmVyUmFkaXVzOiAzNSxcbiAgaGFuZGxlV2lkdGg6IDUwLFxuICBoYW5kbGVIZWlnaHQ6IDMwLFxuICBoYW5kbGVDb3JuZXJSYWRpdXM6IDEwLFxuICBsaWdodEFuZ2xlOiAxLjM1ICogTWF0aC5QSSxcbiAgY29sb3I6ICcjMDA4NTQxJywgLy8gZGFya2lzaCBncmVlblxuICBzZW5zb3JUeXBlRnVuY3Rpb246IGdsYXNzKClcbn07XG5hc3NlcnQgJiYgT2JqZWN0LmZyZWV6ZSggREVGQVVMVF9PUFRJT05TICk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2JlTm9kZSBleHRlbmRzIE5vZGUge1xuXG4gIC8vIENvbG9ycyB1c2VkIHRvIGNyZWF0ZSBncmFkaWVudHNcbiAgcHJpdmF0ZSByZWFkb25seSBicmlnaHRlcjVQcm9wZXJ0eTogUGFpbnRDb2xvclByb3BlcnR5O1xuICBwcml2YXRlIHJlYWRvbmx5IGJyaWdodGVyNFByb3BlcnR5OiBQYWludENvbG9yUHJvcGVydHk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYnJpZ2h0ZXIzUHJvcGVydHk6IFBhaW50Q29sb3JQcm9wZXJ0eTtcbiAgcHJpdmF0ZSByZWFkb25seSBicmlnaHRlcjJQcm9wZXJ0eTogUGFpbnRDb2xvclByb3BlcnR5O1xuICBwcml2YXRlIHJlYWRvbmx5IGRhcmtlcjNQcm9wZXJ0eTogUGFpbnRDb2xvclByb3BlcnR5O1xuICBwcml2YXRlIHJlYWRvbmx5IGRhcmtlcjJQcm9wZXJ0eTogUGFpbnRDb2xvclByb3BlcnR5O1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9QUk9CRV9OT0RFX09QVElPTlMgPSBERUZBVUxUX09QVElPTlM7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZ2xhc3MgPSBnbGFzcztcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjcm9zc2hhaXJzID0gY3Jvc3NoYWlycztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIHByb3ZpZGVkT3B0aW9ucz86IFByb2JlTm9kZU9wdGlvbnMgKSB7XG5cbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplMzxQcm9iZU5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgTm9kZU9wdGlvbnM+KCkoIHt9LCBERUZBVUxUX09QVElPTlMsIHByb3ZpZGVkT3B0aW9ucyApO1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8vIFRvIGltcHJvdmUgcmVhZGFiaWxpdHlcbiAgICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcblxuICAgIC8vIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIG9mIHRoZSBoYW5kbGUsIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4gKGNlbnRlciBvZiB0aGUgc2Vuc29yKVxuICAgIGNvbnN0IGhhbmRsZUJvdHRvbSA9IHJhZGl1cyArIG9wdGlvbnMuaGFuZGxlSGVpZ2h0O1xuXG4gICAgLy8gQ29uc3RhbnRzIHRoYXQgZGV0ZXJtaW5lIHRoZSBvdXRlciBTaGFwZSBvZiB0aGUgcHJvYmVcbiAgICBjb25zdCBhcmNFeHRlbnQgPSAwLjg7XG4gICAgY29uc3QgaGFuZGxlV2lkdGggPSBvcHRpb25zLmhhbmRsZVdpZHRoO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5taW4oIG9wdGlvbnMuaW5uZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzICk7XG4gICAgY29uc3QgY29ybmVyUmFkaXVzID0gb3B0aW9ucy5oYW5kbGVDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgbmVja0Nvcm5lclJhZGl1cyA9IDEwO1xuXG4gICAgLy8gV2UgbXVzdCBrbm93IHdoZXJlIHRoZSBlbGxpcHRpY2FsIGFyYyBiZWdpbnMsIHNvIGNyZWF0ZSBhbiBleHBsaWNpdCBFbGxpcHRpY2FsQXJjIGZvciB0aGF0XG4gICAgLy8gTm90ZTogVGhpcyBlbGxpcHRpY2FsIGFyYyBtdXN0IG1hdGNoIHRoZSBlbGxpcHRpY2FsQXJjIGNhbGwgYmVsb3dcbiAgICBjb25zdCBlbGxpcHRpY2FsQXJjU3RhcnQgPSBuZXcgRWxsaXB0aWNhbEFyYyggbmV3IFZlY3RvcjIoIDAsIDAgKSwgcmFkaXVzLCByYWRpdXMsIDAsIE1hdGguUEkgKiBhcmNFeHRlbnQsIE1hdGguUEkgKiAoIDEgLSBhcmNFeHRlbnQgKSwgZmFsc2UgKS5zdGFydDtcblxuICAgIC8vIENyZWF0ZXMgdGhlIFNoYXBlIGZvciB0aGUgb3V0c2lkZSBlZGdlIG9mIHRoZSBwcm9iZSwgY2lyY3VsYXIgYXQgdG9wIHdpdGggaGFuZGxlIGF0IHRoZSBib3R0b20uXG4gICAgZnVuY3Rpb24gY3JlYXRlT3V0ZXJQcm9iZVNoYXBlKCk6IFNoYXBlIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUoKVxuXG4gICAgICAgIC8vIHN0YXJ0IGluIHRoZSBib3R0b20gY2VudGVyXG4gICAgICAgIC5tb3ZlVG8oIDAsIGhhbmRsZUJvdHRvbSApXG5cbiAgICAgICAgLy8gS2l0ZSBTaGFwZSBhdXRvbWF0aWNhbGx5IGxpbmVUbydzIHRvIHRoZSBmaXJzdCBwb2ludCBvZiBhbiBhcmMsIHNvIG5vIG5lZWQgdG8gbGluZVRvIG91cnNlbHZlc1xuICAgICAgICAuYXJjKCAtaGFuZGxlV2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBoYW5kbGVCb3R0b20gLSBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAvIDIsIE1hdGguUEksIGZhbHNlIClcbiAgICAgICAgLmxpbmVUbyggLWhhbmRsZVdpZHRoIC8gMiwgcmFkaXVzICsgbmVja0Nvcm5lclJhZGl1cyApXG4gICAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvKCAtaGFuZGxlV2lkdGggLyAyLCByYWRpdXMsIGVsbGlwdGljYWxBcmNTdGFydC54LCBlbGxpcHRpY2FsQXJjU3RhcnQueSApXG5cbiAgICAgICAgLy8gVG9wIGFyY1xuICAgICAgICAvLyBOb3RlOiBoaXMgZWxsaXB0aWNhbCBhcmMgbXVzdCBtYXRjaCB0aGUgRWxsaXB0aWNhbEFyYyBhYm92ZVxuICAgICAgICAuZWxsaXB0aWNhbEFyYyggMCwgMCwgcmFkaXVzLCByYWRpdXMsIDAsIE1hdGguUEkgKiBhcmNFeHRlbnQsIE1hdGguUEkgKiAoIDEgLSBhcmNFeHRlbnQgKSwgZmFsc2UgKVxuXG4gICAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvKCBoYW5kbGVXaWR0aCAvIDIsIHJhZGl1cywgK2hhbmRsZVdpZHRoIC8gMiwgcmFkaXVzICsgbmVja0Nvcm5lclJhZGl1cyApXG4gICAgICAgIC5hcmMoIGhhbmRsZVdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgaGFuZGxlQm90dG9tIC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIDAsIE1hdGguUEkgLyAyLCBmYWxzZSApXG5cbiAgICAgICAgLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgd2l0aCB0aGUgb3V0ZXIgU2hhcGUgb2YgdGhlIHByb2JlLCBhbmQgY3V0IG91dCB0aGUgc2Vuc29yIGFyZWEuXG4gICAgY29uc3QgcHJvYmVTaGFwZSA9IGNyZWF0ZU91dGVyUHJvYmVTaGFwZSgpXG4gICAgICAubW92ZVRvKCBpbm5lclJhZGl1cywgMCApXG4gICAgICAuYXJjKCAwLCAwLCBpbm5lclJhZGl1cywgTWF0aC5QSSAqIDIsIDAsIHRydWUgKVxuICAgICAgLmNsb3NlKCk7XG5cbiAgICAvLyBUaGUgbGlnaHQgYW5nbGUgaXMgdmFyaWFibGUgc28gdGhhdCB5b3UgY2FuIGNyZWF0ZSBhIHByb2JlIG5vZGUgdGhhdCBpcyBwb2ludGluZyB1cCBvciB0byB0aGUgc2lkZVxuICAgIGNvbnN0IGxpZ2h0QW5nbGUgPSBvcHRpb25zLmxpZ2h0QW5nbGU7XG5cbiAgICBjb25zdCBjZW50ZXIgPSBwcm9iZVNoYXBlLmJvdW5kcy5jZW50ZXI7XG4gICAgY29uc3QgdjEgPSBWZWN0b3IyLmNyZWF0ZVBvbGFyKCAxLCBsaWdodEFuZ2xlICk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IHByb2JlU2hhcGUuaW50ZXJzZWN0aW9uKCBuZXcgUmF5MiggY2VudGVyLCB2MSApICk7XG5cbiAgICAvLyB0YWtlIGxhc3QgaW50ZXJzZWN0aW9uIG9yIHplcm8gcG9pbnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS1waGV0L2lzc3Vlcy8yOTRcbiAgICBjb25zdCBsYXN0SW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uc1sgaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxIF07XG4gICAgY29uc3QgbGFzdEludGVyc2VjdGlvblBvaW50ID0gbGFzdEludGVyc2VjdGlvbiA/IGxhc3RJbnRlcnNlY3Rpb24ucG9pbnQgOiBWZWN0b3IyLlpFUk87XG4gICAgY29uc3QgZ3JhZGllbnRTb3VyY2UgPSBsYXN0SW50ZXJzZWN0aW9uUG9pbnQucGx1cyggdjEudGltZXNTY2FsYXIoIDEgKSApO1xuXG4gICAgY29uc3QgdjIgPSBWZWN0b3IyLmNyZWF0ZVBvbGFyKCAxLCBsaWdodEFuZ2xlICsgTWF0aC5QSSApO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMyID0gcHJvYmVTaGFwZS5pbnRlcnNlY3Rpb24oIG5ldyBSYXkyKCBjZW50ZXIsIHYyICkgKTtcblxuICAgIC8vIHRha2UgbGFzdCBpbnRlcnNlY3Rpb24gb3IgemVybyBwb2ludCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5LXBoZXQvaXNzdWVzLzI5NFxuICAgIGNvbnN0IGxhc3RJbnRlcnNlY3Rpb24yID0gaW50ZXJzZWN0aW9uczJbIGludGVyc2VjdGlvbnMyLmxlbmd0aCAtIDEgXTtcbiAgICBjb25zdCBsYXN0SW50ZXJzZWN0aW9uUG9pbnQyID0gbGFzdEludGVyc2VjdGlvbjIgPyBsYXN0SW50ZXJzZWN0aW9uMi5wb2ludCA6IFZlY3RvcjIuWkVSTztcbiAgICBjb25zdCBncmFkaWVudERlc3RpbmF0aW9uID0gbGFzdEludGVyc2VjdGlvblBvaW50Mi5wbHVzKCB2Mi50aW1lc1NjYWxhciggMSApICk7XG5cbiAgICB0aGlzLmJyaWdodGVyNVByb3BlcnR5ID0gbmV3IFBhaW50Q29sb3JQcm9wZXJ0eSggb3B0aW9ucy5jb2xvciwgeyBsdW1pbmFuY2VGYWN0b3I6IDAuNSB9ICk7XG4gICAgdGhpcy5icmlnaHRlcjRQcm9wZXJ0eSA9IG5ldyBQYWludENvbG9yUHJvcGVydHkoIG9wdGlvbnMuY29sb3IsIHsgbHVtaW5hbmNlRmFjdG9yOiAwLjQgfSApO1xuICAgIHRoaXMuYnJpZ2h0ZXIzUHJvcGVydHkgPSBuZXcgUGFpbnRDb2xvclByb3BlcnR5KCBvcHRpb25zLmNvbG9yLCB7IGx1bWluYW5jZUZhY3RvcjogMC4zIH0gKTtcbiAgICB0aGlzLmJyaWdodGVyMlByb3BlcnR5ID0gbmV3IFBhaW50Q29sb3JQcm9wZXJ0eSggb3B0aW9ucy5jb2xvciwgeyBsdW1pbmFuY2VGYWN0b3I6IDAuMiB9ICk7XG4gICAgdGhpcy5kYXJrZXIyUHJvcGVydHkgPSBuZXcgUGFpbnRDb2xvclByb3BlcnR5KCBvcHRpb25zLmNvbG9yLCB7IGx1bWluYW5jZUZhY3RvcjogLTAuMiB9ICk7XG4gICAgdGhpcy5kYXJrZXIzUHJvcGVydHkgPSBuZXcgUGFpbnRDb2xvclByb3BlcnR5KCBvcHRpb25zLmNvbG9yLCB7IGx1bWluYW5jZUZhY3RvcjogLTAuMyB9ICk7XG5cbiAgICAvLyBUaGUgbWFpbiBwYXRoIG9mIHRoZSBwcm9iZVxuICAgIGNvbnN0IG1haW5QYXRoID0gbmV3IFBhdGgoIHByb2JlU2hhcGUsIHtcbiAgICAgIHN0cm9rZTogbmV3IExpbmVhckdyYWRpZW50KCBncmFkaWVudFNvdXJjZS54LCBncmFkaWVudFNvdXJjZS55LCBncmFkaWVudERlc3RpbmF0aW9uLngsIGdyYWRpZW50RGVzdGluYXRpb24ueSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuMCwgdGhpcy5icmlnaHRlcjJQcm9wZXJ0eSApIC8vIGhpZ2hsaWdodFxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAxLjAsIHRoaXMuZGFya2VyMlByb3BlcnR5ICksIC8vIHNoYWRvd1xuICAgICAgZmlsbDogbmV3IExpbmVhckdyYWRpZW50KCBncmFkaWVudFNvdXJjZS54LCBncmFkaWVudFNvdXJjZS55LCBncmFkaWVudERlc3RpbmF0aW9uLngsIGdyYWRpZW50RGVzdGluYXRpb24ueSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuMCwgdGhpcy5icmlnaHRlcjVQcm9wZXJ0eSApIC8vIGhpZ2hsaWdodFxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLjAzLCB0aGlzLmJyaWdodGVyNFByb3BlcnR5IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMC4wNywgdGhpcy5icmlnaHRlcjRQcm9wZXJ0eSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuMTEsIHRoaXMuYnJpZ2h0ZXIyUHJvcGVydHkgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLjMsIG9wdGlvbnMuY29sb3IgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLjgsIHRoaXMuZGFya2VyMlByb3BlcnR5ICkgLy8gc2hhZG93c1xuICAgICAgICAuYWRkQ29sb3JTdG9wKCAxLjAsIHRoaXMuZGFya2VyM1Byb3BlcnR5ICksXG4gICAgICBsaW5lV2lkdGg6IDJcbiAgICB9ICk7XG5cbiAgICAvLyBUaGUgZnJvbnQgZmxhdCBcInN1cmZhY2VcIiBvZiB0aGUgcHJvYmUsIG1ha2VzIGl0IGxvb2sgM2QgYnkgZ2l2aW5nIHRoZSBwcm9iZSBhIGJldmVsZWQgYXBwZWFyYW5jZSBhbmQgcHV0dGluZ1xuICAgIC8vIGEgc2hpbnkgZ2xhcmUgb24gdGhlIHRvcCBlZGdlLlxuICAgIGNvbnN0IGZyb250UGF0aCA9IG5ldyBQYXRoKCBwcm9iZVNoYXBlLCB7XG4gICAgICBmaWxsOiBvcHRpb25zLmNvbG9yLFxuXG4gICAgICAvLyB5IHNjYWxlIGlzIGFuIGVtcGlyaWNhbCBmdW5jdGlvbiBvZiBoYW5kbGUgaGVpZ2h0LCB0byBrZWVwIGJldmVsIGF0IGJvdHRvbSBvZiBoYW5kbGUgZnJvbSBjaGFuZ2luZyBzaXplXG4gICAgICBzY2FsZTogbmV3IFZlY3RvcjIoIDAuOSwgMC45MyArICggMC4wMSAqIG9wdGlvbnMuaGFuZGxlSGVpZ2h0IC8gREVGQVVMVF9PUFRJT05TLmhhbmRsZUhlaWdodCApICksXG4gICAgICBjZW50ZXJYOiBtYWluUGF0aC5jZW50ZXJYLFxuICAgICAgc3Ryb2tlOiBuZXcgRGVyaXZlZFByb3BlcnR5KCBbIHRoaXMuYnJpZ2h0ZXIzUHJvcGVydHkgXSwgKCBjb2xvciA9PiB7XG4gICAgICAgIHJldHVybiBjb2xvci53aXRoQWxwaGEoIDAuNSApO1xuICAgICAgfSApICksXG4gICAgICBsaW5lV2lkdGg6IDEuMixcbiAgICAgIHk6IDIgLy8gU2hpZnQgaXQgZG93biBhIGJpdCB0byBtYWtlIHRoZSBmYWNlIGxvb2sgYSBiaXQgbW9yZSAzZFxuICAgIH0gKTtcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgaWYgKCBvcHRpb25zLnNlbnNvclR5cGVGdW5jdGlvbiApIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goIG9wdGlvbnMuc2Vuc29yVHlwZUZ1bmN0aW9uKCByYWRpdXMgKSApO1xuICAgIH1cbiAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgbWFpblBhdGgsXG4gICAgICBmcm9udFBhdGhcbiAgICApO1xuXG4gICAgLy8gQWxsb3cgdGhlIGNsaWVudCB0byBhZGQgY2hpbGQgbm9kZXNcbiAgICBvcHRpb25zLmNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KCBvcHRpb25zLmNoaWxkcmVuIHx8IFtdICk7XG5cbiAgICAvLyBBbGxvdyB0aGUgY2xpZW50IHRvIG92ZXJyaWRlIG1vdXNlIGFuZCB0b3VjaCBhcmVhLCBidXQgZmFsbCBiYWNrIHRvIHRoZSBvdXRsaW5lXG4gICAgY29uc3Qgb3V0bGluZSA9IGNyZWF0ZU91dGVyUHJvYmVTaGFwZSgpO1xuICAgIG9wdGlvbnMubW91c2VBcmVhID0gb3B0aW9ucy5tb3VzZUFyZWEgfHwgb3V0bGluZTtcbiAgICBvcHRpb25zLnRvdWNoQXJlYSA9IG9wdGlvbnMudG91Y2hBcmVhIHx8IG91dGxpbmU7XG5cbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYmluZGVyIGRvY3VtZW50YXRpb24sIHN0cmlwcGVkIG91dCBpbiBidWlsZHMgYW5kIG9ubHkgcnVucyB3aGVuID9iaW5kZXIgaXMgc3BlY2lmaWVkXG4gICAgYXNzZXJ0ICYmIHdpbmRvdy5waGV0Py5jaGlwcGVyPy5xdWVyeVBhcmFtZXRlcnM/LmJpbmRlciAmJiBJbnN0YW5jZVJlZ2lzdHJ5LnJlZ2lzdGVyRGF0YVVSTCggJ3NjZW5lcnktcGhldCcsICdQcm9iZU5vZGUnLCB0aGlzICk7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmJyaWdodGVyNVByb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmJyaWdodGVyNFByb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmJyaWdodGVyM1Byb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmJyaWdodGVyMlByb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLmRhcmtlcjJQcm9wZXJ0eS5kaXNwb3NlKCk7XG4gICAgdGhpcy5kYXJrZXIzUHJvcGVydHkuZGlzcG9zZSgpO1xuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZhbHVlIGZvciBvcHRpb25zLnNlbnNvclR5cGVGdW5jdGlvbi4gU2hvd3MgYSBzaGlueSByZWZsZWN0aXZlIGludGVyaW9yIGluIHRoZSBzZW5zb3IgYXJlYS5cbiAqL1xuZnVuY3Rpb24gZ2xhc3MoIHByb3ZpZGVkT3B0aW9ucz86IEdsYXNzT3B0aW9ucyApOiBTZW5zb3JUeXBlRnVuY3Rpb24ge1xuXG4gIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8R2xhc3NPcHRpb25zLCBFbXB0eVNlbGZPcHRpb25zLCBHbGFzc09wdGlvbnM+KCkoIHtcbiAgICBjZW50ZXJDb2xvcjogJ3doaXRlJyxcbiAgICBtaWRkbGVDb2xvcjogJyNFNkY1RkYnLCAvLyBsaWdodCBibHVlXG4gICAgZWRnZUNvbG9yOiAnI0MyRTdGRicgLy8gc2xpZ2h0bHkgZGFya2VyIGJsdWUsIGxpa2UgZ2xhc3NcbiAgfSwgcHJvdmlkZWRPcHRpb25zICk7XG5cbiAgcmV0dXJuICggcmFkaXVzOiBudW1iZXIgKTogTm9kZSA9PiB7XG4gICAgcmV0dXJuIG5ldyBDaXJjbGUoIHJhZGl1cywge1xuICAgICAgZmlsbDogbmV3IFJhZGlhbEdyYWRpZW50KCAtcmFkaXVzICogMC4xNSwgLXJhZGl1cyAqIDAuMTUsIDAsIC1yYWRpdXMgKiAwLjE1LCAtcmFkaXVzICogMC4yMCwgcmFkaXVzICogMC42MCApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAsIG9wdGlvbnMuY2VudGVyQ29sb3IgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLjQsIG9wdGlvbnMubWlkZGxlQ29sb3IgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAxLCBvcHRpb25zLmVkZ2VDb2xvciApXG4gICAgfSApO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB2YWx1ZSBmb3Igb3B0aW9ucy5zZW5zb3JUeXBlRnVuY3Rpb24uIFNob3dzIGEgY3Jvc3NoYWlycyBpbiB0aGUgc2Vuc29yIGFyZWEuXG4gKi9cbmZ1bmN0aW9uIGNyb3NzaGFpcnMoIHByb3ZpZGVkT3B0aW9ucz86IENyb3NzaGFpcnNPcHRpb25zICk6IFNlbnNvclR5cGVGdW5jdGlvbiB7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxDcm9zc2hhaXJzT3B0aW9ucywgRW1wdHlTZWxmT3B0aW9ucywgQ3Jvc3NoYWlyc09wdGlvbnM+KCkoIHtcbiAgICBzdHJva2U6ICdibGFjaycsXG4gICAgbGluZVdpZHRoOiAzLFxuICAgIGludGVyc2VjdGlvblJhZGl1czogOFxuICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICByZXR1cm4gKCByYWRpdXM6IG51bWJlciApOiBOb2RlID0+IHtcbiAgICBjb25zdCBsaW5lT3B0aW9ucyA9IHsgc3Ryb2tlOiBvcHRpb25zLnN0cm9rZSwgbGluZVdpZHRoOiBvcHRpb25zLmxpbmVXaWR0aCB9O1xuICAgIHJldHVybiBuZXcgTm9kZSgge1xuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgbmV3IExpbmUoIC1yYWRpdXMsIDAsIC1vcHRpb25zLmludGVyc2VjdGlvblJhZGl1cywgMCwgbGluZU9wdGlvbnMgKSxcbiAgICAgICAgbmV3IExpbmUoICtyYWRpdXMsIDAsICtvcHRpb25zLmludGVyc2VjdGlvblJhZGl1cywgMCwgbGluZU9wdGlvbnMgKSxcbiAgICAgICAgbmV3IExpbmUoIDAsIC1yYWRpdXMsIDAsIC1vcHRpb25zLmludGVyc2VjdGlvblJhZGl1cywgbGluZU9wdGlvbnMgKSxcbiAgICAgICAgbmV3IExpbmUoIDAsICtyYWRpdXMsIDAsICtvcHRpb25zLmludGVyc2VjdGlvblJhZGl1cywgbGluZU9wdGlvbnMgKSBdXG4gICAgfSApO1xuICB9O1xufVxuXG5zY2VuZXJ5UGhldC5yZWdpc3RlciggJ1Byb2JlTm9kZScsIFByb2JlTm9kZSApOyJdLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJSYXkyIiwiVmVjdG9yMiIsIkVsbGlwdGljYWxBcmMiLCJTaGFwZSIsIkluc3RhbmNlUmVnaXN0cnkiLCJvcHRpb25pemUiLCJvcHRpb25pemUzIiwiQ2lyY2xlIiwiTGluZSIsIkxpbmVhckdyYWRpZW50IiwiTm9kZSIsIlBhaW50Q29sb3JQcm9wZXJ0eSIsIlBhdGgiLCJSYWRpYWxHcmFkaWVudCIsInNjZW5lcnlQaGV0IiwiREVGQVVMVF9PUFRJT05TIiwicmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJoYW5kbGVXaWR0aCIsImhhbmRsZUhlaWdodCIsImhhbmRsZUNvcm5lclJhZGl1cyIsImxpZ2h0QW5nbGUiLCJNYXRoIiwiUEkiLCJjb2xvciIsInNlbnNvclR5cGVGdW5jdGlvbiIsImdsYXNzIiwiYXNzZXJ0IiwiT2JqZWN0IiwiZnJlZXplIiwiUHJvYmVOb2RlIiwiZGlzcG9zZSIsImJyaWdodGVyNVByb3BlcnR5IiwiYnJpZ2h0ZXI0UHJvcGVydHkiLCJicmlnaHRlcjNQcm9wZXJ0eSIsImJyaWdodGVyMlByb3BlcnR5IiwiZGFya2VyMlByb3BlcnR5IiwiZGFya2VyM1Byb3BlcnR5IiwicHJvdmlkZWRPcHRpb25zIiwid2luZG93Iiwib3B0aW9ucyIsImhhbmRsZUJvdHRvbSIsImFyY0V4dGVudCIsIm1pbiIsImNvcm5lclJhZGl1cyIsIm5lY2tDb3JuZXJSYWRpdXMiLCJlbGxpcHRpY2FsQXJjU3RhcnQiLCJzdGFydCIsImNyZWF0ZU91dGVyUHJvYmVTaGFwZSIsIm1vdmVUbyIsImFyYyIsImxpbmVUbyIsInF1YWRyYXRpY0N1cnZlVG8iLCJ4IiwieSIsImVsbGlwdGljYWxBcmMiLCJjbG9zZSIsInByb2JlU2hhcGUiLCJjZW50ZXIiLCJib3VuZHMiLCJ2MSIsImNyZWF0ZVBvbGFyIiwiaW50ZXJzZWN0aW9ucyIsImludGVyc2VjdGlvbiIsImxhc3RJbnRlcnNlY3Rpb24iLCJsZW5ndGgiLCJsYXN0SW50ZXJzZWN0aW9uUG9pbnQiLCJwb2ludCIsIlpFUk8iLCJncmFkaWVudFNvdXJjZSIsInBsdXMiLCJ0aW1lc1NjYWxhciIsInYyIiwiaW50ZXJzZWN0aW9uczIiLCJsYXN0SW50ZXJzZWN0aW9uMiIsImxhc3RJbnRlcnNlY3Rpb25Qb2ludDIiLCJncmFkaWVudERlc3RpbmF0aW9uIiwibHVtaW5hbmNlRmFjdG9yIiwibWFpblBhdGgiLCJzdHJva2UiLCJhZGRDb2xvclN0b3AiLCJmaWxsIiwibGluZVdpZHRoIiwiZnJvbnRQYXRoIiwic2NhbGUiLCJjZW50ZXJYIiwid2l0aEFscGhhIiwiY2hpbGRyZW4iLCJwdXNoIiwiY29uY2F0Iiwib3V0bGluZSIsIm1vdXNlQXJlYSIsInRvdWNoQXJlYSIsIm11dGF0ZSIsInBoZXQiLCJjaGlwcGVyIiwicXVlcnlQYXJhbWV0ZXJzIiwiYmluZGVyIiwicmVnaXN0ZXJEYXRhVVJMIiwiREVGQVVMVF9QUk9CRV9OT0RFX09QVElPTlMiLCJjcm9zc2hhaXJzIiwiY2VudGVyQ29sb3IiLCJtaWRkbGVDb2xvciIsImVkZ2VDb2xvciIsImludGVyc2VjdGlvblJhZGl1cyIsImxpbmVPcHRpb25zIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7Ozs7OztDQVVDLEdBRUQsT0FBT0EscUJBQXFCLG1DQUFtQztBQUMvRCxPQUFPQyxVQUFVLHVCQUF1QjtBQUN4QyxPQUFPQyxhQUFhLDBCQUEwQjtBQUM5QyxTQUFTQyxhQUFhLEVBQUVDLEtBQUssUUFBUSwyQkFBMkI7QUFDaEUsT0FBT0Msc0JBQXNCLHVEQUF1RDtBQUNwRixPQUFPQyxhQUErQkMsVUFBVSxRQUFRLGtDQUFrQztBQUMxRixTQUFTQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsY0FBYyxFQUFFQyxJQUFJLEVBQWVDLGtCQUFrQixFQUFFQyxJQUFJLEVBQUVDLGNBQWMsUUFBZ0IsOEJBQThCO0FBQ2hKLE9BQU9DLGlCQUFpQixtQkFBbUI7QUE0QzNDLE1BQU1DLGtCQUF5QztJQUM3Q0MsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYkMsY0FBYztJQUNkQyxvQkFBb0I7SUFDcEJDLFlBQVksT0FBT0MsS0FBS0MsRUFBRTtJQUMxQkMsT0FBTztJQUNQQyxvQkFBb0JDO0FBQ3RCO0FBQ0FDLFVBQVVDLE9BQU9DLE1BQU0sQ0FBRWQ7QUFFVixJQUFBLEFBQU1lLFlBQU4sTUFBTUEsa0JBQWtCcEI7SUFrSnJCcUIsVUFBZ0I7UUFDOUIsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0QsT0FBTztRQUM5QixJQUFJLENBQUNFLGlCQUFpQixDQUFDRixPQUFP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