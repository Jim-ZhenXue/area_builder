// Copyright 2013-2024, University of Colorado Boulder
/**
 * Provides a 2-way mapping between wavelength and Color.
 * The mapping is performed using a color lookup table.
 *
 * Note that the sRGB colorspace is not capable of representing all visible colors.
 * So in converting visible wavelengths to Color, it is possible to lose some color information.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */ import Utils from '../../dot/js/Utils.js';
import optionize from '../../phet-core/js/optionize.js';
import { Color } from '../../scenery/js/imports.js';
import sceneryPhet from './sceneryPhet.js';
// constants
const COLOR_MATCH_DELTA = 2; // Two colors match if their RGB components each differ by less than this amount.
const SPEED_OF_LIGHT = 299792458; // speed of light in a vacuum, in m/s
const VIOLET_WAVELENGTH = 380; // nm
const RED_WAVELENGTH = 780; // nm
// Create the color tables on demand, since they take up 282kb per table or so.
let REDUCED_INTENSITY_COLOR_TABLE = null;
let FULL_INTENSITY_COLOR_TABLE = null;
const VisibleColor = {
    // public constants
    MIN_WAVELENGTH: VIOLET_WAVELENGTH,
    MAX_WAVELENGTH: RED_WAVELENGTH,
    MIN_FREQUENCY: SPEED_OF_LIGHT / RED_WAVELENGTH * 1E9,
    MAX_FREQUENCY: SPEED_OF_LIGHT / VIOLET_WAVELENGTH * 1E9,
    SPEED_OF_LIGHT: SPEED_OF_LIGHT,
    WHITE_WAVELENGTH: 0,
    /**
   * Converts a wavelength (in nm, rounded to the nearest integer) to a visible color.
   */ wavelengthToColor: function(wavelength, providedOptions) {
        const options = optionize()({
            irColor: null,
            uvColor: null,
            reduceIntensityAtExtrema: true
        }, providedOptions);
        let color = null;
        if (wavelength === VisibleColor.WHITE_WAVELENGTH) {
            color = Color.WHITE;
        } else if (wavelength < VisibleColor.MIN_WAVELENGTH) {
            color = Color.toColor(options.irColor);
        } else if (wavelength > VisibleColor.MAX_WAVELENGTH) {
            color = Color.toColor(options.uvColor);
        } else {
            const colorTable = getColorTable(options.reduceIntensityAtExtrema);
            color = colorTable[Utils.roundSymmetric(wavelength) - VisibleColor.MIN_WAVELENGTH];
        }
        assert && assert(color, `color not found for wavelength ${wavelength}`);
        return color;
    },
    /**
   * Converts a frequency (in Hz) to a visible color.
   */ frequencyToColor: function(frequency, providedOptions) {
        const wavelengthInMeters = SPEED_OF_LIGHT / frequency;
        const wavelengthInNanometers = wavelengthInMeters * 1E9;
        return VisibleColor.wavelengthToColor(wavelengthInNanometers, providedOptions);
    },
    /**
   * Converts a Color to its corresponding wavelength. Relies on a color lookup table that is initialized the first
   * time that this method is called.  Color lookup is based on RGB component value; the alpha value is ignored.
   */ colorToWavelength: function(color, reduceIntensityAtExtrema = true) {
        color = Color.toColor(color);
        let wavelength = -1;
        if (color.equals(Color.WHITE)) {
            wavelength = VisibleColor.WHITE_WAVELENGTH;
        } else {
            const colorTable = getColorTable(reduceIntensityAtExtrema);
            for(let i = 0; i < colorTable.length; i++){
                if (Math.abs(color.getRed() - colorTable[i].getRed()) < COLOR_MATCH_DELTA && Math.abs(color.getGreen() - colorTable[i].getGreen()) < COLOR_MATCH_DELTA && Math.abs(color.getBlue() - colorTable[i].getBlue()) < COLOR_MATCH_DELTA) {
                    wavelength = VisibleColor.MIN_WAVELENGTH + i;
                    break;
                }
            }
        }
        assert && assert(wavelength !== -1, `no wavelength found for color ${color.toString()}`);
        return wavelength;
    },
    /**
   * Is the specified wavelength in the visible spectrum?
   */ isVisibleWavelength (wavelength) {
        return wavelength >= VisibleColor.MIN_WAVELENGTH && wavelength <= VisibleColor.MAX_WAVELENGTH;
    }
};
/**
 * Creates a table that is used to map wavelength (in nm) to Color.
 * @param reduceIntensityAtExtrema - whether the intensity should be reduced at high and low wavelengths,
 *   see https://github.com/phetsims/wave-interference/issues/395
 */ function createColorTable(reduceIntensityAtExtrema) {
    const colorTable = [];
    // Allocate the lookup table
    const numWavelengths = Math.floor(VisibleColor.MAX_WAVELENGTH - VisibleColor.MIN_WAVELENGTH + 1);
    // Populate the lookup table
    let wavelength;
    let r;
    let g;
    let b;
    for(let i = 0; i < numWavelengths; i++){
        // Create the RGB component values.
        wavelength = VisibleColor.MIN_WAVELENGTH + i;
        r = g = b = 0;
        // Determine the RGB component values.
        if (wavelength >= 380 && wavelength <= 440) {
            r = -1 * (wavelength - 440) / (440 - 380);
            g = 0;
            b = 1;
        } else if (wavelength > 440 && wavelength <= 490) {
            r = 0;
            g = (wavelength - 440) / (490 - 440);
            b = 1;
        } else if (wavelength > 490 && wavelength <= 510) {
            r = 0;
            g = 1;
            b = -1 * (wavelength - 510) / (510 - 490);
        } else if (wavelength > 510 && wavelength <= 580) {
            r = (wavelength - 510) / (580 - 510);
            g = 1;
            b = 0;
        } else if (wavelength > 580 && wavelength <= 645) {
            r = 1;
            g = -1 * (wavelength - 645) / (645 - 580);
            b = 0;
        } else if (wavelength > 645 && wavelength <= 780) {
            r = 1;
            g = 0;
            b = 0;
        }
        // Let the intensity fall off near the vision limits.
        let intensity;
        if (reduceIntensityAtExtrema && wavelength > 645) {
            intensity = 0.3 + 0.7 * (780 - wavelength) / (780 - 645);
        } else if (reduceIntensityAtExtrema && wavelength < 420) {
            intensity = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
        } else {
            intensity = 1;
        }
        const red = Utils.roundSymmetric(255 * (intensity * r));
        const green = Utils.roundSymmetric(255 * (intensity * g));
        const blue = Utils.roundSymmetric(255 * (intensity * b));
        const alpha = 1;
        // Add the color to the lookup array.
        colorTable[i] = new Color(red, green, blue, alpha);
    }
    return colorTable;
}
/**
 * Determines which color table to use based on the options.  This assumes options have been filled in by the call
 * site, hence uses config instead of options.
 */ function getColorTable(reduceIntensityAtExtrema) {
    if (reduceIntensityAtExtrema) {
        // cache for future use
        REDUCED_INTENSITY_COLOR_TABLE = REDUCED_INTENSITY_COLOR_TABLE || createColorTable(true);
        return REDUCED_INTENSITY_COLOR_TABLE;
    } else {
        // cache for future use
        FULL_INTENSITY_COLOR_TABLE = FULL_INTENSITY_COLOR_TABLE || createColorTable(false);
        return FULL_INTENSITY_COLOR_TABLE;
    }
}
sceneryPhet.register('VisibleColor', VisibleColor);
export default VisibleColor;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9WaXNpYmxlQ29sb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogUHJvdmlkZXMgYSAyLXdheSBtYXBwaW5nIGJldHdlZW4gd2F2ZWxlbmd0aCBhbmQgQ29sb3IuXG4gKiBUaGUgbWFwcGluZyBpcyBwZXJmb3JtZWQgdXNpbmcgYSBjb2xvciBsb29rdXAgdGFibGUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBzUkdCIGNvbG9yc3BhY2UgaXMgbm90IGNhcGFibGUgb2YgcmVwcmVzZW50aW5nIGFsbCB2aXNpYmxlIGNvbG9ycy5cbiAqIFNvIGluIGNvbnZlcnRpbmcgdmlzaWJsZSB3YXZlbGVuZ3RocyB0byBDb2xvciwgaXQgaXMgcG9zc2libGUgdG8gbG9zZSBzb21lIGNvbG9yIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xuaW1wb3J0IHNjZW5lcnlQaGV0IGZyb20gJy4vc2NlbmVyeVBoZXQuanMnO1xuXG4vLyBjb25zdGFudHNcbmNvbnN0IENPTE9SX01BVENIX0RFTFRBID0gMjsgLy8gVHdvIGNvbG9ycyBtYXRjaCBpZiB0aGVpciBSR0IgY29tcG9uZW50cyBlYWNoIGRpZmZlciBieSBsZXNzIHRoYW4gdGhpcyBhbW91bnQuXG5jb25zdCBTUEVFRF9PRl9MSUdIVCA9IDI5OTc5MjQ1ODsgLy8gc3BlZWQgb2YgbGlnaHQgaW4gYSB2YWN1dW0sIGluIG0vc1xuXG5jb25zdCBWSU9MRVRfV0FWRUxFTkdUSCA9IDM4MDsgLy8gbm1cbmNvbnN0IFJFRF9XQVZFTEVOR1RIID0gNzgwOyAvLyBubVxuXG4vLyBDcmVhdGUgdGhlIGNvbG9yIHRhYmxlcyBvbiBkZW1hbmQsIHNpbmNlIHRoZXkgdGFrZSB1cCAyODJrYiBwZXIgdGFibGUgb3Igc28uXG5sZXQgUkVEVUNFRF9JTlRFTlNJVFlfQ09MT1JfVEFCTEU6IENvbG9yW10gfCBudWxsID0gbnVsbDtcbmxldCBGVUxMX0lOVEVOU0lUWV9DT0xPUl9UQUJMRTogQ29sb3JbXSB8IG51bGwgPSBudWxsO1xuXG4vLyBUQ29sb3Igd291bGQgYmUgcHJlZmVyYWJsZSwgYnV0IENvbG9yLnRvQ29sb3IgZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgVENvbG9yLlxudHlwZSBUQ29sb3JTdWJzZXQgPSBDb2xvciB8IHN0cmluZyB8IG51bGw7XG5cbmV4cG9ydCB0eXBlIFdhdmVsZW5ndGhUb0NvbG9yT3B0aW9ucyA9IHtcbiAgaXJDb2xvcj86IFRDb2xvclN1YnNldDsgLy8gY29sb3IgdG8gdXNlIGZvciBJUiB3YXZlbGVuZ3Roc1xuICB1dkNvbG9yPzogVENvbG9yU3Vic2V0OyAvLyBjb2xvciB0byB1c2UgZm9yIFVWIHdhdmVsZW5ndGhzXG4gIHJlZHVjZUludGVuc2l0eUF0RXh0cmVtYT86IGJvb2xlYW47IC8vIHdoZXRoZXIgaW50ZW5zaXR5IHNob3VsZCBmYWxsIG9mZiBhdCBtaW4gYW5kIG1heCB3YXZlbGVuZ3Roc1xufTtcblxuY29uc3QgVmlzaWJsZUNvbG9yID0ge1xuXG4gIC8vIHB1YmxpYyBjb25zdGFudHNcbiAgTUlOX1dBVkVMRU5HVEg6IFZJT0xFVF9XQVZFTEVOR1RILCAvLyBpbiBubVxuICBNQVhfV0FWRUxFTkdUSDogUkVEX1dBVkVMRU5HVEgsIC8vIGluIG5tXG4gIE1JTl9GUkVRVUVOQ1k6IFNQRUVEX09GX0xJR0hUIC8gUkVEX1dBVkVMRU5HVEggKiAxRTksIC8vIGluIEh6XG4gIE1BWF9GUkVRVUVOQ1k6IFNQRUVEX09GX0xJR0hUIC8gVklPTEVUX1dBVkVMRU5HVEggKiAxRTksIC8vIGluIEh6XG4gIFNQRUVEX09GX0xJR0hUOiBTUEVFRF9PRl9MSUdIVCwgLy8gc3BlZWQgb2YgbGlnaHQgaW4gYSB2YWN1dW0sIGluIG0vc1xuICBXSElURV9XQVZFTEVOR1RIOiAwLFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHdhdmVsZW5ndGggKGluIG5tLCByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIpIHRvIGEgdmlzaWJsZSBjb2xvci5cbiAgICovXG4gIHdhdmVsZW5ndGhUb0NvbG9yOiBmdW5jdGlvbiggd2F2ZWxlbmd0aDogbnVtYmVyLCBwcm92aWRlZE9wdGlvbnM/OiBXYXZlbGVuZ3RoVG9Db2xvck9wdGlvbnMgKTogQ29sb3Ige1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxXYXZlbGVuZ3RoVG9Db2xvck9wdGlvbnM+KCkoIHtcbiAgICAgIGlyQ29sb3I6IG51bGwsXG4gICAgICB1dkNvbG9yOiBudWxsLFxuICAgICAgcmVkdWNlSW50ZW5zaXR5QXRFeHRyZW1hOiB0cnVlXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XG5cbiAgICBsZXQgY29sb3IgPSBudWxsO1xuICAgIGlmICggd2F2ZWxlbmd0aCA9PT0gVmlzaWJsZUNvbG9yLldISVRFX1dBVkVMRU5HVEggKSB7IC8vIHdoaXRlIGxpZ2h0XG4gICAgICBjb2xvciA9IENvbG9yLldISVRFO1xuICAgIH1cbiAgICBlbHNlIGlmICggd2F2ZWxlbmd0aCA8IFZpc2libGVDb2xvci5NSU5fV0FWRUxFTkdUSCApIHsgLy8gSVJcbiAgICAgIGNvbG9yID0gQ29sb3IudG9Db2xvciggb3B0aW9ucy5pckNvbG9yICk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCB3YXZlbGVuZ3RoID4gVmlzaWJsZUNvbG9yLk1BWF9XQVZFTEVOR1RIICkgeyAvLyBVVlxuICAgICAgY29sb3IgPSBDb2xvci50b0NvbG9yKCBvcHRpb25zLnV2Q29sb3IgKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGxvb2sgdXAgdmlzaWJsZSBjb2xvclxuICAgICAgY29uc3QgY29sb3JUYWJsZSA9IGdldENvbG9yVGFibGUoIG9wdGlvbnMucmVkdWNlSW50ZW5zaXR5QXRFeHRyZW1hICk7XG4gICAgICBjb2xvciA9IGNvbG9yVGFibGVbIFV0aWxzLnJvdW5kU3ltbWV0cmljKCB3YXZlbGVuZ3RoICkgLSBWaXNpYmxlQ29sb3IuTUlOX1dBVkVMRU5HVEggXTtcbiAgICB9XG5cbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBjb2xvciwgYGNvbG9yIG5vdCBmb3VuZCBmb3Igd2F2ZWxlbmd0aCAke3dhdmVsZW5ndGh9YCApO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBmcmVxdWVuY3kgKGluIEh6KSB0byBhIHZpc2libGUgY29sb3IuXG4gICAqL1xuICBmcmVxdWVuY3lUb0NvbG9yOiBmdW5jdGlvbiggZnJlcXVlbmN5OiBudW1iZXIsIHByb3ZpZGVkT3B0aW9ucz86IFdhdmVsZW5ndGhUb0NvbG9yT3B0aW9ucyApOiBDb2xvciB7XG4gICAgY29uc3Qgd2F2ZWxlbmd0aEluTWV0ZXJzID0gU1BFRURfT0ZfTElHSFQgLyBmcmVxdWVuY3k7XG4gICAgY29uc3Qgd2F2ZWxlbmd0aEluTmFub21ldGVycyA9IHdhdmVsZW5ndGhJbk1ldGVycyAqIDFFOTtcbiAgICByZXR1cm4gVmlzaWJsZUNvbG9yLndhdmVsZW5ndGhUb0NvbG9yKCB3YXZlbGVuZ3RoSW5OYW5vbWV0ZXJzLCBwcm92aWRlZE9wdGlvbnMgKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBDb2xvciB0byBpdHMgY29ycmVzcG9uZGluZyB3YXZlbGVuZ3RoLiBSZWxpZXMgb24gYSBjb2xvciBsb29rdXAgdGFibGUgdGhhdCBpcyBpbml0aWFsaXplZCB0aGUgZmlyc3RcbiAgICogdGltZSB0aGF0IHRoaXMgbWV0aG9kIGlzIGNhbGxlZC4gIENvbG9yIGxvb2t1cCBpcyBiYXNlZCBvbiBSR0IgY29tcG9uZW50IHZhbHVlOyB0aGUgYWxwaGEgdmFsdWUgaXMgaWdub3JlZC5cbiAgICovXG4gIGNvbG9yVG9XYXZlbGVuZ3RoOiBmdW5jdGlvbiggY29sb3I6IFRDb2xvclN1YnNldCwgcmVkdWNlSW50ZW5zaXR5QXRFeHRyZW1hID0gdHJ1ZSApOiBudW1iZXIge1xuXG4gICAgY29sb3IgPSBDb2xvci50b0NvbG9yKCBjb2xvciApO1xuXG4gICAgbGV0IHdhdmVsZW5ndGggPSAtMTtcblxuICAgIGlmICggY29sb3IuZXF1YWxzKCBDb2xvci5XSElURSApICkge1xuICAgICAgd2F2ZWxlbmd0aCA9IFZpc2libGVDb2xvci5XSElURV9XQVZFTEVOR1RIO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbG9yVGFibGUgPSBnZXRDb2xvclRhYmxlKCByZWR1Y2VJbnRlbnNpdHlBdEV4dHJlbWEgKTtcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGNvbG9yVGFibGUubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGlmICggTWF0aC5hYnMoIGNvbG9yLmdldFJlZCgpIC0gY29sb3JUYWJsZVsgaSBdLmdldFJlZCgpICkgPCBDT0xPUl9NQVRDSF9ERUxUQSAmJlxuICAgICAgICAgICAgIE1hdGguYWJzKCBjb2xvci5nZXRHcmVlbigpIC0gY29sb3JUYWJsZVsgaSBdLmdldEdyZWVuKCkgKSA8IENPTE9SX01BVENIX0RFTFRBICYmXG4gICAgICAgICAgICAgTWF0aC5hYnMoIGNvbG9yLmdldEJsdWUoKSAtIGNvbG9yVGFibGVbIGkgXS5nZXRCbHVlKCkgKSA8IENPTE9SX01BVENIX0RFTFRBICkge1xuICAgICAgICAgIHdhdmVsZW5ndGggPSBWaXNpYmxlQ29sb3IuTUlOX1dBVkVMRU5HVEggKyBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggd2F2ZWxlbmd0aCAhPT0gLTEsIGBubyB3YXZlbGVuZ3RoIGZvdW5kIGZvciBjb2xvciAke2NvbG9yLnRvU3RyaW5nKCl9YCApO1xuICAgIHJldHVybiB3YXZlbGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyB0aGUgc3BlY2lmaWVkIHdhdmVsZW5ndGggaW4gdGhlIHZpc2libGUgc3BlY3RydW0/XG4gICAqL1xuICBpc1Zpc2libGVXYXZlbGVuZ3RoKCB3YXZlbGVuZ3RoOiBudW1iZXIgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHdhdmVsZW5ndGggPj0gVmlzaWJsZUNvbG9yLk1JTl9XQVZFTEVOR1RIICYmIHdhdmVsZW5ndGggPD0gVmlzaWJsZUNvbG9yLk1BWF9XQVZFTEVOR1RIO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0YWJsZSB0aGF0IGlzIHVzZWQgdG8gbWFwIHdhdmVsZW5ndGggKGluIG5tKSB0byBDb2xvci5cbiAqIEBwYXJhbSByZWR1Y2VJbnRlbnNpdHlBdEV4dHJlbWEgLSB3aGV0aGVyIHRoZSBpbnRlbnNpdHkgc2hvdWxkIGJlIHJlZHVjZWQgYXQgaGlnaCBhbmQgbG93IHdhdmVsZW5ndGhzLFxuICogICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3dhdmUtaW50ZXJmZXJlbmNlL2lzc3Vlcy8zOTVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JUYWJsZSggcmVkdWNlSW50ZW5zaXR5QXRFeHRyZW1hOiBib29sZWFuICk6IENvbG9yW10ge1xuXG4gIGNvbnN0IGNvbG9yVGFibGUgPSBbXTtcblxuICAvLyBBbGxvY2F0ZSB0aGUgbG9va3VwIHRhYmxlXG4gIGNvbnN0IG51bVdhdmVsZW5ndGhzID0gTWF0aC5mbG9vciggVmlzaWJsZUNvbG9yLk1BWF9XQVZFTEVOR1RIIC0gVmlzaWJsZUNvbG9yLk1JTl9XQVZFTEVOR1RIICsgMSApO1xuXG4gIC8vIFBvcHVsYXRlIHRoZSBsb29rdXAgdGFibGVcbiAgbGV0IHdhdmVsZW5ndGg7XG4gIGxldCByO1xuICBsZXQgZztcbiAgbGV0IGI7XG4gIGZvciAoIGxldCBpID0gMDsgaSA8IG51bVdhdmVsZW5ndGhzOyBpKysgKSB7XG5cbiAgICAvLyBDcmVhdGUgdGhlIFJHQiBjb21wb25lbnQgdmFsdWVzLlxuICAgIHdhdmVsZW5ndGggPSBWaXNpYmxlQ29sb3IuTUlOX1dBVkVMRU5HVEggKyBpO1xuICAgIHIgPSBnID0gYiA9IDA7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIFJHQiBjb21wb25lbnQgdmFsdWVzLlxuICAgIGlmICggd2F2ZWxlbmd0aCA+PSAzODAgJiYgd2F2ZWxlbmd0aCA8PSA0NDAgKSB7XG4gICAgICByID0gLTEgKiAoIHdhdmVsZW5ndGggLSA0NDAgKSAvICggNDQwIC0gMzgwICk7XG4gICAgICBnID0gMDtcbiAgICAgIGIgPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmICggd2F2ZWxlbmd0aCA+IDQ0MCAmJiB3YXZlbGVuZ3RoIDw9IDQ5MCApIHtcbiAgICAgIHIgPSAwO1xuICAgICAgZyA9ICggd2F2ZWxlbmd0aCAtIDQ0MCApIC8gKCA0OTAgLSA0NDAgKTtcbiAgICAgIGIgPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmICggd2F2ZWxlbmd0aCA+IDQ5MCAmJiB3YXZlbGVuZ3RoIDw9IDUxMCApIHtcbiAgICAgIHIgPSAwO1xuICAgICAgZyA9IDE7XG4gICAgICBiID0gLTEgKiAoIHdhdmVsZW5ndGggLSA1MTAgKSAvICggNTEwIC0gNDkwICk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCB3YXZlbGVuZ3RoID4gNTEwICYmIHdhdmVsZW5ndGggPD0gNTgwICkge1xuICAgICAgciA9ICggd2F2ZWxlbmd0aCAtIDUxMCApIC8gKCA1ODAgLSA1MTAgKTtcbiAgICAgIGcgPSAxO1xuICAgICAgYiA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKCB3YXZlbGVuZ3RoID4gNTgwICYmIHdhdmVsZW5ndGggPD0gNjQ1ICkge1xuICAgICAgciA9IDE7XG4gICAgICBnID0gLTEgKiAoIHdhdmVsZW5ndGggLSA2NDUgKSAvICggNjQ1IC0gNTgwICk7XG4gICAgICBiID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIHdhdmVsZW5ndGggPiA2NDUgJiYgd2F2ZWxlbmd0aCA8PSA3ODAgKSB7XG4gICAgICByID0gMTtcbiAgICAgIGcgPSAwO1xuICAgICAgYiA9IDA7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBpbnRlbnNpdHkgZmFsbCBvZmYgbmVhciB0aGUgdmlzaW9uIGxpbWl0cy5cbiAgICBsZXQgaW50ZW5zaXR5O1xuICAgIGlmICggcmVkdWNlSW50ZW5zaXR5QXRFeHRyZW1hICYmIHdhdmVsZW5ndGggPiA2NDUgKSB7XG4gICAgICBpbnRlbnNpdHkgPSAwLjMgKyAwLjcgKiAoIDc4MCAtIHdhdmVsZW5ndGggKSAvICggNzgwIC0gNjQ1ICk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCByZWR1Y2VJbnRlbnNpdHlBdEV4dHJlbWEgJiYgd2F2ZWxlbmd0aCA8IDQyMCApIHtcbiAgICAgIGludGVuc2l0eSA9IDAuMyArIDAuNyAqICggd2F2ZWxlbmd0aCAtIDM4MCApIC8gKCA0MjAgLSAzODAgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnRlbnNpdHkgPSAxO1xuICAgIH1cbiAgICBjb25zdCByZWQgPSBVdGlscy5yb3VuZFN5bW1ldHJpYyggMjU1ICogKCBpbnRlbnNpdHkgKiByICkgKTtcbiAgICBjb25zdCBncmVlbiA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCAyNTUgKiAoIGludGVuc2l0eSAqIGcgKSApO1xuICAgIGNvbnN0IGJsdWUgPSBVdGlscy5yb3VuZFN5bW1ldHJpYyggMjU1ICogKCBpbnRlbnNpdHkgKiBiICkgKTtcbiAgICBjb25zdCBhbHBoYSA9IDE7XG5cbiAgICAvLyBBZGQgdGhlIGNvbG9yIHRvIHRoZSBsb29rdXAgYXJyYXkuXG4gICAgY29sb3JUYWJsZVsgaSBdID0gbmV3IENvbG9yKCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSApO1xuICB9XG5cbiAgcmV0dXJuIGNvbG9yVGFibGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGljaCBjb2xvciB0YWJsZSB0byB1c2UgYmFzZWQgb24gdGhlIG9wdGlvbnMuICBUaGlzIGFzc3VtZXMgb3B0aW9ucyBoYXZlIGJlZW4gZmlsbGVkIGluIGJ5IHRoZSBjYWxsXG4gKiBzaXRlLCBoZW5jZSB1c2VzIGNvbmZpZyBpbnN0ZWFkIG9mIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldENvbG9yVGFibGUoIHJlZHVjZUludGVuc2l0eUF0RXh0cmVtYTogYm9vbGVhbiApOiBDb2xvcltdIHtcbiAgaWYgKCByZWR1Y2VJbnRlbnNpdHlBdEV4dHJlbWEgKSB7XG5cbiAgICAvLyBjYWNoZSBmb3IgZnV0dXJlIHVzZVxuICAgIFJFRFVDRURfSU5URU5TSVRZX0NPTE9SX1RBQkxFID0gUkVEVUNFRF9JTlRFTlNJVFlfQ09MT1JfVEFCTEUgfHwgY3JlYXRlQ29sb3JUYWJsZSggdHJ1ZSApO1xuICAgIHJldHVybiBSRURVQ0VEX0lOVEVOU0lUWV9DT0xPUl9UQUJMRTtcbiAgfVxuICBlbHNlIHtcblxuICAgIC8vIGNhY2hlIGZvciBmdXR1cmUgdXNlXG4gICAgRlVMTF9JTlRFTlNJVFlfQ09MT1JfVEFCTEUgPSBGVUxMX0lOVEVOU0lUWV9DT0xPUl9UQUJMRSB8fCBjcmVhdGVDb2xvclRhYmxlKCBmYWxzZSApO1xuICAgIHJldHVybiBGVUxMX0lOVEVOU0lUWV9DT0xPUl9UQUJMRTtcbiAgfVxufVxuXG5zY2VuZXJ5UGhldC5yZWdpc3RlciggJ1Zpc2libGVDb2xvcicsIFZpc2libGVDb2xvciApO1xuZXhwb3J0IGRlZmF1bHQgVmlzaWJsZUNvbG9yOyJdLCJuYW1lcyI6WyJVdGlscyIsIm9wdGlvbml6ZSIsIkNvbG9yIiwic2NlbmVyeVBoZXQiLCJDT0xPUl9NQVRDSF9ERUxUQSIsIlNQRUVEX09GX0xJR0hUIiwiVklPTEVUX1dBVkVMRU5HVEgiLCJSRURfV0FWRUxFTkdUSCIsIlJFRFVDRURfSU5URU5TSVRZX0NPTE9SX1RBQkxFIiwiRlVMTF9JTlRFTlNJVFlfQ09MT1JfVEFCTEUiLCJWaXNpYmxlQ29sb3IiLCJNSU5fV0FWRUxFTkdUSCIsIk1BWF9XQVZFTEVOR1RIIiwiTUlOX0ZSRVFVRU5DWSIsIk1BWF9GUkVRVUVOQ1kiLCJXSElURV9XQVZFTEVOR1RIIiwid2F2ZWxlbmd0aFRvQ29sb3IiLCJ3YXZlbGVuZ3RoIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImlyQ29sb3IiLCJ1dkNvbG9yIiwicmVkdWNlSW50ZW5zaXR5QXRFeHRyZW1hIiwiY29sb3IiLCJXSElURSIsInRvQ29sb3IiLCJjb2xvclRhYmxlIiwiZ2V0Q29sb3JUYWJsZSIsInJvdW5kU3ltbWV0cmljIiwiYXNzZXJ0IiwiZnJlcXVlbmN5VG9Db2xvciIsImZyZXF1ZW5jeSIsIndhdmVsZW5ndGhJbk1ldGVycyIsIndhdmVsZW5ndGhJbk5hbm9tZXRlcnMiLCJjb2xvclRvV2F2ZWxlbmd0aCIsImVxdWFscyIsImkiLCJsZW5ndGgiLCJNYXRoIiwiYWJzIiwiZ2V0UmVkIiwiZ2V0R3JlZW4iLCJnZXRCbHVlIiwidG9TdHJpbmciLCJpc1Zpc2libGVXYXZlbGVuZ3RoIiwiY3JlYXRlQ29sb3JUYWJsZSIsIm51bVdhdmVsZW5ndGhzIiwiZmxvb3IiLCJyIiwiZyIsImIiLCJpbnRlbnNpdHkiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJhbHBoYSIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7Ozs7O0NBUUMsR0FFRCxPQUFPQSxXQUFXLHdCQUF3QjtBQUMxQyxPQUFPQyxlQUFlLGtDQUFrQztBQUN4RCxTQUFTQyxLQUFLLFFBQVEsOEJBQThCO0FBQ3BELE9BQU9DLGlCQUFpQixtQkFBbUI7QUFFM0MsWUFBWTtBQUNaLE1BQU1DLG9CQUFvQixHQUFHLGlGQUFpRjtBQUM5RyxNQUFNQyxpQkFBaUIsV0FBVyxxQ0FBcUM7QUFFdkUsTUFBTUMsb0JBQW9CLEtBQUssS0FBSztBQUNwQyxNQUFNQyxpQkFBaUIsS0FBSyxLQUFLO0FBRWpDLCtFQUErRTtBQUMvRSxJQUFJQyxnQ0FBZ0Q7QUFDcEQsSUFBSUMsNkJBQTZDO0FBV2pELE1BQU1DLGVBQWU7SUFFbkIsbUJBQW1CO0lBQ25CQyxnQkFBZ0JMO0lBQ2hCTSxnQkFBZ0JMO0lBQ2hCTSxlQUFlUixpQkFBaUJFLGlCQUFpQjtJQUNqRE8sZUFBZVQsaUJBQWlCQyxvQkFBb0I7SUFDcERELGdCQUFnQkE7SUFDaEJVLGtCQUFrQjtJQUVsQjs7R0FFQyxHQUNEQyxtQkFBbUIsU0FBVUMsVUFBa0IsRUFBRUMsZUFBMEM7UUFFekYsTUFBTUMsVUFBVWxCLFlBQXVDO1lBQ3JEbUIsU0FBUztZQUNUQyxTQUFTO1lBQ1RDLDBCQUEwQjtRQUM1QixHQUFHSjtRQUVILElBQUlLLFFBQVE7UUFDWixJQUFLTixlQUFlUCxhQUFhSyxnQkFBZ0IsRUFBRztZQUNsRFEsUUFBUXJCLE1BQU1zQixLQUFLO1FBQ3JCLE9BQ0ssSUFBS1AsYUFBYVAsYUFBYUMsY0FBYyxFQUFHO1lBQ25EWSxRQUFRckIsTUFBTXVCLE9BQU8sQ0FBRU4sUUFBUUMsT0FBTztRQUN4QyxPQUNLLElBQUtILGFBQWFQLGFBQWFFLGNBQWMsRUFBRztZQUNuRFcsUUFBUXJCLE1BQU11QixPQUFPLENBQUVOLFFBQVFFLE9BQU87UUFDeEMsT0FDSztZQUNILE1BQU1LLGFBQWFDLGNBQWVSLFFBQVFHLHdCQUF3QjtZQUNsRUMsUUFBUUcsVUFBVSxDQUFFMUIsTUFBTTRCLGNBQWMsQ0FBRVgsY0FBZVAsYUFBYUMsY0FBYyxDQUFFO1FBQ3hGO1FBRUFrQixVQUFVQSxPQUFRTixPQUFPLENBQUMsK0JBQStCLEVBQUVOLFlBQVk7UUFDdkUsT0FBT007SUFDVDtJQUVBOztHQUVDLEdBQ0RPLGtCQUFrQixTQUFVQyxTQUFpQixFQUFFYixlQUEwQztRQUN2RixNQUFNYyxxQkFBcUIzQixpQkFBaUIwQjtRQUM1QyxNQUFNRSx5QkFBeUJELHFCQUFxQjtRQUNwRCxPQUFPdEIsYUFBYU0saUJBQWlCLENBQUVpQix3QkFBd0JmO0lBQ2pFO0lBRUE7OztHQUdDLEdBQ0RnQixtQkFBbUIsU0FBVVgsS0FBbUIsRUFBRUQsMkJBQTJCLElBQUk7UUFFL0VDLFFBQVFyQixNQUFNdUIsT0FBTyxDQUFFRjtRQUV2QixJQUFJTixhQUFhLENBQUM7UUFFbEIsSUFBS00sTUFBTVksTUFBTSxDQUFFakMsTUFBTXNCLEtBQUssR0FBSztZQUNqQ1AsYUFBYVAsYUFBYUssZ0JBQWdCO1FBQzVDLE9BQ0s7WUFDSCxNQUFNVyxhQUFhQyxjQUFlTDtZQUNsQyxJQUFNLElBQUljLElBQUksR0FBR0EsSUFBSVYsV0FBV1csTUFBTSxFQUFFRCxJQUFNO2dCQUM1QyxJQUFLRSxLQUFLQyxHQUFHLENBQUVoQixNQUFNaUIsTUFBTSxLQUFLZCxVQUFVLENBQUVVLEVBQUcsQ0FBQ0ksTUFBTSxNQUFPcEMscUJBQ3hEa0MsS0FBS0MsR0FBRyxDQUFFaEIsTUFBTWtCLFFBQVEsS0FBS2YsVUFBVSxDQUFFVSxFQUFHLENBQUNLLFFBQVEsTUFBT3JDLHFCQUM1RGtDLEtBQUtDLEdBQUcsQ0FBRWhCLE1BQU1tQixPQUFPLEtBQUtoQixVQUFVLENBQUVVLEVBQUcsQ0FBQ00sT0FBTyxNQUFPdEMsbUJBQW9CO29CQUNqRmEsYUFBYVAsYUFBYUMsY0FBYyxHQUFHeUI7b0JBQzNDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBUCxVQUFVQSxPQUFRWixlQUFlLENBQUMsR0FBRyxDQUFDLDhCQUE4QixFQUFFTSxNQUFNb0IsUUFBUSxJQUFJO1FBQ3hGLE9BQU8xQjtJQUNUO0lBRUE7O0dBRUMsR0FDRDJCLHFCQUFxQjNCLFVBQWtCO1FBQ3JDLE9BQU9BLGNBQWNQLGFBQWFDLGNBQWMsSUFBSU0sY0FBY1AsYUFBYUUsY0FBYztJQUMvRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNpQyxpQkFBa0J2Qix3QkFBaUM7SUFFMUQsTUFBTUksYUFBYSxFQUFFO0lBRXJCLDRCQUE0QjtJQUM1QixNQUFNb0IsaUJBQWlCUixLQUFLUyxLQUFLLENBQUVyQyxhQUFhRSxjQUFjLEdBQUdGLGFBQWFDLGNBQWMsR0FBRztJQUUvRiw0QkFBNEI7SUFDNUIsSUFBSU07SUFDSixJQUFJK0I7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBTSxJQUFJZCxJQUFJLEdBQUdBLElBQUlVLGdCQUFnQlYsSUFBTTtRQUV6QyxtQ0FBbUM7UUFDbkNuQixhQUFhUCxhQUFhQyxjQUFjLEdBQUd5QjtRQUMzQ1ksSUFBSUMsSUFBSUMsSUFBSTtRQUVaLHNDQUFzQztRQUN0QyxJQUFLakMsY0FBYyxPQUFPQSxjQUFjLEtBQU07WUFDNUMrQixJQUFJLENBQUMsSUFBTS9CLENBQUFBLGFBQWEsR0FBRSxJQUFRLENBQUEsTUFBTSxHQUFFO1lBQzFDZ0MsSUFBSTtZQUNKQyxJQUFJO1FBQ04sT0FDSyxJQUFLakMsYUFBYSxPQUFPQSxjQUFjLEtBQU07WUFDaEQrQixJQUFJO1lBQ0pDLElBQUksQUFBRWhDLENBQUFBLGFBQWEsR0FBRSxJQUFRLENBQUEsTUFBTSxHQUFFO1lBQ3JDaUMsSUFBSTtRQUNOLE9BQ0ssSUFBS2pDLGFBQWEsT0FBT0EsY0FBYyxLQUFNO1lBQ2hEK0IsSUFBSTtZQUNKQyxJQUFJO1lBQ0pDLElBQUksQ0FBQyxJQUFNakMsQ0FBQUEsYUFBYSxHQUFFLElBQVEsQ0FBQSxNQUFNLEdBQUU7UUFDNUMsT0FDSyxJQUFLQSxhQUFhLE9BQU9BLGNBQWMsS0FBTTtZQUNoRCtCLElBQUksQUFBRS9CLENBQUFBLGFBQWEsR0FBRSxJQUFRLENBQUEsTUFBTSxHQUFFO1lBQ3JDZ0MsSUFBSTtZQUNKQyxJQUFJO1FBQ04sT0FDSyxJQUFLakMsYUFBYSxPQUFPQSxjQUFjLEtBQU07WUFDaEQrQixJQUFJO1lBQ0pDLElBQUksQ0FBQyxJQUFNaEMsQ0FBQUEsYUFBYSxHQUFFLElBQVEsQ0FBQSxNQUFNLEdBQUU7WUFDMUNpQyxJQUFJO1FBQ04sT0FDSyxJQUFLakMsYUFBYSxPQUFPQSxjQUFjLEtBQU07WUFDaEQrQixJQUFJO1lBQ0pDLElBQUk7WUFDSkMsSUFBSTtRQUNOO1FBRUEscURBQXFEO1FBQ3JELElBQUlDO1FBQ0osSUFBSzdCLDRCQUE0QkwsYUFBYSxLQUFNO1lBQ2xEa0MsWUFBWSxNQUFNLE1BQVEsQ0FBQSxNQUFNbEMsVUFBUyxJQUFRLENBQUEsTUFBTSxHQUFFO1FBQzNELE9BQ0ssSUFBS0ssNEJBQTRCTCxhQUFhLEtBQU07WUFDdkRrQyxZQUFZLE1BQU0sTUFBUWxDLENBQUFBLGFBQWEsR0FBRSxJQUFRLENBQUEsTUFBTSxHQUFFO1FBQzNELE9BQ0s7WUFDSGtDLFlBQVk7UUFDZDtRQUNBLE1BQU1DLE1BQU1wRCxNQUFNNEIsY0FBYyxDQUFFLE1BQVF1QixDQUFBQSxZQUFZSCxDQUFBQTtRQUN0RCxNQUFNSyxRQUFRckQsTUFBTTRCLGNBQWMsQ0FBRSxNQUFRdUIsQ0FBQUEsWUFBWUYsQ0FBQUE7UUFDeEQsTUFBTUssT0FBT3RELE1BQU00QixjQUFjLENBQUUsTUFBUXVCLENBQUFBLFlBQVlELENBQUFBO1FBQ3ZELE1BQU1LLFFBQVE7UUFFZCxxQ0FBcUM7UUFDckM3QixVQUFVLENBQUVVLEVBQUcsR0FBRyxJQUFJbEMsTUFBT2tELEtBQUtDLE9BQU9DLE1BQU1DO0lBQ2pEO0lBRUEsT0FBTzdCO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxjQUFlTCx3QkFBaUM7SUFDdkQsSUFBS0EsMEJBQTJCO1FBRTlCLHVCQUF1QjtRQUN2QmQsZ0NBQWdDQSxpQ0FBaUNxQyxpQkFBa0I7UUFDbkYsT0FBT3JDO0lBQ1QsT0FDSztRQUVILHVCQUF1QjtRQUN2QkMsNkJBQTZCQSw4QkFBOEJvQyxpQkFBa0I7UUFDN0UsT0FBT3BDO0lBQ1Q7QUFDRjtBQUVBTixZQUFZcUQsUUFBUSxDQUFFLGdCQUFnQjlDO0FBQ3RDLGVBQWVBLGFBQWEifQ==