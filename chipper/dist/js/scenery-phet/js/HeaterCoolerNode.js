// Copyright 2015-2024, University of Colorado Boulder
/**
 * This is the graphical representation of a stove that can be used to heat or cool things.  The HeaterCoolerNode is
 * composed of HeaterCoolerFront and HeaterCoolerBack so that objects can be layered inside of the heater to create a
 * 3D effect.  This is a convenience node that puts the back and the front together for cases where nothing other than
 * the flame and the ice needs to come out of the bucket.
 *
 * @author Siddhartha Chinthapally (Actual Concepts) on 20-11-2014.
 * @author Jesse Greenberg
 * @author Denzell Barnett (PhET Interactive Sims)
 * @author Chris Malley  (PixelZoom, Inc.)
 */ import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import optionize, { combineOptions } from '../../phet-core/js/optionize.js';
import { Node } from '../../scenery/js/imports.js';
import Tandem from '../../tandem/js/Tandem.js';
import HeaterCoolerBack from './HeaterCoolerBack.js';
import HeaterCoolerFront from './HeaterCoolerFront.js';
import sceneryPhet from './sceneryPhet.js';
let HeaterCoolerNode = class HeaterCoolerNode extends Node {
    dispose() {
        this.disposeHeaterCoolerNode();
        super.dispose();
    }
    /**
   * @param heatCoolAmountProperty +1 for max heating, -1 for max cooling, 0 for no change
   * @param providedOptions
   */ constructor(heatCoolAmountProperty, providedOptions){
        var _window_phet_chipper_queryParameters, _window_phet_chipper, _window_phet;
        super();
        const options = optionize()({
            // SelfOptions
            baseColor: HeaterCoolerFront.DEFAULT_BASE_COLOR,
            // NodeOptions
            tandem: Tandem.REQUIRED,
            tandemNameSuffix: 'HeaterCoolerNode'
        }, providedOptions);
        this.heatCoolAmountProperty = heatCoolAmountProperty;
        // Add the HeaterCoolerBack which contains the heater opening and the fire/ice images
        assert && assert(!options.backOptions || !options.backOptions.baseColor, 'HeaterCoolerNode sets baseColor for HeaterCoolerBack');
        const heaterCoolerBack = new HeaterCoolerBack(heatCoolAmountProperty, combineOptions({
            baseColor: options.baseColor
        }, options.backOptions));
        // Add the HeaterCoolerFront which contains the labels, stove body, and control slider.
        assert && assert(!options.frontOptions || !options.frontOptions.baseColor, 'HeaterCoolerNode sets baseColor for HeaterCoolerFront');
        const heaterCoolerFront = new HeaterCoolerFront(heatCoolAmountProperty, combineOptions({
            baseColor: options.baseColor,
            leftTop: heaterCoolerBack.getHeaterFrontPosition(),
            heaterCoolerBack: heaterCoolerBack,
            // HeaterCoolerFront can be instrumented as a composite in some usages. Here, HeaterCoolerNode is the composite, so
            // don't instrument the HeaterCoolerFront.
            phetioInstrument: false,
            tandem: options.tandem // Keep the same tandem so that things like slider are instrumented directly underneat this Node.
        }, options.frontOptions));
        this.slider = heaterCoolerFront.slider;
        options.children = [
            heaterCoolerBack,
            heaterCoolerFront
        ];
        this.mutate(options);
        this.disposeHeaterCoolerNode = function() {
            heaterCoolerBack.dispose();
            heaterCoolerFront.dispose();
        };
        // support for binder documentation, stripped out in builds and only runs when ?binder is specified
        assert && ((_window_phet = window.phet) == null ? void 0 : (_window_phet_chipper = _window_phet.chipper) == null ? void 0 : (_window_phet_chipper_queryParameters = _window_phet_chipper.queryParameters) == null ? void 0 : _window_phet_chipper_queryParameters.binder) && InstanceRegistry.registerDataURL('scenery-phet', 'HeaterCoolerNode', this);
    }
};
export { HeaterCoolerNode as default };
sceneryPhet.register('HeaterCoolerNode', HeaterCoolerNode);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9IZWF0ZXJDb29sZXJOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIHN0b3ZlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaGVhdCBvciBjb29sIHRoaW5ncy4gIFRoZSBIZWF0ZXJDb29sZXJOb2RlIGlzXG4gKiBjb21wb3NlZCBvZiBIZWF0ZXJDb29sZXJGcm9udCBhbmQgSGVhdGVyQ29vbGVyQmFjayBzbyB0aGF0IG9iamVjdHMgY2FuIGJlIGxheWVyZWQgaW5zaWRlIG9mIHRoZSBoZWF0ZXIgdG8gY3JlYXRlIGFcbiAqIDNEIGVmZmVjdC4gIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBub2RlIHRoYXQgcHV0cyB0aGUgYmFjayBhbmQgdGhlIGZyb250IHRvZ2V0aGVyIGZvciBjYXNlcyB3aGVyZSBub3RoaW5nIG90aGVyIHRoYW5cbiAqIHRoZSBmbGFtZSBhbmQgdGhlIGljZSBuZWVkcyB0byBjb21lIG91dCBvZiB0aGUgYnVja2V0LlxuICpcbiAqIEBhdXRob3IgU2lkZGhhcnRoYSBDaGludGhhcGFsbHkgKEFjdHVhbCBDb25jZXB0cykgb24gMjAtMTEtMjAxNC5cbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnXG4gKiBAYXV0aG9yIERlbnplbGwgQmFybmV0dCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW1zKVxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgIChQaXhlbFpvb20sIEluYy4pXG4gKi9cblxuaW1wb3J0IE51bWJlclByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvTnVtYmVyUHJvcGVydHkuanMnO1xuaW1wb3J0IEluc3RhbmNlUmVnaXN0cnkgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL2RvY3VtZW50YXRpb24vSW5zdGFuY2VSZWdpc3RyeS5qcyc7XG5pbXBvcnQgb3B0aW9uaXplLCB7IGNvbWJpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XG5pbXBvcnQgU3RyaWN0T21pdCBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvU3RyaWN0T21pdC5qcyc7XG5pbXBvcnQgeyBDb2xvciwgTm9kZSwgTm9kZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xuaW1wb3J0IFZTbGlkZXIgZnJvbSAnLi4vLi4vc3VuL2pzL1ZTbGlkZXIuanMnO1xuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcbmltcG9ydCBIZWF0ZXJDb29sZXJCYWNrLCB7IEhlYXRlckNvb2xlckJhY2tPcHRpb25zIH0gZnJvbSAnLi9IZWF0ZXJDb29sZXJCYWNrLmpzJztcbmltcG9ydCBIZWF0ZXJDb29sZXJGcm9udCwgeyBIZWF0ZXJDb29sZXJGcm9udE9wdGlvbnMgfSBmcm9tICcuL0hlYXRlckNvb2xlckZyb250LmpzJztcbmltcG9ydCBzY2VuZXJ5UGhldCBmcm9tICcuL3NjZW5lcnlQaGV0LmpzJztcblxudHlwZSBTZWxmT3B0aW9ucyA9IHtcblxuICAvLyBjb2xvciBvZiB0aGUgc3RvdmUgYm9keSwgYXBwbGllZCB0byBIZWF0ZXJDb29sZXJGcm9udCBhbmQgSGVhdGVyQ29vbGVyQmFja1xuICBiYXNlQ29sb3I/OiBDb2xvciB8IHN0cmluZztcblxuICAvLyBvcHRpb25zIHBhc3NlZCB0byBIZWF0ZXJDb29sZXJGcm9udFxuICBmcm9udE9wdGlvbnM/OiBIZWF0ZXJDb29sZXJGcm9udE9wdGlvbnM7XG5cbiAgLy8gb3B0aW9ucyBwYXNzZWQgdG8gSGVhdGVyQ29vbGVyQmFja1xuICBiYWNrT3B0aW9ucz86IEhlYXRlckNvb2xlckJhY2tPcHRpb25zO1xufTtcblxuZXhwb3J0IHR5cGUgSGVhdGVyQ29vbGVyTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFN0cmljdE9taXQ8Tm9kZU9wdGlvbnMsICdjaGlsZHJlbic+O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWF0ZXJDb29sZXJOb2RlIGV4dGVuZHMgTm9kZSB7XG5cbiAgcHVibGljIHJlYWRvbmx5IGhlYXRDb29sQW1vdW50UHJvcGVydHk6IE51bWJlclByb3BlcnR5O1xuXG4gIC8vIFdpdGggcHVibGljIHZpc2liaWxpdHkgYW5ub3RhdGlvbiBjb21lcyBncmVhdCBwb3dlciAtIHVzZSBpdCB3aXNlbHkuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS1waGV0L2lzc3Vlcy80NDJcbiAgcHVibGljIHJlYWRvbmx5IHNsaWRlcjogVlNsaWRlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VIZWF0ZXJDb29sZXJOb2RlOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gaGVhdENvb2xBbW91bnRQcm9wZXJ0eSArMSBmb3IgbWF4IGhlYXRpbmcsIC0xIGZvciBtYXggY29vbGluZywgMCBmb3Igbm8gY2hhbmdlXG4gICAqIEBwYXJhbSBwcm92aWRlZE9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggaGVhdENvb2xBbW91bnRQcm9wZXJ0eTogTnVtYmVyUHJvcGVydHksIHByb3ZpZGVkT3B0aW9ucz86IEhlYXRlckNvb2xlck5vZGVPcHRpb25zICkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEhlYXRlckNvb2xlck5vZGVPcHRpb25zLCBTdHJpY3RPbWl0PFNlbGZPcHRpb25zLCAnZnJvbnRPcHRpb25zJyB8ICdiYWNrT3B0aW9ucyc+LCBOb2RlT3B0aW9ucz4oKSgge1xuXG4gICAgICAvLyBTZWxmT3B0aW9uc1xuICAgICAgYmFzZUNvbG9yOiBIZWF0ZXJDb29sZXJGcm9udC5ERUZBVUxUX0JBU0VfQ09MT1IsXG5cbiAgICAgIC8vIE5vZGVPcHRpb25zXG4gICAgICB0YW5kZW06IFRhbmRlbS5SRVFVSVJFRCxcbiAgICAgIHRhbmRlbU5hbWVTdWZmaXg6ICdIZWF0ZXJDb29sZXJOb2RlJ1xuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xuXG4gICAgdGhpcy5oZWF0Q29vbEFtb3VudFByb3BlcnR5ID0gaGVhdENvb2xBbW91bnRQcm9wZXJ0eTtcblxuICAgIC8vIEFkZCB0aGUgSGVhdGVyQ29vbGVyQmFjayB3aGljaCBjb250YWlucyB0aGUgaGVhdGVyIG9wZW5pbmcgYW5kIHRoZSBmaXJlL2ljZSBpbWFnZXNcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhb3B0aW9ucy5iYWNrT3B0aW9ucyB8fCAhb3B0aW9ucy5iYWNrT3B0aW9ucy5iYXNlQ29sb3IsXG4gICAgICAnSGVhdGVyQ29vbGVyTm9kZSBzZXRzIGJhc2VDb2xvciBmb3IgSGVhdGVyQ29vbGVyQmFjaycgKTtcbiAgICBjb25zdCBoZWF0ZXJDb29sZXJCYWNrID0gbmV3IEhlYXRlckNvb2xlckJhY2soIGhlYXRDb29sQW1vdW50UHJvcGVydHksIGNvbWJpbmVPcHRpb25zPEhlYXRlckNvb2xlckJhY2tPcHRpb25zPigge1xuICAgICAgYmFzZUNvbG9yOiBvcHRpb25zLmJhc2VDb2xvclxuICAgIH0sIG9wdGlvbnMuYmFja09wdGlvbnMgKSApO1xuXG4gICAgLy8gQWRkIHRoZSBIZWF0ZXJDb29sZXJGcm9udCB3aGljaCBjb250YWlucyB0aGUgbGFiZWxzLCBzdG92ZSBib2R5LCBhbmQgY29udHJvbCBzbGlkZXIuXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMuZnJvbnRPcHRpb25zIHx8ICFvcHRpb25zLmZyb250T3B0aW9ucy5iYXNlQ29sb3IsXG4gICAgICAnSGVhdGVyQ29vbGVyTm9kZSBzZXRzIGJhc2VDb2xvciBmb3IgSGVhdGVyQ29vbGVyRnJvbnQnICk7XG4gICAgY29uc3QgaGVhdGVyQ29vbGVyRnJvbnQgPSBuZXcgSGVhdGVyQ29vbGVyRnJvbnQoIGhlYXRDb29sQW1vdW50UHJvcGVydHksIGNvbWJpbmVPcHRpb25zPEhlYXRlckNvb2xlckZyb250T3B0aW9ucz4oIHtcbiAgICAgIGJhc2VDb2xvcjogb3B0aW9ucy5iYXNlQ29sb3IsXG4gICAgICBsZWZ0VG9wOiBoZWF0ZXJDb29sZXJCYWNrLmdldEhlYXRlckZyb250UG9zaXRpb24oKSxcbiAgICAgIGhlYXRlckNvb2xlckJhY2s6IGhlYXRlckNvb2xlckJhY2ssXG5cbiAgICAgIC8vIEhlYXRlckNvb2xlckZyb250IGNhbiBiZSBpbnN0cnVtZW50ZWQgYXMgYSBjb21wb3NpdGUgaW4gc29tZSB1c2FnZXMuIEhlcmUsIEhlYXRlckNvb2xlck5vZGUgaXMgdGhlIGNvbXBvc2l0ZSwgc29cbiAgICAgIC8vIGRvbid0IGluc3RydW1lbnQgdGhlIEhlYXRlckNvb2xlckZyb250LlxuICAgICAgcGhldGlvSW5zdHJ1bWVudDogZmFsc2UsXG4gICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtIC8vIEtlZXAgdGhlIHNhbWUgdGFuZGVtIHNvIHRoYXQgdGhpbmdzIGxpa2Ugc2xpZGVyIGFyZSBpbnN0cnVtZW50ZWQgZGlyZWN0bHkgdW5kZXJuZWF0IHRoaXMgTm9kZS5cbiAgICB9LCBvcHRpb25zLmZyb250T3B0aW9ucyApICk7XG5cbiAgICB0aGlzLnNsaWRlciA9IGhlYXRlckNvb2xlckZyb250LnNsaWRlcjtcblxuICAgIG9wdGlvbnMuY2hpbGRyZW4gPSBbIGhlYXRlckNvb2xlckJhY2ssIGhlYXRlckNvb2xlckZyb250IF07XG5cbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xuXG4gICAgdGhpcy5kaXNwb3NlSGVhdGVyQ29vbGVyTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaGVhdGVyQ29vbGVyQmFjay5kaXNwb3NlKCk7XG4gICAgICBoZWF0ZXJDb29sZXJGcm9udC5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIC8vIHN1cHBvcnQgZm9yIGJpbmRlciBkb2N1bWVudGF0aW9uLCBzdHJpcHBlZCBvdXQgaW4gYnVpbGRzIGFuZCBvbmx5IHJ1bnMgd2hlbiA/YmluZGVyIGlzIHNwZWNpZmllZFxuICAgIGFzc2VydCAmJiB3aW5kb3cucGhldD8uY2hpcHBlcj8ucXVlcnlQYXJhbWV0ZXJzPy5iaW5kZXIgJiYgSW5zdGFuY2VSZWdpc3RyeS5yZWdpc3RlckRhdGFVUkwoICdzY2VuZXJ5LXBoZXQnLCAnSGVhdGVyQ29vbGVyTm9kZScsIHRoaXMgKTtcbiAgfVxuXG4gIHB1YmxpYyBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZUhlYXRlckNvb2xlck5vZGUoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbn1cblxuc2NlbmVyeVBoZXQucmVnaXN0ZXIoICdIZWF0ZXJDb29sZXJOb2RlJywgSGVhdGVyQ29vbGVyTm9kZSApOyJdLCJuYW1lcyI6WyJJbnN0YW5jZVJlZ2lzdHJ5Iiwib3B0aW9uaXplIiwiY29tYmluZU9wdGlvbnMiLCJOb2RlIiwiVGFuZGVtIiwiSGVhdGVyQ29vbGVyQmFjayIsIkhlYXRlckNvb2xlckZyb250Iiwic2NlbmVyeVBoZXQiLCJIZWF0ZXJDb29sZXJOb2RlIiwiZGlzcG9zZSIsImRpc3Bvc2VIZWF0ZXJDb29sZXJOb2RlIiwiaGVhdENvb2xBbW91bnRQcm9wZXJ0eSIsInByb3ZpZGVkT3B0aW9ucyIsIndpbmRvdyIsIm9wdGlvbnMiLCJiYXNlQ29sb3IiLCJERUZBVUxUX0JBU0VfQ09MT1IiLCJ0YW5kZW0iLCJSRVFVSVJFRCIsInRhbmRlbU5hbWVTdWZmaXgiLCJhc3NlcnQiLCJiYWNrT3B0aW9ucyIsImhlYXRlckNvb2xlckJhY2siLCJmcm9udE9wdGlvbnMiLCJoZWF0ZXJDb29sZXJGcm9udCIsImxlZnRUb3AiLCJnZXRIZWF0ZXJGcm9udFBvc2l0aW9uIiwicGhldGlvSW5zdHJ1bWVudCIsInNsaWRlciIsImNoaWxkcmVuIiwibXV0YXRlIiwicGhldCIsImNoaXBwZXIiLCJxdWVyeVBhcmFtZXRlcnMiLCJiaW5kZXIiLCJyZWdpc3RlckRhdGFVUkwiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7Ozs7Ozs7O0NBVUMsR0FHRCxPQUFPQSxzQkFBc0IsdURBQXVEO0FBQ3BGLE9BQU9DLGFBQWFDLGNBQWMsUUFBUSxrQ0FBa0M7QUFFNUUsU0FBZ0JDLElBQUksUUFBcUIsOEJBQThCO0FBRXZFLE9BQU9DLFlBQVksNEJBQTRCO0FBQy9DLE9BQU9DLHNCQUFtRCx3QkFBd0I7QUFDbEYsT0FBT0MsdUJBQXFELHlCQUF5QjtBQUNyRixPQUFPQyxpQkFBaUIsbUJBQW1CO0FBZ0I1QixJQUFBLEFBQU1DLG1CQUFOLE1BQU1BLHlCQUF5Qkw7SUFpRTVCTSxVQUFnQjtRQUM5QixJQUFJLENBQUNDLHVCQUF1QjtRQUM1QixLQUFLLENBQUNEO0lBQ1I7SUExREE7OztHQUdDLEdBQ0QsWUFBb0JFLHNCQUFzQyxFQUFFQyxlQUF5QyxDQUFHO1lBZ0Q1RkMsc0NBQUFBLHNCQUFBQTtRQS9DVixLQUFLO1FBRUwsTUFBTUMsVUFBVWIsWUFBNEc7WUFFMUgsY0FBYztZQUNkYyxXQUFXVCxrQkFBa0JVLGtCQUFrQjtZQUUvQyxjQUFjO1lBQ2RDLFFBQVFiLE9BQU9jLFFBQVE7WUFDdkJDLGtCQUFrQjtRQUNwQixHQUFHUDtRQUVILElBQUksQ0FBQ0Qsc0JBQXNCLEdBQUdBO1FBRTlCLHFGQUFxRjtRQUNyRlMsVUFBVUEsT0FBUSxDQUFDTixRQUFRTyxXQUFXLElBQUksQ0FBQ1AsUUFBUU8sV0FBVyxDQUFDTixTQUFTLEVBQ3RFO1FBQ0YsTUFBTU8sbUJBQW1CLElBQUlqQixpQkFBa0JNLHdCQUF3QlQsZUFBeUM7WUFDOUdhLFdBQVdELFFBQVFDLFNBQVM7UUFDOUIsR0FBR0QsUUFBUU8sV0FBVztRQUV0Qix1RkFBdUY7UUFDdkZELFVBQVVBLE9BQVEsQ0FBQ04sUUFBUVMsWUFBWSxJQUFJLENBQUNULFFBQVFTLFlBQVksQ0FBQ1IsU0FBUyxFQUN4RTtRQUNGLE1BQU1TLG9CQUFvQixJQUFJbEIsa0JBQW1CSyx3QkFBd0JULGVBQTBDO1lBQ2pIYSxXQUFXRCxRQUFRQyxTQUFTO1lBQzVCVSxTQUFTSCxpQkFBaUJJLHNCQUFzQjtZQUNoREosa0JBQWtCQTtZQUVsQixtSEFBbUg7WUFDbkgsMENBQTBDO1lBQzFDSyxrQkFBa0I7WUFDbEJWLFFBQVFILFFBQVFHLE1BQU0sQ0FBQyxpR0FBaUc7UUFDMUgsR0FBR0gsUUFBUVMsWUFBWTtRQUV2QixJQUFJLENBQUNLLE1BQU0sR0FBR0osa0JBQWtCSSxNQUFNO1FBRXRDZCxRQUFRZSxRQUFRLEdBQUc7WUFBRVA7WUFBa0JFO1NBQW1CO1FBRTFELElBQUksQ0FBQ00sTUFBTSxDQUFFaEI7UUFFYixJQUFJLENBQUNKLHVCQUF1QixHQUFHO1lBQzdCWSxpQkFBaUJiLE9BQU87WUFDeEJlLGtCQUFrQmYsT0FBTztRQUMzQjtRQUVBLG1HQUFtRztRQUNuR1csWUFBVVAsZUFBQUEsT0FBT2tCLElBQUksc0JBQVhsQix1QkFBQUEsYUFBYW1CLE9BQU8sc0JBQXBCbkIsdUNBQUFBLHFCQUFzQm9CLGVBQWUscUJBQXJDcEIscUNBQXVDcUIsTUFBTSxLQUFJbEMsaUJBQWlCbUMsZUFBZSxDQUFFLGdCQUFnQixvQkFBb0IsSUFBSTtJQUN2STtBQU1GO0FBckVBLFNBQXFCM0IsOEJBcUVwQjtBQUVERCxZQUFZNkIsUUFBUSxDQUFFLG9CQUFvQjVCIn0=