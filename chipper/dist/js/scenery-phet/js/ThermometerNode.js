// Copyright 2014-2024, University of Colorado Boulder
/**
 * Thermometer node, see https://github.com/phetsims/scenery-phet/issues/43
 *
 * @author Aaron Davis
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */ import DerivedProperty from '../../axon/js/DerivedProperty.js';
import LinearFunction from '../../dot/js/LinearFunction.js';
import Range from '../../dot/js/Range.js';
import Utils from '../../dot/js/Utils.js';
import { Shape } from '../../kite/js/imports.js';
import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import optionize from '../../phet-core/js/optionize.js';
import { LinearGradient, Node, Path, Rectangle } from '../../scenery/js/imports.js';
import NullableIO from '../../tandem/js/types/NullableIO.js';
import NumberIO from '../../tandem/js/types/NumberIO.js';
import sceneryPhet from './sceneryPhet.js';
import ShadedSphereNode from './ShadedSphereNode.js';
const FLUID_OVERLAP = 1; // overlap of fluid in tube and bulb, to hide seam
// center of the bulb is at (0,0), let the client code move to the correct position
const BULB_CENTER_X = 0;
const BULB_CENTER_Y = 0;
let ThermometerNode = class ThermometerNode extends Node {
    dispose() {
        this.disposeThermometerNode();
        super.dispose();
    }
    /**
   * Get y position at temperature to allow accurate tick placement
   * @param temperature - temperature at which to find y position, null is treated as the provided minTemperature
   */ temperatureToYPos(temperature) {
        // treat null as zero - this is a "legacy requirement", needed by the States of Matter sims
        const compensatedTemperature = temperature === null ? 0 : temperature;
        return this.temperatureLinearFunction.evaluate(compensatedTemperature);
    }
    /**
   * Get temperature at y position to allow temperature thumb mapping
   * @param y - y position on thermometer node
   */ yPosToTemperature(y) {
        return this.temperatureLinearFunction.inverse(y);
    }
    /**
   * @param temperatureProperty - null means there is no temperature to measure, treated as minTemperature
   * @param minTemperature
   * @param maxTemperature
   * @param [providedOptions?]
   */ constructor(temperatureProperty, minTemperature, maxTemperature, providedOptions){
        var _options_tandem, _window_phet_chipper_queryParameters, _window_phet_chipper, _window_phet;
        const options = optionize()({
            bulbDiameter: 50,
            tubeWidth: 30,
            tubeHeight: 100,
            lineWidth: 4,
            outlineStroke: 'black',
            tickSpacing: 15,
            tickSpacingTemperature: null,
            majorTickLength: 15,
            minorTickLength: 7.5,
            glassThickness: 4,
            zeroLevel: 'bulbCenter',
            backgroundFill: null,
            // all the default colors are shades of red
            fluidMainColor: '#850e0e',
            fluidHighlightColor: '#ff7575',
            fluidRightSideColor: '#c41515'
        }, providedOptions);
        super();
        const thermometerRange = new Range(minTemperature, maxTemperature);
        // Create a shaded sphere to act as the bulb fluid
        const bulbFluidDiameter = options.bulbDiameter - options.glassThickness - options.lineWidth / 2;
        const bulbFluidNode = new ShadedSphereNode(bulbFluidDiameter, {
            centerX: BULB_CENTER_X,
            centerY: BULB_CENTER_Y,
            mainColor: options.fluidMainColor,
            highlightColor: options.fluidHighlightColor,
            highlightXOffset: -0.2,
            highlightYOffset: 0.2,
            rotation: Math.PI / 2
        });
        // Angles for the outline of the bulb
        const bulbStartAngle = -Math.acos(options.tubeWidth / options.bulbDiameter);
        const bulbEndAngle = Math.PI - bulbStartAngle;
        // Create the outline for the thermometer, starting with the bulb
        const tubeTopRadius = options.tubeWidth / 2;
        const straightTubeHeight = options.tubeHeight - tubeTopRadius;
        const straightTubeTop = BULB_CENTER_Y - options.bulbDiameter / 2 - straightTubeHeight;
        const straightTubeLeft = BULB_CENTER_X - options.tubeWidth / 2;
        const outlineShape = new Shape().arc(BULB_CENTER_X, BULB_CENTER_Y, options.bulbDiameter / 2, bulbStartAngle, bulbEndAngle) // bulb at bottom
        .arc(BULB_CENTER_X, straightTubeTop, tubeTopRadius, Math.PI, 0) // rounded top of tube
        .close();
        const outlineNode = new Path(outlineShape, {
            stroke: options.outlineStroke,
            lineWidth: options.lineWidth
        });
        assert && assert(outlineNode.height === options.tubeHeight + options.bulbDiameter + options.lineWidth); // see scenery-phet#136
        const tubeFluidWidth = options.tubeWidth - options.glassThickness - options.lineWidth / 2;
        const tubeFluidRadius = tubeFluidWidth / 2;
        const clipBulbRadius = (options.bulbDiameter - options.glassThickness - options.lineWidth / 2) / 2;
        const clipStartAngle = -Math.acos(tubeFluidRadius / clipBulbRadius);
        const clipEndAngle = Math.PI - clipStartAngle;
        const tubeFluidBottom = bulbFluidDiameter / 2 * Math.sin(clipEndAngle);
        const tubeFluidLeft = -tubeFluidRadius;
        // Clip area for the fluid in the tube, round at the top
        const fluidClipArea = new Shape().moveTo(tubeFluidLeft, tubeFluidBottom + FLUID_OVERLAP).arc(BULB_CENTER_X, straightTubeTop, tubeFluidRadius, Math.PI, 0) // round top
        .lineTo(-tubeFluidLeft, tubeFluidBottom + FLUID_OVERLAP).close();
        // Clip the top of the bulb so it's flat where it connects to the tube
        const bulbFluidClipArea = Shape.rectangle(tubeFluidBottom, BULB_CENTER_Y - options.bulbDiameter / 2, options.bulbDiameter, options.bulbDiameter);
        bulbFluidNode.setClipArea(bulbFluidClipArea);
        // Gradient for fluid in tube
        const tubeFluidGradient = new LinearGradient(tubeFluidLeft, 0, tubeFluidLeft + tubeFluidWidth, 0).addColorStop(0, options.fluidMainColor).addColorStop(0.4, options.fluidHighlightColor).addColorStop(0.5, options.fluidHighlightColor).addColorStop(1, options.fluidMainColor);
        // Fluid in the tube (correct size set later)
        const tubeFluidNode = new Rectangle(0, 0, tubeFluidWidth, 0, {
            fill: tubeFluidGradient,
            clipArea: fluidClipArea
        });
        // override tick spacing options when using tickSpacingTemperature
        let offset = options.tickSpacing; // distance between position of minTemp and first tick
        let minorOffset = 0; // bool (as number) indicating where first minor tick is placed
        if (options.tickSpacingTemperature !== null) {
            const scaleTempY = (options.tubeHeight + options.lineWidth) / (maxTemperature - minTemperature);
            const offsetTemp = options.tickSpacingTemperature - minTemperature % options.tickSpacingTemperature;
            offset = offsetTemp * scaleTempY;
            minorOffset = (minTemperature + offsetTemp) % (options.tickSpacingTemperature * 2) % 2;
            options.tickSpacing = options.tickSpacingTemperature * scaleTempY;
        }
        // tick marks, from bottom up, alternating major and minor ticks
        for(let i = 0; i * options.tickSpacing + offset <= options.tubeHeight - tubeTopRadius / 3; i++){
            outlineShape.moveTo(straightTubeLeft, tubeFluidBottom - i * options.tickSpacing - offset);
            outlineShape.horizontalLineTo(straightTubeLeft + (i % 2 === minorOffset ? options.minorTickLength : options.majorTickLength));
        }
        // Background inside the tube
        if (options.backgroundFill) {
            this.addChild(new Path(outlineShape, {
                fill: options.backgroundFill
            }));
        }
        // Add other nodes after optional background
        this.addChild(tubeFluidNode);
        this.addChild(bulbFluidNode);
        this.addChild(outlineNode);
        // Temperature determines the height of the fluid in the tube
        const maxFluidHeight = new Path(fluidClipArea).height;
        let minFluidHeight;
        if (options.zeroLevel === 'bulbCenter') {
            minFluidHeight = 0;
        } else if (options.zeroLevel === 'bulbTop') {
            minFluidHeight = -tubeFluidBottom;
        } else {
            throw new Error(`Invalid zeroLevel: ${options.zeroLevel}`);
        }
        this.temperatureLinearFunction = new LinearFunction(minTemperature, maxTemperature, minFluidHeight, maxFluidHeight + minFluidHeight);
        const temperaturePropertyObserver = (temperature)=>{
            const fluidHeight = this.temperatureToYPos(temperature);
            tubeFluidNode.visible = fluidHeight > 0;
            tubeFluidNode.setRect(tubeFluidLeft, tubeFluidBottom - fluidHeight + minFluidHeight, tubeFluidWidth, fluidHeight + FLUID_OVERLAP);
        };
        temperatureProperty.link(temperaturePropertyObserver);
        const percentProperty = new DerivedProperty([
            temperatureProperty
        ], (temp)=>{
            return temp === null ? 0 : thermometerRange.getNormalizedValue(Utils.clamp(temp, thermometerRange.min, thermometerRange.max)) * 100;
        }, {
            tandem: (_options_tandem = options.tandem) == null ? void 0 : _options_tandem.createTandem('percentProperty'),
            phetioDocumentation: 'the percentage of the thermometer that is filled by the current temperature. If temperature is null, then percent will be 0',
            phetioValueType: NullableIO(NumberIO)
        });
        this.mutate(options);
        this.disposeThermometerNode = ()=>{
            if (temperatureProperty.hasListener(temperaturePropertyObserver)) {
                temperatureProperty.unlink(temperaturePropertyObserver);
            }
            percentProperty.dispose();
        };
        // support for binder documentation, stripped out in builds and only runs when ?binder is specified
        assert && ((_window_phet = window.phet) == null ? void 0 : (_window_phet_chipper = _window_phet.chipper) == null ? void 0 : (_window_phet_chipper_queryParameters = _window_phet_chipper.queryParameters) == null ? void 0 : _window_phet_chipper_queryParameters.binder) && InstanceRegistry.registerDataURL('scenery-phet', 'ThermometerNode', this);
    }
};
export { ThermometerNode as default };
sceneryPhet.register('ThermometerNode', ThermometerNode);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9UaGVybW9tZXRlck5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogVGhlcm1vbWV0ZXIgbm9kZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5LXBoZXQvaXNzdWVzLzQzXG4gKlxuICogQGF1dGhvciBBYXJvbiBEYXZpc1xuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXG4gKi9cblxuaW1wb3J0IERlcml2ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgTGluZWFyRnVuY3Rpb24gZnJvbSAnLi4vLi4vZG90L2pzL0xpbmVhckZ1bmN0aW9uLmpzJztcbmltcG9ydCBSYW5nZSBmcm9tICcuLi8uLi9kb3QvanMvUmFuZ2UuanMnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XG5pbXBvcnQgSW5zdGFuY2VSZWdpc3RyeSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvZG9jdW1lbnRhdGlvbi9JbnN0YW5jZVJlZ2lzdHJ5LmpzJztcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XG5pbXBvcnQgeyBMaW5lYXJHcmFkaWVudCwgTm9kZSwgTm9kZU9wdGlvbnMsIFBhdGgsIFJlY3RhbmdsZSwgVENvbG9yIH0gZnJvbSAnLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcbmltcG9ydCBOdWxsYWJsZUlPIGZyb20gJy4uLy4uL3RhbmRlbS9qcy90eXBlcy9OdWxsYWJsZUlPLmpzJztcbmltcG9ydCBOdW1iZXJJTyBmcm9tICcuLi8uLi90YW5kZW0vanMvdHlwZXMvTnVtYmVySU8uanMnO1xuaW1wb3J0IHNjZW5lcnlQaGV0IGZyb20gJy4vc2NlbmVyeVBoZXQuanMnO1xuaW1wb3J0IFNoYWRlZFNwaGVyZU5vZGUgZnJvbSAnLi9TaGFkZWRTcGhlcmVOb2RlLmpzJztcblxuY29uc3QgRkxVSURfT1ZFUkxBUCA9IDE7IC8vIG92ZXJsYXAgb2YgZmx1aWQgaW4gdHViZSBhbmQgYnVsYiwgdG8gaGlkZSBzZWFtXG5cbi8vIGNlbnRlciBvZiB0aGUgYnVsYiBpcyBhdCAoMCwwKSwgbGV0IHRoZSBjbGllbnQgY29kZSBtb3ZlIHRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG5jb25zdCBCVUxCX0NFTlRFUl9YID0gMDtcbmNvbnN0IEJVTEJfQ0VOVEVSX1kgPSAwO1xuXG50eXBlIFplcm9MZXZlbCA9ICdidWxiQ2VudGVyJyB8ICdidWxiVG9wJztcblxudHlwZSBTZWxmT3B0aW9ucyA9IHtcbiAgYnVsYkRpYW1ldGVyPzogbnVtYmVyO1xuICB0dWJlV2lkdGg/OiBudW1iZXI7XG4gIHR1YmVIZWlnaHQ/OiBudW1iZXI7XG4gIGxpbmVXaWR0aD86IG51bWJlcjtcbiAgb3V0bGluZVN0cm9rZT86IFRDb2xvcjtcbiAgdGlja1NwYWNpbmc/OiBudW1iZXI7XG5cbiAgLy8gb3ZlcnJpZGVzIHRpY2tTcGFjaW5nIHRvIHNwYWNlIHRpY2tzIGJ5IHVuaXRzIG9mIHRlbXBlcmF0dXJlXG4gIHRpY2tTcGFjaW5nVGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuICBtYWpvclRpY2tMZW5ndGg/OiBudW1iZXI7XG4gIG1pbm9yVGlja0xlbmd0aD86IG51bWJlcjtcblxuICAvLyBzcGFjZSBiZXR3ZWVuIHRoZSB0aGVybW9tZXRlciBvdXRsaW5lIGFuZCB0aGUgZmx1aWQgaW5zaWRlIGl0XG4gIGdsYXNzVGhpY2tuZXNzPzogbnVtYmVyO1xuXG4gIC8vIGRlZmluZXMgd2hlcmUgbGV2ZWwgaXMgYXQgdGVtcGVyYXR1cmUgemVybyAtICdidWxiQ2VudGVyJyBvciAnYnVsYlRvcCdcbiAgemVyb0xldmVsPzogWmVyb0xldmVsO1xuXG4gIC8vIGxlYXZlIGFzIG51bGwgdG8gaGF2ZSBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQuIElmIGEgY29sb3IgaXMgZ2l2ZW4sIHRoZW4gYW4gZXh0cmEgUmVjdGFuZ2xlIGlzIGNyZWF0ZWQgZm9yIHRoZSBiYWNrZ3JvdW5kXG4gIGJhY2tncm91bmRGaWxsPzogVENvbG9yO1xuXG4gIC8vIHRoZSBtYWluIGNvbG9yIG9mIHRoZSBidWxiIGZsdWlkLCBhbmQgdGhlIGxlZnQgc2lkZSBvZiB0aGUgdHViZSBncmFkaWVudFxuICBmbHVpZE1haW5Db2xvcj86IFRDb2xvcjtcblxuICAvLyB0aGUgaGlnaGxpZ2h0IGNvbG9yIG9mIHRoZSBidWxiIGZsdWlkIGFuZCB0aGUgbWlkZGxlIG9mIHRoZSB0dWJlIGdyYWRpZW50XG4gIGZsdWlkSGlnaGxpZ2h0Q29sb3I/OiBUQ29sb3I7XG5cbiAgLy8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHR1YmUgZ3JhZGllbnQsIG5vdCB1c2VkIGN1cnJlbnRseVxuICBmbHVpZFJpZ2h0U2lkZUNvbG9yPzogVENvbG9yO1xufTtcblxuZXhwb3J0IHR5cGUgVGhlcm1vbWV0ZXJOb2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgTm9kZU9wdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRoZXJtb21ldGVyTm9kZSBleHRlbmRzIE5vZGUge1xuICBwcml2YXRlIHJlYWRvbmx5IHRlbXBlcmF0dXJlTGluZWFyRnVuY3Rpb246IExpbmVhckZ1bmN0aW9uO1xuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VUaGVybW9tZXRlck5vZGU6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB0ZW1wZXJhdHVyZVByb3BlcnR5IC0gbnVsbCBtZWFucyB0aGVyZSBpcyBubyB0ZW1wZXJhdHVyZSB0byBtZWFzdXJlLCB0cmVhdGVkIGFzIG1pblRlbXBlcmF0dXJlXG4gICAqIEBwYXJhbSBtaW5UZW1wZXJhdHVyZVxuICAgKiBAcGFyYW0gbWF4VGVtcGVyYXR1cmVcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnM/XVxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKCB0ZW1wZXJhdHVyZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiwgbWluVGVtcGVyYXR1cmU6IG51bWJlciwgbWF4VGVtcGVyYXR1cmU6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBUaGVybW9tZXRlck5vZGVPcHRpb25zICkge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxUaGVybW9tZXRlck5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgTm9kZU9wdGlvbnM+KCkoIHtcbiAgICAgIGJ1bGJEaWFtZXRlcjogNTAsXG4gICAgICB0dWJlV2lkdGg6IDMwLFxuICAgICAgdHViZUhlaWdodDogMTAwLFxuICAgICAgbGluZVdpZHRoOiA0LFxuICAgICAgb3V0bGluZVN0cm9rZTogJ2JsYWNrJyxcbiAgICAgIHRpY2tTcGFjaW5nOiAxNSxcbiAgICAgIHRpY2tTcGFjaW5nVGVtcGVyYXR1cmU6IG51bGwsXG4gICAgICBtYWpvclRpY2tMZW5ndGg6IDE1LFxuICAgICAgbWlub3JUaWNrTGVuZ3RoOiA3LjUsXG4gICAgICBnbGFzc1RoaWNrbmVzczogNCxcbiAgICAgIHplcm9MZXZlbDogJ2J1bGJDZW50ZXInLFxuICAgICAgYmFja2dyb3VuZEZpbGw6IG51bGwsXG5cbiAgICAgIC8vIGFsbCB0aGUgZGVmYXVsdCBjb2xvcnMgYXJlIHNoYWRlcyBvZiByZWRcbiAgICAgIGZsdWlkTWFpbkNvbG9yOiAnIzg1MGUwZScsXG4gICAgICBmbHVpZEhpZ2hsaWdodENvbG9yOiAnI2ZmNzU3NScsXG4gICAgICBmbHVpZFJpZ2h0U2lkZUNvbG9yOiAnI2M0MTUxNSdcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCB0aGVybW9tZXRlclJhbmdlID0gbmV3IFJhbmdlKCBtaW5UZW1wZXJhdHVyZSwgbWF4VGVtcGVyYXR1cmUgKTtcblxuICAgIC8vIENyZWF0ZSBhIHNoYWRlZCBzcGhlcmUgdG8gYWN0IGFzIHRoZSBidWxiIGZsdWlkXG4gICAgY29uc3QgYnVsYkZsdWlkRGlhbWV0ZXIgPSBvcHRpb25zLmJ1bGJEaWFtZXRlciAtIG9wdGlvbnMuZ2xhc3NUaGlja25lc3MgLSBvcHRpb25zLmxpbmVXaWR0aCAvIDI7XG4gICAgY29uc3QgYnVsYkZsdWlkTm9kZSA9IG5ldyBTaGFkZWRTcGhlcmVOb2RlKCBidWxiRmx1aWREaWFtZXRlciwge1xuICAgICAgY2VudGVyWDogQlVMQl9DRU5URVJfWCxcbiAgICAgIGNlbnRlclk6IEJVTEJfQ0VOVEVSX1ksXG4gICAgICBtYWluQ29sb3I6IG9wdGlvbnMuZmx1aWRNYWluQ29sb3IsXG4gICAgICBoaWdobGlnaHRDb2xvcjogb3B0aW9ucy5mbHVpZEhpZ2hsaWdodENvbG9yLFxuICAgICAgaGlnaGxpZ2h0WE9mZnNldDogLTAuMixcbiAgICAgIGhpZ2hsaWdodFlPZmZzZXQ6IDAuMixcbiAgICAgIHJvdGF0aW9uOiBNYXRoLlBJIC8gMlxuICAgIH0gKTtcblxuICAgIC8vIEFuZ2xlcyBmb3IgdGhlIG91dGxpbmUgb2YgdGhlIGJ1bGJcbiAgICBjb25zdCBidWxiU3RhcnRBbmdsZSA9IC1NYXRoLmFjb3MoIG9wdGlvbnMudHViZVdpZHRoIC8gb3B0aW9ucy5idWxiRGlhbWV0ZXIgKTtcbiAgICBjb25zdCBidWxiRW5kQW5nbGUgPSBNYXRoLlBJIC0gYnVsYlN0YXJ0QW5nbGU7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG91dGxpbmUgZm9yIHRoZSB0aGVybW9tZXRlciwgc3RhcnRpbmcgd2l0aCB0aGUgYnVsYlxuICAgIGNvbnN0IHR1YmVUb3BSYWRpdXMgPSBvcHRpb25zLnR1YmVXaWR0aCAvIDI7XG4gICAgY29uc3Qgc3RyYWlnaHRUdWJlSGVpZ2h0ID0gb3B0aW9ucy50dWJlSGVpZ2h0IC0gdHViZVRvcFJhZGl1cztcbiAgICBjb25zdCBzdHJhaWdodFR1YmVUb3AgPSBCVUxCX0NFTlRFUl9ZIC0gKCBvcHRpb25zLmJ1bGJEaWFtZXRlciAvIDIgKSAtIHN0cmFpZ2h0VHViZUhlaWdodDtcbiAgICBjb25zdCBzdHJhaWdodFR1YmVMZWZ0ID0gQlVMQl9DRU5URVJfWCAtICggb3B0aW9ucy50dWJlV2lkdGggLyAyICk7XG5cbiAgICBjb25zdCBvdXRsaW5lU2hhcGUgPSBuZXcgU2hhcGUoKVxuICAgICAgLmFyYyggQlVMQl9DRU5URVJfWCwgQlVMQl9DRU5URVJfWSwgb3B0aW9ucy5idWxiRGlhbWV0ZXIgLyAyLCBidWxiU3RhcnRBbmdsZSwgYnVsYkVuZEFuZ2xlICkgLy8gYnVsYiBhdCBib3R0b21cbiAgICAgIC5hcmMoIEJVTEJfQ0VOVEVSX1gsIHN0cmFpZ2h0VHViZVRvcCwgdHViZVRvcFJhZGl1cywgTWF0aC5QSSwgMCApIC8vIHJvdW5kZWQgdG9wIG9mIHR1YmVcbiAgICAgIC5jbG9zZSgpO1xuXG4gICAgY29uc3Qgb3V0bGluZU5vZGUgPSBuZXcgUGF0aCggb3V0bGluZVNoYXBlLCB7XG4gICAgICBzdHJva2U6IG9wdGlvbnMub3V0bGluZVN0cm9rZSxcbiAgICAgIGxpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGhcbiAgICB9ICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3V0bGluZU5vZGUuaGVpZ2h0ID09PSBvcHRpb25zLnR1YmVIZWlnaHQgKyBvcHRpb25zLmJ1bGJEaWFtZXRlciArIG9wdGlvbnMubGluZVdpZHRoICk7IC8vIHNlZSBzY2VuZXJ5LXBoZXQjMTM2XG5cbiAgICBjb25zdCB0dWJlRmx1aWRXaWR0aCA9IG9wdGlvbnMudHViZVdpZHRoIC0gb3B0aW9ucy5nbGFzc1RoaWNrbmVzcyAtIG9wdGlvbnMubGluZVdpZHRoIC8gMjtcbiAgICBjb25zdCB0dWJlRmx1aWRSYWRpdXMgPSB0dWJlRmx1aWRXaWR0aCAvIDI7XG4gICAgY29uc3QgY2xpcEJ1bGJSYWRpdXMgPSAoIG9wdGlvbnMuYnVsYkRpYW1ldGVyIC0gb3B0aW9ucy5nbGFzc1RoaWNrbmVzcyAtIG9wdGlvbnMubGluZVdpZHRoIC8gMiApIC8gMjtcbiAgICBjb25zdCBjbGlwU3RhcnRBbmdsZSA9IC1NYXRoLmFjb3MoIHR1YmVGbHVpZFJhZGl1cyAvIGNsaXBCdWxiUmFkaXVzICk7XG4gICAgY29uc3QgY2xpcEVuZEFuZ2xlID0gTWF0aC5QSSAtIGNsaXBTdGFydEFuZ2xlO1xuICAgIGNvbnN0IHR1YmVGbHVpZEJvdHRvbSA9ICggYnVsYkZsdWlkRGlhbWV0ZXIgLyAyICkgKiBNYXRoLnNpbiggY2xpcEVuZEFuZ2xlICk7XG4gICAgY29uc3QgdHViZUZsdWlkTGVmdCA9IC10dWJlRmx1aWRSYWRpdXM7XG5cbiAgICAvLyBDbGlwIGFyZWEgZm9yIHRoZSBmbHVpZCBpbiB0aGUgdHViZSwgcm91bmQgYXQgdGhlIHRvcFxuICAgIGNvbnN0IGZsdWlkQ2xpcEFyZWEgPSBuZXcgU2hhcGUoKVxuICAgICAgLm1vdmVUbyggdHViZUZsdWlkTGVmdCwgdHViZUZsdWlkQm90dG9tICsgRkxVSURfT1ZFUkxBUCApXG4gICAgICAuYXJjKCBCVUxCX0NFTlRFUl9YLCBzdHJhaWdodFR1YmVUb3AsIHR1YmVGbHVpZFJhZGl1cywgTWF0aC5QSSwgMCApIC8vIHJvdW5kIHRvcFxuICAgICAgLmxpbmVUbyggLXR1YmVGbHVpZExlZnQsIHR1YmVGbHVpZEJvdHRvbSArIEZMVUlEX09WRVJMQVAgKVxuICAgICAgLmNsb3NlKCk7XG5cbiAgICAvLyBDbGlwIHRoZSB0b3Agb2YgdGhlIGJ1bGIgc28gaXQncyBmbGF0IHdoZXJlIGl0IGNvbm5lY3RzIHRvIHRoZSB0dWJlXG4gICAgY29uc3QgYnVsYkZsdWlkQ2xpcEFyZWEgPSBTaGFwZS5yZWN0YW5nbGUoXG4gICAgICB0dWJlRmx1aWRCb3R0b20sXG4gICAgICBCVUxCX0NFTlRFUl9ZIC0gb3B0aW9ucy5idWxiRGlhbWV0ZXIgLyAyLFxuICAgICAgb3B0aW9ucy5idWxiRGlhbWV0ZXIsXG4gICAgICBvcHRpb25zLmJ1bGJEaWFtZXRlclxuICAgICk7XG4gICAgYnVsYkZsdWlkTm9kZS5zZXRDbGlwQXJlYSggYnVsYkZsdWlkQ2xpcEFyZWEgKTtcblxuICAgIC8vIEdyYWRpZW50IGZvciBmbHVpZCBpbiB0dWJlXG4gICAgY29uc3QgdHViZUZsdWlkR3JhZGllbnQgPSBuZXcgTGluZWFyR3JhZGllbnQoIHR1YmVGbHVpZExlZnQsIDAsIHR1YmVGbHVpZExlZnQgKyB0dWJlRmx1aWRXaWR0aCwgMCApXG4gICAgICAuYWRkQ29sb3JTdG9wKCAwLCBvcHRpb25zLmZsdWlkTWFpbkNvbG9yIClcbiAgICAgIC5hZGRDb2xvclN0b3AoIDAuNCwgb3B0aW9ucy5mbHVpZEhpZ2hsaWdodENvbG9yIClcbiAgICAgIC5hZGRDb2xvclN0b3AoIDAuNSwgb3B0aW9ucy5mbHVpZEhpZ2hsaWdodENvbG9yIClcbiAgICAgIC5hZGRDb2xvclN0b3AoIDEsIG9wdGlvbnMuZmx1aWRNYWluQ29sb3IgKTtcblxuICAgIC8vIEZsdWlkIGluIHRoZSB0dWJlIChjb3JyZWN0IHNpemUgc2V0IGxhdGVyKVxuICAgIGNvbnN0IHR1YmVGbHVpZE5vZGUgPSBuZXcgUmVjdGFuZ2xlKCAwLCAwLCB0dWJlRmx1aWRXaWR0aCwgMCwge1xuICAgICAgZmlsbDogdHViZUZsdWlkR3JhZGllbnQsXG4gICAgICBjbGlwQXJlYTogZmx1aWRDbGlwQXJlYVxuICAgIH0gKTtcblxuICAgIC8vIG92ZXJyaWRlIHRpY2sgc3BhY2luZyBvcHRpb25zIHdoZW4gdXNpbmcgdGlja1NwYWNpbmdUZW1wZXJhdHVyZVxuICAgIGxldCBvZmZzZXQgPSBvcHRpb25zLnRpY2tTcGFjaW5nOyAvLyBkaXN0YW5jZSBiZXR3ZWVuIHBvc2l0aW9uIG9mIG1pblRlbXAgYW5kIGZpcnN0IHRpY2tcbiAgICBsZXQgbWlub3JPZmZzZXQgPSAwOyAvLyBib29sIChhcyBudW1iZXIpIGluZGljYXRpbmcgd2hlcmUgZmlyc3QgbWlub3IgdGljayBpcyBwbGFjZWRcbiAgICBpZiAoIG9wdGlvbnMudGlja1NwYWNpbmdUZW1wZXJhdHVyZSAhPT0gbnVsbCApIHtcbiAgICAgIGNvbnN0IHNjYWxlVGVtcFkgPSAoIG9wdGlvbnMudHViZUhlaWdodCArIG9wdGlvbnMubGluZVdpZHRoICkgLyAoIG1heFRlbXBlcmF0dXJlIC0gbWluVGVtcGVyYXR1cmUgKTtcbiAgICAgIGNvbnN0IG9mZnNldFRlbXAgPSBvcHRpb25zLnRpY2tTcGFjaW5nVGVtcGVyYXR1cmUgLSAoIG1pblRlbXBlcmF0dXJlICUgb3B0aW9ucy50aWNrU3BhY2luZ1RlbXBlcmF0dXJlICk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXRUZW1wICogc2NhbGVUZW1wWTtcbiAgICAgIG1pbm9yT2Zmc2V0ID0gKCAoIG1pblRlbXBlcmF0dXJlICsgb2Zmc2V0VGVtcCApICUgKCBvcHRpb25zLnRpY2tTcGFjaW5nVGVtcGVyYXR1cmUgKiAyICkgKSAlIDI7XG4gICAgICBvcHRpb25zLnRpY2tTcGFjaW5nID0gb3B0aW9ucy50aWNrU3BhY2luZ1RlbXBlcmF0dXJlICogc2NhbGVUZW1wWTtcbiAgICB9XG5cbiAgICAvLyB0aWNrIG1hcmtzLCBmcm9tIGJvdHRvbSB1cCwgYWx0ZXJuYXRpbmcgbWFqb3IgYW5kIG1pbm9yIHRpY2tzXG4gICAgZm9yICggbGV0IGkgPSAwOyBpICogb3B0aW9ucy50aWNrU3BhY2luZyArIG9mZnNldCA8PSBvcHRpb25zLnR1YmVIZWlnaHQgLSAoIHR1YmVUb3BSYWRpdXMgLyAzICk7IGkrKyApIHtcbiAgICAgIG91dGxpbmVTaGFwZS5tb3ZlVG8oXG4gICAgICAgIHN0cmFpZ2h0VHViZUxlZnQsXG4gICAgICAgIHR1YmVGbHVpZEJvdHRvbSAtICggaSAqIG9wdGlvbnMudGlja1NwYWNpbmcgKSAtIG9mZnNldFxuICAgICAgKTtcbiAgICAgIG91dGxpbmVTaGFwZS5ob3Jpem9udGFsTGluZVRvKFxuICAgICAgICBzdHJhaWdodFR1YmVMZWZ0ICsgKCAoIGkgJSAyID09PSBtaW5vck9mZnNldCApID8gb3B0aW9ucy5taW5vclRpY2tMZW5ndGggOiBvcHRpb25zLm1ham9yVGlja0xlbmd0aCApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJhY2tncm91bmQgaW5zaWRlIHRoZSB0dWJlXG4gICAgaWYgKCBvcHRpb25zLmJhY2tncm91bmRGaWxsICkge1xuICAgICAgdGhpcy5hZGRDaGlsZCggbmV3IFBhdGgoIG91dGxpbmVTaGFwZSwgeyBmaWxsOiBvcHRpb25zLmJhY2tncm91bmRGaWxsIH0gKSApO1xuICAgIH1cblxuICAgIC8vIEFkZCBvdGhlciBub2RlcyBhZnRlciBvcHRpb25hbCBiYWNrZ3JvdW5kXG4gICAgdGhpcy5hZGRDaGlsZCggdHViZUZsdWlkTm9kZSApO1xuICAgIHRoaXMuYWRkQ2hpbGQoIGJ1bGJGbHVpZE5vZGUgKTtcbiAgICB0aGlzLmFkZENoaWxkKCBvdXRsaW5lTm9kZSApO1xuXG4gICAgLy8gVGVtcGVyYXR1cmUgZGV0ZXJtaW5lcyB0aGUgaGVpZ2h0IG9mIHRoZSBmbHVpZCBpbiB0aGUgdHViZVxuICAgIGNvbnN0IG1heEZsdWlkSGVpZ2h0ID0gbmV3IFBhdGgoIGZsdWlkQ2xpcEFyZWEgKS5oZWlnaHQ7XG5cbiAgICBsZXQgbWluRmx1aWRIZWlnaHQ6IG51bWJlcjtcbiAgICBpZiAoIG9wdGlvbnMuemVyb0xldmVsID09PSAnYnVsYkNlbnRlcicgKSB7XG4gICAgICBtaW5GbHVpZEhlaWdodCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKCBvcHRpb25zLnplcm9MZXZlbCA9PT0gJ2J1bGJUb3AnICkge1xuICAgICAgbWluRmx1aWRIZWlnaHQgPSAtdHViZUZsdWlkQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggYEludmFsaWQgemVyb0xldmVsOiAke29wdGlvbnMuemVyb0xldmVsfWAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnRlbXBlcmF0dXJlTGluZWFyRnVuY3Rpb24gPSBuZXcgTGluZWFyRnVuY3Rpb24oXG4gICAgICBtaW5UZW1wZXJhdHVyZSxcbiAgICAgIG1heFRlbXBlcmF0dXJlLFxuICAgICAgbWluRmx1aWRIZWlnaHQsXG4gICAgICBtYXhGbHVpZEhlaWdodCArIG1pbkZsdWlkSGVpZ2h0XG4gICAgKTtcblxuICAgIGNvbnN0IHRlbXBlcmF0dXJlUHJvcGVydHlPYnNlcnZlciA9ICggdGVtcGVyYXR1cmU6IG51bWJlciB8IG51bGwgKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBmbHVpZEhlaWdodCA9IHRoaXMudGVtcGVyYXR1cmVUb1lQb3MoIHRlbXBlcmF0dXJlICk7XG4gICAgICB0dWJlRmx1aWROb2RlLnZpc2libGUgPSAoIGZsdWlkSGVpZ2h0ID4gMCApO1xuICAgICAgdHViZUZsdWlkTm9kZS5zZXRSZWN0KFxuICAgICAgICB0dWJlRmx1aWRMZWZ0LFxuICAgICAgICB0dWJlRmx1aWRCb3R0b20gLSBmbHVpZEhlaWdodCArIG1pbkZsdWlkSGVpZ2h0LFxuICAgICAgICB0dWJlRmx1aWRXaWR0aCxcbiAgICAgICAgZmx1aWRIZWlnaHQgKyBGTFVJRF9PVkVSTEFQXG4gICAgICApO1xuICAgIH07XG5cbiAgICB0ZW1wZXJhdHVyZVByb3BlcnR5LmxpbmsoIHRlbXBlcmF0dXJlUHJvcGVydHlPYnNlcnZlciApO1xuXG4gICAgY29uc3QgcGVyY2VudFByb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eSggWyB0ZW1wZXJhdHVyZVByb3BlcnR5IF0sIHRlbXAgPT4ge1xuICAgICAgcmV0dXJuIHRlbXAgPT09IG51bGwgPyAwIDpcbiAgICAgICAgICAgICB0aGVybW9tZXRlclJhbmdlLmdldE5vcm1hbGl6ZWRWYWx1ZSggVXRpbHMuY2xhbXAoIHRlbXAsIHRoZXJtb21ldGVyUmFuZ2UubWluLCB0aGVybW9tZXRlclJhbmdlLm1heCApICkgKiAxMDA7XG4gICAgfSwge1xuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbT8uY3JlYXRlVGFuZGVtKCAncGVyY2VudFByb3BlcnR5JyApLFxuICAgICAgcGhldGlvRG9jdW1lbnRhdGlvbjogJ3RoZSBwZXJjZW50YWdlIG9mIHRoZSB0aGVybW9tZXRlciB0aGF0IGlzIGZpbGxlZCBieSB0aGUgY3VycmVudCB0ZW1wZXJhdHVyZS4gSWYgdGVtcGVyYXR1cmUgaXMgbnVsbCwgdGhlbiBwZXJjZW50IHdpbGwgYmUgMCcsXG4gICAgICBwaGV0aW9WYWx1ZVR5cGU6IE51bGxhYmxlSU8oIE51bWJlcklPIClcbiAgICB9ICk7XG5cbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xuXG4gICAgdGhpcy5kaXNwb3NlVGhlcm1vbWV0ZXJOb2RlID0gKCkgPT4ge1xuICAgICAgaWYgKCB0ZW1wZXJhdHVyZVByb3BlcnR5Lmhhc0xpc3RlbmVyKCB0ZW1wZXJhdHVyZVByb3BlcnR5T2JzZXJ2ZXIgKSApIHtcbiAgICAgICAgdGVtcGVyYXR1cmVQcm9wZXJ0eS51bmxpbmsoIHRlbXBlcmF0dXJlUHJvcGVydHlPYnNlcnZlciApO1xuICAgICAgfVxuICAgICAgcGVyY2VudFByb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYmluZGVyIGRvY3VtZW50YXRpb24sIHN0cmlwcGVkIG91dCBpbiBidWlsZHMgYW5kIG9ubHkgcnVucyB3aGVuID9iaW5kZXIgaXMgc3BlY2lmaWVkXG4gICAgYXNzZXJ0ICYmIHdpbmRvdy5waGV0Py5jaGlwcGVyPy5xdWVyeVBhcmFtZXRlcnM/LmJpbmRlciAmJiBJbnN0YW5jZVJlZ2lzdHJ5LnJlZ2lzdGVyRGF0YVVSTCggJ3NjZW5lcnktcGhldCcsICdUaGVybW9tZXRlck5vZGUnLCB0aGlzICk7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpc3Bvc2VUaGVybW9tZXRlck5vZGUoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHkgcG9zaXRpb24gYXQgdGVtcGVyYXR1cmUgdG8gYWxsb3cgYWNjdXJhdGUgdGljayBwbGFjZW1lbnRcbiAgICogQHBhcmFtIHRlbXBlcmF0dXJlIC0gdGVtcGVyYXR1cmUgYXQgd2hpY2ggdG8gZmluZCB5IHBvc2l0aW9uLCBudWxsIGlzIHRyZWF0ZWQgYXMgdGhlIHByb3ZpZGVkIG1pblRlbXBlcmF0dXJlXG4gICAqL1xuICBwdWJsaWMgdGVtcGVyYXR1cmVUb1lQb3MoIHRlbXBlcmF0dXJlOiBudW1iZXIgfCBudWxsICk6IG51bWJlciB7XG5cbiAgICAvLyB0cmVhdCBudWxsIGFzIHplcm8gLSB0aGlzIGlzIGEgXCJsZWdhY3kgcmVxdWlyZW1lbnRcIiwgbmVlZGVkIGJ5IHRoZSBTdGF0ZXMgb2YgTWF0dGVyIHNpbXNcbiAgICBjb25zdCBjb21wZW5zYXRlZFRlbXBlcmF0dXJlID0gdGVtcGVyYXR1cmUgPT09IG51bGwgPyAwIDogdGVtcGVyYXR1cmU7XG5cbiAgICByZXR1cm4gdGhpcy50ZW1wZXJhdHVyZUxpbmVhckZ1bmN0aW9uLmV2YWx1YXRlKCBjb21wZW5zYXRlZFRlbXBlcmF0dXJlICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRlbXBlcmF0dXJlIGF0IHkgcG9zaXRpb24gdG8gYWxsb3cgdGVtcGVyYXR1cmUgdGh1bWIgbWFwcGluZ1xuICAgKiBAcGFyYW0geSAtIHkgcG9zaXRpb24gb24gdGhlcm1vbWV0ZXIgbm9kZVxuICAgKi9cbiAgcHVibGljIHlQb3NUb1RlbXBlcmF0dXJlKCB5OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wZXJhdHVyZUxpbmVhckZ1bmN0aW9uLmludmVyc2UoIHkgKTtcbiAgfVxufVxuXG5zY2VuZXJ5UGhldC5yZWdpc3RlciggJ1RoZXJtb21ldGVyTm9kZScsIFRoZXJtb21ldGVyTm9kZSApOyJdLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJMaW5lYXJGdW5jdGlvbiIsIlJhbmdlIiwiVXRpbHMiLCJTaGFwZSIsIkluc3RhbmNlUmVnaXN0cnkiLCJvcHRpb25pemUiLCJMaW5lYXJHcmFkaWVudCIsIk5vZGUiLCJQYXRoIiwiUmVjdGFuZ2xlIiwiTnVsbGFibGVJTyIsIk51bWJlcklPIiwic2NlbmVyeVBoZXQiLCJTaGFkZWRTcGhlcmVOb2RlIiwiRkxVSURfT1ZFUkxBUCIsIkJVTEJfQ0VOVEVSX1giLCJCVUxCX0NFTlRFUl9ZIiwiVGhlcm1vbWV0ZXJOb2RlIiwiZGlzcG9zZSIsImRpc3Bvc2VUaGVybW9tZXRlck5vZGUiLCJ0ZW1wZXJhdHVyZVRvWVBvcyIsInRlbXBlcmF0dXJlIiwiY29tcGVuc2F0ZWRUZW1wZXJhdHVyZSIsInRlbXBlcmF0dXJlTGluZWFyRnVuY3Rpb24iLCJldmFsdWF0ZSIsInlQb3NUb1RlbXBlcmF0dXJlIiwieSIsImludmVyc2UiLCJ0ZW1wZXJhdHVyZVByb3BlcnR5IiwibWluVGVtcGVyYXR1cmUiLCJtYXhUZW1wZXJhdHVyZSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJ3aW5kb3ciLCJidWxiRGlhbWV0ZXIiLCJ0dWJlV2lkdGgiLCJ0dWJlSGVpZ2h0IiwibGluZVdpZHRoIiwib3V0bGluZVN0cm9rZSIsInRpY2tTcGFjaW5nIiwidGlja1NwYWNpbmdUZW1wZXJhdHVyZSIsIm1ham9yVGlja0xlbmd0aCIsIm1pbm9yVGlja0xlbmd0aCIsImdsYXNzVGhpY2tuZXNzIiwiemVyb0xldmVsIiwiYmFja2dyb3VuZEZpbGwiLCJmbHVpZE1haW5Db2xvciIsImZsdWlkSGlnaGxpZ2h0Q29sb3IiLCJmbHVpZFJpZ2h0U2lkZUNvbG9yIiwidGhlcm1vbWV0ZXJSYW5nZSIsImJ1bGJGbHVpZERpYW1ldGVyIiwiYnVsYkZsdWlkTm9kZSIsImNlbnRlclgiLCJjZW50ZXJZIiwibWFpbkNvbG9yIiwiaGlnaGxpZ2h0Q29sb3IiLCJoaWdobGlnaHRYT2Zmc2V0IiwiaGlnaGxpZ2h0WU9mZnNldCIsInJvdGF0aW9uIiwiTWF0aCIsIlBJIiwiYnVsYlN0YXJ0QW5nbGUiLCJhY29zIiwiYnVsYkVuZEFuZ2xlIiwidHViZVRvcFJhZGl1cyIsInN0cmFpZ2h0VHViZUhlaWdodCIsInN0cmFpZ2h0VHViZVRvcCIsInN0cmFpZ2h0VHViZUxlZnQiLCJvdXRsaW5lU2hhcGUiLCJhcmMiLCJjbG9zZSIsIm91dGxpbmVOb2RlIiwic3Ryb2tlIiwiYXNzZXJ0IiwiaGVpZ2h0IiwidHViZUZsdWlkV2lkdGgiLCJ0dWJlRmx1aWRSYWRpdXMiLCJjbGlwQnVsYlJhZGl1cyIsImNsaXBTdGFydEFuZ2xlIiwiY2xpcEVuZEFuZ2xlIiwidHViZUZsdWlkQm90dG9tIiwic2luIiwidHViZUZsdWlkTGVmdCIsImZsdWlkQ2xpcEFyZWEiLCJtb3ZlVG8iLCJsaW5lVG8iLCJidWxiRmx1aWRDbGlwQXJlYSIsInJlY3RhbmdsZSIsInNldENsaXBBcmVhIiwidHViZUZsdWlkR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJ0dWJlRmx1aWROb2RlIiwiZmlsbCIsImNsaXBBcmVhIiwib2Zmc2V0IiwibWlub3JPZmZzZXQiLCJzY2FsZVRlbXBZIiwib2Zmc2V0VGVtcCIsImkiLCJob3Jpem9udGFsTGluZVRvIiwiYWRkQ2hpbGQiLCJtYXhGbHVpZEhlaWdodCIsIm1pbkZsdWlkSGVpZ2h0IiwiRXJyb3IiLCJ0ZW1wZXJhdHVyZVByb3BlcnR5T2JzZXJ2ZXIiLCJmbHVpZEhlaWdodCIsInZpc2libGUiLCJzZXRSZWN0IiwibGluayIsInBlcmNlbnRQcm9wZXJ0eSIsInRlbXAiLCJnZXROb3JtYWxpemVkVmFsdWUiLCJjbGFtcCIsIm1pbiIsIm1heCIsInRhbmRlbSIsImNyZWF0ZVRhbmRlbSIsInBoZXRpb0RvY3VtZW50YXRpb24iLCJwaGV0aW9WYWx1ZVR5cGUiLCJtdXRhdGUiLCJoYXNMaXN0ZW5lciIsInVubGluayIsInBoZXQiLCJjaGlwcGVyIiwicXVlcnlQYXJhbWV0ZXJzIiwiYmluZGVyIiwicmVnaXN0ZXJEYXRhVVJMIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7O0NBTUMsR0FFRCxPQUFPQSxxQkFBcUIsbUNBQW1DO0FBRS9ELE9BQU9DLG9CQUFvQixpQ0FBaUM7QUFDNUQsT0FBT0MsV0FBVyx3QkFBd0I7QUFDMUMsT0FBT0MsV0FBVyx3QkFBd0I7QUFDMUMsU0FBU0MsS0FBSyxRQUFRLDJCQUEyQjtBQUNqRCxPQUFPQyxzQkFBc0IsdURBQXVEO0FBQ3BGLE9BQU9DLGVBQWUsa0NBQWtDO0FBQ3hELFNBQVNDLGNBQWMsRUFBRUMsSUFBSSxFQUFlQyxJQUFJLEVBQUVDLFNBQVMsUUFBZ0IsOEJBQThCO0FBQ3pHLE9BQU9DLGdCQUFnQixzQ0FBc0M7QUFDN0QsT0FBT0MsY0FBYyxvQ0FBb0M7QUFDekQsT0FBT0MsaUJBQWlCLG1CQUFtQjtBQUMzQyxPQUFPQyxzQkFBc0Isd0JBQXdCO0FBRXJELE1BQU1DLGdCQUFnQixHQUFHLGtEQUFrRDtBQUUzRSxtRkFBbUY7QUFDbkYsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLGdCQUFnQjtBQXNDUCxJQUFBLEFBQU1DLGtCQUFOLE1BQU1BLHdCQUF3QlY7SUFtTTNCVyxVQUFnQjtRQUM5QixJQUFJLENBQUNDLHNCQUFzQjtRQUMzQixLQUFLLENBQUNEO0lBQ1I7SUFFQTs7O0dBR0MsR0FDRCxBQUFPRSxrQkFBbUJDLFdBQTBCLEVBQVc7UUFFN0QsMkZBQTJGO1FBQzNGLE1BQU1DLHlCQUF5QkQsZ0JBQWdCLE9BQU8sSUFBSUE7UUFFMUQsT0FBTyxJQUFJLENBQUNFLHlCQUF5QixDQUFDQyxRQUFRLENBQUVGO0lBQ2xEO0lBRUE7OztHQUdDLEdBQ0QsQUFBT0csa0JBQW1CQyxDQUFTLEVBQVc7UUFDNUMsT0FBTyxJQUFJLENBQUNILHlCQUF5QixDQUFDSSxPQUFPLENBQUVEO0lBQ2pEO0lBdE5BOzs7OztHQUtDLEdBQ0QsWUFBb0JFLG1CQUFx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