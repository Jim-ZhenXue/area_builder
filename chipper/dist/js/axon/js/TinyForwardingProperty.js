// Copyright 2020-2024, University of Colorado Boulder
/**
 * A lightweight version of Property (that satisfies some of the interface), meant for high-performance applications
 * where validation, phet-io support and other things are not needed. This includes additional logic for conditionally
 * forwarding to/from another Property.
 *
 * Please note that TinyForwardingProperty exclusively supports settable Properties
 * via its TypeScript implementation. If you want to use a read-only Property as the target, please type cast as settable
 * and use runtime assertions to ensure that the target (or this forwarding Property) are not set. See examples like
 * Node.setVisibleProperty.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import axon from './axon.js';
import Property from './Property.js';
import ReadOnlyProperty from './ReadOnlyProperty.js';
import TinyProperty from './TinyProperty.js';
import { isTReadOnlyProperty } from './TReadOnlyProperty.js';
let TinyForwardingProperty = class TinyForwardingProperty extends TinyProperty {
    // API support for setting a Property|ValueType onto the forwarding Property
    setValueOrTargetProperty(node, tandemName, newValueOrTargetProperty) {
        if (isTReadOnlyProperty(newValueOrTargetProperty)) {
            // As a new Property
            this.setTargetProperty(newValueOrTargetProperty, node, tandemName);
        } else {
            const oldValue = this.get();
            this.clearTargetProperty();
            assert && assert(!this.targetProperty, 'just cleared');
            // If we're switching away from a targetProperty, prefer no notification (so set our value to the last value)
            this.setPropertyValue(newValueOrTargetProperty);
            // Changing forwarding target COULD change the value, so send notifications if this is the case.
            if (!this.areValuesEqual(oldValue, newValueOrTargetProperty)) {
                this.notifyListeners(oldValue);
            }
        }
    }
    /**
   * Sets (or unsets if `null` is provided) the Property that we use for forwarding changes.
   *
   * @param newTargetProperty - null to "unset" forwarding.
   * @param node - (For phet-io support only):
   *               The container of TinyForwardingProperty which supports updateLinkedElementForProperty()
   * @param tandemName - null if the Property does not support PhET-iO instrumentation
   * @returns the passed in Node, for chaining.
   */ setTargetProperty(newTargetProperty, node = null, tandemName = null) {
        assert && node && tandemName === null && this.targetPropertyInstrumented && assert(!node.isPhetioInstrumented(), 'tandemName must be provided for instrumented Nodes');
        // no-op if we are already forwarding to that property OR if we still aren't forwarding
        if (this.targetProperty === newTargetProperty) {
            return node; // for chaining
        }
        const currentForwardingPropertyInstrumented = this.targetProperty && this.targetProperty instanceof ReadOnlyProperty && this.targetProperty.isPhetioInstrumented();
        assert && currentForwardingPropertyInstrumented && assert(newTargetProperty && newTargetProperty instanceof ReadOnlyProperty && newTargetProperty.isPhetioInstrumented(), 'Cannot set swap out a PhET-iO instrumented targetProperty for an uninstrumented one');
        // We need this information eagerly for later on in the function
        const previousTarget = this.targetProperty;
        // If we had the "default instrumented" Property, we'll remove that and then link our new Property. Guard on the fact
        // that ownedPhetioProperty is added via this exact method, see this.initializePhetio() for details
        // Do this before adding a PhET-iO LinkedElement because ownedPhetioProperty has the same phetioID as the LinkedElement
        if (this.ownedPhetioProperty && newTargetProperty !== this.ownedPhetioProperty) {
            this.disposeOwnedPhetioProperty();
        }
        node && tandemName !== null && node.updateLinkedElementForProperty(tandemName, previousTarget, newTargetProperty);
        const oldValue = this.get();
        this.clearTargetProperty();
        this.targetProperty = newTargetProperty;
        if (this.targetProperty) {
            assert && assert(this.forwardingListener, 'forwardingListener is not set yet');
            this.targetProperty.lazyLink(this.forwardingListener);
            this.setPropertyValue(this.targetProperty.value);
        } else {
            // If we're switching away from a targetProperty, prefer no notification (so set our value to the last value)
            this.setPropertyValue(oldValue);
        }
        // Changing forwarding target COULD change the value, so send notifications if this is the case.
        if (!this.areValuesEqual(oldValue, this.get())) {
            this.notifyListeners(oldValue);
        }
        return node; // for chaining
    }
    clearTargetProperty() {
        // Lazily set this value, it will be added as a listener to any targetProperty we have.
        this.forwardingListener = this.forwardingListener || this.onTargetPropertyChange.bind(this);
        if (this.targetProperty) {
            this.targetProperty.unlink(this.forwardingListener);
        }
        this.targetProperty = null;
    }
    /**
   * Notify this Property's listeners when the targetProperty changes.
   * For performance, keep this listener on the prototype.
   */ onTargetPropertyChange(value) {
        super.set(value);
    }
    /**
   * Sets the value and notifies listeners, unless deferred or disposed. You can also use the es5 getter
   * (property.value) but this means is provided for inner loops or internal code that must be fast. If the value
   * hasn't changed, this is a no-op.
   */ set(value) {
        if (this.targetProperty) {
            assert && assert(this.targetProperty.isSettable(), 'targetProperty must be settable');
            this.targetProperty.set(value);
        } else {
            super.set(value);
        }
        return this;
    }
    /**
   * Use this to automatically create a forwarded, PhET-iO instrumented Property owned by this TinyForwardingProperty.
   */ setTargetPropertyInstrumented(targetPropertyInstrumented, node) {
        // See Node.initializePhetioObject for more details on this assertion
        assert && assert(!node.isPhetioInstrumented(), 'this option only works if it is passed in before this Node is instrumented');
        this.targetPropertyInstrumented = targetPropertyInstrumented;
        return node;
    }
    getTargetPropertyInstrumented() {
        return this.targetPropertyInstrumented || false;
    }
    /**
   * @param node - the parent container that supports updateLinkedElementForProperty()
   * @param tandemName
   * @param createProperty - creates an "owned" Property
   */ initializePhetio(node, tandemName, createProperty) {
        assert && assert(!this.phetioInitialized, 'already initialized');
        assert && assert(!this.ownedPhetioProperty, 'Already created the ownedPhetioProperty');
        if (!this.targetProperty && this.targetPropertyInstrumented) {
            this.ownedPhetioProperty = createProperty();
            assert && assert(this.ownedPhetioProperty instanceof Property, 'The owned property should be an AXON/Property');
            assert && assert(this.ownedPhetioProperty instanceof ReadOnlyProperty && this.ownedPhetioProperty.isPhetioInstrumented(), 'The owned property should be PhET-iO instrumented');
            this.setTargetProperty(this.ownedPhetioProperty, node, tandemName);
        } else if (this.targetProperty && this.targetProperty instanceof ReadOnlyProperty && this.targetProperty.isPhetioInstrumented()) {
            // If the Property was already set, now that it is instrumented, add a LinkedElement for it.
            node.updateLinkedElementForProperty(tandemName, null, this.targetProperty);
        }
        if (assert) {
            this.phetioInitialized = true;
        }
    }
    /**
   * Get the target property, if any. Use sparingly! Internal use only.
   */ getTargetProperty() {
        return this.targetProperty || null;
    }
    // A TinyForwardingProperty is settable if the target property is settable.
    isSettable() {
        return this.targetProperty ? this.targetProperty.isSettable() : super.isSettable();
    }
    /**
   * This currently also involves deleting the field.
   */ disposeOwnedPhetioProperty() {
        if (this.ownedPhetioProperty) {
            this.ownedPhetioProperty.dispose();
            delete this.ownedPhetioProperty; // back to original value
        }
    }
    dispose() {
        this.clearTargetProperty();
        this.disposeOwnedPhetioProperty();
        super.dispose();
    }
    /**
   * @param value
   * @param [targetPropertyInstrumented] - For phet-io support only, set to false if the target Property is not instrumented
   * @param [onBeforeNotify]
   */ constructor(value, targetPropertyInstrumented = false, onBeforeNotify){
        super(value, onBeforeNotify);
        if (targetPropertyInstrumented) {
            this.targetPropertyInstrumented = targetPropertyInstrumented;
        }
        if (assert) {
            this.phetioInitialized = false;
        }
    }
};
export { TinyForwardingProperty as default };
axon.register('TinyForwardingProperty', TinyForwardingProperty);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2F4b24vanMvVGlueUZvcndhcmRpbmdQcm9wZXJ0eS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBBIGxpZ2h0d2VpZ2h0IHZlcnNpb24gb2YgUHJvcGVydHkgKHRoYXQgc2F0aXNmaWVzIHNvbWUgb2YgdGhlIGludGVyZmFjZSksIG1lYW50IGZvciBoaWdoLXBlcmZvcm1hbmNlIGFwcGxpY2F0aW9uc1xuICogd2hlcmUgdmFsaWRhdGlvbiwgcGhldC1pbyBzdXBwb3J0IGFuZCBvdGhlciB0aGluZ3MgYXJlIG5vdCBuZWVkZWQuIFRoaXMgaW5jbHVkZXMgYWRkaXRpb25hbCBsb2dpYyBmb3IgY29uZGl0aW9uYWxseVxuICogZm9yd2FyZGluZyB0by9mcm9tIGFub3RoZXIgUHJvcGVydHkuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCBUaW55Rm9yd2FyZGluZ1Byb3BlcnR5IGV4Y2x1c2l2ZWx5IHN1cHBvcnRzIHNldHRhYmxlIFByb3BlcnRpZXNcbiAqIHZpYSBpdHMgVHlwZVNjcmlwdCBpbXBsZW1lbnRhdGlvbi4gSWYgeW91IHdhbnQgdG8gdXNlIGEgcmVhZC1vbmx5IFByb3BlcnR5IGFzIHRoZSB0YXJnZXQsIHBsZWFzZSB0eXBlIGNhc3QgYXMgc2V0dGFibGVcbiAqIGFuZCB1c2UgcnVudGltZSBhc3NlcnRpb25zIHRvIGVuc3VyZSB0aGF0IHRoZSB0YXJnZXQgKG9yIHRoaXMgZm9yd2FyZGluZyBQcm9wZXJ0eSkgYXJlIG5vdCBzZXQuIFNlZSBleGFtcGxlcyBsaWtlXG4gKiBOb2RlLnNldFZpc2libGVQcm9wZXJ0eS5cbiAqXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICogQGF1dGhvciBNaWNoYWVsIEthdXptYW5uIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxuICovXG5cbmltcG9ydCBheG9uIGZyb20gJy4vYXhvbi5qcyc7XG5pbXBvcnQgUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQgUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuL1JlYWRPbmx5UHJvcGVydHkuanMnO1xuaW1wb3J0IFRpbnlQcm9wZXJ0eSwgeyBUaW55UHJvcGVydHlPbkJlZm9yZU5vdGlmeSB9IGZyb20gJy4vVGlueVByb3BlcnR5LmpzJztcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi9UUHJvcGVydHkuanMnO1xuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5LCB7IGlzVFJlYWRPbmx5UHJvcGVydHksIFByb3BlcnR5TGF6eUxpbmtMaXN0ZW5lciB9IGZyb20gJy4vVFJlYWRPbmx5UHJvcGVydHkuanMnO1xuXG50eXBlIE5vZGVMaWtlID0ge1xuICB1cGRhdGVMaW5rZWRFbGVtZW50Rm9yUHJvcGVydHk6IDxWYWx1ZVR5cGU+KCB0YW5kZW1OYW1lOiBzdHJpbmcsIG9sZFByb3BlcnR5PzogVFJlYWRPbmx5UHJvcGVydHk8VmFsdWVUeXBlPiB8IG51bGwsIG5ld1Byb3BlcnR5PzogVFJlYWRPbmx5UHJvcGVydHk8VmFsdWVUeXBlPiB8IG51bGwgKSA9PiB2b2lkO1xuICBpc1BoZXRpb0luc3RydW1lbnRlZDogKCkgPT4gYm9vbGVhbjtcbn07XG50eXBlIE9yTnVsbDxUeXBlPiA9IFR5cGUgfCBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW55Rm9yd2FyZGluZ1Byb3BlcnR5PFZhbHVlVHlwZT4gZXh0ZW5kcyBUaW55UHJvcGVydHk8VmFsdWVUeXBlPiB7XG5cbiAgLy8gU2V0IGluIHNldFRhcmdldFByb3BlcnR5KCkuXG4gIHByaXZhdGUgdGFyZ2V0UHJvcGVydHk/OiBUUmVhZE9ubHlQcm9wZXJ0eTxWYWx1ZVR5cGU+IHwgbnVsbDtcblxuICAvLyBTZXQgbGF6aWx5IGluIHNldFRhcmdldFByb3BlcnR5KClcbiAgcHJvdGVjdGVkIGZvcndhcmRpbmdMaXN0ZW5lcj86IFByb3BlcnR5TGF6eUxpbmtMaXN0ZW5lcjxWYWx1ZVR5cGU+O1xuXG4gIC8vIFRpbnlQcm9wZXJ0eSBpcyBub3QgaW5zdHJ1bWVudGVkIGZvciBQaEVULWlPLCBzbyB3aGVuIGEgTm9kZSBpcyBpbnN0cnVtZW50ZWQsIGJ5IGRlZmF1bHQsIGFuIGluc3RydW1lbnRlZFxuICAvLyBgUHJvcGVydHlgIGNhbiBiZSBmb3J3YXJkZWQgdG8uIFRoaXMgZmllbGQgc3RvcmVzIHRoZSBkZWZhdWx0IGluc3RydW1lbnRlZCBQcm9wZXJ0eSB3aGVuXG4gIC8vIHRhcmdldFByb3BlcnR5SW5zdHJ1bWVudGVkIGlzIHRydWUuIC0gUHVibGljIGZvciBOb2RlVGVzdHNcbiAgcHJpdmF0ZSBvd25lZFBoZXRpb1Byb3BlcnR5PzogVFByb3BlcnR5PFZhbHVlVHlwZT47XG5cbiAgLy8gd2hlbiB0cnVlLCBhdXRvbWF0aWNhbGx5IHNldCB1cCBhIFBoRVQtaU8gaW5zdHJ1bWVudGVkIGZvcndhcmRlZCBQcm9wZXJ0eSBmb3IgdGhpcyBUaW55UHJvcGVydHksIHNlZVxuICAvLyB0aGlzLmluaXRpYWxpemVQaGV0aW9PYmplY3QoKSBmb3IgdXNhZ2UuXG4gIHByaXZhdGUgdGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQ/OiBib29sZWFuO1xuXG4gIC8vIEd1YXJkIGFnYWluc3QgZG91YmxlIGluaXRpYWxpemF0aW9uXG4gIHByaXZhdGUgcGhldGlvSW5pdGlhbGl6ZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIFt0YXJnZXRQcm9wZXJ0eUluc3RydW1lbnRlZF0gLSBGb3IgcGhldC1pbyBzdXBwb3J0IG9ubHksIHNldCB0byBmYWxzZSBpZiB0aGUgdGFyZ2V0IFByb3BlcnR5IGlzIG5vdCBpbnN0cnVtZW50ZWRcbiAgICogQHBhcmFtIFtvbkJlZm9yZU5vdGlmeV1cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdmFsdWU6IFZhbHVlVHlwZSwgdGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQgPSBmYWxzZSwgb25CZWZvcmVOb3RpZnk/OiBUaW55UHJvcGVydHlPbkJlZm9yZU5vdGlmeTxWYWx1ZVR5cGU+ICkge1xuICAgIHN1cGVyKCB2YWx1ZSwgb25CZWZvcmVOb3RpZnkgKTtcblxuICAgIGlmICggdGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQgKSB7XG4gICAgICB0aGlzLnRhcmdldFByb3BlcnR5SW5zdHJ1bWVudGVkID0gdGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCBhc3NlcnQgKSB7XG4gICAgICB0aGlzLnBoZXRpb0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQVBJIHN1cHBvcnQgZm9yIHNldHRpbmcgYSBQcm9wZXJ0eXxWYWx1ZVR5cGUgb250byB0aGUgZm9yd2FyZGluZyBQcm9wZXJ0eVxuICBwdWJsaWMgc2V0VmFsdWVPclRhcmdldFByb3BlcnR5PE5vZGVUeXBlIGV4dGVuZHMgTm9kZUxpa2UsIE5vZGVQYXJhbSBleHRlbmRzIE9yTnVsbDxOb2RlVHlwZT4+KFxuICAgIG5vZGU6IE5vZGVQYXJhbSwgdGFuZGVtTmFtZTogc3RyaW5nIHwgbnVsbCwgbmV3VmFsdWVPclRhcmdldFByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxWYWx1ZVR5cGU+IHwgVmFsdWVUeXBlICk6IHZvaWQge1xuXG4gICAgaWYgKCAoIGlzVFJlYWRPbmx5UHJvcGVydHkoIG5ld1ZhbHVlT3JUYXJnZXRQcm9wZXJ0eSApICkgKSB7XG5cbiAgICAgIC8vIEFzIGEgbmV3IFByb3BlcnR5XG4gICAgICB0aGlzLnNldFRhcmdldFByb3BlcnR5KCBuZXdWYWx1ZU9yVGFyZ2V0UHJvcGVydHkgYXMgVFByb3BlcnR5PFZhbHVlVHlwZT4sIG5vZGUsIHRhbmRlbU5hbWUgKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGFzIGEgVmFsdWVUeXBlXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuZ2V0KCk7XG5cbiAgICAgIHRoaXMuY2xlYXJUYXJnZXRQcm9wZXJ0eSgpO1xuXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy50YXJnZXRQcm9wZXJ0eSwgJ2p1c3QgY2xlYXJlZCcgKTtcblxuICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGF3YXkgZnJvbSBhIHRhcmdldFByb3BlcnR5LCBwcmVmZXIgbm8gbm90aWZpY2F0aW9uIChzbyBzZXQgb3VyIHZhbHVlIHRvIHRoZSBsYXN0IHZhbHVlKVxuICAgICAgdGhpcy5zZXRQcm9wZXJ0eVZhbHVlKCBuZXdWYWx1ZU9yVGFyZ2V0UHJvcGVydHkgKTtcblxuICAgICAgLy8gQ2hhbmdpbmcgZm9yd2FyZGluZyB0YXJnZXQgQ09VTEQgY2hhbmdlIHRoZSB2YWx1ZSwgc28gc2VuZCBub3RpZmljYXRpb25zIGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICBpZiAoICF0aGlzLmFyZVZhbHVlc0VxdWFsKCBvbGRWYWx1ZSwgbmV3VmFsdWVPclRhcmdldFByb3BlcnR5ICkgKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKCBvbGRWYWx1ZSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIChvciB1bnNldHMgaWYgYG51bGxgIGlzIHByb3ZpZGVkKSB0aGUgUHJvcGVydHkgdGhhdCB3ZSB1c2UgZm9yIGZvcndhcmRpbmcgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIG5ld1RhcmdldFByb3BlcnR5IC0gbnVsbCB0byBcInVuc2V0XCIgZm9yd2FyZGluZy5cbiAgICogQHBhcmFtIG5vZGUgLSAoRm9yIHBoZXQtaW8gc3VwcG9ydCBvbmx5KTpcbiAgICogICAgICAgICAgICAgICBUaGUgY29udGFpbmVyIG9mIFRpbnlGb3J3YXJkaW5nUHJvcGVydHkgd2hpY2ggc3VwcG9ydHMgdXBkYXRlTGlua2VkRWxlbWVudEZvclByb3BlcnR5KClcbiAgICogQHBhcmFtIHRhbmRlbU5hbWUgLSBudWxsIGlmIHRoZSBQcm9wZXJ0eSBkb2VzIG5vdCBzdXBwb3J0IFBoRVQtaU8gaW5zdHJ1bWVudGF0aW9uXG4gICAqIEByZXR1cm5zIHRoZSBwYXNzZWQgaW4gTm9kZSwgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcHVibGljIHNldFRhcmdldFByb3BlcnR5PE5vZGVUeXBlIGV4dGVuZHMgTm9kZUxpa2UsIE5vZGVQYXJhbSBleHRlbmRzIE9yTnVsbDxOb2RlVHlwZT4+KFxuICAgIG5ld1RhcmdldFByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxWYWx1ZVR5cGU+IHwgbnVsbCxcbiAgICBub2RlOiBOb2RlUGFyYW0gPSBudWxsIGFzIE5vZGVQYXJhbSxcbiAgICB0YW5kZW1OYW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICApOiBOb2RlUGFyYW0ge1xuICAgIGFzc2VydCAmJiBub2RlICYmIHRhbmRlbU5hbWUgPT09IG51bGwgJiYgdGhpcy50YXJnZXRQcm9wZXJ0eUluc3RydW1lbnRlZCAmJiBhc3NlcnQoICFub2RlLmlzUGhldGlvSW5zdHJ1bWVudGVkKCksICd0YW5kZW1OYW1lIG11c3QgYmUgcHJvdmlkZWQgZm9yIGluc3RydW1lbnRlZCBOb2RlcycgKTtcblxuICAgIC8vIG5vLW9wIGlmIHdlIGFyZSBhbHJlYWR5IGZvcndhcmRpbmcgdG8gdGhhdCBwcm9wZXJ0eSBPUiBpZiB3ZSBzdGlsbCBhcmVuJ3QgZm9yd2FyZGluZ1xuICAgIGlmICggdGhpcy50YXJnZXRQcm9wZXJ0eSA9PT0gbmV3VGFyZ2V0UHJvcGVydHkgKSB7XG4gICAgICByZXR1cm4gbm9kZTsgLy8gZm9yIGNoYWluaW5nXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEZvcndhcmRpbmdQcm9wZXJ0eUluc3RydW1lbnRlZCA9IHRoaXMudGFyZ2V0UHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eSBpbnN0YW5jZW9mIFJlYWRPbmx5UHJvcGVydHkgJiYgdGhpcy50YXJnZXRQcm9wZXJ0eS5pc1BoZXRpb0luc3RydW1lbnRlZCgpO1xuICAgIGFzc2VydCAmJiBjdXJyZW50Rm9yd2FyZGluZ1Byb3BlcnR5SW5zdHJ1bWVudGVkICYmIGFzc2VydCggbmV3VGFyZ2V0UHJvcGVydHkgJiYgbmV3VGFyZ2V0UHJvcGVydHkgaW5zdGFuY2VvZiBSZWFkT25seVByb3BlcnR5ICYmIG5ld1RhcmdldFByb3BlcnR5LmlzUGhldGlvSW5zdHJ1bWVudGVkKCksXG4gICAgICAnQ2Fubm90IHNldCBzd2FwIG91dCBhIFBoRVQtaU8gaW5zdHJ1bWVudGVkIHRhcmdldFByb3BlcnR5IGZvciBhbiB1bmluc3RydW1lbnRlZCBvbmUnICk7XG5cbiAgICAvLyBXZSBuZWVkIHRoaXMgaW5mb3JtYXRpb24gZWFnZXJseSBmb3IgbGF0ZXIgb24gaW4gdGhlIGZ1bmN0aW9uXG4gICAgY29uc3QgcHJldmlvdXNUYXJnZXQgPSB0aGlzLnRhcmdldFByb3BlcnR5O1xuXG4gICAgLy8gSWYgd2UgaGFkIHRoZSBcImRlZmF1bHQgaW5zdHJ1bWVudGVkXCIgUHJvcGVydHksIHdlJ2xsIHJlbW92ZSB0aGF0IGFuZCB0aGVuIGxpbmsgb3VyIG5ldyBQcm9wZXJ0eS4gR3VhcmQgb24gdGhlIGZhY3RcbiAgICAvLyB0aGF0IG93bmVkUGhldGlvUHJvcGVydHkgaXMgYWRkZWQgdmlhIHRoaXMgZXhhY3QgbWV0aG9kLCBzZWUgdGhpcy5pbml0aWFsaXplUGhldGlvKCkgZm9yIGRldGFpbHNcbiAgICAvLyBEbyB0aGlzIGJlZm9yZSBhZGRpbmcgYSBQaEVULWlPIExpbmtlZEVsZW1lbnQgYmVjYXVzZSBvd25lZFBoZXRpb1Byb3BlcnR5IGhhcyB0aGUgc2FtZSBwaGV0aW9JRCBhcyB0aGUgTGlua2VkRWxlbWVudFxuICAgIGlmICggdGhpcy5vd25lZFBoZXRpb1Byb3BlcnR5ICYmIG5ld1RhcmdldFByb3BlcnR5ICE9PSB0aGlzLm93bmVkUGhldGlvUHJvcGVydHkgKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VPd25lZFBoZXRpb1Byb3BlcnR5KCk7XG4gICAgfVxuXG4gICAgbm9kZSAmJiB0YW5kZW1OYW1lICE9PSBudWxsICYmIG5vZGUudXBkYXRlTGlua2VkRWxlbWVudEZvclByb3BlcnR5KCB0YW5kZW1OYW1lLCBwcmV2aW91c1RhcmdldCwgbmV3VGFyZ2V0UHJvcGVydHkgKTtcblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXQoKTtcblxuICAgIHRoaXMuY2xlYXJUYXJnZXRQcm9wZXJ0eSgpO1xuXG4gICAgdGhpcy50YXJnZXRQcm9wZXJ0eSA9IG5ld1RhcmdldFByb3BlcnR5O1xuXG4gICAgaWYgKCB0aGlzLnRhcmdldFByb3BlcnR5ICkge1xuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5mb3J3YXJkaW5nTGlzdGVuZXIsICdmb3J3YXJkaW5nTGlzdGVuZXIgaXMgbm90IHNldCB5ZXQnICk7XG4gICAgICB0aGlzLnRhcmdldFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLmZvcndhcmRpbmdMaXN0ZW5lciEgKTtcbiAgICAgIHRoaXMuc2V0UHJvcGVydHlWYWx1ZSggdGhpcy50YXJnZXRQcm9wZXJ0eS52YWx1ZSApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBhd2F5IGZyb20gYSB0YXJnZXRQcm9wZXJ0eSwgcHJlZmVyIG5vIG5vdGlmaWNhdGlvbiAoc28gc2V0IG91ciB2YWx1ZSB0byB0aGUgbGFzdCB2YWx1ZSlcbiAgICAgIHRoaXMuc2V0UHJvcGVydHlWYWx1ZSggb2xkVmFsdWUgKTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2luZyBmb3J3YXJkaW5nIHRhcmdldCBDT1VMRCBjaGFuZ2UgdGhlIHZhbHVlLCBzbyBzZW5kIG5vdGlmaWNhdGlvbnMgaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICBpZiAoICF0aGlzLmFyZVZhbHVlc0VxdWFsKCBvbGRWYWx1ZSwgdGhpcy5nZXQoKSApICkge1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoIG9sZFZhbHVlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7IC8vIGZvciBjaGFpbmluZ1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclRhcmdldFByb3BlcnR5KCk6IHZvaWQge1xuXG4gICAgLy8gTGF6aWx5IHNldCB0aGlzIHZhbHVlLCBpdCB3aWxsIGJlIGFkZGVkIGFzIGEgbGlzdGVuZXIgdG8gYW55IHRhcmdldFByb3BlcnR5IHdlIGhhdmUuXG4gICAgdGhpcy5mb3J3YXJkaW5nTGlzdGVuZXIgPSB0aGlzLmZvcndhcmRpbmdMaXN0ZW5lciB8fCB0aGlzLm9uVGFyZ2V0UHJvcGVydHlDaGFuZ2UuYmluZCggdGhpcyApO1xuXG4gICAgaWYgKCB0aGlzLnRhcmdldFByb3BlcnR5ICkge1xuICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eS51bmxpbmsoIHRoaXMuZm9yd2FyZGluZ0xpc3RlbmVyICk7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGlzIFByb3BlcnR5J3MgbGlzdGVuZXJzIHdoZW4gdGhlIHRhcmdldFByb3BlcnR5IGNoYW5nZXMuXG4gICAqIEZvciBwZXJmb3JtYW5jZSwga2VlcCB0aGlzIGxpc3RlbmVyIG9uIHRoZSBwcm90b3R5cGUuXG4gICAqL1xuICBwcml2YXRlIG9uVGFyZ2V0UHJvcGVydHlDaGFuZ2UoIHZhbHVlOiBWYWx1ZVR5cGUgKTogdm9pZCB7XG4gICAgc3VwZXIuc2V0KCB2YWx1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGFuZCBub3RpZmllcyBsaXN0ZW5lcnMsIHVubGVzcyBkZWZlcnJlZCBvciBkaXNwb3NlZC4gWW91IGNhbiBhbHNvIHVzZSB0aGUgZXM1IGdldHRlclxuICAgKiAocHJvcGVydHkudmFsdWUpIGJ1dCB0aGlzIG1lYW5zIGlzIHByb3ZpZGVkIGZvciBpbm5lciBsb29wcyBvciBpbnRlcm5hbCBjb2RlIHRoYXQgbXVzdCBiZSBmYXN0LiBJZiB0aGUgdmFsdWVcbiAgICogaGFzbid0IGNoYW5nZWQsIHRoaXMgaXMgYSBuby1vcC5cbiAgICovXG4gIHB1YmxpYyBvdmVycmlkZSBzZXQoIHZhbHVlOiBWYWx1ZVR5cGUgKTogdGhpcyB7XG4gICAgaWYgKCB0aGlzLnRhcmdldFByb3BlcnR5ICkge1xuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy50YXJnZXRQcm9wZXJ0eS5pc1NldHRhYmxlKCksICd0YXJnZXRQcm9wZXJ0eSBtdXN0IGJlIHNldHRhYmxlJyApO1xuICAgICAgKCB0aGlzLnRhcmdldFByb3BlcnR5IGFzIFRQcm9wZXJ0eTxWYWx1ZVR5cGU+ICkuc2V0KCB2YWx1ZSApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN1cGVyLnNldCggdmFsdWUgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgYSBmb3J3YXJkZWQsIFBoRVQtaU8gaW5zdHJ1bWVudGVkIFByb3BlcnR5IG93bmVkIGJ5IHRoaXMgVGlueUZvcndhcmRpbmdQcm9wZXJ0eS5cbiAgICovXG4gIHB1YmxpYyBzZXRUYXJnZXRQcm9wZXJ0eUluc3RydW1lbnRlZDxOb2RlVHlwZSBleHRlbmRzIE5vZGVMaWtlPiggdGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQ6IGJvb2xlYW4sIG5vZGU6IE5vZGVUeXBlICk6IE5vZGVUeXBlIHtcblxuICAgIC8vIFNlZSBOb2RlLmluaXRpYWxpemVQaGV0aW9PYmplY3QgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIGFzc2VydGlvblxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFub2RlLmlzUGhldGlvSW5zdHJ1bWVudGVkKCksICd0aGlzIG9wdGlvbiBvbmx5IHdvcmtzIGlmIGl0IGlzIHBhc3NlZCBpbiBiZWZvcmUgdGhpcyBOb2RlIGlzIGluc3RydW1lbnRlZCcgKTtcblxuICAgIHRoaXMudGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQgPSB0YXJnZXRQcm9wZXJ0eUluc3RydW1lbnRlZDtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcHVibGljIGdldFRhcmdldFByb3BlcnR5SW5zdHJ1bWVudGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRhcmdldFByb3BlcnR5SW5zdHJ1bWVudGVkIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBub2RlIC0gdGhlIHBhcmVudCBjb250YWluZXIgdGhhdCBzdXBwb3J0cyB1cGRhdGVMaW5rZWRFbGVtZW50Rm9yUHJvcGVydHkoKVxuICAgKiBAcGFyYW0gdGFuZGVtTmFtZVxuICAgKiBAcGFyYW0gY3JlYXRlUHJvcGVydHkgLSBjcmVhdGVzIGFuIFwib3duZWRcIiBQcm9wZXJ0eVxuICAgKi9cbiAgcHVibGljIGluaXRpYWxpemVQaGV0aW8oIG5vZGU6IE5vZGVMaWtlLCB0YW5kZW1OYW1lOiBzdHJpbmcsIGNyZWF0ZVByb3BlcnR5OiAoKSA9PiBUUHJvcGVydHk8VmFsdWVUeXBlPiApOiB2b2lkIHtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy5waGV0aW9Jbml0aWFsaXplZCwgJ2FscmVhZHkgaW5pdGlhbGl6ZWQnICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIXRoaXMub3duZWRQaGV0aW9Qcm9wZXJ0eSwgJ0FscmVhZHkgY3JlYXRlZCB0aGUgb3duZWRQaGV0aW9Qcm9wZXJ0eScgKTtcblxuICAgIGlmICggIXRoaXMudGFyZ2V0UHJvcGVydHkgJiYgdGhpcy50YXJnZXRQcm9wZXJ0eUluc3RydW1lbnRlZCApIHtcblxuICAgICAgdGhpcy5vd25lZFBoZXRpb1Byb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkoKTtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMub3duZWRQaGV0aW9Qcm9wZXJ0eSBpbnN0YW5jZW9mIFByb3BlcnR5LCAnVGhlIG93bmVkIHByb3BlcnR5IHNob3VsZCBiZSBhbiBBWE9OL1Byb3BlcnR5JyApO1xuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5vd25lZFBoZXRpb1Byb3BlcnR5IGluc3RhbmNlb2YgUmVhZE9ubHlQcm9wZXJ0eSAmJiB0aGlzLm93bmVkUGhldGlvUHJvcGVydHkuaXNQaGV0aW9JbnN0cnVtZW50ZWQoKSwgJ1RoZSBvd25lZCBwcm9wZXJ0eSBzaG91bGQgYmUgUGhFVC1pTyBpbnN0cnVtZW50ZWQnICk7XG5cbiAgICAgIHRoaXMuc2V0VGFyZ2V0UHJvcGVydHkoIHRoaXMub3duZWRQaGV0aW9Qcm9wZXJ0eSwgbm9kZSwgdGFuZGVtTmFtZSApO1xuICAgIH1cbiAgICBlbHNlIGlmICggdGhpcy50YXJnZXRQcm9wZXJ0eSAmJiB0aGlzLnRhcmdldFByb3BlcnR5IGluc3RhbmNlb2YgUmVhZE9ubHlQcm9wZXJ0eSAmJiB0aGlzLnRhcmdldFByb3BlcnR5LmlzUGhldGlvSW5zdHJ1bWVudGVkKCkgKSB7XG5cbiAgICAgIC8vIElmIHRoZSBQcm9wZXJ0eSB3YXMgYWxyZWFkeSBzZXQsIG5vdyB0aGF0IGl0IGlzIGluc3RydW1lbnRlZCwgYWRkIGEgTGlua2VkRWxlbWVudCBmb3IgaXQuXG4gICAgICBub2RlLnVwZGF0ZUxpbmtlZEVsZW1lbnRGb3JQcm9wZXJ0eSggdGFuZGVtTmFtZSwgbnVsbCwgdGhpcy50YXJnZXRQcm9wZXJ0eSApO1xuICAgIH1cblxuICAgIGlmICggYXNzZXJ0ICkge1xuICAgICAgdGhpcy5waGV0aW9Jbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFyZ2V0IHByb3BlcnR5LCBpZiBhbnkuIFVzZSBzcGFyaW5nbHkhIEludGVybmFsIHVzZSBvbmx5LlxuICAgKi9cbiAgcHVibGljIGdldFRhcmdldFByb3BlcnR5KCk6IFRSZWFkT25seVByb3BlcnR5PFZhbHVlVHlwZT4gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRQcm9wZXJ0eSB8fCBudWxsO1xuICB9XG5cbiAgLy8gQSBUaW55Rm9yd2FyZGluZ1Byb3BlcnR5IGlzIHNldHRhYmxlIGlmIHRoZSB0YXJnZXQgcHJvcGVydHkgaXMgc2V0dGFibGUuXG4gIHB1YmxpYyBvdmVycmlkZSBpc1NldHRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRhcmdldFByb3BlcnR5ID8gdGhpcy50YXJnZXRQcm9wZXJ0eS5pc1NldHRhYmxlKCkgOiBzdXBlci5pc1NldHRhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBjdXJyZW50bHkgYWxzbyBpbnZvbHZlcyBkZWxldGluZyB0aGUgZmllbGQuXG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2VPd25lZFBoZXRpb1Byb3BlcnR5KCk6IHZvaWQge1xuICAgIGlmICggdGhpcy5vd25lZFBoZXRpb1Byb3BlcnR5ICkge1xuICAgICAgdGhpcy5vd25lZFBoZXRpb1Byb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm93bmVkUGhldGlvUHJvcGVydHk7IC8vIGJhY2sgdG8gb3JpZ2luYWwgdmFsdWVcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyVGFyZ2V0UHJvcGVydHkoKTtcbiAgICB0aGlzLmRpc3Bvc2VPd25lZFBoZXRpb1Byb3BlcnR5KCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbmF4b24ucmVnaXN0ZXIoICdUaW55Rm9yd2FyZGluZ1Byb3BlcnR5JywgVGlueUZvcndhcmRpbmdQcm9wZXJ0eSApOyJdLCJuYW1lcyI6WyJheG9uIiwiUHJvcGVydHkiLCJSZWFkT25seVByb3BlcnR5IiwiVGlueVByb3BlcnR5IiwiaXNUUmVhZE9ubHlQcm9wZXJ0eSIsIlRpbnlGb3J3YXJkaW5nUHJvcGVydHkiLCJzZXRWYWx1ZU9yVGFyZ2V0UHJvcGVydHkiLCJub2RlIiwidGFuZGVtTmFtZSIsIm5ld1ZhbHVlT3JUYXJnZXRQcm9wZXJ0eSIsInNldFRhcmdldFByb3BlcnR5Iiwib2xkVmFsdWUiLCJnZXQiLCJjbGVhclRhcmdldFByb3BlcnR5IiwiYXNzZXJ0IiwidGFyZ2V0UHJvcGVydHkiLCJzZXRQcm9wZXJ0eVZhbHVlIiwiYXJlVmFsdWVzRXF1YWwiLCJub3RpZnlMaXN0ZW5lcnMiLCJuZXdUYXJnZXRQcm9wZXJ0eSIsInRhcmdldFByb3BlcnR5SW5zdHJ1bWVudGVkIiwiaXNQaGV0aW9JbnN0cnVtZW50ZWQiLCJjdXJyZW50Rm9yd2FyZGluZ1Byb3BlcnR5SW5zdHJ1bWVudGVkIiwicHJldmlvdXNUYXJnZXQiLCJvd25lZFBoZXRpb1Byb3BlcnR5IiwiZGlzcG9zZU93bmVkUGhldGlvUHJvcGVydHkiLCJ1cGRhdGVMaW5rZWRFbGVtZW50Rm9yUHJvcGVydHkiLCJmb3J3YXJkaW5nTGlzdGVuZXIiLCJsYXp5TGluayIsInZhbHVlIiwib25UYXJnZXRQcm9wZXJ0eUNoYW5nZSIsImJpbmQiLCJ1bmxpbmsiLCJzZXQiLCJpc1NldHRhYmxlIiwic2V0VGFyZ2V0UHJvcGVydHlJbnN0cnVtZW50ZWQiLCJnZXRUYXJnZXRQcm9wZXJ0eUluc3RydW1lbnRlZCIsImluaXRpYWxpemVQaGV0aW8iLCJjcmVhdGVQcm9wZXJ0eSIsInBoZXRpb0luaXRpYWxpemVkIiwiZ2V0VGFyZ2V0UHJvcGVydHkiLCJkaXNwb3NlIiwib25CZWZvcmVOb3RpZnkiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FFRCxPQUFPQSxVQUFVLFlBQVk7QUFDN0IsT0FBT0MsY0FBYyxnQkFBZ0I7QUFDckMsT0FBT0Msc0JBQXNCLHdCQUF3QjtBQUNyRCxPQUFPQyxrQkFBa0Qsb0JBQW9CO0FBRTdFLFNBQTRCQyxtQkFBbUIsUUFBa0MseUJBQXlCO0FBUTNGLElBQUEsQUFBTUMseUJBQU4sTUFBTUEsK0JBQTBDRjtJQXFDN0QsNEVBQTRFO0lBQ3JFRyx5QkFDTEMs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