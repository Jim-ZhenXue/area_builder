// Copyright 2024, University of Colorado Boulder
/**
 * Uses js/parser/svgPath.pegjs to generate js/parser/svgPath.js
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import fs from 'fs';
import pegjs from 'pegjs';
const pegInput = fs.readFileSync('js/parser/svgPath.pegjs', 'utf8');
// @ts-expect-error - older version of pegjs such that typescript doesn't know about this function
let source = pegjs.buildParser(pegInput).toSource();
// replace fixed strings at the start/end with our prefix/suffix, so that it will work nicely with require.js
const prefix = '/*\n' + ' * NOTE: Generated from svgPath.pegjs using PEG.js, with added kite namespace and require.js compatibility.\n' + ' * See svgPath.pegjs for more documentation, or run \'grunt generate-svg-path-parser\' to regenerate.\n' + ' */\n' + '\n' + 'define( require => {\n' + '  const kite = require( \'KITE/kite\' );\n';
const suffix = '  kite.register( \'svgPath\', result );\n' + '  return kite.svgPath;\n' + '} );\n';
const toStripFromStart = '(function(){';
const toStrimFromEnd = '  return result;\n})()';
const startIndex = source.indexOf(toStripFromStart);
if (startIndex !== 0) {
    throw new Error('Could not find string to strip from the beginning of the PEG.js output');
}
source = prefix + source.substring(startIndex + toStripFromStart.length);
const endIndex = source.lastIndexOf(toStrimFromEnd);
if (endIndex === -1) {
    throw new Error('Could not find string to strip from the end of the PEG.js output');
}
source = source.substring(0, endIndex) + suffix;
// write the output
fs.writeFileSync('js/parser/svgPath.js', source, 'utf8');
console.log('Please reformat the generated svgPath.js before checking in!'); // TODO: Why does this not fail lint in Webstorm? Rename grunt/tasks/eslint.config.mjs -> blarg.config.mjs and it
 //  catches lint errors fails correctly. https://github.com/phetsims/chipper/issues/1483
 // (async()=>{})();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2tpdGUvanMvZ3J1bnQvdGFza3MvZ2VuZXJhdGUtc3ZnLXBhdGgtcGFyc2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBVc2VzIGpzL3BhcnNlci9zdmdQYXRoLnBlZ2pzIHRvIGdlbmVyYXRlIGpzL3BhcnNlci9zdmdQYXRoLmpzXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwZWdqcyBmcm9tICdwZWdqcyc7XG5cbmNvbnN0IHBlZ0lucHV0ID0gZnMucmVhZEZpbGVTeW5jKCAnanMvcGFyc2VyL3N2Z1BhdGgucGVnanMnLCAndXRmOCcgKTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvciAtIG9sZGVyIHZlcnNpb24gb2YgcGVnanMgc3VjaCB0aGF0IHR5cGVzY3JpcHQgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgZnVuY3Rpb25cbmxldCBzb3VyY2UgPSBwZWdqcy5idWlsZFBhcnNlciggcGVnSW5wdXQgKS50b1NvdXJjZSgpO1xuXG4vLyByZXBsYWNlIGZpeGVkIHN0cmluZ3MgYXQgdGhlIHN0YXJ0L2VuZCB3aXRoIG91ciBwcmVmaXgvc3VmZml4LCBzbyB0aGF0IGl0IHdpbGwgd29yayBuaWNlbHkgd2l0aCByZXF1aXJlLmpzXG5jb25zdCBwcmVmaXggPSAnLypcXG4nICtcbiAgICAgICAgICAgICAgICcgKiBOT1RFOiBHZW5lcmF0ZWQgZnJvbSBzdmdQYXRoLnBlZ2pzIHVzaW5nIFBFRy5qcywgd2l0aCBhZGRlZCBraXRlIG5hbWVzcGFjZSBhbmQgcmVxdWlyZS5qcyBjb21wYXRpYmlsaXR5LlxcbicgK1xuICAgICAgICAgICAgICAgJyAqIFNlZSBzdmdQYXRoLnBlZ2pzIGZvciBtb3JlIGRvY3VtZW50YXRpb24sIG9yIHJ1biBcXCdncnVudCBnZW5lcmF0ZS1zdmctcGF0aC1wYXJzZXJcXCcgdG8gcmVnZW5lcmF0ZS5cXG4nICtcbiAgICAgICAgICAgICAgICcgKi9cXG4nICtcbiAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICdkZWZpbmUoIHJlcXVpcmUgPT4ge1xcbicgK1xuICAgICAgICAgICAgICAgJyAgY29uc3Qga2l0ZSA9IHJlcXVpcmUoIFxcJ0tJVEUva2l0ZVxcJyApO1xcbic7XG5jb25zdCBzdWZmaXggPSAnICBraXRlLnJlZ2lzdGVyKCBcXCdzdmdQYXRoXFwnLCByZXN1bHQgKTtcXG4nICtcbiAgICAgICAgICAgICAgICcgIHJldHVybiBraXRlLnN2Z1BhdGg7XFxuJyArXG4gICAgICAgICAgICAgICAnfSApO1xcbic7XG5jb25zdCB0b1N0cmlwRnJvbVN0YXJ0ID0gJyhmdW5jdGlvbigpeyc7XG5jb25zdCB0b1N0cmltRnJvbUVuZCA9ICcgIHJldHVybiByZXN1bHQ7XFxufSkoKSc7XG5cbmNvbnN0IHN0YXJ0SW5kZXggPSBzb3VyY2UuaW5kZXhPZiggdG9TdHJpcEZyb21TdGFydCApO1xuaWYgKCBzdGFydEluZGV4ICE9PSAwICkge1xuICB0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBzdHJpbmcgdG8gc3RyaXAgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRUcuanMgb3V0cHV0JyApO1xufVxuc291cmNlID0gcHJlZml4ICsgc291cmNlLnN1YnN0cmluZyggc3RhcnRJbmRleCArIHRvU3RyaXBGcm9tU3RhcnQubGVuZ3RoICk7XG5cbmNvbnN0IGVuZEluZGV4ID0gc291cmNlLmxhc3RJbmRleE9mKCB0b1N0cmltRnJvbUVuZCApO1xuaWYgKCBlbmRJbmRleCA9PT0gLTEgKSB7XG4gIHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIHN0cmluZyB0byBzdHJpcCBmcm9tIHRoZSBlbmQgb2YgdGhlIFBFRy5qcyBvdXRwdXQnICk7XG59XG5zb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKCAwLCBlbmRJbmRleCApICsgc3VmZml4O1xuXG4vLyB3cml0ZSB0aGUgb3V0cHV0XG5mcy53cml0ZUZpbGVTeW5jKCAnanMvcGFyc2VyL3N2Z1BhdGguanMnLCBzb3VyY2UsICd1dGY4JyApO1xuXG5jb25zb2xlLmxvZyggJ1BsZWFzZSByZWZvcm1hdCB0aGUgZ2VuZXJhdGVkIHN2Z1BhdGguanMgYmVmb3JlIGNoZWNraW5nIGluIScgKTtcblxuLy8gVE9ETzogV2h5IGRvZXMgdGhpcyBub3QgZmFpbCBsaW50IGluIFdlYnN0b3JtPyBSZW5hbWUgZ3J1bnQvdGFza3MvZXNsaW50LmNvbmZpZy5tanMgLT4gYmxhcmcuY29uZmlnLm1qcyBhbmQgaXRcbi8vICBjYXRjaGVzIGxpbnQgZXJyb3JzIGZhaWxzIGNvcnJlY3RseS4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzE0ODNcbi8vIChhc3luYygpPT57fSkoKTsiXSwibmFtZXMiOlsiZnMiLCJwZWdqcyIsInBlZ0lucHV0IiwicmVhZEZpbGVTeW5jIiwic291cmNlIiwiYnVpbGRQYXJzZXIiLCJ0b1NvdXJjZSIsInByZWZpeCIsInN1ZmZpeCIsInRvU3RyaXBGcm9tU3RhcnQiLCJ0b1N0cmltRnJvbUVuZCIsInN0YXJ0SW5kZXgiLCJpbmRleE9mIiwiRXJyb3IiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJlbmRJbmRleCIsImxhc3RJbmRleE9mIiwid3JpdGVGaWxlU3luYyIsImNvbnNvbGUiLCJsb2ciXSwibWFwcGluZ3MiOiJBQUFBLGlEQUFpRDtBQUVqRDs7O0NBR0MsR0FFRCxPQUFPQSxRQUFRLEtBQUs7QUFDcEIsT0FBT0MsV0FBVyxRQUFRO0FBRTFCLE1BQU1DLFdBQVdGLEdBQUdHLFlBQVksQ0FBRSwyQkFBMkI7QUFFN0Qsa0dBQWtHO0FBQ2xHLElBQUlDLFNBQVNILE1BQU1JLFdBQVcsQ0FBRUgsVUFBV0ksUUFBUTtBQUVuRCw2R0FBNkc7QUFDN0csTUFBTUMsU0FBUyxTQUNBLGtIQUNBLDRHQUNBLFVBQ0EsT0FDQSwyQkFDQTtBQUNmLE1BQU1DLFNBQVMsOENBQ0EsNkJBQ0E7QUFDZixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsaUJBQWlCO0FBRXZCLE1BQU1DLGFBQWFQLE9BQU9RLE9BQU8sQ0FBRUg7QUFDbkMsSUFBS0UsZUFBZSxHQUFJO0lBQ3RCLE1BQU0sSUFBSUUsTUFBTztBQUNuQjtBQUNBVCxTQUFTRyxTQUFTSCxPQUFPVSxTQUFTLENBQUVILGFBQWFGLGlCQUFpQk0sTUFBTTtBQUV4RSxNQUFNQyxXQUFXWixPQUFPYSxXQUFXLENBQUVQO0FBQ3JDLElBQUtNLGFBQWEsQ0FBQyxHQUFJO0lBQ3JCLE1BQU0sSUFBSUgsTUFBTztBQUNuQjtBQUNBVCxTQUFTQSxPQUFPVSxTQUFTLENBQUUsR0FBR0UsWUFBYVI7QUFFM0MsbUJBQW1CO0FBQ25CUixHQUFHa0IsYUFBYSxDQUFFLHdCQUF3QmQsUUFBUTtBQUVsRGUsUUFBUUMsR0FBRyxDQUFFLGlFQUViLGlIQUFpSDtDQUNqSCx3RkFBd0Y7Q0FDeEYsbUJBQW1CIn0=