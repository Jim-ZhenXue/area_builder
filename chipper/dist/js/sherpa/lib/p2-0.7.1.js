/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 p2.js authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */ !function(e) {
    if ("object" == typeof exports) module.exports = e();
    else if ("function" == typeof define && false) define(e);
    else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.p2 = e();
    }
}(function() {
    var define1, module1, exports1;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'");
                }
                var f = n[o] = {
                    exports: {}
                };
                t[o][0].call(f.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, f, f.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for(var o = 0; o < r.length; o++)s(r[o]);
        return s;
    })({
        1: [
            function(_dereq_, module1, exports1) {
                var Scalar = _dereq_('./Scalar');
                module1.exports = Line;
                /**
 * Container for line-related functions
 * @class Line
 */ function Line() {}
                ;
                /**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */ Line.lineInt = function(l1, l2, precision) {
                    precision = precision || 0;
                    var i = [
                        0,
                        0
                    ]; // point
                    var a1, b1, c1, a2, b2, c2, det; // scalars
                    a1 = l1[1][1] - l1[0][1];
                    b1 = l1[0][0] - l1[1][0];
                    c1 = a1 * l1[0][0] + b1 * l1[0][1];
                    a2 = l2[1][1] - l2[0][1];
                    b2 = l2[0][0] - l2[1][0];
                    c2 = a2 * l2[0][0] + b2 * l2[0][1];
                    det = a1 * b2 - a2 * b1;
                    if (!Scalar.eq(det, 0, precision)) {
                        i[0] = (b2 * c1 - b1 * c2) / det;
                        i[1] = (a1 * c2 - a2 * c1) / det;
                    }
                    return i;
                };
                /**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */ Line.segmentsIntersect = function(p1, p2, q1, q2) {
                    var dx = p2[0] - p1[0];
                    var dy = p2[1] - p1[1];
                    var da = q2[0] - q1[0];
                    var db = q2[1] - q1[1];
                    // segments are parallel
                    if (da * dy - db * dx == 0) return false;
                    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
                    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
                    return s >= 0 && s <= 1 && t >= 0 && t <= 1;
                };
            },
            {
                "./Scalar": 4
            }
        ],
        2: [
            function(_dereq_, module1, exports1) {
                module1.exports = Point;
                /**
 * Point related functions
 * @class Point
 */ function Point() {}
                ;
                /**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */ Point.area = function(a, b, c) {
                    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
                };
                Point.left = function(a, b, c) {
                    return Point.area(a, b, c) > 0;
                };
                Point.leftOn = function(a, b, c) {
                    return Point.area(a, b, c) >= 0;
                };
                Point.right = function(a, b, c) {
                    return Point.area(a, b, c) < 0;
                };
                Point.rightOn = function(a, b, c) {
                    return Point.area(a, b, c) <= 0;
                };
                var tmpPoint1 = [], tmpPoint2 = [];
                /**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */ Point.collinear = function(a, b, c, thresholdAngle) {
                    if (!thresholdAngle) return Point.area(a, b, c) == 0;
                    else {
                        var ab = tmpPoint1, bc = tmpPoint2;
                        ab[0] = b[0] - a[0];
                        ab[1] = b[1] - a[1];
                        bc[0] = c[0] - b[0];
                        bc[1] = c[1] - b[1];
                        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
                        return angle < thresholdAngle;
                    }
                };
                Point.sqdist = function(a, b) {
                    var dx = b[0] - a[0];
                    var dy = b[1] - a[1];
                    return dx * dx + dy * dy;
                };
            },
            {}
        ],
        3: [
            function(_dereq_, module1, exports1) {
                var Line = _dereq_("./Line"), Point = _dereq_("./Point"), Scalar = _dereq_("./Scalar");
                module1.exports = Polygon;
                /**
 * Polygon class.
 * @class Polygon
 * @constructor
 */ function Polygon() {
                    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */ this.vertices = [];
                }
                /**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */ Polygon.prototype.at = function(i) {
                    var v = this.vertices, s = v.length;
                    return v[i < 0 ? i % s + s : i % s];
                };
                /**
 * Get first vertex
 * @method first
 * @return {Array}
 */ Polygon.prototype.first = function() {
                    return this.vertices[0];
                };
                /**
 * Get last vertex
 * @method last
 * @return {Array}
 */ Polygon.prototype.last = function() {
                    return this.vertices[this.vertices.length - 1];
                };
                /**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */ Polygon.prototype.clear = function() {
                    this.vertices.length = 0;
                };
                /**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */ Polygon.prototype.append = function(poly, from, to) {
                    if (typeof from == "undefined") throw new Error("From is not given!");
                    if (typeof to == "undefined") throw new Error("To is not given!");
                    if (to - 1 < from) throw new Error("lol1");
                    if (to > poly.vertices.length) throw new Error("lol2");
                    if (from < 0) throw new Error("lol3");
                    for(var i = from; i < to; i++){
                        this.vertices.push(poly.vertices[i]);
                    }
                };
                /**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */ Polygon.prototype.makeCCW = function() {
                    var br = 0, v = this.vertices;
                    // find bottom right point
                    for(var i = 1; i < this.vertices.length; ++i){
                        if (v[i][1] < v[br][1] || v[i][1] == v[br][1] && v[i][0] > v[br][0]) {
                            br = i;
                        }
                    }
                    // reverse poly if clockwise
                    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
                        this.reverse();
                    }
                };
                /**
 * Reverse the vertices in the polygon
 * @method reverse
 */ Polygon.prototype.reverse = function() {
                    var tmp = [];
                    for(var i = 0, N = this.vertices.length; i !== N; i++){
                        tmp.push(this.vertices.pop());
                    }
                    this.vertices = tmp;
                };
                /**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */ Polygon.prototype.isReflex = function(i) {
                    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
                };
                var tmpLine1 = [], tmpLine2 = [];
                /**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */ Polygon.prototype.canSee = function(a, b) {
                    var p, dist, l1 = tmpLine1, l2 = tmpLine2;
                    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
                        return false;
                    }
                    dist = Point.sqdist(this.at(a), this.at(b));
                    for(var i = 0; i !== this.vertices.length; ++i){
                        if ((i + 1) % this.vertices.length === a || i === a) continue;
                        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) {
                            l1[0] = this.at(a);
                            l1[1] = this.at(b);
                            l2[0] = this.at(i);
                            l2[1] = this.at(i + 1);
                            p = Line.lineInt(l1, l2);
                            if (Point.sqdist(this.at(a), p) < dist) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                /**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */ Polygon.prototype.copy = function(i, j, targetPoly) {
                    var p = targetPoly || new Polygon();
                    p.clear();
                    if (i < j) {
                        // Insert all vertices from i to j
                        for(var k = i; k <= j; k++)p.vertices.push(this.vertices[k]);
                    } else {
                        // Insert vertices 0 to j
                        for(var k = 0; k <= j; k++)p.vertices.push(this.vertices[k]);
                        // Insert vertices i to end
                        for(var k = i; k < this.vertices.length; k++)p.vertices.push(this.vertices[k]);
                    }
                    return p;
                };
                /**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */ Polygon.prototype.getCutEdges = function() {
                    var min = [], tmp1 = [], tmp2 = [], tmpPoly = new Polygon();
                    var nDiags = Number.MAX_VALUE;
                    for(var i = 0; i < this.vertices.length; ++i){
                        if (this.isReflex(i)) {
                            for(var j = 0; j < this.vertices.length; ++j){
                                if (this.canSee(i, j)) {
                                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();
                                    for(var k = 0; k < tmp2.length; k++)tmp1.push(tmp2[k]);
                                    if (tmp1.length < nDiags) {
                                        min = tmp1;
                                        nDiags = tmp1.length;
                                        min.push([
                                            this.at(i),
                                            this.at(j)
                                        ]);
                                    }
                                }
                            }
                        }
                    }
                    return min;
                };
                /**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */ Polygon.prototype.decomp = function() {
                    var edges = this.getCutEdges();
                    if (edges.length > 0) return this.slice(edges);
                    else return [
                        this
                    ];
                };
                /**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */ Polygon.prototype.slice = function(cutEdges) {
                    if (cutEdges.length == 0) return [
                        this
                    ];
                    if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length == 2 && cutEdges[0][0] instanceof Array) {
                        var polys = [
                            this
                        ];
                        for(var i = 0; i < cutEdges.length; i++){
                            var cutEdge = cutEdges[i];
                            // Cut all polys
                            for(var j = 0; j < polys.length; j++){
                                var poly = polys[j];
                                var result = poly.slice(cutEdge);
                                if (result) {
                                    // Found poly! Cut and quit
                                    polys.splice(j, 1);
                                    polys.push(result[0], result[1]);
                                    break;
                                }
                            }
                        }
                        return polys;
                    } else {
                        // Was given one edge
                        var cutEdge = cutEdges;
                        var i = this.vertices.indexOf(cutEdge[0]);
                        var j = this.vertices.indexOf(cutEdge[1]);
                        if (i != -1 && j != -1) {
                            return [
                                this.copy(i, j),
                                this.copy(j, i)
                            ];
                        } else {
                            return false;
                        }
                    }
                };
                /**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */ Polygon.prototype.isSimple = function() {
                    var path = this.vertices;
                    // Check
                    for(var i = 0; i < path.length - 1; i++){
                        for(var j = 0; j < i - 1; j++){
                            if (Line.segmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                                return false;
                            }
                        }
                    }
                    // Check the segment between the last and the first point to all others
                    for(var i = 1; i < path.length - 2; i++){
                        if (Line.segmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                            return false;
                        }
                    }
                    return true;
                };
                function getIntersectionPoint(p1, p2, q1, q2, delta) {
                    delta = delta || 0;
                    var a1 = p2[1] - p1[1];
                    var b1 = p1[0] - p2[0];
                    var c1 = a1 * p1[0] + b1 * p1[1];
                    var a2 = q2[1] - q1[1];
                    var b2 = q1[0] - q2[0];
                    var c2 = a2 * q1[0] + b2 * q1[1];
                    var det = a1 * b2 - a2 * b1;
                    if (!Scalar.eq(det, 0, delta)) return [
                        (b2 * c1 - b1 * c2) / det,
                        (a1 * c2 - a2 * c1) / det
                    ];
                    else return [
                        0,
                        0
                    ];
                }
                /**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */ Polygon.prototype.quickDecomp = function(result, reflexVertices, steinerPoints, delta, maxlevel, level) {
                    maxlevel = maxlevel || 100;
                    level = level || 0;
                    delta = delta || 25;
                    result = typeof result != "undefined" ? result : [];
                    reflexVertices = reflexVertices || [];
                    steinerPoints = steinerPoints || [];
                    var upperInt = [
                        0,
                        0
                    ], lowerInt = [
                        0,
                        0
                    ], p = [
                        0,
                        0
                    ]; // Points
                    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0; // scalars
                    var upperIndex = 0, lowerIndex = 0, closestIndex = 0; // Integers
                    var lowerPoly = new Polygon(), upperPoly = new Polygon(); // polygons
                    var poly = this, v = this.vertices;
                    if (v.length < 3) return result;
                    level++;
                    if (level > maxlevel) {
                        console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
                        return result;
                    }
                    for(var i = 0; i < this.vertices.length; ++i){
                        if (poly.isReflex(i)) {
                            reflexVertices.push(poly.vertices[i]);
                            upperDist = lowerDist = Number.MAX_VALUE;
                            for(var j = 0; j < this.vertices.length; ++j){
                                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) {
                                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                                    if (Point.right(poly.at(i + 1), poly.at(i), p)) {
                                        d = Point.sqdist(poly.vertices[i], p);
                                        if (d < lowerDist) {
                                            lowerDist = d;
                                            lowerInt = p;
                                            lowerIndex = j;
                                        }
                                    }
                                }
                                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                                        d = Point.sqdist(poly.vertices[i], p);
                                        if (d < upperDist) {
                                            upperDist = d;
                                            upperInt = p;
                                            upperIndex = j;
                                        }
                                    }
                                }
                            }
                            // if there are no vertices to connect to, choose a point in the middle
                            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                                steinerPoints.push(p);
                                if (i < upperIndex) {
                                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                                    lowerPoly.append(poly, i, upperIndex + 1);
                                    lowerPoly.vertices.push(p);
                                    upperPoly.vertices.push(p);
                                    if (lowerIndex != 0) {
                                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                                        upperPoly.append(poly, lowerIndex, poly.vertices.length);
                                    }
                                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                                    upperPoly.append(poly, 0, i + 1);
                                } else {
                                    if (i != 0) {
                                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                                        lowerPoly.append(poly, i, poly.vertices.length);
                                    }
                                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                                    lowerPoly.append(poly, 0, upperIndex + 1);
                                    lowerPoly.vertices.push(p);
                                    upperPoly.vertices.push(p);
                                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                                    upperPoly.append(poly, lowerIndex, i + 1);
                                }
                            } else {
                                // connect to the closest point within the triangle
                                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");
                                if (lowerIndex > upperIndex) {
                                    upperIndex += this.vertices.length;
                                }
                                closestDist = Number.MAX_VALUE;
                                if (upperIndex < lowerIndex) {
                                    return result;
                                }
                                for(var j = lowerIndex; j <= upperIndex; ++j){
                                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                        d = Point.sqdist(poly.at(i), poly.at(j));
                                        if (d < closestDist) {
                                            closestDist = d;
                                            closestIndex = j % this.vertices.length;
                                        }
                                    }
                                }
                                if (i < closestIndex) {
                                    lowerPoly.append(poly, i, closestIndex + 1);
                                    if (closestIndex != 0) {
                                        upperPoly.append(poly, closestIndex, v.length);
                                    }
                                    upperPoly.append(poly, 0, i + 1);
                                } else {
                                    if (i != 0) {
                                        lowerPoly.append(poly, i, v.length);
                                    }
                                    lowerPoly.append(poly, 0, closestIndex + 1);
                                    upperPoly.append(poly, closestIndex, i + 1);
                                }
                            }
                            // solve smallest poly first
                            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                                lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                                upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            } else {
                                upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                                lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            }
                            return result;
                        }
                    }
                    result.push(this);
                    return result;
                };
                /**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */ Polygon.prototype.removeCollinearPoints = function(precision) {
                    var num = 0;
                    for(var i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i){
                        if (Point.collinear(this.at(i - 1), this.at(i), this.at(i + 1), precision)) {
                            // Remove the middle point
                            this.vertices.splice(i % this.vertices.length, 1);
                            i--; // Jump one point forward. Otherwise we may get a chain removal
                            num++;
                        }
                    }
                    return num;
                };
            },
            {
                "./Line": 1,
                "./Point": 2,
                "./Scalar": 4
            }
        ],
        4: [
            function(_dereq_, module1, exports1) {
                module1.exports = Scalar;
                /**
 * Scalar functions
 * @class Scalar
 */ function Scalar() {}
                /**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */ Scalar.eq = function(a, b, precision) {
                    precision = precision || 0;
                    return Math.abs(a - b) < precision;
                };
            },
            {}
        ],
        5: [
            function(_dereq_, module1, exports1) {
                module1.exports = {
                    Polygon: _dereq_("./Polygon"),
                    Point: _dereq_("./Point")
                };
            },
            {
                "./Point": 2,
                "./Polygon": 3
            }
        ],
        6: [
            function(_dereq_, module1, exports1) {
                module1.exports = {
                    "name": "p2",
                    "version": "0.7.1",
                    "description": "A JavaScript 2D physics engine.",
                    "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    "keywords": [
                        "p2.js",
                        "p2",
                        "physics",
                        "engine",
                        "2d"
                    ],
                    "main": "./src/p2.js",
                    "engines": {
                        "node": "*"
                    },
                    "repository": {
                        "type": "git",
                        "url": "https://github.com/schteppe/p2.js.git"
                    },
                    "bugs": {
                        "url": "https://github.com/schteppe/p2.js/issues"
                    },
                    "licenses": [
                        {
                            "type": "MIT"
                        }
                    ],
                    "devDependencies": {
                        "grunt": "^0.4.5",
                        "grunt-contrib-jshint": "^0.11.2",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-uglify": "~0.4.0",
                        "grunt-contrib-watch": "~0.5.0",
                        "grunt-browserify": "~2.0.1",
                        "grunt-contrib-concat": "^0.4.0"
                    },
                    "dependencies": {
                        "poly-decomp": "0.1.1"
                    }
                };
            },
            {}
        ],
        7: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), Utils = _dereq_('../utils/Utils');
                module1.exports = AABB;
                /**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */ function AABB(options) {
                    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */ this.lowerBound = vec2.create();
                    if (options && options.lowerBound) {
                        vec2.copy(this.lowerBound, options.lowerBound);
                    }
                    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */ this.upperBound = vec2.create();
                    if (options && options.upperBound) {
                        vec2.copy(this.upperBound, options.upperBound);
                    }
                }
                var tmp = vec2.create();
                /**
 * Set the AABB bounds from a set of points, transformed by the given position and angle.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 * @param {Array} position
 * @param {number} angle
 * @param {number} skinSize Some margin to be added to the AABB.
 */ AABB.prototype.setFromPoints = function(points, position, angle, skinSize) {
                    var l = this.lowerBound, u = this.upperBound;
                    if (typeof angle !== "number") {
                        angle = 0;
                    }
                    // Set to the first point
                    if (angle !== 0) {
                        vec2.rotate(l, points[0], angle);
                    } else {
                        vec2.copy(l, points[0]);
                    }
                    vec2.copy(u, l);
                    // Compute cosines and sines just once
                    var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
                    for(var i = 1; i < points.length; i++){
                        var p = points[i];
                        if (angle !== 0) {
                            var x = p[0], y = p[1];
                            tmp[0] = cosAngle * x - sinAngle * y;
                            tmp[1] = sinAngle * x + cosAngle * y;
                            p = tmp;
                        }
                        for(var j = 0; j < 2; j++){
                            if (p[j] > u[j]) {
                                u[j] = p[j];
                            }
                            if (p[j] < l[j]) {
                                l[j] = p[j];
                            }
                        }
                    }
                    // Add offset
                    if (position) {
                        vec2.add(this.lowerBound, this.lowerBound, position);
                        vec2.add(this.upperBound, this.upperBound, position);
                    }
                    if (skinSize) {
                        this.lowerBound[0] -= skinSize;
                        this.lowerBound[1] -= skinSize;
                        this.upperBound[0] += skinSize;
                        this.upperBound[1] += skinSize;
                    }
                };
                /**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */ AABB.prototype.copy = function(aabb) {
                    vec2.copy(this.lowerBound, aabb.lowerBound);
                    vec2.copy(this.upperBound, aabb.upperBound);
                };
                /**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */ AABB.prototype.extend = function(aabb) {
                    // Loop over x and y
                    var i = 2;
                    while(i--){
                        // Extend lower bound
                        var l = aabb.lowerBound[i];
                        if (this.lowerBound[i] > l) {
                            this.lowerBound[i] = l;
                        }
                        // Upper
                        var u = aabb.upperBound[i];
                        if (this.upperBound[i] < u) {
                            this.upperBound[i] = u;
                        }
                    }
                };
                /**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */ AABB.prototype.overlaps = function(aabb) {
                    var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
                    //      l2        u2
                    //      |---------|
                    // |--------|
                    // l1       u1
                    return (l2[0] <= u1[0] && u1[0] <= u2[0] || l1[0] <= u2[0] && u2[0] <= u1[0]) && (l2[1] <= u1[1] && u1[1] <= u2[1] || l1[1] <= u2[1] && u2[1] <= u1[1]);
                };
                /**
 * @method containsPoint
 * @param  {Array} point
 * @return {boolean}
 */ AABB.prototype.containsPoint = function(point) {
                    var l = this.lowerBound, u = this.upperBound;
                    return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
                };
                /**
 * Check if the AABB is hit by a ray.
 * @method overlapsRay
 * @param  {Ray} ray
 * @return {number} -1 if no hit, a number between 0 and 1 if hit.
 */ AABB.prototype.overlapsRay = function(ray) {
                    var t = 0;
                    // ray.direction is unit direction vector of ray
                    var dirFracX = 1 / ray.direction[0];
                    var dirFracY = 1 / ray.direction[1];
                    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
                    var t1 = (this.lowerBound[0] - ray.from[0]) * dirFracX;
                    var t2 = (this.upperBound[0] - ray.from[0]) * dirFracX;
                    var t3 = (this.lowerBound[1] - ray.from[1]) * dirFracY;
                    var t4 = (this.upperBound[1] - ray.from[1]) * dirFracY;
                    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
                    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
                    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
                    if (tmax < 0) {
                        //t = tmax;
                        return -1;
                    }
                    // if tmin > tmax, ray doesn't intersect AABB
                    if (tmin > tmax) {
                        //t = tmax;
                        return -1;
                    }
                    return tmin;
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }
        ],
        8: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2');
                var Body = _dereq_('../objects/Body');
                module1.exports = Broadphase;
                /**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */ function Broadphase(type) {
                    this.type = type;
                    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */ this.result = [];
                    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */ this.world = null;
                    /**
     * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.
     * @property {Number} boundingVolumeType
     */ this.boundingVolumeType = Broadphase.AABB;
                }
                /**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */ Broadphase.AABB = 1;
                /**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */ Broadphase.BOUNDING_CIRCLE = 2;
                /**
 * Set the world that we are searching for collision pairs in.
 * @method setWorld
 * @param  {World} world
 */ Broadphase.prototype.setWorld = function(world) {
                    this.world = world;
                };
                /**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */ Broadphase.prototype.getCollisionPairs = function(world) {};
                var dist = vec2.create();
                /**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */ Broadphase.boundingRadiusCheck = function(bodyA, bodyB) {
                    vec2.sub(dist, bodyA.position, bodyB.position);
                    var d2 = vec2.squaredLength(dist), r = bodyA.boundingRadius + bodyB.boundingRadius;
                    return d2 <= r * r;
                };
                /**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */ Broadphase.aabbCheck = function(bodyA, bodyB) {
                    return bodyA.getAABB().overlaps(bodyB.getAABB());
                };
                /**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */ Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB) {
                    var result;
                    switch(this.boundingVolumeType){
                        case Broadphase.BOUNDING_CIRCLE:
                            result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                            break;
                        case Broadphase.AABB:
                            result = Broadphase.aabbCheck(bodyA, bodyB);
                            break;
                        default:
                            throw new Error('Bounding volume type not recognized: ' + this.boundingVolumeType);
                    }
                    return result;
                };
                /**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */ Broadphase.canCollide = function(bodyA, bodyB) {
                    var KINEMATIC = Body.KINEMATIC;
                    var STATIC = Body.STATIC;
                    // Cannot collide static bodies
                    if (bodyA.type === STATIC && bodyB.type === STATIC) {
                        return false;
                    }
                    // Cannot collide static vs kinematic bodies
                    if (bodyA.type === KINEMATIC && bodyB.type === STATIC || bodyA.type === STATIC && bodyB.type === KINEMATIC) {
                        return false;
                    }
                    // Cannot collide kinematic vs kinematic
                    if (bodyA.type === KINEMATIC && bodyB.type === KINEMATIC) {
                        return false;
                    }
                    // Cannot collide both sleeping bodies
                    if (bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING) {
                        return false;
                    }
                    // Cannot collide if one is static and the other is sleeping
                    if (bodyA.sleepState === Body.SLEEPING && bodyB.type === STATIC || bodyB.sleepState === Body.SLEEPING && bodyA.type === STATIC) {
                        return false;
                    }
                    return true;
                };
                Broadphase.NAIVE = 1;
                Broadphase.SAP = 2;
            },
            {
                "../math/vec2": 30,
                "../objects/Body": 31
            }
        ],
        9: [
            function(_dereq_, module1, exports1) {
                var Circle = _dereq_('../shapes/Circle'), Plane = _dereq_('../shapes/Plane'), Shape = _dereq_('../shapes/Shape'), Particle = _dereq_('../shapes/Particle'), Broadphase = _dereq_('../collision/Broadphase'), vec2 = _dereq_('../math/vec2');
                module1.exports = NaiveBroadphase;
                /**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */ function NaiveBroadphase() {
                    Broadphase.call(this, Broadphase.NAIVE);
                }
                NaiveBroadphase.prototype = new Broadphase();
                NaiveBroadphase.prototype.constructor = NaiveBroadphase;
                /**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */ NaiveBroadphase.prototype.getCollisionPairs = function(world) {
                    var bodies = world.bodies, result = this.result;
                    result.length = 0;
                    for(var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++){
                        var bi = bodies[i];
                        for(var j = 0; j < i; j++){
                            var bj = bodies[j];
                            if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                                result.push(bi, bj);
                            }
                        }
                    }
                    return result;
                };
                /**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */ NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result) {
                    result = result || [];
                    var bodies = world.bodies;
                    for(var i = 0; i < bodies.length; i++){
                        var b = bodies[i];
                        if (b.aabbNeedsUpdate) {
                            b.updateAABB();
                        }
                        if (b.aabb.overlaps(aabb)) {
                            result.push(b);
                        }
                    }
                    return result;
                };
            },
            {
                "../collision/Broadphase": 8,
                "../math/vec2": 30,
                "../shapes/Circle": 39,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45
            }
        ],
        10: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), sub = vec2.sub, add = vec2.add, dot = vec2.dot, Utils = _dereq_('../utils/Utils'), ContactEquationPool = _dereq_('../utils/ContactEquationPool'), FrictionEquationPool = _dereq_('../utils/FrictionEquationPool'), TupleDictionary = _dereq_('../utils/TupleDictionary'), Equation = _dereq_('../equations/Equation'), ContactEquation = _dereq_('../equations/ContactEquation'), FrictionEquation = _dereq_('../equations/FrictionEquation'), Circle = _dereq_('../shapes/Circle'), Convex = _dereq_('../shapes/Convex'), Shape = _dereq_('../shapes/Shape'), Body = _dereq_('../objects/Body'), Box = _dereq_('../shapes/Box');
                module1.exports = Narrowphase;
                // Temp things
                var yAxis = vec2.fromValues(0, 1);
                var tmp1 = vec2.fromValues(0, 0), tmp2 = vec2.fromValues(0, 0), tmp3 = vec2.fromValues(0, 0), tmp4 = vec2.fromValues(0, 0), tmp5 = vec2.fromValues(0, 0), tmp6 = vec2.fromValues(0, 0), tmp7 = vec2.fromValues(0, 0), tmp8 = vec2.fromValues(0, 0), tmp9 = vec2.fromValues(0, 0), tmp10 = vec2.fromValues(0, 0), tmp11 = vec2.fromValues(0, 0), tmp12 = vec2.fromValues(0, 0), tmp13 = vec2.fromValues(0, 0), tmp14 = vec2.fromValues(0, 0), tmp15 = vec2.fromValues(0, 0), tmp16 = vec2.fromValues(0, 0), tmp17 = vec2.fromValues(0, 0), tmp18 = vec2.fromValues(0, 0), tmpArray = [];
                /**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */ function Narrowphase() {
                    /**
     * @property contactEquations
     * @type {Array}
     */ this.contactEquations = [];
                    /**
     * @property frictionEquations
     * @type {Array}
     */ this.frictionEquations = [];
                    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */ this.enableFriction = true;
                    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */ this.enabledEquations = true;
                    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */ this.slipForce = 10.0;
                    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */ this.frictionCoefficient = 0.3;
                    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */ this.surfaceVelocity = 0;
                    /**
     * Keeps track of the allocated ContactEquations.
     * @property {ContactEquationPool} contactEquationPool
     *
     * @example
     *
     *     // Allocate a few equations before starting the simulation.
     *     // This way, no contact objects need to be created on the fly in the game loop.
     *     world.narrowphase.contactEquationPool.resize(1024);
     *     world.narrowphase.frictionEquationPool.resize(1024);
     */ this.contactEquationPool = new ContactEquationPool({
                        size: 32
                    });
                    /**
     * Keeps track of the allocated ContactEquations.
     * @property {FrictionEquationPool} frictionEquationPool
     */ this.frictionEquationPool = new FrictionEquationPool({
                        size: 64
                    });
                    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */ this.restitution = 0;
                    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */ this.stiffness = Equation.DEFAULT_STIFFNESS;
                    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */ this.relaxation = Equation.DEFAULT_RELAXATION;
                    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */ this.frictionStiffness = Equation.DEFAULT_STIFFNESS;
                    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */ this.frictionRelaxation = Equation.DEFAULT_RELAXATION;
                    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */ this.enableFrictionReduction = true;
                    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */ this.collidingBodiesLastStep = new TupleDictionary();
                    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */ this.contactSkinSize = 0.01;
                }
                var bodiesOverlap_shapePositionA = vec2.create();
                var bodiesOverlap_shapePositionB = vec2.create();
                /**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 * @todo shape world transforms are wrong
 */ Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB) {
                    var shapePositionA = bodiesOverlap_shapePositionA;
                    var shapePositionB = bodiesOverlap_shapePositionB;
                    // Loop over all shapes of bodyA
                    for(var k = 0, Nshapesi = bodyA.shapes.length; k !== Nshapesi; k++){
                        var shapeA = bodyA.shapes[k];
                        bodyA.toWorldFrame(shapePositionA, shapeA.position);
                        // All shapes of body j
                        for(var l = 0, Nshapesj = bodyB.shapes.length; l !== Nshapesj; l++){
                            var shapeB = bodyB.shapes[l];
                            bodyB.toWorldFrame(shapePositionB, shapeB.position);
                            if (this[shapeA.type | shapeB.type](bodyA, shapeA, shapePositionA, shapeA.angle + bodyA.angle, bodyB, shapeB, shapePositionB, shapeB.angle + bodyB.angle, true)) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                /**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */ Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB) {
                    var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
                    return !!this.collidingBodiesLastStep.get(id1, id2);
                };
                /**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */ Narrowphase.prototype.reset = function() {
                    this.collidingBodiesLastStep.reset();
                    var eqs = this.contactEquations;
                    var l = eqs.length;
                    while(l--){
                        var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
                        this.collidingBodiesLastStep.set(id1, id2, true);
                    }
                    var ce = this.contactEquations, fe = this.frictionEquations;
                    for(var i = 0; i < ce.length; i++){
                        this.contactEquationPool.release(ce[i]);
                    }
                    for(var i = 0; i < fe.length; i++){
                        this.frictionEquationPool.release(fe[i]);
                    }
                    // Reset
                    this.contactEquations.length = this.frictionEquations.length = 0;
                };
                /**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */ Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB) {
                    var c = this.contactEquationPool.get();
                    c.bodyA = bodyA;
                    c.bodyB = bodyB;
                    c.shapeA = shapeA;
                    c.shapeB = shapeB;
                    c.restitution = this.restitution;
                    c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
                    c.stiffness = this.stiffness;
                    c.relaxation = this.relaxation;
                    c.needsUpdate = true;
                    c.enabled = this.enabledEquations;
                    c.offset = this.contactSkinSize;
                    return c;
                };
                /**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */ Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB) {
                    var c = this.frictionEquationPool.get();
                    c.bodyA = bodyA;
                    c.bodyB = bodyB;
                    c.shapeA = shapeA;
                    c.shapeB = shapeB;
                    c.setSlipForce(this.slipForce);
                    c.frictionCoefficient = this.frictionCoefficient;
                    c.relativeVelocity = this.surfaceVelocity;
                    c.enabled = this.enabledEquations;
                    c.needsUpdate = true;
                    c.stiffness = this.frictionStiffness;
                    c.relaxation = this.frictionRelaxation;
                    c.contactEquations.length = 0;
                    return c;
                };
                /**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */ Narrowphase.prototype.createFrictionFromContact = function(c) {
                    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                    vec2.copy(eq.contactPointA, c.contactPointA);
                    vec2.copy(eq.contactPointB, c.contactPointB);
                    vec2.rotate90cw(eq.t, c.normalA);
                    eq.contactEquations.push(c);
                    return eq;
                };
                // Take the average N latest contact point on the plane.
                Narrowphase.prototype.createFrictionFromAverage = function(numContacts) {
                    var c = this.contactEquations[this.contactEquations.length - 1];
                    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                    var bodyA = c.bodyA;
                    var bodyB = c.bodyB;
                    vec2.set(eq.contactPointA, 0, 0);
                    vec2.set(eq.contactPointB, 0, 0);
                    vec2.set(eq.t, 0, 0);
                    for(var i = 0; i !== numContacts; i++){
                        c = this.contactEquations[this.contactEquations.length - 1 - i];
                        if (c.bodyA === bodyA) {
                            vec2.add(eq.t, eq.t, c.normalA);
                            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
                        } else {
                            vec2.sub(eq.t, eq.t, c.normalA);
                            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
                        }
                        eq.contactEquations.push(c);
                    }
                    var invNumContacts = 1 / numContacts;
                    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
                    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
                    vec2.normalize(eq.t, eq.t);
                    vec2.rotate90cw(eq.t, eq.t);
                    return eq;
                };
                /**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */ Narrowphase.prototype[Shape.LINE | Shape.CONVEX] = Narrowphase.prototype.convexLine = function(convexBody, convexShape, convexOffset, convexAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                    // TODO
                    if (justTest) {
                        return false;
                    } else {
                        return 0;
                    }
                };
                /**
 * Line/box narrowphase
 * @method lineBox
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       boxBody
 * @param  {Box}  boxShape
 * @param  {Array}      boxOffset
 * @param  {Number}     boxAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */ Narrowphase.prototype[Shape.LINE | Shape.BOX] = Narrowphase.prototype.lineBox = function(lineBody, lineShape, lineOffset, lineAngle, boxBody, boxShape, boxOffset, boxAngle, justTest) {
                    // TODO
                    if (justTest) {
                        return false;
                    } else {
                        return 0;
                    }
                };
                function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
                    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
                    vec2.set(convexShape.vertices[1], capsuleShape.length * 0.5, -capsuleShape.radius);
                    vec2.set(convexShape.vertices[2], capsuleShape.length * 0.5, capsuleShape.radius);
                    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5, capsuleShape.radius);
                }
                var convexCapsule_tempRect = new Box({
                    width: 1,
                    height: 1
                }), convexCapsule_tempVec = vec2.create();
                /**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */ Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] = Narrowphase.prototype[Shape.CAPSULE | Shape.BOX] = Narrowphase.prototype.convexCapsule = function(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                    // Check the circles
                    // Add offsets!
                    var circlePos = convexCapsule_tempVec;
                    vec2.set(circlePos, capsuleShape.length / 2, 0);
                    vec2.rotate(circlePos, circlePos, capsuleAngle);
                    vec2.add(circlePos, circlePos, capsulePosition);
                    var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                    vec2.set(circlePos, -capsuleShape.length / 2, 0);
                    vec2.rotate(circlePos, circlePos, capsuleAngle);
                    vec2.add(circlePos, circlePos, capsulePosition);
                    var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                    if (justTest && (result1 || result2)) {
                        return true;
                    }
                    // Check center rect
                    var r = convexCapsule_tempRect;
                    setConvexToCapsuleShapeMiddle(r, capsuleShape);
                    var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
                    return result + result1 + result2;
                };
                /**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */ Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] = Narrowphase.prototype.lineCapsule = function(lineBody, lineShape, linePosition, lineAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                    // TODO
                    if (justTest) {
                        return false;
                    } else {
                        return 0;
                    }
                };
                var capsuleCapsule_tempVec1 = vec2.create();
                var capsuleCapsule_tempVec2 = vec2.create();
                var capsuleCapsule_tempRect1 = new Box({
                    width: 1,
                    height: 1
                });
                /**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */ Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] = Narrowphase.prototype.capsuleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                    var enableFrictionBefore;
                    // Check the circles
                    // Add offsets!
                    var circlePosi = capsuleCapsule_tempVec1, circlePosj = capsuleCapsule_tempVec2;
                    var numContacts = 0;
                    // Need 4 circle checks, between all
                    for(var i = 0; i < 2; i++){
                        vec2.set(circlePosi, (i === 0 ? -1 : 1) * si.length / 2, 0);
                        vec2.rotate(circlePosi, circlePosi, ai);
                        vec2.add(circlePosi, circlePosi, xi);
                        for(var j = 0; j < 2; j++){
                            vec2.set(circlePosj, (j === 0 ? -1 : 1) * sj.length / 2, 0);
                            vec2.rotate(circlePosj, circlePosj, aj);
                            vec2.add(circlePosj, circlePosj, xj);
                            // Temporarily turn off friction
                            if (this.enableFrictionReduction) {
                                enableFrictionBefore = this.enableFriction;
                                this.enableFriction = false;
                            }
                            var result = this.circleCircle(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.radius, sj.radius);
                            if (this.enableFrictionReduction) {
                                this.enableFriction = enableFrictionBefore;
                            }
                            if (justTest && result) {
                                return true;
                            }
                            numContacts += result;
                        }
                    }
                    if (this.enableFrictionReduction) {
                        // Temporarily turn off friction
                        enableFrictionBefore = this.enableFriction;
                        this.enableFriction = false;
                    }
                    // Check circles against the center boxs
                    var rect = capsuleCapsule_tempRect1;
                    setConvexToCapsuleShapeMiddle(rect, si);
                    var result1 = this.convexCapsule(bi, rect, xi, ai, bj, sj, xj, aj, justTest);
                    if (this.enableFrictionReduction) {
                        this.enableFriction = enableFrictionBefore;
                    }
                    if (justTest && result1) {
                        return true;
                    }
                    numContacts += result1;
                    if (this.enableFrictionReduction) {
                        // Temporarily turn off friction
                        var enableFrictionBefore = this.enableFriction;
                        this.enableFriction = false;
                    }
                    setConvexToCapsuleShapeMiddle(rect, sj);
                    var result2 = this.convexCapsule(bj, rect, xj, aj, bi, si, xi, ai, justTest);
                    if (this.enableFrictionReduction) {
                        this.enableFriction = enableFrictionBefore;
                    }
                    if (justTest && result2) {
                        return true;
                    }
                    numContacts += result2;
                    if (this.enableFrictionReduction) {
                        if (numContacts && this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                        }
                    }
                    return numContacts;
                };
                /**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */ Narrowphase.prototype[Shape.LINE | Shape.LINE] = Narrowphase.prototype.lineLine = function(bodyA, shapeA, positionA, angleA, bodyB, shapeB, positionB, angleB, justTest) {
                    // TODO
                    if (justTest) {
                        return false;
                    } else {
                        return 0;
                    }
                };
                /**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */ Narrowphase.prototype[Shape.PLANE | Shape.LINE] = Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                    var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
                    // Get start and end points
                    vec2.set(worldVertex0, -lineShape.length / 2, 0);
                    vec2.set(worldVertex1, lineShape.length / 2, 0);
                    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
                    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                    vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                    add(worldVertex01, worldVertex01, lineOffset);
                    add(worldVertex11, worldVertex11, lineOffset);
                    vec2.copy(worldVertex0, worldVertex01);
                    vec2.copy(worldVertex1, worldVertex11);
                    // Get vector along the line
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    // Get tangent to the edge.
                    vec2.rotate90cw(worldTangent, worldEdgeUnit);
                    vec2.rotate(worldNormal, yAxis, planeAngle);
                    // Check line ends
                    verts[0] = worldVertex0;
                    verts[1] = worldVertex1;
                    for(var i = 0; i < verts.length; i++){
                        var v = verts[i];
                        sub(dist, v, planeOffset);
                        var d = dot(dist, worldNormal);
                        if (d < 0) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                            numContacts++;
                            vec2.copy(c.normalA, worldNormal);
                            vec2.normalize(c.normalA, c.normalA);
                            // distance vector along plane normal
                            vec2.scale(dist, worldNormal, d);
                            // Vector from plane center to contact
                            sub(c.contactPointA, v, dist);
                            sub(c.contactPointA, c.contactPointA, planeBody.position);
                            // From line center to contact
                            sub(c.contactPointB, v, lineOffset);
                            add(c.contactPointB, c.contactPointB, lineOffset);
                            sub(c.contactPointB, c.contactPointB, lineBody.position);
                            this.contactEquations.push(c);
                            if (!this.enableFrictionReduction) {
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                            }
                        }
                    }
                    if (justTest) {
                        return false;
                    }
                    if (!this.enableFrictionReduction) {
                        if (numContacts && this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                        }
                    }
                    return numContacts;
                };
                Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] = Narrowphase.prototype.particleCapsule = function(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                    return this.circleLine(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
                };
                /**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */ Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] = Narrowphase.prototype.circleLine = function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
                    var lineRadius = lineRadius || 0, circleRadius = typeof circleRadius !== "undefined" ? circleRadius : circleShape.radius, orthoDist = tmp1, lineToCircleOrthoUnit = tmp2, projectedPoint = tmp3, centerDist = tmp4, worldTangent = tmp5, worldEdge = tmp6, worldEdgeUnit = tmp7, worldVertex0 = tmp8, worldVertex1 = tmp9, worldVertex01 = tmp10, worldVertex11 = tmp11, dist = tmp12, lineToCircle = tmp13, lineEndToLineRadius = tmp14, verts = tmpArray;
                    // Get start and end points
                    vec2.set(worldVertex0, -lineShape.length / 2, 0);
                    vec2.set(worldVertex1, lineShape.length / 2, 0);
                    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
                    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                    vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                    add(worldVertex01, worldVertex01, lineOffset);
                    add(worldVertex11, worldVertex11, lineOffset);
                    vec2.copy(worldVertex0, worldVertex01);
                    vec2.copy(worldVertex1, worldVertex11);
                    // Get vector along the line
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    // Get tangent to the edge.
                    vec2.rotate90cw(worldTangent, worldEdgeUnit);
                    // Check distance from the plane spanned by the edge vs the circle
                    sub(dist, circleOffset, worldVertex0);
                    var d = dot(dist, worldTangent); // Distance from center of line to circle center
                    sub(centerDist, worldVertex0, lineOffset);
                    sub(lineToCircle, circleOffset, lineOffset);
                    var radiusSum = circleRadius + lineRadius;
                    if (Math.abs(d) < radiusSum) {
                        // Now project the circle onto the edge
                        vec2.scale(orthoDist, worldTangent, d);
                        sub(projectedPoint, circleOffset, orthoDist);
                        // Add the missing line radius
                        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
                        vec2.normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
                        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
                        add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
                        // Check if the point is within the edge span
                        var pos = dot(worldEdgeUnit, projectedPoint);
                        var pos0 = dot(worldEdgeUnit, worldVertex0);
                        var pos1 = dot(worldEdgeUnit, worldVertex1);
                        if (pos > pos0 && pos < pos1) {
                            // We got contact!
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                            vec2.scale(c.normalA, orthoDist, -1);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointA, c.normalA, circleRadius);
                            add(c.contactPointA, c.contactPointA, circleOffset);
                            sub(c.contactPointA, c.contactPointA, circleBody.position);
                            sub(c.contactPointB, projectedPoint, lineOffset);
                            add(c.contactPointB, c.contactPointB, lineOffset);
                            sub(c.contactPointB, c.contactPointB, lineBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                            return 1;
                        }
                    }
                    // Add corner
                    verts[0] = worldVertex0;
                    verts[1] = worldVertex1;
                    for(var i = 0; i < verts.length; i++){
                        var v = verts[i];
                        sub(dist, v, circleOffset);
                        if (vec2.squaredLength(dist) < Math.pow(radiusSum, 2)) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            // Vector from circle to contact point is the normal times the circle radius
                            vec2.scale(c.contactPointA, c.normalA, circleRadius);
                            add(c.contactPointA, c.contactPointA, circleOffset);
                            sub(c.contactPointA, c.contactPointA, circleBody.position);
                            sub(c.contactPointB, v, lineOffset);
                            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
                            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                            add(c.contactPointB, c.contactPointB, lineOffset);
                            sub(c.contactPointB, c.contactPointB, lineBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                            return 1;
                        }
                    }
                    return 0;
                };
                /**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */ Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] = Narrowphase.prototype.circleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                    return this.circleLine(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.radius);
                };
                /**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */ Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] = Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] = Narrowphase.prototype.circleConvex = function(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
                    var circleRadius = typeof circleRadius === "number" ? circleRadius : circleShape.radius;
                    var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldNormal = tmp5, centerDist = tmp6, convexToCircle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, minCandidate = tmp16, found = false, minCandidateDistance = Number.MAX_VALUE;
                    var numReported = 0;
                    // New algorithm:
                    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
                    // 2. For each edge
                    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
                    // 2. 2. Check if point is inside.
                    var verts = convexShape.vertices;
                    // Check all edges first
                    for(var i = 0; i !== verts.length + 1; i++){
                        var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                        vec2.rotate(worldVertex0, v0, convexAngle);
                        vec2.rotate(worldVertex1, v1, convexAngle);
                        add(worldVertex0, worldVertex0, convexOffset);
                        add(worldVertex1, worldVertex1, convexOffset);
                        sub(worldEdge, worldVertex1, worldVertex0);
                        vec2.normalize(worldEdgeUnit, worldEdge);
                        // Get tangent to the edge. Points out of the Convex
                        vec2.rotate90cw(worldNormal, worldEdgeUnit);
                        // Get point on circle, closest to the polygon
                        vec2.scale(candidate, worldNormal, -circleShape.radius);
                        add(candidate, candidate, circleOffset);
                        if (pointInConvex(candidate, convexShape, convexOffset, convexAngle)) {
                            vec2.sub(candidateDist, worldVertex0, candidate);
                            var candidateDistance = Math.abs(vec2.dot(candidateDist, worldNormal));
                            if (candidateDistance < minCandidateDistance) {
                                vec2.copy(minCandidate, candidate);
                                minCandidateDistance = candidateDistance;
                                vec2.scale(closestEdgeProjectedPoint, worldNormal, candidateDistance);
                                vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
                                found = true;
                            }
                        }
                    }
                    if (found) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                        vec2.sub(c.normalA, minCandidate, circleOffset);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                        add(c.contactPointB, c.contactPointB, convexOffset);
                        sub(c.contactPointB, c.contactPointB, convexBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                    // Check all vertices
                    if (circleRadius > 0) {
                        for(var i = 0; i < verts.length; i++){
                            var localVertex = verts[i];
                            vec2.rotate(worldVertex, localVertex, convexAngle);
                            add(worldVertex, worldVertex, convexOffset);
                            sub(dist, worldVertex, circleOffset);
                            if (vec2.squaredLength(dist) < Math.pow(circleRadius, 2)) {
                                if (justTest) {
                                    return true;
                                }
                                var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                                vec2.copy(c.normalA, dist);
                                vec2.normalize(c.normalA, c.normalA);
                                // Vector from circle to contact point is the normal times the circle radius
                                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                                add(c.contactPointA, c.contactPointA, circleOffset);
                                sub(c.contactPointA, c.contactPointA, circleBody.position);
                                sub(c.contactPointB, worldVertex, convexOffset);
                                add(c.contactPointB, c.contactPointB, convexOffset);
                                sub(c.contactPointB, c.contactPointB, convexBody.position);
                                this.contactEquations.push(c);
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                                return 1;
                            }
                        }
                    }
                    return 0;
                };
                var pic_worldVertex0 = vec2.create(), pic_worldVertex1 = vec2.create(), pic_r0 = vec2.create(), pic_r1 = vec2.create();
                /*
 * Check if a point is in a polygon
 */ function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
                    var worldVertex0 = pic_worldVertex0, worldVertex1 = pic_worldVertex1, r0 = pic_r0, r1 = pic_r1, point = worldPoint, verts = convexShape.vertices, lastCross = null;
                    for(var i = 0; i !== verts.length + 1; i++){
                        var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                        // Transform vertices to world
                        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
                        vec2.rotate(worldVertex0, v0, convexAngle);
                        vec2.rotate(worldVertex1, v1, convexAngle);
                        add(worldVertex0, worldVertex0, convexOffset);
                        add(worldVertex1, worldVertex1, convexOffset);
                        sub(r0, worldVertex0, point);
                        sub(r1, worldVertex1, point);
                        var cross = vec2.crossLength(r0, r1);
                        if (lastCross === null) {
                            lastCross = cross;
                        }
                        // If we got a different sign of the distance vector, the point is out of the polygon
                        if (cross * lastCross <= 0) {
                            return false;
                        }
                        lastCross = cross;
                    }
                    return true;
                }
                /**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */ Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] = Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] = Narrowphase.prototype.particleConvex = function(particleBody, particleShape, particleOffset, particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                    var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, r0 = tmp14, r1 = tmp15, localPoint = tmp16, candidateDist = tmp17, minEdgeNormal = tmp18, minCandidateDistance = Number.MAX_VALUE;
                    var numReported = 0, found = false, verts = convexShape.vertices;
                    // Check if the particle is in the polygon at all
                    if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
                        return 0;
                    }
                    if (justTest) {
                        return true;
                    }
                    // Check edges first
                    var lastCross = null;
                    for(var i = 0; i !== verts.length + 1; i++){
                        var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                        // Transform vertices to world
                        vec2.rotate(worldVertex0, v0, convexAngle);
                        vec2.rotate(worldVertex1, v1, convexAngle);
                        add(worldVertex0, worldVertex0, convexOffset);
                        add(worldVertex1, worldVertex1, convexOffset);
                        // Get world edge
                        sub(worldEdge, worldVertex1, worldVertex0);
                        vec2.normalize(worldEdgeUnit, worldEdge);
                        // Get tangent to the edge. Points out of the Convex
                        vec2.rotate90cw(worldTangent, worldEdgeUnit);
                        // Check distance from the infinite line (spanned by the edge) to the particle
                        sub(dist, particleOffset, worldVertex0);
                        var d = dot(dist, worldTangent);
                        sub(centerDist, worldVertex0, convexOffset);
                        sub(convexToparticle, particleOffset, convexOffset);
                        vec2.sub(candidateDist, worldVertex0, particleOffset);
                        var candidateDistance = Math.abs(vec2.dot(candidateDist, worldTangent));
                        if (candidateDistance < minCandidateDistance) {
                            minCandidateDistance = candidateDistance;
                            vec2.scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                            vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                            vec2.copy(minEdgeNormal, worldTangent);
                            found = true;
                        }
                    }
                    if (found) {
                        var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
                        vec2.scale(c.normalA, minEdgeNormal, -1);
                        vec2.normalize(c.normalA, c.normalA);
                        // Particle has no extent to the contact point
                        vec2.set(c.contactPointA, 0, 0);
                        add(c.contactPointA, c.contactPointA, particleOffset);
                        sub(c.contactPointA, c.contactPointA, particleBody.position);
                        // From convex center to point
                        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                        add(c.contactPointB, c.contactPointB, convexOffset);
                        sub(c.contactPointB, c.contactPointB, convexBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                    return 0;
                };
                /**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */ Narrowphase.prototype[Shape.CIRCLE] = Narrowphase.prototype.circleCircle = function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA, radiusB) {
                    var dist = tmp1, radiusA = radiusA || shapeA.radius, radiusB = radiusB || shapeB.radius;
                    sub(dist, offsetA, offsetB);
                    var r = radiusA + radiusB;
                    if (vec2.squaredLength(dist) > Math.pow(r, 2)) {
                        return 0;
                    }
                    if (justTest) {
                        return true;
                    }
                    var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                    sub(c.normalA, offsetB, offsetA);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.scale(c.contactPointA, c.normalA, radiusA);
                    vec2.scale(c.contactPointB, c.normalA, -radiusB);
                    add(c.contactPointA, c.contactPointA, offsetA);
                    sub(c.contactPointA, c.contactPointA, bodyA.position);
                    add(c.contactPointB, c.contactPointB, offsetB);
                    sub(c.contactPointB, c.contactPointB, bodyB.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                };
                /**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */ Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] = Narrowphase.prototype[Shape.PLANE | Shape.BOX] = Narrowphase.prototype.planeConvex = function(planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                    var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3;
                    var numReported = 0;
                    vec2.rotate(worldNormal, yAxis, planeAngle);
                    for(var i = 0; i !== convexShape.vertices.length; i++){
                        var v = convexShape.vertices[i];
                        vec2.rotate(worldVertex, v, convexAngle);
                        add(worldVertex, worldVertex, convexOffset);
                        sub(dist, worldVertex, planeOffset);
                        if (dot(dist, worldNormal) <= 0) {
                            if (justTest) {
                                return true;
                            }
                            // Found vertex
                            numReported++;
                            var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                            sub(dist, worldVertex, planeOffset);
                            vec2.copy(c.normalA, worldNormal);
                            var d = dot(dist, c.normalA);
                            vec2.scale(dist, c.normalA, d);
                            // rj is from convex center to contact
                            sub(c.contactPointB, worldVertex, convexBody.position);
                            // ri is from plane center to contact
                            sub(c.contactPointA, worldVertex, dist);
                            sub(c.contactPointA, c.contactPointA, planeBody.position);
                            this.contactEquations.push(c);
                            if (!this.enableFrictionReduction) {
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                            }
                        }
                    }
                    if (this.enableFrictionReduction) {
                        if (this.enableFriction && numReported) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
                        }
                    }
                    return numReported;
                };
                /**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */ Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] = Narrowphase.prototype.particlePlane = function(particleBody, particleShape, particleOffset, particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
                    var dist = tmp1, worldNormal = tmp2;
                    planeAngle = planeAngle || 0;
                    sub(dist, particleOffset, planeOffset);
                    vec2.rotate(worldNormal, yAxis, planeAngle);
                    var d = dot(dist, worldNormal);
                    if (d > 0) {
                        return 0;
                    }
                    if (justTest) {
                        return true;
                    }
                    var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
                    vec2.copy(c.normalA, worldNormal);
                    vec2.scale(dist, c.normalA, d);
                    // dist is now the distance vector in the normal direction
                    // ri is the particle position projected down onto the plane, from the plane center
                    sub(c.contactPointA, particleOffset, dist);
                    sub(c.contactPointA, c.contactPointA, planeBody.position);
                    // rj is from the body center to the particle center
                    sub(c.contactPointB, particleOffset, particleBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                };
                /**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */ Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] = Narrowphase.prototype.circleParticle = function(circleBody, circleShape, circleOffset, circleAngle, particleBody, particleShape, particleOffset, particleAngle, justTest) {
                    var dist = tmp1;
                    sub(dist, particleOffset, circleOffset);
                    if (vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)) {
                        return 0;
                    }
                    if (justTest) {
                        return true;
                    }
                    var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
                    vec2.copy(c.normalA, dist);
                    vec2.normalize(c.normalA, c.normalA);
                    // Vector from circle to contact point is the normal times the circle radius
                    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    // Vector from particle center to contact point is zero
                    sub(c.contactPointB, particleOffset, particleBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                };
                var planeCapsule_tmpCircle = new Circle({
                    radius: 1
                }), planeCapsule_tmp1 = vec2.create(), planeCapsule_tmp2 = vec2.create(), planeCapsule_tmp3 = vec2.create();
                /**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */ Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] = Narrowphase.prototype.planeCapsule = function(planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
                    var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, dst = planeCapsule_tmp3;
                    // Compute world end positions
                    vec2.set(end1, -capsuleShape.length / 2, 0);
                    vec2.rotate(end1, end1, capsuleAngle);
                    add(end1, end1, capsuleOffset);
                    vec2.set(end2, capsuleShape.length / 2, 0);
                    vec2.rotate(end2, end2, capsuleAngle);
                    add(end2, end2, capsuleOffset);
                    circle.radius = capsuleShape.radius;
                    var enableFrictionBefore;
                    // Temporarily turn off friction
                    if (this.enableFrictionReduction) {
                        enableFrictionBefore = this.enableFriction;
                        this.enableFriction = false;
                    }
                    // Do Narrowphase as two circles
                    var numContacts1 = this.circlePlane(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
                    // Restore friction
                    if (this.enableFrictionReduction) {
                        this.enableFriction = enableFrictionBefore;
                    }
                    if (justTest) {
                        return numContacts1 || numContacts2;
                    } else {
                        var numTotal = numContacts1 + numContacts2;
                        if (this.enableFrictionReduction) {
                            if (numTotal) {
                                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                            }
                        }
                        return numTotal;
                    }
                };
                /**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */ Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] = Narrowphase.prototype.circlePlane = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                    var circleBody = bi, circleShape = si, circleOffset = xi, planeBody = bj, shapeB = sj, planeOffset = xj, planeAngle = aj;
                    planeAngle = planeAngle || 0;
                    // Vector from plane to circle
                    var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
                    sub(planeToCircle, circleOffset, planeOffset);
                    // World plane normal
                    vec2.rotate(worldNormal, yAxis, planeAngle);
                    // Normal direction distance
                    var d = dot(worldNormal, planeToCircle);
                    if (d > circleShape.radius) {
                        return 0; // No overlap. Abort.
                    }
                    if (justTest) {
                        return true;
                    }
                    // Create contact
                    var contact = this.createContactEquation(planeBody, circleBody, sj, si);
                    // ni is the plane world normal
                    vec2.copy(contact.normalA, worldNormal);
                    // rj is the vector from circle center to the contact point
                    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
                    add(contact.contactPointB, contact.contactPointB, circleOffset);
                    sub(contact.contactPointB, contact.contactPointB, circleBody.position);
                    // ri is the distance from plane center to contact.
                    vec2.scale(temp, contact.normalA, d);
                    sub(contact.contactPointA, planeToCircle, temp); // Subtract normal distance vector from the distance vector
                    add(contact.contactPointA, contact.contactPointA, planeOffset);
                    sub(contact.contactPointA, contact.contactPointA, planeBody.position);
                    this.contactEquations.push(contact);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(contact));
                    }
                    return 1;
                };
                /**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */ Narrowphase.prototype[Shape.CONVEX] = Narrowphase.prototype[Shape.CONVEX | Shape.BOX] = Narrowphase.prototype[Shape.BOX] = Narrowphase.prototype.convexConvex = function(bi, si, xi, ai, bj, sj, xj, aj, justTest, precision) {
                    var sepAxis = tmp1, worldPoint = tmp2, worldPoint0 = tmp3, worldPoint1 = tmp4, worldEdge = tmp5, projected = tmp6, penetrationVec = tmp7, dist = tmp8, worldNormal = tmp9, numContacts = 0, precision = typeof precision === 'number' ? precision : 0;
                    var found = Narrowphase.findSeparatingAxis(si, xi, ai, sj, xj, aj, sepAxis);
                    if (!found) {
                        return 0;
                    }
                    // Make sure the separating axis is directed from shape i to shape j
                    sub(dist, xj, xi);
                    if (dot(sepAxis, dist) > 0) {
                        vec2.scale(sepAxis, sepAxis, -1);
                    }
                    // Find edges with normals closest to the separating axis
                    var closestEdge1 = Narrowphase.getClosestEdge(si, ai, sepAxis, true), closestEdge2 = Narrowphase.getClosestEdge(sj, aj, sepAxis);
                    if (closestEdge1 === -1 || closestEdge2 === -1) {
                        return 0;
                    }
                    // Loop over the shapes
                    for(var k = 0; k < 2; k++){
                        var closestEdgeA = closestEdge1, closestEdgeB = closestEdge2, shapeA = si, shapeB = sj, offsetA = xi, offsetB = xj, angleA = ai, angleB = aj, bodyA = bi, bodyB = bj;
                        if (k === 0) {
                            // Swap!
                            var tmp;
                            tmp = closestEdgeA;
                            closestEdgeA = closestEdgeB;
                            closestEdgeB = tmp;
                            tmp = shapeA;
                            shapeA = shapeB;
                            shapeB = tmp;
                            tmp = offsetA;
                            offsetA = offsetB;
                            offsetB = tmp;
                            tmp = angleA;
                            angleA = angleB;
                            angleB = tmp;
                            tmp = bodyA;
                            bodyA = bodyB;
                            bodyB = tmp;
                        }
                        // Loop over 2 points in convex B
                        for(var j = closestEdgeB; j < closestEdgeB + 2; j++){
                            // Get world point
                            var v = shapeB.vertices[(j + shapeB.vertices.length) % shapeB.vertices.length];
                            vec2.rotate(worldPoint, v, angleB);
                            add(worldPoint, worldPoint, offsetB);
                            var insideNumEdges = 0;
                            // Loop over the 3 closest edges in convex A
                            for(var i = closestEdgeA - 1; i < closestEdgeA + 2; i++){
                                var v0 = shapeA.vertices[(i + shapeA.vertices.length) % shapeA.vertices.length], v1 = shapeA.vertices[(i + 1 + shapeA.vertices.length) % shapeA.vertices.length];
                                // Construct the edge
                                vec2.rotate(worldPoint0, v0, angleA);
                                vec2.rotate(worldPoint1, v1, angleA);
                                add(worldPoint0, worldPoint0, offsetA);
                                add(worldPoint1, worldPoint1, offsetA);
                                sub(worldEdge, worldPoint1, worldPoint0);
                                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                                vec2.normalize(worldNormal, worldNormal);
                                sub(dist, worldPoint, worldPoint0);
                                var d = dot(worldNormal, dist);
                                if (i === closestEdgeA && d <= precision || i !== closestEdgeA && d <= 0) {
                                    insideNumEdges++;
                                }
                            }
                            if (insideNumEdges >= 3) {
                                if (justTest) {
                                    return true;
                                }
                                // worldPoint was on the "inside" side of each of the 3 checked edges.
                                // Project it to the center edge and use the projection direction as normal
                                // Create contact
                                var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                                numContacts++;
                                // Get center edge from body A
                                var v0 = shapeA.vertices[closestEdgeA % shapeA.vertices.length], v1 = shapeA.vertices[(closestEdgeA + 1) % shapeA.vertices.length];
                                // Construct the edge
                                vec2.rotate(worldPoint0, v0, angleA);
                                vec2.rotate(worldPoint1, v1, angleA);
                                add(worldPoint0, worldPoint0, offsetA);
                                add(worldPoint1, worldPoint1, offsetA);
                                sub(worldEdge, worldPoint1, worldPoint0);
                                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                                vec2.normalize(c.normalA, c.normalA);
                                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                                var d = dot(c.normalA, dist); // Penetration
                                vec2.scale(penetrationVec, c.normalA, d); // Vector penetration
                                sub(c.contactPointA, worldPoint, offsetA);
                                sub(c.contactPointA, c.contactPointA, penetrationVec);
                                add(c.contactPointA, c.contactPointA, offsetA);
                                sub(c.contactPointA, c.contactPointA, bodyA.position);
                                sub(c.contactPointB, worldPoint, offsetB);
                                add(c.contactPointB, c.contactPointB, offsetB);
                                sub(c.contactPointB, c.contactPointB, bodyB.position);
                                this.contactEquations.push(c);
                                // Todo reduce to 1 friction equation if we have 2 contact points
                                if (!this.enableFrictionReduction) {
                                    if (this.enableFriction) {
                                        this.frictionEquations.push(this.createFrictionFromContact(c));
                                    }
                                }
                            }
                        }
                    }
                    if (this.enableFrictionReduction) {
                        if (this.enableFriction && numContacts) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                        }
                    }
                    return numContacts;
                };
                // .projectConvex is called by other functions, need local tmp vectors
                var pcoa_tmp1 = vec2.fromValues(0, 0);
                /**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */ Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result) {
                    var max = null, min = null, v, value, localAxis = pcoa_tmp1;
                    // Convert the axis to local coords of the body
                    vec2.rotate(localAxis, worldAxis, -convexAngle);
                    // Get projected position of all vertices
                    for(var i = 0; i < convexShape.vertices.length; i++){
                        v = convexShape.vertices[i];
                        value = dot(v, localAxis);
                        if (max === null || value > max) {
                            max = value;
                        }
                        if (min === null || value < min) {
                            min = value;
                        }
                    }
                    if (min > max) {
                        var t = min;
                        min = max;
                        max = t;
                    }
                    // Project the position of the body onto the axis - need to add this to the result
                    var offset = dot(convexOffset, worldAxis);
                    vec2.set(result, min + offset, max + offset);
                };
                // .findSeparatingAxis is called by other functions, need local tmp vectors
                var fsa_tmp1 = vec2.fromValues(0, 0), fsa_tmp2 = vec2.fromValues(0, 0), fsa_tmp3 = vec2.fromValues(0, 0), fsa_tmp4 = vec2.fromValues(0, 0), fsa_tmp5 = vec2.fromValues(0, 0), fsa_tmp6 = vec2.fromValues(0, 0);
                /**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */ Narrowphase.findSeparatingAxis = function(c1, offset1, angle1, c2, offset2, angle2, sepAxis) {
                    var maxDist = null, overlap = false, found = false, edge = fsa_tmp1, worldPoint0 = fsa_tmp2, worldPoint1 = fsa_tmp3, normal = fsa_tmp4, span1 = fsa_tmp5, span2 = fsa_tmp6;
                    if (c1 instanceof Box && c2 instanceof Box) {
                        for(var j = 0; j !== 2; j++){
                            var c = c1, angle = angle1;
                            if (j === 1) {
                                c = c2;
                                angle = angle2;
                            }
                            for(var i = 0; i !== 2; i++){
                                // Get the world edge
                                if (i === 0) {
                                    vec2.set(normal, 0, 1);
                                } else if (i === 1) {
                                    vec2.set(normal, 1, 0);
                                }
                                if (angle !== 0) {
                                    vec2.rotate(normal, normal, angle);
                                }
                                // Project hulls onto that normal
                                Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                                Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                                // Order by span position
                                var a = span1, b = span2, swapped = false;
                                if (span1[0] > span2[0]) {
                                    b = span1;
                                    a = span2;
                                    swapped = true;
                                }
                                // Get separating distance
                                var dist = b[0] - a[1];
                                overlap = dist <= 0;
                                if (maxDist === null || dist > maxDist) {
                                    vec2.copy(sepAxis, normal);
                                    maxDist = dist;
                                    found = overlap;
                                }
                            }
                        }
                    } else {
                        for(var j = 0; j !== 2; j++){
                            var c = c1, angle = angle1;
                            if (j === 1) {
                                c = c2;
                                angle = angle2;
                            }
                            for(var i = 0; i !== c.vertices.length; i++){
                                // Get the world edge
                                vec2.rotate(worldPoint0, c.vertices[i], angle);
                                vec2.rotate(worldPoint1, c.vertices[(i + 1) % c.vertices.length], angle);
                                sub(edge, worldPoint1, worldPoint0);
                                // Get normal - just rotate 90 degrees since vertices are given in CCW
                                vec2.rotate90cw(normal, edge);
                                vec2.normalize(normal, normal);
                                // Project hulls onto that normal
                                Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                                Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                                // Order by span position
                                var a = span1, b = span2, swapped = false;
                                if (span1[0] > span2[0]) {
                                    b = span1;
                                    a = span2;
                                    swapped = true;
                                }
                                // Get separating distance
                                var dist = b[0] - a[1];
                                overlap = dist <= 0;
                                if (maxDist === null || dist > maxDist) {
                                    vec2.copy(sepAxis, normal);
                                    maxDist = dist;
                                    found = overlap;
                                }
                            }
                        }
                    }
                    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */ return found;
                };
                // .getClosestEdge is called by other functions, need local tmp vectors
                var gce_tmp1 = vec2.fromValues(0, 0), gce_tmp2 = vec2.fromValues(0, 0), gce_tmp3 = vec2.fromValues(0, 0);
                /**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */ Narrowphase.getClosestEdge = function(c, angle, axis, flip) {
                    var localAxis = gce_tmp1, edge = gce_tmp2, normal = gce_tmp3;
                    // Convert the axis to local coords of the body
                    vec2.rotate(localAxis, axis, -angle);
                    if (flip) {
                        vec2.scale(localAxis, localAxis, -1);
                    }
                    var closestEdge = -1, N = c.vertices.length, maxDot = -1;
                    for(var i = 0; i !== N; i++){
                        // Get the edge
                        sub(edge, c.vertices[(i + 1) % N], c.vertices[i % N]);
                        // Get normal - just rotate 90 degrees since vertices are given in CCW
                        vec2.rotate90cw(normal, edge);
                        vec2.normalize(normal, normal);
                        var d = dot(normal, localAxis);
                        if (closestEdge === -1 || d > maxDot) {
                            closestEdge = i % N;
                            maxDot = d;
                        }
                    }
                    return closestEdge;
                };
                var circleHeightfield_candidate = vec2.create(), circleHeightfield_dist = vec2.create(), circleHeightfield_v0 = vec2.create(), circleHeightfield_v1 = vec2.create(), circleHeightfield_minCandidate = vec2.create(), circleHeightfield_worldNormal = vec2.create(), circleHeightfield_minCandidateNormal = vec2.create();
                /**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */ Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] = Narrowphase.prototype.circleHeightfield = function(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest, radius) {
                    var data = hfShape.heights, radius = radius || circleShape.radius, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
                    // Get the index of the points to test against
                    var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
                    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/ if (idxA < 0) {
                        idxA = 0;
                    }
                    if (idxB >= data.length) {
                        idxB = data.length - 1;
                    }
                    // Get max and min
                    var max = data[idxA], min = data[idxB];
                    for(var i = idxA; i < idxB; i++){
                        if (data[i] < min) {
                            min = data[i];
                        }
                        if (data[i] > max) {
                            max = data[i];
                        }
                    }
                    if (circlePos[1] - radius > max) {
                        return justTest ? false : 0;
                    }
                    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */ // 1. Check so center of circle is not inside the field. If it is, this wont work...
                    // 2. For each edge
                    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
                    // 2. 2. Check if point is inside.
                    var found = false;
                    // Check all edges first
                    for(var i = idxA; i < idxB; i++){
                        // Get points
                        vec2.set(v0, i * w, data[i]);
                        vec2.set(v1, (i + 1) * w, data[i + 1]);
                        vec2.add(v0, v0, hfPos);
                        vec2.add(v1, v1, hfPos);
                        // Get normal
                        vec2.sub(worldNormal, v1, v0);
                        vec2.rotate(worldNormal, worldNormal, Math.PI / 2);
                        vec2.normalize(worldNormal, worldNormal);
                        // Get point on circle, closest to the edge
                        vec2.scale(candidate, worldNormal, -radius);
                        vec2.add(candidate, candidate, circlePos);
                        // Distance from v0 to the candidate point
                        vec2.sub(dist, candidate, v0);
                        // Check if it is in the element "stick"
                        var d = vec2.dot(dist, worldNormal);
                        if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                            if (justTest) {
                                return true;
                            }
                            found = true;
                            // Store the candidate point, projected to the edge
                            vec2.scale(dist, worldNormal, -d);
                            vec2.add(minCandidate, candidate, dist);
                            vec2.copy(minCandidateNormal, worldNormal);
                            var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                            // Normal is out of the heightfield
                            vec2.copy(c.normalA, minCandidateNormal);
                            // Vector from circle to heightfield
                            vec2.scale(c.contactPointB, c.normalA, -radius);
                            add(c.contactPointB, c.contactPointB, circlePos);
                            sub(c.contactPointB, c.contactPointB, circleBody.position);
                            vec2.copy(c.contactPointA, minCandidate);
                            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                    // Check all vertices
                    found = false;
                    if (radius > 0) {
                        for(var i = idxA; i <= idxB; i++){
                            // Get point
                            vec2.set(v0, i * w, data[i]);
                            vec2.add(v0, v0, hfPos);
                            vec2.sub(dist, circlePos, v0);
                            if (vec2.squaredLength(dist) < Math.pow(radius, 2)) {
                                if (justTest) {
                                    return true;
                                }
                                found = true;
                                var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                                // Construct normal - out of heightfield
                                vec2.copy(c.normalA, dist);
                                vec2.normalize(c.normalA, c.normalA);
                                vec2.scale(c.contactPointB, c.normalA, -radius);
                                add(c.contactPointB, c.contactPointB, circlePos);
                                sub(c.contactPointB, c.contactPointB, circleBody.position);
                                sub(c.contactPointA, v0, hfPos);
                                add(c.contactPointA, c.contactPointA, hfPos);
                                sub(c.contactPointA, c.contactPointA, hfBody.position);
                                this.contactEquations.push(c);
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                            }
                        }
                    }
                    if (found) {
                        return 1;
                    }
                    return 0;
                };
                var convexHeightfield_v0 = vec2.create(), convexHeightfield_v1 = vec2.create(), convexHeightfield_tilePos = vec2.create(), convexHeightfield_tempConvexShape = new Convex({
                    vertices: [
                        vec2.create(),
                        vec2.create(),
                        vec2.create(),
                        vec2.create()
                    ]
                });
                /**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */ Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] = Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function(convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, hfAngle, justTest) {
                    var data = hfShape.heights, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
                    // Get the index of the points to test against
                    var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
                    if (idxA < 0) {
                        idxA = 0;
                    }
                    if (idxB >= data.length) {
                        idxB = data.length - 1;
                    }
                    // Get max and min
                    var max = data[idxA], min = data[idxB];
                    for(var i = idxA; i < idxB; i++){
                        if (data[i] < min) {
                            min = data[i];
                        }
                        if (data[i] > max) {
                            max = data[i];
                        }
                    }
                    if (convexBody.aabb.lowerBound[1] > max) {
                        return justTest ? false : 0;
                    }
                    var found = false;
                    var numContacts = 0;
                    // Loop over all edges
                    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
                    for(var i = idxA; i < idxB; i++){
                        // Get points
                        vec2.set(v0, i * w, data[i]);
                        vec2.set(v1, (i + 1) * w, data[i + 1]);
                        vec2.add(v0, v0, hfPos);
                        vec2.add(v1, v1, hfPos);
                        // Construct a convex
                        var tileHeight = 100; // todo
                        vec2.set(tilePos, (v1[0] + v0[0]) * 0.5, (v1[1] + v0[1] - tileHeight) * 0.5);
                        vec2.sub(tileConvex.vertices[0], v1, tilePos);
                        vec2.sub(tileConvex.vertices[1], v0, tilePos);
                        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
                        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
                        tileConvex.vertices[2][1] -= tileHeight;
                        tileConvex.vertices[3][1] -= tileHeight;
                        // Do convex collision
                        numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
                    }
                    return numContacts;
                };
            },
            {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../shapes/Box": 37,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Shape": 45,
                "../utils/ContactEquationPool": 48,
                "../utils/FrictionEquationPool": 49,
                "../utils/TupleDictionary": 56,
                "../utils/Utils": 57
            }
        ],
        11: [
            function(_dereq_, module1, exports1) {
                module1.exports = Ray;
                var vec2 = _dereq_('../math/vec2');
                var RaycastResult = _dereq_('../collision/RaycastResult');
                var Shape = _dereq_('../shapes/Shape');
                var AABB = _dereq_('../collision/AABB');
                /**
 * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink "World/raycast:method"}}World.raycast{{/crossLink}}
 * @class Ray
 * @constructor
 * @param {object} [options]
 * @param {array} [options.from]
 * @param {array} [options.to]
 * @param {boolean} [options.checkCollisionResponse=true]
 * @param {boolean} [options.skipBackfaces=false]
 * @param {number} [options.collisionMask=-1]
 * @param {number} [options.collisionGroup=-1]
 * @param {number} [options.mode=Ray.ANY]
 * @param {number} [options.callback]
 */ function Ray(options) {
                    options = options || {};
                    /**
     * Ray start point.
     * @property {array} from
     */ this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();
                    /**
     * Ray end point
     * @property {array} to
     */ this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();
                    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */ this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;
                    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */ this.skipBackfaces = !!options.skipBackfaces;
                    /**
     * @property {number} collisionMask
     * @default -1
     */ this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;
                    /**
     * @property {number} collisionGroup
     * @default -1
     */ this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;
                    /**
     * The intersection mode. Should be {{#crossLink "Ray/ANY:property"}}Ray.ANY{{/crossLink}}, {{#crossLink "Ray/ALL:property"}}Ray.ALL{{/crossLink}} or {{#crossLink "Ray/CLOSEST:property"}}Ray.CLOSEST{{/crossLink}}.
     * @property {number} mode
     */ this.mode = options.mode !== undefined ? options.mode : Ray.ANY;
                    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */ this.callback = options.callback || function(result) {};
                    /**
     * @readOnly
     * @property {array} direction
     */ this.direction = vec2.create();
                    /**
     * Length of the ray
     * @readOnly
     * @property {number} length
     */ this.length = 1;
                    this.update();
                }
                Ray.prototype.constructor = Ray;
                /**
 * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.
 * @static
 * @property {Number} CLOSEST
 */ Ray.CLOSEST = 1;
                /**
 * This raycasting mode will make the Ray stop when it finds the first intersection point.
 * @static
 * @property {Number} ANY
 */ Ray.ANY = 2;
                /**
 * This raycasting mode will traverse all intersection points and executes a callback for each one.
 * @static
 * @property {Number} ALL
 */ Ray.ALL = 4;
                /**
 * Should be called if you change the from or to point.
 * @method update
 */ Ray.prototype.update = function() {
                    // Update .direction and .length
                    var d = this.direction;
                    vec2.sub(d, this.to, this.from);
                    this.length = vec2.length(d);
                    vec2.normalize(d, d);
                };
                /**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 */ Ray.prototype.intersectBodies = function(result, bodies) {
                    for(var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++){
                        var body = bodies[i];
                        var aabb = body.getAABB();
                        if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {
                            this.intersectBody(result, body);
                        }
                    }
                };
                var intersectBody_worldPosition = vec2.create();
                /**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 */ Ray.prototype.intersectBody = function(result, body) {
                    var checkCollisionResponse = this.checkCollisionResponse;
                    if (checkCollisionResponse && !body.collisionResponse) {
                        return;
                    }
                    var worldPosition = intersectBody_worldPosition;
                    for(var i = 0, N = body.shapes.length; i < N; i++){
                        var shape = body.shapes[i];
                        if (checkCollisionResponse && !shape.collisionResponse) {
                            continue; // Skip
                        }
                        if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {
                            continue;
                        }
                        // Get world angle and position of the shape
                        vec2.rotate(worldPosition, shape.position, body.angle);
                        vec2.add(worldPosition, worldPosition, body.position);
                        var worldAngle = shape.angle + body.angle;
                        this.intersectShape(result, shape, worldAngle, worldPosition, body);
                        if (result.shouldStop(this)) {
                            break;
                        }
                    }
                };
                /**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */ Ray.prototype.intersectShape = function(result, shape, angle, position, body) {
                    var from = this.from;
                    // Checking radius
                    var distance = distanceFromIntersectionSquared(from, this.direction, position);
                    if (distance > shape.boundingRadius * shape.boundingRadius) {
                        return;
                    }
                    this._currentBody = body;
                    this._currentShape = shape;
                    shape.raycast(result, this, position, angle);
                    this._currentBody = this._currentShape = null;
                };
                /**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */ Ray.prototype.getAABB = function(result) {
                    var to = this.to;
                    var from = this.from;
                    vec2.set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));
                    vec2.set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));
                };
                var hitPointWorld = vec2.create();
                /**
 * @method reportIntersection
 * @private
 * @param  {number} fraction
 * @param  {array} normal
 * @param  {number} [faceIndex=-1]
 * @return {boolean} True if the intersections should continue
 */ Ray.prototype.reportIntersection = function(result, fraction, normal, faceIndex) {
                    var from = this.from;
                    var to = this.to;
                    var shape = this._currentShape;
                    var body = this._currentBody;
                    // Skip back faces?
                    if (this.skipBackfaces && vec2.dot(normal, this.direction) > 0) {
                        return;
                    }
                    switch(this.mode){
                        case Ray.ALL:
                            result.set(normal, shape, body, fraction, faceIndex);
                            this.callback(result);
                            break;
                        case Ray.CLOSEST:
                            // Store if closer than current closest
                            if (fraction < result.fraction || !result.hasHit()) {
                                result.set(normal, shape, body, fraction, faceIndex);
                            }
                            break;
                        case Ray.ANY:
                            // Report and stop.
                            result.set(normal, shape, body, fraction, faceIndex);
                            break;
                    }
                };
                var v0 = vec2.create(), intersect = vec2.create();
                function distanceFromIntersectionSquared(from, direction, position) {
                    // v0 is vector from from to position
                    vec2.sub(v0, position, from);
                    var dot = vec2.dot(v0, direction);
                    // intersect = direction * dot + from
                    vec2.scale(intersect, direction, dot);
                    vec2.add(intersect, intersect, from);
                    return vec2.squaredDistance(position, intersect);
                }
            },
            {
                "../collision/AABB": 7,
                "../collision/RaycastResult": 12,
                "../math/vec2": 30,
                "../shapes/Shape": 45
            }
        ],
        12: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2');
                var Ray = _dereq_('../collision/Ray');
                module1.exports = RaycastResult;
                /**
 * Storage for Ray casting hit data.
 * @class RaycastResult
 * @constructor
 */ function RaycastResult() {
                    /**
	 * The normal of the hit, oriented in world space.
	 * @property {array} normal
	 */ this.normal = vec2.create();
                    /**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */ this.shape = null;
                    /**
	 * The hit body, or null.
	 * @property {Body} body
	 */ this.body = null;
                    /**
	 * The index of the hit triangle, if the hit shape was indexable.
	 * @property {number} faceIndex
	 * @default -1
	 */ this.faceIndex = -1;
                    /**
	 * Distance to the hit, as a fraction. 0 is at the "from" point, 1 is at the "to" point. Will be set to -1 if there was no hit yet.
	 * @property {number} fraction
	 * @default -1
	 */ this.fraction = -1;
                    /**
	 * If the ray should stop traversing.
	 * @readonly
	 * @property {Boolean} isStopped
	 */ this.isStopped = false;
                }
                /**
 * Reset all result data. Must be done before re-using the result object.
 * @method reset
 */ RaycastResult.prototype.reset = function() {
                    vec2.set(this.normal, 0, 0);
                    this.shape = null;
                    this.body = null;
                    this.faceIndex = -1;
                    this.fraction = -1;
                    this.isStopped = false;
                };
                /**
 * Get the distance to the hit point.
 * @method getHitDistance
 * @param {Ray} ray
 */ RaycastResult.prototype.getHitDistance = function(ray) {
                    return vec2.distance(ray.from, ray.to) * this.fraction;
                };
                /**
 * Returns true if the ray hit something since the last reset().
 * @method hasHit
 */ RaycastResult.prototype.hasHit = function() {
                    return this.fraction !== -1;
                };
                /**
 * Get world hit point.
 * @method getHitPoint
 * @param {array} out
 * @param {Ray} ray
 */ RaycastResult.prototype.getHitPoint = function(out, ray) {
                    vec2.lerp(out, ray.from, ray.to, this.fraction);
                };
                /**
 * Can be called while iterating over hits to stop searching for hit points.
 * @method stop
 */ RaycastResult.prototype.stop = function() {
                    this.isStopped = true;
                };
                /**
 * @method shouldStop
 * @private
 * @param {Ray} ray
 * @return {boolean}
 */ RaycastResult.prototype.shouldStop = function(ray) {
                    return this.isStopped || this.fraction !== -1 && ray.mode === Ray.ANY;
                };
                /**
 * @method set
 * @private
 * @param {array} normal
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} fraction
 */ RaycastResult.prototype.set = function(normal, shape, body, fraction, faceIndex) {
                    vec2.copy(this.normal, normal);
                    this.shape = shape;
                    this.body = body;
                    this.fraction = fraction;
                    this.faceIndex = faceIndex;
                };
            },
            {
                "../collision/Ray": 11,
                "../math/vec2": 30
            }
        ],
        13: [
            function(_dereq_, module1, exports1) {
                var Utils = _dereq_('../utils/Utils'), Broadphase = _dereq_('../collision/Broadphase');
                module1.exports = SAPBroadphase;
                /**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */ function SAPBroadphase() {
                    Broadphase.call(this, Broadphase.SAP);
                    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */ this.axisList = [];
                    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */ this.axisIndex = 0;
                    var that = this;
                    this._addBodyHandler = function(e) {
                        that.axisList.push(e.body);
                    };
                    this._removeBodyHandler = function(e) {
                        // Remove from list
                        var idx = that.axisList.indexOf(e.body);
                        if (idx !== -1) {
                            that.axisList.splice(idx, 1);
                        }
                    };
                }
                SAPBroadphase.prototype = new Broadphase();
                SAPBroadphase.prototype.constructor = SAPBroadphase;
                /**
 * Change the world
 * @method setWorld
 * @param {World} world
 */ SAPBroadphase.prototype.setWorld = function(world) {
                    // Clear the old axis array
                    this.axisList.length = 0;
                    // Add all bodies from the new world
                    Utils.appendArray(this.axisList, world.bodies);
                    // Remove old handlers, if any
                    world.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
                    // Add handlers to update the list of bodies.
                    world.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
                    this.world = world;
                };
                /**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */ SAPBroadphase.sortAxisList = function(a, axisIndex) {
                    axisIndex = axisIndex | 0;
                    for(var i = 1, l = a.length; i < l; i++){
                        var v = a[i];
                        for(var j = i - 1; j >= 0; j--){
                            if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                                break;
                            }
                            a[j + 1] = a[j];
                        }
                        a[j + 1] = v;
                    }
                    return a;
                };
                SAPBroadphase.prototype.sortList = function() {
                    var bodies = this.axisList, axisIndex = this.axisIndex;
                    // Sort the lists
                    SAPBroadphase.sortAxisList(bodies, axisIndex);
                };
                /**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */ SAPBroadphase.prototype.getCollisionPairs = function(world) {
                    var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
                    result.length = 0;
                    // Update all AABBs if needed
                    var l = bodies.length;
                    while(l--){
                        var b = bodies[l];
                        if (b.aabbNeedsUpdate) {
                            b.updateAABB();
                        }
                    }
                    // Sort the lists
                    this.sortList();
                    // Look through the X list
                    for(var i = 0, N = bodies.length | 0; i !== N; i++){
                        var bi = bodies[i];
                        for(var j = i + 1; j < N; j++){
                            var bj = bodies[j];
                            // Bounds overlap?
                            var overlaps = bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex];
                            if (!overlaps) {
                                break;
                            }
                            if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                                result.push(bi, bj);
                            }
                        }
                    }
                    return result;
                };
                /**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */ SAPBroadphase.prototype.aabbQuery = function(world, aabb, result) {
                    result = result || [];
                    this.sortList();
                    var axisIndex = this.axisIndex;
                    var axis = 'x';
                    if (axisIndex === 1) {
                        axis = 'y';
                    }
                    if (axisIndex === 2) {
                        axis = 'z';
                    }
                    var axisList = this.axisList;
                    var lower = aabb.lowerBound[axis];
                    var upper = aabb.upperBound[axis];
                    for(var i = 0; i < axisList.length; i++){
                        var b = axisList[i];
                        if (b.aabbNeedsUpdate) {
                            b.updateAABB();
                        }
                        if (b.aabb.overlaps(aabb)) {
                            result.push(b);
                        }
                    }
                    return result;
                };
            },
            {
                "../collision/Broadphase": 8,
                "../utils/Utils": 57
            }
        ],
        14: [
            function(_dereq_, module1, exports1) {
                module1.exports = Constraint;
                var Utils = _dereq_('../utils/Utils');
                /**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */ function Constraint(bodyA, bodyB, type, options) {
                    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */ this.type = type;
                    options = Utils.defaults(options, {
                        collideConnected: true,
                        wakeUpBodies: true
                    });
                    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */ this.equations = [];
                    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */ this.bodyA = bodyA;
                    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */ this.bodyB = bodyB;
                    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */ this.collideConnected = options.collideConnected;
                    // Wake up bodies when connected
                    if (options.wakeUpBodies) {
                        if (bodyA) {
                            bodyA.wakeUp();
                        }
                        if (bodyB) {
                            bodyB.wakeUp();
                        }
                    }
                }
                /**
 * Updates the internal constraint parameters before solve.
 * @method update
 */ Constraint.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!");
                };
                /**
 * @static
 * @property {number} DISTANCE
 */ Constraint.DISTANCE = 1;
                /**
 * @static
 * @property {number} GEAR
 */ Constraint.GEAR = 2;
                /**
 * @static
 * @property {number} LOCK
 */ Constraint.LOCK = 3;
                /**
 * @static
 * @property {number} PRISMATIC
 */ Constraint.PRISMATIC = 4;
                /**
 * @static
 * @property {number} REVOLUTE
 */ Constraint.REVOLUTE = 5;
                /**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */ Constraint.prototype.setStiffness = function(stiffness) {
                    var eqs = this.equations;
                    for(var i = 0; i !== eqs.length; i++){
                        var eq = eqs[i];
                        eq.stiffness = stiffness;
                        eq.needsUpdate = true;
                    }
                };
                /**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */ Constraint.prototype.setRelaxation = function(relaxation) {
                    var eqs = this.equations;
                    for(var i = 0; i !== eqs.length; i++){
                        var eq = eqs[i];
                        eq.relaxation = relaxation;
                        eq.needsUpdate = true;
                    }
                };
            },
            {
                "../utils/Utils": 57
            }
        ],
        15: [
            function(_dereq_, module1, exports1) {
                var Constraint = _dereq_('./Constraint'), Equation = _dereq_('../equations/Equation'), vec2 = _dereq_('../math/vec2'), Utils = _dereq_('../utils/Utils');
                module1.exports = DistanceConstraint;
                /**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 *
 * @example
 *     // Manually set the distance and anchors
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 *     world.addConstraint(constraint);
 */ function DistanceConstraint(bodyA, bodyB, options) {
                    options = Utils.defaults(options, {
                        localAnchorA: [
                            0,
                            0
                        ],
                        localAnchorB: [
                            0,
                            0
                        ]
                    });
                    Constraint.call(this, bodyA, bodyB, Constraint.DISTANCE, options);
                    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */ this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);
                    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */ this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);
                    var localAnchorA = this.localAnchorA;
                    var localAnchorB = this.localAnchorB;
                    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */ this.distance = 0;
                    if (typeof options.distance === 'number') {
                        this.distance = options.distance;
                    } else {
                        // Use the current world distance between the world anchor points.
                        var worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), r = vec2.create();
                        // Transform local anchors to world
                        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
                        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);
                        vec2.add(r, bodyB.position, worldAnchorB);
                        vec2.sub(r, r, worldAnchorA);
                        vec2.sub(r, r, bodyA.position);
                        this.distance = vec2.length(r);
                    }
                    var maxForce;
                    if (typeof options.maxForce === "undefined") {
                        maxForce = Number.MAX_VALUE;
                    } else {
                        maxForce = options.maxForce;
                    }
                    var normal = new Equation(bodyA, bodyB, -maxForce, maxForce); // Just in the normal direction
                    this.equations = [
                        normal
                    ];
                    /**
     * Max force to apply.
     * @property {number} maxForce
     */ this.maxForce = maxForce;
                    // g = (xi - xj).dot(n)
                    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'
                    // ...and if we were to include offset points:
                    // g =
                    //      (xj + rj - xi - ri).dot(n) - distance
                    //
                    // dg/dt =
                    //      (vj + wj x rj - vi - wi x ri).dot(n) =
                    //      { term 2 is near zero } =
                    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
                    //      G * W
                    //
                    // => G = [-n -rixn n rjxn]
                    var r = vec2.create();
                    var ri = vec2.create(); // worldAnchorA
                    var rj = vec2.create(); // worldAnchorB
                    var that = this;
                    normal.computeGq = function() {
                        var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
                        // Transform local anchors to world
                        vec2.rotate(ri, localAnchorA, bodyA.angle);
                        vec2.rotate(rj, localAnchorB, bodyB.angle);
                        vec2.add(r, xj, rj);
                        vec2.sub(r, r, ri);
                        vec2.sub(r, r, xi);
                        //vec2.sub(r, bodyB.position, bodyA.position);
                        return vec2.length(r) - that.distance;
                    };
                    // Make the contact constraint bilateral
                    this.setMaxForce(maxForce);
                    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */ this.upperLimitEnabled = false;
                    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */ this.upperLimit = 1;
                    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */ this.lowerLimitEnabled = false;
                    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */ this.lowerLimit = 0;
                    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */ this.position = 0;
                }
                DistanceConstraint.prototype = new Constraint();
                DistanceConstraint.prototype.constructor = DistanceConstraint;
                /**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */ var n = vec2.create();
                var ri = vec2.create(); // worldAnchorA
                var rj = vec2.create(); // worldAnchorB
                DistanceConstraint.prototype.update = function() {
                    var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, distance = this.distance, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
                    // Transform local anchors to world
                    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
                    vec2.rotate(rj, this.localAnchorB, bodyB.angle);
                    // Get world anchor points and normal
                    vec2.add(n, xj, rj);
                    vec2.sub(n, n, ri);
                    vec2.sub(n, n, xi);
                    this.position = vec2.length(n);
                    var violating = false;
                    if (this.upperLimitEnabled) {
                        if (this.position > this.upperLimit) {
                            normalEquation.maxForce = 0;
                            normalEquation.minForce = -this.maxForce;
                            this.distance = this.upperLimit;
                            violating = true;
                        }
                    }
                    if (this.lowerLimitEnabled) {
                        if (this.position < this.lowerLimit) {
                            normalEquation.maxForce = this.maxForce;
                            normalEquation.minForce = 0;
                            this.distance = this.lowerLimit;
                            violating = true;
                        }
                    }
                    if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
                        // No constraint needed.
                        normalEquation.enabled = false;
                        return;
                    }
                    normalEquation.enabled = true;
                    vec2.normalize(n, n);
                    // Caluclate cross products
                    var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                    // G = [-n -rixn n rjxn]
                    G[0] = -n[0];
                    G[1] = -n[1];
                    G[2] = -rixn;
                    G[3] = n[0];
                    G[4] = n[1];
                    G[5] = rjxn;
                };
                /**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} maxForce
 */ DistanceConstraint.prototype.setMaxForce = function(maxForce) {
                    var normal = this.equations[0];
                    normal.minForce = -maxForce;
                    normal.maxForce = maxForce;
                };
                /**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */ DistanceConstraint.prototype.getMaxForce = function() {
                    var normal = this.equations[0];
                    return normal.maxForce;
                };
            },
            {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Constraint": 14
            }
        ],
        16: [
            function(_dereq_, module1, exports1) {
                var Constraint = _dereq_('./Constraint'), Equation = _dereq_('../equations/Equation'), AngleLockEquation = _dereq_('../equations/AngleLockEquation'), vec2 = _dereq_('../math/vec2');
                module1.exports = GearConstraint;
                /**
 * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 *
 * @example
 *     var constraint = new GearConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 *
 * @example
 *     var constraint = new GearConstraint(bodyA, bodyB, {
 *         ratio: 2,
 *         maxTorque: 1000
 *     });
 *     world.addConstraint(constraint);
 */ function GearConstraint(bodyA, bodyB, options) {
                    options = options || {};
                    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);
                    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */ this.ratio = options.ratio !== undefined ? options.ratio : 1;
                    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */ this.angle = options.angle !== undefined ? options.angle : bodyB.angle - this.ratio * bodyA.angle;
                    // Send same parameters to the equation
                    options.angle = this.angle;
                    options.ratio = this.ratio;
                    this.equations = [
                        new AngleLockEquation(bodyA, bodyB, options)
                    ];
                    // Set max torque
                    if (options.maxTorque !== undefined) {
                        this.setMaxTorque(options.maxTorque);
                    }
                }
                GearConstraint.prototype = new Constraint();
                GearConstraint.prototype.constructor = GearConstraint;
                GearConstraint.prototype.update = function() {
                    var eq = this.equations[0];
                    if (eq.ratio !== this.ratio) {
                        eq.setRatio(this.ratio);
                    }
                    eq.angle = this.angle;
                };
                /**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */ GearConstraint.prototype.setMaxTorque = function(torque) {
                    this.equations[0].setMaxTorque(torque);
                };
                /**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */ GearConstraint.prototype.getMaxTorque = function(torque) {
                    return this.equations[0].maxForce;
                };
            },
            {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        17: [
            function(_dereq_, module1, exports1) {
                var Constraint = _dereq_('./Constraint'), vec2 = _dereq_('../math/vec2'), Equation = _dereq_('../equations/Equation');
                module1.exports = LockConstraint;
                /**
 * Locks the relative position and rotation between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 *
 * @example
 *     // Locks the relative position and rotation between bodyA and bodyB
 *     var constraint = new LockConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 */ function LockConstraint(bodyA, bodyB, options) {
                    options = options || {};
                    Constraint.call(this, bodyA, bodyB, Constraint.LOCK, options);
                    var maxForce = typeof options.maxForce === "undefined" ? Number.MAX_VALUE : options.maxForce;
                    var localAngleB = options.localAngleB || 0;
                    // Use 3 equations:
                    // gx =   (xj - xi - l) * xhat = 0
                    // gy =   (xj - xi - l) * yhat = 0
                    // gr =   (xi - xj + r) * that = 0
                    //
                    // ...where:
                    //   l is the localOffsetB vector rotated to world in bodyA frame
                    //   r is the same vector but reversed and rotated from bodyB frame
                    //   xhat, yhat are world axis vectors
                    //   that is the tangent of r
                    //
                    // For the first two constraints, we get
                    // G*W = (vj - vi - ldot  ) * xhat
                    //     = (vj - vi - wi x l) * xhat
                    //
                    // Since (wi x l) * xhat = (l x xhat) * wi, we get
                    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
                    //
                    // The last constraint gives
                    // GW = (vi - vj + wj x r) * that
                    //    = [  that   0  -that  (r x t) ]
                    var x = new Equation(bodyA, bodyB, -maxForce, maxForce), y = new Equation(bodyA, bodyB, -maxForce, maxForce), rot = new Equation(bodyA, bodyB, -maxForce, maxForce);
                    var l = vec2.create(), g = vec2.create(), that = this;
                    x.computeGq = function() {
                        vec2.rotate(l, that.localOffsetB, bodyA.angle);
                        vec2.sub(g, bodyB.position, bodyA.position);
                        vec2.sub(g, g, l);
                        return g[0];
                    };
                    y.computeGq = function() {
                        vec2.rotate(l, that.localOffsetB, bodyA.angle);
                        vec2.sub(g, bodyB.position, bodyA.position);
                        vec2.sub(g, g, l);
                        return g[1];
                    };
                    var r = vec2.create(), t = vec2.create();
                    rot.computeGq = function() {
                        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
                        vec2.scale(r, r, -1);
                        vec2.sub(g, bodyA.position, bodyB.position);
                        vec2.add(g, g, r);
                        vec2.rotate(t, r, -Math.PI / 2);
                        vec2.normalize(t, t);
                        return vec2.dot(g, t);
                    };
                    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */ this.localOffsetB = vec2.create();
                    if (options.localOffsetB) {
                        vec2.copy(this.localOffsetB, options.localOffsetB);
                    } else {
                        // Construct from current positions
                        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
                        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
                    }
                    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */ this.localAngleB = 0;
                    if (typeof options.localAngleB === 'number') {
                        this.localAngleB = options.localAngleB;
                    } else {
                        // Construct
                        this.localAngleB = bodyB.angle - bodyA.angle;
                    }
                    this.equations.push(x, y, rot);
                    this.setMaxForce(maxForce);
                }
                LockConstraint.prototype = new Constraint();
                LockConstraint.prototype.constructor = LockConstraint;
                /**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */ LockConstraint.prototype.setMaxForce = function(force) {
                    var eqs = this.equations;
                    for(var i = 0; i < this.equations.length; i++){
                        eqs[i].maxForce = force;
                        eqs[i].minForce = -force;
                    }
                };
                /**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */ LockConstraint.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce;
                };
                var l = vec2.create();
                var r = vec2.create();
                var t = vec2.create();
                var xAxis = vec2.fromValues(1, 0);
                var yAxis = vec2.fromValues(0, 1);
                LockConstraint.prototype.update = function() {
                    var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
                    vec2.rotate(l, this.localOffsetB, bodyA.angle);
                    vec2.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
                    vec2.scale(r, r, -1);
                    vec2.rotate(t, r, Math.PI / 2);
                    vec2.normalize(t, t);
                    x.G[0] = -1;
                    x.G[1] = 0;
                    x.G[2] = -vec2.crossLength(l, xAxis);
                    x.G[3] = 1;
                    y.G[0] = 0;
                    y.G[1] = -1;
                    y.G[2] = -vec2.crossLength(l, yAxis);
                    y.G[4] = 1;
                    rot.G[0] = -t[0];
                    rot.G[1] = -t[1];
                    rot.G[3] = t[0];
                    rot.G[4] = t[1];
                    rot.G[5] = vec2.crossLength(r, t);
                };
            },
            {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        18: [
            function(_dereq_, module1, exports1) {
                var Constraint = _dereq_('./Constraint'), ContactEquation = _dereq_('../equations/ContactEquation'), Equation = _dereq_('../equations/Equation'), vec2 = _dereq_('../math/vec2'), RotationalLockEquation = _dereq_('../equations/RotationalLockEquation');
                module1.exports = PrismaticConstraint;
                /**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>. Also called "slider constraint".
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */ function PrismaticConstraint(bodyA, bodyB, options) {
                    options = options || {};
                    Constraint.call(this, bodyA, bodyB, Constraint.PRISMATIC, options);
                    // Get anchors
                    var localAnchorA = vec2.fromValues(0, 0), localAxisA = vec2.fromValues(1, 0), localAnchorB = vec2.fromValues(0, 0);
                    if (options.localAnchorA) {
                        vec2.copy(localAnchorA, options.localAnchorA);
                    }
                    if (options.localAxisA) {
                        vec2.copy(localAxisA, options.localAxisA);
                    }
                    if (options.localAnchorB) {
                        vec2.copy(localAnchorB, options.localAnchorB);
                    }
                    /**
     * @property localAnchorA
     * @type {Array}
     */ this.localAnchorA = localAnchorA;
                    /**
     * @property localAnchorB
     * @type {Array}
     */ this.localAnchorB = localAnchorB;
                    /**
     * @property localAxisA
     * @type {Array}
     */ this.localAxisA = localAxisA;
                    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */ var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                    // Translational part
                    var trans = new Equation(bodyA, bodyB, -maxForce, maxForce);
                    var ri = new vec2.create(), rj = new vec2.create(), gg = new vec2.create(), t = new vec2.create();
                    trans.computeGq = function() {
                        // g = ( xj + rj - xi - ri ) * t
                        return vec2.dot(gg, t);
                    };
                    trans.updateJacobian = function() {
                        var G = this.G, xi = bodyA.position, xj = bodyB.position;
                        vec2.rotate(ri, localAnchorA, bodyA.angle);
                        vec2.rotate(rj, localAnchorB, bodyB.angle);
                        vec2.add(gg, xj, rj);
                        vec2.sub(gg, gg, xi);
                        vec2.sub(gg, gg, ri);
                        vec2.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
                        G[0] = -t[0];
                        G[1] = -t[1];
                        G[2] = -vec2.crossLength(ri, t) + vec2.crossLength(t, gg);
                        G[3] = t[0];
                        G[4] = t[1];
                        G[5] = vec2.crossLength(rj, t);
                    };
                    this.equations.push(trans);
                    // Rotational part
                    if (!options.disableRotationalLock) {
                        var rot = new RotationalLockEquation(bodyA, bodyB, -maxForce, maxForce);
                        this.equations.push(rot);
                    }
                    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */ this.position = 0;
                    // Is this one used at all?
                    this.velocity = 0;
                    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */ this.lowerLimitEnabled = typeof options.lowerLimit !== "undefined" ? true : false;
                    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */ this.upperLimitEnabled = typeof options.upperLimit !== "undefined" ? true : false;
                    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */ this.lowerLimit = typeof options.lowerLimit !== "undefined" ? options.lowerLimit : 0;
                    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */ this.upperLimit = typeof options.upperLimit !== "undefined" ? options.upperLimit : 1;
                    // Equations used for limits
                    this.upperLimitEquation = new ContactEquation(bodyA, bodyB);
                    this.lowerLimitEquation = new ContactEquation(bodyA, bodyB);
                    // Set max/min forces
                    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
                    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;
                    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */ this.motorEquation = new Equation(bodyA, bodyB);
                    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */ this.motorEnabled = false;
                    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */ this.motorSpeed = 0;
                    var that = this;
                    var motorEquation = this.motorEquation;
                    var old = motorEquation.computeGW;
                    motorEquation.computeGq = function() {
                        return 0;
                    };
                    motorEquation.computeGW = function() {
                        var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                        return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
                    };
                }
                PrismaticConstraint.prototype = new Constraint();
                PrismaticConstraint.prototype.constructor = PrismaticConstraint;
                var worldAxisA = vec2.create(), worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), orientedAnchorA = vec2.create(), orientedAnchorB = vec2.create(), tmp = vec2.create();
                /**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */ PrismaticConstraint.prototype.update = function() {
                    var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
                    trans.updateJacobian();
                    // Transform local things to world
                    vec2.rotate(worldAxisA, localAxisA, bodyA.angle);
                    vec2.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
                    vec2.add(worldAnchorA, orientedAnchorA, bodyA.position);
                    vec2.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
                    vec2.add(worldAnchorB, orientedAnchorB, bodyB.position);
                    var relPosition = this.position = vec2.dot(worldAnchorB, worldAxisA) - vec2.dot(worldAnchorA, worldAxisA);
                    // Motor
                    if (this.motorEnabled) {
                        // G = [ a     a x ri   -a   -a x rj ]
                        var G = this.motorEquation.G;
                        G[0] = worldAxisA[0];
                        G[1] = worldAxisA[1];
                        G[2] = vec2.crossLength(worldAxisA, orientedAnchorB);
                        G[3] = -worldAxisA[0];
                        G[4] = -worldAxisA[1];
                        G[5] = -vec2.crossLength(worldAxisA, orientedAnchorA);
                    }
                    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */ if (this.upperLimitEnabled && relPosition > upperLimit) {
                        // Update contact constraint normal, etc
                        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
                        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                        vec2.scale(tmp, worldAxisA, upperLimit);
                        vec2.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
                        if (eqs.indexOf(upperLimitEquation) === -1) {
                            eqs.push(upperLimitEquation);
                        }
                    } else {
                        var idx = eqs.indexOf(upperLimitEquation);
                        if (idx !== -1) {
                            eqs.splice(idx, 1);
                        }
                    }
                    if (this.lowerLimitEnabled && relPosition < lowerLimit) {
                        // Update contact constraint normal, etc
                        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
                        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                        vec2.scale(tmp, worldAxisA, lowerLimit);
                        vec2.sub(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
                        if (eqs.indexOf(lowerLimitEquation) === -1) {
                            eqs.push(lowerLimitEquation);
                        }
                    } else {
                        var idx = eqs.indexOf(lowerLimitEquation);
                        if (idx !== -1) {
                            eqs.splice(idx, 1);
                        }
                    }
                };
                /**
 * Enable the motor
 * @method enableMotor
 */ PrismaticConstraint.prototype.enableMotor = function() {
                    if (this.motorEnabled) {
                        return;
                    }
                    this.equations.push(this.motorEquation);
                    this.motorEnabled = true;
                };
                /**
 * Disable the rotational motor
 * @method disableMotor
 */ PrismaticConstraint.prototype.disableMotor = function() {
                    if (!this.motorEnabled) {
                        return;
                    }
                    var i = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(i, 1);
                    this.motorEnabled = false;
                };
                /**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */ PrismaticConstraint.prototype.setLimits = function(lower, upper) {
                    if (typeof lower === 'number') {
                        this.lowerLimit = lower;
                        this.lowerLimitEnabled = true;
                    } else {
                        this.lowerLimit = lower;
                        this.lowerLimitEnabled = false;
                    }
                    if (typeof upper === 'number') {
                        this.upperLimit = upper;
                        this.upperLimitEnabled = true;
                    } else {
                        this.upperLimit = upper;
                        this.upperLimitEnabled = false;
                    }
                };
            },
            {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        19: [
            function(_dereq_, module1, exports1) {
                var Constraint = _dereq_('./Constraint'), Equation = _dereq_('../equations/Equation'), RotationalVelocityEquation = _dereq_('../equations/RotationalVelocityEquation'), RotationalLockEquation = _dereq_('../equations/RotationalLockEquation'), vec2 = _dereq_('../math/vec2');
                module1.exports = RevoluteConstraint;
                var worldPivotA = vec2.create(), worldPivotB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1), g = vec2.create();
                /**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */ function RevoluteConstraint(bodyA, bodyB, options) {
                    options = options || {};
                    Constraint.call(this, bodyA, bodyB, Constraint.REVOLUTE, options);
                    var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                    /**
     * @property {Array} pivotA
     */ this.pivotA = vec2.create();
                    /**
     * @property {Array} pivotB
     */ this.pivotB = vec2.create();
                    if (options.worldPivot) {
                        // Compute pivotA and pivotB
                        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
                        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
                        // Rotate to local coordinate system
                        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
                        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
                    } else {
                        // Get pivotA and pivotB
                        vec2.copy(this.pivotA, options.localPivotA);
                        vec2.copy(this.pivotB, options.localPivotB);
                    }
                    // Equations to be fed to the solver
                    var eqs = this.equations = [
                        new Equation(bodyA, bodyB, -maxForce, maxForce),
                        new Equation(bodyA, bodyB, -maxForce, maxForce)
                    ];
                    var x = eqs[0];
                    var y = eqs[1];
                    var that = this;
                    x.computeGq = function() {
                        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                        vec2.add(g, bodyB.position, worldPivotB);
                        vec2.sub(g, g, bodyA.position);
                        vec2.sub(g, g, worldPivotA);
                        return vec2.dot(g, xAxis);
                    };
                    y.computeGq = function() {
                        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                        vec2.add(g, bodyB.position, worldPivotB);
                        vec2.sub(g, g, bodyA.position);
                        vec2.sub(g, g, worldPivotA);
                        return vec2.dot(g, yAxis);
                    };
                    y.minForce = x.minForce = -maxForce;
                    y.maxForce = x.maxForce = maxForce;
                    this.motorEquation = new RotationalVelocityEquation(bodyA, bodyB);
                    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */ this.motorEnabled = false;
                    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */ this.angle = 0;
                    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */ this.lowerLimitEnabled = false;
                    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */ this.upperLimitEnabled = false;
                    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */ this.lowerLimit = 0;
                    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */ this.upperLimit = 0;
                    this.upperLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                    this.lowerLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                    this.upperLimitEquation.minForce = 0;
                    this.lowerLimitEquation.maxForce = 0;
                }
                RevoluteConstraint.prototype = new Constraint();
                RevoluteConstraint.prototype.constructor = RevoluteConstraint;
                /**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */ RevoluteConstraint.prototype.setLimits = function(lower, upper) {
                    if (typeof lower === 'number') {
                        this.lowerLimit = lower;
                        this.lowerLimitEnabled = true;
                    } else {
                        this.lowerLimit = lower;
                        this.lowerLimitEnabled = false;
                    }
                    if (typeof upper === 'number') {
                        this.upperLimit = upper;
                        this.upperLimitEnabled = true;
                    } else {
                        this.upperLimit = upper;
                        this.upperLimitEnabled = false;
                    }
                };
                RevoluteConstraint.prototype.update = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, normal = eqs[0], tangent = eqs[1], x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
                    var relAngle = this.angle = bodyB.angle - bodyA.angle;
                    if (this.upperLimitEnabled && relAngle > upperLimit) {
                        upperLimitEquation.angle = upperLimit;
                        if (eqs.indexOf(upperLimitEquation) === -1) {
                            eqs.push(upperLimitEquation);
                        }
                    } else {
                        var idx = eqs.indexOf(upperLimitEquation);
                        if (idx !== -1) {
                            eqs.splice(idx, 1);
                        }
                    }
                    if (this.lowerLimitEnabled && relAngle < lowerLimit) {
                        lowerLimitEquation.angle = lowerLimit;
                        if (eqs.indexOf(lowerLimitEquation) === -1) {
                            eqs.push(lowerLimitEquation);
                        }
                    } else {
                        var idx = eqs.indexOf(lowerLimitEquation);
                        if (idx !== -1) {
                            eqs.splice(idx, 1);
                        }
                    }
                    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */ vec2.rotate(worldPivotA, pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, pivotB, bodyB.angle);
                    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc
                    x.G[0] = -1;
                    x.G[1] = 0;
                    x.G[2] = -vec2.crossLength(worldPivotA, xAxis);
                    x.G[3] = 1;
                    x.G[4] = 0;
                    x.G[5] = vec2.crossLength(worldPivotB, xAxis);
                    y.G[0] = 0;
                    y.G[1] = -1;
                    y.G[2] = -vec2.crossLength(worldPivotA, yAxis);
                    y.G[3] = 0;
                    y.G[4] = 1;
                    y.G[5] = vec2.crossLength(worldPivotB, yAxis);
                };
                /**
 * Enable the rotational motor
 * @method enableMotor
 */ RevoluteConstraint.prototype.enableMotor = function() {
                    if (this.motorEnabled) {
                        return;
                    }
                    this.equations.push(this.motorEquation);
                    this.motorEnabled = true;
                };
                /**
 * Disable the rotational motor
 * @method disableMotor
 */ RevoluteConstraint.prototype.disableMotor = function() {
                    if (!this.motorEnabled) {
                        return;
                    }
                    var i = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(i, 1);
                    this.motorEnabled = false;
                };
                /**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */ RevoluteConstraint.prototype.motorIsEnabled = function() {
                    return !!this.motorEnabled;
                };
                /**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */ RevoluteConstraint.prototype.setMotorSpeed = function(speed) {
                    if (!this.motorEnabled) {
                        return;
                    }
                    var i = this.equations.indexOf(this.motorEquation);
                    this.equations[i].relativeVelocity = speed;
                };
                /**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */ RevoluteConstraint.prototype.getMotorSpeed = function() {
                    if (!this.motorEnabled) {
                        return false;
                    }
                    return this.motorEquation.relativeVelocity;
                };
            },
            {
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../equations/RotationalVelocityEquation": 25,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        20: [
            function(_dereq_, module1, exports1) {
                var Equation = _dereq_("./Equation"), vec2 = _dereq_('../math/vec2');
                module1.exports = AngleLockEquation;
                /**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */ function AngleLockEquation(bodyA, bodyB, options) {
                    options = options || {};
                    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                    this.angle = options.angle || 0;
                    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */ this.ratio = typeof options.ratio === "number" ? options.ratio : 1;
                    this.setRatio(this.ratio);
                }
                AngleLockEquation.prototype = new Equation();
                AngleLockEquation.prototype.constructor = AngleLockEquation;
                AngleLockEquation.prototype.computeGq = function() {
                    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
                };
                /**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */ AngleLockEquation.prototype.setRatio = function(ratio) {
                    var G = this.G;
                    G[2] = ratio;
                    G[5] = -1;
                    this.ratio = ratio;
                };
                /**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */ AngleLockEquation.prototype.setMaxTorque = function(torque) {
                    this.maxForce = torque;
                    this.minForce = -torque;
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        21: [
            function(_dereq_, module1, exports1) {
                var Equation = _dereq_("./Equation"), vec2 = _dereq_('../math/vec2');
                module1.exports = ContactEquation;
                /**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function ContactEquation(bodyA, bodyB) {
                    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);
                    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */ this.contactPointA = vec2.create();
                    this.penetrationVec = vec2.create();
                    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */ this.contactPointB = vec2.create();
                    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */ this.normalA = vec2.create();
                    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */ this.restitution = 0;
                    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */ this.firstImpact = false;
                    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */ this.shapeA = null;
                    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */ this.shapeB = null;
                }
                ContactEquation.prototype = new Equation();
                ContactEquation.prototype.constructor = ContactEquation;
                ContactEquation.prototype.computeB = function(a, b, h) {
                    var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = bi.position, xj = bj.position;
                    var penetrationVec = this.penetrationVec, n = this.normalA, G = this.G;
                    // Caluclate cross products
                    var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                    // G = [-n -rixn n rjxn]
                    G[0] = -n[0];
                    G[1] = -n[1];
                    G[2] = -rixn;
                    G[3] = n[0];
                    G[4] = n[1];
                    G[5] = rjxn;
                    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
                    vec2.add(penetrationVec, xj, rj);
                    vec2.sub(penetrationVec, penetrationVec, xi);
                    vec2.sub(penetrationVec, penetrationVec, ri);
                    // Compute iteration
                    var GW, Gq;
                    if (this.firstImpact && this.restitution !== 0) {
                        Gq = 0;
                        GW = 1 / b * (1 + this.restitution) * this.computeGW();
                    } else {
                        Gq = vec2.dot(n, penetrationVec) + this.offset;
                        GW = this.computeGW();
                    }
                    var GiMf = this.computeGiMf();
                    var B = -Gq * a - GW * b - h * GiMf;
                    return B;
                };
                var vi = vec2.create();
                var vj = vec2.create();
                var relVel = vec2.create();
                /**
 * Get the relative velocity along the normal vector.
 * @return {number}
 */ ContactEquation.prototype.getVelocityAlongNormal = function() {
                    this.bodyA.getVelocityAtPoint(vi, this.contactPointA);
                    this.bodyB.getVelocityAtPoint(vj, this.contactPointB);
                    vec2.subtract(relVel, vi, vj);
                    return vec2.dot(this.normalA, relVel);
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        22: [
            function(_dereq_, module1, exports1) {
                module1.exports = Equation;
                var vec2 = _dereq_('../math/vec2'), Utils = _dereq_('../utils/Utils'), Body = _dereq_('../objects/Body');
                /**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */ function Equation(bodyA, bodyB, minForce, maxForce) {
                    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */ this.minForce = typeof minForce === "undefined" ? -Number.MAX_VALUE : minForce;
                    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */ this.maxForce = typeof maxForce === "undefined" ? Number.MAX_VALUE : maxForce;
                    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */ this.bodyA = bodyA;
                    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */ this.bodyB = bodyB;
                    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */ this.stiffness = Equation.DEFAULT_STIFFNESS;
                    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */ this.relaxation = Equation.DEFAULT_RELAXATION;
                    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */ this.G = new Utils.ARRAY_TYPE(6);
                    for(var i = 0; i < 6; i++){
                        this.G[i] = 0;
                    }
                    this.offset = 0;
                    this.a = 0;
                    this.b = 0;
                    this.epsilon = 0;
                    this.timeStep = 1 / 60;
                    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */ this.needsUpdate = true;
                    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */ this.multiplier = 0;
                    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */ this.relativeVelocity = 0;
                    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */ this.enabled = true;
                }
                Equation.prototype.constructor = Equation;
                /**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */ Equation.DEFAULT_STIFFNESS = 1e6;
                /**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */ Equation.DEFAULT_RELAXATION = 4;
                /**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */ Equation.prototype.update = function() {
                    var k = this.stiffness, d = this.relaxation, h = this.timeStep;
                    this.a = 4.0 / (h * (1 + 4 * d));
                    this.b = 4.0 * d / (1 + 4 * d);
                    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));
                    this.needsUpdate = false;
                };
                /**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */ Equation.prototype.gmult = function(G, vi, wi, vj, wj) {
                    return G[0] * vi[0] + G[1] * vi[1] + G[2] * wi + G[3] * vj[0] + G[4] * vj[1] + G[5] * wj;
                };
                /**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */ Equation.prototype.computeB = function(a, b, h) {
                    var GW = this.computeGW();
                    var Gq = this.computeGq();
                    var GiMf = this.computeGiMf();
                    return -Gq * a - GW * b - GiMf * h;
                };
                /**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */ var qi = vec2.create(), qj = vec2.create();
                Equation.prototype.computeGq = function() {
                    var G = this.G, bi = this.bodyA, bj = this.bodyB, xi = bi.position, xj = bj.position, ai = bi.angle, aj = bj.angle;
                    return this.gmult(G, qi, ai, qj, aj) + this.offset;
                };
                /**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */ Equation.prototype.computeGW = function() {
                    var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                    return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
                };
                /**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */ Equation.prototype.computeGWlambda = function() {
                    var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
                    return this.gmult(G, vi, wi, vj, wj);
                };
                /**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */ var iMfi = vec2.create(), iMfj = vec2.create();
                Equation.prototype.computeGiMf = function() {
                    var bi = this.bodyA, bj = this.bodyB, fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                    vec2.scale(iMfi, fi, invMassi);
                    vec2.multiply(iMfi, bi.massMultiplier, iMfi);
                    vec2.scale(iMfj, fj, invMassj);
                    vec2.multiply(iMfj, bj.massMultiplier, iMfj);
                    return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
                };
                /**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */ Equation.prototype.computeGiMGt = function() {
                    var bi = this.bodyA, bj = this.bodyB, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                    return G[0] * G[0] * invMassi * bi.massMultiplier[0] + G[1] * G[1] * invMassi * bi.massMultiplier[1] + G[2] * G[2] * invIi + G[3] * G[3] * invMassj * bj.massMultiplier[0] + G[4] * G[4] * invMassj * bj.massMultiplier[1] + G[5] * G[5] * invIj;
                };
                var addToWlambda_temp = vec2.create(), addToWlambda_Gi = vec2.create(), addToWlambda_Gj = vec2.create(), addToWlambda_ri = vec2.create(), addToWlambda_rj = vec2.create(), addToWlambda_Mdiag = vec2.create();
                /**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */ Equation.prototype.addToWlambda = function(deltalambda) {
                    var bi = this.bodyA, bj = this.bodyB, temp = addToWlambda_temp, Gi = addToWlambda_Gi, Gj = addToWlambda_Gj, ri = addToWlambda_ri, rj = addToWlambda_rj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, Mdiag = addToWlambda_Mdiag, G = this.G;
                    Gi[0] = G[0];
                    Gi[1] = G[1];
                    Gj[0] = G[3];
                    Gj[1] = G[4];
                    // Add to linear velocity
                    // v_lambda += inv(M) * delta_lamba * G
                    vec2.scale(temp, Gi, invMassi * deltalambda);
                    vec2.multiply(temp, temp, bi.massMultiplier);
                    vec2.add(bi.vlambda, bi.vlambda, temp);
                    // This impulse is in the offset frame
                    // Also add contribution to angular
                    //bi.wlambda -= vec2.crossLength(temp,ri);
                    bi.wlambda += invIi * G[2] * deltalambda;
                    vec2.scale(temp, Gj, invMassj * deltalambda);
                    vec2.multiply(temp, temp, bj.massMultiplier);
                    vec2.add(bj.vlambda, bj.vlambda, temp);
                    //bj.wlambda -= vec2.crossLength(temp,rj);
                    bj.wlambda += invIj * G[5] * deltalambda;
                };
                /**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */ Equation.prototype.computeInvC = function(eps) {
                    return 1.0 / (this.computeGiMGt() + eps);
                };
            },
            {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }
        ],
        23: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), Equation = _dereq_('./Equation'), Utils = _dereq_('../utils/Utils');
                module1.exports = FrictionEquation;
                /**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */ function FrictionEquation(bodyA, bodyB, slipForce) {
                    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
                    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */ this.contactPointA = vec2.create();
                    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */ this.contactPointB = vec2.create();
                    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */ this.t = vec2.create();
                    /**
     * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */ this.contactEquations = [];
                    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */ this.shapeA = null;
                    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */ this.shapeB = null;
                    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */ this.frictionCoefficient = 0.3;
                }
                FrictionEquation.prototype = new Equation();
                FrictionEquation.prototype.constructor = FrictionEquation;
                /**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */ FrictionEquation.prototype.setSlipForce = function(slipForce) {
                    this.maxForce = slipForce;
                    this.minForce = -slipForce;
                };
                /**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */ FrictionEquation.prototype.getSlipForce = function() {
                    return this.maxForce;
                };
                FrictionEquation.prototype.computeB = function(a, b, h) {
                    var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
                    // G = [-t -rixt t rjxt]
                    // And remember, this is a pure velocity constraint, g is always zero!
                    G[0] = -t[0];
                    G[1] = -t[1];
                    G[2] = -vec2.crossLength(ri, t);
                    G[3] = t[0];
                    G[4] = t[1];
                    G[5] = vec2.crossLength(rj, t);
                    var GW = this.computeGW(), GiMf = this.computeGiMf();
                    var B = /* - g * a  */ -GW * b - h * GiMf;
                    return B;
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Equation": 22
            }
        ],
        24: [
            function(_dereq_, module1, exports1) {
                var Equation = _dereq_("./Equation"), vec2 = _dereq_('../math/vec2');
                module1.exports = RotationalLockEquation;
                /**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */ function RotationalLockEquation(bodyA, bodyB, options) {
                    options = options || {};
                    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                    /**
     * @property {number} angle
     */ this.angle = options.angle || 0;
                    var G = this.G;
                    G[2] = 1;
                    G[5] = -1;
                }
                RotationalLockEquation.prototype = new Equation();
                RotationalLockEquation.prototype.constructor = RotationalLockEquation;
                var worldVectorA = vec2.create(), worldVectorB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1);
                RotationalLockEquation.prototype.computeGq = function() {
                    vec2.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
                    vec2.rotate(worldVectorB, yAxis, this.bodyB.angle);
                    return vec2.dot(worldVectorA, worldVectorB);
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        25: [
            function(_dereq_, module1, exports1) {
                var Equation = _dereq_("./Equation"), vec2 = _dereq_('../math/vec2');
                module1.exports = RotationalVelocityEquation;
                /**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function RotationalVelocityEquation(bodyA, bodyB) {
                    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                    this.relativeVelocity = 1;
                    this.ratio = 1;
                }
                RotationalVelocityEquation.prototype = new Equation();
                RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
                RotationalVelocityEquation.prototype.computeB = function(a, b, h) {
                    var G = this.G;
                    G[2] = -1;
                    G[5] = this.ratio;
                    var GiMf = this.computeGiMf();
                    var GW = this.computeGW();
                    var B = -GW * b - h * GiMf;
                    return B;
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        26: [
            function(_dereq_, module1, exports1) {
                /**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */ var EventEmitter = function() {};
                module1.exports = EventEmitter;
                EventEmitter.prototype = {
                    constructor: EventEmitter,
                    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */ on: function(type, listener, context) {
                        listener.context = context || this;
                        if (this._listeners === undefined) {
                            this._listeners = {};
                        }
                        var listeners = this._listeners;
                        if (listeners[type] === undefined) {
                            listeners[type] = [];
                        }
                        if (listeners[type].indexOf(listener) === -1) {
                            listeners[type].push(listener);
                        }
                        return this;
                    },
                    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */ has: function(type, listener) {
                        if (this._listeners === undefined) {
                            return false;
                        }
                        var listeners = this._listeners;
                        if (listener) {
                            if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                                return true;
                            }
                        } else {
                            if (listeners[type] !== undefined) {
                                return true;
                            }
                        }
                        return false;
                    },
                    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */ off: function(type, listener) {
                        if (this._listeners === undefined) {
                            return this;
                        }
                        var listeners = this._listeners;
                        var index = listeners[type].indexOf(listener);
                        if (index !== -1) {
                            listeners[type].splice(index, 1);
                        }
                        return this;
                    },
                    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */ emit: function(event) {
                        if (this._listeners === undefined) {
                            return this;
                        }
                        var listeners = this._listeners;
                        var listenerArray = listeners[event.type];
                        if (listenerArray !== undefined) {
                            event.target = this;
                            for(var i = 0, l = listenerArray.length; i < l; i++){
                                var listener = listenerArray[i];
                                listener.call(listener.context, event);
                            }
                        }
                        return this;
                    }
                };
            },
            {}
        ],
        27: [
            function(_dereq_, module1, exports1) {
                var Material = _dereq_('./Material');
                var Equation = _dereq_('../equations/Equation');
                module1.exports = ContactMaterial;
                /**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */ function ContactMaterial(materialA, materialB, options) {
                    options = options || {};
                    if (!(materialA instanceof Material) || !(materialB instanceof Material)) {
                        throw new Error("First two arguments must be Material instances.");
                    }
                    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */ this.id = ContactMaterial.idCounter++;
                    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */ this.materialA = materialA;
                    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */ this.materialB = materialB;
                    /**
     * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.
     * @property friction
     * @type {Number}
     * @default 0.3
     */ this.friction = typeof options.friction !== "undefined" ? Number(options.friction) : 0.3;
                    /**
     * Restitution, or "bounciness" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.
     * @property restitution
     * @type {Number}
     * @default 0
     */ this.restitution = typeof options.restitution !== "undefined" ? Number(options.restitution) : 0;
                    /**
     * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
     * @property stiffness
     * @type {Number}
     */ this.stiffness = typeof options.stiffness !== "undefined" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;
                    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
     * @property relaxation
     * @type {Number}
     */ this.relaxation = typeof options.relaxation !== "undefined" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;
                    /**
     * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
     * @property frictionStiffness
     * @type {Number}
     */ this.frictionStiffness = typeof options.frictionStiffness !== "undefined" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;
                    /**
     * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
     * @property frictionRelaxation
     * @type {Number}
     */ this.frictionRelaxation = typeof options.frictionRelaxation !== "undefined" ? Number(options.frictionRelaxation) : Equation.DEFAULT_RELAXATION;
                    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     * @default 0
     */ this.surfaceVelocity = typeof options.surfaceVelocity !== "undefined" ? Number(options.surfaceVelocity) : 0;
                    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */ this.contactSkinSize = 0.005;
                }
                ContactMaterial.idCounter = 0;
            },
            {
                "../equations/Equation": 22,
                "./Material": 28
            }
        ],
        28: [
            function(_dereq_, module1, exports1) {
                module1.exports = Material;
                /**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */ function Material(id) {
                    /**
     * The material identifier
     * @property id
     * @type {Number}
     */ this.id = id || Material.idCounter++;
                }
                Material.idCounter = 0;
            },
            {}
        ],
        29: [
            function(_dereq_, module1, exports1) {
                /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */ var PolyK = {};
                /*
        Is Polygon self-intersecting?

        O(n^2)
    */ /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */ PolyK.GetArea = function(p) {
                    if (p.length < 6) return 0;
                    var l = p.length - 2;
                    var sum = 0;
                    for(var i = 0; i < l; i += 2)sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
                    sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
                    return -sum * 0.5;
                };
                /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */ PolyK.Triangulate = function(p) {
                    var n = p.length >> 1;
                    if (n < 3) return [];
                    var tgs = [];
                    var avl = [];
                    for(var i = 0; i < n; i++)avl.push(i);
                    var i = 0;
                    var al = n;
                    while(al > 3){
                        var i0 = avl[(i + 0) % al];
                        var i1 = avl[(i + 1) % al];
                        var i2 = avl[(i + 2) % al];
                        var ax = p[2 * i0], ay = p[2 * i0 + 1];
                        var bx = p[2 * i1], by = p[2 * i1 + 1];
                        var cx = p[2 * i2], cy = p[2 * i2 + 1];
                        var earFound = false;
                        if (PolyK._convex(ax, ay, bx, by, cx, cy)) {
                            earFound = true;
                            for(var j = 0; j < al; j++){
                                var vi = avl[j];
                                if (vi == i0 || vi == i1 || vi == i2) continue;
                                if (PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                                    earFound = false;
                                    break;
                                }
                            }
                        }
                        if (earFound) {
                            tgs.push(i0, i1, i2);
                            avl.splice((i + 1) % al, 1);
                            al--;
                            i = 0;
                        } else if (i++ > 3 * al) break; // no convex angles :(
                    }
                    tgs.push(avl[0], avl[1], avl[2]);
                    return tgs;
                };
                /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */ PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
                    var v0x = cx - ax;
                    var v0y = cy - ay;
                    var v1x = bx - ax;
                    var v1y = by - ay;
                    var v2x = px - ax;
                    var v2y = py - ay;
                    var dot00 = v0x * v0x + v0y * v0y;
                    var dot01 = v0x * v1x + v0y * v1y;
                    var dot02 = v0x * v2x + v0y * v2y;
                    var dot11 = v1x * v1x + v1y * v1y;
                    var dot12 = v1x * v2x + v1y * v2y;
                    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                    // Check if point is in triangle
                    return u >= 0 && v >= 0 && u + v < 1;
                };
                /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */ PolyK._convex = function(ax, ay, bx, by, cx, cy) {
                    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
                };
                /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */ module1.exports = PolyK;
            },
            {}
        ],
        30: [
            function(_dereq_, module1, exports1) {
                /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ /**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */ var vec2 = module1.exports = {};
                var Utils = _dereq_('../utils/Utils');
                /**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */ vec2.crossLength = function(a, b) {
                    return a[0] * b[1] - a[1] * b[0];
                };
                /**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */ vec2.crossVZ = function(out, vec, zcomp) {
                    vec2.rotate(out, vec, -Math.PI / 2); // Rotate according to the right hand rule
                    vec2.scale(out, out, zcomp); // Scale with z
                    return out;
                };
                /**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */ vec2.crossZV = function(out, zcomp, vec) {
                    vec2.rotate(out, vec, Math.PI / 2); // Rotate according to the right hand rule
                    vec2.scale(out, out, zcomp); // Scale with z
                    return out;
                };
                /**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */ vec2.rotate = function(out, a, angle) {
                    if (angle !== 0) {
                        var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
                        out[0] = c * x - s * y;
                        out[1] = s * x + c * y;
                    } else {
                        out[0] = a[0];
                        out[1] = a[1];
                    }
                };
                /**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */ vec2.rotate90cw = function(out, a) {
                    var x = a[0];
                    var y = a[1];
                    out[0] = y;
                    out[1] = -x;
                };
                /**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */ vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle) {
                    vec2.copy(out, worldPoint);
                    vec2.sub(out, out, framePosition);
                    vec2.rotate(out, out, -frameAngle);
                };
                /**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */ vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle) {
                    vec2.copy(out, localPoint);
                    vec2.rotate(out, out, frameAngle);
                    vec2.add(out, out, framePosition);
                };
                /**
 * Transform a vector to local frame.
 * @method vectorToLocalFrame
 * @param  {Array} out
 * @param  {Array} worldVector
 * @param  {Number} frameAngle
 */ vec2.vectorToLocalFrame = function(out, worldVector, frameAngle) {
                    vec2.rotate(out, worldVector, -frameAngle);
                };
                /**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localVector
 * @param  {Number} frameAngle
 */ vec2.vectorToGlobalFrame = function(out, localVector, frameAngle) {
                    vec2.rotate(out, localVector, frameAngle);
                };
                /**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */ vec2.centroid = function(out, a, b, c) {
                    vec2.add(out, a, b);
                    vec2.add(out, out, c);
                    vec2.scale(out, out, 1 / 3);
                    return out;
                };
                /**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */ vec2.create = function() {
                    var out = new Utils.ARRAY_TYPE(2);
                    out[0] = 0;
                    out[1] = 0;
                    return out;
                };
                /**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */ vec2.clone = function(a) {
                    var out = new Utils.ARRAY_TYPE(2);
                    out[0] = a[0];
                    out[1] = a[1];
                    return out;
                };
                /**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */ vec2.fromValues = function(x, y) {
                    var out = new Utils.ARRAY_TYPE(2);
                    out[0] = x;
                    out[1] = y;
                    return out;
                };
                /**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */ vec2.copy = function(out, a) {
                    out[0] = a[0];
                    out[1] = a[1];
                    return out;
                };
                /**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */ vec2.set = function(out, x, y) {
                    out[0] = x;
                    out[1] = y;
                    return out;
                };
                /**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */ vec2.add = function(out, a, b) {
                    out[0] = a[0] + b[0];
                    out[1] = a[1] + b[1];
                    return out;
                };
                /**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */ vec2.subtract = function(out, a, b) {
                    out[0] = a[0] - b[0];
                    out[1] = a[1] - b[1];
                    return out;
                };
                /**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */ vec2.sub = vec2.subtract;
                /**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */ vec2.multiply = function(out, a, b) {
                    out[0] = a[0] * b[0];
                    out[1] = a[1] * b[1];
                    return out;
                };
                /**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */ vec2.mul = vec2.multiply;
                /**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */ vec2.divide = function(out, a, b) {
                    out[0] = a[0] / b[0];
                    out[1] = a[1] / b[1];
                    return out;
                };
                /**
 * Alias for vec2.divide
 * @static
 * @method div
 */ vec2.div = vec2.divide;
                /**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */ vec2.scale = function(out, a, b) {
                    out[0] = a[0] * b;
                    out[1] = a[1] * b;
                    return out;
                };
                /**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */ vec2.distance = function(a, b) {
                    var x = b[0] - a[0], y = b[1] - a[1];
                    return Math.sqrt(x * x + y * y);
                };
                /**
 * Alias for vec2.distance
 * @static
 * @method dist
 */ vec2.dist = vec2.distance;
                /**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */ vec2.squaredDistance = function(a, b) {
                    var x = b[0] - a[0], y = b[1] - a[1];
                    return x * x + y * y;
                };
                /**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */ vec2.sqrDist = vec2.squaredDistance;
                /**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */ vec2.length = function(a) {
                    var x = a[0], y = a[1];
                    return Math.sqrt(x * x + y * y);
                };
                /**
 * Alias for vec2.length
 * @method len
 * @static
 */ vec2.len = vec2.length;
                /**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */ vec2.squaredLength = function(a) {
                    var x = a[0], y = a[1];
                    return x * x + y * y;
                };
                /**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */ vec2.sqrLen = vec2.squaredLength;
                /**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */ vec2.negate = function(out, a) {
                    out[0] = -a[0];
                    out[1] = -a[1];
                    return out;
                };
                /**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */ vec2.normalize = function(out, a) {
                    var x = a[0], y = a[1];
                    var len = x * x + y * y;
                    if (len > 0) {
                        //TODO: evaluate use of glm_invsqrt here?
                        len = 1 / Math.sqrt(len);
                        out[0] = a[0] * len;
                        out[1] = a[1] * len;
                    }
                    return out;
                };
                /**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */ vec2.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1];
                };
                /**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */ vec2.str = function(a) {
                    return 'vec2(' + a[0] + ', ' + a[1] + ')';
                };
                /**
 * Linearly interpolate/mix two vectors.
 * @static
 * @method lerp
 * @param {Array} out
 * @param {Array} a First vector
 * @param {Array} b Second vector
 * @param {number} t Lerp factor
 */ vec2.lerp = function(out, a, b, t) {
                    var ax = a[0], ay = a[1];
                    out[0] = ax + t * (b[0] - ax);
                    out[1] = ay + t * (b[1] - ay);
                    return out;
                };
                /**
 * Reflect a vector along a normal.
 * @static
 * @method reflect
 * @param {Array} out
 * @param {Array} vector
 * @param {Array} normal
 */ vec2.reflect = function(out, vector, normal) {
                    var dot = vector[0] * normal[0] + vector[1] * normal[1];
                    out[0] = vector[0] - 2 * normal[0] * dot;
                    out[1] = vector[1] - 2 * normal[1] * dot;
                };
                /**
 * Get the intersection point between two line segments.
 * @static
 * @method getLineSegmentsIntersection
 * @param  {Array} out
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @return {boolean} True if there was an intersection, otherwise false.
 */ vec2.getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {
                    var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
                    if (t < 0) {
                        return false;
                    } else {
                        out[0] = p0[0] + t * (p1[0] - p0[0]);
                        out[1] = p0[1] + t * (p1[1] - p0[1]);
                        return true;
                    }
                };
                /**
 * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)
 * @static
 * @method getLineSegmentsIntersectionFraction
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.
 */ vec2.getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {
                    var s1_x = p1[0] - p0[0];
                    var s1_y = p1[1] - p0[1];
                    var s2_x = p3[0] - p2[0];
                    var s2_y = p3[1] - p2[1];
                    var s, t;
                    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
                    t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
                    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                        return t;
                    }
                    return -1; // No collision
                };
            },
            {
                "../utils/Utils": 57
            }
        ],
        31: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), decomp = _dereq_('poly-decomp'), Convex = _dereq_('../shapes/Convex'), RaycastResult = _dereq_('../collision/RaycastResult'), Ray = _dereq_('../collision/Ray'), AABB = _dereq_('../collision/AABB'), EventEmitter = _dereq_('../events/EventEmitter');
                module1.exports = Body;
                /**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Array} [options.force]
 * @param {Array} [options.position]
 * @param {Array} [options.velocity]
 * @param {Boolean} [options.allowSleep]
 * @param {Boolean} [options.collisionResponse]
 * @param {Number} [options.angle=0]
 * @param {Number} [options.angularForce=0]
 * @param {Number} [options.angularVelocity=0]
 * @param {Number} [options.ccdIterations=10]
 * @param {Number} [options.ccdSpeedThreshold=-1]
 * @param {Number} [options.fixedRotation=false]
 * @param {Number} [options.gravityScale]
 * @param {Number} [options.id]
 * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Number} [options.sleepSpeedLimit]
 * @param {Number} [options.sleepTimeLimit]
 * @param {Object} [options]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle({ radius: 1 }));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */ function Body(options) {
                    options = options || {};
                    EventEmitter.call(this);
                    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */ this.id = options.id || ++Body._idCounter;
                    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */ this.world = null;
                    /**
     * The shapes of the body.
     *
     * @property shapes
     * @type {Array}
     */ this.shapes = [];
                    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */ this.mass = options.mass || 0;
                    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */ this.invMass = 0;
                    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */ this.inertia = 0;
                    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */ this.invInertia = 0;
                    this.invMassSolve = 0;
                    this.invInertiaSolve = 0;
                    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */ this.fixedRotation = !!options.fixedRotation;
                    /**
     * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.
     * @property {Boolean} fixedX
     */ this.fixedX = !!options.fixedX;
                    /**
     * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X.
     * @property {Boolean} fixedY
     */ this.fixedY = !!options.fixedY;
                    /**
     * @private
     * @property {array} massMultiplier
     */ this.massMultiplier = vec2.create();
                    /**
     * The position of the body
     * @property position
     * @type {Array}
     */ this.position = vec2.fromValues(0, 0);
                    if (options.position) {
                        vec2.copy(this.position, options.position);
                    }
                    /**
     * The interpolated position of the body. Use this for rendering.
     * @property interpolatedPosition
     * @type {Array}
     */ this.interpolatedPosition = vec2.fromValues(0, 0);
                    /**
     * The interpolated angle of the body. Use this for rendering.
     * @property interpolatedAngle
     * @type {Number}
     */ this.interpolatedAngle = 0;
                    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */ this.previousPosition = vec2.fromValues(0, 0);
                    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */ this.previousAngle = 0;
                    /**
     * The current velocity of the body.
     * @property velocity
     * @type {Array}
     */ this.velocity = vec2.fromValues(0, 0);
                    if (options.velocity) {
                        vec2.copy(this.velocity, options.velocity);
                    }
                    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */ this.vlambda = vec2.fromValues(0, 0);
                    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */ this.wlambda = 0;
                    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */ this.angle = options.angle || 0;
                    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */ this.angularVelocity = options.angularVelocity || 0;
                    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */ this.force = vec2.create();
                    if (options.force) {
                        vec2.copy(this.force, options.force);
                    }
                    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */ this.angularForce = options.angularForce || 0;
                    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */ this.damping = typeof options.damping === "number" ? options.damping : 0.1;
                    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */ this.angularDamping = typeof options.angularDamping === "number" ? options.angularDamping : 0.1;
                    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */ this.type = Body.STATIC;
                    if (typeof options.type !== 'undefined') {
                        this.type = options.type;
                    } else if (!options.mass) {
                        this.type = Body.STATIC;
                    } else {
                        this.type = Body.DYNAMIC;
                    }
                    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */ this.boundingRadius = 0;
                    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */ this.aabb = new AABB();
                    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */ this.aabbNeedsUpdate = true;
                    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */ this.allowSleep = options.allowSleep !== undefined ? options.allowSleep : true;
                    this.wantsToSleep = false;
                    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */ this.sleepState = Body.AWAKE;
                    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */ this.sleepSpeedLimit = options.sleepSpeedLimit !== undefined ? options.sleepSpeedLimit : 0.2;
                    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */ this.sleepTimeLimit = options.sleepTimeLimit !== undefined ? options.sleepTimeLimit : 1;
                    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */ this.gravityScale = options.gravityScale !== undefined ? options.gravityScale : 1;
                    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */ this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;
                    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */ this.idleTime = 0;
                    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */ this.timeLastSleepy = 0;
                    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */ this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;
                    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */ this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;
                    this.concavePath = null;
                    this._wakeUpAfterNarrowphase = false;
                    this.updateMassProperties();
                }
                Body.prototype = new EventEmitter();
                Body.prototype.constructor = Body;
                Body._idCounter = 0;
                /**
 * @private
 * @method updateSolveMassProperties
 */ Body.prototype.updateSolveMassProperties = function() {
                    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
                        this.invMassSolve = 0;
                        this.invInertiaSolve = 0;
                    } else {
                        this.invMassSolve = this.invMass;
                        this.invInertiaSolve = this.invInertia;
                    }
                };
                /**
 * Set the total density of the body
 * @method setDensity
 * @param {number} density
 */ Body.prototype.setDensity = function(density) {
                    var totalArea = this.getArea();
                    this.mass = totalArea * density;
                    this.updateMassProperties();
                };
                /**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */ Body.prototype.getArea = function() {
                    var totalArea = 0;
                    for(var i = 0; i < this.shapes.length; i++){
                        totalArea += this.shapes[i].area;
                    }
                    return totalArea;
                };
                /**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 * @return {AABB} The AABB instance (this.aabb)
 */ Body.prototype.getAABB = function() {
                    if (this.aabbNeedsUpdate) {
                        this.updateAABB();
                    }
                    return this.aabb;
                };
                var shapeAABB = new AABB(), tmp = vec2.create();
                /**
 * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.
 * @method updateAABB
 */ Body.prototype.updateAABB = function() {
                    var shapes = this.shapes, N = shapes.length, offset = tmp, bodyAngle = this.angle;
                    for(var i = 0; i !== N; i++){
                        var shape = shapes[i], angle = shape.angle + bodyAngle;
                        // Get shape world offset
                        vec2.rotate(offset, shape.position, bodyAngle);
                        vec2.add(offset, offset, this.position);
                        // Get shape AABB
                        shape.computeAABB(shapeAABB, offset, angle);
                        if (i === 0) {
                            this.aabb.copy(shapeAABB);
                        } else {
                            this.aabb.extend(shapeAABB);
                        }
                    }
                    this.aabbNeedsUpdate = false;
                };
                /**
 * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.
 * @method updateBoundingRadius
 */ Body.prototype.updateBoundingRadius = function() {
                    var shapes = this.shapes, N = shapes.length, radius = 0;
                    for(var i = 0; i !== N; i++){
                        var shape = shapes[i], offset = vec2.length(shape.position), r = shape.boundingRadius;
                        if (offset + r > radius) {
                            radius = offset + r;
                        }
                    }
                    this.boundingRadius = radius;
                };
                /**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle({ radius: 1 });
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */ Body.prototype.addShape = function(shape, offset, angle) {
                    if (shape.body) {
                        throw new Error('A shape can only be added to one body.');
                    }
                    shape.body = this;
                    // Copy the offset vector
                    if (offset) {
                        vec2.copy(shape.position, offset);
                    } else {
                        vec2.set(shape.position, 0, 0);
                    }
                    shape.angle = angle || 0;
                    this.shapes.push(shape);
                    this.updateMassProperties();
                    this.updateBoundingRadius();
                    this.aabbNeedsUpdate = true;
                };
                /**
 * Remove a shape
 * @method removeShape
 * @param  {Shape} shape
 * @return {Boolean} True if the shape was found and removed, else false.
 */ Body.prototype.removeShape = function(shape) {
                    var idx = this.shapes.indexOf(shape);
                    if (idx !== -1) {
                        this.shapes.splice(idx, 1);
                        this.aabbNeedsUpdate = true;
                        shape.body = null;
                        return true;
                    } else {
                        return false;
                    }
                };
                /**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */ Body.prototype.updateMassProperties = function() {
                    if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
                        this.mass = Number.MAX_VALUE;
                        this.invMass = 0;
                        this.inertia = Number.MAX_VALUE;
                        this.invInertia = 0;
                    } else {
                        var shapes = this.shapes, N = shapes.length, m = this.mass / N, I = 0;
                        if (!this.fixedRotation) {
                            for(var i = 0; i < N; i++){
                                var shape = shapes[i], r2 = vec2.squaredLength(shape.position), Icm = shape.computeMomentOfInertia(m);
                                I += Icm + m * r2;
                            }
                            this.inertia = I;
                            this.invInertia = I > 0 ? 1 / I : 0;
                        } else {
                            this.inertia = Number.MAX_VALUE;
                            this.invInertia = 0;
                        }
                        // Inverse mass properties are easy
                        this.invMass = 1 / this.mass;
                        vec2.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
                    }
                };
                var Body_applyForce_r = vec2.create();
                /**
 * Apply force to a point relative to the center of mass of the body. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce. If relativePoint is zero, the force will be applied directly on the center of mass, and the torque produced will be zero.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} [relativePoint] A world point to apply the force on.
 */ Body.prototype.applyForce = function(force, relativePoint) {
                    // Add linear force
                    vec2.add(this.force, this.force, force);
                    if (relativePoint) {
                        // Compute produced rotational force
                        var rotForce = vec2.crossLength(relativePoint, force);
                        // Add rotational force
                        this.angularForce += rotForce;
                    }
                };
                /**
 * Apply force to a body-local point.
 * @method applyForceLocal
 * @param  {Array} localForce The force vector to add, oriented in local body space.
 * @param  {Array} [localPoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
 */ var Body_applyForce_forceWorld = vec2.create();
                var Body_applyForce_pointWorld = vec2.create();
                var Body_applyForce_pointLocal = vec2.create();
                Body.prototype.applyForceLocal = function(localForce, localPoint) {
                    localPoint = localPoint || Body_applyForce_pointLocal;
                    var worldForce = Body_applyForce_forceWorld;
                    var worldPoint = Body_applyForce_pointWorld;
                    this.vectorToWorldFrame(worldForce, localForce);
                    this.vectorToWorldFrame(worldPoint, localPoint);
                    this.applyForce(worldForce, worldPoint);
                };
                /**
 * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Array} impulse The impulse vector to add, oriented in world space.
 * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
 */ var Body_applyImpulse_velo = vec2.create();
                Body.prototype.applyImpulse = function(impulseVector, relativePoint) {
                    if (this.type !== Body.DYNAMIC) {
                        return;
                    }
                    // Compute produced central impulse velocity
                    var velo = Body_applyImpulse_velo;
                    vec2.scale(velo, impulseVector, this.invMass);
                    vec2.multiply(velo, this.massMultiplier, velo);
                    // Add linear impulse
                    vec2.add(this.velocity, velo, this.velocity);
                    if (relativePoint) {
                        // Compute produced rotational impulse velocity
                        var rotVelo = vec2.crossLength(relativePoint, impulseVector);
                        rotVelo *= this.invInertia;
                        // Add rotational Impulse
                        this.angularVelocity += rotVelo;
                    }
                };
                /**
 * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulseLocal
 * @param  {Array} impulse The impulse vector to add, oriented in world space.
 * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
 */ var Body_applyImpulse_impulseWorld = vec2.create();
                var Body_applyImpulse_pointWorld = vec2.create();
                var Body_applyImpulse_pointLocal = vec2.create();
                Body.prototype.applyImpulseLocal = function(localImpulse, localPoint) {
                    localPoint = localPoint || Body_applyImpulse_pointLocal;
                    var worldImpulse = Body_applyImpulse_impulseWorld;
                    var worldPoint = Body_applyImpulse_pointWorld;
                    this.vectorToWorldFrame(worldImpulse, localImpulse);
                    this.vectorToWorldFrame(worldPoint, localPoint);
                    this.applyImpulse(worldImpulse, worldPoint);
                };
                /**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world point
 */ Body.prototype.toLocalFrame = function(out, worldPoint) {
                    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
                };
                /**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local point
 */ Body.prototype.toWorldFrame = function(out, localPoint) {
                    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
                };
                /**
 * Transform a world point to local body frame.
 * @method vectorToLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldVector  The input world vector
 */ Body.prototype.vectorToLocalFrame = function(out, worldVector) {
                    vec2.vectorToLocalFrame(out, worldVector, this.angle);
                };
                /**
 * Transform a local point to world frame.
 * @method vectorToWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localVector  The input local vector
 */ Body.prototype.vectorToWorldFrame = function(out, localVector) {
                    vec2.vectorToGlobalFrame(out, localVector, this.angle);
                };
                /**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */ Body.prototype.fromPolygon = function(path, options) {
                    options = options || {};
                    // Remove all shapes
                    for(var i = this.shapes.length; i >= 0; --i){
                        this.removeShape(this.shapes[i]);
                    }
                    var p = new decomp.Polygon();
                    p.vertices = path;
                    // Make it counter-clockwise
                    p.makeCCW();
                    if (typeof options.removeCollinearPoints === "number") {
                        p.removeCollinearPoints(options.removeCollinearPoints);
                    }
                    // Check if any line segment intersects the path itself
                    if (typeof options.skipSimpleCheck === "undefined") {
                        if (!p.isSimple()) {
                            return false;
                        }
                    }
                    // Save this path for later
                    this.concavePath = p.vertices.slice(0);
                    for(var i = 0; i < this.concavePath.length; i++){
                        var v = [
                            0,
                            0
                        ];
                        vec2.copy(v, this.concavePath[i]);
                        this.concavePath[i] = v;
                    }
                    // Slow or fast decomp?
                    var convexes;
                    if (options.optimalDecomp) {
                        convexes = p.decomp();
                    } else {
                        convexes = p.quickDecomp();
                    }
                    var cm = vec2.create();
                    // Add convexes
                    for(var i = 0; i !== convexes.length; i++){
                        // Create convex
                        var c = new Convex({
                            vertices: convexes[i].vertices
                        });
                        // Move all vertices so its center of mass is in the local center of the convex
                        for(var j = 0; j !== c.vertices.length; j++){
                            var v = c.vertices[j];
                            vec2.sub(v, v, c.centerOfMass);
                        }
                        vec2.scale(cm, c.centerOfMass, 1);
                        c.updateTriangles();
                        c.updateCenterOfMass();
                        c.updateBoundingRadius();
                        // Add the shape
                        this.addShape(c, cm);
                    }
                    this.adjustCenterOfMass();
                    this.aabbNeedsUpdate = true;
                    return true;
                };
                var adjustCenterOfMass_tmp1 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp2 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp3 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp4 = vec2.fromValues(0, 0);
                /**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */ Body.prototype.adjustCenterOfMass = function() {
                    var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
                    vec2.set(sum, 0, 0);
                    for(var i = 0; i !== this.shapes.length; i++){
                        var s = this.shapes[i];
                        vec2.scale(offset_times_area, s.position, s.area);
                        vec2.add(sum, sum, offset_times_area);
                        totalArea += s.area;
                    }
                    vec2.scale(cm, sum, 1 / totalArea);
                    // Now move all shapes
                    for(var i = 0; i !== this.shapes.length; i++){
                        var s = this.shapes[i];
                        vec2.sub(s.position, s.position, cm);
                    }
                    // Move the body position too
                    vec2.add(this.position, this.position, cm);
                    // And concave path
                    for(var i = 0; this.concavePath && i < this.concavePath.length; i++){
                        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
                    }
                    this.updateMassProperties();
                    this.updateBoundingRadius();
                };
                /**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */ Body.prototype.setZeroForce = function() {
                    vec2.set(this.force, 0.0, 0.0);
                    this.angularForce = 0.0;
                };
                Body.prototype.resetConstraintVelocity = function() {
                    var b = this, vlambda = b.vlambda;
                    vec2.set(vlambda, 0, 0);
                    b.wlambda = 0;
                };
                Body.prototype.addConstraintVelocity = function() {
                    var b = this, v = b.velocity;
                    vec2.add(v, v, b.vlambda);
                    b.angularVelocity += b.wlambda;
                };
                /**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */ Body.prototype.applyDamping = function(dt) {
                    if (this.type === Body.DYNAMIC) {
                        var v = this.velocity;
                        vec2.scale(v, v, Math.pow(1.0 - this.damping, dt));
                        this.angularVelocity *= Math.pow(1.0 - this.angularDamping, dt);
                    }
                };
                /**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */ Body.prototype.wakeUp = function() {
                    var s = this.sleepState;
                    this.sleepState = Body.AWAKE;
                    this.idleTime = 0;
                    if (s !== Body.AWAKE) {
                        this.emit(Body.wakeUpEvent);
                    }
                };
                /**
 * Force body sleep
 * @method sleep
 */ Body.prototype.sleep = function() {
                    this.sleepState = Body.SLEEPING;
                    this.angularVelocity = 0;
                    this.angularForce = 0;
                    vec2.set(this.velocity, 0, 0);
                    vec2.set(this.force, 0, 0);
                    this.emit(Body.sleepEvent);
                };
                /**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */ Body.prototype.sleepTick = function(time, dontSleep, dt) {
                    if (!this.allowSleep || this.type === Body.SLEEPING) {
                        return;
                    }
                    this.wantsToSleep = false;
                    var sleepState = this.sleepState, speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                    // Add to idle time
                    if (speedSquared >= speedLimitSquared) {
                        this.idleTime = 0;
                        this.sleepState = Body.AWAKE;
                    } else {
                        this.idleTime += dt;
                        this.sleepState = Body.SLEEPY;
                    }
                    if (this.idleTime > this.sleepTimeLimit) {
                        if (!dontSleep) {
                            this.sleep();
                        } else {
                            this.wantsToSleep = true;
                        }
                    }
                };
                /**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */ Body.prototype.overlaps = function(body) {
                    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
                };
                var integrate_fhMinv = vec2.create();
                var integrate_velodt = vec2.create();
                /**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */ Body.prototype.integrate = function(dt) {
                    var minv = this.invMass, f = this.force, pos = this.position, velo = this.velocity;
                    // Save old position
                    vec2.copy(this.previousPosition, this.position);
                    this.previousAngle = this.angle;
                    // Velocity update
                    if (!this.fixedRotation) {
                        this.angularVelocity += this.angularForce * this.invInertia * dt;
                    }
                    vec2.scale(integrate_fhMinv, f, dt * minv);
                    vec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
                    vec2.add(velo, integrate_fhMinv, velo);
                    // CCD
                    if (!this.integrateToTimeOfImpact(dt)) {
                        // Regular position update
                        vec2.scale(integrate_velodt, velo, dt);
                        vec2.add(pos, pos, integrate_velodt);
                        if (!this.fixedRotation) {
                            this.angle += this.angularVelocity * dt;
                        }
                    }
                    this.aabbNeedsUpdate = true;
                };
                var result = new RaycastResult();
                var ray = new Ray({
                    mode: Ray.ALL
                });
                var direction = vec2.create();
                var end = vec2.create();
                var startToEnd = vec2.create();
                var rememberPosition = vec2.create();
                Body.prototype.integrateToTimeOfImpact = function(dt) {
                    if (this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
                        return false;
                    }
                    vec2.normalize(direction, this.velocity);
                    vec2.scale(end, this.velocity, dt);
                    vec2.add(end, end, this.position);
                    vec2.sub(startToEnd, end, this.position);
                    var startToEndAngle = this.angularVelocity * dt;
                    var len = vec2.length(startToEnd);
                    var timeOfImpact = 1;
                    var hit;
                    var that = this;
                    result.reset();
                    ray.callback = function(result) {
                        if (result.body === that) {
                            return;
                        }
                        hit = result.body;
                        result.getHitPoint(end, ray);
                        vec2.sub(startToEnd, end, that.position);
                        timeOfImpact = vec2.length(startToEnd) / len;
                        result.stop();
                    };
                    vec2.copy(ray.from, this.position);
                    vec2.copy(ray.to, end);
                    ray.update();
                    this.world.raycast(result, ray);
                    if (!hit) {
                        return false;
                    }
                    var rememberAngle = this.angle;
                    vec2.copy(rememberPosition, this.position);
                    // Got a start and end point. Approximate time of impact using binary search
                    var iter = 0;
                    var tmin = 0;
                    var tmid = 0;
                    var tmax = timeOfImpact;
                    while(tmax >= tmin && iter < this.ccdIterations){
                        iter++;
                        // calculate the midpoint
                        tmid = (tmax - tmin) / 2;
                        // Move the body to that point
                        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
                        vec2.add(this.position, rememberPosition, integrate_velodt);
                        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
                        this.updateAABB();
                        // check overlap
                        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);
                        if (overlaps) {
                            // change min to search upper interval
                            tmin = tmid;
                        } else {
                            // change max to search lower interval
                            tmax = tmid;
                        }
                    }
                    timeOfImpact = tmid;
                    vec2.copy(this.position, rememberPosition);
                    this.angle = rememberAngle;
                    // move to TOI
                    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
                    vec2.add(this.position, this.position, integrate_velodt);
                    if (!this.fixedRotation) {
                        this.angle += startToEndAngle * timeOfImpact;
                    }
                    return true;
                };
                /**
 * Get velocity of a point in the body.
 * @method getVelocityAtPoint
 * @param  {Array} result A vector to store the result in
 * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from
 * @return {Array} The result vector
 */ Body.prototype.getVelocityAtPoint = function(result, relativePoint) {
                    vec2.crossVZ(result, relativePoint, this.angularVelocity);
                    vec2.subtract(result, this.velocity, result);
                    return result;
                };
                /**
 * @event sleepy
 */ Body.sleepyEvent = {
                    type: "sleepy"
                };
                /**
 * @event sleep
 */ Body.sleepEvent = {
                    type: "sleep"
                };
                /**
 * @event wakeup
 */ Body.wakeUpEvent = {
                    type: "wakeup"
                };
                /**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */ Body.DYNAMIC = 1;
                /**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */ Body.STATIC = 2;
                /**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */ Body.KINEMATIC = 4;
                /**
 * @property AWAKE
 * @type {Number}
 * @static
 */ Body.AWAKE = 0;
                /**
 * @property SLEEPY
 * @type {Number}
 * @static
 */ Body.SLEEPY = 1;
                /**
 * @property SLEEPING
 * @type {Number}
 * @static
 */ Body.SLEEPING = 2;
            },
            {
                "../collision/AABB": 7,
                "../collision/Ray": 11,
                "../collision/RaycastResult": 12,
                "../events/EventEmitter": 26,
                "../math/vec2": 30,
                "../shapes/Convex": 40,
                "poly-decomp": 5
            }
        ],
        32: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2');
                var Spring = _dereq_('./Spring');
                var Utils = _dereq_('../utils/Utils');
                module1.exports = LinearSpring;
                /**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */ function LinearSpring(bodyA, bodyB, options) {
                    options = options || {};
                    Spring.call(this, bodyA, bodyB, options);
                    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */ this.localAnchorA = vec2.fromValues(0, 0);
                    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */ this.localAnchorB = vec2.fromValues(0, 0);
                    if (options.localAnchorA) {
                        vec2.copy(this.localAnchorA, options.localAnchorA);
                    }
                    if (options.localAnchorB) {
                        vec2.copy(this.localAnchorB, options.localAnchorB);
                    }
                    if (options.worldAnchorA) {
                        this.setWorldAnchorA(options.worldAnchorA);
                    }
                    if (options.worldAnchorB) {
                        this.setWorldAnchorB(options.worldAnchorB);
                    }
                    var worldAnchorA = vec2.create();
                    var worldAnchorB = vec2.create();
                    this.getWorldAnchorA(worldAnchorA);
                    this.getWorldAnchorB(worldAnchorB);
                    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);
                    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */ this.restLength = typeof options.restLength === "number" ? options.restLength : worldDistance;
                }
                LinearSpring.prototype = new Spring();
                LinearSpring.prototype.constructor = LinearSpring;
                /**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */ LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA) {
                    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
                };
                /**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */ LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB) {
                    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
                };
                /**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */ LinearSpring.prototype.getWorldAnchorA = function(result) {
                    this.bodyA.toWorldFrame(result, this.localAnchorA);
                };
                /**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */ LinearSpring.prototype.getWorldAnchorB = function(result) {
                    this.bodyB.toWorldFrame(result, this.localAnchorB);
                };
                var applyForce_r = vec2.create(), applyForce_r_unit = vec2.create(), applyForce_u = vec2.create(), applyForce_f = vec2.create(), applyForce_worldAnchorA = vec2.create(), applyForce_worldAnchorB = vec2.create(), applyForce_ri = vec2.create(), applyForce_rj = vec2.create(), applyForce_tmp = vec2.create();
                /**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */ LinearSpring.prototype.applyForce = function() {
                    var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
                    var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
                    // Get world anchors
                    this.getWorldAnchorA(worldAnchorA);
                    this.getWorldAnchorB(worldAnchorB);
                    // Get offset points
                    vec2.sub(ri, worldAnchorA, bodyA.position);
                    vec2.sub(rj, worldAnchorB, bodyB.position);
                    // Compute distance vector between world anchor points
                    vec2.sub(r, worldAnchorB, worldAnchorA);
                    var rlen = vec2.len(r);
                    vec2.normalize(r_unit, r);
                    //console.log(rlen)
                    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))
                    // Compute relative velocity of the anchor points, u
                    vec2.sub(u, bodyB.velocity, bodyA.velocity);
                    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
                    vec2.add(u, u, tmp);
                    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
                    vec2.sub(u, u, tmp);
                    // F = - k * ( x - L ) - D * ( u )
                    vec2.scale(f, r_unit, -k * (rlen - l) - d * vec2.dot(u, r_unit));
                    // Add forces to bodies
                    vec2.sub(bodyA.force, bodyA.force, f);
                    vec2.add(bodyB.force, bodyB.force, f);
                    // Angular force
                    var ri_x_f = vec2.crossLength(ri, f);
                    var rj_x_f = vec2.crossLength(rj, f);
                    bodyA.angularForce -= ri_x_f;
                    bodyB.angularForce += rj_x_f;
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Spring": 34
            }
        ],
        33: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2');
                var Spring = _dereq_('./Spring');
                module1.exports = RotationalSpring;
                /**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */ function RotationalSpring(bodyA, bodyB, options) {
                    options = options || {};
                    Spring.call(this, bodyA, bodyB, options);
                    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */ this.restAngle = typeof options.restAngle === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
                }
                RotationalSpring.prototype = new Spring();
                RotationalSpring.prototype.constructor = RotationalSpring;
                /**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */ RotationalSpring.prototype.applyForce = function() {
                    var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
                    var torque = -k * (x - l) - d * u * 0;
                    bodyA.angularForce -= torque;
                    bodyB.angularForce += torque;
                };
            },
            {
                "../math/vec2": 30,
                "./Spring": 34
            }
        ],
        34: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2');
                var Utils = _dereq_('../utils/Utils');
                module1.exports = Spring;
                /**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */ function Spring(bodyA, bodyB, options) {
                    options = Utils.defaults(options, {
                        stiffness: 100,
                        damping: 1
                    });
                    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */ this.stiffness = options.stiffness;
                    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */ this.damping = options.damping;
                    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */ this.bodyA = bodyA;
                    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */ this.bodyB = bodyB;
                }
                /**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */ Spring.prototype.applyForce = function() {
                // To be implemented by subclasses
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }
        ],
        35: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2');
                var Utils = _dereq_('../utils/Utils');
                var Constraint = _dereq_('../constraints/Constraint');
                var FrictionEquation = _dereq_('../equations/FrictionEquation');
                var Body = _dereq_('../objects/Body');
                module1.exports = TopDownVehicle;
                /**
 * @class TopDownVehicle
 * @constructor
 * @param {Body} chassisBody A dynamic body, already added to the world.
 * @param {Object} [options]
 *
 * @example
 *
 *     // Create a dynamic body for the chassis
 *     var chassisBody = new Body({
 *         mass: 1
 *     });
 *     var boxShape = new Box({ width: 0.5, height: 1 });
 *     chassisBody.addShape(boxShape);
 *     world.addBody(chassisBody);
 *
 *     // Create the vehicle
 *     var vehicle = new TopDownVehicle(chassisBody);
 *
 *     // Add one front wheel and one back wheel - we don't actually need four :)
 *     var frontWheel = vehicle.addWheel({
 *         localPosition: [0, 0.5] // front
 *     });
 *     frontWheel.setSideFriction(4);
 *
 *     // Back wheel
 *     var backWheel = vehicle.addWheel({
 *         localPosition: [0, -0.5] // back
 *     });
 *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift
 *     vehicle.addToWorld(world);
 *
 *     // Steer value zero means straight forward. Positive is left and negative right.
 *     frontWheel.steerValue = Math.PI / 16;
 *
 *     // Engine force forward
 *     backWheel.engineForce = 10;
 *     backWheel.setBrakeForce(0);
 */ function TopDownVehicle(chassisBody, options) {
                    options = options || {};
                    /**
     * @property {Body} chassisBody
     */ this.chassisBody = chassisBody;
                    /**
     * @property {Array} wheels
     */ this.wheels = [];
                    // A dummy body to constrain the chassis to
                    this.groundBody = new Body({
                        mass: 0
                    });
                    this.world = null;
                    var that = this;
                    this.preStepCallback = function() {
                        that.update();
                    };
                }
                /**
 * @method addToWorld
 * @param {World} world
 */ TopDownVehicle.prototype.addToWorld = function(world) {
                    this.world = world;
                    world.addBody(this.groundBody);
                    world.on('preStep', this.preStepCallback);
                    for(var i = 0; i < this.wheels.length; i++){
                        var wheel = this.wheels[i];
                        world.addConstraint(wheel);
                    }
                };
                /**
 * @method removeFromWorld
 * @param {World} world
 */ TopDownVehicle.prototype.removeFromWorld = function() {
                    var world = this.world;
                    world.removeBody(this.groundBody);
                    world.off('preStep', this.preStepCallback);
                    for(var i = 0; i < this.wheels.length; i++){
                        var wheel = this.wheels[i];
                        world.removeConstraint(wheel);
                    }
                    this.world = null;
                };
                /**
 * @method addWheel
 * @param {object} [wheelOptions]
 * @return {WheelConstraint}
 */ TopDownVehicle.prototype.addWheel = function(wheelOptions) {
                    var wheel = new WheelConstraint(this, wheelOptions);
                    this.wheels.push(wheel);
                    return wheel;
                };
                /**
 * @method update
 */ TopDownVehicle.prototype.update = function() {
                    for(var i = 0; i < this.wheels.length; i++){
                        this.wheels[i].update();
                    }
                };
                /**
 * @class WheelConstraint
 * @constructor
 * @extends {Constraint}
 * @param {Vehicle} vehicle
 * @param {object} [options]
 * @param {Array} [options.localForwardVector]The local wheel forward vector in local body space. Default is zero.
 * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.
 * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.
 */ function WheelConstraint(vehicle, options) {
                    options = options || {};
                    this.vehicle = vehicle;
                    this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);
                    this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);
                    /**
     * @property {number} steerValue
     */ this.steerValue = 0;
                    /**
     * @property {number} engineForce
     */ this.engineForce = 0;
                    this.setSideFriction(options.sideFriction !== undefined ? options.sideFriction : 5);
                    /**
     * @property {Array} localForwardVector
     */ this.localForwardVector = vec2.fromValues(0, 1);
                    if (options.localForwardVector) {
                        vec2.copy(this.localForwardVector, options.localForwardVector);
                    }
                    /**
     * @property {Array} localPosition
     */ this.localPosition = vec2.fromValues(0, 0);
                    if (options.localPosition) {
                        vec2.copy(this.localPosition, options.localPosition);
                    }
                    Constraint.apply(this, vehicle.chassisBody, vehicle.groundBody);
                    this.equations.push(this.forwardEquation, this.sideEquation);
                    this.setBrakeForce(0);
                }
                WheelConstraint.prototype = new Constraint();
                /**
 * @method setForwardFriction
 */ WheelConstraint.prototype.setBrakeForce = function(force) {
                    this.forwardEquation.setSlipForce(force);
                };
                /**
 * @method setSideFriction
 */ WheelConstraint.prototype.setSideFriction = function(force) {
                    this.sideEquation.setSlipForce(force);
                };
                var worldVelocity = vec2.create();
                var relativePoint = vec2.create();
                /**
 * @method getSpeed
 */ WheelConstraint.prototype.getSpeed = function() {
                    this.vehicle.chassisBody.vectorToWorldFrame(relativePoint, this.localForwardVector);
                    this.vehicle.chassisBody.getVelocityAtPoint(worldVelocity, relativePoint);
                    return vec2.dot(worldVelocity, relativePoint);
                };
                var tmpVec = vec2.create();
                /**
 * @method update
 */ WheelConstraint.prototype.update = function() {
                    // Directional
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);
                    vec2.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);
                    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);
                    vec2.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);
                    vec2.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);
                    // Attachment point
                    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);
                    vec2.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);
                    vec2.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);
                    // Add engine force
                    vec2.normalize(tmpVec, this.forwardEquation.t);
                    vec2.scale(tmpVec, tmpVec, this.engineForce);
                    this.vehicle.chassisBody.applyForce(tmpVec, this.forwardEquation.contactPointA);
                };
            },
            {
                "../constraints/Constraint": 14,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }
        ],
        36: [
            function(_dereq_, module1, exports1) {
                // Export p2 classes
                var p2 = module1.exports = {
                    AABB: _dereq_('./collision/AABB'),
                    AngleLockEquation: _dereq_('./equations/AngleLockEquation'),
                    Body: _dereq_('./objects/Body'),
                    Broadphase: _dereq_('./collision/Broadphase'),
                    Capsule: _dereq_('./shapes/Capsule'),
                    Circle: _dereq_('./shapes/Circle'),
                    Constraint: _dereq_('./constraints/Constraint'),
                    ContactEquation: _dereq_('./equations/ContactEquation'),
                    ContactEquationPool: _dereq_('./utils/ContactEquationPool'),
                    ContactMaterial: _dereq_('./material/ContactMaterial'),
                    Convex: _dereq_('./shapes/Convex'),
                    DistanceConstraint: _dereq_('./constraints/DistanceConstraint'),
                    Equation: _dereq_('./equations/Equation'),
                    EventEmitter: _dereq_('./events/EventEmitter'),
                    FrictionEquation: _dereq_('./equations/FrictionEquation'),
                    FrictionEquationPool: _dereq_('./utils/FrictionEquationPool'),
                    GearConstraint: _dereq_('./constraints/GearConstraint'),
                    GSSolver: _dereq_('./solver/GSSolver'),
                    Heightfield: _dereq_('./shapes/Heightfield'),
                    Line: _dereq_('./shapes/Line'),
                    LockConstraint: _dereq_('./constraints/LockConstraint'),
                    Material: _dereq_('./material/Material'),
                    Narrowphase: _dereq_('./collision/Narrowphase'),
                    NaiveBroadphase: _dereq_('./collision/NaiveBroadphase'),
                    Particle: _dereq_('./shapes/Particle'),
                    Plane: _dereq_('./shapes/Plane'),
                    Pool: _dereq_('./utils/Pool'),
                    RevoluteConstraint: _dereq_('./constraints/RevoluteConstraint'),
                    PrismaticConstraint: _dereq_('./constraints/PrismaticConstraint'),
                    Ray: _dereq_('./collision/Ray'),
                    RaycastResult: _dereq_('./collision/RaycastResult'),
                    Box: _dereq_('./shapes/Box'),
                    RotationalVelocityEquation: _dereq_('./equations/RotationalVelocityEquation'),
                    SAPBroadphase: _dereq_('./collision/SAPBroadphase'),
                    Shape: _dereq_('./shapes/Shape'),
                    Solver: _dereq_('./solver/Solver'),
                    Spring: _dereq_('./objects/Spring'),
                    TopDownVehicle: _dereq_('./objects/TopDownVehicle'),
                    LinearSpring: _dereq_('./objects/LinearSpring'),
                    RotationalSpring: _dereq_('./objects/RotationalSpring'),
                    Utils: _dereq_('./utils/Utils'),
                    World: _dereq_('./world/World'),
                    vec2: _dereq_('./math/vec2'),
                    version: _dereq_('../package.json').version
                };
                Object.defineProperty(p2, 'Rectangle', {
                    get: function() {
                        console.warn('The Rectangle class has been renamed to Box.');
                        return this.Box;
                    }
                });
            },
            {
                "../package.json": 6,
                "./collision/AABB": 7,
                "./collision/Broadphase": 8,
                "./collision/NaiveBroadphase": 9,
                "./collision/Narrowphase": 10,
                "./collision/Ray": 11,
                "./collision/RaycastResult": 12,
                "./collision/SAPBroadphase": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/GearConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PrismaticConstraint": 18,
                "./constraints/RevoluteConstraint": 19,
                "./equations/AngleLockEquation": 20,
                "./equations/ContactEquation": 21,
                "./equations/Equation": 22,
                "./equations/FrictionEquation": 23,
                "./equations/RotationalVelocityEquation": 25,
                "./events/EventEmitter": 26,
                "./material/ContactMaterial": 27,
                "./material/Material": 28,
                "./math/vec2": 30,
                "./objects/Body": 31,
                "./objects/LinearSpring": 32,
                "./objects/RotationalSpring": 33,
                "./objects/Spring": 34,
                "./objects/TopDownVehicle": 35,
                "./shapes/Box": 37,
                "./shapes/Capsule": 38,
                "./shapes/Circle": 39,
                "./shapes/Convex": 40,
                "./shapes/Heightfield": 41,
                "./shapes/Line": 42,
                "./shapes/Particle": 43,
                "./shapes/Plane": 44,
                "./shapes/Shape": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./utils/ContactEquationPool": 48,
                "./utils/FrictionEquationPool": 49,
                "./utils/Pool": 55,
                "./utils/Utils": 57,
                "./world/World": 61
            }
        ],
        37: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), Shape = _dereq_('./Shape'), Convex = _dereq_('./Convex');
                module1.exports = Box;
                /**
 * Box shape class.
 * @class Box
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Number} [options.width=1] Total width of the box
 * @param {Number} [options.height=1] Total height of the box
 * @extends Convex
 */ function Box(options) {
                    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                        options = {
                            width: arguments[0],
                            height: arguments[1]
                        };
                        console.warn('The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })');
                    }
                    options = options || {};
                    /**
     * Total width of the box
     * @property width
     * @type {Number}
     */ var width = this.width = options.width || 1;
                    /**
     * Total height of the box
     * @property height
     * @type {Number}
     */ var height = this.height = options.height || 1;
                    var verts = [
                        vec2.fromValues(-width / 2, -height / 2),
                        vec2.fromValues(width / 2, -height / 2),
                        vec2.fromValues(width / 2, height / 2),
                        vec2.fromValues(-width / 2, height / 2)
                    ];
                    var axes = [
                        vec2.fromValues(1, 0),
                        vec2.fromValues(0, 1)
                    ];
                    options.vertices = verts;
                    options.axes = axes;
                    options.type = Shape.BOX;
                    Convex.call(this, options);
                }
                Box.prototype = new Convex();
                Box.prototype.constructor = Box;
                /**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */ Box.prototype.computeMomentOfInertia = function(mass) {
                    var w = this.width, h = this.height;
                    return mass * (h * h + w * w) / 12;
                };
                /**
 * Update the bounding radius
 * @method updateBoundingRadius
 */ Box.prototype.updateBoundingRadius = function() {
                    var w = this.width, h = this.height;
                    this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
                };
                var corner1 = vec2.create(), corner2 = vec2.create(), corner3 = vec2.create(), corner4 = vec2.create();
                /**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */ Box.prototype.computeAABB = function(out, position, angle) {
                    out.setFromPoints(this.vertices, position, angle, 0);
                };
                Box.prototype.updateArea = function() {
                    this.area = this.width * this.height;
                };
            },
            {
                "../math/vec2": 30,
                "./Convex": 40,
                "./Shape": 45
            }
        ],
        38: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2');
                module1.exports = Capsule;
                /**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Number} [options.length=1] The distance between the end points
 * @param {Number} [options.radius=1] Radius of the capsule
 * @example
 *     var capsuleShape = new Capsule({
 *         length: 1,
 *         radius: 2
 *     });
 *     body.addShape(capsuleShape);
 */ function Capsule(options) {
                    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                        options = {
                            length: arguments[0],
                            radius: arguments[1]
                        };
                        console.warn('The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })');
                    }
                    options = options || {};
                    /**
     * The distance between the end points.
     * @property {Number} length
     */ this.length = options.length || 1;
                    /**
     * The radius of the capsule.
     * @property {Number} radius
     */ this.radius = options.radius || 1;
                    options.type = Shape.CAPSULE;
                    Shape.call(this, options);
                }
                Capsule.prototype = new Shape();
                Capsule.prototype.constructor = Capsule;
                /**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */ Capsule.prototype.computeMomentOfInertia = function(mass) {
                    // Approximate with rectangle
                    var r = this.radius, w = this.length + r, h = r * 2;
                    return mass * (h * h + w * w) / 12;
                };
                /**
 * @method updateBoundingRadius
 */ Capsule.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius + this.length / 2;
                };
                /**
 * @method updateArea
 */ Capsule.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
                };
                var r = vec2.create();
                /**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */ Capsule.prototype.computeAABB = function(out, position, angle) {
                    var radius = this.radius;
                    // Compute center position of one of the the circles, world oriented, but with local offset
                    vec2.set(r, this.length / 2, 0);
                    if (angle !== 0) {
                        vec2.rotate(r, r, angle);
                    }
                    // Get bounds
                    vec2.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
                    vec2.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
                    // Add offset
                    vec2.add(out.lowerBound, out.lowerBound, position);
                    vec2.add(out.upperBound, out.upperBound, position);
                };
                var intersectCapsule_hitPointWorld = vec2.create();
                var intersectCapsule_normal = vec2.create();
                var intersectCapsule_l0 = vec2.create();
                var intersectCapsule_l1 = vec2.create();
                var intersectCapsule_unit_y = vec2.fromValues(0, 1);
                /**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */ Capsule.prototype.raycast = function(result, ray, position, angle) {
                    var from = ray.from;
                    var to = ray.to;
                    var direction = ray.direction;
                    var hitPointWorld = intersectCapsule_hitPointWorld;
                    var normal = intersectCapsule_normal;
                    var l0 = intersectCapsule_l0;
                    var l1 = intersectCapsule_l1;
                    // The sides
                    var halfLen = this.length / 2;
                    for(var i = 0; i < 2; i++){
                        // get start and end of the line
                        var y = this.radius * (i * 2 - 1);
                        vec2.set(l0, -halfLen, y);
                        vec2.set(l1, halfLen, y);
                        vec2.toGlobalFrame(l0, l0, position, angle);
                        vec2.toGlobalFrame(l1, l1, position, angle);
                        var delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);
                        if (delta >= 0) {
                            vec2.rotate(normal, intersectCapsule_unit_y, angle);
                            vec2.scale(normal, normal, i * 2 - 1);
                            ray.reportIntersection(result, delta, normal, -1);
                            if (result.shouldStop(ray)) {
                                return;
                            }
                        }
                    }
                    // Circles
                    var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
                    for(var i = 0; i < 2; i++){
                        vec2.set(l0, halfLen * (i * 2 - 1), 0);
                        vec2.toGlobalFrame(l0, l0, position, angle);
                        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
                        var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
                        var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
                        var delta = Math.pow(b, 2) - 4 * a * c;
                        if (delta < 0) {
                            continue;
                        } else if (delta === 0) {
                            // single intersection point
                            vec2.lerp(hitPointWorld, from, to, delta);
                            if (vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                                vec2.sub(normal, hitPointWorld, l0);
                                vec2.normalize(normal, normal);
                                ray.reportIntersection(result, delta, normal, -1);
                                if (result.shouldStop(ray)) {
                                    return;
                                }
                            }
                        } else {
                            var sqrtDelta = Math.sqrt(delta);
                            var inv2a = 1 / (2 * a);
                            var d1 = (-b - sqrtDelta) * inv2a;
                            var d2 = (-b + sqrtDelta) * inv2a;
                            if (d1 >= 0 && d1 <= 1) {
                                vec2.lerp(hitPointWorld, from, to, d1);
                                if (vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                                    vec2.sub(normal, hitPointWorld, l0);
                                    vec2.normalize(normal, normal);
                                    ray.reportIntersection(result, d1, normal, -1);
                                    if (result.shouldStop(ray)) {
                                        return;
                                    }
                                }
                            }
                            if (d2 >= 0 && d2 <= 1) {
                                vec2.lerp(hitPointWorld, from, to, d2);
                                if (vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                                    vec2.sub(normal, hitPointWorld, l0);
                                    vec2.normalize(normal, normal);
                                    ray.reportIntersection(result, d2, normal, -1);
                                    if (result.shouldStop(ray)) {
                                        return;
                                    }
                                }
                            }
                        }
                    }
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        39: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2');
                module1.exports = Circle;
                /**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {number} [options.radius=1] The radius of this circle
 *
 * @example
 *     var circleShape = new Circle({ radius: 1 });
 *     body.addShape(circleShape);
 */ function Circle(options) {
                    if (typeof arguments[0] === 'number') {
                        options = {
                            radius: arguments[0]
                        };
                        console.warn('The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })');
                    }
                    options = options || {};
                    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */ this.radius = options.radius || 1;
                    options.type = Shape.CIRCLE;
                    Shape.call(this, options);
                }
                Circle.prototype = new Shape();
                Circle.prototype.constructor = Circle;
                /**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */ Circle.prototype.computeMomentOfInertia = function(mass) {
                    var r = this.radius;
                    return mass * r * r / 2;
                };
                /**
 * @method updateBoundingRadius
 * @return {Number}
 */ Circle.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius;
                };
                /**
 * @method updateArea
 * @return {Number}
 */ Circle.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius;
                };
                /**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */ Circle.prototype.computeAABB = function(out, position, angle) {
                    var r = this.radius;
                    vec2.set(out.upperBound, r, r);
                    vec2.set(out.lowerBound, -r, -r);
                    if (position) {
                        vec2.add(out.lowerBound, out.lowerBound, position);
                        vec2.add(out.upperBound, out.upperBound, position);
                    }
                };
                var Ray_intersectSphere_intersectionPoint = vec2.create();
                var Ray_intersectSphere_normal = vec2.create();
                /**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */ Circle.prototype.raycast = function(result, ray, position, angle) {
                    var from = ray.from, to = ray.to, r = this.radius;
                    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
                    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
                    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
                    var delta = Math.pow(b, 2) - 4 * a * c;
                    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
                    var normal = Ray_intersectSphere_normal;
                    if (delta < 0) {
                        // No intersection
                        return;
                    } else if (delta === 0) {
                        // single intersection point
                        vec2.lerp(intersectionPoint, from, to, delta);
                        vec2.sub(normal, intersectionPoint, position);
                        vec2.normalize(normal, normal);
                        ray.reportIntersection(result, delta, normal, -1);
                    } else {
                        var sqrtDelta = Math.sqrt(delta);
                        var inv2a = 1 / (2 * a);
                        var d1 = (-b - sqrtDelta) * inv2a;
                        var d2 = (-b + sqrtDelta) * inv2a;
                        if (d1 >= 0 && d1 <= 1) {
                            vec2.lerp(intersectionPoint, from, to, d1);
                            vec2.sub(normal, intersectionPoint, position);
                            vec2.normalize(normal, normal);
                            ray.reportIntersection(result, d1, normal, -1);
                            if (result.shouldStop(ray)) {
                                return;
                            }
                        }
                        if (d2 >= 0 && d2 <= 1) {
                            vec2.lerp(intersectionPoint, from, to, d2);
                            vec2.sub(normal, intersectionPoint, position);
                            vec2.normalize(normal, normal);
                            ray.reportIntersection(result, d2, normal, -1);
                        }
                    }
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        40: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2'), polyk = _dereq_('../math/polyk'), decomp = _dereq_('poly-decomp');
                module1.exports = Convex;
                /**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [options.axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex({ vertices: vertices });
 *     body.addShape(convexShape);
 */ function Convex(options) {
                    if (Array.isArray(arguments[0])) {
                        options = {
                            vertices: arguments[0],
                            axes: arguments[1]
                        };
                        console.warn('The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })');
                    }
                    options = options || {};
                    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */ this.vertices = [];
                    // Copy the verts
                    var vertices = options.vertices !== undefined ? options.vertices : [];
                    for(var i = 0; i < vertices.length; i++){
                        var v = vec2.create();
                        vec2.copy(v, vertices[i]);
                        this.vertices.push(v);
                    }
                    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */ this.axes = [];
                    if (options.axes) {
                        // Copy the axes
                        for(var i = 0; i < options.axes.length; i++){
                            var axis = vec2.create();
                            vec2.copy(axis, options.axes[i]);
                            this.axes.push(axis);
                        }
                    } else {
                        // Construct axes from the vertex data
                        for(var i = 0; i < this.vertices.length; i++){
                            // Get the world edge
                            var worldPoint0 = this.vertices[i];
                            var worldPoint1 = this.vertices[(i + 1) % this.vertices.length];
                            var normal = vec2.create();
                            vec2.sub(normal, worldPoint1, worldPoint0);
                            // Get normal - just rotate 90 degrees since vertices are given in CCW
                            vec2.rotate90cw(normal, normal);
                            vec2.normalize(normal, normal);
                            this.axes.push(normal);
                        }
                    }
                    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */ this.centerOfMass = vec2.fromValues(0, 0);
                    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */ this.triangles = [];
                    if (this.vertices.length) {
                        this.updateTriangles();
                        this.updateCenterOfMass();
                    }
                    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */ this.boundingRadius = 0;
                    options.type = Shape.CONVEX;
                    Shape.call(this, options);
                    this.updateBoundingRadius();
                    this.updateArea();
                    if (this.area < 0) {
                        throw new Error("Convex vertices must be given in conter-clockwise winding.");
                    }
                }
                Convex.prototype = new Shape();
                Convex.prototype.constructor = Convex;
                var tmpVec1 = vec2.create();
                var tmpVec2 = vec2.create();
                /**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */ Convex.prototype.projectOntoLocalAxis = function(localAxis, result) {
                    var max = null, min = null, v, value, localAxis = tmpVec1;
                    // Get projected position of all vertices
                    for(var i = 0; i < this.vertices.length; i++){
                        v = this.vertices[i];
                        value = vec2.dot(v, localAxis);
                        if (max === null || value > max) {
                            max = value;
                        }
                        if (min === null || value < min) {
                            min = value;
                        }
                    }
                    if (min > max) {
                        var t = min;
                        min = max;
                        max = t;
                    }
                    vec2.set(result, min, max);
                };
                Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result) {
                    var worldAxis = tmpVec2;
                    this.projectOntoLocalAxis(localAxis, result);
                    // Project the position of the body onto the axis - need to add this to the result
                    if (shapeAngle !== 0) {
                        vec2.rotate(worldAxis, localAxis, shapeAngle);
                    } else {
                        worldAxis = localAxis;
                    }
                    var offset = vec2.dot(shapeOffset, worldAxis);
                    vec2.set(result, result[0] + offset, result[1] + offset);
                };
                /**
 * Update the .triangles property
 * @method updateTriangles
 */ Convex.prototype.updateTriangles = function() {
                    this.triangles.length = 0;
                    // Rewrite on polyk notation, array of numbers
                    var polykVerts = [];
                    for(var i = 0; i < this.vertices.length; i++){
                        var v = this.vertices[i];
                        polykVerts.push(v[0], v[1]);
                    }
                    // Triangulate
                    var triangles = polyk.Triangulate(polykVerts);
                    // Loop over all triangles, add their inertia contributions to I
                    for(var i = 0; i < triangles.length; i += 3){
                        var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
                        // Add to triangles
                        this.triangles.push([
                            id1,
                            id2,
                            id3
                        ]);
                    }
                };
                var updateCenterOfMass_centroid = vec2.create(), updateCenterOfMass_centroid_times_mass = vec2.create(), updateCenterOfMass_a = vec2.create(), updateCenterOfMass_b = vec2.create(), updateCenterOfMass_c = vec2.create(), updateCenterOfMass_ac = vec2.create(), updateCenterOfMass_ca = vec2.create(), updateCenterOfMass_cb = vec2.create(), updateCenterOfMass_n = vec2.create();
                /**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */ Convex.prototype.updateCenterOfMass = function() {
                    var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, n = updateCenterOfMass_n, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, ac = updateCenterOfMass_ac, ca = updateCenterOfMass_ca, cb = updateCenterOfMass_cb, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
                    vec2.set(cm, 0, 0);
                    var totalArea = 0;
                    for(var i = 0; i !== triangles.length; i++){
                        var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                        vec2.centroid(centroid, a, b, c);
                        // Get mass for the triangle (density=1 in this case)
                        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
                        var m = Convex.triangleArea(a, b, c);
                        totalArea += m;
                        // Add to center of mass
                        vec2.scale(centroid_times_mass, centroid, m);
                        vec2.add(cm, cm, centroid_times_mass);
                    }
                    vec2.scale(cm, cm, 1 / totalArea);
                };
                /**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */ Convex.prototype.computeMomentOfInertia = function(mass) {
                    var denom = 0.0, numer = 0.0, N = this.vertices.length;
                    for(var j = N - 1, i = 0; i < N; j = i, i++){
                        var p0 = this.vertices[j];
                        var p1 = this.vertices[i];
                        var a = Math.abs(vec2.crossLength(p0, p1));
                        var b = vec2.dot(p1, p1) + vec2.dot(p1, p0) + vec2.dot(p0, p0);
                        denom += a * b;
                        numer += a;
                    }
                    return mass / 6.0 * (denom / numer);
                };
                /**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */ Convex.prototype.updateBoundingRadius = function() {
                    var verts = this.vertices, r2 = 0;
                    for(var i = 0; i !== verts.length; i++){
                        var l2 = vec2.squaredLength(verts[i]);
                        if (l2 > r2) {
                            r2 = l2;
                        }
                    }
                    this.boundingRadius = Math.sqrt(r2);
                };
                /**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */ Convex.triangleArea = function(a, b, c) {
                    return ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])) * 0.5;
                };
                /**
 * Update the .area
 * @method updateArea
 */ Convex.prototype.updateArea = function() {
                    this.updateTriangles();
                    this.area = 0;
                    var triangles = this.triangles, verts = this.vertices;
                    for(var i = 0; i !== triangles.length; i++){
                        var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                        // Get mass for the triangle (density=1 in this case)
                        var m = Convex.triangleArea(a, b, c);
                        this.area += m;
                    }
                };
                /**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */ Convex.prototype.computeAABB = function(out, position, angle) {
                    out.setFromPoints(this.vertices, position, angle, 0);
                };
                var intersectConvex_rayStart = vec2.create();
                var intersectConvex_rayEnd = vec2.create();
                var intersectConvex_normal = vec2.create();
                /**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */ Convex.prototype.raycast = function(result, ray, position, angle) {
                    var rayStart = intersectConvex_rayStart;
                    var rayEnd = intersectConvex_rayEnd;
                    var normal = intersectConvex_normal;
                    var vertices = this.vertices;
                    // Transform to local shape space
                    vec2.toLocalFrame(rayStart, ray.from, position, angle);
                    vec2.toLocalFrame(rayEnd, ray.to, position, angle);
                    var n = vertices.length;
                    for(var i = 0; i < n && !result.shouldStop(ray); i++){
                        var q1 = vertices[i];
                        var q2 = vertices[(i + 1) % n];
                        var delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
                        if (delta >= 0) {
                            vec2.sub(normal, q2, q1);
                            vec2.rotate(normal, normal, -Math.PI / 2 + angle);
                            vec2.normalize(normal, normal);
                            ray.reportIntersection(result, delta, normal, i);
                        }
                    }
                };
            },
            {
                "../math/polyk": 29,
                "../math/vec2": 30,
                "./Shape": 45,
                "poly-decomp": 5
            }
        ],
        41: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2'), Utils = _dereq_('../utils/Utils');
                module1.exports = Heightfield;
                /**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 *
 * @example
 *     // Generate some height data (y-values).
 *     var heights = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         heights.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield({
 *         heights: heights,
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 *
 * @todo Should use a scale property with X and Y direction instead of just elementWidth
 */ function Heightfield(options) {
                    if (Array.isArray(arguments[0])) {
                        options = {
                            heights: arguments[0]
                        };
                        if (typeof arguments[1] === 'object') {
                            for(var key in arguments[1]){
                                options[key] = arguments[1][key];
                            }
                        }
                        console.warn('The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })');
                    }
                    options = options || {};
                    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} heights
     */ this.heights = options.heights ? options.heights.slice(0) : [];
                    /**
     * Max value of the heights
     * @property {number} maxValue
     */ this.maxValue = options.maxValue || null;
                    /**
     * Max value of the heights
     * @property {number} minValue
     */ this.minValue = options.minValue || null;
                    /**
     * The width of each element
     * @property {number} elementWidth
     */ this.elementWidth = options.elementWidth || 0.1;
                    if (options.maxValue === undefined || options.minValue === undefined) {
                        this.updateMaxMinValues();
                    }
                    options.type = Shape.HEIGHTFIELD;
                    Shape.call(this, options);
                }
                Heightfield.prototype = new Shape();
                Heightfield.prototype.constructor = Heightfield;
                /**
 * Update the .minValue and the .maxValue
 * @method updateMaxMinValues
 */ Heightfield.prototype.updateMaxMinValues = function() {
                    var data = this.heights;
                    var maxValue = data[0];
                    var minValue = data[0];
                    for(var i = 0; i !== data.length; i++){
                        var v = data[i];
                        if (v > maxValue) {
                            maxValue = v;
                        }
                        if (v < minValue) {
                            minValue = v;
                        }
                    }
                    this.maxValue = maxValue;
                    this.minValue = minValue;
                };
                /**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */ Heightfield.prototype.computeMomentOfInertia = function(mass) {
                    return Number.MAX_VALUE;
                };
                Heightfield.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE;
                };
                Heightfield.prototype.updateArea = function() {
                    var data = this.heights, area = 0;
                    for(var i = 0; i < data.length - 1; i++){
                        area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
                    }
                    this.area = area;
                };
                var points = [
                    vec2.create(),
                    vec2.create(),
                    vec2.create(),
                    vec2.create()
                ];
                /**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */ Heightfield.prototype.computeAABB = function(out, position, angle) {
                    vec2.set(points[0], 0, this.maxValue);
                    vec2.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
                    vec2.set(points[2], this.elementWidth * this.heights.length, this.minValue);
                    vec2.set(points[3], 0, this.minValue);
                    out.setFromPoints(points, position, angle);
                };
                /**
 * Get a line segment in the heightfield
 * @method getLineSegment
 * @param  {array} start Where to store the resulting start point
 * @param  {array} end Where to store the resulting end point
 * @param  {number} i
 */ Heightfield.prototype.getLineSegment = function(start, end, i) {
                    var data = this.heights;
                    var width = this.elementWidth;
                    vec2.set(start, i * width, data[i]);
                    vec2.set(end, (i + 1) * width, data[i + 1]);
                };
                Heightfield.prototype.getSegmentIndex = function(position) {
                    return Math.floor(position[0] / this.elementWidth);
                };
                Heightfield.prototype.getClampedSegmentIndex = function(position) {
                    var i = this.getSegmentIndex(position);
                    i = Math.min(this.heights.length, Math.max(i, 0)); // clamp
                    return i;
                };
                var intersectHeightfield_hitPointWorld = vec2.create();
                var intersectHeightfield_worldNormal = vec2.create();
                var intersectHeightfield_l0 = vec2.create();
                var intersectHeightfield_l1 = vec2.create();
                var intersectHeightfield_localFrom = vec2.create();
                var intersectHeightfield_localTo = vec2.create();
                var intersectHeightfield_unit_y = vec2.fromValues(0, 1);
                // Returns 1 if the lines intersect, otherwise 0.
                function getLineSegmentsIntersection(out, p0, p1, p2, p3) {
                    var s1_x, s1_y, s2_x, s2_y;
                    s1_x = p1[0] - p0[0];
                    s1_y = p1[1] - p0[1];
                    s2_x = p3[0] - p2[0];
                    s2_y = p3[1] - p2[1];
                    var s, t;
                    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
                    t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
                    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                        var intX = p0[0] + t * s1_x;
                        var intY = p0[1] + t * s1_y;
                        out[0] = intX;
                        out[1] = intY;
                        return t;
                    }
                    return -1; // No collision
                }
                /**
 * @method raycast
 * @param  {RayResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */ Heightfield.prototype.raycast = function(result, ray, position, angle) {
                    var from = ray.from;
                    var to = ray.to;
                    var direction = ray.direction;
                    var hitPointWorld = intersectHeightfield_hitPointWorld;
                    var worldNormal = intersectHeightfield_worldNormal;
                    var l0 = intersectHeightfield_l0;
                    var l1 = intersectHeightfield_l1;
                    var localFrom = intersectHeightfield_localFrom;
                    var localTo = intersectHeightfield_localTo;
                    // get local ray start and end
                    vec2.toLocalFrame(localFrom, from, position, angle);
                    vec2.toLocalFrame(localTo, to, position, angle);
                    // Get the segment range
                    var i0 = this.getClampedSegmentIndex(localFrom);
                    var i1 = this.getClampedSegmentIndex(localTo);
                    if (i0 > i1) {
                        var tmp = i0;
                        i0 = i1;
                        i1 = tmp;
                    }
                    // The segments
                    for(var i = 0; i < this.heights.length - 1; i++){
                        this.getLineSegment(l0, l1, i);
                        var t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
                        if (t >= 0) {
                            vec2.sub(worldNormal, l1, l0);
                            vec2.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
                            vec2.normalize(worldNormal, worldNormal);
                            ray.reportIntersection(result, t, worldNormal, -1);
                            if (result.shouldStop(ray)) {
                                return;
                            }
                        }
                    }
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }
        ],
        42: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2');
                module1.exports = Line;
                /**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Number} [options.length=1] The total length of the line
 * @extends Shape
 * @constructor
 */ function Line(options) {
                    if (typeof arguments[0] === 'number') {
                        options = {
                            length: arguments[0]
                        };
                        console.warn('The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })');
                    }
                    options = options || {};
                    /**
     * Length of this line
     * @property {Number} length
     * @default 1
     */ this.length = options.length || 1;
                    options.type = Shape.LINE;
                    Shape.call(this, options);
                }
                Line.prototype = new Shape();
                Line.prototype.constructor = Line;
                Line.prototype.computeMomentOfInertia = function(mass) {
                    return mass * Math.pow(this.length, 2) / 12;
                };
                Line.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.length / 2;
                };
                var points = [
                    vec2.create(),
                    vec2.create()
                ];
                /**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */ Line.prototype.computeAABB = function(out, position, angle) {
                    var l2 = this.length / 2;
                    vec2.set(points[0], -l2, 0);
                    vec2.set(points[1], l2, 0);
                    out.setFromPoints(points, position, angle, 0);
                };
                var raycast_hitPoint = vec2.create();
                var raycast_normal = vec2.create();
                var raycast_l0 = vec2.create();
                var raycast_l1 = vec2.create();
                var raycast_unit_y = vec2.fromValues(0, 1);
                /**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {number} angle
 * @param  {array} position
 */ Line.prototype.raycast = function(result, ray, position, angle) {
                    var from = ray.from;
                    var to = ray.to;
                    var l0 = raycast_l0;
                    var l1 = raycast_l1;
                    // get start and end of the line
                    var halfLen = this.length / 2;
                    vec2.set(l0, -halfLen, 0);
                    vec2.set(l1, halfLen, 0);
                    vec2.toGlobalFrame(l0, l0, position, angle);
                    vec2.toGlobalFrame(l1, l1, position, angle);
                    var fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);
                    if (fraction >= 0) {
                        var normal = raycast_normal;
                        vec2.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from
                        ray.reportIntersection(result, fraction, normal, -1);
                    }
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        43: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2');
                module1.exports = Particle;
                /**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @extends Shape
 */ function Particle(options) {
                    options = options || {};
                    options.type = Shape.PARTICLE;
                    Shape.call(this, options);
                }
                Particle.prototype = new Shape();
                Particle.prototype.constructor = Particle;
                Particle.prototype.computeMomentOfInertia = function(mass) {
                    return 0; // Can't rotate a particle
                };
                Particle.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = 0;
                };
                /**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */ Particle.prototype.computeAABB = function(out, position, angle) {
                    vec2.copy(out.lowerBound, position);
                    vec2.copy(out.upperBound, position);
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        44: [
            function(_dereq_, module1, exports1) {
                var Shape = _dereq_('./Shape'), vec2 = _dereq_('../math/vec2'), Utils = _dereq_('../utils/Utils');
                module1.exports = Plane;
                /**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 */ function Plane(options) {
                    options = options || {};
                    options.type = Shape.PLANE;
                    Shape.call(this, options);
                }
                Plane.prototype = new Shape();
                Plane.prototype.constructor = Plane;
                /**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */ Plane.prototype.computeMomentOfInertia = function(mass) {
                    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
                };
                /**
 * Update the bounding radius
 * @method updateBoundingRadius
 */ Plane.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE;
                };
                /**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */ Plane.prototype.computeAABB = function(out, position, angle) {
                    var a = angle % (2 * Math.PI);
                    var set = vec2.set;
                    var max = 1e7;
                    var lowerBound = out.lowerBound;
                    var upperBound = out.upperBound;
                    // Set max bounds
                    set(lowerBound, -max, -max);
                    set(upperBound, max, max);
                    if (a === 0) {
                        // y goes from -inf to 0
                        upperBound[1] = 0;
                    // set(lowerBound, -max, -max);
                    // set(upperBound,  max,  0);
                    } else if (a === Math.PI / 2) {
                        // x goes from 0 to inf
                        lowerBound[0] = 0;
                    // set(lowerBound, 0, -max);
                    // set(upperBound,      max,  max);
                    } else if (a === Math.PI) {
                        // y goes from 0 to inf
                        lowerBound[1] = 0;
                    // set(lowerBound, -max, 0);
                    // set(upperBound,  max, max);
                    } else if (a === 3 * Math.PI / 2) {
                        // x goes from -inf to 0
                        upperBound[0] = 0;
                    // set(lowerBound, -max,     -max);
                    // set(upperBound,  0,  max);
                    }
                };
                Plane.prototype.updateArea = function() {
                    this.area = Number.MAX_VALUE;
                };
                var intersectPlane_planePointToFrom = vec2.create();
                var intersectPlane_dir_scaled_with_t = vec2.create();
                var intersectPlane_hitPoint = vec2.create();
                var intersectPlane_normal = vec2.create();
                var intersectPlane_len = vec2.create();
                /**
 * @method raycast
 * @param  {RayResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */ Plane.prototype.raycast = function(result, ray, position, angle) {
                    var from = ray.from;
                    var to = ray.to;
                    var direction = ray.direction;
                    var planePointToFrom = intersectPlane_planePointToFrom;
                    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
                    var hitPoint = intersectPlane_hitPoint;
                    var normal = intersectPlane_normal;
                    var len = intersectPlane_len;
                    // Get plane normal
                    vec2.set(normal, 0, 1);
                    vec2.rotate(normal, normal, angle);
                    vec2.sub(len, from, position);
                    var planeToFrom = vec2.dot(len, normal);
                    vec2.sub(len, to, position);
                    var planeToTo = vec2.dot(len, normal);
                    if (planeToFrom * planeToTo > 0) {
                        // "from" and "to" are on the same side of the plane... bail out
                        return;
                    }
                    if (vec2.squaredDistance(from, to) < planeToFrom * planeToFrom) {
                        return;
                    }
                    var n_dot_dir = vec2.dot(normal, direction);
                    vec2.sub(planePointToFrom, from, position);
                    var t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;
                    ray.reportIntersection(result, t, normal, -1);
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }
        ],
        45: [
            function(_dereq_, module1, exports1) {
                module1.exports = Shape;
                var vec2 = _dereq_('../math/vec2');
                /**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {object} [options]
 * @param {array} [options.position]
 * @param {number} [options.angle=0]
 * @param {number} [options.collisionGroup=1]
 * @param {number} [options.collisionMask=1]
 * @param {boolean} [options.sensor=false]
 * @param {boolean} [options.collisionResponse=true]
 * @param {object} [options.type=0]
 */ function Shape(options) {
                    options = options || {};
                    /**
     * The body this shape is attached to. A shape can only be attached to a single body.
     * @property {Body} body
     */ this.body = null;
                    /**
     * Body-local position of the shape.
     * @property {Array} position
     */ this.position = vec2.fromValues(0, 0);
                    if (options.position) {
                        vec2.copy(this.position, options.position);
                    }
                    /**
     * Body-local angle of the shape.
     * @property {number} angle
     */ this.angle = options.angle || 0;
                    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/BOX:property"}}Shape.BOX{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */ this.type = options.type || 0;
                    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */ this.id = Shape.idCounter++;
                    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */ this.boundingRadius = 0;
                    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */ this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : 1;
                    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */ this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;
                    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */ this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : 1;
                    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */ this.material = options.material || null;
                    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */ this.area = 0;
                    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */ this.sensor = options.sensor !== undefined ? options.sensor : false;
                    if (this.type) {
                        this.updateBoundingRadius();
                    }
                    this.updateArea();
                }
                Shape.idCounter = 0;
                /**
 * @static
 * @property {Number} CIRCLE
 */ Shape.CIRCLE = 1;
                /**
 * @static
 * @property {Number} PARTICLE
 */ Shape.PARTICLE = 2;
                /**
 * @static
 * @property {Number} PLANE
 */ Shape.PLANE = 4;
                /**
 * @static
 * @property {Number} CONVEX
 */ Shape.CONVEX = 8;
                /**
 * @static
 * @property {Number} LINE
 */ Shape.LINE = 16;
                /**
 * @static
 * @property {Number} BOX
 */ Shape.BOX = 32;
                Object.defineProperty(Shape, 'RECTANGLE', {
                    get: function() {
                        console.warn('Shape.RECTANGLE is deprecated, use Shape.BOX instead.');
                        return Shape.BOX;
                    }
                });
                /**
 * @static
 * @property {Number} CAPSULE
 */ Shape.CAPSULE = 64;
                /**
 * @static
 * @property {Number} HEIGHTFIELD
 */ Shape.HEIGHTFIELD = 128;
                /**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */ Shape.prototype.computeMomentOfInertia = function(mass) {};
                /**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */ Shape.prototype.updateBoundingRadius = function() {};
                /**
 * Update the .area property of the shape.
 * @method updateArea
 */ Shape.prototype.updateArea = function() {
                // To be implemented in all subclasses
                };
                /**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB} out The resulting AABB.
 * @param  {Array} position World position of the shape.
 * @param  {Number} angle World angle of the shape.
 */ Shape.prototype.computeAABB = function(out, position, angle) {
                // To be implemented in each subclass
                };
                /**
 * Perform raycasting on this shape.
 * @method raycast
 * @param  {RayResult} result Where to store the resulting data.
 * @param  {Ray} ray The Ray that you want to use for raycasting.
 * @param  {array} position World position of the shape (the .position property will be ignored).
 * @param  {number} angle World angle of the shape (the .angle property will be ignored).
 */ Shape.prototype.raycast = function(result, ray, position, angle) {
                // To be implemented in each subclass
                };
            },
            {
                "../math/vec2": 30
            }
        ],
        46: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), Solver = _dereq_('./Solver'), Utils = _dereq_('../utils/Utils'), FrictionEquation = _dereq_('../equations/FrictionEquation');
                module1.exports = GSSolver;
                /**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */ function GSSolver(options) {
                    Solver.call(this, options, Solver.GS);
                    options = options || {};
                    /**
     * The max number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */ this.iterations = options.iterations || 10;
                    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     * @default 1e-7
     */ this.tolerance = options.tolerance || 1e-7;
                    this.arrayStep = 30;
                    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
                    this.Bs = new Utils.ARRAY_TYPE(this.arrayStep);
                    this.invCs = new Utils.ARRAY_TYPE(this.arrayStep);
                    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     * @todo Remove, not used
     */ this.useZeroRHS = false;
                    /**
     * Number of solver iterations that are used to approximate normal forces used for friction (F_friction = mu * F_normal). These friction forces will override any other friction forces that are set. If you set frictionIterations = 0, then this feature will be disabled.
     *
     * Use only frictionIterations > 0 if the approximated normal force (F_normal = mass * gravity) is not good enough. Examples of where it can happen is in space games where gravity is zero, or in tall stacks where the normal force is large at bottom but small at top.
     *
     * @property frictionIterations
     * @type {Number}
     * @default 0
     */ this.frictionIterations = options.frictionIterations !== undefined ? 0 : options.frictionIterations;
                    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */ this.usedIterations = 0;
                }
                GSSolver.prototype = new Solver();
                GSSolver.prototype.constructor = GSSolver;
                function setArrayZero(array) {
                    var l = array.length;
                    while(l--){
                        array[l] = +0.0;
                    }
                }
                /**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */ GSSolver.prototype.solve = function(h, world) {
                    this.sortEquations();
                    var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = world.bodies.length, add = vec2.add, set = vec2.set, useZeroRHS = this.useZeroRHS, lambda = this.lambda;
                    this.usedIterations = 0;
                    if (Neq) {
                        for(var i = 0; i !== Nbodies; i++){
                            var b = bodies[i];
                            // Update solve mass
                            b.updateSolveMassProperties();
                        }
                    }
                    // Things that does not change during iteration can be computed once
                    if (lambda.length < Neq) {
                        lambda = this.lambda = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                        this.Bs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                        this.invCs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    }
                    setArrayZero(lambda);
                    var invCs = this.invCs, Bs = this.Bs, lambda = this.lambda;
                    for(var i = 0; i !== equations.length; i++){
                        var c = equations[i];
                        if (c.timeStep !== h || c.needsUpdate) {
                            c.timeStep = h;
                            c.update();
                        }
                        Bs[i] = c.computeB(c.a, c.b, h);
                        invCs[i] = c.computeInvC(c.epsilon);
                    }
                    var q, B, c, deltalambdaTot, i, j;
                    if (Neq !== 0) {
                        for(i = 0; i !== Nbodies; i++){
                            var b = bodies[i];
                            // Reset vlambda
                            b.resetConstraintVelocity();
                        }
                        if (maxFrictionIter) {
                            // Iterate over contact equations to get normal forces
                            for(iter = 0; iter !== maxFrictionIter; iter++){
                                // Accumulate the total error for each iteration.
                                deltalambdaTot = 0.0;
                                for(j = 0; j !== Neq; j++){
                                    c = equations[j];
                                    var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                                    deltalambdaTot += Math.abs(deltalambda);
                                }
                                this.usedIterations++;
                                // If the total error is small enough - stop iterate
                                if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                                    break;
                                }
                            }
                            GSSolver.updateMultipliers(equations, lambda, 1 / h);
                            // Set computed friction force
                            for(j = 0; j !== Neq; j++){
                                var eq = equations[j];
                                if (eq instanceof FrictionEquation) {
                                    var f = 0.0;
                                    for(var k = 0; k !== eq.contactEquations.length; k++){
                                        f += eq.contactEquations[k].multiplier;
                                    }
                                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                                    eq.maxForce = f;
                                    eq.minForce = -f;
                                }
                            }
                        }
                        // Iterate over all equations
                        for(iter = 0; iter !== maxIter; iter++){
                            // Accumulate the total error for each iteration.
                            deltalambdaTot = 0.0;
                            for(j = 0; j !== Neq; j++){
                                c = equations[j];
                                var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                                deltalambdaTot += Math.abs(deltalambda);
                            }
                            this.usedIterations++;
                            // If the total error is small enough - stop iterate
                            if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                                break;
                            }
                        }
                        // Add result to velocity
                        for(i = 0; i !== Nbodies; i++){
                            bodies[i].addConstraintVelocity();
                        }
                        GSSolver.updateMultipliers(equations, lambda, 1 / h);
                    }
                };
                // Sets the .multiplier property of each equation
                GSSolver.updateMultipliers = function(equations, lambda, invDt) {
                    // Set the .multiplier property of each equation
                    var l = equations.length;
                    while(l--){
                        equations[l].multiplier = lambda[l] * invDt;
                    }
                };
                GSSolver.iterateEquation = function(j, eq, eps, Bs, invCs, lambda, useZeroRHS, dt, iter) {
                    // Compute iteration
                    var B = Bs[j], invC = invCs[j], lambdaj = lambda[j], GWlambda = eq.computeGWlambda();
                    var maxForce = eq.maxForce, minForce = eq.minForce;
                    if (useZeroRHS) {
                        B = 0;
                    }
                    var deltalambda = invC * (B - GWlambda - eps * lambdaj);
                    // Clamp if we are not within the min/max interval
                    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
                    if (lambdaj_plus_deltalambda < minForce * dt) {
                        deltalambda = minForce * dt - lambdaj;
                    } else if (lambdaj_plus_deltalambda > maxForce * dt) {
                        deltalambda = maxForce * dt - lambdaj;
                    }
                    lambda[j] += deltalambda;
                    eq.addToWlambda(deltalambda);
                    return deltalambda;
                };
            },
            {
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Solver": 47
            }
        ],
        47: [
            function(_dereq_, module1, exports1) {
                var Utils = _dereq_('../utils/Utils'), EventEmitter = _dereq_('../events/EventEmitter');
                module1.exports = Solver;
                /**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */ function Solver(options, type) {
                    options = options || {};
                    EventEmitter.call(this);
                    this.type = type;
                    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */ this.equations = [];
                    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */ this.equationSortFunction = options.equationSortFunction || false;
                }
                Solver.prototype = new EventEmitter();
                Solver.prototype.constructor = Solver;
                /**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */ Solver.prototype.solve = function(dt, world) {
                    throw new Error("Solver.solve should be implemented by subclasses!");
                };
                var mockWorld = {
                    bodies: []
                };
                /**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */ Solver.prototype.solveIsland = function(dt, island) {
                    this.removeAllEquations();
                    if (island.equations.length) {
                        // Add equations to solver
                        this.addEquations(island.equations);
                        mockWorld.bodies.length = 0;
                        island.getBodies(mockWorld.bodies);
                        // Solve
                        if (mockWorld.bodies.length) {
                            this.solve(dt, mockWorld);
                        }
                    }
                };
                /**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */ Solver.prototype.sortEquations = function() {
                    if (this.equationSortFunction) {
                        this.equations.sort(this.equationSortFunction);
                    }
                };
                /**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */ Solver.prototype.addEquation = function(eq) {
                    if (eq.enabled) {
                        this.equations.push(eq);
                    }
                };
                /**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */ Solver.prototype.addEquations = function(eqs) {
                    //Utils.appendArray(this.equations,eqs);
                    for(var i = 0, N = eqs.length; i !== N; i++){
                        var eq = eqs[i];
                        if (eq.enabled) {
                            this.equations.push(eq);
                        }
                    }
                };
                /**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */ Solver.prototype.removeEquation = function(eq) {
                    var i = this.equations.indexOf(eq);
                    if (i !== -1) {
                        this.equations.splice(i, 1);
                    }
                };
                /**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */ Solver.prototype.removeAllEquations = function() {
                    this.equations.length = 0;
                };
                Solver.GS = 1;
                Solver.ISLAND = 2;
            },
            {
                "../events/EventEmitter": 26,
                "../utils/Utils": 57
            }
        ],
        48: [
            function(_dereq_, module1, exports1) {
                var ContactEquation = _dereq_('../equations/ContactEquation');
                var Pool = _dereq_('./Pool');
                module1.exports = ContactEquationPool;
                /**
 * @class
 */ function ContactEquationPool() {
                    Pool.apply(this, arguments);
                }
                ContactEquationPool.prototype = new Pool();
                ContactEquationPool.prototype.constructor = ContactEquationPool;
                /**
 * @method create
 * @return {ContactEquation}
 */ ContactEquationPool.prototype.create = function() {
                    return new ContactEquation();
                };
                /**
 * @method destroy
 * @param {ContactEquation} equation
 * @return {ContactEquationPool}
 */ ContactEquationPool.prototype.destroy = function(equation) {
                    equation.bodyA = equation.bodyB = null;
                    return this;
                };
            },
            {
                "../equations/ContactEquation": 21,
                "./Pool": 55
            }
        ],
        49: [
            function(_dereq_, module1, exports1) {
                var FrictionEquation = _dereq_('../equations/FrictionEquation');
                var Pool = _dereq_('./Pool');
                module1.exports = FrictionEquationPool;
                /**
 * @class
 */ function FrictionEquationPool() {
                    Pool.apply(this, arguments);
                }
                FrictionEquationPool.prototype = new Pool();
                FrictionEquationPool.prototype.constructor = FrictionEquationPool;
                /**
 * @method create
 * @return {FrictionEquation}
 */ FrictionEquationPool.prototype.create = function() {
                    return new FrictionEquation();
                };
                /**
 * @method destroy
 * @param {FrictionEquation} equation
 * @return {FrictionEquationPool}
 */ FrictionEquationPool.prototype.destroy = function(equation) {
                    equation.bodyA = equation.bodyB = null;
                    return this;
                };
            },
            {
                "../equations/FrictionEquation": 23,
                "./Pool": 55
            }
        ],
        50: [
            function(_dereq_, module1, exports1) {
                var IslandNode = _dereq_('../world/IslandNode');
                var Pool = _dereq_('./Pool');
                module1.exports = IslandNodePool;
                /**
 * @class
 */ function IslandNodePool() {
                    Pool.apply(this, arguments);
                }
                IslandNodePool.prototype = new Pool();
                IslandNodePool.prototype.constructor = IslandNodePool;
                /**
 * @method create
 * @return {IslandNode}
 */ IslandNodePool.prototype.create = function() {
                    return new IslandNode();
                };
                /**
 * @method destroy
 * @param {IslandNode} node
 * @return {IslandNodePool}
 */ IslandNodePool.prototype.destroy = function(node) {
                    node.reset();
                    return this;
                };
            },
            {
                "../world/IslandNode": 60,
                "./Pool": 55
            }
        ],
        51: [
            function(_dereq_, module1, exports1) {
                var Island = _dereq_('../world/Island');
                var Pool = _dereq_('./Pool');
                module1.exports = IslandPool;
                /**
 * @class
 */ function IslandPool() {
                    Pool.apply(this, arguments);
                }
                IslandPool.prototype = new Pool();
                IslandPool.prototype.constructor = IslandPool;
                /**
 * @method create
 * @return {Island}
 */ IslandPool.prototype.create = function() {
                    return new Island();
                };
                /**
 * @method destroy
 * @param {Island} island
 * @return {IslandPool}
 */ IslandPool.prototype.destroy = function(island) {
                    island.reset();
                    return this;
                };
            },
            {
                "../world/Island": 58,
                "./Pool": 55
            }
        ],
        52: [
            function(_dereq_, module1, exports1) {
                var TupleDictionary = _dereq_('./TupleDictionary');
                var OverlapKeeperRecord = _dereq_('./OverlapKeeperRecord');
                var OverlapKeeperRecordPool = _dereq_('./OverlapKeeperRecordPool');
                var Utils = _dereq_('./Utils');
                module1.exports = OverlapKeeper;
                /**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */ function OverlapKeeper() {
                    this.overlappingShapesLastState = new TupleDictionary();
                    this.overlappingShapesCurrentState = new TupleDictionary();
                    this.recordPool = new OverlapKeeperRecordPool({
                        size: 16
                    });
                    this.tmpDict = new TupleDictionary();
                    this.tmpArray1 = [];
                }
                /**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */ OverlapKeeper.prototype.tick = function() {
                    var last = this.overlappingShapesLastState;
                    var current = this.overlappingShapesCurrentState;
                    // Save old objects into pool
                    var l = last.keys.length;
                    while(l--){
                        var key = last.keys[l];
                        var lastObject = last.getByKey(key);
                        var currentObject = current.getByKey(key);
                        if (lastObject) {
                            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
                            this.recordPool.release(lastObject);
                        }
                    }
                    // Clear last object
                    last.reset();
                    // Transfer from new object to old
                    last.copy(current);
                    // Clear current object
                    current.reset();
                };
                /**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */ OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
                    var last = this.overlappingShapesLastState;
                    var current = this.overlappingShapesCurrentState;
                    // Store current contact state
                    if (!current.get(shapeA.id, shapeB.id)) {
                        var data = this.recordPool.get();
                        data.set(bodyA, shapeA, bodyB, shapeB);
                        current.set(shapeA.id, shapeB.id, data);
                    }
                };
                OverlapKeeper.prototype.getNewOverlaps = function(result) {
                    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
                };
                OverlapKeeper.prototype.getEndOverlaps = function(result) {
                    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
                };
                /**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */ OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB) {
                    var current = this.overlappingShapesCurrentState;
                    var l = current.keys.length;
                    while(l--){
                        var key = current.keys[l];
                        var data = current.data[key];
                        if (data.bodyA === bodyA && data.bodyB === bodyB || data.bodyA === bodyB && data.bodyB === bodyA) {
                            return true;
                        }
                    }
                    return false;
                };
                OverlapKeeper.prototype.getDiff = function(dictA, dictB, result) {
                    var result = result || [];
                    var last = dictA;
                    var current = dictB;
                    result.length = 0;
                    var l = current.keys.length;
                    while(l--){
                        var key = current.keys[l];
                        var data = current.data[key];
                        if (!data) {
                            throw new Error('Key ' + key + ' had no data!');
                        }
                        var lastData = last.data[key];
                        if (!lastData) {
                            // Not overlapping in last state, but in current.
                            result.push(data);
                        }
                    }
                    return result;
                };
                OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB) {
                    var idA = shapeA.id | 0, idB = shapeB.id | 0;
                    var last = this.overlappingShapesLastState;
                    var current = this.overlappingShapesCurrentState;
                    // Not in last but in new
                    return !!!last.get(idA, idB) && !!current.get(idA, idB);
                };
                OverlapKeeper.prototype.getNewBodyOverlaps = function(result) {
                    this.tmpArray1.length = 0;
                    var overlaps = this.getNewOverlaps(this.tmpArray1);
                    return this.getBodyDiff(overlaps, result);
                };
                OverlapKeeper.prototype.getEndBodyOverlaps = function(result) {
                    this.tmpArray1.length = 0;
                    var overlaps = this.getEndOverlaps(this.tmpArray1);
                    return this.getBodyDiff(overlaps, result);
                };
                OverlapKeeper.prototype.getBodyDiff = function(overlaps, result) {
                    result = result || [];
                    var accumulator = this.tmpDict;
                    var l = overlaps.length;
                    while(l--){
                        var data = overlaps[l];
                        // Since we use body id's for the accumulator, these will be a subset of the original one
                        accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
                    }
                    l = accumulator.keys.length;
                    while(l--){
                        var data = accumulator.getByKey(accumulator.keys[l]);
                        if (data) {
                            result.push(data.bodyA, data.bodyB);
                        }
                    }
                    accumulator.reset();
                    return result;
                };
            },
            {
                "./OverlapKeeperRecord": 53,
                "./OverlapKeeperRecordPool": 54,
                "./TupleDictionary": 56,
                "./Utils": 57
            }
        ],
        53: [
            function(_dereq_, module1, exports1) {
                module1.exports = OverlapKeeperRecord;
                /**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */ function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
                    /**
     * @property {Shape} shapeA
     */ this.shapeA = shapeA;
                    /**
     * @property {Shape} shapeB
     */ this.shapeB = shapeB;
                    /**
     * @property {Body} bodyA
     */ this.bodyA = bodyA;
                    /**
     * @property {Body} bodyB
     */ this.bodyB = bodyB;
                }
                /**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */ OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB) {
                    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
                };
            },
            {}
        ],
        54: [
            function(_dereq_, module1, exports1) {
                var OverlapKeeperRecord = _dereq_('./OverlapKeeperRecord');
                var Pool = _dereq_('./Pool');
                module1.exports = OverlapKeeperRecordPool;
                /**
 * @class
 */ function OverlapKeeperRecordPool() {
                    Pool.apply(this, arguments);
                }
                OverlapKeeperRecordPool.prototype = new Pool();
                OverlapKeeperRecordPool.prototype.constructor = OverlapKeeperRecordPool;
                /**
 * @method create
 * @return {OverlapKeeperRecord}
 */ OverlapKeeperRecordPool.prototype.create = function() {
                    return new OverlapKeeperRecord();
                };
                /**
 * @method destroy
 * @param {OverlapKeeperRecord} record
 * @return {OverlapKeeperRecordPool}
 */ OverlapKeeperRecordPool.prototype.destroy = function(record) {
                    record.bodyA = record.bodyB = record.shapeA = record.shapeB = null;
                    return this;
                };
            },
            {
                "./OverlapKeeperRecord": 53,
                "./Pool": 55
            }
        ],
        55: [
            function(_dereq_, module1, exports1) {
                module1.exports = Pool;
                /**
 * @class Object pooling utility.
 */ function Pool(options) {
                    options = options || {};
                    /**
	 * @property {Array} objects
	 * @type {Array}
	 */ this.objects = [];
                    if (options.size !== undefined) {
                        this.resize(options.size);
                    }
                }
                /**
 * @method resize
 * @param {number} size
 * @return {Pool} Self, for chaining
 */ Pool.prototype.resize = function(size) {
                    var objects = this.objects;
                    while(objects.length > size){
                        objects.pop();
                    }
                    while(objects.length < size){
                        objects.push(this.create());
                    }
                    return this;
                };
                /**
 * Get an object from the pool or create a new instance.
 * @method get
 * @return {Object}
 */ Pool.prototype.get = function() {
                    var objects = this.objects;
                    return objects.length ? objects.pop() : this.create();
                };
                /**
 * Clean up and put the object back into the pool for later use.
 * @method release
 * @param {Object} object
 * @return {Pool} Self for chaining
 */ Pool.prototype.release = function(object) {
                    this.destroy(object);
                    this.objects.push(object);
                    return this;
                };
            },
            {}
        ],
        56: [
            function(_dereq_, module1, exports1) {
                var Utils = _dereq_('./Utils');
                module1.exports = TupleDictionary;
                /**
 * @class TupleDictionary
 * @constructor
 */ function TupleDictionary() {
                    /**
     * The data storage
     * @property data
     * @type {Object}
     */ this.data = {};
                    /**
     * Keys that are currently used.
     * @property {Array} keys
     */ this.keys = [];
                }
                /**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */ TupleDictionary.prototype.getKey = function(id1, id2) {
                    id1 = id1 | 0;
                    id2 = id2 | 0;
                    if ((id1 | 0) === (id2 | 0)) {
                        return -1;
                    }
                    // valid for values < 2^16
                    return ((id1 | 0) > (id2 | 0) ? id1 << 16 | id2 & 0xFFFF : id2 << 16 | id1 & 0xFFFF) | 0;
                };
                /**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */ TupleDictionary.prototype.getByKey = function(key) {
                    key = key | 0;
                    return this.data[key];
                };
                /**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */ TupleDictionary.prototype.get = function(i, j) {
                    return this.data[this.getKey(i, j)];
                };
                /**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */ TupleDictionary.prototype.set = function(i, j, value) {
                    if (!value) {
                        throw new Error("No data!");
                    }
                    var key = this.getKey(i, j);
                    // Check if key already exists
                    if (!this.data[key]) {
                        this.keys.push(key);
                    }
                    this.data[key] = value;
                    return key;
                };
                /**
 * Remove all data.
 * @method reset
 */ TupleDictionary.prototype.reset = function() {
                    var data = this.data, keys = this.keys;
                    var l = keys.length;
                    while(l--){
                        delete data[keys[l]];
                    }
                    keys.length = 0;
                };
                /**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */ TupleDictionary.prototype.copy = function(dict) {
                    this.reset();
                    Utils.appendArray(this.keys, dict.keys);
                    var l = dict.keys.length;
                    while(l--){
                        var key = dict.keys[l];
                        this.data[key] = dict.data[key];
                    }
                };
            },
            {
                "./Utils": 57
            }
        ],
        57: [
            function(_dereq_, module1, exports1) {
                /* global P2_ARRAY_TYPE */ module1.exports = Utils;
                /**
 * Misc utility functions
 * @class Utils
 * @constructor
 */ function Utils() {}
                /**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */ Utils.appendArray = function(a, b) {
                    if (b.length < 150000) {
                        a.push.apply(a, b);
                    } else {
                        for(var i = 0, len = b.length; i !== len; ++i){
                            a.push(b[i]);
                        }
                    }
                };
                /**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */ Utils.splice = function(array, index, howmany) {
                    howmany = howmany || 1;
                    for(var i = index, len = array.length - howmany; i < len; i++){
                        array[i] = array[i + howmany];
                    }
                    array.length = len;
                };
                /**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     <script src="p2.js">
 */ if (typeof P2_ARRAY_TYPE !== 'undefined') {
                    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
                } else if (typeof Float32Array !== 'undefined') {
                    Utils.ARRAY_TYPE = Float32Array;
                } else {
                    Utils.ARRAY_TYPE = Array;
                }
                /**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */ Utils.extend = function(a, b) {
                    for(var key in b){
                        a[key] = b[key];
                    }
                };
                /**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */ Utils.defaults = function(options, defaults) {
                    options = options || {};
                    for(var key in defaults){
                        if (!(key in options)) {
                            options[key] = defaults[key];
                        }
                    }
                    return options;
                };
            },
            {}
        ],
        58: [
            function(_dereq_, module1, exports1) {
                var Body = _dereq_('../objects/Body');
                module1.exports = Island;
                /**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */ function Island() {
                    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */ this.equations = [];
                    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */ this.bodies = [];
                }
                /**
 * Clean this island from bodies and equations.
 * @method reset
 */ Island.prototype.reset = function() {
                    this.equations.length = this.bodies.length = 0;
                };
                var bodyIds = [];
                /**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */ Island.prototype.getBodies = function(result) {
                    var bodies = result || [], eqs = this.equations;
                    bodyIds.length = 0;
                    for(var i = 0; i !== eqs.length; i++){
                        var eq = eqs[i];
                        if (bodyIds.indexOf(eq.bodyA.id) === -1) {
                            bodies.push(eq.bodyA);
                            bodyIds.push(eq.bodyA.id);
                        }
                        if (bodyIds.indexOf(eq.bodyB.id) === -1) {
                            bodies.push(eq.bodyB);
                            bodyIds.push(eq.bodyB.id);
                        }
                    }
                    return bodies;
                };
                /**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */ Island.prototype.wantsToSleep = function() {
                    for(var i = 0; i < this.bodies.length; i++){
                        var b = this.bodies[i];
                        if (b.type === Body.DYNAMIC && !b.wantsToSleep) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
 * Make all bodies in the island sleep.
 * @method sleep
 */ Island.prototype.sleep = function() {
                    for(var i = 0; i < this.bodies.length; i++){
                        var b = this.bodies[i];
                        b.sleep();
                    }
                    return true;
                };
            },
            {
                "../objects/Body": 31
            }
        ],
        59: [
            function(_dereq_, module1, exports1) {
                var vec2 = _dereq_('../math/vec2'), Island = _dereq_('./Island'), IslandNode = _dereq_('./IslandNode'), IslandNodePool = _dereq_('./../utils/IslandNodePool'), IslandPool = _dereq_('./../utils/IslandPool'), Body = _dereq_('../objects/Body');
                module1.exports = IslandManager;
                /**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */ function IslandManager(options) {
                    /**
     * @property nodePool
     * @type {IslandNodePool}
     */ this.nodePool = new IslandNodePool({
                        size: 16
                    });
                    /**
     * @property islandPool
     * @type {IslandPool}
     */ this.islandPool = new IslandPool({
                        size: 8
                    });
                    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */ this.equations = [];
                    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */ this.islands = [];
                    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */ this.nodes = [];
                    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */ this.queue = [];
                }
                /**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */ IslandManager.getUnvisitedNode = function(nodes) {
                    var Nnodes = nodes.length;
                    for(var i = 0; i !== Nnodes; i++){
                        var node = nodes[i];
                        if (!node.visited && node.body.type === Body.DYNAMIC) {
                            return node;
                        }
                    }
                    return false;
                };
                /**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */ IslandManager.prototype.visit = function(node, bds, eqs) {
                    bds.push(node.body);
                    var Neqs = node.equations.length;
                    for(var i = 0; i !== Neqs; i++){
                        var eq = node.equations[i];
                        if (eqs.indexOf(eq) === -1) {
                            eqs.push(eq);
                        }
                    }
                };
                /**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */ IslandManager.prototype.bfs = function(root, bds, eqs) {
                    // Reset the visit queue
                    var queue = this.queue;
                    queue.length = 0;
                    // Add root node to queue
                    queue.push(root);
                    root.visited = true;
                    this.visit(root, bds, eqs);
                    // Process all queued nodes
                    while(queue.length){
                        // Get next node in the queue
                        var node = queue.pop();
                        // Visit unvisited neighboring nodes
                        var child;
                        while(child = IslandManager.getUnvisitedNode(node.neighbors)){
                            child.visited = true;
                            this.visit(child, bds, eqs);
                            // Only visit the children of this node if it's dynamic
                            if (child.body.type === Body.DYNAMIC) {
                                queue.push(child);
                            }
                        }
                    }
                };
                /**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */ IslandManager.prototype.split = function(world) {
                    var bodies = world.bodies, nodes = this.nodes, equations = this.equations;
                    // Move old nodes to the node pool
                    while(nodes.length){
                        this.nodePool.release(nodes.pop());
                    }
                    // Create needed nodes, reuse if possible
                    for(var i = 0; i !== bodies.length; i++){
                        var node = this.nodePool.get();
                        node.body = bodies[i];
                        nodes.push(node);
                    // if(this.nodePool.length){
                    //     var node = this.nodePool.pop();
                    //     node.reset();
                    //     node.body = bodies[i];
                    //     nodes.push(node);
                    // } else {
                    //     nodes.push(new IslandNode(bodies[i]));
                    // }
                    }
                    // Add connectivity data. Each equation connects 2 bodies.
                    for(var k = 0; k !== equations.length; k++){
                        var eq = equations[k], i = bodies.indexOf(eq.bodyA), j = bodies.indexOf(eq.bodyB), ni = nodes[i], nj = nodes[j];
                        ni.neighbors.push(nj);
                        nj.neighbors.push(ni);
                        ni.equations.push(eq);
                        nj.equations.push(eq);
                    }
                    // Move old islands to the island pool
                    var islands = this.islands;
                    for(var i = 0; i < islands.length; i++){
                        this.islandPool.release(islands[i]);
                    }
                    islands.length = 0;
                    // Get islands
                    var child;
                    while(child = IslandManager.getUnvisitedNode(nodes)){
                        // Create new island
                        var island = this.islandPool.get();
                        // Get all equations and bodies in this island
                        this.bfs(child, island.bodies, island.equations);
                        islands.push(island);
                    }
                    return islands;
                };
            },
            {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "./../utils/IslandNodePool": 50,
                "./../utils/IslandPool": 51,
                "./Island": 58,
                "./IslandNode": 60
            }
        ],
        60: [
            function(_dereq_, module1, exports1) {
                module1.exports = IslandNode;
                /**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */ function IslandNode(body) {
                    /**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */ this.body = body;
                    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */ this.neighbors = [];
                    /**
     * Equations connected to this node.
     * @property {Array} equations
     */ this.equations = [];
                    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */ this.visited = false;
                }
                /**
 * Clean this node from bodies and equations.
 * @method reset
 */ IslandNode.prototype.reset = function() {
                    this.equations.length = 0;
                    this.neighbors.length = 0;
                    this.visited = false;
                    this.body = null;
                };
            },
            {}
        ],
        61: [
            function(_dereq_, module1, exports1) {
                var GSSolver = _dereq_('../solver/GSSolver'), Solver = _dereq_('../solver/Solver'), Ray = _dereq_('../collision/Ray'), vec2 = _dereq_('../math/vec2'), Circle = _dereq_('../shapes/Circle'), Convex = _dereq_('../shapes/Convex'), Line = _dereq_('../shapes/Line'), Plane = _dereq_('../shapes/Plane'), Capsule = _dereq_('../shapes/Capsule'), Particle = _dereq_('../shapes/Particle'), EventEmitter = _dereq_('../events/EventEmitter'), Body = _dereq_('../objects/Body'), Shape = _dereq_('../shapes/Shape'), LinearSpring = _dereq_('../objects/LinearSpring'), Material = _dereq_('../material/Material'), ContactMaterial = _dereq_('../material/ContactMaterial'), DistanceConstraint = _dereq_('../constraints/DistanceConstraint'), Constraint = _dereq_('../constraints/Constraint'), LockConstraint = _dereq_('../constraints/LockConstraint'), RevoluteConstraint = _dereq_('../constraints/RevoluteConstraint'), PrismaticConstraint = _dereq_('../constraints/PrismaticConstraint'), GearConstraint = _dereq_('../constraints/GearConstraint'), pkg = _dereq_('../../package.json'), Broadphase = _dereq_('../collision/Broadphase'), AABB = _dereq_('../collision/AABB'), SAPBroadphase = _dereq_('../collision/SAPBroadphase'), Narrowphase = _dereq_('../collision/Narrowphase'), Utils = _dereq_('../utils/Utils'), OverlapKeeper = _dereq_('../utils/OverlapKeeper'), IslandManager = _dereq_('./IslandManager'), RotationalSpring = _dereq_('../objects/RotationalSpring');
                module1.exports = World;
                /**
 * The dynamics world, where all bodies and constraints live.
 *
 * @class World
 * @constructor
 * @param {Object} [options]
 * @param {Solver} [options.solver] Defaults to GSSolver.
 * @param {Array} [options.gravity] Defaults to y=-9.78.
 * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase
 * @param {Boolean} [options.islandSplit=true]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -10],
 *         broadphase: new SAPBroadphase()
 *     });
 *     world.addBody(new Body());
 */ function World(options) {
                    EventEmitter.apply(this);
                    options = options || {};
                    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */ this.springs = [];
                    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */ this.bodies = [];
                    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */ this.disabledBodyCollisionPairs = [];
                    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */ this.solver = options.solver || new GSSolver();
                    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */ this.narrowphase = new Narrowphase(this);
                    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */ this.islandManager = new IslandManager();
                    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */ this.gravity = vec2.fromValues(0, -9.78);
                    if (options.gravity) {
                        vec2.copy(this.gravity, options.gravity);
                    }
                    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */ this.frictionGravity = vec2.length(this.gravity) || 10;
                    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     * @default true
     */ this.useWorldGravityAsFrictionGravity = true;
                    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     * @default true
     */ this.useFrictionGravityOnZeroGravity = true;
                    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */ this.broadphase = options.broadphase || new SAPBroadphase();
                    this.broadphase.setWorld(this);
                    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */ this.constraints = [];
                    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */ this.defaultMaterial = new Material();
                    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */ this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial);
                    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */ this.lastTimeStep = 1 / 60;
                    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     * @default true
     */ this.applySpringForces = true;
                    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     * @default true
     */ this.applyDamping = true;
                    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     * @default true
     */ this.applyGravity = true;
                    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     * @default true
     */ this.solveConstraints = true;
                    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */ this.contactMaterials = [];
                    /**
     * World time.
     * @property time
     * @type {Number}
     */ this.time = 0.0;
                    this.accumulator = 0;
                    /**
     * Is true during step().
     * @property {Boolean} stepping
     */ this.stepping = false;
                    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */ this.bodiesToBeRemoved = [];
                    /**
     * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     * @default true
     */ this.islandSplit = typeof options.islandSplit !== "undefined" ? !!options.islandSplit : true;
                    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     * @default true
     */ this.emitImpactEvent = true;
                    // Id counters
                    this._constraintIdCounter = 0;
                    this._bodyIdCounter = 0;
                    /**
     * Fired after the step().
     * @event postStep
     */ this.postStepEvent = {
                        type: "postStep"
                    };
                    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */ this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    };
                    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */ this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    };
                    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */ this.addSpringEvent = {
                        type: "addSpring",
                        spring: null
                    };
                    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */ this.impactEvent = {
                        type: "impact",
                        bodyA: null,
                        bodyB: null,
                        shapeA: null,
                        shapeB: null,
                        contactEquation: null
                    };
                    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */ this.postBroadphaseEvent = {
                        type: "postBroadphase",
                        pairs: null
                    };
                    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */ this.sleepMode = World.NO_SLEEPING;
                    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */ this.beginContactEvent = {
                        type: "beginContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null,
                        contactEquations: []
                    };
                    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     */ this.endContactEvent = {
                        type: "endContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null
                    };
                    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */ this.preSolveEvent = {
                        type: "preSolve",
                        contactEquations: null,
                        frictionEquations: null
                    };
                    // For keeping track of overlapping shapes
                    this.overlappingShapesLastState = {
                        keys: []
                    };
                    this.overlappingShapesCurrentState = {
                        keys: []
                    };
                    /**
     * @property {OverlapKeeper} overlapKeeper
     */ this.overlapKeeper = new OverlapKeeper();
                }
                World.prototype = new Object(EventEmitter.prototype);
                World.prototype.constructor = World;
                /**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */ World.NO_SLEEPING = 1;
                /**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */ World.BODY_SLEEPING = 2;
                /**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */ World.ISLAND_SLEEPING = 4;
                /**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} constraint
 * @example
 *     var constraint = new LockConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 */ World.prototype.addConstraint = function(constraint) {
                    this.constraints.push(constraint);
                };
                /**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */ World.prototype.addContactMaterial = function(contactMaterial) {
                    this.contactMaterials.push(contactMaterial);
                };
                /**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */ World.prototype.removeContactMaterial = function(cm) {
                    var idx = this.contactMaterials.indexOf(cm);
                    if (idx !== -1) {
                        Utils.splice(this.contactMaterials, idx, 1);
                    }
                };
                /**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */ World.prototype.getContactMaterial = function(materialA, materialB) {
                    var cmats = this.contactMaterials;
                    for(var i = 0, N = cmats.length; i !== N; i++){
                        var cm = cmats[i];
                        if (cm.materialA.id === materialA.id && cm.materialB.id === materialB.id || cm.materialA.id === materialB.id && cm.materialB.id === materialA.id) {
                            return cm;
                        }
                    }
                    return false;
                };
                /**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} constraint
 */ World.prototype.removeConstraint = function(constraint) {
                    var idx = this.constraints.indexOf(constraint);
                    if (idx !== -1) {
                        Utils.splice(this.constraints, idx, 1);
                    }
                };
                var step_r = vec2.create(), step_runit = vec2.create(), step_u = vec2.create(), step_f = vec2.create(), step_fhMinv = vec2.create(), step_velodt = vec2.create(), step_mg = vec2.create(), xiw = vec2.fromValues(0, 0), xjw = vec2.fromValues(0, 0), zero = vec2.fromValues(0, 0), interpvelo = vec2.fromValues(0, 0);
                /**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // Simple fixed timestepping without interpolation
 *     var fixedTimeStep = 1 / 60;
 *     var world = new World();
 *     var body = new Body({ mass: 1 });
 *     world.addBody(body);
 *
 *     function animate(){
 *         requestAnimationFrame(animate);
 *         world.step(fixedTimeStep);
 *         renderBody(body.position, body.angle);
 *     }
 *
 *     // Start animation loop
 *     requestAnimationFrame(animate);
 *
 * @example
 *     // Fixed timestepping with interpolation
 *     var maxSubSteps = 10;
 *     var lastTimeSeconds;
 *
 *     function animate(t){
 *         requestAnimationFrame(animate);
 *         timeSeconds = t / 1000;
 *         lastTimeSeconds = lastTimeSeconds || timeSeconds;
 *
 *         deltaTime = timeSeconds - lastTimeSeconds;
 *         world.step(fixedTimeStep, deltaTime, maxSubSteps);
 *
 *         renderBody(body.interpolatedPosition, body.interpolatedAngle);
 *     }
 *
 *     // Start animation loop
 *     requestAnimationFrame(animate);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */ World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
                    maxSubSteps = maxSubSteps || 10;
                    timeSinceLastCalled = timeSinceLastCalled || 0;
                    if (timeSinceLastCalled === 0) {
                        this.internalStep(dt);
                        // Increment time
                        this.time += dt;
                    } else {
                        this.accumulator += timeSinceLastCalled;
                        var substeps = 0;
                        while(this.accumulator >= dt && substeps < maxSubSteps){
                            // Do fixed steps to catch up
                            this.internalStep(dt);
                            this.time += dt;
                            this.accumulator -= dt;
                            substeps++;
                        }
                        var t = this.accumulator % dt / dt;
                        for(var j = 0; j !== this.bodies.length; j++){
                            var b = this.bodies[j];
                            vec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
                            b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
                        }
                    }
                };
                var endOverlaps = [];
                /**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */ World.prototype.internalStep = function(dt) {
                    this.stepping = true;
                    var that = this, Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, t0, t1, fhMinv = step_fhMinv, velodt = step_velodt, mg = step_mg, scale = vec2.scale, add = vec2.add, rotate = vec2.rotate, islandManager = this.islandManager;
                    this.overlapKeeper.tick();
                    this.lastTimeStep = dt;
                    // Update approximate friction gravity.
                    if (this.useWorldGravityAsFrictionGravity) {
                        var gravityLen = vec2.length(this.gravity);
                        if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                            // Nonzero gravity. Use it.
                            this.frictionGravity = gravityLen;
                        }
                    }
                    // Add gravity to bodies
                    if (this.applyGravity) {
                        for(var i = 0; i !== Nbodies; i++){
                            var b = bodies[i], fi = b.force;
                            if (b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING) {
                                continue;
                            }
                            vec2.scale(mg, g, b.mass * b.gravityScale); // F=m*g
                            add(fi, fi, mg);
                        }
                    }
                    // Add spring forces
                    if (this.applySpringForces) {
                        for(var i = 0; i !== Nsprings; i++){
                            var s = springs[i];
                            s.applyForce();
                        }
                    }
                    if (this.applyDamping) {
                        for(var i = 0; i !== Nbodies; i++){
                            var b = bodies[i];
                            if (b.type === Body.DYNAMIC) {
                                b.applyDamping(dt);
                            }
                        }
                    }
                    // Broadphase
                    var result = broadphase.getCollisionPairs(this);
                    // Remove ignored collision pairs
                    var ignoredPairs = this.disabledBodyCollisionPairs;
                    for(var i = ignoredPairs.length - 2; i >= 0; i -= 2){
                        for(var j = result.length - 2; j >= 0; j -= 2){
                            if (ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1] || ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1]) {
                                result.splice(j, 2);
                            }
                        }
                    }
                    // Remove constrained pairs with collideConnected == false
                    var Nconstraints = constraints.length;
                    for(i = 0; i !== Nconstraints; i++){
                        var c = constraints[i];
                        if (!c.collideConnected) {
                            for(var j = result.length - 2; j >= 0; j -= 2){
                                if (c.bodyA === result[j] && c.bodyB === result[j + 1] || c.bodyB === result[j] && c.bodyA === result[j + 1]) {
                                    result.splice(j, 2);
                                }
                            }
                        }
                    }
                    // postBroadphase event
                    this.postBroadphaseEvent.pairs = result;
                    this.emit(this.postBroadphaseEvent);
                    this.postBroadphaseEvent.pairs = null;
                    // Narrowphase
                    np.reset(this);
                    for(var i = 0, Nresults = result.length; i !== Nresults; i += 2){
                        var bi = result[i], bj = result[i + 1];
                        // Loop over all shapes of body i
                        for(var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++){
                            var si = bi.shapes[k], xi = si.position, ai = si.angle;
                            // All shapes of body j
                            for(var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++){
                                var sj = bj.shapes[l], xj = sj.position, aj = sj.angle;
                                var cm = this.defaultContactMaterial;
                                if (si.material && sj.material) {
                                    var tmp = this.getContactMaterial(si.material, sj.material);
                                    if (tmp) {
                                        cm = tmp;
                                    }
                                }
                                this.runNarrowphase(np, bi, si, xi, ai, bj, sj, xj, aj, cm, this.frictionGravity);
                            }
                        }
                    }
                    // Wake up bodies
                    for(var i = 0; i !== Nbodies; i++){
                        var body = bodies[i];
                        if (body._wakeUpAfterNarrowphase) {
                            body.wakeUp();
                            body._wakeUpAfterNarrowphase = false;
                        }
                    }
                    // Emit end overlap events
                    if (this.has('endContact')) {
                        this.overlapKeeper.getEndOverlaps(endOverlaps);
                        var e = this.endContactEvent;
                        var l = endOverlaps.length;
                        while(l--){
                            var data = endOverlaps[l];
                            e.shapeA = data.shapeA;
                            e.shapeB = data.shapeB;
                            e.bodyA = data.bodyA;
                            e.bodyB = data.bodyB;
                            this.emit(e);
                        }
                        endOverlaps.length = 0;
                    }
                    var preSolveEvent = this.preSolveEvent;
                    preSolveEvent.contactEquations = np.contactEquations;
                    preSolveEvent.frictionEquations = np.frictionEquations;
                    this.emit(preSolveEvent);
                    preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;
                    // update constraint equations
                    var Nconstraints = constraints.length;
                    for(i = 0; i !== Nconstraints; i++){
                        constraints[i].update();
                    }
                    if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {
                        if (this.islandSplit) {
                            // Split into islands
                            islandManager.equations.length = 0;
                            Utils.appendArray(islandManager.equations, np.contactEquations);
                            Utils.appendArray(islandManager.equations, np.frictionEquations);
                            for(i = 0; i !== Nconstraints; i++){
                                Utils.appendArray(islandManager.equations, constraints[i].equations);
                            }
                            islandManager.split(this);
                            for(var i = 0; i !== islandManager.islands.length; i++){
                                var island = islandManager.islands[i];
                                if (island.equations.length) {
                                    solver.solveIsland(dt, island);
                                }
                            }
                        } else {
                            // Add contact equations to solver
                            solver.addEquations(np.contactEquations);
                            solver.addEquations(np.frictionEquations);
                            // Add user-defined constraint equations
                            for(i = 0; i !== Nconstraints; i++){
                                solver.addEquations(constraints[i].equations);
                            }
                            if (this.solveConstraints) {
                                solver.solve(dt, this);
                            }
                            solver.removeAllEquations();
                        }
                    }
                    // Step forward
                    for(var i = 0; i !== Nbodies; i++){
                        var body = bodies[i];
                        // if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
                        body.integrate(dt);
                    // }
                    }
                    // Reset force
                    for(var i = 0; i !== Nbodies; i++){
                        bodies[i].setZeroForce();
                    }
                    // Emit impact event
                    if (this.emitImpactEvent && this.has('impact')) {
                        var ev = this.impactEvent;
                        for(var i = 0; i !== np.contactEquations.length; i++){
                            var eq = np.contactEquations[i];
                            if (eq.firstImpact) {
                                ev.bodyA = eq.bodyA;
                                ev.bodyB = eq.bodyB;
                                ev.shapeA = eq.shapeA;
                                ev.shapeB = eq.shapeB;
                                ev.contactEquation = eq;
                                this.emit(ev);
                            }
                        }
                    }
                    // Sleeping update
                    if (this.sleepMode === World.BODY_SLEEPING) {
                        for(i = 0; i !== Nbodies; i++){
                            bodies[i].sleepTick(this.time, false, dt);
                        }
                    } else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
                        // Tell all bodies to sleep tick but dont sleep yet
                        for(i = 0; i !== Nbodies; i++){
                            bodies[i].sleepTick(this.time, true, dt);
                        }
                        // Sleep islands
                        for(var i = 0; i < this.islandManager.islands.length; i++){
                            var island = this.islandManager.islands[i];
                            if (island.wantsToSleep()) {
                                island.sleep();
                            }
                        }
                    }
                    this.stepping = false;
                    // Remove bodies that are scheduled for removal
                    var bodiesToBeRemoved = this.bodiesToBeRemoved;
                    for(var i = 0; i !== bodiesToBeRemoved.length; i++){
                        this.removeBody(bodiesToBeRemoved[i]);
                    }
                    bodiesToBeRemoved.length = 0;
                    this.emit(this.postStepEvent);
                };
                /**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */ World.prototype.runNarrowphase = function(np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
                    // Check collision groups and masks
                    if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
                        return;
                    }
                    // Get world position and angle of each shape
                    vec2.rotate(xiw, xi, bi.angle);
                    vec2.rotate(xjw, xj, bj.angle);
                    vec2.add(xiw, xiw, bi.position);
                    vec2.add(xjw, xjw, bj.position);
                    var aiw = ai + bi.angle;
                    var ajw = aj + bj.angle;
                    np.enableFriction = cm.friction > 0;
                    np.frictionCoefficient = cm.friction;
                    var reducedMass;
                    if (bi.type === Body.STATIC || bi.type === Body.KINEMATIC) {
                        reducedMass = bj.mass;
                    } else if (bj.type === Body.STATIC || bj.type === Body.KINEMATIC) {
                        reducedMass = bi.mass;
                    } else {
                        reducedMass = bi.mass * bj.mass / (bi.mass + bj.mass);
                    }
                    np.slipForce = cm.friction * glen * reducedMass;
                    np.restitution = cm.restitution;
                    np.surfaceVelocity = cm.surfaceVelocity;
                    np.frictionStiffness = cm.frictionStiffness;
                    np.frictionRelaxation = cm.frictionRelaxation;
                    np.stiffness = cm.stiffness;
                    np.relaxation = cm.relaxation;
                    np.contactSkinSize = cm.contactSkinSize;
                    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
                    var resolver = np[si.type | sj.type], numContacts = 0;
                    if (resolver) {
                        var sensor = si.sensor || sj.sensor;
                        var numFrictionBefore = np.frictionEquations.length;
                        if (si.type < sj.type) {
                            numContacts = resolver.call(np, bi, si, xiw, aiw, bj, sj, xjw, ajw, sensor);
                        } else {
                            numContacts = resolver.call(np, bj, sj, xjw, ajw, bi, si, xiw, aiw, sensor);
                        }
                        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
                        if (numContacts) {
                            if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
                                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
                                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                                if (speedSquaredB >= speedLimitSquaredB * 2) {
                                    bi._wakeUpAfterNarrowphase = true;
                                }
                            }
                            if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
                                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
                                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                                if (speedSquaredA >= speedLimitSquaredA * 2) {
                                    bj._wakeUpAfterNarrowphase = true;
                                }
                            }
                            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
                            if (this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)) {
                                // Report new shape overlap
                                var e = this.beginContactEvent;
                                e.shapeA = si;
                                e.shapeB = sj;
                                e.bodyA = bi;
                                e.bodyB = bj;
                                // Reset contact equations
                                e.contactEquations.length = 0;
                                if (typeof numContacts === "number") {
                                    for(var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++){
                                        e.contactEquations.push(np.contactEquations[i]);
                                    }
                                }
                                this.emit(e);
                            }
                            // divide the max friction force by the number of contacts
                            if (typeof numContacts === "number" && numFrictionEquations > 1) {
                                for(var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++){
                                    var f = np.frictionEquations[i];
                                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                                }
                            }
                        }
                    }
                };
                /**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} spring
 */ World.prototype.addSpring = function(spring) {
                    this.springs.push(spring);
                    var evt = this.addSpringEvent;
                    evt.spring = spring;
                    this.emit(evt);
                    evt.spring = null;
                };
                /**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} spring
 */ World.prototype.removeSpring = function(spring) {
                    var idx = this.springs.indexOf(spring);
                    if (idx !== -1) {
                        Utils.splice(this.springs, idx, 1);
                    }
                };
                /**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */ World.prototype.addBody = function(body) {
                    if (this.bodies.indexOf(body) === -1) {
                        this.bodies.push(body);
                        body.world = this;
                        var evt = this.addBodyEvent;
                        evt.body = body;
                        this.emit(evt);
                        evt.body = null;
                    }
                };
                /**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */ World.prototype.removeBody = function(body) {
                    if (this.stepping) {
                        this.bodiesToBeRemoved.push(body);
                    } else {
                        body.world = null;
                        var idx = this.bodies.indexOf(body);
                        if (idx !== -1) {
                            Utils.splice(this.bodies, idx, 1);
                            this.removeBodyEvent.body = body;
                            body.resetConstraintVelocity();
                            this.emit(this.removeBodyEvent);
                            this.removeBodyEvent.body = null;
                        }
                    }
                };
                /**
 * Get a body by its id.
 * @method getBodyById
 * @param {number} id
 * @return {Body} The body, or false if it was not found.
 */ World.prototype.getBodyById = function(id) {
                    var bodies = this.bodies;
                    for(var i = 0; i < bodies.length; i++){
                        var b = bodies[i];
                        if (b.id === id) {
                            return b;
                        }
                    }
                    return false;
                };
                /**
 * Disable collision between two bodies
 * @method disableBodyCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ World.prototype.disableBodyCollision = function(bodyA, bodyB) {
                    this.disabledBodyCollisionPairs.push(bodyA, bodyB);
                };
                /**
 * Enable collisions between the given two bodies
 * @method enableBodyCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ World.prototype.enableBodyCollision = function(bodyA, bodyB) {
                    var pairs = this.disabledBodyCollisionPairs;
                    for(var i = 0; i < pairs.length; i += 2){
                        if (pairs[i] === bodyA && pairs[i + 1] === bodyB || pairs[i + 1] === bodyA && pairs[i] === bodyB) {
                            pairs.splice(i, 2);
                            return;
                        }
                    }
                };
                /**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */ World.prototype.clear = function() {
                    this.time = 0;
                    // Remove all solver equations
                    if (this.solver && this.solver.equations.length) {
                        this.solver.removeAllEquations();
                    }
                    // Remove all constraints
                    var cs = this.constraints;
                    for(var i = cs.length - 1; i >= 0; i--){
                        this.removeConstraint(cs[i]);
                    }
                    // Remove all bodies
                    var bodies = this.bodies;
                    for(var i = bodies.length - 1; i >= 0; i--){
                        this.removeBody(bodies[i]);
                    }
                    // Remove all springs
                    var springs = this.springs;
                    for(var i = springs.length - 1; i >= 0; i--){
                        this.removeSpring(springs[i]);
                    }
                    // Remove all contact materials
                    var cms = this.contactMaterials;
                    for(var i = cms.length - 1; i >= 0; i--){
                        this.removeContactMaterial(cms[i]);
                    }
                    World.apply(this);
                };
                var hitTest_tmp1 = vec2.create(), hitTest_zero = vec2.fromValues(0, 0), hitTest_tmp2 = vec2.fromValues(0, 0);
                /**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 * @todo Should use an api similar to the raycast function
 * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient
 * @todo Should use the broadphase
 */ World.prototype.hitTest = function(worldPoint, bodies, precision) {
                    precision = precision || 0;
                    // Create a dummy particle body with a particle shape to test against the bodies
                    var pb = new Body({
                        position: worldPoint
                    }), ps = new Particle(), px = worldPoint, pa = 0, x = hitTest_tmp1, zero = hitTest_zero, tmp = hitTest_tmp2;
                    pb.addShape(ps);
                    var n = this.narrowphase, result = [];
                    // Check bodies
                    for(var i = 0, N = bodies.length; i !== N; i++){
                        var b = bodies[i];
                        for(var j = 0, NS = b.shapes.length; j !== NS; j++){
                            var s = b.shapes[j];
                            // Get shape world position + angle
                            vec2.rotate(x, s.position, b.angle);
                            vec2.add(x, x, b.position);
                            var a = s.angle + b.angle;
                            if (s instanceof Circle && n.circleParticle(b, s, x, a, pb, ps, px, pa, true) || s instanceof Convex && n.particleConvex(pb, ps, px, pa, b, s, x, a, true) || s instanceof Plane && n.particlePlane(pb, ps, px, pa, b, s, x, a, true) || s instanceof Capsule && n.particleCapsule(pb, ps, px, pa, b, s, x, a, true) || s instanceof Particle && vec2.squaredLength(vec2.sub(tmp, x, worldPoint)) < precision * precision) {
                                result.push(b);
                            }
                        }
                    }
                    return result;
                };
                /**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */ World.prototype.setGlobalStiffness = function(stiffness) {
                    // Set for all constraints
                    var constraints = this.constraints;
                    for(var i = 0; i !== constraints.length; i++){
                        var c = constraints[i];
                        for(var j = 0; j !== c.equations.length; j++){
                            var eq = c.equations[j];
                            eq.stiffness = stiffness;
                            eq.needsUpdate = true;
                        }
                    }
                    // Set for all contact materials
                    var contactMaterials = this.contactMaterials;
                    for(var i = 0; i !== contactMaterials.length; i++){
                        var c = contactMaterials[i];
                        c.stiffness = c.frictionStiffness = stiffness;
                    }
                    // Set for default contact material
                    var c = this.defaultContactMaterial;
                    c.stiffness = c.frictionStiffness = stiffness;
                };
                /**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */ World.prototype.setGlobalRelaxation = function(relaxation) {
                    // Set for all constraints
                    for(var i = 0; i !== this.constraints.length; i++){
                        var c = this.constraints[i];
                        for(var j = 0; j !== c.equations.length; j++){
                            var eq = c.equations[j];
                            eq.relaxation = relaxation;
                            eq.needsUpdate = true;
                        }
                    }
                    // Set for all contact materials
                    for(var i = 0; i !== this.contactMaterials.length; i++){
                        var c = this.contactMaterials[i];
                        c.relaxation = c.frictionRelaxation = relaxation;
                    }
                    // Set for default contact material
                    var c = this.defaultContactMaterial;
                    c.relaxation = c.frictionRelaxation = relaxation;
                };
                var tmpAABB = new AABB();
                var tmpArray = [];
                /**
 * Ray cast against all bodies in the world.
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @return {boolean} True if any body was hit.
 *
 * @example
 *     var ray = new Ray({
 *         mode: Ray.CLOSEST, // or ANY
 *         from: [0, 0],
 *         to: [10, 0],
 *     });
 *     var result = new RaycastResult();
 *     world.raycast(result, ray);
 *
 *     // Get the hit point
 *     var hitPoint = vec2.create();
 *     result.getHitPoint(hitPoint, ray);
 *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
 *
 * @example
 *     var ray = new Ray({
 *         mode: Ray.ALL,
 *         from: [0, 0],
 *         to: [10, 0],
 *         callback: function(result){
 *
 *             // Print some info about the hit
 *             console.log('Hit body and shape: ', result.body, result.shape);
 *
 *             // Get the hit point
 *             var hitPoint = vec2.create();
 *             result.getHitPoint(hitPoint, ray);
 *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
 *
 *             // If you are happy with the hits you got this far, you can stop the traversal here:
 *             result.stop();
 *         }
 *     });
 *     var result = new RaycastResult();
 *     world.raycast(result, ray);
 */ World.prototype.raycast = function(result, ray) {
                    // Get all bodies within the ray AABB
                    ray.getAABB(tmpAABB);
                    this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
                    ray.intersectBodies(result, tmpArray);
                    tmpArray.length = 0;
                    return result.hasHit();
                };
            },
            {
                "../../package.json": 6,
                "../collision/AABB": 7,
                "../collision/Broadphase": 8,
                "../collision/Narrowphase": 10,
                "../collision/Ray": 11,
                "../collision/SAPBroadphase": 13,
                "../constraints/Constraint": 14,
                "../constraints/DistanceConstraint": 15,
                "../constraints/GearConstraint": 16,
                "../constraints/LockConstraint": 17,
                "../constraints/PrismaticConstraint": 18,
                "../constraints/RevoluteConstraint": 19,
                "../events/EventEmitter": 26,
                "../material/ContactMaterial": 27,
                "../material/Material": 28,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../objects/LinearSpring": 32,
                "../objects/RotationalSpring": 33,
                "../shapes/Capsule": 38,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Line": 42,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45,
                "../solver/GSSolver": 46,
                "../solver/Solver": 47,
                "../utils/OverlapKeeper": 52,
                "../utils/Utils": 57,
                "./IslandManager": 59
            }
        ]
    }, {}, [
        36
    ])(36);
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NoZXJwYS9saWIvcDItMC43LjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgcDIuanMgYXV0aG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmZhbHNlKWRlZmluZShlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5wMj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTY2FsYXIgPSBfZGVyZXFfKCcuL1NjYWxhcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKlxuICogQ29udGFpbmVyIGZvciBsaW5lLXJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAY2xhc3MgTGluZVxuICovXG5mdW5jdGlvbiBMaW5lKCl7fTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d28gbGluZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGxpbmVJbnRcbiAqIEBwYXJhbSAge0FycmF5fSAgbDEgICAgICAgICAgTGluZSB2ZWN0b3IgMVxuICogQHBhcmFtICB7QXJyYXl9ICBsMiAgICAgICAgICBMaW5lIHZlY3RvciAyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFByZWNpc2lvbiB0byB1c2Ugd2hlbiBjaGVja2luZyBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQuXG4gKi9cbkxpbmUubGluZUludCA9IGZ1bmN0aW9uKGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFTY2FsYXIuZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMuXG4gKiBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHEyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XG4gKi9cbkxpbmUuc2VnbWVudHNJbnRlcnNlY3QgPSBmdW5jdGlvbihwMSwgcDIsIHExLCBxMil7XG4gICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xuICAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBkYSA9IHEyWzBdIC0gcTFbMF07XG4gICB2YXIgZGIgPSBxMlsxXSAtIHExWzFdO1xuXG4gICAvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcbiAgIGlmKGRhKmR5IC0gZGIqZHggPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgdmFyIHMgPSAoZHggKiAocTFbMV0gLSBwMVsxXSkgKyBkeSAqIChwMVswXSAtIHExWzBdKSkgLyAoZGEgKiBkeSAtIGRiICogZHgpXG4gICB2YXIgdCA9IChkYSAqIChwMVsxXSAtIHExWzFdKSArIGRiICogKHExWzBdIC0gcDFbMF0pKSAvIChkYiAqIGR4IC0gZGEgKiBkeSlcblxuICAgcmV0dXJuIChzPj0wICYmIHM8PTEgJiYgdD49MCAmJiB0PD0xKTtcbn07XG5cblxufSx7XCIuL1NjYWxhclwiOjR9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKlxuICogUG9pbnQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBjbGFzcyBQb2ludFxuICovXG5mdW5jdGlvbiBQb2ludCgpe307XG5cbi8qKlxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFyZWFcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUG9pbnQuYXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKTtcbn07XG5cblBvaW50LmxlZnQgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSxiLGMpID4gMDtcbn07XG5cblBvaW50LmxlZnRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPj0gMDtcbn07XG5cblBvaW50LnJpZ2h0ID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8IDA7XG59O1xuXG5Qb2ludC5yaWdodE9uID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8PSAwO1xufTtcblxudmFyIHRtcFBvaW50MSA9IFtdLFxuICAgIHRtcFBvaW50MiA9IFtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBhcmUgY29sbGluZWFyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHBhcmFtICB7TnVtYmVyfSBbdGhyZXNob2xkQW5nbGU9MF0gVGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGNvbXBhcmluZyB0aGUgdmVjdG9ycy4gVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHJlc3VsdGluZyB2ZWN0b3JzIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLiBVc2UgemVybyBmb3IgbWF4IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvaW50LmNvbGxpbmVhciA9IGZ1bmN0aW9uKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XG4gICAgaWYoIXRocmVzaG9sZEFuZ2xlKVxuICAgICAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA9PSAwO1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWIgPSB0bXBQb2ludDEsXG4gICAgICAgICAgICBiYyA9IHRtcFBvaW50MjtcblxuICAgICAgICBhYlswXSA9IGJbMF0tYVswXTtcbiAgICAgICAgYWJbMV0gPSBiWzFdLWFbMV07XG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xuICAgICAgICBiY1sxXSA9IGNbMV0tYlsxXTtcblxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcbiAgICAgICAgICAgIG1hZ0EgPSBNYXRoLnNxcnQoYWJbMF0qYWJbMF0gKyBhYlsxXSphYlsxXSksXG4gICAgICAgICAgICBtYWdCID0gTWF0aC5zcXJ0KGJjWzBdKmJjWzBdICsgYmNbMV0qYmNbMV0pLFxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlIDwgdGhyZXNob2xkQW5nbGU7XG4gICAgfVxufTtcblxuUG9pbnQuc3FkaXN0ID0gZnVuY3Rpb24oYSxiKXtcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBMaW5lID0gX2RlcmVxXyhcIi4vTGluZVwiKVxuLCAgIFBvaW50ID0gX2RlcmVxXyhcIi4vUG9pbnRcIilcbiwgICBTY2FsYXIgPSBfZGVyZXFfKFwiLi9TY2FsYXJcIilcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG4vKipcbiAqIFBvbHlnb24gY2xhc3MuXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvbHlnb24oKXtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIHRoYXQgdGhpcyBwb2x5Z29uIGNvbnNpc3RzIG9mLiBBbiBhcnJheSBvZiBhcnJheSBvZiBudW1iZXJzLCBleGFtcGxlOiBbWzAsMF0sWzEsMF0sLi5dXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpe1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcyA9IHYubGVuZ3RoO1xuICAgIHJldHVybiB2W2kgPCAwID8gaSAlIHMgKyBzIDogaSAlIHNdO1xufTtcblxuLyoqXG4gKiBHZXQgZmlyc3QgdmVydGV4XG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzWzBdO1xufTtcblxuLyoqXG4gKiBHZXQgbGFzdCB2ZXJ0ZXhcbiAqIEBtZXRob2QgbGFzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXMubGVuZ3RoLTFdO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudmVydGljZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQXBwZW5kIHBvaW50cyBcImZyb21cIiB0byBcInRvXCItMSBmcm9tIGFuIG90aGVyIHBvbHlnb24gXCJwb2x5XCIgb250byB0aGlzIG9uZS5cbiAqIEBtZXRob2QgYXBwZW5kXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24gdG8gZ2V0IHBvaW50cyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBmcm9tIFRoZSB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHBvbHksZnJvbSx0byl7XG4gICAgaWYodHlwZW9mKGZyb20pID09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIkZyb20gaXMgbm90IGdpdmVuIVwiKTtcbiAgICBpZih0eXBlb2YodG8pID09IFwidW5kZWZpbmVkXCIpICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gaXMgbm90IGdpdmVuIVwiKTtcblxuICAgIGlmKHRvLTEgPCBmcm9tKSAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sMVwiKTtcbiAgICBpZih0byA+IHBvbHkudmVydGljZXMubGVuZ3RoKSAgIHRocm93IG5ldyBFcnJvcihcImxvbDJcIik7XG4gICAgaWYoZnJvbSA8IDApICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wzXCIpO1xuXG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGFyZSBvcmRlcmVkIGNvdW50ZXItY2xvY2t3aXNlLlxuICogQG1ldGhvZCBtYWtlQ0NXXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLm1ha2VDQ1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiciA9IDAsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gZmluZCBib3R0b20gcmlnaHQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFQb2ludC5sZWZ0KHRoaXMuYXQoYnIgLSAxKSwgdGhpcy5hdChiciksIHRoaXMuYXQoYnIgKyAxKSkpIHtcbiAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxuICogQG1ldGhvZCByZXZlcnNlXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGk9MCwgTj10aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHRoaXMudmVydGljZXMucG9wKCkpO1xuICAgIH1cbiAgICB0aGlzLnZlcnRpY2VzID0gdG1wO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XG4gKiBAbWV0aG9kIGlzUmVmbGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1JlZmxleCA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiBQb2ludC5yaWdodCh0aGlzLmF0KGkgLSAxKSwgdGhpcy5hdChpKSwgdGhpcy5hdChpICsgMSkpO1xufTtcblxudmFyIHRtcExpbmUxPVtdLFxuICAgIHRtcExpbmUyPVtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2FuU2VlID0gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhICsgMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhIC0gMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzdCA9IFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkgeyAvLyBmb3IgZWFjaCBlZGdlXG4gICAgICAgIGlmICgoaSArIDEpICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPT09IGEgfHwgaSA9PT0gYSkgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKFBvaW50LmxlZnRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkgKyAxKSkgJiYgUG9pbnQucmlnaHRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSB0aGlzLmF0KGEpO1xuICAgICAgICAgICAgbDFbMV0gPSB0aGlzLmF0KGIpO1xuICAgICAgICAgICAgbDJbMF0gPSB0aGlzLmF0KGkpO1xuICAgICAgICAgICAgbDJbMV0gPSB0aGlzLmF0KGkgKyAxKTtcbiAgICAgICAgICAgIHAgPSBMaW5lLmxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCBwKSA8IGRpc3QpIHsgLy8gaWYgZWRnZSBpcyBibG9ja2luZyB2aXNpYmlsaXR5IHRvIGJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtICB7UG9seWdvbn0gW3RhcmdldFBvbHldICAgT3B0aW9uYWwgdGFyZ2V0IHBvbHlnb24gdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1BvbHlnb259ICAgICAgICAgICAgICAgIFRoZSByZXN1bHRpbmcgY29weS5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgbmV3IFBvbHlnb24oKTtcbiAgICBwLmNsZWFyKCk7XG4gICAgaWYgKGkgPCBqKSB7XG4gICAgICAgIC8vIEluc2VydCBhbGwgdmVydGljZXMgZnJvbSBpIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxuICAgICAgICBmb3IodmFyIGs9MDsgazw9ajsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxuICAgICAgICBmb3IodmFyIGs9aTsgazx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZ2V0Q3V0RWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gbmV3IFBvbHlnb24oKTtcbiAgICB2YXIgbkRpYWdzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VlKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSB0aGlzLmNvcHkoaSwgaiwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wMiA9IHRoaXMuY29weShqLCBpLCB0bXBQb2x5KS5nZXRDdXRFZGdlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbdGhpcy5hdChpKSwgdGhpcy5hdChqKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZGVjb21wID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldEN1dEVkZ2VzKCk7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoZWRnZXMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbi8qKlxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxuICogQG1ldGhvZCBzbGljZVxuICogQHBhcmFtIHtBcnJheX0gY3V0RWRnZXMgQSBsaXN0IG9mIGVkZ2VzLCBhcyByZXR1cm5lZCBieSAuZ2V0Q3V0RWRnZXMoKVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PSAwKSByZXR1cm4gW3RoaXNdO1xuICAgIGlmKGN1dEVkZ2VzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXMubGVuZ3RoICYmIGN1dEVkZ2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXNbMF0ubGVuZ3RoPT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFt0aGlzXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHkuc2xpY2UoY3V0RWRnZSk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcbiAgICAgICAgdmFyIGkgPSB0aGlzLnZlcnRpY2VzLmluZGV4T2YoY3V0RWRnZVswXSk7XG4gICAgICAgIHZhciBqID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMV0pO1xuXG4gICAgICAgIGlmKGkgIT0gLTEgJiYgaiAhPSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuY29weShpLGopLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHkoaixpKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBsaW5lIHNlZ21lbnRzIG9mIHRoaXMgcG9seWdvbiBkbyBub3QgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXG4gKiBAbWV0aG9kIGlzU2ltcGxlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHRvZG8gU2hvdWxkIGl0IGNoZWNrIGFsbCBzZWdtZW50cyB3aXRoIGFsbCBvdGhlcnM/XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmlzU2ltcGxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGF0aCA9IHRoaXMudmVydGljZXM7XG4gICAgLy8gQ2hlY2tcbiAgICBmb3IodmFyIGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihMaW5lLnNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbaV0sIHBhdGhbaSsxXSwgcGF0aFtqXSwgcGF0aFtqKzFdICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBzZWdtZW50IGJldHdlZW4gdGhlIGxhc3QgYW5kIHRoZSBmaXJzdCBwb2ludCB0byBhbGwgb3RoZXJzXG4gICAgZm9yKHZhciBpPTE7IGk8cGF0aC5sZW5ndGgtMjsgaSsrKXtcbiAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAwO1xuICAgdmFyIGExID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBiMSA9IHAxWzBdIC0gcDJbMF07XG4gICB2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG4gICB2YXIgYTIgPSBxMlsxXSAtIHExWzFdO1xuICAgdmFyIGIyID0gcTFbMF0gLSBxMlswXTtcbiAgIHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcbiAgIHZhciBkZXQgPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XG5cbiAgIGlmKCFTY2FsYXIuZXEoZGV0LDAsZGVsdGEpKVxuICAgICAgcmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdXG4gICBlbHNlXG4gICAgICByZXR1cm4gWzAsMF1cbn1cblxuLyoqXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXG4gKiBAbWV0aG9kIHF1aWNrRGVjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxuICogQHBhcmFtICB7QXJyYXl9IFtzdGVpbmVyUG9pbnRzXVxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xldmVsXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnF1aWNrRGVjb21wID0gZnVuY3Rpb24ocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XG4gICAgcmVmbGV4VmVydGljZXMgPSByZWZsZXhWZXJ0aWNlcyB8fCBbXTtcbiAgICBzdGVpbmVyUG9pbnRzID0gc3RlaW5lclBvaW50cyB8fCBbXTtcblxuICAgIHZhciB1cHBlckludD1bMCwwXSwgbG93ZXJJbnQ9WzAsMF0sIHA9WzAsMF07IC8vIFBvaW50c1xuICAgIHZhciB1cHBlckRpc3Q9MCwgbG93ZXJEaXN0PTAsIGQ9MCwgY2xvc2VzdERpc3Q9MDsgLy8gc2NhbGFyc1xuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXG4gICAgdmFyIGxvd2VyUG9seT1uZXcgUG9seWdvbigpLCB1cHBlclBvbHk9bmV3IFBvbHlnb24oKTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHRoaXMsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgbGV2ZWwrKztcbiAgICBpZihsZXZlbCA+IG1heGxldmVsKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwicXVpY2tEZWNvbXA6IG1heCBsZXZlbCAoXCIrbWF4bGV2ZWwrXCIpIHJlYWNoZWQuXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocG9seS5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiAtIDEpKTsgLy8gZmluZCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5yaWdodChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpIHsgLy8ga2VlcCBvbmx5IHRoZSBjbG9zZXN0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSwgcG9seS5hdChqICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS52ZXJ0aWNlc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IHVwcGVyRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT0gKHVwcGVySW5kZXggKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrdGhpcy52ZXJ0aWNlcy5sZW5ndGgrXCIpXCIpO1xuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwgaSwgdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxwb2x5LnZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksbG93ZXJJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgY2xvc2VzdCBwb2ludCB3aXRoaW4gdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVxcblwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgICAgICBpZih1cHBlckluZGV4IDwgbG93ZXJJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxvd2VySW5kZXg7IGogPD0gdXBwZXJJbmRleDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0T24ocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS5hdChpKSwgcG9seS5hdChqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSwwLGkrMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LDAsY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5LnZlcnRpY2VzLmxlbmd0aCA8IHVwcGVyUG9seS52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb3dlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucHVzaCh0aGlzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuUG9seWdvbi5wcm90b3R5cGUucmVtb3ZlQ29sbGluZWFyUG9pbnRzID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IodmFyIGk9dGhpcy52ZXJ0aWNlcy5sZW5ndGgtMTsgdGhpcy52ZXJ0aWNlcy5sZW5ndGg+MyAmJiBpPj0wOyAtLWkpe1xuICAgICAgICBpZihQb2ludC5jb2xsaW5lYXIodGhpcy5hdChpLTEpLHRoaXMuYXQoaSksdGhpcy5hdChpKzEpLHByZWNpc2lvbikpe1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMuc3BsaWNlKGkldGhpcy52ZXJ0aWNlcy5sZW5ndGgsMSk7XG4gICAgICAgICAgICBpLS07IC8vIEp1bXAgb25lIHBvaW50IGZvcndhcmQuIE90aGVyd2lzZSB3ZSBtYXkgZ2V0IGEgY2hhaW4gcmVtb3ZhbFxuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn07XG5cbn0se1wiLi9MaW5lXCI6MSxcIi4vUG9pbnRcIjoyLFwiLi9TY2FsYXJcIjo0fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxhcjtcblxuLyoqXG4gKiBTY2FsYXIgZnVuY3Rpb25zXG4gKiBAY2xhc3MgU2NhbGFyXG4gKi9cbmZ1bmN0aW9uIFNjYWxhcigpe31cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gc2NhbGFycyBhcmUgZXF1YWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXFcbiAqIEBwYXJhbSAge051bWJlcn0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBiXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TY2FsYXIuZXEgPSBmdW5jdGlvbihhLGIscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8IHByZWNpc2lvbjtcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUG9seWdvbiA6IF9kZXJlcV8oXCIuL1BvbHlnb25cIiksXG4gICAgUG9pbnQgOiBfZGVyZXFfKFwiLi9Qb2ludFwiKSxcbn07XG5cbn0se1wiLi9Qb2ludFwiOjIsXCIuL1BvbHlnb25cIjozfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInAyXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuNy4xXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIEphdmFTY3JpcHQgMkQgcGh5c2ljcyBlbmdpbmUuXCIsXG4gIFwiYXV0aG9yXCI6IFwiU3RlZmFuIEhlZG1hbiA8c2NodGVwcGVAZ21haWwuY29tPiAoaHR0cDovL3N0ZWZmZS5zZSlcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJwMi5qc1wiLFxuICAgIFwicDJcIixcbiAgICBcInBoeXNpY3NcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiMmRcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL3NyYy9wMi5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3AyLmpzLmdpdFwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanMvaXNzdWVzXCJcbiAgfSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcbiAgICB9XG4gIF0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIl4wLjExLjJcIixcbiAgICBcImdydW50LWNvbnRyaWItbm9kZXVuaXRcIjogXCJeMC40LjFcIixcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXdhdGNoXCI6IFwifjAuNS4wXCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwifjIuMC4xXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbmNhdFwiOiBcIl4wLjQuMFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInBvbHktZGVjb21wXCI6IFwiMC4xLjFcIlxuICB9XG59XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXG4gKiBAY2xhc3MgQUFCQlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxuICovXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMubG93ZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIG9wdGlvbnMubG93ZXJCb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51cHBlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMudXBwZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIG9wdGlvbnMudXBwZXJCb3VuZCk7XG4gICAgfVxufVxuXG52YXIgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLCB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIGFuZ2xlLlxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxuICogQHBhcmFtIHtBcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHNraW5TaXplIFNvbWUgbWFyZ2luIHRvIGJlIGFkZGVkIHRvIHRoZSBBQUJCLlxuICovXG5BQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcblxuICAgIGlmKHR5cGVvZihhbmdsZSkgIT09IFwibnVtYmVyXCIpe1xuICAgICAgICBhbmdsZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgcG9pbnRzWzBdLCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjMi5jb3B5KGwsIHBvaW50c1swXSk7XG4gICAgfVxuICAgIHZlYzIuY29weSh1LCBsKTtcblxuICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgIHRtcFswXSA9IGNvc0FuZ2xlICogeCAtc2luQW5nbGUgKiB5O1xuICAgICAgICAgICAgdG1wWzFdID0gc2luQW5nbGUgKiB4ICtjb3NBbmdsZSAqIHk7XG4gICAgICAgICAgICBwID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcbiAgICAgICAgICAgIGlmKHBbal0gPiB1W2pdKXtcbiAgICAgICAgICAgICAgICB1W2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBbal0gPCBsW2pdKXtcbiAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICBpZihwb3NpdGlvbil7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMubG93ZXJCb3VuZCwgdGhpcy5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMudXBwZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYoc2tpblNpemUpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMF0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFsxXSAtPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzBdICs9IHNraW5TaXplO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmRbMV0gKz0gc2tpblNpemU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIGFhYmIubG93ZXJCb3VuZCk7XG4gICAgdmVjMi5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcbiAgICAvLyBMb29wIG92ZXIgeCBhbmQgeVxuICAgIHZhciBpID0gMjtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmRbaV07XG4gICAgICAgIGlmKHRoaXMubG93ZXJCb3VuZFtpXSA+IGwpe1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kW2ldID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwcGVyXG4gICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLnVwcGVyQm91bmRbaV0gPCB1KXtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFtpXSA9IHU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgcmV0dXJuICgobDJbMF0gPD0gdTFbMF0gJiYgdTFbMF0gPD0gdTJbMF0pIHx8IChsMVswXSA8PSB1MlswXSAmJiB1MlswXSA8PSB1MVswXSkpICYmXG4gICAgICAgICAgICgobDJbMV0gPD0gdTFbMV0gJiYgdTFbMV0gPD0gdTJbMV0pIHx8IChsMVsxXSA8PSB1MlsxXSAmJiB1MlsxXSA8PSB1MVsxXSkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbnRhaW5zUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBwb2ludFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQUFCQi5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHBvaW50KXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICByZXR1cm4gbFswXSA8PSBwb2ludFswXSAmJiBwb2ludFswXSA8PSB1WzBdICYmIGxbMV0gPD0gcG9pbnRbMV0gJiYgcG9pbnRbMV0gPD0gdVsxXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIEFBQkIgaXMgaGl0IGJ5IGEgcmF5LlxuICogQG1ldGhvZCBvdmVybGFwc1JheVxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEByZXR1cm4ge251bWJlcn0gLTEgaWYgbm8gaGl0LCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaWYgaGl0LlxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwc1JheSA9IGZ1bmN0aW9uKHJheSl7XG4gICAgdmFyIHQgPSAwO1xuXG4gICAgLy8gcmF5LmRpcmVjdGlvbiBpcyB1bml0IGRpcmVjdGlvbiB2ZWN0b3Igb2YgcmF5XG4gICAgdmFyIGRpckZyYWNYID0gMSAvIHJheS5kaXJlY3Rpb25bMF07XG4gICAgdmFyIGRpckZyYWNZID0gMSAvIHJheS5kaXJlY3Rpb25bMV07XG5cbiAgICAvLyB0aGlzLmxvd2VyQm91bmQgaXMgdGhlIGNvcm5lciBvZiBBQUJCIHdpdGggbWluaW1hbCBjb29yZGluYXRlcyAtIGxlZnQgYm90dG9tLCBydCBpcyBtYXhpbWFsIGNvcm5lclxuICAgIHZhciB0MSA9ICh0aGlzLmxvd2VyQm91bmRbMF0gLSByYXkuZnJvbVswXSkgKiBkaXJGcmFjWDtcbiAgICB2YXIgdDIgPSAodGhpcy51cHBlckJvdW5kWzBdIC0gcmF5LmZyb21bMF0pICogZGlyRnJhY1g7XG4gICAgdmFyIHQzID0gKHRoaXMubG93ZXJCb3VuZFsxXSAtIHJheS5mcm9tWzFdKSAqIGRpckZyYWNZO1xuICAgIHZhciB0NCA9ICh0aGlzLnVwcGVyQm91bmRbMV0gLSByYXkuZnJvbVsxXSkgKiBkaXJGcmFjWTtcblxuICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSkpO1xuICAgIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpO1xuXG4gICAgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1c1xuICAgIGlmICh0bWF4IDwgMCl7XG4gICAgICAgIC8vdCA9IHRtYXg7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBpZiB0bWluID4gdG1heCwgcmF5IGRvZXNuJ3QgaW50ZXJzZWN0IEFBQkJcbiAgICBpZiAodG1pbiA+IHRtYXgpe1xuICAgICAgICAvL3QgPSB0bWF4O1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRtaW47XG59O1xufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTd9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSl7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdWx0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uIFRvIGNoYW5nZSBpdCwgdXNlIC5zZXRXb3JsZCgpXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLiBTaG91bGQgYmUgc2V0IHRvIEJyb2FkcGhhc2UuQUFCQiBvciBCcm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdWb2x1bWVUeXBlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUgPSBCcm9hZHBoYXNlLkFBQkI7XG59XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFBQkJcbiAqL1xuQnJvYWRwaGFzZS5BQUJCID0gMTtcblxuLyoqXG4gKiBCb3VuZGluZyBjaXJjbGUgdHlwZS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19DSVJDTEVcbiAqL1xuQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEUgPSAyO1xuXG4vKipcbiAqIFNldCB0aGUgd29ybGQgdGhhdCB3ZSBhcmUgc2VhcmNoaW5nIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIHBvdGVudGlhbCBpbnRlcnNlY3RpbmcgYm9keSBwYWlycy5cbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBib2RpZXMsIG9yZGVyZWQgaW4gcGFpcnMuIEV4YW1wbGU6IEEgcmVzdWx0IG9mIFthLGIsYyxkXSBtZWFucyB0aGF0IHRoZSBwb3RlbnRpYWwgcGFpcnMgYXJlOiAoYSxiKSwgKGMsZCkuXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe307XG5cbnZhciBkaXN0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZlYzIuc3ViKGRpc3QsIGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgdmFyIGQyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpLFxuICAgICAgICByID0gYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cztcbiAgICByZXR1cm4gZDIgPD0gcipyO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmFhYmJDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgcmV0dXJuIGJvZHlBLmdldEFBQkIoKS5vdmVybGFwcyhib2R5Qi5nZXRBQUJCKCkpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5ib3VuZGluZ1ZvbHVtZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgc3dpdGNoKHRoaXMuYm91bmRpbmdWb2x1bWVUeXBlKXtcbiAgICBjYXNlIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFOlxuICAgICAgICByZXN1bHQgPSAgQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBCcm9hZHBoYXNlLkFBQkI6XG4gICAgICAgIHJlc3VsdCA9IEJyb2FkcGhhc2UuYWFiYkNoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZGluZyB2b2x1bWUgdHlwZSBub3QgcmVjb2duaXplZDogJyt0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgYWxsb3dlZCB0byBjb2xsaWRlIGF0IGFsbC5cbiAqIEBtZXRob2QgIGNhbkNvbGxpZGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5jYW5Db2xsaWRlID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgS0lORU1BVElDID0gQm9keS5LSU5FTUFUSUM7XG4gICAgdmFyIFNUQVRJQyA9IEJvZHkuU1RBVElDO1xuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IFNUQVRJQyAmJiBib2R5Qi50eXBlID09PSBTVEFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIHZzIGtpbmVtYXRpYyBib2RpZXNcbiAgICBpZiggKGJvZHlBLnR5cGUgPT09IEtJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBTVEFUSUMpIHx8XG4gICAgICAgIChib2R5QS50eXBlID09PSBTVEFUSUMgICAgJiYgYm9keUIudHlwZSA9PT0gS0lORU1BVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBraW5lbWF0aWMgdnMga2luZW1hdGljXG4gICAgaWYoYm9keUEudHlwZSA9PT0gS0lORU1BVElDICYmIGJvZHlCLnR5cGUgPT09IEtJTkVNQVRJQyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBib3RoIHNsZWVwaW5nIGJvZGllc1xuICAgIGlmKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBpZiBvbmUgaXMgc3RhdGljIGFuZCB0aGUgb3RoZXIgaXMgc2xlZXBpbmdcbiAgICBpZiggKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIudHlwZSA9PT0gU1RBVElDKSB8fFxuICAgICAgICAoYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5QS50eXBlID09PSBTVEFUSUMpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQnJvYWRwaGFzZS5OQUlWRSA9IDE7XG5Ccm9hZHBoYXNlLlNBUCA9IDI7XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMX1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKSxcbiAgICBQbGFuZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QbGFuZScpLFxuICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyksXG4gICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIE5haXZlIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb24uIERvZXMgTl4yIHRlc3RzLlxuICpcbiAqIEBjbGFzcyBOYWl2ZUJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmNhbGwodGhpcywgQnJvYWRwaGFzZS5OQUlWRSk7XG59XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIGZvcih2YXIgaT0wLCBOY29sbGlkaW5nPWJvZGllcy5sZW5ndGg7IGkhPT1OY29sbGlkaW5nOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aTsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3NoYXBlcy9DaXJjbGVcIjozOSxcIi4uL3NoYXBlcy9QYXJ0aWNsZVwiOjQzLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDQsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBzdWIgPSB2ZWMyLnN1YlxuLCAgIGFkZCA9IHZlYzIuYWRkXG4sICAgZG90ID0gdmVjMi5kb3RcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBDb250YWN0RXF1YXRpb25Qb29sID0gX2RlcmVxXygnLi4vdXRpbHMvQ29udGFjdEVxdWF0aW9uUG9vbCcpXG4sICAgRnJpY3Rpb25FcXVhdGlvblBvb2wgPSBfZGVyZXFfKCcuLi91dGlscy9GcmljdGlvbkVxdWF0aW9uUG9vbCcpXG4sICAgVHVwbGVEaWN0aW9uYXJ5ID0gX2RlcmVxXygnLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpXG4sICAgRnJpY3Rpb25FcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJylcbiwgICBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICBDb252ZXggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4JylcbiwgICBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpXG4sICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgQm94ID0gX2RlcmVxXygnLi4vc2hhcGVzL0JveCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hcnJvd3BoYXNlO1xuXG4vLyBUZW1wIHRoaW5nc1xudmFyIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5cbnZhciB0bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA4ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA5ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE4ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIE5hcnJvd3BoYXNlLiBDcmVhdGVzIGNvbnRhY3RzIGFuZCBmcmljdGlvbiBnaXZlbiBzaGFwZXMgYW5kIHRyYW5zZm9ybXMuXG4gKiBAY2xhc3MgTmFycm93cGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSgpe1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25FcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBtYWtlIGZyaWN0aW9uIGVxdWF0aW9ucyBpbiB0aGUgdXBjb21pbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZUZyaWN0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZXF1YXRpb25zIGVuYWJsZWQgaW4gdXBjb21pbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZWRFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWRFcXVhdGlvbnMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyaWN0aW9uIHNsaXAgZm9yY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBzbGlwRm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2xpcEZvcmNlID0gMTAuMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIHVwY29taW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25Db2VmZmljaWVudFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50ID0gMC4zO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSB0aGUgLnJlbGF0aXZlVmVsb2NpdHkgaW4gZWFjaCBwcm9kdWNlZCBGcmljdGlvbkVxdWF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdXJmYWNlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYWxsb2NhdGVkIENvbnRhY3RFcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb25Qb29sfSBjb250YWN0RXF1YXRpb25Qb29sXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIC8vIEFsbG9jYXRlIGEgZmV3IGVxdWF0aW9ucyBiZWZvcmUgc3RhcnRpbmcgdGhlIHNpbXVsYXRpb24uXG4gICAgICogICAgIC8vIFRoaXMgd2F5LCBubyBjb250YWN0IG9iamVjdHMgbmVlZCB0byBiZSBjcmVhdGVkIG9uIHRoZSBmbHkgaW4gdGhlIGdhbWUgbG9vcC5cbiAgICAgKiAgICAgd29ybGQubmFycm93cGhhc2UuY29udGFjdEVxdWF0aW9uUG9vbC5yZXNpemUoMTAyNCk7XG4gICAgICogICAgIHdvcmxkLm5hcnJvd3BoYXNlLmZyaWN0aW9uRXF1YXRpb25Qb29sLnJlc2l6ZSgxMDI0KTtcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wgPSBuZXcgQ29udGFjdEVxdWF0aW9uUG9vbCh7IHNpemU6IDMyIH0pO1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFsbG9jYXRlZCBDb250YWN0RXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7RnJpY3Rpb25FcXVhdGlvblBvb2x9IGZyaWN0aW9uRXF1YXRpb25Qb29sXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IG5ldyBGcmljdGlvbkVxdWF0aW9uUG9vbCh7IHNpemU6IDY0IH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3RpdHV0aW9uIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF4YXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25SZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSByZWR1Y3Rpb24gb2YgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBkaXNhYmxlZCwgYSBib3ggb24gYSBwbGFuZSB3aWxsIGdlbmVyYXRlIDIgY29udGFjdCBlcXVhdGlvbnMgYW5kIDIgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBlbmFibGVkLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGZyaWN0aW9uIGVxdWF0aW9uLiBTYW1lIGtpbmQgb2Ygc2ltcGxpZmljYXRpb25zIGFyZSBtYWRlICBmb3IgYWxsIGNvbGxpc2lvbiB0eXBlcy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGZlYXR1cmUgaXMgc3RhYmxlIGVub3VnaC5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY29sbGlkaW5nIGJvZGllcyBsYXN0IHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXBcbiAgICAgKiBAdHlwZSB7VHVwbGVEaWN0aW9uYXJ5fVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWN0IHNraW4gc2l6ZSB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRhY3RTa2luU2l6ZVxuICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDE7XG59XG5cbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BID0gdmVjMi5jcmVhdGUoKTtcbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGJvZGllc092ZXJsYXBcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIHNoYXBlIHdvcmxkIHRyYW5zZm9ybXMgYXJlIHdyb25nXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib2RpZXNPdmVybGFwID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgc2hhcGVQb3NpdGlvbkEgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BO1xuICAgIHZhciBzaGFwZVBvc2l0aW9uQiA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkI7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHNoYXBlcyBvZiBib2R5QVxuICAgIGZvcih2YXIgaz0wLCBOc2hhcGVzaT1ib2R5QS5zaGFwZXMubGVuZ3RoOyBrIT09TnNoYXBlc2k7IGsrKyl7XG4gICAgICAgIHZhciBzaGFwZUEgPSBib2R5QS5zaGFwZXNba107XG5cbiAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBzaGFwZUEucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXG4gICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1ib2R5Qi5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICB2YXIgc2hhcGVCID0gYm9keUIuc2hhcGVzW2xdO1xuXG4gICAgICAgICAgICBib2R5Qi50b1dvcmxkRnJhbWUoc2hhcGVQb3NpdGlvbkIsIHNoYXBlQi5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmKHRoaXNbc2hhcGVBLnR5cGUgfCBzaGFwZUIudHlwZV0oXG4gICAgICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICAgICAgc2hhcGVBLFxuICAgICAgICAgICAgICAgIHNoYXBlUG9zaXRpb25BLFxuICAgICAgICAgICAgICAgIHNoYXBlQS5hbmdsZSArIGJvZHlBLmFuZ2xlLFxuICAgICAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgICAgIHNoYXBlQixcbiAgICAgICAgICAgICAgICBzaGFwZVBvc2l0aW9uQixcbiAgICAgICAgICAgICAgICBzaGFwZUIuYW5nbGUgKyBib2R5Qi5hbmdsZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvZGllcyB3ZXJlIGluIGNvbnRhY3Qgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cbiAqIEBtZXRob2QgY29sbGlkZWRMYXN0U3RlcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29sbGlkZWRMYXN0U3RlcCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGlkMSA9IGJvZHlBLmlkfDAsXG4gICAgICAgIGlkMiA9IGJvZHlCLmlkfDA7XG4gICAgcmV0dXJuICEhdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5nZXQoaWQxLCBpZDIpO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYXdheSB0aGUgb2xkIGVxdWF0aW9ucyBhbmQgZ2V0cyByZWFkeSB0byBjcmVhdGUgbmV3XG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5yZXNldCgpO1xuXG4gICAgdmFyIGVxcyA9IHRoaXMuY29udGFjdEVxdWF0aW9ucztcbiAgICB2YXIgbCA9IGVxcy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2xdLFxuICAgICAgICAgICAgaWQxID0gZXEuYm9keUEuaWQsXG4gICAgICAgICAgICBpZDIgPSBlcS5ib2R5Qi5pZDtcbiAgICAgICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5zZXQoaWQxLCBpZDIsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBjZSA9IHRoaXMuY29udGFjdEVxdWF0aW9ucyxcbiAgICAgICAgZmUgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPGNlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25Qb29sLnJlbGVhc2UoY2VbaV0pO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxmZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wucmVsZWFzZShmZVtpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29udGFjdEVxdWF0aW9uLCBlaXRoZXIgYnkgcmV1c2luZyBhbiBleGlzdGluZyBvYmplY3Qgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxuICogQG1ldGhvZCBjcmVhdGVDb250YWN0RXF1YXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlQ29udGFjdEVxdWF0aW9uID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wuZ2V0KCk7XG4gICAgYy5ib2R5QSA9IGJvZHlBO1xuICAgIGMuYm9keUIgPSBib2R5QjtcbiAgICBjLnNoYXBlQSA9IHNoYXBlQTtcbiAgICBjLnNoYXBlQiA9IHNoYXBlQjtcbiAgICBjLnJlc3RpdHV0aW9uID0gdGhpcy5yZXN0aXR1dGlvbjtcbiAgICBjLmZpcnN0SW1wYWN0ID0gIXRoaXMuY29sbGlkZWRMYXN0U3RlcChib2R5QSxib2R5Qik7XG4gICAgYy5zdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLnJlbGF4YXRpb247XG4gICAgYy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMub2Zmc2V0ID0gdGhpcy5jb250YWN0U2tpblNpemU7XG5cbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24gPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgYyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wuZ2V0KCk7XG4gICAgYy5ib2R5QSA9IGJvZHlBO1xuICAgIGMuYm9keUIgPSBib2R5QjtcbiAgICBjLnNoYXBlQSA9IHNoYXBlQTtcbiAgICBjLnNoYXBlQiA9IHNoYXBlQjtcbiAgICBjLnNldFNsaXBGb3JjZSh0aGlzLnNsaXBGb3JjZSk7XG4gICAgYy5mcmljdGlvbkNvZWZmaWNpZW50ID0gdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50O1xuICAgIGMucmVsYXRpdmVWZWxvY2l0eSA9IHRoaXMuc3VyZmFjZVZlbG9jaXR5O1xuICAgIGMuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZEVxdWF0aW9ucztcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgYy5yZWxheGF0aW9uID0gdGhpcy5mcmljdGlvblJlbGF4YXRpb247XG4gICAgYy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBGcmljdGlvbkVxdWF0aW9uIGdpdmVuIHRoZSBkYXRhIGluIHRoZSBDb250YWN0RXF1YXRpb24uIFVzZXMgc2FtZSBvZmZzZXQgdmVjdG9ycyByaSBhbmQgcmosIGJ1dCB0aGUgdGFuZ2VudCB2ZWN0b3Igd2lsbCBiZSBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBjb2xsaXNpb24gbm9ybWFsLlxuICogQG1ldGhvZCBjcmVhdGVGcmljdGlvbkZyb21Db250YWN0XG4gKiBAcGFyYW0gIHtDb250YWN0RXF1YXRpb259IGNvbnRhY3RFcXVhdGlvblxuICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QgPSBmdW5jdGlvbihjKXtcbiAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcbiAgICB2ZWMyLmNvcHkoZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICB2ZWMyLmNvcHkoZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgYy5ub3JtYWxBKTtcbiAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLy8gVGFrZSB0aGUgYXZlcmFnZSBOIGxhdGVzdCBjb250YWN0IHBvaW50IG9uIHRoZSBwbGFuZS5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlID0gZnVuY3Rpb24obnVtQ29udGFjdHMpe1xuICAgIHZhciBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcbiAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IGMuYm9keUI7XG4gICAgdmVjMi5zZXQoZXEuY29udGFjdFBvaW50QSwgMCwgMCk7XG4gICAgdmVjMi5zZXQoZXEuY29udGFjdFBvaW50QiwgMCwgMCk7XG4gICAgdmVjMi5zZXQoZXEudCwgMCwgMCk7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcbiAgICAgICAgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uc1t0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBpZihjLmJvZHlBID09PSBib2R5QSl7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMyLnN1YihlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgIH1cbiAgICAgICAgZXEuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuICAgIH1cblxuICAgIHZhciBpbnZOdW1Db250YWN0cyA9IDEvbnVtQ29udGFjdHM7XG4gICAgdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XG4gICAgdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XG4gICAgdmVjMi5ub3JtYWxpemUoZXEudCwgZXEudCk7XG4gICAgdmVjMi5yb3RhdGU5MGN3KGVxLnQsIGVxLnQpO1xuICAgIHJldHVybiBlcTtcbn07XG5cbi8qKlxuICogQ29udmV4L2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgY29udmV4TGluZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSAgICAgY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtIHtib29sZWFufSAgICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhMaW5lID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpbmUvYm94IG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVCb3hcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm94Qm9keVxuICogQHBhcmFtICB7Qm94fSAgYm94U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGJveE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYm94QW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgIGp1c3RUZXN0XG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUJveCA9IGZ1bmN0aW9uKFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICBib3hCb2R5LFxuICAgIGJveFNoYXBlLFxuICAgIGJveE9mZnNldCxcbiAgICBib3hBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUoY29udmV4U2hhcGUsIGNhcHN1bGVTaGFwZSl7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMF0sIC1jYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAtY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMV0sICBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAtY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMl0sICBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbM10sIC1jYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG59XG5cbnZhciBjb252ZXhDYXBzdWxlX3RlbXBSZWN0ID0gbmV3IEJveCh7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSksXG4gICAgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb252ZXgvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4UG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhQb3NpdGlvbixcbiAgICBjb252ZXhBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvcyA9IGNvbnZleENhcHN1bGVfdGVtcFZlYztcbiAgICB2ZWMyLnNldChjaXJjbGVQb3MsIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIGlmKGp1c3RUZXN0ICYmIChyZXN1bHQxIHx8IHJlc3VsdDIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2VudGVyIHJlY3RcbiAgICB2YXIgciA9IGNvbnZleENhcHN1bGVfdGVtcFJlY3Q7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocixjYXBzdWxlU2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSxyLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIHJldHVybiByZXN1bHQgKyByZXN1bHQxICsgcmVzdWx0Mjtcbn07XG5cbi8qKlxuICogQ2Fwc3VsZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZVBvc2l0aW9uLFxuICAgIGxpbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxID0gbmV3IEJveCh7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSk7XG5cbi8qKlxuICogQ2Fwc3VsZS9jYXBzdWxlIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNhcHN1bGVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2Fwc3VsZUNhcHN1bGUgPSBmdW5jdGlvbihiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KXtcblxuICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZTtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvc2kgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMSxcbiAgICAgICAgY2lyY2xlUG9zaiA9IGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyO1xuXG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuXG4gICAgLy8gTmVlZCA0IGNpcmNsZSBjaGVja3MsIGJldHdlZW4gYWxsXG4gICAgZm9yKHZhciBpPTA7IGk8MjsgaSsrKXtcblxuICAgICAgICB2ZWMyLnNldChjaXJjbGVQb3NpLChpPT09MD8tMToxKSpzaS5sZW5ndGgvMiwwKTtcbiAgICAgICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zaSxjaXJjbGVQb3NpLGFpKTtcbiAgICAgICAgdmVjMi5hZGQoY2lyY2xlUG9zaSxjaXJjbGVQb3NpLHhpKTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajwyOyBqKyspe1xuXG4gICAgICAgICAgICB2ZWMyLnNldChjaXJjbGVQb3NqLChqPT09MD8tMToxKSpzai5sZW5ndGgvMiwgMCk7XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3NqLGNpcmNsZVBvc2osYWopO1xuICAgICAgICAgICAgdmVjMi5hZGQoY2lyY2xlUG9zaixjaXJjbGVQb3NqLHhqKTtcblxuICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNpcmNsZUNpcmNsZShiaSxzaSxjaXJjbGVQb3NpLGFpLCBiaixzaixjaXJjbGVQb3NqLGFqLCBqdXN0VGVzdCwgc2kucmFkaXVzLCBzai5yYWRpdXMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjaXJjbGVzIGFnYWluc3QgdGhlIGNlbnRlciBib3hzXG4gICAgdmFyIHJlY3QgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDE7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaSk7XG4gICAgdmFyIHJlc3VsdDEgPSB0aGlzLmNvbnZleENhcHN1bGUoYmkscmVjdCx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0MSl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBudW1Db250YWN0cyArPSByZXN1bHQxO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNqKTtcbiAgICB2YXIgcmVzdWx0MiA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaixyZWN0LHhqLGFqLCBiaSxzaSx4aSxhaSwganVzdFRlc3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQyKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDI7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG4vKipcbiAqIExpbmUvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBsaW5lTGluZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm9keUFcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIHNoYXBlQVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcG9zaXRpb25BXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZUFcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlCXG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVCXG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVMaW5lID0gZnVuY3Rpb24oXG4gICAgYm9keUEsXG4gICAgc2hhcGVBLFxuICAgIHBvc2l0aW9uQSxcbiAgICBhbmdsZUEsXG4gICAgYm9keUIsXG4gICAgc2hhcGVCLFxuICAgIHBvc2l0aW9uQixcbiAgICBhbmdsZUIsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGxhbmUvbGluZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwbGFuZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gIHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lTGluZSA9IGZ1bmN0aW9uKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJvZHksICBsaW5lU2hhcGUsICBsaW5lT2Zmc2V0LCAgbGluZUFuZ2xlLCBqdXN0VGVzdCl7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkVmVydGV4MDEgPSB0bXAzLFxuICAgICAgICB3b3JsZFZlcnRleDExID0gdG1wNCxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNSxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDYsXG4gICAgICAgIGRpc3QgPSB0bXA3LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDgsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDksXG4gICAgICAgIHZlcnRzID0gdG1wQXJyYXksXG4gICAgICAgIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgxLCAgbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcblxuICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lQW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZUFuZ2xlKTtcblxuICAgIGFkZCh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAxLCBsaW5lT2Zmc2V0KTtcbiAgICBhZGQod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxMSwgbGluZU9mZnNldCk7XG5cbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgwLHdvcmxkVmVydGV4MDEpO1xuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDEsd29ybGRWZXJ0ZXgxMSk7XG5cbiAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXG4gICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cbiAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICAvLyBDaGVjayBsaW5lIGVuZHNcbiAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcbiAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgc3ViKGRpc3QsIHYsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LHdvcmxkTm9ybWFsKTtcblxuICAgICAgICBpZihkIDwgMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksbGluZUJvZHkscGxhbmVTaGFwZSxsaW5lU2hhcGUpO1xuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIC8vIGRpc3RhbmNlIHZlY3RvciBhbG9uZyBwbGFuZSBub3JtYWxcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCwgd29ybGROb3JtYWwsIGQpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgdiwgZGlzdCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIC8vIEZyb20gbGluZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgICAgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVQb3NpdGlvbixcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUocGFydGljbGVCb2R5LHBhcnRpY2xlU2hhcGUscGFydGljbGVQb3NpdGlvbixwYXJ0aWNsZUFuZ2xlLCBjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2Fwc3VsZVBvc2l0aW9uLGNhcHN1bGVBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMsIDApO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvbGluZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3QgSWYgc2V0IHRvIHRydWUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCAoaW50ZXJzZWN0aW9uIG9yIG5vdCkgd2l0aG91dCBhZGRpbmcgZXF1YXRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVSYWRpdXMgUmFkaXVzIHRvIGFkZCB0byB0aGUgbGluZS4gQ2FuIGJlIHVzZWQgdG8gdGVzdCBDYXBzdWxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjaXJjbGVSYWRpdXMgSWYgc2V0LCB0aGlzIHZhbHVlIG92ZXJyaWRlcyB0aGUgY2lyY2xlIHNoYXBlIHJhZGl1cy5cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVMaW5lID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGp1c3RUZXN0LFxuICAgIGxpbmVSYWRpdXMsXG4gICAgY2lyY2xlUmFkaXVzXG4pe1xuICAgIHZhciBsaW5lUmFkaXVzID0gbGluZVJhZGl1cyB8fCAwLFxuICAgICAgICBjaXJjbGVSYWRpdXMgPSB0eXBlb2YoY2lyY2xlUmFkaXVzKSE9PVwidW5kZWZpbmVkXCIgPyBjaXJjbGVSYWRpdXMgOiBjaXJjbGVTaGFwZS5yYWRpdXMsXG5cbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wMSxcbiAgICAgICAgbGluZVRvQ2lyY2xlT3J0aG9Vbml0ID0gdG1wMixcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXAzLFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wNSxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNixcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDcsXG4gICAgICAgIHdvcmxkVmVydGV4MCA9IHRtcDgsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDksXG4gICAgICAgIHdvcmxkVmVydGV4MDEgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxMSA9IHRtcDExLFxuICAgICAgICBkaXN0ID0gdG1wMTIsXG4gICAgICAgIGxpbmVUb0NpcmNsZSA9IHRtcDEzLFxuICAgICAgICBsaW5lRW5kVG9MaW5lUmFkaXVzID0gdG1wMTQsXG5cbiAgICAgICAgdmVydHMgPSB0bXBBcnJheTtcblxuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgxLCAgbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcblxuICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lQW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZUFuZ2xlKTtcblxuICAgIGFkZCh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAxLCBsaW5lT2Zmc2V0KTtcbiAgICBhZGQod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxMSwgbGluZU9mZnNldCk7XG5cbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgwLHdvcmxkVmVydGV4MDEpO1xuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDEsd29ybGRWZXJ0ZXgxMSk7XG5cbiAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXG4gICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cbiAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gdGhlIHBsYW5lIHNwYW5uZWQgYnkgdGhlIGVkZ2UgdnMgdGhlIGNpcmNsZVxuICAgIHN1YihkaXN0LCBjaXJjbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XG4gICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTsgLy8gRGlzdGFuY2UgZnJvbSBjZW50ZXIgb2YgbGluZSB0byBjaXJjbGUgY2VudGVyXG4gICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgbGluZU9mZnNldCk7XG5cbiAgICBzdWIobGluZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmFyIHJhZGl1c1N1bSA9IGNpcmNsZVJhZGl1cyArIGxpbmVSYWRpdXM7XG5cbiAgICBpZihNYXRoLmFicyhkKSA8IHJhZGl1c1N1bSl7XG5cbiAgICAgICAgLy8gTm93IHByb2plY3QgdGhlIGNpcmNsZSBvbnRvIHRoZSBlZGdlXG4gICAgICAgIHZlYzIuc2NhbGUob3J0aG9EaXN0LCB3b3JsZFRhbmdlbnQsIGQpO1xuICAgICAgICBzdWIocHJvamVjdGVkUG9pbnQsIGNpcmNsZU9mZnNldCwgb3J0aG9EaXN0KTtcblxuICAgICAgICAvLyBBZGQgdGhlIG1pc3NpbmcgbGluZSByYWRpdXNcbiAgICAgICAgdmVjMi5zY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIHdvcmxkVGFuZ2VudCwgZG90KHdvcmxkVGFuZ2VudCwgbGluZVRvQ2lyY2xlKSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCxsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xuICAgICAgICB2ZWMyLnNjYWxlKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lUmFkaXVzKTtcbiAgICAgICAgYWRkKHByb2plY3RlZFBvaW50LHByb2plY3RlZFBvaW50LGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgZWRnZSBzcGFuXG4gICAgICAgIHZhciBwb3MgPSAgZG90KHdvcmxkRWRnZVVuaXQsIHByb2plY3RlZFBvaW50KTtcbiAgICAgICAgdmFyIHBvczAgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmFyIHBvczEgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgxKTtcblxuICAgICAgICBpZihwb3MgPiBwb3MwICYmIHBvcyA8IHBvczEpe1xuICAgICAgICAgICAgLy8gV2UgZ290IGNvbnRhY3QhXG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGxpbmVCb2R5LGNpcmNsZVNoYXBlLGxpbmVTaGFwZSk7XG5cbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5ub3JtYWxBLCBvcnRob0Rpc3QsIC0xKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsICBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgcHJvamVjdGVkUG9pbnQsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvcm5lclxuICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xuICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xuXG4gICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIHN1YihkaXN0LCB2LCBjaXJjbGVPZmZzZXQpO1xuXG4gICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1c1N1bSwgMikpe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxsaW5lQm9keSxjaXJjbGVTaGFwZSxsaW5lU2hhcGUpO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGxpbmVFbmRUb0xpbmVSYWRpdXMsIGMubm9ybWFsQSwgLWxpbmVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lRW5kVG9MaW5lUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY2Fwc3VsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gIHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGJqXG4gKiBAcGFyYW0gIHtMaW5lfSAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3Qpe1xuICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUoYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCwgc2oucmFkaXVzKTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NvbnZleCBOYXJyb3dwaGFzZS5cbiAqIEBtZXRob2QgY2lyY2xlQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVSYWRpdXNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0LFxuICAgIGNpcmNsZVJhZGl1c1xuKXtcbiAgICB2YXIgY2lyY2xlUmFkaXVzID0gdHlwZW9mKGNpcmNsZVJhZGl1cyk9PT1cIm51bWJlclwiID8gY2lyY2xlUmFkaXVzIDogY2lyY2xlU2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDMsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA0LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDUsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA2LFxuICAgICAgICBjb252ZXhUb0NpcmNsZSA9IHRtcDcsXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDgsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wOSxcbiAgICAgICAgZGlzdCA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleCA9IHRtcDExLFxuXG4gICAgICAgIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlRGlzdGFuY2UgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RWRnZU9ydGhvRGlzdCA9IHRtcDEyLFxuICAgICAgICBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsXG4gICAgICAgIGNhbmRpZGF0ZSA9IHRtcDE0LFxuICAgICAgICBjYW5kaWRhdGVEaXN0ID0gdG1wMTUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZSA9IHRtcDE2LFxuXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XG5cbiAgICAvLyBOZXcgYWxnb3JpdGhtOlxuICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgcG9seWdvbi4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXG4gICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxuICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxuICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cblxuICAgIHZhciB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xuXG4gICAgLy8gQ2hlY2sgYWxsIGVkZ2VzIGZpcnN0XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuXG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGROb3JtYWwsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIHBvbHlnb25cbiAgICAgICAgdmVjMi5zY2FsZShjYW5kaWRhdGUsd29ybGROb3JtYWwsLWNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgICAgIGFkZChjYW5kaWRhdGUsY2FuZGlkYXRlLGNpcmNsZU9mZnNldCk7XG5cbiAgICAgICAgaWYocG9pbnRJbkNvbnZleChjYW5kaWRhdGUsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKSl7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKGNhbmRpZGF0ZURpc3Qsd29ybGRWZXJ0ZXgwLGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyh2ZWMyLmRvdChjYW5kaWRhdGVEaXN0LHdvcmxkTm9ybWFsKSk7XG5cbiAgICAgICAgICAgIGlmKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2Upe1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShtaW5DYW5kaWRhdGUsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCx3b3JsZE5vcm1hbCxjYW5kaWRhdGVEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5hZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuXG4gICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGNvbnZleEJvZHksY2lyY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuICAgICAgICB2ZWMyLnN1YihjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCAgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCB2ZXJ0aWNlc1xuICAgIGlmKGNpcmNsZVJhZGl1cyA+IDApe1xuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgbG9jYWxWZXJ0ZXggPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4LCBsb2NhbFZlcnRleCwgY29udmV4QW5nbGUpO1xuICAgICAgICAgICAgYWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3coY2lyY2xlUmFkaXVzLCAyKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxjb252ZXhCb2R5LGNpcmNsZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG52YXIgcGljX3dvcmxkVmVydGV4MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3dvcmxkVmVydGV4MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3IwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfcjEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpcyBpbiBhIHBvbHlnb25cbiAqL1xuZnVuY3Rpb24gcG9pbnRJbkNvbnZleCh3b3JsZFBvaW50LGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSl7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHBpY193b3JsZFZlcnRleDAsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHBpY193b3JsZFZlcnRleDEsXG4gICAgICAgIHIwID0gcGljX3IwLFxuICAgICAgICByMSA9IHBpY19yMSxcbiAgICAgICAgcG9pbnQgPSB3b3JsZFBvaW50LFxuICAgICAgICB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzLFxuICAgICAgICBsYXN0Q3Jvc3MgPSBudWxsO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcbiAgICAgICAgLy8gQHRvZG8gVGhlIHBvaW50IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCB0byBsb2NhbCBjb29yZGluYXRlcyBpbiB0aGUgY29udmV4LCBubyBuZWVkIHRvIHRyYW5zZm9ybSBlYWNoIHZlcnRleFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKHIwLCB3b3JsZFZlcnRleDAsIHBvaW50KTtcbiAgICAgICAgc3ViKHIxLCB3b3JsZFZlcnRleDEsIHBvaW50KTtcbiAgICAgICAgdmFyIGNyb3NzID0gdmVjMi5jcm9zc0xlbmd0aChyMCxyMSk7XG5cbiAgICAgICAgaWYobGFzdENyb3NzPT09bnVsbCl7XG4gICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGdvdCBhIGRpZmZlcmVudCBzaWduIG9mIHRoZSBkaXN0YW5jZSB2ZWN0b3IsIHRoZSBwb2ludCBpcyBvdXQgb2YgdGhlIHBvbHlnb25cbiAgICAgICAgaWYoY3Jvc3MqbGFzdENyb3NzIDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQYXJ0aWNsZS9jb252ZXggTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGFydGljbGVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAdG9kbyB1c2UgcG9pbnRJbkNvbnZleCBhbmQgY29kZSBtb3JlIHNpbWlsYXIgdG8gY2lyY2xlQ29udmV4XG4gKiBAdG9kbyBkb24ndCB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXgsIGJ1dCB0cmFuc2Zvcm0gdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHRvIGNvbnZleC1sb2NhbCBpbnN0ZWFkXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVDb252ZXggPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXAzLFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wNSxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDYsXG4gICAgICAgIGNvbnZleFRvcGFydGljbGUgPSB0bXA3LFxuICAgICAgICBvcnRob0Rpc3QgPSB0bXA4LFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDksXG4gICAgICAgIGRpc3QgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSB0bXAxMSxcbiAgICAgICAgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgY2xvc2VzdEVkZ2VEaXN0YW5jZSA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3RFZGdlT3J0aG9EaXN0ID0gdG1wMTIsXG4gICAgICAgIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQgPSB0bXAxMyxcbiAgICAgICAgcjAgPSB0bXAxNCwgLy8gdmVjdG9yIGZyb20gcGFydGljbGUgdG8gdmVydGV4MFxuICAgICAgICByMSA9IHRtcDE1LFxuICAgICAgICBsb2NhbFBvaW50ID0gdG1wMTYsXG4gICAgICAgIGNhbmRpZGF0ZURpc3QgPSB0bXAxNyxcbiAgICAgICAgbWluRWRnZU5vcm1hbCA9IHRtcDE4LFxuICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwLFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBhcnRpY2xlIGlzIGluIHRoZSBwb2x5Z29uIGF0IGFsbFxuICAgIGlmKCFwb2ludEluQ29udmV4KHBhcnRpY2xlT2Zmc2V0LGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSkpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGVkZ2VzIGZpcnN0XG4gICAgdmFyIGxhc3RDcm9zcyA9IG51bGw7XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSB2ZXJ0aWNlcyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2VcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgaW5maW5pdGUgbGluZSAoc3Bhbm5lZCBieSB0aGUgZWRnZSkgdG8gdGhlIHBhcnRpY2xlXG4gICAgICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTtcbiAgICAgICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIoY29udmV4VG9wYXJ0aWNsZSwgcGFydGljbGVPZmZzZXQsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgdmVjMi5zdWIoY2FuZGlkYXRlRGlzdCx3b3JsZFZlcnRleDAscGFydGljbGVPZmZzZXQpO1xuICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyh2ZWMyLmRvdChjYW5kaWRhdGVEaXN0LHdvcmxkVGFuZ2VudCkpO1xuXG4gICAgICAgIGlmKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2Upe1xuICAgICAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBjYW5kaWRhdGVEaXN0YW5jZTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCx3b3JsZFRhbmdlbnQsY2FuZGlkYXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgdmVjMi5hZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHZlYzIuY29weShtaW5FZGdlTm9ybWFsLHdvcmxkVGFuZ2VudCk7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGFydGljbGVCb2R5LGNvbnZleEJvZHkscGFydGljbGVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgdmVjMi5zY2FsZShjLm5vcm1hbEEsIG1pbkVkZ2VOb3JtYWwsIC0xKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgIC8vIFBhcnRpY2xlIGhhcyBubyBleHRlbnQgdG8gdGhlIGNvbnRhY3QgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoYy5jb250YWN0UG9pbnRBLCAgMCwgMCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgLy8gRnJvbSBjb252ZXggY2VudGVyIHRvIHBvaW50XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cblxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY2lyY2xlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUNpcmNsZVxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVBXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNoYXBlQlxuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldEJcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVCXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0FdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQVxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNCXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUJcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICAgIGJvZHlBLFxuICAgIHNoYXBlQSxcbiAgICBvZmZzZXRBLFxuICAgIGFuZ2xlQSxcbiAgICBib2R5QixcbiAgICBzaGFwZUIsXG4gICAgb2Zmc2V0QixcbiAgICBhbmdsZUIsXG4gICAganVzdFRlc3QsXG4gICAgcmFkaXVzQSxcbiAgICByYWRpdXNCXG4pe1xuXG4gICAgdmFyIGRpc3QgPSB0bXAxLFxuICAgICAgICByYWRpdXNBID0gcmFkaXVzQSB8fCBzaGFwZUEucmFkaXVzLFxuICAgICAgICByYWRpdXNCID0gcmFkaXVzQiB8fCBzaGFwZUIucmFkaXVzO1xuXG4gICAgc3ViKGRpc3Qsb2Zmc2V0QSxvZmZzZXRCKTtcbiAgICB2YXIgciA9IHJhZGl1c0EgKyByYWRpdXNCO1xuICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA+IE1hdGgucG93KHIsMikpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIsc2hhcGVBLHNoYXBlQik7XG4gICAgc3ViKGMubm9ybWFsQSwgb2Zmc2V0Qiwgb2Zmc2V0QSk7XG4gICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgIHJhZGl1c0EpO1xuICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzQik7XG5cbiAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIG9mZnNldEEpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBvZmZzZXRCKTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogUGxhbmUvQ29udmV4IE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXggPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDIsXG4gICAgICAgIGRpc3QgPSB0bXAzO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMDtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gY29udmV4U2hhcGUudmVydGljZXNbaV07XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4LCB2LCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgaWYoZG90KGRpc3Qsd29ybGROb3JtYWwpIDw9IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIHZlcnRleFxuICAgICAgICAgICAgbnVtUmVwb3J0ZWQrKztcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksY29udmV4Qm9keSxwbGFuZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCwgYy5ub3JtYWxBLCBkKTtcblxuICAgICAgICAgICAgLy8gcmogaXMgZnJvbSBjb252ZXggY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuXG4gICAgICAgICAgICAvLyByaSBpcyBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgd29ybGRWZXJ0ZXgsIGRpc3QpO1xuICAgICAgICAgICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgbnVtUmVwb3J0ZWQpe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1SZXBvcnRlZCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bVJlcG9ydGVkO1xufTtcblxuLyoqXG4gKiBOYXJyb3dwaGFzZSBmb3IgcGFydGljbGUgdnMgcGxhbmVcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gICBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gICAgICBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcGxhbmVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSAgICAganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuUExBTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZVBsYW5lID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBkaXN0ID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyO1xuXG4gICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcblxuICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZE5vcm1hbCk7XG5cbiAgICBpZihkID4gMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LHBhcnRpY2xlQm9keSxwbGFuZVNoYXBlLHBhcnRpY2xlU2hhcGUpO1xuXG4gICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuICAgIHZlYzIuc2NhbGUoIGRpc3QsIGMubm9ybWFsQSwgZCApO1xuICAgIC8vIGRpc3QgaXMgbm93IHRoZSBkaXN0YW5jZSB2ZWN0b3IgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cblxuICAgIC8vIHJpIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgZG93biBvbnRvIHRoZSBwbGFuZSwgZnJvbSB0aGUgcGxhbmUgY2VudGVyXG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0LCBkaXN0KTtcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gcmogaXMgZnJvbSB0aGUgYm9keSBjZW50ZXIgdG8gdGhlIHBhcnRpY2xlIGNlbnRlclxuICAgIHN1YiggYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uICk7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIENpcmNsZS9QYXJ0aWNsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVQYXJ0aWNsZVxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QQVJUSUNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBhcnRpY2xlID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGlzdCA9IHRtcDE7XG5cbiAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIGNpcmNsZU9mZnNldCk7XG4gICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpID4gTWF0aC5wb3coY2lyY2xlU2hhcGUucmFkaXVzLCAyKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxwYXJ0aWNsZUJvZHksY2lyY2xlU2hhcGUscGFydGljbGVTaGFwZSk7XG4gICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIFZlY3RvciBmcm9tIHBhcnRpY2xlIGNlbnRlciB0byBjb250YWN0IHBvaW50IGlzIHplcm9cbiAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxudmFyIHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMiA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNhcHN1bGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2Fwc3VsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjYXBzdWxlQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVPZmZzZXQsXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBlbmQxID0gcGxhbmVDYXBzdWxlX3RtcDEsXG4gICAgICAgIGVuZDIgPSBwbGFuZUNhcHN1bGVfdG1wMixcbiAgICAgICAgY2lyY2xlID0gcGxhbmVDYXBzdWxlX3RtcENpcmNsZSxcbiAgICAgICAgZHN0ID0gcGxhbmVDYXBzdWxlX3RtcDM7XG5cbiAgICAvLyBDb21wdXRlIHdvcmxkIGVuZCBwb3NpdGlvbnNcbiAgICB2ZWMyLnNldChlbmQxLCAtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShlbmQxLGVuZDEsY2Fwc3VsZUFuZ2xlKTtcbiAgICBhZGQoZW5kMSxlbmQxLGNhcHN1bGVPZmZzZXQpO1xuXG4gICAgdmVjMi5zZXQoZW5kMiwgIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoZW5kMixlbmQyLGNhcHN1bGVBbmdsZSk7XG4gICAgYWRkKGVuZDIsZW5kMixjYXBzdWxlT2Zmc2V0KTtcblxuICAgIGNpcmNsZS5yYWRpdXMgPSBjYXBzdWxlU2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRG8gTmFycm93cGhhc2UgYXMgdHdvIGNpcmNsZXNcbiAgICB2YXIgbnVtQ29udGFjdHMxID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSxjaXJjbGUsZW5kMSwwLCBwbGFuZUJvZHkscGxhbmVTaGFwZSxwbGFuZU9mZnNldCxwbGFuZUFuZ2xlLCBqdXN0VGVzdCksXG4gICAgICAgIG51bUNvbnRhY3RzMiA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksY2lyY2xlLGVuZDIsMCwgcGxhbmVCb2R5LHBsYW5lU2hhcGUscGxhbmVPZmZzZXQscGxhbmVBbmdsZSwganVzdFRlc3QpO1xuXG4gICAgLy8gUmVzdG9yZSBmcmljdGlvblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gbnVtQ29udGFjdHMxIHx8IG51bUNvbnRhY3RzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbnVtVG90YWwgPSBudW1Db250YWN0czEgKyBudW1Db250YWN0czI7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgaWYobnVtVG90YWwpe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtVG90YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtVG90YWw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIENvbnRhY3RFcXVhdGlvbnMgYW5kIEZyaWN0aW9uRXF1YXRpb25zIGZvciBhIGNvbGxpc2lvbi5cbiAqIEBtZXRob2QgY2lyY2xlUGxhbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgIGJpICAgICBUaGUgZmlyc3QgYm9keSB0aGF0IHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSAge0NpcmNsZX0gIHNpICAgICBUaGUgY2lyY2xlIHNoYXBlIHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbGxpc2lvbi5cbiAqIEBwYXJhbSAge0FycmF5fSAgIHhpICAgICBFeHRyYSBvZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgZm9yIHRoZSBTaGFwZSwgaW4gYWRkaXRpb24gdG8gdGhlIG9uZSBpbiBjaXJjbGVCb2R5LnBvc2l0aW9uLiBXaWxsICpub3QqIGJlIHJvdGF0ZWQgYnkgY2lyY2xlQm9keS5hbmdsZSAobWF5YmUgaXQgc2hvdWxkLCBmb3Igc2FrZSBvZiBob21vZ2VuaXR5PykuIFNldCB0byBudWxsIGlmIG5vbmUuXG4gKiBAcGFyYW0gIHtCb2R5fSAgICBiaiAgICAgVGhlIHNlY29uZCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbm5lY3RlZCB0byB0aGUgZXF1YXRpb25zLlxuICogQHBhcmFtICB7UGxhbmV9ICAgc2ogICAgIFRoZSBQbGFuZSBzaGFwZSB0aGF0IGlzIHBhcnRpY2lwYXRpbmdcbiAqIEBwYXJhbSAge0FycmF5fSAgIHhqICAgICBFeHRyYSBvZmZzZXQgZm9yIHRoZSBwbGFuZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gIGFqICAgICBFeHRyYSBhbmdsZSB0byBhcHBseSB0byB0aGUgcGxhbmVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlUGxhbmUgPSBmdW5jdGlvbiggICBiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0ICl7XG4gICAgdmFyIGNpcmNsZUJvZHkgPSBiaSxcbiAgICAgICAgY2lyY2xlU2hhcGUgPSBzaSxcbiAgICAgICAgY2lyY2xlT2Zmc2V0ID0geGksIC8vIE9mZnNldCBmcm9tIGJvZHkgY2VudGVyLCByb3RhdGVkIVxuICAgICAgICBwbGFuZUJvZHkgPSBiaixcbiAgICAgICAgc2hhcGVCID0gc2osXG4gICAgICAgIHBsYW5lT2Zmc2V0ID0geGosXG4gICAgICAgIHBsYW5lQW5nbGUgPSBhajtcblxuICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSB0byBjaXJjbGVcbiAgICB2YXIgcGxhbmVUb0NpcmNsZSA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMixcbiAgICAgICAgdGVtcCA9IHRtcDM7XG5cbiAgICBzdWIocGxhbmVUb0NpcmNsZSwgY2lyY2xlT2Zmc2V0LCBwbGFuZU9mZnNldCk7XG5cbiAgICAvLyBXb3JsZCBwbGFuZSBub3JtYWxcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgLy8gTm9ybWFsIGRpcmVjdGlvbiBkaXN0YW5jZVxuICAgIHZhciBkID0gZG90KHdvcmxkTm9ybWFsLCBwbGFuZVRvQ2lyY2xlKTtcblxuICAgIGlmKGQgPiBjaXJjbGVTaGFwZS5yYWRpdXMpe1xuICAgICAgICByZXR1cm4gMDsgLy8gTm8gb3ZlcmxhcC4gQWJvcnQuXG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgIHZhciBjb250YWN0ID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGNpcmNsZUJvZHksc2osc2kpO1xuXG4gICAgLy8gbmkgaXMgdGhlIHBsYW5lIHdvcmxkIG5vcm1hbFxuICAgIHZlYzIuY29weShjb250YWN0Lm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcblxuICAgIC8vIHJqIGlzIHRoZSB2ZWN0b3IgZnJvbSBjaXJjbGUgY2VudGVyIHRvIHRoZSBjb250YWN0IHBvaW50XG4gICAgdmVjMi5zY2FsZShjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3Qubm9ybWFsQSwgLWNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgYWRkKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5jb250YWN0UG9pbnRCLCBjaXJjbGVPZmZzZXQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3QuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyByaSBpcyB0aGUgZGlzdGFuY2UgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdC5cbiAgICB2ZWMyLnNjYWxlKHRlbXAsIGNvbnRhY3Qubm9ybWFsQSwgZCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVUb0NpcmNsZSwgdGVtcCApOyAvLyBTdWJ0cmFjdCBub3JtYWwgZGlzdGFuY2UgdmVjdG9yIGZyb20gdGhlIGRpc3RhbmNlIHZlY3RvclxuICAgIGFkZChjb250YWN0LmNvbnRhY3RQb2ludEEsIGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVPZmZzZXQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEEsIGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGNvbnRhY3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGNvbnRhY3QpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIENvbnZleC9jb252ZXggTmFycm93cGhhc2UuU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXCI+dGhpcyBhcnRpY2xlPC9hPiBmb3IgbW9yZSBpbmZvLlxuICogQG1ldGhvZCBjb252ZXhDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IGJpXG4gKiBAcGFyYW0gIHtDb252ZXh9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtDb252ZXh9IHNqXG4gKiBAcGFyYW0gIHtBcnJheX0geGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENvbnZleCA9IGZ1bmN0aW9uKCAgYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCwgcHJlY2lzaW9uICl7XG4gICAgdmFyIHNlcEF4aXMgPSB0bXAxLFxuICAgICAgICB3b3JsZFBvaW50ID0gdG1wMixcbiAgICAgICAgd29ybGRQb2ludDAgPSB0bXAzLFxuICAgICAgICB3b3JsZFBvaW50MSA9IHRtcDQsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDUsXG4gICAgICAgIHByb2plY3RlZCA9IHRtcDYsXG4gICAgICAgIHBlbmV0cmF0aW9uVmVjID0gdG1wNyxcbiAgICAgICAgZGlzdCA9IHRtcDgsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wOSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwLFxuICAgICAgICBwcmVjaXNpb24gPSB0eXBlb2YocHJlY2lzaW9uKSA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiAwO1xuXG4gICAgdmFyIGZvdW5kID0gTmFycm93cGhhc2UuZmluZFNlcGFyYXRpbmdBeGlzKHNpLHhpLGFpLHNqLHhqLGFqLHNlcEF4aXMpO1xuICAgIGlmKCFmb3VuZCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgc2VwYXJhdGluZyBheGlzIGlzIGRpcmVjdGVkIGZyb20gc2hhcGUgaSB0byBzaGFwZSBqXG4gICAgc3ViKGRpc3QseGoseGkpO1xuICAgIGlmKGRvdChzZXBBeGlzLGRpc3QpID4gMCl7XG4gICAgICAgIHZlYzIuc2NhbGUoc2VwQXhpcyxzZXBBeGlzLC0xKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGVkZ2VzIHdpdGggbm9ybWFscyBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcbiAgICB2YXIgY2xvc2VzdEVkZ2UxID0gTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2Uoc2ksYWksc2VwQXhpcyx0cnVlKSwgLy8gRmxpcHBlZCBheGlzXG4gICAgICAgIGNsb3Nlc3RFZGdlMiA9IE5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlKHNqLGFqLHNlcEF4aXMpO1xuXG4gICAgaWYoY2xvc2VzdEVkZ2UxID09PSAtMSB8fCBjbG9zZXN0RWRnZTIgPT09IC0xKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vcCBvdmVyIHRoZSBzaGFwZXNcbiAgICBmb3IodmFyIGs9MDsgazwyOyBrKyspe1xuXG4gICAgICAgIHZhciBjbG9zZXN0RWRnZUEgPSBjbG9zZXN0RWRnZTEsXG4gICAgICAgICAgICBjbG9zZXN0RWRnZUIgPSBjbG9zZXN0RWRnZTIsXG4gICAgICAgICAgICBzaGFwZUEgPSAgc2ksIHNoYXBlQiA9ICBzaixcbiAgICAgICAgICAgIG9mZnNldEEgPSB4aSwgb2Zmc2V0QiA9IHhqLFxuICAgICAgICAgICAgYW5nbGVBID0gYWksIGFuZ2xlQiA9IGFqLFxuICAgICAgICAgICAgYm9keUEgPSBiaSwgYm9keUIgPSBiajtcblxuICAgICAgICBpZihrID09PSAwKXtcbiAgICAgICAgICAgIC8vIFN3YXAhXG4gICAgICAgICAgICB2YXIgdG1wO1xuICAgICAgICAgICAgdG1wID0gY2xvc2VzdEVkZ2VBO1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2VBID0gY2xvc2VzdEVkZ2VCO1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2VCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBzaGFwZUE7XG4gICAgICAgICAgICBzaGFwZUEgPSBzaGFwZUI7XG4gICAgICAgICAgICBzaGFwZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IG9mZnNldEE7XG4gICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QjtcbiAgICAgICAgICAgIG9mZnNldEIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IGFuZ2xlQTtcbiAgICAgICAgICAgIGFuZ2xlQSA9IGFuZ2xlQjtcbiAgICAgICAgICAgIGFuZ2xlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gYm9keUE7XG4gICAgICAgICAgICBib2R5QSA9IGJvZHlCO1xuICAgICAgICAgICAgYm9keUIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIG92ZXIgMiBwb2ludHMgaW4gY29udmV4IEJcbiAgICAgICAgZm9yKHZhciBqPWNsb3Nlc3RFZGdlQjsgajxjbG9zZXN0RWRnZUIrMjsgaisrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIHBvaW50XG4gICAgICAgICAgICB2YXIgdiA9IHNoYXBlQi52ZXJ0aWNlc1soaitzaGFwZUIudmVydGljZXMubGVuZ3RoKSVzaGFwZUIudmVydGljZXMubGVuZ3RoXTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQsIHYsIGFuZ2xlQik7XG4gICAgICAgICAgICBhZGQod29ybGRQb2ludCwgd29ybGRQb2ludCwgb2Zmc2V0Qik7XG5cbiAgICAgICAgICAgIHZhciBpbnNpZGVOdW1FZGdlcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciB0aGUgMyBjbG9zZXN0IGVkZ2VzIGluIGNvbnZleCBBXG4gICAgICAgICAgICBmb3IodmFyIGk9Y2xvc2VzdEVkZ2VBLTE7IGk8Y2xvc2VzdEVkZ2VBKzI7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICB2YXIgdjAgPSBzaGFwZUEudmVydGljZXNbKGkgICtzaGFwZUEudmVydGljZXMubGVuZ3RoKSVzaGFwZUEudmVydGljZXMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBzaGFwZUEudmVydGljZXNbKGkrMStzaGFwZUEudmVydGljZXMubGVuZ3RoKSVzaGFwZUEudmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCB2MCwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgdjEsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQwLCB3b3JsZFBvaW50MCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MSwgb2Zmc2V0QSk7XG5cbiAgICAgICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkTm9ybWFsLCB3b3JsZEVkZ2UpOyAvLyBOb3JtYWwgcG9pbnRzIG91dCBvZiBjb252ZXggMVxuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFBvaW50LCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCxkaXN0KTtcblxuICAgICAgICAgICAgICAgIGlmKChpID09PSBjbG9zZXN0RWRnZUEgJiYgZCA8PSBwcmVjaXNpb24pIHx8IChpICE9PSBjbG9zZXN0RWRnZUEgJiYgZCA8PSAwKSl7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZU51bUVkZ2VzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbnNpZGVOdW1FZGdlcyA+PSAzKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd29ybGRQb2ludCB3YXMgb24gdGhlIFwiaW5zaWRlXCIgc2lkZSBvZiBlYWNoIG9mIHRoZSAzIGNoZWNrZWQgZWRnZXMuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBpdCB0byB0aGUgY2VudGVyIGVkZ2UgYW5kIHVzZSB0aGUgcHJvamVjdGlvbiBkaXJlY3Rpb24gYXMgbm9ybWFsXG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIsc2hhcGVBLHNoYXBlQik7XG4gICAgICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjZW50ZXIgZWRnZSBmcm9tIGJvZHkgQVxuICAgICAgICAgICAgICAgIHZhciB2MCA9IHNoYXBlQS52ZXJ0aWNlc1soY2xvc2VzdEVkZ2VBKSAgICUgc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgIHYxID0gc2hhcGVBLnZlcnRpY2VzWyhjbG9zZXN0RWRnZUErMSkgJSBzaGFwZUEudmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCB2MCwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgdjEsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQwLCB3b3JsZFBvaW50MCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MSwgb2Zmc2V0QSk7XG5cbiAgICAgICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KGMubm9ybWFsQSwgd29ybGRFZGdlKTsgLy8gTm9ybWFsIHBvaW50cyBvdXQgb2YgY29udmV4IEFcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFBvaW50LCB3b3JsZFBvaW50MCk7IC8vIEZyb20gZWRnZSBwb2ludCB0byB0aGUgcGVuZXRyYXRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdChjLm5vcm1hbEEsZGlzdCk7ICAgICAgICAgICAgIC8vIFBlbmV0cmF0aW9uXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShwZW5ldHJhdGlvblZlYywgYy5ub3JtYWxBLCBkKTsgICAgIC8vIFZlY3RvciBwZW5ldHJhdGlvblxuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgd29ybGRQb2ludCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkUG9pbnQsIG9mZnNldEIpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qiwgb2Zmc2V0Qik7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIC8vIFRvZG8gcmVkdWNlIHRvIDEgZnJpY3Rpb24gZXF1YXRpb24gaWYgd2UgaGF2ZSAyIGNvbnRhY3QgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgbnVtQ29udGFjdHMpe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuLy8gLnByb2plY3RDb252ZXggaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIHBjb2FfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcbiAqIEBtZXRob2QgcHJvamVjdENvbnZleE9udG9BeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRBeGlzXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKi9cbk5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyA9IGZ1bmN0aW9uKGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCB3b3JsZEF4aXMsIHJlc3VsdCl7XG4gICAgdmFyIG1heD1udWxsLFxuICAgICAgICBtaW49bnVsbCxcbiAgICAgICAgdixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGxvY2FsQXhpcyA9IHBjb2FfdG1wMTtcblxuICAgIC8vIENvbnZlcnQgdGhlIGF4aXMgdG8gbG9jYWwgY29vcmRzIG9mIHRoZSBib2R5XG4gICAgdmVjMi5yb3RhdGUobG9jYWxBeGlzLCB3b3JsZEF4aXMsIC1jb252ZXhBbmdsZSk7XG5cbiAgICAvLyBHZXQgcHJvamVjdGVkIHBvc2l0aW9uIG9mIGFsbCB2ZXJ0aWNlc1xuICAgIGZvcih2YXIgaT0wOyBpPGNvbnZleFNoYXBlLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdiA9IGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IGRvdCh2LGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICB2YXIgb2Zmc2V0ID0gZG90KGNvbnZleE9mZnNldCwgd29ybGRBeGlzKTtcblxuICAgIHZlYzIuc2V0KCByZXN1bHQsIG1pbiArIG9mZnNldCwgbWF4ICsgb2Zmc2V0KTtcbn07XG5cbi8vIC5maW5kU2VwYXJhdGluZ0F4aXMgaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIGZzYV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBGaW5kIGEgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhlIHNoYXBlcywgdGhhdCBtYXhpbWl6ZXMgdGhlIHNlcGFyYXRpbmcgZGlzdGFuY2UgYmV0d2VlbiB0aGVtLlxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGMxXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBvZmZzZXQxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZTFcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGMyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBvZmZzZXQyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZTJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHNlcEF4aXMgICAgIFRoZSByZXN1bHRpbmcgYXhpc1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgV2hldGhlciB0aGUgYXhpcyBjb3VsZCBiZSBmb3VuZC5cbiAqL1xuTmFycm93cGhhc2UuZmluZFNlcGFyYXRpbmdBeGlzID0gZnVuY3Rpb24oYzEsb2Zmc2V0MSxhbmdsZTEsYzIsb2Zmc2V0MixhbmdsZTIsc2VwQXhpcyl7XG4gICAgdmFyIG1heERpc3QgPSBudWxsLFxuICAgICAgICBvdmVybGFwID0gZmFsc2UsXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIGVkZ2UgPSBmc2FfdG1wMSxcbiAgICAgICAgd29ybGRQb2ludDAgPSBmc2FfdG1wMixcbiAgICAgICAgd29ybGRQb2ludDEgPSBmc2FfdG1wMyxcbiAgICAgICAgbm9ybWFsID0gZnNhX3RtcDQsXG4gICAgICAgIHNwYW4xID0gZnNhX3RtcDUsXG4gICAgICAgIHNwYW4yID0gZnNhX3RtcDY7XG5cbiAgICBpZihjMSBpbnN0YW5jZW9mIEJveCAmJiBjMiBpbnN0YW5jZW9mIEJveCl7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09MjsgaSsrKXtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldChub3JtYWwsIDAsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc2V0KG5vcm1hbCwgMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBub3JtYWwsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsb2Zmc2V0MSxhbmdsZTEsbm9ybWFsLHNwYW4xKTtcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsb2Zmc2V0MixhbmdsZTIsbm9ybWFsLHNwYW4yKTtcblxuICAgICAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IDApO1xuXG4gICAgICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09Yy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIGMudmVydGljZXNbaV0sIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgYy52ZXJ0aWNlc1soaSsxKSVjLnZlcnRpY2VzLmxlbmd0aF0sIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHN1YihlZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLG9mZnNldDEsYW5nbGUxLG5vcm1hbCxzcGFuMSk7XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLG9mZnNldDIsYW5nbGUyLG5vcm1hbCxzcGFuMik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSAwKTtcblxuICAgICAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKlxuICAgIC8vIE5lZWRzIHRvIGJlIHRlc3RlZCBzb21lIG1vcmVcbiAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWMuYXhlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBjLmF4ZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLCBvZmZzZXQxLCBhbmdsZTEsIG5vcm1hbCwgc3BhbjEpO1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLCBvZmZzZXQyLCBhbmdsZTIsIG5vcm1hbCwgc3BhbjIpO1xuXG4gICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gTmFycm93cGhhc2UuY29udmV4UHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLy8gLmdldENsb3Nlc3RFZGdlIGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBnY2VfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZ2NlX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGdjZV90bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogR2V0IHRoZSBlZGdlIHRoYXQgaGFzIGEgbm9ybWFsIGNsb3Nlc3QgdG8gYW4gYXhpcy5cbiAqIEBtZXRob2QgZ2V0Q2xvc2VzdEVkZ2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBheGlzXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICBmbGlwXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgIEluZGV4IG9mIHRoZSBlZGdlIHRoYXQgaXMgY2xvc2VzdC4gVGhpcyBpbmRleCBhbmQgdGhlIG5leHQgc3BhbnMgdGhlIHJlc3VsdGluZyBlZGdlLiBSZXR1cm5zIC0xIGlmIGZhaWxlZC5cbiAqL1xuTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2UgPSBmdW5jdGlvbihjLGFuZ2xlLGF4aXMsZmxpcCl7XG4gICAgdmFyIGxvY2FsQXhpcyA9IGdjZV90bXAxLFxuICAgICAgICBlZGdlID0gZ2NlX3RtcDIsXG4gICAgICAgIG5vcm1hbCA9IGdjZV90bXAzO1xuXG4gICAgLy8gQ29udmVydCB0aGUgYXhpcyB0byBsb2NhbCBjb29yZHMgb2YgdGhlIGJvZHlcbiAgICB2ZWMyLnJvdGF0ZShsb2NhbEF4aXMsIGF4aXMsIC1hbmdsZSk7XG4gICAgaWYoZmxpcCl7XG4gICAgICAgIHZlYzIuc2NhbGUobG9jYWxBeGlzLGxvY2FsQXhpcywtMSk7XG4gICAgfVxuXG4gICAgdmFyIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIE4gPSBjLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgbWF4RG90ID0gLTE7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICAvLyBHZXQgdGhlIGVkZ2VcbiAgICAgICAgc3ViKGVkZ2UsIGMudmVydGljZXNbKGkrMSklTl0sIGMudmVydGljZXNbaSVOXSk7XG5cbiAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBlZGdlKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgdmFyIGQgPSBkb3Qobm9ybWFsLGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKGNsb3Nlc3RFZGdlID09PSAtMSB8fCBkID4gbWF4RG90KXtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlID0gaSAlIE47XG4gICAgICAgICAgICBtYXhEb3QgPSBkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RFZGdlO1xufTtcblxudmFyIGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3YxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY2lyY2xlSGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSAgICAgICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBialxuICogQHBhcmFtICB7SGVpZ2h0ZmllbGR9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKCBjaXJjbGVCb2R5LGNpcmNsZVNoYXBlLGNpcmNsZVBvcyxjaXJjbGVBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZkJvZHksaGZTaGFwZSxoZlBvcyxoZkFuZ2xlLCBqdXN0VGVzdCwgcmFkaXVzICl7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmhlaWdodHMsXG4gICAgICAgIHJhZGl1cyA9IHJhZGl1cyB8fCBjaXJjbGVTaGFwZS5yYWRpdXMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCxcbiAgICAgICAgZGlzdCA9IGNpcmNsZUhlaWdodGZpZWxkX2Rpc3QsXG4gICAgICAgIGNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlLFxuICAgICAgICBtaW5DYW5kaWRhdGVOb3JtYWwgPSBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwsXG4gICAgICAgIHYwID0gY2lyY2xlSGVpZ2h0ZmllbGRfdjAsXG4gICAgICAgIHYxID0gY2lyY2xlSGVpZ2h0ZmllbGRfdjE7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKCAoY2lyY2xlUG9zWzBdIC0gcmFkaXVzIC0gaGZQb3NbMF0pIC8gdyApLFxuICAgICAgICBpZHhCID0gTWF0aC5jZWlsKCAgKGNpcmNsZVBvc1swXSArIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIC8qaWYoaWR4QiA8IDAgfHwgaWR4QSA+PSBkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwOyovXG5cbiAgICBpZihpZHhBIDwgMCl7XG4gICAgICAgIGlkeEEgPSAwO1xuICAgIH1cbiAgICBpZihpZHhCID49IGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoLTE7XG4gICAgfVxuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluXG4gICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sXG4gICAgICAgIG1pbiA9IGRhdGFbaWR4Ql07XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcbiAgICAgICAgaWYoZGF0YVtpXSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbaV0gPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNpcmNsZVBvc1sxXS1yYWRpdXMgPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgLypcbiAgICBpZihjaXJjbGVQb3NbMV0rcmFkaXVzIDwgbWluKXtcbiAgICAgICAgLy8gQmVsb3cgdGhlIG1pbmltdW0gcG9pbnQuLi4gV2UgY2FuIGp1c3QgZ3Vlc3MuXG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgKi9cblxuICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgZmllbGQuIElmIGl0IGlzLCB0aGlzIHdvbnQgd29yay4uLlxuICAgIC8vIDIuIEZvciBlYWNoIGVkZ2VcbiAgICAvLyAyLiAxLiBHZXQgcG9pbnQgb24gY2lyY2xlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZWRnZSAoc2NhbGUgbm9ybWFsIHdpdGggLXJhZGl1cylcbiAgICAvLyAyLiAyLiBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUuXG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50c1xuICAgICAgICB2ZWMyLnNldCh2MCwgICAgIGkqdywgZGF0YVtpXSAgKTtcbiAgICAgICAgdmVjMi5zZXQodjEsIChpKzEpKncsIGRhdGFbaSsxXSk7XG4gICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcbiAgICAgICAgdmVjMi5hZGQodjEsdjEsaGZQb3MpO1xuXG4gICAgICAgIC8vIEdldCBub3JtYWxcbiAgICAgICAgdmVjMi5zdWIod29ybGROb3JtYWwsIHYxLCB2MCk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgTWF0aC5QSS8yKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGROb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIGVkZ2VcbiAgICAgICAgdmVjMi5zY2FsZShjYW5kaWRhdGUsd29ybGROb3JtYWwsLXJhZGl1cyk7XG4gICAgICAgIHZlYzIuYWRkKGNhbmRpZGF0ZSxjYW5kaWRhdGUsY2lyY2xlUG9zKTtcblxuICAgICAgICAvLyBEaXN0YW5jZSBmcm9tIHYwIHRvIHRoZSBjYW5kaWRhdGUgcG9pbnRcbiAgICAgICAgdmVjMi5zdWIoZGlzdCxjYW5kaWRhdGUsdjApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSBlbGVtZW50IFwic3RpY2tcIlxuICAgICAgICB2YXIgZCA9IHZlYzIuZG90KGRpc3Qsd29ybGROb3JtYWwpO1xuICAgICAgICBpZihjYW5kaWRhdGVbMF0gPj0gdjBbMF0gJiYgY2FuZGlkYXRlWzBdIDwgdjFbMF0gJiYgZCA8PSAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjYW5kaWRhdGUgcG9pbnQsIHByb2plY3RlZCB0byB0aGUgZWRnZVxuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LHdvcmxkTm9ybWFsLC1kKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKG1pbkNhbmRpZGF0ZSxjYW5kaWRhdGUsZGlzdCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkobWluQ2FuZGlkYXRlTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihoZkJvZHksY2lyY2xlQm9keSxoZlNoYXBlLGNpcmNsZVNoYXBlKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsIGlzIG91dCBvZiB0aGUgaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZU5vcm1hbCk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEIsICBjLm5vcm1hbEEsIC1yYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMuY29udGFjdFBvaW50QSwgbWluQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHZlYzIuc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZkJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCB2ZXJ0aWNlc1xuICAgIGZvdW5kID0gZmFsc2U7XG4gICAgaWYocmFkaXVzID4gMCl7XG4gICAgICAgIGZvcih2YXIgaT1pZHhBOyBpPD1pZHhCOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnRcbiAgICAgICAgICAgIHZlYzIuc2V0KHYwLCBpKncsIGRhdGFbaV0pO1xuICAgICAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuXG4gICAgICAgICAgICB2ZWMyLnN1YihkaXN0LCBjaXJjbGVQb3MsIHYwKTtcblxuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzLCAyKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LGNpcmNsZUJvZHksaGZTaGFwZSxjaXJjbGVTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgbm9ybWFsIC0gb3V0IG9mIGhlaWdodGZpZWxkXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYwLCBoZlBvcyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZlBvcyk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZkJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcblxufTtcblxudmFyIGNvbnZleEhlaWdodGZpZWxkX3YwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF92MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdGVtcENvbnZleFNoYXBlID0gbmV3IENvbnZleCh7IHZlcnRpY2VzOiBbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKV0gfSk7XG4vKipcbiAqIEBtZXRob2QgY2lyY2xlSGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSAgICAgICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBialxuICogQHBhcmFtICB7SGVpZ2h0ZmllbGR9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleEhlaWdodGZpZWxkID0gZnVuY3Rpb24oIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zLGNvbnZleEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSxoZlNoYXBlLGhmUG9zLGhmQW5nbGUsIGp1c3RUZXN0ICl7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmhlaWdodHMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCxcbiAgICAgICAgdjAgPSBjb252ZXhIZWlnaHRmaWVsZF92MCxcbiAgICAgICAgdjEgPSBjb252ZXhIZWlnaHRmaWVsZF92MSxcbiAgICAgICAgdGlsZVBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MsXG4gICAgICAgIHRpbGVDb252ZXggPSBjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGU7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKCAoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3ICksXG4gICAgICAgIGlkeEIgPSBNYXRoLmNlaWwoICAoY29udmV4Qm9keS5hYWJiLnVwcGVyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3ICk7XG5cbiAgICBpZihpZHhBIDwgMCl7XG4gICAgICAgIGlkeEEgPSAwO1xuICAgIH1cbiAgICBpZihpZHhCID49IGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoLTE7XG4gICAgfVxuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluXG4gICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sXG4gICAgICAgIG1pbiA9IGRhdGFbaWR4Ql07XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcbiAgICAgICAgaWYoZGF0YVtpXSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbaV0gPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNvbnZleEJvZHkuYWFiYi5sb3dlckJvdW5kWzFdID4gbWF4KXtcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwO1xuICAgIH1cblxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIGVkZ2VzXG4gICAgLy8gVE9ETzogSWYgcG9zc2libGUsIGNvbnN0cnVjdCBhIGNvbnZleCBmcm9tIHNldmVyYWwgZGF0YSBwb2ludHMgKG5lZWQgbyBjaGVjayBpZiB0aGUgcG9pbnRzIG1ha2UgYSBjb252ZXggc2hhcGUpXG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcblxuICAgICAgICAvLyBHZXQgcG9pbnRzXG4gICAgICAgIHZlYzIuc2V0KHYwLCAgICAgaSp3LCBkYXRhW2ldICApO1xuICAgICAgICB2ZWMyLnNldCh2MSwgKGkrMSkqdywgZGF0YVtpKzFdKTtcbiAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuICAgICAgICB2ZWMyLmFkZCh2MSx2MSxoZlBvcyk7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGEgY29udmV4XG4gICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gMTAwOyAvLyB0b2RvXG4gICAgICAgIHZlYzIuc2V0KHRpbGVQb3MsICh2MVswXSArIHYwWzBdKSowLjUsICh2MVsxXSArIHYwWzFdIC0gdGlsZUhlaWdodCkqMC41KTtcblxuICAgICAgICB2ZWMyLnN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzBdLCB2MSwgdGlsZVBvcyk7XG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMV0sIHYwLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5jb3B5KHRpbGVDb252ZXgudmVydGljZXNbMl0sIHRpbGVDb252ZXgudmVydGljZXNbMV0pO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1szXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1swXSk7XG4gICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbMl1bMV0gLT0gdGlsZUhlaWdodDtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1szXVsxXSAtPSB0aWxlSGVpZ2h0O1xuXG4gICAgICAgIC8vIERvIGNvbnZleCBjb2xsaXNpb25cbiAgICAgICAgbnVtQ29udGFjdHMgKz0gdGhpcy5jb252ZXhDb252ZXgoICAgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvcywgY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSwgdGlsZUNvbnZleCwgdGlsZVBvcywgMCwganVzdFRlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMSxcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzEsXCIuLi9zaGFwZXMvQm94XCI6MzcsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzksXCIuLi9zaGFwZXMvQ29udmV4XCI6NDAsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NSxcIi4uL3V0aWxzL0NvbnRhY3RFcXVhdGlvblBvb2xcIjo0OCxcIi4uL3V0aWxzL0ZyaWN0aW9uRXF1YXRpb25Qb29sXCI6NDksXCIuLi91dGlscy9UdXBsZURpY3Rpb25hcnlcIjo1NixcIi4uL3V0aWxzL1V0aWxzXCI6NTd9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuXG4vKipcbiAqIEEgbGluZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBwb2ludCB0aGF0IGlzIHVzZWQgdG8gaW50ZXJzZWN0IHNoYXBlcy4gRm9yIGFuIGV4YW1wbGUsIHNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9yYXljYXN0Om1ldGhvZFwifX1Xb3JsZC5yYXljYXN0e3svY3Jvc3NMaW5rfX1cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZnJvbV1cbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnRvXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tb2RlPVJheS5BTlldXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKi9cbmZ1bmN0aW9uIFJheShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFJheSBzdGFydCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gb3B0aW9ucy5mcm9tID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMuZnJvbVswXSwgb3B0aW9ucy5mcm9tWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSYXkgZW5kIHBvaW50XG4gICAgICogQHByb3BlcnR5IHthcnJheX0gdG9cbiAgICAgKi9cbiAgICB0aGlzLnRvID0gb3B0aW9ucy50byA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLnRvWzBdLCBvcHRpb25zLnRvWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgUmF5IHRvIHRha2UgLmNvbGxpc2lvblJlc3BvbnNlIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBza2lwQmFja2ZhY2VzXG4gICAgICovXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uTWFza1xuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIHt7I2Nyb3NzTGluayBcIlJheS9BTlk6cHJvcGVydHlcIn19UmF5LkFOWXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJSYXkvQUxMOnByb3BlcnR5XCJ9fVJheS5BTEx7ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJSYXkvQ0xPU0VTVDpwcm9wZXJ0eVwifX1SYXkuQ0xPU0VTVHt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vZGUgOiBSYXkuQU5ZO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCwgdXNlci1wcm92aWRlZCByZXN1bHQgY2FsbGJhY2suIFdpbGwgYmUgdXNlZCBpZiBtb2RlIGlzIFJheS5BTEwuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbihyZXN1bHQpe307XG5cbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBMZW5ndGggb2YgdGhlIHJheVxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xufVxuUmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJheTtcblxuLyoqXG4gKiBUaGlzIHJheWNhc3RpbmcgbW9kZSB3aWxsIG1ha2UgdGhlIFJheSB0cmF2ZXJzZSB0aHJvdWdoIGFsbCBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBvbmx5IHJldHVybiB0aGUgY2xvc2VzdCBvbmUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0xPU0VTVFxuICovXG5SYXkuQ0xPU0VTVCA9IDE7XG5cbi8qKlxuICogVGhpcyByYXljYXN0aW5nIG1vZGUgd2lsbCBtYWtlIHRoZSBSYXkgc3RvcCB3aGVuIGl0IGZpbmRzIHRoZSBmaXJzdCBpbnRlcnNlY3Rpb24gcG9pbnQuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQU5ZXG4gKi9cblJheS5BTlkgPSAyO1xuXG4vKipcbiAqIFRoaXMgcmF5Y2FzdGluZyBtb2RlIHdpbGwgdHJhdmVyc2UgYWxsIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIGVhY2ggb25lLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFMTFxuICovXG5SYXkuQUxMID0gNDtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIGlmIHlvdSBjaGFuZ2UgdGhlIGZyb20gb3IgdG8gcG9pbnQuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5SYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBVcGRhdGUgLmRpcmVjdGlvbiBhbmQgLmxlbmd0aFxuICAgIHZhciBkID0gdGhpcy5kaXJlY3Rpb247XG4gICAgdmVjMi5zdWIoZCwgdGhpcy50bywgdGhpcy5mcm9tKTtcbiAgICB0aGlzLmxlbmd0aCA9IHZlYzIubGVuZ3RoKGQpO1xuICAgIHZlYzIubm9ybWFsaXplKGQsIGQpO1xuXG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXG4gKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZGllcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXJlc3VsdC5zaG91bGRTdG9wKHRoaXMpICYmIGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBhYWJiID0gYm9keS5nZXRBQUJCKCk7XG4gICAgICAgIGlmKGFhYmIub3ZlcmxhcHNSYXkodGhpcykgPj0gMCB8fCBhYWJiLmNvbnRhaW5zUG9pbnQodGhpcy5mcm9tKSl7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkocmVzdWx0LCBib2R5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAocmVzdWx0LCBib2R5KSB7XG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIE4gPSBib2R5LnNoYXBlcy5sZW5ndGg7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCh0aGlzLmNvbGxpc2lvbkdyb3VwICYgc2hhcGUuY29sbGlzaW9uTWFzaykgPT09IDAgfHwgKHNoYXBlLmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKSA9PT0gMCl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmdsZSBhbmQgcG9zaXRpb24gb2YgdGhlIHNoYXBlXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9zaXRpb24sIHNoYXBlLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQod29ybGRQb3NpdGlvbiwgd29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIHZhciB3b3JsZEFuZ2xlID0gc2hhcGUuYW5nbGUgKyBib2R5LmFuZ2xlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUoXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIHdvcmxkQW5nbGUsXG4gICAgICAgICAgICB3b3JsZFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHRoaXMpKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24ocmVzdWx0LCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcblxuICAgIC8vIENoZWNraW5nIHJhZGl1c1xuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvblNxdWFyZWQoZnJvbSwgdGhpcy5kaXJlY3Rpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1JhZGl1cyAqIHNoYXBlLmJvdW5kaW5nUmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Qm9keSA9IGJvZHk7XG4gICAgdGhpcy5fY3VycmVudFNoYXBlID0gc2hhcGU7XG5cbiAgICBzaGFwZS5yYXljYXN0KHJlc3VsdCwgdGhpcywgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgIHRoaXMuX2N1cnJlbnRCb2R5ID0gdGhpcy5fY3VycmVudFNoYXBlID0gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZlYzIuc2V0KFxuICAgICAgICByZXN1bHQubG93ZXJCb3VuZCxcbiAgICAgICAgTWF0aC5taW4odG9bMF0sIGZyb21bMF0pLFxuICAgICAgICBNYXRoLm1pbih0b1sxXSwgZnJvbVsxXSlcbiAgICApO1xuICAgIHZlYzIuc2V0KFxuICAgICAgICByZXN1bHQudXBwZXJCb3VuZCxcbiAgICAgICAgTWF0aC5tYXgodG9bMF0sIGZyb21bMF0pLFxuICAgICAgICBNYXRoLm1heCh0b1sxXSwgZnJvbVsxXSlcbiAgICApO1xufTtcblxudmFyIGhpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7bnVtYmVyfSBmcmFjdGlvblxuICogQHBhcmFtICB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtICB7bnVtYmVyfSBbZmFjZUluZGV4PS0xXVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcbiAqL1xuUmF5LnByb3RvdHlwZS5yZXBvcnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIGZyYWN0aW9uLCBub3JtYWwsIGZhY2VJbmRleCl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgc2hhcGUgPSB0aGlzLl9jdXJyZW50U2hhcGU7XG4gICAgdmFyIGJvZHkgPSB0aGlzLl9jdXJyZW50Qm9keTtcblxuICAgIC8vIFNraXAgYmFjayBmYWNlcz9cbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgdmVjMi5kb3Qobm9ybWFsLCB0aGlzLmRpcmVjdGlvbikgPiAwKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCh0aGlzLm1vZGUpe1xuXG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZnJhY3Rpb24sXG4gICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkNMT1NFU1Q6XG5cbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XG4gICAgICAgIGlmKGZyYWN0aW9uIDwgcmVzdWx0LmZyYWN0aW9uIHx8ICFyZXN1bHQuaGFzSGl0KCkpe1xuICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbixcbiAgICAgICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5BTlk6XG5cbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZnJhY3Rpb24sXG4gICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxudmFyIHYwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpbnRlcnNlY3QgPSB2ZWMyLmNyZWF0ZSgpO1xuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZChmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XG5cbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXG4gICAgdmVjMi5zdWIodjAsIHBvc2l0aW9uLCBmcm9tKTtcbiAgICB2YXIgZG90ID0gdmVjMi5kb3QodjAsIGRpcmVjdGlvbik7XG5cbiAgICAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24gKiBkb3QgKyBmcm9tXG4gICAgdmVjMi5zY2FsZShpbnRlcnNlY3QsIGRpcmVjdGlvbiwgZG90KTtcbiAgICB2ZWMyLmFkZChpbnRlcnNlY3QsIGludGVyc2VjdCwgZnJvbSk7XG5cbiAgICByZXR1cm4gdmVjMi5zcXVhcmVkRGlzdGFuY2UocG9zaXRpb24sIGludGVyc2VjdCk7XG59XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjcsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEyLFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgaGl0IGRhdGEuXG4gKiBAY2xhc3MgUmF5Y2FzdFJlc3VsdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJheWNhc3RSZXN1bHQoKXtcblxuXHQvKipcblx0ICogVGhlIG5vcm1hbCBvZiB0aGUgaGl0LCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cblx0ICogQHByb3BlcnR5IHthcnJheX0gbm9ybWFsXG5cdCAqL1xuXHR0aGlzLm5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgc2hhcGUsIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG5cdCAqL1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGhpdCBib2R5LCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG5cdHRoaXMuYm9keSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBpbmRleGFibGUuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmYWNlSW5kZXhcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZmFjZUluZGV4ID0gLTE7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIHRvIHRoZSBoaXQsIGFzIGEgZnJhY3Rpb24uIDAgaXMgYXQgdGhlIFwiZnJvbVwiIHBvaW50LCAxIGlzIGF0IHRoZSBcInRvXCIgcG9pbnQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQgeWV0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZnJhY3Rpb25cblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZnJhY3Rpb24gPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nLlxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBpc1N0b3BwZWRcblx0ICovXG5cdHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLiBNdXN0IGJlIGRvbmUgYmVmb3JlIHJlLXVzaW5nIHRoZSByZXN1bHQgb2JqZWN0LlxuICogQG1ldGhvZCByZXNldFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0dmVjMi5zZXQodGhpcy5ub3JtYWwsIDAsIDApO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5mYWNlSW5kZXggPSAtMTtcblx0dGhpcy5mcmFjdGlvbiA9IC0xO1xuXHR0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBoaXQgcG9pbnQuXG4gKiBAbWV0aG9kIGdldEhpdERpc3RhbmNlXG4gKiBAcGFyYW0ge1JheX0gcmF5XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdERpc3RhbmNlID0gZnVuY3Rpb24gKHJheSkge1xuXHRyZXR1cm4gdmVjMi5kaXN0YW5jZShyYXkuZnJvbSwgcmF5LnRvKSAqIHRoaXMuZnJhY3Rpb247XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmF5IGhpdCBzb21ldGhpbmcgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cbiAqIEBtZXRob2QgaGFzSGl0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmhhc0hpdCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZnJhY3Rpb24gIT09IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgd29ybGQgaGl0IHBvaW50LlxuICogQG1ldGhvZCBnZXRIaXRQb2ludFxuICogQHBhcmFtIHthcnJheX0gb3V0XG4gKiBAcGFyYW0ge1JheX0gcmF5XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdFBvaW50ID0gZnVuY3Rpb24gKG91dCwgcmF5KSB7XG5cdHZlYzIubGVycChvdXQsIHJheS5mcm9tLCByYXkudG8sIHRoaXMuZnJhY3Rpb24pO1xufTtcblxuLyoqXG4gKiBDYW4gYmUgY2FsbGVkIHdoaWxlIGl0ZXJhdGluZyBvdmVyIGhpdHMgdG8gc3RvcCBzZWFyY2hpbmcgZm9yIGhpdCBwb2ludHMuXG4gKiBAbWV0aG9kIHN0b3BcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzaG91bGRTdG9wXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSYXl9IHJheVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2hvdWxkU3RvcCA9IGZ1bmN0aW9uKHJheSl7XG5cdHJldHVybiB0aGlzLmlzU3RvcHBlZCB8fCAodGhpcy5mcmFjdGlvbiAhPT0gLTEgJiYgcmF5Lm1vZGUgPT09IFJheS5BTlkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRub3JtYWwsXG5cdHNoYXBlLFxuXHRib2R5LFxuXHRmcmFjdGlvbixcblx0ZmFjZUluZGV4XG4pe1xuXHR2ZWMyLmNvcHkodGhpcy5ub3JtYWwsIG5vcm1hbCk7XG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcblx0dGhpcy5ib2R5ID0gYm9keTtcblx0dGhpcy5mcmFjdGlvbiA9IGZyYWN0aW9uO1xuXHR0aGlzLmZhY2VJbmRleCA9IGZhY2VJbmRleDtcbn07XG59LHtcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMSxcIi4uL21hdGgvdmVjMlwiOjMwfV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNBUEJyb2FkcGhhc2U7XG5cbi8qKlxuICogU3dlZXAgYW5kIHBydW5lIGJyb2FkcGhhc2UgYWxvbmcgb25lIGF4aXMuXG4gKlxuICogQGNsYXNzIFNBUEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBTQVBCcm9hZHBoYXNlKCl7XG4gICAgQnJvYWRwaGFzZS5jYWxsKHRoaXMsQnJvYWRwaGFzZS5TQVApO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBib2RpZXMgY3VycmVudGx5IGluIHRoZSBicm9hZHBoYXNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzTGlzdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNMaXN0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXhpcyB0byBzb3J0IGFsb25nLiAwIG1lYW5zIHgtYXhpcyBhbmQgMSB5LWF4aXMuIElmIHlvdXIgYm9kaWVzIGFyZSBtb3JlIHNwcmVhZCBvdXQgb3ZlciB0aGUgWCBheGlzLCBzZXQgYXhpc0luZGV4IHRvIDAsIGFuZCB5b3Ugd2lsbCBnYWluIHNvbWUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNJbmRleFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5heGlzSW5kZXggPSAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoYXQuYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgIHZhciBpZHggPSB0aGF0LmF4aXNMaXN0LmluZGV4T2YoZS5ib2R5KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICB0aGF0LmF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIENoYW5nZSB0aGUgd29ybGRcbiAqIEBtZXRob2Qgc2V0V29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMuYXhpc0xpc3QsIHdvcmxkLmJvZGllcyk7XG5cbiAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcbiAgICB3b3JsZFxuICAgICAgICAub2ZmKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKVxuICAgICAgICAub2ZmKFwicmVtb3ZlQm9keVwiLHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcblxuICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxuICAgIHdvcmxkLm9uKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKS5vbihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG59O1xuXG4vKipcbiAqIFNvcnRzIGJvZGllcyBhbG9uZyBhbiBheGlzLlxuICogQG1ldGhvZCBzb3J0QXhpc0xpc3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdCA9IGZ1bmN0aW9uKGEsIGF4aXNJbmRleCl7XG4gICAgYXhpc0luZGV4ID0gYXhpc0luZGV4fDA7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gdi5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc29ydExpc3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICBTQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdChib2RpZXMsIGF4aXNJbmRleCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQsXG4gICAgICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgYWxsIEFBQkJzIGlmIG5lZWRlZFxuICAgIHZhciBsID0gYm9kaWVzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tsXTtcbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHRoZSBsaXN0c1xuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgWCBsaXN0XG4gICAgZm9yKHZhciBpPTAsIE49Ym9kaWVzLmxlbmd0aHwwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8TjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgLy8gQm91bmRzIG92ZXJsYXA/XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSAoYmouYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gYmkuYWFiYi51cHBlckJvdW5kW2F4aXNJbmRleF0pO1xuICAgICAgICAgICAgaWYoIW92ZXJsYXBzKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgdGhpcy5zb3J0TGlzdCgpO1xuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuICAgIHZhciBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi91dGlscy9VdGlsc1wiOjU3fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIEJhc2UgY29uc3RyYWludCBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChib2R5QSwgYm9keUIsIHR5cGUsIG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgY29uc3RyYWludC4gTWF5IGJlIG9uZSBvZiBDb25zdHJhaW50LkRJU1RBTkNFLCBDb25zdHJhaW50LkdFQVIsIENvbnN0cmFpbnQuTE9DSywgQ29uc3RyYWludC5QUklTTUFUSUMgb3IgQ29uc3RyYWludC5SRVZPTFVURS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQgOiB0cnVlLFxuICAgICAgICB3YWtlVXBCb2RpZXMgOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIHRvIGJlIHNvbHZlZCBpbiB0aGlzIGNvbnN0cmFpbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGNvbGxpZGUuXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGVDb25uZWN0ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xuXG4gICAgLy8gV2FrZSB1cCBib2RpZXMgd2hlbiBjb25uZWN0ZWRcbiAgICBpZihvcHRpb25zLndha2VVcEJvZGllcyl7XG4gICAgICAgIGlmKGJvZHlBKXtcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlCKXtcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGNvbnN0cmFpbnQgcGFyYW1ldGVycyBiZWZvcmUgc29sdmUuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyFcIik7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBESVNUQU5DRVxuICovXG5Db25zdHJhaW50LkRJU1RBTkNFID0gMTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gR0VBUlxuICovXG5Db25zdHJhaW50LkdFQVIgPSAyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0NLXG4gKi9cbkNvbnN0cmFpbnQuTE9DSyA9IDM7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFBSSVNNQVRJQ1xuICovXG5Db25zdHJhaW50LlBSSVNNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFJFVk9MVVRFXG4gKi9cbkNvbnN0cmFpbnQuUkVWT0xVVEUgPSA1O1xuXG4vKipcbiAqIFNldCBzdGlmZm5lc3MgZm9yIHRoaXMgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0U3RpZmZuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGVxLnN0aWZmbmVzcyA9IHN0aWZmbmVzcztcbiAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHJlbGF4YXRpb24gZm9yIHRoaXMgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0UmVsYXhhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF4YXRpb25cbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuc2V0UmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBlcS5yZWxheGF0aW9uID0gcmVsYXhhdGlvbjtcbiAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1N31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgdHJpZXMgdG8ga2VlcCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gYm9kaWVzIGNvbnN0YW50LlxuICpcbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlBLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JCXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QiwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tYXhGb3JjZT1OdW1iZXIuTUFYX1ZBTFVFXSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gSWYgZGlzdGFuY2UgaXMgbm90IGdpdmVuIGFzIGFuIG9wdGlvbiwgdGhlbiB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMgaXMgdXNlZC5cbiAqICAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIHRoZSBib2RpZXMgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBoYXZlIGEgZGlzdGFuY2Ugb2YgMiBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuXG4gKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgZGlzdGFuY2UgYW5kIGFuY2hvcnNcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIGRpc3RhbmNlOiAxLCAgICAgICAgICAvLyBEaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIHBvaW50c1xuICogICAgICAgICBsb2NhbEFuY2hvckE6IFsxLCAwXSwgLy8gUG9pbnQgb24gYm9keUFcbiAqICAgICAgICAgbG9jYWxBbmNob3JCOiBbLTEsIDBdIC8vIFBvaW50IG9uIGJvZHlCXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgbG9jYWxBbmNob3JBOlswLDBdLFxuICAgICAgICBsb2NhbEFuY2hvckI6WzAsMF1cbiAgICB9KTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuRElTVEFOQ0Usb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBhbmNob3IgaW4gYm9keSBBLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy5sb2NhbEFuY2hvckFbMF0sIG9wdGlvbnMubG9jYWxBbmNob3JBWzFdKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEIuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQlswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckJbMV0pO1xuXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBO1xuICAgIHZhciBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSB0byBrZWVwLlxuICAgICAqIEBwcm9wZXJ0eSBkaXN0YW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5kaXN0YW5jZSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBjdXJyZW50IHdvcmxkIGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgYm9keUIucG9zaXRpb24sIHdvcmxkQW5jaG9yQik7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHdvcmxkQW5jaG9yQSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdmVjMi5sZW5ndGgocik7XG4gICAgfVxuXG4gICAgdmFyIG1heEZvcmNlO1xuICAgIGlmKHR5cGVvZihvcHRpb25zLm1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgKXtcbiAgICAgICAgbWF4Rm9yY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEZvcmNlID0gb3B0aW9ucy5tYXhGb3JjZTtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7IC8vIEp1c3QgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFsgbm9ybWFsIF07XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEZvcmNlXG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLy8gZyA9ICh4aSAtIHhqKS5kb3QobilcbiAgICAvLyBkZy9kdCA9ICh2aSAtIHZqKS5kb3QobikgPSBHKlcgPSBbbiAwIC1uIDBdICogW3ZpIHdpIHZqIHdqXSdcblxuICAgIC8vIC4uLmFuZCBpZiB3ZSB3ZXJlIHRvIGluY2x1ZGUgb2Zmc2V0IHBvaW50czpcbiAgICAvLyBnID1cbiAgICAvLyAgICAgICh4aiArIHJqIC0geGkgLSByaSkuZG90KG4pIC0gZGlzdGFuY2VcbiAgICAvL1xuICAgIC8vIGRnL2R0ID1cbiAgICAvLyAgICAgICh2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkpLmRvdChuKSA9XG4gICAgLy8gICAgICB7IHRlcm0gMiBpcyBuZWFyIHplcm8gfSA9XG4gICAgLy8gICAgICBbLW4gICAtcmkgeCBuICAgbiAgIHJqIHggbl0gKiBbdmkgd2kgdmogd2pdJyA9XG4gICAgLy8gICAgICBHICogV1xuICAgIC8vXG4gICAgLy8gPT4gRyA9IFstbiAtcml4biBuIHJqeG5dXG5cbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHJpID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXG4gICAgdmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIG5vcm1hbC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUocmksIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgeGosIHJqKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgcmkpO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCB4aSk7XG5cbiAgICAgICAgLy92ZWMyLnN1YihyLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdmVjMi5sZW5ndGgocikgLSB0aGF0LmRpc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSBjb250YWN0IGNvbnN0cmFpbnQgYmlsYXRlcmFsXG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXBwZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBjb25zdHJhaW50IGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cHBlckxpbWl0XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBsb3dlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvd2VyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjb25zdHJhaW50IHBvc2l0aW9uLiBUaGlzIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG59XG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG52YXIgbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbnZhciByaiA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQlxuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbixcbiAgICAgICAgbm9ybWFsRXF1YXRpb24gPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgRyA9IG5vcm1hbC5HO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICB2ZWMyLnJvdGF0ZShyaSwgdGhpcy5sb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShyaiwgdGhpcy5sb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3IgcG9pbnRzIGFuZCBub3JtYWxcbiAgICB2ZWMyLmFkZChuLCB4aiwgcmopO1xuICAgIHZlYzIuc3ViKG4sIG4sIHJpKTtcbiAgICB2ZWMyLnN1YihuLCBuLCB4aSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIubGVuZ3RoKG4pO1xuXG4gICAgdmFyIHZpb2xhdGluZyA9IGZhbHNlO1xuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uID4gdGhpcy51cHBlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gMDtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gLXRoaXMubWF4Rm9yY2U7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy51cHBlckxpbWl0O1xuICAgICAgICAgICAgdmlvbGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uIDwgdGhpcy5sb3dlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLmxvd2VyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgfHwgdGhpcy51cHBlckxpbWl0RW5hYmxlZCkgJiYgIXZpb2xhdGluZyl7XG4gICAgICAgIC8vIE5vIGNvbnN0cmFpbnQgbmVlZGVkLlxuICAgICAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHZlYzIubm9ybWFsaXplKG4sbik7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICB2YXIgcml4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmksIG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgdG8gYmUgdXNlZFxuICogQG1ldGhvZCBzZXRNYXhGb3JjZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlXG4gKi9cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihtYXhGb3JjZSl7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIG5vcm1hbC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICBub3JtYWwubWF4Rm9yY2UgPSAgbWF4Rm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICByZXR1cm4gbm9ybWFsLm1heEZvcmNlO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMixcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1NyxcIi4vQ29uc3RyYWludFwiOjE0fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBBbmdsZUxvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlYXJDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbnN0cmFpbnMgdGhlIGFuZ2xlIG9mIHR3byBib2RpZXMgdG8gZWFjaCBvdGhlciB0byBiZSBlcXVhbC4gSWYgYSBnZWFyIHJhdGlvIGlzIG5vdCBvbmUsIHRoZSBhbmdsZSBvZiBib2R5QSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIGFuZ2xlIG9mIGJvZHlCLlxuICogQGNsYXNzIEdlYXJDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF0gUmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLiBXaWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMgKHRoZSBnZWFyIHJhdGlvIGlzIGFjY291bnRlZCBmb3IpLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLnJhdGlvPTFdIEdlYXIgcmF0aW8uXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMubWF4VG9ycXVlXSBNYXhpbXVtIHRvcnF1ZSB0byBhcHBseS5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICByYXRpbzogMixcbiAqICAgICAgICAgbWF4VG9ycXVlOiAxMDAwXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gR2VhckNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIENvbnN0cmFpbnQuR0VBUiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VhciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkgcmF0aW9cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmF0aW8gPSBvcHRpb25zLnJhdGlvICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJhdGlvIDogMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiBib2R5Qi5hbmdsZSAtIHRoaXMucmF0aW8gKiBib2R5QS5hbmdsZTtcblxuICAgIC8vIFNlbmQgc2FtZSBwYXJhbWV0ZXJzIHRvIHRoZSBlcXVhdGlvblxuICAgIG9wdGlvbnMuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIG9wdGlvbnMucmF0aW8gPSB0aGlzLnJhdGlvO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKSxcbiAgICBdO1xuXG4gICAgLy8gU2V0IG1heCB0b3JxdWVcbiAgICBpZihvcHRpb25zLm1heFRvcnF1ZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgdGhpcy5zZXRNYXhUb3JxdWUob3B0aW9ucy5tYXhUb3JxdWUpO1xuICAgIH1cbn1cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZWFyQ29uc3RyYWludDtcblxuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxID0gdGhpcy5lcXVhdGlvbnNbMF07XG4gICAgaWYoZXEucmF0aW8gIT09IHRoaXMucmF0aW8pe1xuICAgICAgICBlcS5zZXRSYXRpbyh0aGlzLnJhdGlvKTtcbiAgICB9XG4gICAgZXEuYW5nbGUgPSB0aGlzLmFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcbiAqL1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgdGhpcy5lcXVhdGlvbnNbMF0uc2V0TWF4VG9ycXVlKHRvcnF1ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGdldE1heFRvcnF1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb25cIjoyMCxcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2tDb25zdHJhaW50O1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuTE9DSyxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9ICggdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBvcHRpb25zLm1heEZvcmNlICk7XG5cbiAgICB2YXIgbG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCIHx8IDA7XG5cbiAgICAvLyBVc2UgMyBlcXVhdGlvbnM6XG4gICAgLy8gZ3ggPSAgICh4aiAtIHhpIC0gbCkgKiB4aGF0ID0gMFxuICAgIC8vIGd5ID0gICAoeGogLSB4aSAtIGwpICogeWhhdCA9IDBcbiAgICAvLyBnciA9ICAgKHhpIC0geGogKyByKSAqIHRoYXQgPSAwXG4gICAgLy9cbiAgICAvLyAuLi53aGVyZTpcbiAgICAvLyAgIGwgaXMgdGhlIGxvY2FsT2Zmc2V0QiB2ZWN0b3Igcm90YXRlZCB0byB3b3JsZCBpbiBib2R5QSBmcmFtZVxuICAgIC8vICAgciBpcyB0aGUgc2FtZSB2ZWN0b3IgYnV0IHJldmVyc2VkIGFuZCByb3RhdGVkIGZyb20gYm9keUIgZnJhbWVcbiAgICAvLyAgIHhoYXQsIHloYXQgYXJlIHdvcmxkIGF4aXMgdmVjdG9yc1xuICAgIC8vICAgdGhhdCBpcyB0aGUgdGFuZ2VudCBvZiByXG4gICAgLy9cbiAgICAvLyBGb3IgdGhlIGZpcnN0IHR3byBjb25zdHJhaW50cywgd2UgZ2V0XG4gICAgLy8gRypXID0gKHZqIC0gdmkgLSBsZG90ICApICogeGhhdFxuICAgIC8vICAgICA9ICh2aiAtIHZpIC0gd2kgeCBsKSAqIHhoYXRcbiAgICAvL1xuICAgIC8vIFNpbmNlICh3aSB4IGwpICogeGhhdCA9IChsIHggeGhhdCkgKiB3aSwgd2UgZ2V0XG4gICAgLy8gRypXID0gWyAtMSAgIDAgICAoLWwgeCB4aGF0KSAgMSAgIDAgICAwXSAqIFt2aSB3aSB2aiB3al1cbiAgICAvL1xuICAgIC8vIFRoZSBsYXN0IGNvbnN0cmFpbnQgZ2l2ZXNcbiAgICAvLyBHVyA9ICh2aSAtIHZqICsgd2ogeCByKSAqIHRoYXRcbiAgICAvLyAgICA9IFsgIHRoYXQgICAwICAtdGhhdCAgKHIgeCB0KSBdXG5cbiAgICB2YXIgeCA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgeSA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgcm90ID0gICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIHZhciBsID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZyA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5zdWIoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgbCk7XG4gICAgICAgIHJldHVybiBnWzBdO1xuICAgIH07XG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMV07XG4gICAgfTtcbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHJvdC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUIuYW5nbGUgLSB0aGF0LmxvY2FsQW5nbGVCKTtcbiAgICAgICAgdmVjMi5zY2FsZShyLHIsLTEpO1xuICAgICAgICB2ZWMyLnN1YihnLGJvZHlBLnBvc2l0aW9uLGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQoZyxnLHIpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LHIsLU1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxPZmZzZXRCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMubG9jYWxPZmZzZXRCKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG9jYWxPZmZzZXRCLCBvcHRpb25zLmxvY2FsT2Zmc2V0Qik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgdmVjMi5zdWIodGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMubG9jYWxPZmZzZXRCLCB0aGlzLmxvY2FsT2Zmc2V0QiwgLWJvZHlBLmFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvY2FsQW5nbGVCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuZ2xlQiA9IDA7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubG9jYWxBbmdsZUIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdFxuICAgICAgICB0aGlzLmxvY2FsQW5nbGVCID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHJvdCk7XG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG59XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZvcmNlIHRvIGJlIGFwcGxpZWQuXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yY2VcbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9ICBmb3JjZTtcbiAgICAgICAgZXFzW2ldLm1pbkZvcmNlID0gLWZvcmNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UuXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTtcblxudmFyIGwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCk7XG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4ID0gICB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgeSA9ICAgdGhpcy5lcXVhdGlvbnNbMV0sXG4gICAgICAgIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZlYzIucm90YXRlKGwsdGhpcy5sb2NhbE9mZnNldEIsYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHIsdGhpcy5sb2NhbE9mZnNldEIsYm9keUIuYW5nbGUgLSB0aGlzLmxvY2FsQW5nbGVCKTtcbiAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh0LHIsTWF0aC5QSS8yKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0LHQpO1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgobCx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHlBeGlzKTtcbiAgICB5LkdbNF0gPSAgMTtcblxuICAgIHJvdC5HWzBdID0gIC10WzBdO1xuICAgIHJvdC5HWzFdID0gIC10WzFdO1xuICAgIHJvdC5HWzNdID0gIHRbMF07XG4gICAgcm90LkdbNF0gPSAgdFsxXTtcbiAgICByb3QuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHIsdCk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgUm90YXRpb25hbExvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpc21hdGljQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgb25seSBhbGxvd3MgYm9kaWVzIHRvIG1vdmUgYWxvbmcgYSBsaW5lLCByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuaWZvcmNlMmQubmV0L2IyZHR1dC9qb2ludHMtcHJpc21hdGljXCI+dGhpcyB0dXRvcmlhbDwvYT4uIEFsc28gY2FsbGVkIFwic2xpZGVyIGNvbnN0cmFpbnRcIi5cbiAqXG4gKiBAY2xhc3MgUHJpc21hdGljQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gICAgICAgICAgICAgICAgTWF4IGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgICAgICAgICAgIEJvZHkgQSdzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdICAgICAgICAgICAgQm9keSBCJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQXhpc0FdICAgICAgICAgICAgICBBbiBheGlzLCBkZWZpbmVkIGluIGJvZHkgQSBmcmFtZSwgdGhhdCBib2R5IEIncyBhbmNob3IgcG9pbnQgbWF5IHNsaWRlIGFsb25nLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2tdICAgSWYgc2V0IHRvIHRydWUsIGJvZHlCIHdpbGwgYmUgZnJlZSB0byByb3RhdGUgYXJvdW5kIGl0cyBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLnVwcGVyTGltaXRdXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLmxvd2VyTGltaXRdXG4gKiBAdG9kbyBBYmlsaXR5IHRvIGNyZWF0ZSB1c2luZyBvbmx5IGEgcG9pbnQgYW5kIGEgd29ybGRBeGlzXG4gKi9cbmZ1bmN0aW9uIFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LlBSSVNNQVRJQyxvcHRpb25zKTtcblxuICAgIC8vIEdldCBhbmNob3JzXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgICAgICBsb2NhbEF4aXNBID0gdmVjMi5mcm9tVmFsdWVzKDEsMCksXG4gICAgICAgIGxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KGxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEF4aXNBKXsgdmVjMi5jb3B5KGxvY2FsQXhpc0EsICAgb3B0aW9ucy5sb2NhbEF4aXNBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JCKXsgdmVjMi5jb3B5KGxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEF4aXNBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBeGlzQSA9IGxvY2FsQXhpc0E7XG5cbiAgICAvKlxuXG4gICAgVGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGZvciB0aGUgY29tbW9uIGF4aXMgcG9pbnQgaXNcblxuICAgICAgICBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdCAgIDo9ICBnZyp0XG5cbiAgICB3aGVyZSByIGFyZSBib2R5LWxvY2FsIGFuY2hvciBwb2ludHMsIGFuZCB0IGlzIGEgdGFuZ2VudCB0byB0aGUgY29uc3RyYWludCBheGlzIGRlZmluZWQgaW4gYm9keSBpIGZyYW1lLlxuXG4gICAgICAgIGdkb3QgPSAgKCB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkgKSAqIHQgKyAoIHhqICsgcmogLSB4aSAtIHJpICkgKiAoIHdpIHggdCApXG5cbiAgICBOb3RlIHRoZSB1c2Ugb2YgdGhlIGNoYWluIHJ1bGUuIE5vdyB3ZSBpZGVudGlmeSB0aGUgamFjb2JpYW5cblxuICAgICAgICBHKlcgPSBbIC10ICAgICAgLXJpIHggdCArIHQgeCBnZyAgICAgdCAgICByaiB4IHQgXSAqIFt2aSB3aSB2aiB3al1cblxuICAgIFRoZSByb3RhdGlvbmFsIHBhcnQgaXMganVzdCBhIHJvdGF0aW9uIGxvY2suXG5cbiAgICAgKi9cblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXhGb3JjZSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvLyBUcmFuc2xhdGlvbmFsIHBhcnRcbiAgICB2YXIgdHJhbnMgPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcbiAgICB2YXIgcmkgPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgcmogPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZ2cgPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdCA9ICBuZXcgdmVjMi5jcmVhdGUoKTtcbiAgICB0cmFucy5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdFxuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZ2csdCk7XG4gICAgfTtcbiAgICB0cmFucy51cGRhdGVKYWNvYmlhbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG4gICAgICAgIHZlYzIucm90YXRlKHJpLGxvY2FsQW5jaG9yQSxib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHJqLGxvY2FsQW5jaG9yQixib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGdnLHhqLHJqKTtcbiAgICAgICAgdmVjMi5zdWIoZ2csZ2cseGkpO1xuICAgICAgICB2ZWMyLnN1YihnZyxnZyxyaSk7XG4gICAgICAgIHZlYzIucm90YXRlKHQsbG9jYWxBeGlzQSxib2R5QS5hbmdsZStNYXRoLlBJLzIpO1xuXG4gICAgICAgIEdbMF0gPSAtdFswXTtcbiAgICAgICAgR1sxXSA9IC10WzFdO1xuICAgICAgICBHWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgocmksdCkgKyB2ZWMyLmNyb3NzTGVuZ3RoKHQsZ2cpO1xuICAgICAgICBHWzNdID0gdFswXTtcbiAgICAgICAgR1s0XSA9IHRbMV07XG4gICAgICAgIEdbNV0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLHQpO1xuICAgIH07XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0cmFucyk7XG5cbiAgICAvLyBSb3RhdGlvbmFsIHBhcnRcbiAgICBpZighb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2spe1xuICAgICAgICB2YXIgcm90ID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiBhbmNob3IgQSByZWxhdGl2ZSB0byBhbmNob3IgQiwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuXG4gICAgLy8gSXMgdGhpcyBvbmUgdXNlZCBhdCBhbGw/XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbG93ZXIgbGltaXQuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHR5cGVvZihvcHRpb25zLmxvd2VyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHlwZW9mKG9wdGlvbnMudXBwZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTG93ZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IHR5cGVvZihvcHRpb25zLmxvd2VyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG93ZXJMaW1pdCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBVcHBlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IHR5cGVvZihvcHRpb25zLnVwcGVyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMudXBwZXJMaW1pdCA6IDE7XG5cbiAgICAvLyBFcXVhdGlvbnMgdXNlZCBmb3IgbGltaXRzXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLy8gU2V0IG1heC9taW4gZm9yY2VzXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb24gdXNlZCBmb3IgdGhlIG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSBtb3RvckVxdWF0aW9uXG4gICAgICogQHR5cGUge0VxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBtb3RvciBzdGF0ZS4gRW5hYmxlIG9yIGRpc2FibGUgdGhlIG1vdG9yIHVzaW5nIC5lbmFibGVNb3RvclxuICAgICAqIEBwcm9wZXJ0eSBtb3RvckVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0YXJnZXQgc3BlZWQgZm9yIHRoZSBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkgbW90b3JTcGVlZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb3RvclNwZWVkID0gMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgbW90b3JFcXVhdGlvbiA9IHRoaXMubW90b3JFcXVhdGlvbjtcbiAgICB2YXIgb2xkID0gbW90b3JFcXVhdGlvbi5jb21wdXRlR1c7XG4gICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR3EgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTtcbiAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKSArIHRoYXQubW90b3JTcGVlZDtcbiAgICB9O1xufVxuXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XG5cbnZhciB3b3JsZEF4aXNBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgb3JpZW50ZWRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICBvcmllbnRlZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgdHJhbnMgPSBlcXNbMF0sXG4gICAgICAgIHVwcGVyTGltaXQgPSB0aGlzLnVwcGVyTGltaXQsXG4gICAgICAgIGxvd2VyTGltaXQgPSB0aGlzLmxvd2VyTGltaXQsXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbiA9IHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24gPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbixcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGxvY2FsQXhpc0EgPSB0aGlzLmxvY2FsQXhpc0EsXG4gICAgICAgIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBLFxuICAgICAgICBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgdGhpbmdzIHRvIHdvcmxkXG4gICAgdmVjMi5yb3RhdGUod29ybGRBeGlzQSwgICAgICBsb2NhbEF4aXNBLCAgICAgIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShvcmllbnRlZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgICAgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIuYWRkKHdvcmxkQW5jaG9yQSwgICAgICAgb3JpZW50ZWRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgdmVjMi5yb3RhdGUob3JpZW50ZWRBbmNob3JCLCBsb2NhbEFuY2hvckIsICAgIGJvZHlCLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh3b3JsZEFuY2hvckIsICAgICAgIG9yaWVudGVkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgdmFyIHJlbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHZlYzIuZG90KHdvcmxkQW5jaG9yQix3b3JsZEF4aXNBKSAtIHZlYzIuZG90KHdvcmxkQW5jaG9yQSx3b3JsZEF4aXNBKTtcblxuICAgIC8vIE1vdG9yXG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICAvLyBHID0gWyBhICAgICBhIHggcmkgICAtYSAgIC1hIHggcmogXVxuICAgICAgICB2YXIgRyA9IHRoaXMubW90b3JFcXVhdGlvbi5HO1xuICAgICAgICBHWzBdID0gd29ybGRBeGlzQVswXTtcbiAgICAgICAgR1sxXSA9IHdvcmxkQXhpc0FbMV07XG4gICAgICAgIEdbMl0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0Esb3JpZW50ZWRBbmNob3JCKTtcbiAgICAgICAgR1szXSA9IC13b3JsZEF4aXNBWzBdO1xuICAgICAgICBHWzRdID0gLXdvcmxkQXhpc0FbMV07XG4gICAgICAgIEdbNV0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZEF4aXNBLG9yaWVudGVkQW5jaG9yQSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgTGltaXRzIHN0cmF0ZWd5OlxuICAgICAgICBBZGQgY29udGFjdCBlcXVhdGlvbiwgd2l0aCBub3JtYWwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cbiAgICAgICAgbWluL21heEZvcmNlIGlzIHNldCBzbyB0aGUgY29uc3RyYWludCBpcyByZXB1bHNpdmUgaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICAgICAgICBTb21lIG9mZnNldCBpcyBhZGRlZCB0byBlaXRoZXIgZXF1YXRpb24uY29udGFjdFBvaW50QSBvciAuY29udGFjdFBvaW50QiB0byBnZXQgdGhlIGNvcnJlY3QgdXBwZXIvbG93ZXIgbGltaXQuXG5cbiAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICAgICAgICB8XG4gICAgICB1cHBlckxpbWl0IHhcbiAgICAgICAgICAgICAgICAgfCAgICAtLS0tLS1cbiAgICAgICAgIGFuY2hvckIgeDwtLS18ICBCIHxcbiAgICAgICAgICAgICAgICAgfCAgICB8ICAgIHxcbiAgICAgICAgLS0tLS0tICAgfCAgICAtLS0tLS1cbiAgICAgICAgfCAgICB8ICAgfFxuICAgICAgICB8ICBBIHwtLT54IGFuY2hvckFcbiAgICAgICAgLS0tLS0tICAgfFxuICAgICAgICAgICAgICAgICB4IGxvd2VyTGltaXRcbiAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgKi9cblxuXG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCAmJiByZWxQb3NpdGlvbiA+IHVwcGVyTGltaXQpe1xuICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXG4gICAgICAgIHZlYzIuc2NhbGUodXBwZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIC0xKTtcbiAgICAgICAgdmVjMi5zdWIodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc2NhbGUodG1wLHdvcmxkQXhpc0EsdXBwZXJMaW1pdCk7XG4gICAgICAgIHZlYzIuYWRkKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLHRtcCk7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPCBsb3dlckxpbWl0KXtcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgY29uc3RyYWludCBub3JtYWwsIGV0Y1xuICAgICAgICB2ZWMyLnNjYWxlKGxvd2VyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAxKTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc2NhbGUodG1wLHdvcmxkQXhpc0EsbG93ZXJMaW1pdCk7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLHRtcCk7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSBtb3RvclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIERpc2FibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbnN0cmFpbnQgbGltaXRzLlxuICogQG1ldGhvZCBzZXRMaW1pdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBsaW1pdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBsaW1pdC5cbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgIGlmKHR5cGVvZihsb3dlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKHVwcGVyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5cbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIxLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvblwiOjI0LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24nKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldm9sdXRlQ29uc3RyYWludDtcblxudmFyIHdvcmxkUGl2b3RBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZFBpdm90QiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpLFxuICAgIGcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cywgbGV0dGluZyB0aGVtIHJvdGF0ZSByZWxhdGl2ZSB0byBlYWNoIG90aGVyIGFyb3VuZCB0aGlzIHBvaW50LlxuICogQGNsYXNzIFJldm9sdXRlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy53b3JsZFBpdm90XSBBIHBpdm90IHBvaW50IGdpdmVuIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBJZiBzcGVjaWZpZWQsIGxvY2FsUGl2b3RBIGFuZCBsb2NhbFBpdm90QiBhcmUgYXV0b21hdGljYWxseSBjb21wdXRlZCBmcm9tIHRoaXMgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RBXSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHdoaWNoIGJvZHlBIGlzIGNvbnN0cmFpbmVkIHRvLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90Ql0gU2VlIGxvY2FsUGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gVGhlIG1heGltdW0gZm9yY2UgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBjb25zdHJhaW4gdGhlIGJvZGllcy5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSByZXZvbHV0ZSBjb25zdHJhaW50IGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHBpdm90IHBvaW50IGluIGJldHdlZW4gdGhlbS5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIHdvcmxkUGl2b3Q6IFswLCAwXVxuICogICAgIH0pO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKlxuICogICAgIC8vIFVzaW5nIGJvZHktbG9jYWwgcGl2b3QgcG9pbnRzLCB0aGUgY29uc3RyYWludCBjb3VsZCBoYXZlIGJlZW4gY29uc3RydWN0ZWQgbGlrZSB0aGlzOlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgbG9jYWxQaXZvdEE6IFsxLCAwXSxcbiAqICAgICAgICAgbG9jYWxQaXZvdEI6IFstMSwgMF1cbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5SRVZPTFVURSxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1heEZvcmNlIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QVxuICAgICAqL1xuICAgIHRoaXMucGl2b3RBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QlxuICAgICAqL1xuICAgIHRoaXMucGl2b3RCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGlmKG9wdGlvbnMud29ybGRQaXZvdCl7XG4gICAgICAgIC8vIENvbXB1dGUgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5zdWIodGhpcy5waXZvdEEsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLnBpdm90Qiwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIC8vIFJvdGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLnBpdm90QSwgdGhpcy5waXZvdEEsIC1ib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMucGl2b3RCLCB0aGlzLnBpdm90QiwgLWJvZHlCLmFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RBLCBvcHRpb25zLmxvY2FsUGl2b3RBKTtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RCLCBvcHRpb25zLmxvY2FsUGl2b3RCKTtcbiAgICB9XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICBdO1xuXG4gICAgdmFyIHggPSBlcXNbMF07XG4gICAgdmFyIHkgPSBlcXNbMV07XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgdGhhdC5waXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHRoYXQucGl2b3RCLCBib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgd29ybGRQaXZvdEEpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx4QXhpcyk7XG4gICAgfTtcblxuICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHRoYXQucGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCB0aGF0LnBpdm90QiwgYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcseUF4aXMpO1xuICAgIH07XG5cbiAgICB5Lm1pbkZvcmNlID0geC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICB5Lm1heEZvcmNlID0geC5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcblxuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW90b3IgaXMgZW5hYmxlZC4gVXNlIC5lbmFibGVNb3RvcigpIHRvIGVuYWJsZSB0aGUgY29uc3RyYWludCBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG1vdG9yRW5hYmxlZFxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RyYWludCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHVwcGVyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGxpbWl0IG9uIHRoZSBjb25zdHJhaW50IGFuZ2xlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBsaW1pdCBvbiB0aGUgY29uc3RyYWludCBhbmdsZS5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IDA7XG5cbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xufVxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmV2b2x1dGVDb25zdHJhaW50O1xuXG4vKipcbiAqIFNldCB0aGUgY29uc3RyYWludCBhbmdsZSBsaW1pdHMuXG4gKiBAbWV0aG9kIHNldExpbWl0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGFuZ2xlIGxpbWl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGFuZ2xlIGxpbWl0LlxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2R5QSA9ICB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9ICB0aGlzLmJvZHlCLFxuICAgICAgICBwaXZvdEEgPSB0aGlzLnBpdm90QSxcbiAgICAgICAgcGl2b3RCID0gdGhpcy5waXZvdEIsXG4gICAgICAgIGVxcyA9ICAgIHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBub3JtYWwgPSBlcXNbMF0sXG4gICAgICAgIHRhbmdlbnQ9IGVxc1sxXSxcbiAgICAgICAgeCA9IGVxc1swXSxcbiAgICAgICAgeSA9IGVxc1sxXSxcbiAgICAgICAgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCxcbiAgICAgICAgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCxcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uO1xuXG4gICAgdmFyIHJlbEFuZ2xlID0gdGhpcy5hbmdsZSA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG5cbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlID4gdXBwZXJMaW1pdCl7XG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbi5hbmdsZSA9IHVwcGVyTGltaXQ7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPCBsb3dlckxpbWl0KXtcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gbG93ZXJMaW1pdDtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2gobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBpc1xuXG4gICAgICAgIGcgPSB4aiArIHJqIC0geGkgLSByaVxuXG4gICAgLi4ud2hlcmUgeGkgYW5kIHhqIGFyZSB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIHJpIGFuZCByaiB3b3JsZC1vcmllbnRlZCBvZmZzZXQgdmVjdG9ycy4gRGlmZmVyZW50aWF0ZTpcblxuICAgICAgICBnZG90ID0gdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpXG5cbiAgICBXZSBzcGxpdCB0aGlzIGludG8geCBhbmQgeSBkaXJlY3Rpb25zLiAobGV0IHggYW5kIHkgYmUgdW5pdCB2ZWN0b3JzIGFsb25nIHRoZSByZXNwZWN0aXZlIGF4ZXMpXG5cbiAgICAgICAgZ2RvdCAqIHggPSAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArICh3aiB4IHJqKSp4IC12aSp4IC0od2kgeCByaSkqeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArIChyaiB4IHgpKndqIC12aSp4IC0ocmkgeCB4KSp3aVxuICAgICAgICAgICAgICAgICA9IFsgLXggICAtKHJpIHggeCkgICB4ICAgKHJqIHggeCldICogW3ZpIHdpIHZqIHdqXVxuICAgICAgICAgICAgICAgICA9IEcqV1xuXG4gICAgLi4uYW5kIHNpbWlsYXIgZm9yIHkuIFdlIGhhdmUgdGhlbiBpZGVudGlmaWVkIHRoZSBqYWNvYmlhbiBlbnRyaWVzIGZvciB4IGFuZCB5IGRpcmVjdGlvbnM6XG5cbiAgICAgICAgR3ggPSBbIHggICAocmogeCB4KSAgIC14ICAgLShyaSB4IHgpXVxuICAgICAgICBHeSA9IFsgeSAgIChyaiB4IHkpICAgLXkgICAtKHJpIHggeSldXG5cbiAgICAgKi9cblxuICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCBwaXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAvLyB0b2RvOiB0aGVzZSBhcmUgYSBiaXQgc3BhcnNlLiBXZSBjb3VsZCBzYXZlIHNvbWUgY29tcHV0YXRpb25zIG9uIG1ha2luZyBjdXN0b20gZXEuY29tcHV0ZUdXIGZ1bmN0aW9ucywgZXRjXG5cbiAgICB4LkdbMF0gPSAtMTtcbiAgICB4LkdbMV0gPSAgMDtcbiAgICB4LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG4gICAgeC5HWzRdID0gIDA7XG4gICAgeC5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIseEF4aXMpO1xuXG4gICAgeS5HWzBdID0gIDA7XG4gICAgeS5HWzFdID0gLTE7XG4gICAgeS5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEseUF4aXMpO1xuICAgIHkuR1szXSA9ICAwO1xuICAgIHkuR1s0XSA9ICAxO1xuICAgIHkuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLHlBeGlzKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbW90b3IgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2QgbW90b3JJc0VuYWJsZWRcbiAqIEBkZXByZWNhdGVkIHVzZSBwcm9wZXJ0eSBtb3RvckVuYWJsZWQgaW5zdGVhZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUubW90b3JJc0VuYWJsZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXRoaXMubW90b3JFbmFibGVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNwZWVkIG9mIHRoZSByb3RhdGlvbmFsIGNvbnN0cmFpbnQgbW90b3JcbiAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICogQHBhcmFtICB7TnVtYmVyfSBzcGVlZFxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9uc1tpXS5yZWxhdGl2ZVZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3BlZWQgb2YgdGhlIHJvdGF0aW9uYWwgY29uc3RyYWludCBtb3RvclxuICogQG1ldGhvZCBnZXRNb3RvclNwZWVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHNwZWVkLCBvciBmYWxzZSBpZiB0aGUgbW90b3IgaXMgbm90IGVuYWJsZWQuXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb25cIjoyNCxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblwiOjI1LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZUxvY2tFcXVhdGlvbjtcblxuLyoqXG4gKiBMb2NrcyB0aGUgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGUgY29uc3RyYWludCB0cmllcyB0byBrZWVwIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLCBsb2NhbCBpbiBlYWNoIGJvZHksIHRvIHplcm8uIFRoZSBsb2NhbCBhbmdsZSBpbiBib2R5IGkgaXMgYSBwYXJhbWV0ZXIuXG4gKlxuICogQGNsYXNzIEFuZ2xlTG9ja0VxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHkgQS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYXRpb10gR2VhciByYXRpb1xuICovXG5mdW5jdGlvbiBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdlYXIgcmF0aW8uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHNldFJhdGlvXG4gICAgICovXG4gICAgdGhpcy5yYXRpbyA9IHR5cGVvZihvcHRpb25zLnJhdGlvKT09PVwibnVtYmVyXCIgPyBvcHRpb25zLnJhdGlvIDogMTtcblxuICAgIHRoaXMuc2V0UmF0aW8odGhpcy5yYXRpbyk7XG59XG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xuXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5yYXRpbyAqIHRoaXMuYm9keUEuYW5nbGUgLSB0aGlzLmJvZHlCLmFuZ2xlICsgdGhpcy5hbmdsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBnZWFyIHJhdGlvIGZvciB0aGlzIGVxdWF0aW9uXG4gKiBAbWV0aG9kIHNldFJhdGlvXG4gKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAqL1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLnNldFJhdGlvID0gZnVuY3Rpb24ocmF0aW8pe1xuICAgIHZhciBHID0gdGhpcy5HO1xuICAgIEdbMl0gPSAgcmF0aW87XG4gICAgR1s1XSA9IC0xO1xuICAgIHRoaXMucmF0aW8gPSByYXRpbztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBlcXVhdGlvbi5cbiAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXG4gKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXG4gKi9cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHRoaXMubWF4Rm9yY2UgPSAgdG9ycXVlO1xuICAgIHRoaXMubWluRm9yY2UgPSAtdG9ycXVlO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4vRXF1YXRpb25cIjoyMn1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0RXF1YXRpb247XG5cbi8qKlxuICogTm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24uIFRyaWVzIHRvIG1ha2UgdGhlIGNvbnRhY3RQb2ludEEgYW5kIGNvbnRhY3RQb2ludEIgdmVjdG9ycyBjb2luY2lkZSwgd2hpbGUga2VlcGluZyB0aGUgYXBwbGllZCBmb3JjZSByZXB1bHNpdmUuXG4gKlxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgMCwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBWZWN0b3IgZnJvbSBib2R5IGkgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMi5jcmVhdGUoKTtcbiAgICB0aGlzLnBlbmV0cmF0aW9uVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkLW9yaWVudGVkIHZlY3RvciBmcm9tIGJvZHkgQSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbCB2ZWN0b3IsIHBvaW50aW5nIG91dCBvZiBib2R5IGlcbiAgICAgKiBAcHJvcGVydHkgbm9ybWFsQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3RpdHV0aW9uIHRvIHVzZSAoMD1ubyBib3VuY2luZXNzLCAxPW1heCBib3VuY2luZXNzKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBpbXBhY3QgYmV0d2VlbiB0aGUgYm9kaWVzIChub3QgcGVyc2lzdGFudCBjb250YWN0KS5cbiAgICAgKiBAcHJvcGVydHkgZmlyc3RJbXBhY3RcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0SW1wYWN0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVBXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb250YWN0LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBudWxsO1xufVxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICByaSA9IHRoaXMuY29udGFjdFBvaW50QSxcbiAgICAgICAgcmogPSB0aGlzLmNvbnRhY3RQb2ludEIsXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb247XG5cbiAgICB2YXIgcGVuZXRyYXRpb25WZWMgPSB0aGlzLnBlbmV0cmF0aW9uVmVjLFxuICAgICAgICBuID0gdGhpcy5ub3JtYWxBLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgdmFyIHJpeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaixuKTtcblxuICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxuICAgIEdbMF0gPSAtblswXTtcbiAgICBHWzFdID0gLW5bMV07XG4gICAgR1syXSA9IC1yaXhuO1xuICAgIEdbM10gPSBuWzBdO1xuICAgIEdbNF0gPSBuWzFdO1xuICAgIEdbNV0gPSByanhuO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHEgPSB4aityaiAtKHhpK3JpKSBpLmUuIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcbiAgICB2ZWMyLmFkZChwZW5ldHJhdGlvblZlYyx4aixyaik7XG4gICAgdmVjMi5zdWIocGVuZXRyYXRpb25WZWMscGVuZXRyYXRpb25WZWMseGkpO1xuICAgIHZlYzIuc3ViKHBlbmV0cmF0aW9uVmVjLHBlbmV0cmF0aW9uVmVjLHJpKTtcblxuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgdmFyIEdXLCBHcTtcbiAgICBpZih0aGlzLmZpcnN0SW1wYWN0ICYmIHRoaXMucmVzdGl0dXRpb24gIT09IDApe1xuICAgICAgICBHcSA9IDA7XG4gICAgICAgIEdXID0gKDEvYikqKDErdGhpcy5yZXN0aXR1dGlvbikgKiB0aGlzLmNvbXB1dGVHVygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEdxID0gdmVjMi5kb3QobixwZW5ldHJhdGlvblZlYykgKyB0aGlzLm9mZnNldDtcbiAgICAgICAgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIH1cblxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHZhciBCID0gLSBHcSAqIGEgLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbnZhciB2aSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdmogPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbFZlbCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGl2ZSB2ZWxvY2l0eSBhbG9uZyB0aGUgbm9ybWFsIHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5nZXRWZWxvY2l0eUFsb25nTm9ybWFsID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMuYm9keUEuZ2V0VmVsb2NpdHlBdFBvaW50KHZpLCB0aGlzLmNvbnRhY3RQb2ludEEpO1xuICAgIHRoaXMuYm9keUIuZ2V0VmVsb2NpdHlBdFBvaW50KHZqLCB0aGlzLmNvbnRhY3RQb2ludEIpO1xuXG4gICAgdmVjMi5zdWJ0cmFjdChyZWxWZWwsIHZpLCB2aik7XG5cbiAgICByZXR1cm4gdmVjMi5kb3QodGhpcy5ub3JtYWxBLCByZWxWZWwpO1xufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0VxdWF0aW9uXCI6MjJ9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEVxdWF0aW9uO1xuXG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpLFxuICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKSxcbiAgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBlcXVhdGlvbnMuXG4gKiBAY2xhc3MgRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QSBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluRm9yY2UgTWluaW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogLU51bWJlci5NQVhfVkFMVUVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LiBEZWZhdWx0OiBOdW1iZXIuTUFYX1ZBTFVFXG4gKi9cbmZ1bmN0aW9uIEVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWluRm9yY2UsIG1heEZvcmNlKXtcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkgd2hlbiBzb2x2aW5nLlxuICAgICAqIEBwcm9wZXJ0eSBtaW5Gb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5Gb3JjZSA9IHR5cGVvZihtaW5Gb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gLU51bWJlci5NQVhfVkFMVUUgOiBtaW5Gb3JjZTtcblxuICAgIC8qKlxuICAgICAqIE1heCBmb3JjZSB0byBhcHBseSB3aGVuIHNvbHZpbmcuXG4gICAgICogQHByb3BlcnR5IG1heEZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1ZBTFVFIDogbWF4Rm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnRcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyBvZiB0aGlzIGVxdWF0aW9uLiBUeXBpY2FsbHkgY2hvc2VuIHRvIGEgbGFyZ2UgbnVtYmVyICh+MWU3KSwgYnV0IGNhbiBiZSBjaG9zZW4gc29tZXdoYXQgZnJlZWx5IHRvIGdldCBhIHN0YWJsZSBzaW11bGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWUgc3RlcHMgbmVlZGVkIHRvIHN0YWJpbGl6ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbi4gVHlwaWNhbGx5IGJldHdlZW4gMyBhbmQgNSB0aW1lIHN0ZXBzLlxuICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSmFjb2JpYW4gZW50cnkgb2YgdGhpcyBlcXVhdGlvbi4gNiBudW1iZXJzLCAzIHBlciBib2R5ICh4LHksYW5nbGUpLlxuICAgICAqIEBwcm9wZXJ0eSBHXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuRyA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKDYpO1xuICAgIGZvcih2YXIgaT0wOyBpPDY7IGkrKyl7XG4gICAgICAgIHRoaXMuR1tpXT0wO1xuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYSA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmVwc2lsb24gPSAwO1xuICAgIHRoaXMudGltZVN0ZXAgPSAxLzYwO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHN0aWZmbmVzcyBvciByZWxheGF0aW9uIHdhcyBjaGFuZ2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbmVlZHNVcGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgY29uc3RyYWludCBtdWx0aXBsaWVyIGZyb20gdGhlIGxhc3Qgc29sdmUuIFRoaXMgaXMgbW9zdGx5IGVxdWl2YWxlbnQgdG8gdGhlIGZvcmNlIHByb2R1Y2VkIGJ5IHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBtdWx0aXBsaWVyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVsb2NpdHkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlbGF0aXZlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGVxdWF0aW9uIGlzIGVuYWJsZWQgb3Igbm90LiBJZiB0cnVlLCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbn1cbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWF0aW9uO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0aWZmbmVzcyB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfU1RJRkZORVNTXG4gKiBAZGVmYXVsdCAxZTZcbiAqL1xuRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1MgPSAxZTY7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVsYXhhdGlvbiB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfUkVMQVhBVElPTlxuICogQGRlZmF1bHQgNFxuICovXG5FcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT04gPSA0O1xuXG4vKipcbiAqIENvbXB1dGUgU1BPT0sgcGFyYW1ldGVycyAuYSwgLmIgYW5kIC5lcHNpbG9uIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYXJhbWV0ZXJzLiBTZWUgZXF1YXRpb25zIDksIDEwIGFuZCAxMSBpbiB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGZcIj5TUE9PSyBub3RlczwvYT4uXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5yZWxheGF0aW9uLFxuICAgICAgICBoID0gdGhpcy50aW1lU3RlcDtcblxuICAgIHRoaXMuYSA9IDQuMCAvIChoICogKDEgKyA0ICogZCkpO1xuICAgIHRoaXMuYiA9ICg0LjAgKiBkKSAvICgxICsgNCAqIGQpO1xuICAgIHRoaXMuZXBzaWxvbiA9IDQuMCAvIChoICogaCAqIGsgKiAoMSArIDQgKiBkKSk7XG5cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgamFjb2JpYW4gZW50cnkgd2l0aCBjb3JyZXNwb25kaW5nIHBvc2l0aW9ucyBvciB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGdtdWx0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5nbXVsdCA9IGZ1bmN0aW9uKEcsdmksd2ksdmosd2ope1xuICAgIHJldHVybiAgR1swXSAqIHZpWzBdICtcbiAgICAgICAgICAgIEdbMV0gKiB2aVsxXSArXG4gICAgICAgICAgICBHWzJdICogd2kgK1xuICAgICAgICAgICAgR1szXSAqIHZqWzBdICtcbiAgICAgICAgICAgIEdbNF0gKiB2alsxXSArXG4gICAgICAgICAgICBHWzVdICogd2o7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBSSFMgb2YgdGhlIFNQT09LIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGNvbXB1dGVCXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7XG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgcmV0dXJuIC0gR3EgKiBhIC0gR1cgKiBiIC0gR2lNZipoO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqcSwgd2hlcmUgcSBhcmUgdGhlIGdlbmVyYWxpemVkIGJvZHkgY29vcmRpbmF0ZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBxaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcWogPSB2ZWMyLmNyZWF0ZSgpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB4aSA9IGJpLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJqLnBvc2l0aW9uLFxuICAgICAgICBhaSA9IGJpLmFuZ2xlLFxuICAgICAgICBhaiA9IGJqLmFuZ2xlO1xuXG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRywgcWksIGFpLCBxaiwgYWopICsgdGhpcy5vZmZzZXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKSArIHRoaXMucmVsYXRpdmVWZWxvY2l0eTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdmkgPSBiaS52bGFtYmRhLFxuICAgICAgICB2aiA9IGJqLnZsYW1iZGEsXG4gICAgICAgIHdpID0gYmkud2xhbWJkYSxcbiAgICAgICAgd2ogPSBiai53bGFtYmRhO1xuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqaW52KE0pXFwqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgY29tcHV0ZUdpTWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGlNZmkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGlNZmogPSB2ZWMyLmNyZWF0ZSgpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1mID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGZpID0gYmkuZm9yY2UsXG4gICAgICAgIHRpID0gYmkuYW5ndWxhckZvcmNlLFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0aiA9IGJqLmFuZ3VsYXJGb3JjZSxcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICB2ZWMyLnNjYWxlKGlNZmksIGZpLCBpbnZNYXNzaSk7XG4gICAgdmVjMi5tdWx0aXBseShpTWZpLCBiaS5tYXNzTXVsdGlwbGllciwgaU1maSk7XG4gICAgdmVjMi5zY2FsZShpTWZqLCBmaixpbnZNYXNzaik7XG4gICAgdmVjMi5tdWx0aXBseShpTWZqLCBiai5tYXNzTXVsdGlwbGllciwgaU1maik7XG5cbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLGlNZmksdGkqaW52SWksaU1maix0aippbnZJaik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpHJ1xuICogQG1ldGhvZCBjb21wdXRlR2lNR3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIHJldHVybiAgR1swXSAqIEdbMF0gKiBpbnZNYXNzaSAqIGJpLm1hc3NNdWx0aXBsaWVyWzBdICtcbiAgICAgICAgICAgIEdbMV0gKiBHWzFdICogaW52TWFzc2kgKiBiaS5tYXNzTXVsdGlwbGllclsxXSArXG4gICAgICAgICAgICBHWzJdICogR1syXSAqICAgIGludklpICtcbiAgICAgICAgICAgIEdbM10gKiBHWzNdICogaW52TWFzc2ogKiBiai5tYXNzTXVsdGlwbGllclswXSArXG4gICAgICAgICAgICBHWzRdICogR1s0XSAqIGludk1hc3NqICogYmoubWFzc011bHRpcGxpZXJbMV0gK1xuICAgICAgICAgICAgR1s1XSAqIEdbNV0gKiAgICBpbnZJajtcbn07XG5cbnZhciBhZGRUb1dsYW1iZGFfdGVtcCA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX0dpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfR2ogPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9yaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX3JqID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfTWRpYWcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhbGFtYmRhXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5hZGRUb1dsYW1iZGEgPSBmdW5jdGlvbihkZWx0YWxhbWJkYSl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXAsXG4gICAgICAgIEdpID0gYWRkVG9XbGFtYmRhX0dpLFxuICAgICAgICBHaiA9IGFkZFRvV2xhbWJkYV9HaixcbiAgICAgICAgcmkgPSBhZGRUb1dsYW1iZGFfcmksXG4gICAgICAgIHJqID0gYWRkVG9XbGFtYmRhX3JqLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgTWRpYWcgPSBhZGRUb1dsYW1iZGFfTWRpYWcsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICBHaVswXSA9IEdbMF07XG4gICAgR2lbMV0gPSBHWzFdO1xuICAgIEdqWzBdID0gR1szXTtcbiAgICBHalsxXSA9IEdbNF07XG5cbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XG4gICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBHaSwgaW52TWFzc2kqZGVsdGFsYW1iZGEpO1xuICAgIHZlYzIubXVsdGlwbHkodGVtcCwgdGVtcCwgYmkubWFzc011bHRpcGxpZXIpO1xuICAgIHZlYzIuYWRkKCBiaS52bGFtYmRhLCBiaS52bGFtYmRhLCB0ZW1wKTtcbiAgICAvLyBUaGlzIGltcHVsc2UgaXMgaW4gdGhlIG9mZnNldCBmcmFtZVxuICAgIC8vIEFsc28gYWRkIGNvbnRyaWJ1dGlvbiB0byBhbmd1bGFyXG4gICAgLy9iaS53bGFtYmRhIC09IHZlYzIuY3Jvc3NMZW5ndGgodGVtcCxyaSk7XG4gICAgYmkud2xhbWJkYSArPSBpbnZJaSAqIEdbMl0gKiBkZWx0YWxhbWJkYTtcblxuXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBHaiwgaW52TWFzc2oqZGVsdGFsYW1iZGEpO1xuICAgIHZlYzIubXVsdGlwbHkodGVtcCwgdGVtcCwgYmoubWFzc011bHRpcGxpZXIpO1xuICAgIHZlYzIuYWRkKCBiai52bGFtYmRhLCBiai52bGFtYmRhLCB0ZW1wKTtcbiAgICAvL2JqLndsYW1iZGEgLT0gdmVjMi5jcm9zc0xlbmd0aCh0ZW1wLHJqKTtcbiAgICBiai53bGFtYmRhICs9IGludklqICogR1s1XSAqIGRlbHRhbGFtYmRhO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEdcXCppbnYoTSlcXCpHJyArIGVwc1xuICogQG1ldGhvZCBjb21wdXRlSW52Q1xuICogQHBhcmFtICB7TnVtYmVyfSBlcHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVJbnZDID0gZnVuY3Rpb24oZXBzKXtcbiAgICByZXR1cm4gMS4wIC8gKHRoaXMuY29tcHV0ZUdpTUd0KCkgKyBlcHMpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1N31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnRcbiAqXG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEEgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBCIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGFuZ2VudCB2ZWN0b3IgdGhhdCB0aGUgZnJpY3Rpb24gZm9yY2Ugd2lsbCBhY3QgYWxvbmcuIFdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSB0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudCA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWN0RXF1YXRpb25zIGNvbm5lY3RlZCB0byB0aGlzIGZyaWN0aW9uIGVxdWF0aW9uLiBUaGUgY29udGFjdCBlcXVhdGlvbnMgY2FuIGJlIHVzZWQgdG8gcmVzY2FsZSB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZnJpY3Rpb24uIElmIG1vcmUgdGhhbiBvbmUgY29udGFjdCBlcXVhdGlvbiBpcyBnaXZlbiwgdGhlbiB0aGUgbWF4IGZvcmNlIGNhbiBiZSBzZXQgdG8gdGhlIGF2ZXJhZ2UuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Q29udGFjdEVxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQS4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBmcmljdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqIEB0b2RvIE5lZWRlZD8gVGhlIHNoYXBlIGNhbiBiZSBsb29rZWQgdXAgdmlhIGNvbnRhY3RFcXVhdGlvbi5zaGFwZUIuLi5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG59XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIFNldCB0aGUgc2xpcHBpbmcgY29uZGl0aW9uIGZvciB0aGUgY29uc3RyYWludC4gVGhlIGZyaWN0aW9uIGZvcmNlIGNhbm5vdCBiZVxuICogbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0U2xpcEZvcmNlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICovXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTbGlwRm9yY2UgPSBmdW5jdGlvbihzbGlwRm9yY2Upe1xuICAgIHRoaXMubWF4Rm9yY2UgPSBzbGlwRm9yY2U7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC1zbGlwRm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0U2xpcEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmdldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubWF4Rm9yY2U7XG59O1xuXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgdCA9IHRoaXMudCxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcbiAgICBHWzBdID0gLXRbMF07XG4gICAgR1sxXSA9IC10WzFdO1xuICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KTtcbiAgICBHWzNdID0gdFswXTtcbiAgICBHWzRdID0gdFsxXTtcbiAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcblxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1NyxcIi4vRXF1YXRpb25cIjoyMn1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbExvY2tFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5QS5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICAxO1xuICAgIEdbNV0gPSAtMTtcbn1cblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbnZhciB3b3JsZFZlY3RvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkVmVjdG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckEseEF4aXMsdGhpcy5ib2R5QS5hbmdsZSt0aGlzLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckIseUF4aXMsdGhpcy5ib2R5Qi5hbmdsZSk7XG4gICAgcmV0dXJuIHZlYzIuZG90KHdvcmxkVmVjdG9yQSx3b3JsZFZlY3RvckIpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4vRXF1YXRpb25cIjoyMn1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblxuLyoqXG4gKiBTeW5jcyByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHR3byBib2RpZXMsIG9yIHNldHMgYSByZWxhdGl2ZSB2ZWxvY2l0eSAobW90b3IpLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSwgYm9keUIpe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMTtcbiAgICB0aGlzLnJhdGlvID0gMTtcbn1cblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb247XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9IC0xO1xuICAgIEdbNV0gPSB0aGlzLnJhdGlvO1xuXG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9FcXVhdGlvblwiOjIyfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMuXG4gKiBAY2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRFbWl0dGVyLFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0ICkge1xuICAgICAgICBsaXN0ZW5lci5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcbiAgICAgKiBAbWV0aG9kIGhhc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYobGlzdGVuZXIpe1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICk7XG4gICAgICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBldmVudC5cbiAgICAgKiBAbWV0aG9kIGVtaXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBldmVudC50eXBlXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKCBsaXN0ZW5lci5jb250ZXh0LCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4vTWF0ZXJpYWwnKTtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldCwgc3VjaCBhcyB3aGF0IGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS4gWW91IGNhbiBhbHNvIHNldCBvdGhlciB0aGluZ3Mgc3VjaCBhcyByZXN0aXR1dGlvbiwgc3VyZmFjZSB2ZWxvY2l0eSBhbmQgY29uc3RyYWludCBwYXJhbWV0ZXJzLlxuICogQGNsYXNzIENvbnRhY3RNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQlxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvbj0wLjNdICAgICAgIEZyaWN0aW9uIGNvZWZmaWNpZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMucmVzdGl0dXRpb249MF0gICAgICBSZXN0aXR1dGlvbiBjb2VmZmljaWVudCBha2EgXCJib3VuY2luZXNzXCIuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdGlmZm5lc3NdICAgICAgICAgIENvbnRhY3RFcXVhdGlvbiBzdGlmZm5lc3MuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZWxheGF0aW9uXSAgICAgICAgIENvbnRhY3RFcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3NdICBGcmljdGlvbkVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbl0gRnJpY3Rpb25FcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuc3VyZmFjZVZlbG9jaXR5PTBdICBTdXJmYWNlIHZlbG9jaXR5LlxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobWF0ZXJpYWxBLCBtYXRlcmlhbEIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYoIShtYXRlcmlhbEEgaW5zdGFuY2VvZiBNYXRlcmlhbCkgfHwgIShtYXRlcmlhbEIgaW5zdGFuY2VvZiBNYXRlcmlhbCkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCB0d28gYXJndW1lbnRzIG11c3QgYmUgTWF0ZXJpYWwgaW5zdGFuY2VzLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEFcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEEgPSBtYXRlcmlhbEE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEJcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEIgPSBtYXRlcmlhbEI7XG5cbiAgICAvKipcbiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudCB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFscy4gRnJpY3Rpb24gPSAwIHdpbGwgbWFrZSB0aGUgaW52b2x2ZWQgb2JqZWN0cyBzdXBlciBzbGlwcGVyeSwgYW5kIGZyaWN0aW9uID0gMSB3aWxsIG1ha2UgaXQgbXVjaCBsZXNzIHNsaXBwZXJ5LiBBIGZyaWN0aW9uIGNvZWZmaWNpZW50IGxhcmdlciB0aGFuIDEgd2lsbCBhbGxvdyBmb3IgdmVyeSBsYXJnZSBmcmljdGlvbiBmb3JjZXMsIHdoaWNoIGNhbiBiZSBjb252ZW5pZW50IGZvciBwcmV2ZW50aW5nIGNhciB0aXJlcyBub3Qgc2xpcCBvbiB0aGUgZ3JvdW5kLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4zXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZihvcHRpb25zLmZyaWN0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLmZyaWN0aW9uKSA6IDAuMztcblxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uLCBvciBcImJvdW5jaW5lc3NcIiB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFscy4gQSByZXN0aXR1dGlvbiBvZiAwIHdpbGwgbWFrZSBubyBib3VuY2UsIHdoaWxlIHJlc3RpdHV0aW9uPTEgd2lsbCBhcHByb3hpbWF0ZWx5IGJvdW5jZSBiYWNrIHdpdGggdGhlIHNhbWUgdmVsb2NpdHkgdGhlIG9iamVjdCBjYW1lIHdpdGguXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZihvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLnJlc3RpdHV0aW9uKSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBIYXJkbmVzcyBvZiB0aGUgY29udGFjdC4gTGVzcyBzdGlmZm5lc3Mgd2lsbCBtYWtlIHRoZSBvYmplY3RzIHBlbmV0cmF0ZSBtb3JlLCBhbmQgd2lsbCBtYWtlIHRoZSBjb250YWN0IGFjdCBtb3JlIGxpa2UgYSBzcHJpbmcgdGhhbiBhIGNvbnRhY3QgZm9yY2UuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9TVElGRk5FU1M6cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1N7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IHR5cGVvZihvcHRpb25zLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIob3B0aW9ucy5zdGlmZm5lc3MpIDogRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGUuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLnJlbGF4YXRpb24pIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSByZXN1bHRpbmcgZnJpY3Rpb24gZm9yY2UuIEZvciBtb3N0IGNhc2VzLCB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgYSBsYXJnZSBudW1iZXIuIEkgY2Fubm90IHRoaW5rIG9mIGFueSBjYXNlIHdoZXJlIHlvdSB3b3VsZCB3YW50IGxlc3MgZnJpY3Rpb25TdGlmZm5lc3MuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9TVElGRk5FU1M6cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1N7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25TdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25TdGlmZm5lc3MgPSB0eXBlb2Yob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgOiBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBmcmljdGlvbiBmb3JjZS4gVGhlIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIGdvb2QgZm9yIG1vc3Qgc2ltdWxhdGlvbnMuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBhZGQgc3VyZmFjZSB2ZWxvY2l0eSB0byB0aGlzIG1hdGVyaWFsLiBJZiBib2R5QSByZXN0cyBvbiB0b3AgaWYgYm9keUIsIGFuZCB0aGUgc3VyZmFjZSB2ZWxvY2l0eSBpcyBwb3NpdGl2ZSwgYm9keUEgd2lsbCBzbGlkZSB0byB0aGUgcmlnaHQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IHR5cGVvZihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgIT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIob3B0aW9ucy5zdXJmYWNlVmVsb2NpdHkpIDogMDtcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCB0byBiZSBzZXQgb24gQ29udGFjdEVxdWF0aW9ucy4gQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIG1ha2UgdGhlIGJvZGllcyBwZW5ldHJhdGUgbW9yZSBpbnRvIGVhY2ggb3RoZXIuIENhbiBiZSB1c2VmdWwgaW4gc2NlbmVzIHdoZXJlIGNvbnRhY3RzIG5lZWQgdG8gYmUgbW9yZSBwZXJzaXN0ZW50LCBmb3IgZXhhbXBsZSB3aGVuIHN0YWNraW5nLiBBa2EgXCJjdXJlIGZvciBuZXJ2b3VzIGNvbnRhY3RzXCIuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RTa2luU2l6ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0U2tpblNpemUgPSAwLjAwNTtcbn1cblxuQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG5cbn0se1wiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjIsXCIuL01hdGVyaWFsXCI6Mjh9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBNYXRlcmlhbCBpZGVudGlmaWVyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIE1hdGVyaWFsKGlkKXtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF0ZXJpYWwgaWRlbnRpZmllclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGlkIHx8IE1hdGVyaWFsLmlkQ291bnRlcisrO1xufVxuXG5NYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbiAgICAvKlxuICAgICAgICBQb2x5SyBsaWJyYXJ5XG4gICAgICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxuICAgICAgICBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cblxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICAgICBjb25kaXRpb25zOlxuXG4gICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICovXG5cbiAgICB2YXIgUG9seUsgPSB7fTtcblxuICAgIC8qXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XG5cbiAgICAgICAgTyhuXjIpXG4gICAgKi9cbiAgICAvKlxuICAgIFBvbHlLLklzU2ltcGxlID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIGlmKG48NCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBhMSA9IG5ldyBQb2x5Sy5fUCgpLCBhMiA9IG5ldyBQb2x5Sy5fUCgpO1xuICAgICAgICB2YXIgYjEgPSBuZXcgUG9seUsuX1AoKSwgYjIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgUG9seUsuX1AoKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGExLnggPSBwWzIqaSAgXTtcbiAgICAgICAgICAgIGExLnkgPSBwWzIqaSsxXTtcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICBlbHNlICAgICAgICB7IGEyLnggPSBwWzIqaSsyXTsgIGEyLnkgPSBwWzIqaSszXTsgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaS1qKSA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihpPT1uLTEgJiYgaj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XG4gICAgICAgICAgICAgICAgYjEueSA9IHBbMipqKzFdO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSkgIHsgYjIueCA9IHBbMCAgICBdOyAgYjIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cblxuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBQb2x5Sy5Jc0NvbnZleCA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICBpZihwLmxlbmd0aDw2KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDQ7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2ldLCBwW2krMV0sIHBbaSsyXSwgcFtpKzNdLCBwW2krNF0sIHBbaSs1XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsICBdLCBwW2wrMV0sIHBbbCsyXSwgcFtsKzNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLkdldEFyZWEgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGggPDYpIHJldHVybiAwO1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcbiAgICAgICAgc3VtICs9IChwWzBdLXBbbF0pICogKHBbbCsxXStwWzFdKTtcbiAgICAgICAgcmV0dXJuIC0gc3VtICogMC41O1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkdldEFBQkIgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heHggPSAtbWlueDtcbiAgICAgICAgdmFyIG1heHkgPSAtbWlueTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1pbnggPSBNYXRoLm1pbihtaW54LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XG4gICAgICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpKzFdKTtcbiAgICAgICAgICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2krMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDptaW54LCB5Om1pbnksIHdpZHRoOm1heHgtbWlueCwgaGVpZ2h0Om1heHktbWlueX07XG4gICAgfVxuICAgICovXG5cbiAgICBQb2x5Sy5Ucmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDMpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHRncyA9IFtdO1xuICAgICAgICB2YXIgYXZsID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYWwgPSBuO1xuICAgICAgICB3aGlsZShhbCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSswKSVhbF07XG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpKzIpJWFsXTtcblxuICAgICAgICAgICAgdmFyIGF4ID0gcFsyKmkwXSwgIGF5ID0gcFsyKmkwKzFdO1xuICAgICAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICAgICAgdmFyIGN4ID0gcFsyKmkyXSwgIGN5ID0gcFsyKmkyKzFdO1xuXG4gICAgICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKFBvbHlLLl9jb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPGFsOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgICAgICAgICAgICAgIGlmKHZpPT1pMCB8fCB2aT09aTEgfHwgdmk9PWkyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7ZWFyRm91bmQgPSBmYWxzZTsgYnJlYWs7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVhckZvdW5kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgICAgIGFsLS07XG4gICAgICAgICAgICAgICAgaT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsrID4gMyphbCkgYnJlYWs7ICAgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICAgICAgICB9XG4gICAgICAgIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICAgICAgICByZXR1cm4gdGdzO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwLCBweCwgcHkpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICB2YXIgYXgsIGF5LCBieCA9IHBbMipuLTJdLXB4LCBieSA9IHBbMipuLTFdLXB5O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xuICAgICAgICAgICAgYnggPSBwWzIqaSAgXSAtIHB4O1xuICAgICAgICAgICAgYnkgPSBwWzIqaSsxXSAtIHB5O1xuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheT49MCAmJiBieT49MCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcbiAgICAgICAgICAgIGlmKGF4PCAwICYmIGJ4PCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGx4ID0gYXggKyAoYngtYXgpKigtYXkpLyhieS1heSk7XG4gICAgICAgICAgICBpZihseD4wKSBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGVwdGggJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIFBvbHlLLlNsaWNlID0gZnVuY3Rpb24ocCwgYXgsIGF5LCBieCwgYnkpXG4gICAge1xuICAgICAgICBpZihQb2x5Sy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgUG9seUsuQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSByZXR1cm4gW3Auc2xpY2UoMCldO1xuXG4gICAgICAgIHZhciBhID0gbmV3IFBvbHlLLl9QKGF4LCBheSk7XG4gICAgICAgIHZhciBiID0gbmV3IFBvbHlLLl9QKGJ4LCBieSk7XG4gICAgICAgIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXG4gICAgICAgIHZhciBwcyA9IFtdOyAgICAvLyBwb2ludHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IFBvbHlLLl9QKHBbaV0sIHBbaSsxXSkpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXNjID0gbmV3IFBvbHlLLl9QKDAsMCk7XG4gICAgICAgICAgICBpc2MgPSBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhLCBiLCBwc1tpXSwgcHNbKGkrMSklcHMubGVuZ3RoXSwgaXNjKTtcblxuICAgICAgICAgICAgaWYoaXNjKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgICAgICAgICAgICBwcy5zcGxpY2UoaSsxLDAsaXNjKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcbiAgICAgICAgdmFyIGNvbXAgPSBmdW5jdGlvbih1LHYpIHtyZXR1cm4gUG9seUsuX1AuZGlzdChhLHUpIC0gUG9seUsuX1AuZGlzdChhLHYpOyB9XG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcblxuICAgICAgICB2YXIgcGdzID0gW107XG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICB3aGlsZShpc2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICAgICAgICAgIHZhciBpMSA9IGlzY3NbMV07XG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgIHZhciBzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoUG9seUsuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaTAgPSBpc2NzWzFdO1xuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcbiAgICAgICAgICAgICAgICBpbmQwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICAgICAgICAgICAgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc29sdmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpci0tO1xuICAgICAgICAgICAgICAgIHZhciBwZ24gPSBQb2x5Sy5fZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKTtcbiAgICAgICAgICAgICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgICAgICAgICAgIHBzID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMSwgaW5kMCk7XG4gICAgICAgICAgICAgICAgaTAuZmxhZyA9IGkxLmZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xuICAgICAgICAgICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cbiAgICAgICAgICAgIGlmKGRpcj4xKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBncy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xuICAgICAgICAgICAgdmFyIG5wZyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cGcubGVuZ3RoOyBqKyspIG5wZy5wdXNoKHBnW2pdLngsIHBnW2pdLnkpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIFBvbHlLLlJheWNhc3QgPSBmdW5jdGlvbihwLCB4LCB5LCBkeCwgZHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBub3JtOnt4OjAsIHk6MH0sIHJlZmw6e3g6MCwgeTowfX07XG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcbiAgICAgICAgICAgIHZhciBuaXNjID0gUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgICAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIHAubGVuZ3RoLzIsIGlzYyk7XG5cbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLkNsb3Nlc3RFZGdlID0gZnVuY3Rpb24ocCwgeCwgeSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB0cCA9IFBvbHlLLl90cDtcbiAgICAgICAgdmFyIGExID0gdHBbMF0sXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBwb2ludDp7eDowLCB5OjB9LCBub3JtOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpPj4xLCBpc2MpO1xuICAgICAgICB9XG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XG4gICAgICAgIFBvbHlLLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XG5cbiAgICAgICAgdmFyIGlkc3QgPSAxL2lzYy5kaXN0O1xuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XG4gICAgICAgIGlzYy5ub3JtLnkgPSAoeS1pc2MucG9pbnQueSkqaWRzdDtcbiAgICAgICAgcmV0dXJuIGlzYztcbiAgICB9XG5cbiAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdCA9IGZ1bmN0aW9uKHAsIGEsIGIsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcblxuICAgICAgICB2YXIgQSA9IHggLSB4MTtcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XG4gICAgICAgIHZhciBDID0geDIgLSB4MTtcbiAgICAgICAgdmFyIEQgPSB5MiAtIHkxO1xuXG4gICAgICAgIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xuICAgICAgICB2YXIgbGVuX3NxID0gQyAqIEMgKyBEICogRDtcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xuXG4gICAgICAgIHZhciB4eCwgeXk7XG5cbiAgICAgICAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgICAgICAgICB4eCA9IHgxO1xuICAgICAgICAgICAgeXkgPSB5MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgICAgICAgIHh4ID0geDI7XG4gICAgICAgICAgICB5eSA9IHkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB4MSArIHBhcmFtICogQztcbiAgICAgICAgICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSB4IC0geHg7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcbiAgICAgICAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmKGRzdDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBkc3Q7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgICAgICAgICAgaXNjLnBvaW50LnkgPSB5eTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvbHlLLl91cGRhdGVJU0MgPSBmdW5jdGlvbihkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBucmwgPSBQb2x5Sy5fUC5kaXN0KGExLCBjKTtcbiAgICAgICAgaWYobnJsPGlzYy5kaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaWJsID0gMS9Qb2x5Sy5fUC5kaXN0KGIxLCBiMik7XG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xuICAgICAgICAgICAgdmFyIG55ID0gIChiMi54LWIxLngpKmlibDtcbiAgICAgICAgICAgIHZhciBkZG90ID0gMiooZHgqbngrZHkqbnkpO1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XG4gICAgICAgICAgICBpc2Mubm9ybS54ID0gbng7XG4gICAgICAgICAgICBpc2Mubm9ybS55ID0gbnk7XG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XG4gICAgICAgICAgICBpc2MucmVmbC55ID0gLWRkb3QqbnkrZHk7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fZ2V0UG9pbnRzID0gZnVuY3Rpb24ocHMsIGluZDAsIGluZDEpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5wcyA9IFtdO1xuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcbiAgICAgICAgZm9yKHZhciBpPWluZDA7IGk8PSBpbmQxOyBpKyspIG5wcy5wdXNoKHBzW2klbl0pO1xuICAgICAgICByZXR1cm4gbnBzO1xuICAgIH1cblxuICAgIFBvbHlLLl9maXJzdFdpdGhGbGFnID0gZnVuY3Rpb24ocHMsIGluZClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XG4gICAgICAgICAgICBpZihwc1tpbmRdLmZsYWcpIHJldHVybiBpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24ocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgdmFyIHYweCA9IGN4LWF4O1xuICAgICAgICB2YXIgdjB5ID0gY3ktYXk7XG4gICAgICAgIHZhciB2MXggPSBieC1heDtcbiAgICAgICAgdmFyIHYxeSA9IGJ5LWF5O1xuICAgICAgICB2YXIgdjJ4ID0gcHgtYXg7XG4gICAgICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgICAgICB2YXIgZG90MDAgPSB2MHgqdjB4K3YweSp2MHk7XG4gICAgICAgIHZhciBkb3QwMSA9IHYweCp2MXgrdjB5KnYxeTtcbiAgICAgICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgICAgICB2YXIgZG90MTEgPSB2MXgqdjF4K3YxeSp2MXk7XG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCp2MngrdjF5KnYyeTtcblxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICAgICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIHZhciBpRGVuID0gMS9EZW47XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApICogaURlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xuXG4gICAgICAgIGlmKCFQb2x5Sy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF5PjAgJiYgSS55PmExLnkpIHx8IChkYXk8MCAmJiBJLnk8YTEueSkpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF4PjAgJiYgSS54PmExLngpIHx8IChkYXg8MCAmJiBJLng8YTEueCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gSTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApIC8gRGVuO1xuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcblxuICAgICAgICBpZihQb2x5Sy5fSW5SZWN0KEksIGExLCBhMikgJiYgUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gSTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgUG9seUsuX0luUmVjdCA9IGZ1bmN0aW9uKGEsIGIsIGMpXG4gICAge1xuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xuICAgICAgICBpZiAgKGIueSA9PSBjLnkpIHJldHVybiAoYS54Pj1NYXRoLm1pbihiLngsIGMueCkgJiYgYS54PD1NYXRoLm1heChiLngsIGMueCkpO1xuXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxuICAgICAgICAmJiBhLnkgPj0gTWF0aC5taW4oYi55LCBjLnkpICYmIGEueSA8PSBNYXRoLm1heChiLnksIGMueSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX2NvbnZleCA9IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG4gICAge1xuICAgICAgICByZXR1cm4gKGF5LWJ5KSooY3gtYngpICsgKGJ4LWF4KSooY3ktYnkpID49IDA7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1AgPSBmdW5jdGlvbih4LHkpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgUG9seUsuX1AucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwiUG9pbnQgW1wiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiXVwiO1xuICAgIH1cbiAgICBQb2x5Sy5fUC5kaXN0ID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gYi54LWEueDtcbiAgICAgICAgdmFyIGR5ID0gYi55LWEueTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fdHAgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSBQb2x5Sy5fdHAucHVzaChuZXcgUG9seUsuX1AoMCwwKSk7XG4gICAgICAgICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seUs7XG5cbn0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIFRoZSB2ZWMyIG9iamVjdCBmcm9tIGdsTWF0cml4LCB3aXRoIHNvbWUgZXh0ZW5zaW9ucyBhbmQgc29tZSByZW1vdmVkIG1ldGhvZHMuIFNlZSBodHRwOi8vZ2xtYXRyaXgubmV0LlxuICogQGNsYXNzIHZlYzJcbiAqL1xuXG52YXIgdmVjMiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbi8qKlxuICogTWFrZSBhIGNyb3NzIHByb2R1Y3QgYW5kIG9ubHkgcmV0dXJuIHRoZSB6IGNvbXBvbmVudFxuICogQG1ldGhvZCBjcm9zc0xlbmd0aFxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NMZW5ndGggPSBmdW5jdGlvbihhLGIpe1xuICAgIHJldHVybiBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xufTtcblxuLyoqXG4gKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxuICogQG1ldGhvZCBjcm9zc1ZaXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gdmVjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NWWiA9IGZ1bmN0aW9uKG91dCwgdmVjLCB6Y29tcCl7XG4gICAgdmVjMi5yb3RhdGUob3V0LHZlYywtTWF0aC5QSS8yKTsvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICB2ZWMyLnNjYWxlKG91dCxvdXQsemNvbXApOyAgICAgIC8vIFNjYWxlIHdpdGggelxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNyb3NzWlZcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcbiAqIEBwYXJhbSAge0FycmF5fSB2ZWNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc1pWID0gZnVuY3Rpb24ob3V0LCB6Y29tcCwgdmVjKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsdmVjLE1hdGguUEkvMik7IC8vIFJvdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0IGhhbmQgcnVsZVxuICAgIHZlYzIuc2NhbGUob3V0LG91dCx6Y29tcCk7ICAgICAgLy8gU2NhbGUgd2l0aCB6XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IGFuIGFuZ2xlXG4gKiBAbWV0aG9kIHJvdGF0ZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xudmVjMi5yb3RhdGUgPSBmdW5jdGlvbihvdXQsYSxhbmdsZSl7XG4gICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gYVswXSxcbiAgICAgICAgICAgIHkgPSBhWzFdO1xuICAgICAgICBvdXRbMF0gPSBjKnggLXMqeTtcbiAgICAgICAgb3V0WzFdID0gcyp4ICtjKnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxuICogQG1ldGhvZCByb3RhdGU5MGN3XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG52ZWMyLnJvdGF0ZTkwY3cgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF07XG4gICAgdmFyIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IHk7XG4gICAgb3V0WzFdID0gLXg7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGxvY2FsIGZyYW1lLlxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0LCB3b3JsZFBvaW50KTtcbiAgICB2ZWMyLnN1YihvdXQsIG91dCwgZnJhbWVQb3NpdGlvbik7XG4gICAgdmVjMi5yb3RhdGUob3V0LCBvdXQsIC1mcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gZ2xvYmFsIGZyYW1lLlxuICogQG1ldGhvZCB0b0dsb2JhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnRvR2xvYmFsRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIuY29weShvdXQsIGxvY2FsUG9pbnQpO1xuICAgIHZlYzIucm90YXRlKG91dCwgb3V0LCBmcmFtZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgZnJhbWVQb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHZlY3RvciB0byBsb2NhbCBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRWZWN0b3JcbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRWZWN0b3IsIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIucm90YXRlKG91dCwgd29ybGRWZWN0b3IsIC1mcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gZ2xvYmFsIGZyYW1lLlxuICogQG1ldGhvZCB0b0dsb2JhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3JcbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnZlY3RvclRvR2xvYmFsRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsVmVjdG9yLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIGxvY2FsVmVjdG9yLCBmcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBjZW50cm9pZCBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdmVjdG9ycyBhLGIsYy4gU2VlIGh0dHA6Ly9lYXN5Y2FsY3VsYXRpb24uY29tL2FuYWx5dGljYWwvbGVhcm4tY2VudHJvaWQucGhwXG4gKiBAbWV0aG9kIGNlbnRyb2lkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuICB7QXJyYXl9IFRoZSBvdXQgb2JqZWN0XG4gKi9cbnZlYzIuY2VudHJvaWQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgIHZlYzIuYWRkKG91dCwgYSwgYik7XG4gICAgdmVjMi5hZGQob3V0LCBvdXQsIGMpO1xuICAgIHZlYzIuc2NhbGUob3V0LCBvdXQsIDEvMyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbVZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3VidHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnN1YnRyYWN0XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YlxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5tdWx0aXBseVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBtdWxcbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZpZGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXZpZGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGl2XG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuZGlzdGFuY2VcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGlzdFxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkRGlzdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5zcXVhcmVkRGlzdGFuY2VcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3FyRGlzdFxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmxlbmd0aFxuICogQG1ldGhvZCBsZW5cbiAqIEBzdGF0aWNcbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3F1YXJlZExlbmd0aFxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWRMZW5ndGhcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3FyTGVuXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5lZ2F0ZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3RyXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlL21peCB0d28gdmVjdG9ycy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGVycFxuICogQHBhcmFtIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBhIEZpcnN0IHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYiBTZWNvbmQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdCBMZXJwIGZhY3RvclxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlZmxlY3QgYSB2ZWN0b3IgYWxvbmcgYSBub3JtYWwuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHJlZmxlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG91dFxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBub3JtYWxcbiAqL1xudmVjMi5yZWZsZWN0ID0gZnVuY3Rpb24ob3V0LCB2ZWN0b3IsIG5vcm1hbCl7XG4gICAgdmFyIGRvdCA9IHZlY3RvclswXSAqIG5vcm1hbFswXSArIHZlY3RvclsxXSAqIG5vcm1hbFsxXTtcbiAgICBvdXRbMF0gPSB2ZWN0b3JbMF0gLSAyICogbm9ybWFsWzBdICogZG90O1xuICAgIG91dFsxXSA9IHZlY3RvclsxXSAtIDIgKiBub3JtYWxbMV0gKiBkb3Q7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvblxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcnNlY3Rpb24sIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xudmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihvdXQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgdmFyIHQgPSB2ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uKHAwLCBwMSwgcDIsIHAzKTtcbiAgICBpZih0IDwgMCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBwMFswXSArICh0ICogKHAxWzBdIC0gcDBbMF0pKTtcbiAgICAgICAgb3V0WzFdID0gcDBbMV0gKyAodCAqIChwMVsxXSAtIHAwWzFdKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gZnJhY3Rpb24gYmV0d2VlbiB0d28gbGluZSBzZWdtZW50cy4gSWYgc3VjY2Vzc2Z1bCwgdGhlIGludGVyc2VjdGlvbiBpcyBhdCBwMCArIHQgKiAocDEgLSBwMClcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb25cbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqIEBwYXJhbSAge0FycmF5fSBwM1xuICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaWYgdGhlcmUgd2FzIGFuIGludGVyc2VjdGlvbiwgb3RoZXJ3aXNlIC0xLlxuICovXG52ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgczFfeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgdmFyIHMxX3kgPSBwMVsxXSAtIHAwWzFdO1xuICAgIHZhciBzMl94ID0gcDNbMF0gLSBwMlswXTtcbiAgICB2YXIgczJfeSA9IHAzWzFdIC0gcDJbMV07XG5cbiAgICB2YXIgcywgdDtcbiAgICBzID0gKC1zMV95ICogKHAwWzBdIC0gcDJbMF0pICsgczFfeCAqIChwMFsxXSAtIHAyWzFdKSkgLyAoLXMyX3ggKiBzMV95ICsgczFfeCAqIHMyX3kpO1xuICAgIHQgPSAoIHMyX3ggKiAocDBbMV0gLSBwMlsxXSkgLSBzMl95ICogKHAwWzBdIC0gcDJbMF0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XG4gICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMSkgeyAvLyBDb2xsaXNpb24gZGV0ZWN0ZWRcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHJldHVybiAtMTsgLy8gTm8gY29sbGlzaW9uXG59O1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTd9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgZGVjb21wID0gX2RlcmVxXygncG9seS1kZWNvbXAnKVxuLCAgIENvbnZleCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpXG4sICAgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpXG4sICAgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxuLyoqXG4gKiBBIHJpZ2lkIGJvZHkuIEhhcyBnb3QgYSBjZW50ZXIgb2YgbWFzcywgcG9zaXRpb24sIHZlbG9jaXR5IGFuZCBhIG51bWJlciBvZlxuICogc2hhcGVzIHRoYXQgYXJlIHVzZWQgZm9yIGNvbGxpc2lvbnMuXG4gKlxuICogQGNsYXNzIEJvZHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mb3JjZV1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMudmVsb2NpdHldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXBdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5ndWxhckZvcmNlPTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2NkSXRlcmF0aW9ucz0xMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZD0tMV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5maXhlZFJvdGF0aW9uPWZhbHNlXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdyYXZpdHlTY2FsZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pZF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXNzPTBdIEEgbnVtYmVyID49IDAuIElmIHplcm8sIHRoZSAudHlwZSB3aWxsIGJlIHNldCB0byBCb2R5LlNUQVRJQy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbGVlcFNwZWVkTGltaXRdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2xlZXBUaW1lTGltaXRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgdHlwaWNhbCBkeW5hbWljIGJvZHlcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMSxcbiAqICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcbiAqICAgICAgICAgYW5nbGU6IDAsXG4gKiAgICAgICAgIHZlbG9jaXR5OiBbMCwgMF0sXG4gKiAgICAgICAgIGFuZ3VsYXJWZWxvY2l0eTogMFxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBjaXJjdWxhciBzaGFwZSB0byB0aGUgYm9keVxuICogICAgIGJvZHkuYWRkU2hhcGUobmV3IENpcmNsZSh7IHJhZGl1czogMSB9KSk7XG4gKlxuICogICAgIC8vIEFkZCB0aGUgYm9keSB0byB0aGUgd29ybGRcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xuICovXG5mdW5jdGlvbiBCb2R5KG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBpZGVudGlmeWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCArK0JvZHkuX2lkQ291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0aGF0IHRoaXMgYm9keSBpcyBhZGRlZCB0by4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gTlVMTCBpZiB0aGUgYm9keSBpcyBub3QgYWRkZWQgdG8gYW55IHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZXMgb2YgdGhlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXNzID0gb3B0aW9ucy5tYXNzIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBtYXNzIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnZNYXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludk1hc3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZXJ0aWEgb2YgdGhlIGJvZHkgYXJvdW5kIHRoZSBaIGF4aXMuXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5lcnRpYSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBpbmVydGlhIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnZJbmVydGlhXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuXG4gICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xuICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgcm90YXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGZpeGVkUm90YXRpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSAhIW9wdGlvbnMuZml4ZWRSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgYm9keSBtb3ZlbWVudCBhbG9uZyB0aGUgWCBheGlzLiBUaGUgYm9keSB3aWxsIHN0aWxsIGJlIGFibGUgdG8gbW92ZSBhbG9uZyBZLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZml4ZWRYXG4gICAgICovXG4gICAgdGhpcy5maXhlZFggPSAhIW9wdGlvbnMuZml4ZWRYO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSBib2R5IG1vdmVtZW50IGFsb25nIHRoZSBZIGF4aXMuIFRoZSBib2R5IHdpbGwgc3RpbGwgYmUgYWJsZSB0byBtb3ZlIGFsb25nIFguXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFlcbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkWSA9ICEhb3B0aW9ucy5maXhlZFk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IG1hc3NNdWx0aXBsaWVyXG4gICAgICovXG4gICAgdGhpcy5tYXNzTXVsdGlwbGllciA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGJvZHlcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5wb3NpdGlvbiwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVXNlIHRoaXMgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkUG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBhbmdsZSBvZiB0aGUgYm9keS4gVXNlIHRoaXMgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkQW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIGFuZ2xlIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c0FuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnZlbG9jaXR5KXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudmVsb2NpdHksIG9wdGlvbnMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIHRoZSBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHZsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52bGFtYmRhID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGNvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgd2xhbWJkYVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLndsYW1iZGEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIG9mIHRoZSBib2R5LCBpbiByYWRpYW5zLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhlIGFuZ2xlIHByb3BlcnR5IGlzIG5vdCBub3JtYWxpemVkIHRvIHRoZSBpbnRlcnZhbCAwIHRvIDIqcGksIGl0IGNhbiBiZSBhbnkgdmFsdWUuXG4gICAgICogICAgIC8vIElmIHlvdSBuZWVkIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyKnBpLCB1c2UgdGhlIGZvbGxvd2luZyBmdW5jdGlvbiB0byBub3JtYWxpemUgaXQuXG4gICAgICogICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlKGFuZ2xlKXtcbiAgICAgKiAgICAgICAgIGFuZ2xlID0gYW5nbGUgJSAoMipNYXRoLlBJKTtcbiAgICAgKiAgICAgICAgIGlmKGFuZ2xlIDwgMCl7XG4gICAgICogICAgICAgICAgICAgYW5nbGUgKz0gKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaW5jZSB0aGUgYm9keSBmb3JjZSAoYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvYW5ndWxhckZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319KSB3aWxsIGJlIHplcm9lZCBhZnRlciBlYWNoIHN0ZXAsIHNvIHlvdSBuZWVkIHRvIHNldCB0aGUgZm9yY2UgYmVmb3JlIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHByb2R1Y2VzIGEgZm9yY2VmaWVsZCBvZiAxIE5ld3RvbiBpbiB0aGUgcG9zaXRpdmUgeCBkaXJlY3Rpb24uXG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5mb3JjZVswXSA9IDE7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHdpbGwgYXBwbHkgYSByb3RhdGlvbmFsIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5hbmd1bGFyRm9yY2UgPSAtMztcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zLmZvcmNlKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuZm9yY2UsIG9wdGlvbnMuZm9yY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvZm9yY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJGb3JjZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSBvcHRpb25zLmFuZ3VsYXJGb3JjZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpbmVhciBkYW1waW5nIGFjdGluZyBvbiB0aGUgYm9keSBpbiB0aGUgdmVsb2NpdHkgZGlyZWN0aW9uLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5kYW1waW5nIDogMC4xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJEYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJEYW1waW5nID0gdHlwZW9mKG9wdGlvbnMuYW5ndWxhckRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbmd1bGFyRGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1vdGlvbiB0aGlzIGJvZHkgaGFzLiBTaG91bGQgYmUgb25lIG9mOiB7eyNjcm9zc0xpbmsgXCJCb2R5L1NUQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LlNUQVRJQ3t7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L0RZTkFNSUM6cHJvcGVydHlcIn19Qm9keS5EWU5BTUlDe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvS0lORU1BVElDOnByb3BlcnR5XCJ9fUJvZHkuS0lORU1BVElDe3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiAqIFN0YXRpYyBib2RpZXMgZG8gbm90IG1vdmUsIGFuZCB0aGV5IGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcyBvciBjb2xsaXNpb24uXG4gICAgICogKiBEeW5hbWljIGJvZGllcyBib2R5IGNhbiBtb3ZlIGFuZCByZXNwb25kIHRvIGNvbGxpc2lvbnMgYW5kIGZvcmNlcy5cbiAgICAgKiAqIEtpbmVtYXRpYyBib2RpZXMgb25seSBtb3ZlcyBhY2NvcmRpbmcgdG8gaXRzIC52ZWxvY2l0eSwgYW5kIGRvZXMgbm90IHJlc3BvbmQgdG8gY29sbGlzaW9ucyBvciBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJvZGllcyBhcmUgc3RhdGljIGJ5IGRlZmF1bHQuIFN0YXRpYyBib2RpZXMgd2lsbCBuZXZlciBtb3ZlLlxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkudHlwZSA9PSBCb2R5LlNUQVRJQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJ5IHNldHRpbmcgdGhlIG1hc3Mgb2YgYSBib2R5IHRvIGEgbm9uemVybyBudW1iZXIsIHRoZSBib2R5XG4gICAgICogICAgIC8vIHdpbGwgYmVjb21lIGR5bmFtaWMgYW5kIHdpbGwgbW92ZSBhbmQgaW50ZXJhY3Qgd2l0aCBvdGhlciBib2RpZXMuXG4gICAgICogICAgIHZhciBkeW5hbWljQm9keSA9IG5ldyBCb2R5KHtcbiAgICAgKiAgICAgICAgIG1hc3MgOiAxXG4gICAgICogICAgIH0pO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhkeW5hbWljQm9keS50eXBlID09IEJvZHkuRFlOQU1JQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEtpbmVtYXRpYyBib2RpZXMgd2lsbCBvbmx5IG1vdmUgaWYgeW91IGNoYW5nZSB0aGVpciB2ZWxvY2l0eS5cbiAgICAgKiAgICAgdmFyIGtpbmVtYXRpY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICB0eXBlOiBCb2R5LktJTkVNQVRJQyAvLyBUeXBlIGNhbiBiZSBzZXQgdmlhIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiAgICAgfSk7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy50eXBlKSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfSBlbHNlIGlmKCFvcHRpb25zLm1hc3Mpe1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LlNUQVRJQztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LkRZTkFNSUM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgYm94IG9mIHRoaXMgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBQUJCfVxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdXBkYXRlLiBVcGRhdGUgaXQgd2l0aCB7eyNjcm9zc0xpbmsgXCJCb2R5L3VwZGF0ZUFBQkI6bWV0aG9kXCJ9fS51cGRhdGVBQUJCKCl7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHNlZSB1cGRhdGVBQUJCXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBGb3JjZSB1cGRhdGUgdGhlIEFBQkJcbiAgICAgKiAgICAgYm9keS5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAqICAgICBib2R5LnVwZGF0ZUFBQkIoKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hYWJiTmVlZHNVcGRhdGUpOyAvLyBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBib2R5IHdpbGwgYXV0b21hdGljYWxseSBmYWxsIHRvIHNsZWVwLiBOb3RlIHRoYXQgeW91IG5lZWQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJXb3JsZFwifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgYW55dGhpbmcgd2lsbCBoYXBwZW4uXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gb3B0aW9ucy5hbGxvd1NsZWVwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFsbG93U2xlZXAgOiB0cnVlO1xuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9uZSBvZiB7eyNjcm9zc0xpbmsgXCJCb2R5L0FXQUtFOnByb3BlcnR5XCJ9fUJvZHkuQVdBS0V7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQm9keS9TTEVFUFk6cHJvcGVydHlcIn19Qm9keS5TTEVFUFl7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9TTEVFUElORzpwcm9wZXJ0eVwifX1Cb2R5LlNMRUVQSU5He3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBUaGUgYm9keSBpcyBpbml0aWFsbHkgQm9keS5BV0FLRS4gSWYgaXRzIHZlbG9jaXR5IG5vcm0gaXMgYmVsb3cgLnNsZWVwU3BlZWRMaW1pdCwgdGhlIHNsZWVwU3RhdGUgd2lsbCBiZWNvbWUgQm9keS5TTEVFUFkuIElmIHRoZSBib2R5IGNvbnRpbnVlcyB0byBiZSBCb2R5LlNMRUVQWSBmb3IgLnNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IHdpbGwgZmFsbCBhc2xlZXAgKEJvZHkuU0xFRVBZKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFN0YXRlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBCb2R5LkFXQUtFXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3BlZWRMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4yXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFNwZWVkTGltaXQgPSBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zbGVlcFNwZWVkTGltaXQgOiAwLjI7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcHkgZm9yIHRoaXMgc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBzbGVlcGluZy5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBUaW1lTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwVGltZUxpbWl0ID0gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IHNjYWxpbmcgZmFjdG9yLiBJZiB5b3Ugd2FudCB0aGUgYm9keSB0byBpZ25vcmUgZ3Jhdml0eSwgc2V0IHRoaXMgdG8gemVyby4gSWYgeW91IHdhbnQgdG8gcmV2ZXJzZSBncmF2aXR5LCBzZXQgaXQgdG8gLTEuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGdyYXZpdHlTY2FsZVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHlTY2FsZSA9IG9wdGlvbnMuZ3Jhdml0eVNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdyYXZpdHlTY2FsZSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGJvZHkgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9kaWVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBsb25nIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZGxlVGltZVxuICAgICAqL1xuICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgdGltZSB3aGVuIHRoZSBib2R5IHdlbnQgdG8gU0xFRVBZIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aW1lTGFzdFNsZWVweVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBzcGVlZCBleGNlZWRzIHRoaXMgdGhyZXNob2xkLCBDQ0QgKGNvbnRpbnVvdXMgY29sbGlzaW9uIGRldGVjdGlvbikgd2lsbCBiZSBlbmFibGVkLiBTZXQgaXQgdG8gYSBuZWdhdGl2ZSBudW1iZXIgdG8gZGlzYWJsZSBDQ0QgY29tcGxldGVseSBmb3IgdGhpcyBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RTcGVlZFRocmVzaG9sZFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jY2RTcGVlZFRocmVzaG9sZCA9IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciB0aGUgdGltZSBvZiBpbXBhY3QgZHVyaW5nIENDRC4gQSBsYXJnZXIgbnVtYmVyIHdpbGwgYXNzdXJlIHRoYXQgdGhlcmUncyBhIHNtYWxsIHBlbmV0cmF0aW9uIG9uIENDRCBjb2xsaXNpb24sIGJ1dCBhIHNtYWxsIG51bWJlciB3aWxsIGdpdmUgbW9yZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkSXRlcmF0aW9uc1xuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgdGhpcy5jY2RJdGVyYXRpb25zID0gb3B0aW9ucy5jY2RJdGVyYXRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNjZEl0ZXJhdGlvbnMgOiAxMDtcblxuICAgIHRoaXMuY29uY2F2ZVBhdGggPSBudWxsO1xuXG4gICAgdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufVxuQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Cb2R5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvZHk7XG5cbkJvZHkuX2lkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IHRoaXMuaW52SW5lcnRpYTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdG90YWwgZGVuc2l0eSBvZiB0aGUgYm9keVxuICogQG1ldGhvZCBzZXREZW5zaXR5XG4gKiBAcGFyYW0ge251bWJlcn0gZGVuc2l0eVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24oZGVuc2l0eSkge1xuICAgIHZhciB0b3RhbEFyZWEgPSB0aGlzLmdldEFyZWEoKTtcbiAgICB0aGlzLm1hc3MgPSB0b3RhbEFyZWEgKiBkZW5zaXR5O1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0b3RhbCBhcmVhIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGJvZHlcbiAqIEBtZXRob2QgZ2V0QXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0b3RhbEFyZWEgKz0gdGhpcy5zaGFwZXNbaV0uYXJlYTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQXJlYTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIGZyb20gdGhlIGJvZHkuIFRoZSBBQUJCIGlzIHVwZGF0ZWQgaWYgbmVjZXNzYXJ5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgQUFCQiBpbnN0YW5jZSAodGhpcy5hYWJiKVxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hYWJiO1xufTtcblxudmFyIHNoYXBlQUFCQiA9IG5ldyBBQUJCKCksXG4gICAgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBBQUJCIG9mIHRoZSBCb2R5LCBhbmQgc2V0IC5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZS5cbiAqIEBtZXRob2QgdXBkYXRlQUFCQlxuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gdG1wLFxuICAgICAgICBib2R5QW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBhbmdsZSA9IHNoYXBlLmFuZ2xlICsgYm9keUFuZ2xlO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBvZmZzZXRcbiAgICAgICAgdmVjMi5yb3RhdGUob2Zmc2V0LCBzaGFwZS5wb3NpdGlvbiwgYm9keUFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQob2Zmc2V0LCBvZmZzZXQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXG4gICAgICAgIHNoYXBlLmNvbXB1dGVBQUJCKHNoYXBlQUFCQiwgb2Zmc2V0LCBhbmdsZSk7XG5cbiAgICAgICAgaWYoaT09PTApe1xuICAgICAgICAgICAgdGhpcy5hYWJiLmNvcHkoc2hhcGVBQUJCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWFiYi5leHRlbmQoc2hhcGVBQUJCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBib2R5ICh0aGlzLmJvdW5kaW5nUmFkaXVzKS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZSBkaW1lbnNpb25zIG9yIHBvc2l0aW9ucyBhcmUgY2hhbmdlZC5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHZlYzIubGVuZ3RoKHNoYXBlLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIHIgPSBzaGFwZS5ib3VuZGluZ1JhZGl1cztcbiAgICAgICAgaWYob2Zmc2V0ICsgciA+IHJhZGl1cyl7XG4gICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcbn07XG5cbi8qKlxuICogQWRkIGEgc2hhcGUgdG8gdGhlIGJvZHkuIFlvdSBjYW4gcGFzcyBhIGxvY2FsIHRyYW5zZm9ybSB3aGVuIGFkZGluZyBhIHNoYXBlLFxuICogc28gdGhhdCB0aGUgc2hhcGUgZ2V0cyBhbiBvZmZzZXQgYW5kIGFuZ2xlIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxuICogV2lsbCBhdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIGFuZCBib3VuZGluZyByYWRpdXMuXG4gKlxuICogQG1ldGhvZCBhZGRTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgICAgICAgICBzaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IFtvZmZzZXRdIExvY2FsIGJvZHkgb2Zmc2V0IG9mIHRoZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgW2FuZ2xlXSAgTG9jYWwgYm9keSBhbmdsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKSxcbiAqICAgICAgICAgc2hhcGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pO1xuICpcbiAqICAgICAvLyBBZGQgdGhlIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcbiAqXG4gKiAgICAgLy8gQWRkIGFub3RoZXIgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgMSB1bml0IGxlbmd0aCBmcm9tIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzIGFsb25nIHRoZSBsb2NhbCB4LWF4aXMuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMSwwXSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeS1heGlzLCBhbmQgcm90YXRlZCA5MCBkZWdyZWVzIENDVy5cbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLFswLDFdLE1hdGguUEkvMik7XG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIG9mZnNldCwgYW5nbGUpe1xuICAgIGlmKHNoYXBlLmJvZHkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2hhcGUgY2FuIG9ubHkgYmUgYWRkZWQgdG8gb25lIGJvZHkuJyk7XG4gICAgfVxuICAgIHNoYXBlLmJvZHkgPSB0aGlzO1xuXG4gICAgLy8gQ29weSB0aGUgb2Zmc2V0IHZlY3RvclxuICAgIGlmKG9mZnNldCl7XG4gICAgICAgIHZlYzIuY29weShzaGFwZS5wb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZWMyLnNldChzaGFwZS5wb3NpdGlvbiwgMCwgMCk7XG4gICAgfVxuXG4gICAgc2hhcGUuYW5nbGUgPSBhbmdsZSB8fCAwO1xuXG4gICAgdGhpcy5zaGFwZXMucHVzaChzaGFwZSk7XG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc2hhcGVcbiAqIEBtZXRob2QgcmVtb3ZlU2hhcGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2hhcGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XG5cbiAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzaGFwZS5ib2R5ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyAuaW5lcnRpYSwgLmludk1hc3MsIC5pbnZJbmVydGlhIGZvciB0aGlzIEJvZHkuIFNob3VsZCBiZSBjYWxsZWQgd2hlblxuICogY2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvciBtYXNzIG9mIHRoZSBCb2R5LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlTWFzc1Byb3BlcnRpZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGJvZHkubWFzcyArPSAxO1xuICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG5cbiAgICAgICAgdGhpcy5tYXNzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMDtcbiAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5tYXNzIC8gTixcbiAgICAgICAgICAgIEkgPSAwO1xuXG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHIyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHNoYXBlLnBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgSWNtID0gc2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYShtKTtcbiAgICAgICAgICAgICAgICBJICs9IEljbSArIG0qcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJO1xuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gST4wID8gMS9JIDogMDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZlcnNlIG1hc3MgcHJvcGVydGllcyBhcmUgZWFzeVxuICAgICAgICB0aGlzLmludk1hc3MgPSAxIC8gdGhpcy5tYXNzO1xuXG4gICAgICAgIHZlYzIuc2V0KFxuICAgICAgICAgICAgdGhpcy5tYXNzTXVsdGlwbGllcixcbiAgICAgICAgICAgIHRoaXMuZml4ZWRYID8gMCA6IDEsXG4gICAgICAgICAgICB0aGlzLmZpeGVkWSA/IDAgOiAxXG4gICAgICAgICk7XG4gICAgfVxufTtcblxudmFyIEJvZHlfYXBwbHlGb3JjZV9yID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBSaWdpZEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS5hbmd1bGFyRm9yY2UuIElmIHJlbGF0aXZlUG9pbnQgaXMgemVybywgdGhlIGZvcmNlIHdpbGwgYmUgYXBwbGllZCBkaXJlY3RseSBvbiB0aGUgY2VudGVyIG9mIG1hc3MsIGFuZCB0aGUgdG9ycXVlIHByb2R1Y2VkIHdpbGwgYmUgemVyby5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtIHtBcnJheX0gZm9yY2UgVGhlIGZvcmNlIHRvIGFkZC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZWxhdGl2ZVBvaW50XSBBIHdvcmxkIHBvaW50IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlLCByZWxhdGl2ZVBvaW50KXtcblxuICAgIC8vIEFkZCBsaW5lYXIgZm9yY2VcbiAgICB2ZWMyLmFkZCh0aGlzLmZvcmNlLCB0aGlzLmZvcmNlLCBmb3JjZSk7XG5cbiAgICBpZihyZWxhdGl2ZVBvaW50KXtcblxuICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICAgICAgdmFyIHJvdEZvcmNlID0gdmVjMi5jcm9zc0xlbmd0aChyZWxhdGl2ZVBvaW50LGZvcmNlKTtcblxuICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBmb3JjZVxuICAgICAgICB0aGlzLmFuZ3VsYXJGb3JjZSArPSByb3RGb3JjZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgYm9keS1sb2NhbCBwb2ludC5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZUxvY2FsXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxGb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gbG9jYWwgYm9keSBzcGFjZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbbG9jYWxQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhjZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG52YXIgQm9keV9hcHBseUZvcmNlX2ZvcmNlV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIEJvZHlfYXBwbHlGb3JjZV9wb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbCA9IHZlYzIuY3JlYXRlKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlTG9jYWwgPSBmdW5jdGlvbihsb2NhbEZvcmNlLCBsb2NhbFBvaW50KXtcbiAgICBsb2NhbFBvaW50ID0gbG9jYWxQb2ludCB8fCBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbDtcbiAgICB2YXIgd29ybGRGb3JjZSA9IEJvZHlfYXBwbHlGb3JjZV9mb3JjZVdvcmxkO1xuICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUZvcmNlX3BvaW50V29ybGQ7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRGb3JjZSwgbG9jYWxGb3JjZSk7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRQb2ludCwgbG9jYWxQb2ludCk7XG4gICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHdvcmxkUG9pbnQpO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cbiAqIEBtZXRob2QgYXBwbHlJbXB1bHNlXG4gKiBAcGFyYW0gIHtBcnJheX0gaW1wdWxzZSBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhjZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG52YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IHZlYzIuY3JlYXRlKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2UgPSBmdW5jdGlvbihpbXB1bHNlVmVjdG9yLCByZWxhdGl2ZVBvaW50KXtcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIGNlbnRyYWwgaW1wdWxzZSB2ZWxvY2l0eVxuICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcbiAgICB2ZWMyLnNjYWxlKHZlbG8sIGltcHVsc2VWZWN0b3IsIHRoaXMuaW52TWFzcyk7XG4gICAgdmVjMi5tdWx0aXBseSh2ZWxvLCB0aGlzLm1hc3NNdWx0aXBsaWVyLCB2ZWxvKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxuICAgIHZlYzIuYWRkKHRoaXMudmVsb2NpdHksIHZlbG8sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgaWYocmVsYXRpdmVQb2ludCl7XG4gICAgICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBpbXB1bHNlIHZlbG9jaXR5XG4gICAgICAgIHZhciByb3RWZWxvID0gdmVjMi5jcm9zc0xlbmd0aChyZWxhdGl2ZVBvaW50LCBpbXB1bHNlVmVjdG9yKTtcbiAgICAgICAgcm90VmVsbyAqPSB0aGlzLmludkluZXJ0aWE7XG5cbiAgICAgICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSByb3RWZWxvO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZUxvY2FsXG4gKiBAcGFyYW0gIHtBcnJheX0gaW1wdWxzZSBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhjZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG52YXIgQm9keV9hcHBseUltcHVsc2VfaW1wdWxzZVdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsID0gdmVjMi5jcmVhdGUoKTtcbkJvZHkucHJvdG90eXBlLmFwcGx5SW1wdWxzZUxvY2FsID0gZnVuY3Rpb24obG9jYWxJbXB1bHNlLCBsb2NhbFBvaW50KXtcbiAgICBsb2NhbFBvaW50ID0gbG9jYWxQb2ludCB8fCBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsO1xuICAgIHZhciB3b3JsZEltcHVsc2UgPSBCb2R5X2FwcGx5SW1wdWxzZV9pbXB1bHNlV29ybGQ7XG4gICAgdmFyIHdvcmxkUG9pbnQgPSBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkO1xuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkSW1wdWxzZSwgbG9jYWxJbXB1bHNlKTtcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZFBvaW50LCBsb2NhbFBvaW50KTtcbiAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHdvcmxkUG9pbnQpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludCAgIFRoZSBpbnB1dCB3b3JsZCBwb2ludFxuICovXG5Cb2R5LnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihvdXQsIHdvcmxkUG9pbnQpe1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludCAgIFRoZSBpbnB1dCBsb2NhbCBwb2ludFxuICovXG5Cb2R5LnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQpe1xuICAgIHZlYzIudG9HbG9iYWxGcmFtZShvdXQsIGxvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxuICogQG1ldGhvZCB2ZWN0b3JUb0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRWZWN0b3IgIFRoZSBpbnB1dCB3b3JsZCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFZlY3Rvcil7XG4gICAgdmVjMi52ZWN0b3JUb0xvY2FsRnJhbWUob3V0LCB3b3JsZFZlY3RvciwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3IgIFRoZSBpbnB1dCBsb2NhbCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFZlY3Rvcil7XG4gICAgdmVjMi52ZWN0b3JUb0dsb2JhbEZyYW1lKG91dCwgbG9jYWxWZWN0b3IsIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHBvbHlnb24gc2hhcGUgcGF0aCwgYW5kIGFzc2VtYmxlcyBjb252ZXggc2hhcGVzIGZyb20gdGhhdCBhbmQgcHV0cyB0aGVtIGF0IHByb3BlciBvZmZzZXQgcG9pbnRzLlxuICogQG1ldGhvZCBmcm9tUG9seWdvblxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiAyZCB2ZWN0b3JzLCBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dIHRoYXQgcmVzZW1ibGVzIGEgY29uY2F2ZSBvciBjb252ZXggcG9seWdvbi4gVGhlIHNoYXBlIG11c3QgYmUgc2ltcGxlIGFuZCB3aXRob3V0IGhvbGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcHRpbWFsRGVjb21wPWZhbHNlXSAgIFNldCB0byB0cnVlIGlmIHlvdSBuZWVkIG9wdGltYWwgZGVjb21wb3NpdGlvbi4gV2FybmluZzogdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiAxMCB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFNpbXBsZUNoZWNrPWZhbHNlXSBTZXQgdG8gdHJ1ZSBpZiB5b3UgYWxyZWFkeSBrbm93IHRoYXQgdGhlIHBhdGggaXMgbm90IGludGVyc2VjdGluZyBpdHNlbGYuXG4gKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBbb3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHM9ZmFsc2VdIFNldCB0byBhIG51bWJlciAoYW5nbGUgdGhyZXNob2xkIHZhbHVlKSB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgb3IgZmFsc2UgdG8ga2VlcCBhbGwgcG9pbnRzLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5mcm9tUG9seWdvbiA9IGZ1bmN0aW9uKHBhdGgsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBSZW1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT10aGlzLnNoYXBlcy5sZW5ndGg7IGk+PTA7IC0taSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU2hhcGUodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IGRlY29tcC5Qb2x5Z29uKCk7XG4gICAgcC52ZXJ0aWNlcyA9IHBhdGg7XG5cbiAgICAvLyBNYWtlIGl0IGNvdW50ZXItY2xvY2t3aXNlXG4gICAgcC5tYWtlQ0NXKCk7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgcC5yZW1vdmVDb2xsaW5lYXJQb2ludHMob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgcGF0aCBpdHNlbGZcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5za2lwU2ltcGxlQ2hlY2spID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgaWYoIXAuaXNTaW1wbGUoKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoaXMgcGF0aCBmb3IgbGF0ZXJcbiAgICB0aGlzLmNvbmNhdmVQYXRoID0gcC52ZXJ0aWNlcy5zbGljZSgwKTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBbMCwwXTtcbiAgICAgICAgdmVjMi5jb3B5KHYsdGhpcy5jb25jYXZlUGF0aFtpXSk7XG4gICAgICAgIHRoaXMuY29uY2F2ZVBhdGhbaV0gPSB2O1xuICAgIH1cblxuICAgIC8vIFNsb3cgb3IgZmFzdCBkZWNvbXA/XG4gICAgdmFyIGNvbnZleGVzO1xuICAgIGlmKG9wdGlvbnMub3B0aW1hbERlY29tcCl7XG4gICAgICAgIGNvbnZleGVzID0gcC5kZWNvbXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb252ZXhlcyA9IHAucXVpY2tEZWNvbXAoKTtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLy8gQWRkIGNvbnZleGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXhcbiAgICAgICAgdmFyIGMgPSBuZXcgQ29udmV4KHsgdmVydGljZXM6IGNvbnZleGVzW2ldLnZlcnRpY2VzIH0pO1xuXG4gICAgICAgIC8vIE1vdmUgYWxsIHZlcnRpY2VzIHNvIGl0cyBjZW50ZXIgb2YgbWFzcyBpcyBpbiB0aGUgbG9jYWwgY2VudGVyIG9mIHRoZSBjb252ZXhcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1jLnZlcnRpY2VzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciB2ID0gYy52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgIHZlYzIuc3ViKHYsdixjLmNlbnRlck9mTWFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnNjYWxlKGNtLGMuY2VudGVyT2ZNYXNzLDEpO1xuICAgICAgICBjLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICBjLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgICAgICBjLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzaGFwZVxuICAgICAgICB0aGlzLmFkZFNoYXBlKGMsY20pO1xuICAgIH1cblxuICAgIHRoaXMuYWRqdXN0Q2VudGVyT2ZNYXNzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIE1vdmVzIHRoZSBzaGFwZSBvZmZzZXRzIHNvIHRoZWlyIGNlbnRlciBvZiBtYXNzIGJlY29tZXMgdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXG4gKiBAbWV0aG9kIGFkanVzdENlbnRlck9mTWFzc1xuICovXG5Cb2R5LnByb3RvdHlwZS5hZGp1c3RDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciBvZmZzZXRfdGltZXNfYXJlYSA9IGFkanVzdENlbnRlck9mTWFzc190bXAyLFxuICAgICAgICBzdW0gPSAgICAgICAgICAgICAgIGFkanVzdENlbnRlck9mTWFzc190bXAzLFxuICAgICAgICBjbSA9ICAgICAgICAgICAgICAgIGFkanVzdENlbnRlck9mTWFzc190bXA0LFxuICAgICAgICB0b3RhbEFyZWEgPSAgICAgICAgIDA7XG4gICAgdmVjMi5zZXQoc3VtLDAsMCk7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgdmVjMi5zY2FsZShvZmZzZXRfdGltZXNfYXJlYSwgcy5wb3NpdGlvbiwgcy5hcmVhKTtcbiAgICAgICAgdmVjMi5hZGQoc3VtLCBzdW0sIG9mZnNldF90aW1lc19hcmVhKTtcbiAgICAgICAgdG90YWxBcmVhICs9IHMuYXJlYTtcbiAgICB9XG5cbiAgICB2ZWMyLnNjYWxlKGNtLHN1bSwxL3RvdGFsQXJlYSk7XG5cbiAgICAvLyBOb3cgbW92ZSBhbGwgc2hhcGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIHZlYzIuc3ViKHMucG9zaXRpb24sIHMucG9zaXRpb24sIGNtKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib2R5IHBvc2l0aW9uIHRvb1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sdGhpcy5wb3NpdGlvbixjbSk7XG5cbiAgICAvLyBBbmQgY29uY2F2ZSBwYXRoXG4gICAgZm9yKHZhciBpPTA7IHRoaXMuY29uY2F2ZVBhdGggJiYgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmVjMi5zdWIodGhpcy5jb25jYXZlUGF0aFtpXSwgdGhpcy5jb25jYXZlUGF0aFtpXSwgY20pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZvcmNlIG9uIHRoZSBib2R5IHRvIHplcm8uXG4gKiBAbWV0aG9kIHNldFplcm9Gb3JjZVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRaZXJvRm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIuc2V0KHRoaXMuZm9yY2UsMC4wLDAuMCk7XG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSAwLjA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICB2bGFtYmRhID0gYi52bGFtYmRhO1xuICAgIHZlYzIuc2V0KHZsYW1iZGEsMCwwKTtcbiAgICBiLndsYW1iZGEgPSAwO1xufTtcblxuQm9keS5wcm90b3R5cGUuYWRkQ29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgIHYgPSBiLnZlbG9jaXR5O1xuICAgIHZlYzIuYWRkKCB2LCB2LCBiLnZsYW1iZGEpO1xuICAgIGIuYW5ndWxhclZlbG9jaXR5ICs9IGIud2xhbWJkYTtcbn07XG5cbi8qKlxuICogQXBwbHkgZGFtcGluZywgc2VlIDxhIGhyZWY9XCJodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzRcIj50aGlzPC9hPiBmb3IgZGV0YWlscy5cbiAqIEBtZXRob2QgYXBwbHlEYW1waW5nXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0IEN1cnJlbnQgdGltZSBzdGVwXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5RGFtcGluZyA9IGZ1bmN0aW9uKGR0KXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgIHZhciB2ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgdmVjMi5zY2FsZSh2LCB2LCBNYXRoLnBvdygxLjAgLSB0aGlzLmRhbXBpbmcsZHQpKTtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKj0gTWF0aC5wb3coMS4wIC0gdGhpcy5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLiBOb3JtYWxseSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRoaXMsIGFzIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgYXdva2VuIGF0IGV2ZW50cyBzdWNoIGFzIGNvbGxpc2lvbnMuXG4gKiBTZXRzIHRoZSBzbGVlcFN0YXRlIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319IGFuZCBlbWl0cyB0aGUgd2FrZVVwIGV2ZW50IGlmIHRoZSBib2R5IHdhc24ndCBhd2FrZSBiZWZvcmUuXG4gKiBAbWV0aG9kIHdha2VVcFxuICovXG5Cb2R5LnByb3RvdHlwZS53YWtlVXAgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzID0gdGhpcy5zbGVlcFN0YXRlO1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG4gICAgdGhpcy5pZGxlVGltZSA9IDA7XG4gICAgaWYocyAhPT0gQm9keS5BV0FLRSl7XG4gICAgICAgIHRoaXMuZW1pdChCb2R5Lndha2VVcEV2ZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZvcmNlIGJvZHkgc2xlZXBcbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBJTkc7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gMDtcbiAgICB2ZWMyLnNldCh0aGlzLnZlbG9jaXR5LDAsMCk7XG4gICAgdmVjMi5zZXQodGhpcy5mb3JjZSwwLDApO1xuICAgIHRoaXMuZW1pdChCb2R5LnNsZWVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFNsZWVwXG4gKiBAcGFyYW0ge251bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSwgZG9udFNsZWVwLCBkdCl7XG4gICAgaWYoIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnR5cGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIHZhciBzbGVlcFN0YXRlID0gdGhpcy5zbGVlcFN0YXRlLFxuICAgICAgICBzcGVlZFNxdWFyZWQgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgKyBNYXRoLnBvdyh0aGlzLmFuZ3VsYXJWZWxvY2l0eSwyKSxcbiAgICAgICAgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcblxuICAgIC8vIEFkZCB0byBpZGxlIHRpbWVcbiAgICBpZihzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlkbGVUaW1lICs9IGR0O1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTtcbiAgICB9XG4gICAgaWYodGhpcy5pZGxlVGltZSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpe1xuICAgICAgICBpZighZG9udFNsZWVwKXtcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvZHkgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBib2R5LiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSB3b3JrcyBpZiB0aGUgYm9keSB3YXMgYWRkZWQgdG8gYSBXb3JsZCBhbmQgaWYgYXQgbGVhc3Qgb25lIHN0ZXAgd2FzIHRha2VuLlxuICogQG1ldGhvZCBvdmVybGFwc1xuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQm9keS5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihib2R5KXtcbiAgICByZXR1cm4gdGhpcy53b3JsZC5vdmVybGFwS2VlcGVyLmJvZGllc0FyZU92ZXJsYXBwaW5nKHRoaXMsIGJvZHkpO1xufTtcblxudmFyIGludGVncmF0ZV9maE1pbnYgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVncmF0ZV92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIE1vdmUgdGhlIGJvZHkgZm9yd2FyZCBpbiB0aW1lIGdpdmVuIGl0cyBjdXJyZW50IHZlbG9jaXR5LlxuICogQG1ldGhvZCBpbnRlZ3JhdGVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24oZHQpe1xuICAgIHZhciBtaW52ID0gdGhpcy5pbnZNYXNzLFxuICAgICAgICBmID0gdGhpcy5mb3JjZSxcbiAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdmVsbyA9IHRoaXMudmVsb2NpdHk7XG5cbiAgICAvLyBTYXZlIG9sZCBwb3NpdGlvblxuICAgIHZlYzIuY29weSh0aGlzLnByZXZpb3VzUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuICAgIHRoaXMucHJldmlvdXNBbmdsZSA9IHRoaXMuYW5nbGU7XG5cbiAgICAvLyBWZWxvY2l0eSB1cGRhdGVcbiAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5hbmd1bGFyRm9yY2UgKiB0aGlzLmludkluZXJ0aWEgKiBkdDtcbiAgICB9XG4gICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfZmhNaW52LCBmLCBkdCAqIG1pbnYpO1xuICAgIHZlYzIubXVsdGlwbHkoaW50ZWdyYXRlX2ZoTWludiwgdGhpcy5tYXNzTXVsdGlwbGllciwgaW50ZWdyYXRlX2ZoTWludik7XG4gICAgdmVjMi5hZGQodmVsbywgaW50ZWdyYXRlX2ZoTWludiwgdmVsbyk7XG5cbiAgICAvLyBDQ0RcbiAgICBpZighdGhpcy5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdChkdCkpe1xuXG4gICAgICAgIC8vIFJlZ3VsYXIgcG9zaXRpb24gdXBkYXRlXG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgdmVsbywgZHQpO1xuICAgICAgICB2ZWMyLmFkZChwb3MsIHBvcywgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgdGhpcy5hbmdsZSArPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxudmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG52YXIgcmF5ID0gbmV3IFJheSh7XG4gICAgbW9kZTogUmF5LkFMTFxufSk7XG52YXIgZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHN0YXJ0VG9FbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbWVtYmVyUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlVG9UaW1lT2ZJbXBhY3QgPSBmdW5jdGlvbihkdCl7XG5cbiAgICBpZih0aGlzLmNjZFNwZWVkVGhyZXNob2xkIDwgMCB8fCB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgPCBNYXRoLnBvdyh0aGlzLmNjZFNwZWVkVGhyZXNob2xkLCAyKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2ZWMyLm5vcm1hbGl6ZShkaXJlY3Rpb24sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgdmVjMi5zY2FsZShlbmQsIHRoaXMudmVsb2NpdHksIGR0KTtcbiAgICB2ZWMyLmFkZChlbmQsIGVuZCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuICAgIHZhciBzdGFydFRvRW5kQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgIHZhciBsZW4gPSB2ZWMyLmxlbmd0aChzdGFydFRvRW5kKTtcblxuICAgIHZhciB0aW1lT2ZJbXBhY3QgPSAxO1xuXG4gICAgdmFyIGhpdDtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmVzdWx0LnJlc2V0KCk7XG4gICAgcmF5LmNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZihyZXN1bHQuYm9keSA9PT0gdGhhdCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGl0ID0gcmVzdWx0LmJvZHk7XG4gICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChlbmQsIHJheSk7XG4gICAgICAgIHZlYzIuc3ViKHN0YXJ0VG9FbmQsIGVuZCwgdGhhdC5wb3NpdGlvbik7XG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHZlYzIubGVuZ3RoKHN0YXJ0VG9FbmQpIC8gbGVuO1xuICAgICAgICByZXN1bHQuc3RvcCgpO1xuICAgIH07XG4gICAgdmVjMi5jb3B5KHJheS5mcm9tLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB2ZWMyLmNvcHkocmF5LnRvLCBlbmQpO1xuICAgIHJheS51cGRhdGUoKTtcbiAgICB0aGlzLndvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xuXG4gICAgaWYoIWhpdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVtZW1iZXJBbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgdmVjMi5jb3B5KHJlbWVtYmVyUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gR290IGEgc3RhcnQgYW5kIGVuZCBwb2ludC4gQXBwcm94aW1hdGUgdGltZSBvZiBpbXBhY3QgdXNpbmcgYmluYXJ5IHNlYXJjaFxuICAgIHZhciBpdGVyID0gMDtcbiAgICB2YXIgdG1pbiA9IDA7XG4gICAgdmFyIHRtaWQgPSAwO1xuICAgIHZhciB0bWF4ID0gdGltZU9mSW1wYWN0O1xuICAgIHdoaWxlICh0bWF4ID49IHRtaW4gJiYgaXRlciA8IHRoaXMuY2NkSXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyKys7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludFxuICAgICAgICB0bWlkID0gKHRtYXggLSB0bWluKSAvIDI7XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgYm9keSB0byB0aGF0IHBvaW50XG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdGltZU9mSW1wYWN0KTtcbiAgICAgICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlICsgc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcblxuICAgICAgICAvLyBjaGVjayBvdmVybGFwXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHRoaXMuYWFiYi5vdmVybGFwcyhoaXQuYWFiYikgJiYgdGhpcy53b3JsZC5uYXJyb3dwaGFzZS5ib2RpZXNPdmVybGFwKHRoaXMsIGhpdCk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWluIHRvIHNlYXJjaCB1cHBlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1pbiA9IHRtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWF4IHRvIHNlYXJjaCBsb3dlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1heCA9IHRtaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lT2ZJbXBhY3QgPSB0bWlkO1xuXG4gICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24pO1xuICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlO1xuXG4gICAgLy8gbW92ZSB0byBUT0lcbiAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5nbGUgKz0gc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBHZXQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBdFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0IEEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAqIEBwYXJhbSAge0FycmF5fSByZWxhdGl2ZVBvaW50IEEgd29ybGQgb3JpZW50ZWQgdmVjdG9yLCBpbmRpY2F0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgdG8gZ2V0IHRoZSB2ZWxvY2l0eSBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0VmVsb2NpdHlBdFBvaW50ID0gZnVuY3Rpb24ocmVzdWx0LCByZWxhdGl2ZVBvaW50KXtcbiAgICB2ZWMyLmNyb3NzVloocmVzdWx0LCByZWxhdGl2ZVBvaW50LCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgdmVjMi5zdWJ0cmFjdChyZXN1bHQsIHRoaXMudmVsb2NpdHksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVweVxuICovXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXB5XCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVwXG4gKi9cbkJvZHkuc2xlZXBFdmVudCA9IHtcbiAgICB0eXBlOiBcInNsZWVwXCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHdha2V1cFxuICovXG5Cb2R5Lndha2VVcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwid2FrZXVwXCJcbn07XG5cbi8qKlxuICogRHluYW1pYyBib2R5LlxuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogU3RhdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgU1RBVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNUQVRJQyA9IDI7XG5cbi8qKlxuICogS2luZW1hdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHByb3BlcnR5IEFXQUtFXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LkFXQUtFID0gMDtcblxuLyoqXG4gKiBAcHJvcGVydHkgU0xFRVBZXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQWSA9IDE7XG5cbi8qKlxuICogQHByb3BlcnR5IFNMRUVQSU5HXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQSU5HID0gMjtcblxuXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6NyxcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMSxcIi4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTIsXCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjYsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3NoYXBlcy9Db252ZXhcIjo0MCxcInBvbHktZGVjb21wXCI6NX1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgU3ByaW5nID0gX2RlcmVxXygnLi9TcHJpbmcnKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyU3ByaW5nO1xuXG4vKipcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXG4gKlxuICogVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMaW5lYXJTcHJpbmdcbiAqIEBleHRlbmRzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdExlbmd0aF0gICBBIG51bWJlciA+IDAuIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBMaW5lYXJTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTcHJpbmcuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlCIGluIGxvY2FsIGJvZHlCIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KHRoaXMubG9jYWxBbmNob3JBLCBvcHRpb25zLmxvY2FsQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weSh0aGlzLmxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpeyB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQil7IHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsgfVxuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuICAgIHZhciB3b3JsZERpc3RhbmNlID0gdmVjMi5kaXN0YW5jZSh3b3JsZEFuY2hvckEsIHdvcmxkQW5jaG9yQik7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IHdvcmxkRGlzdGFuY2U7XG59XG5MaW5lYXJTcHJpbmcucHJvdG90eXBlID0gbmV3IFNwcmluZygpO1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclNwcmluZztcblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQVxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQSl7XG4gICAgdGhpcy5ib2R5QS50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHdvcmxkQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JCXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24od29ybGRBbmNob3JCKXtcbiAgICB0aGlzLmJvZHlCLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQiwgd29ybGRBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5QS50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuYm9keUIudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckIpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2Vfcmo7XG5cbiAgICAvLyBHZXQgd29ybGQgYW5jaG9yc1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcblxuICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXG4gICAgdmVjMi5zdWIocmksIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIuc3ViKHJqLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIC8vIENvbXB1dGUgZGlzdGFuY2UgdmVjdG9yIGJldHdlZW4gd29ybGQgYW5jaG9yIHBvaW50c1xuICAgIHZlYzIuc3ViKHIsIHdvcmxkQW5jaG9yQiwgd29ybGRBbmNob3JBKTtcbiAgICB2YXIgcmxlbiA9IHZlYzIubGVuKHIpO1xuICAgIHZlYzIubm9ybWFsaXplKHJfdW5pdCxyKTtcblxuICAgIC8vY29uc29sZS5sb2cocmxlbilcbiAgICAvL2NvbnNvbGUubG9nKFwiQVwiLHZlYzIuc3RyKHdvcmxkQW5jaG9yQSksXCJCXCIsdmVjMi5zdHIod29ybGRBbmNob3JCKSlcblxuICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcbiAgICB2ZWMyLnN1Yih1LCBib2R5Qi52ZWxvY2l0eSwgYm9keUEudmVsb2NpdHkpO1xuICAgIHZlYzIuY3Jvc3NaVih0bXAsIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgcmopO1xuICAgIHZlYzIuYWRkKHUsIHUsIHRtcCk7XG4gICAgdmVjMi5jcm9zc1pWKHRtcCwgYm9keUEuYW5ndWxhclZlbG9jaXR5LCByaSk7XG4gICAgdmVjMi5zdWIodSwgdSwgdG1wKTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICB2ZWMyLnNjYWxlKGYsIHJfdW5pdCwgLWsqKHJsZW4tbCkgLSBkKnZlYzIuZG90KHUscl91bml0KSk7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIHZlYzIuc3ViKCBib2R5QS5mb3JjZSwgYm9keUEuZm9yY2UsIGYpO1xuICAgIHZlYzIuYWRkKCBib2R5Qi5mb3JjZSwgYm9keUIuZm9yY2UsIGYpO1xuXG4gICAgLy8gQW5ndWxhciBmb3JjZVxuICAgIHZhciByaV94X2YgPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLCBmKTtcbiAgICB2YXIgcmpfeF9mID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgZik7XG4gICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHJpX3hfZjtcbiAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gcmpfeF9mO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTcsXCIuL1NwcmluZ1wiOjM0fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSBfZGVyZXFfKCcuL1NwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQSByb3RhdGlvbmFsIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzIHJvdGF0aW9uLiBUaGlzIHNwcmluZyBleHBsaWNpdGx5IGFkZHMgYW5ndWxhckZvcmNlICh0b3JxdWUpIHRvIHRoZSBib2RpZXMuXG4gKlxuICogVGhlIHNwcmluZyBjYW4gYmUgY29tYmluZWQgd2l0aCBhIHt7I2Nyb3NzTGluayBcIlJldm9sdXRlQ29uc3RyYWludFwifX17ey9jcm9zc0xpbmt9fSB0byBtYWtlLCBmb3IgZXhhbXBsZSwgYSBtb3VzZSB0cmFwLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RBbmdsZV0gVGhlIHJlbGF0aXZlIGFuZ2xlIG9mIGJvZGllcyBhdCB3aGljaCB0aGUgc3ByaW5nIGlzIGF0IHJlc3QuIElmIG5vdCBnaXZlbiwgaXQncyBzZXQgdG8gdGhlIGN1cnJlbnQgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gQSBudW1iZXIgPj0gMC5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgYW5nbGUgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdEFuZ2xlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RBbmdsZSA9IHR5cGVvZihvcHRpb25zLnJlc3RBbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RBbmdsZSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG59XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RBbmdsZSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHggPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlLFxuICAgICAgICB1ID0gYm9keUIuYW5ndWxhclZlbG9jaXR5IC0gYm9keUEuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgdmFyIHRvcnF1ZSA9IC0gayAqICh4IC0gbCkgLSBkICogdSAqIDA7XG5cbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gdG9ycXVlO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSB0b3JxdWU7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TcHJpbmdcIjozNH1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblxuLyoqXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMgYW5kIGRvZXMgdGhlcmVmb3JlIG5vdCBwdXQgbG9hZCBvbiB0aGUgY29uc3RyYWludCBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cbiAqL1xuZnVuY3Rpb24gU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3M7XG5cbiAgICAvKipcbiAgICAgKiBEYW1waW5nIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IG9wdGlvbnMuZGFtcGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNvbm5lY3RlZCBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5TcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi91dGlscy9VdGlsc1wiOjU3fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKTtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVG9wRG93blZlaGljbGU7XG5cbi8qKlxuICogQGNsYXNzIFRvcERvd25WZWhpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gY2hhc3Npc0JvZHkgQSBkeW5hbWljIGJvZHksIGFscmVhZHkgYWRkZWQgdG8gdGhlIHdvcmxkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIGR5bmFtaWMgYm9keSBmb3IgdGhlIGNoYXNzaXNcbiAqICAgICB2YXIgY2hhc3Npc0JvZHkgPSBuZXcgQm9keSh7XG4gKiAgICAgICAgIG1hc3M6IDFcbiAqICAgICB9KTtcbiAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHsgd2lkdGg6IDAuNSwgaGVpZ2h0OiAxIH0pO1xuICogICAgIGNoYXNzaXNCb2R5LmFkZFNoYXBlKGJveFNoYXBlKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGNoYXNzaXNCb2R5KTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSB2ZWhpY2xlXG4gKiAgICAgdmFyIHZlaGljbGUgPSBuZXcgVG9wRG93blZlaGljbGUoY2hhc3Npc0JvZHkpO1xuICpcbiAqICAgICAvLyBBZGQgb25lIGZyb250IHdoZWVsIGFuZCBvbmUgYmFjayB3aGVlbCAtIHdlIGRvbid0IGFjdHVhbGx5IG5lZWQgZm91ciA6KVxuICogICAgIHZhciBmcm9udFdoZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XG4gKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAwLjVdIC8vIGZyb250XG4gKiAgICAgfSk7XG4gKiAgICAgZnJvbnRXaGVlbC5zZXRTaWRlRnJpY3Rpb24oNCk7XG4gKlxuICogICAgIC8vIEJhY2sgd2hlZWxcbiAqICAgICB2YXIgYmFja1doZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XG4gKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAtMC41XSAvLyBiYWNrXG4gKiAgICAgfSk7XG4gKiAgICAgYmFja1doZWVsLnNldFNpZGVGcmljdGlvbigzKTsgLy8gTGVzcyBzaWRlIGZyaWN0aW9uIG9uIGJhY2sgd2hlZWwgbWFrZXMgaXQgZWFzaWVyIHRvIGRyaWZ0XG4gKiAgICAgdmVoaWNsZS5hZGRUb1dvcmxkKHdvcmxkKTtcbiAqXG4gKiAgICAgLy8gU3RlZXIgdmFsdWUgemVybyBtZWFucyBzdHJhaWdodCBmb3J3YXJkLiBQb3NpdGl2ZSBpcyBsZWZ0IGFuZCBuZWdhdGl2ZSByaWdodC5cbiAqICAgICBmcm9udFdoZWVsLnN0ZWVyVmFsdWUgPSBNYXRoLlBJIC8gMTY7XG4gKlxuICogICAgIC8vIEVuZ2luZSBmb3JjZSBmb3J3YXJkXG4gKiAgICAgYmFja1doZWVsLmVuZ2luZUZvcmNlID0gMTA7XG4gKiAgICAgYmFja1doZWVsLnNldEJyYWtlRm9yY2UoMCk7XG4gKi9cbmZ1bmN0aW9uIFRvcERvd25WZWhpY2xlKGNoYXNzaXNCb2R5LCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gY2hhc3Npc0JvZHlcbiAgICAgKi9cbiAgICB0aGlzLmNoYXNzaXNCb2R5ID0gY2hhc3Npc0JvZHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3aGVlbHNcbiAgICAgKi9cbiAgICB0aGlzLndoZWVscyA9IFtdO1xuXG4gICAgLy8gQSBkdW1teSBib2R5IHRvIGNvbnN0cmFpbiB0aGUgY2hhc3NpcyB0b1xuICAgIHRoaXMuZ3JvdW5kQm9keSA9IG5ldyBCb2R5KHsgbWFzczogMCB9KTtcblxuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMucHJlU3RlcENhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhhdC51cGRhdGUoKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuVG9wRG93blZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHdvcmxkLmFkZEJvZHkodGhpcy5ncm91bmRCb2R5KTtcbiAgICB3b3JsZC5vbigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2hlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxzW2ldO1xuICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KHdoZWVsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5Ub3BEb3duVmVoaWNsZS5wcm90b3R5cGUucmVtb3ZlRnJvbVdvcmxkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xuICAgIHdvcmxkLnJlbW92ZUJvZHkodGhpcy5ncm91bmRCb2R5KTtcbiAgICB3b3JsZC5vZmYoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgd2hlZWwgPSB0aGlzLndoZWVsc1tpXTtcbiAgICAgICAgd29ybGQucmVtb3ZlQ29uc3RyYWludCh3aGVlbCk7XG4gICAgfVxuICAgIHRoaXMud29ybGQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gW3doZWVsT3B0aW9uc11cbiAqIEByZXR1cm4ge1doZWVsQ29uc3RyYWludH1cbiAqL1xuVG9wRG93blZlaGljbGUucHJvdG90eXBlLmFkZFdoZWVsID0gZnVuY3Rpb24od2hlZWxPcHRpb25zKXtcbiAgICB2YXIgd2hlZWwgPSBuZXcgV2hlZWxDb25zdHJhaW50KHRoaXMsd2hlZWxPcHRpb25zKTtcbiAgICB0aGlzLndoZWVscy5wdXNoKHdoZWVsKTtcbiAgICByZXR1cm4gd2hlZWw7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblRvcERvd25WZWhpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aGVlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53aGVlbHNbaV0udXBkYXRlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAY2xhc3MgV2hlZWxDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtDb25zdHJhaW50fVxuICogQHBhcmFtIHtWZWhpY2xlfSB2ZWhpY2xlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3JdVGhlIGxvY2FsIHdoZWVsIGZvcndhcmQgdmVjdG9yIGluIGxvY2FsIGJvZHkgc3BhY2UuIERlZmF1bHQgaXMgemVyby5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsUG9zaXRpb25dIFRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgd2hlZW4gaW4gdGhlIGNoYXNzaXMgYm9keS4gRGVmYXVsdCBpcyB6ZXJvIC0gdGhlIGNlbnRlciBvZiB0aGUgYm9keS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnNpZGVGcmljdGlvbj01XSBUaGUgbWF4IGZyaWN0aW9uIGZvcmNlIGluIHRoZSBzaWRld2F5cyBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIFdoZWVsQ29uc3RyYWludCh2ZWhpY2xlLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMudmVoaWNsZSA9IHZlaGljbGU7XG5cbiAgICB0aGlzLmZvcndhcmRFcXVhdGlvbiA9IG5ldyBGcmljdGlvbkVxdWF0aW9uKHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XG5cbiAgICB0aGlzLnNpZGVFcXVhdGlvbiA9IG5ldyBGcmljdGlvbkVxdWF0aW9uKHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RlZXJWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMuc3RlZXJWYWx1ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZW5naW5lRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLmVuZ2luZUZvcmNlID0gMDtcblxuICAgIHRoaXMuc2V0U2lkZUZyaWN0aW9uKG9wdGlvbnMuc2lkZUZyaWN0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNpZGVGcmljdGlvbiA6IDUpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxGb3J3YXJkVmVjdG9yXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgMSk7XG4gICAgaWYob3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3Ipe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5sb2NhbEZvcndhcmRWZWN0b3IsIG9wdGlvbnMubG9jYWxGb3J3YXJkVmVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbFBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5sb2NhbFBvc2l0aW9uID0gdmVjMi5mcm9tVmFsdWVzKDAsIDApO1xuICAgIGlmKG9wdGlvbnMubG9jYWxQb3NpdGlvbil7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvY2FsUG9zaXRpb24sIG9wdGlvbnMubG9jYWxQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgQ29uc3RyYWludC5hcHBseSh0aGlzLCB2ZWhpY2xlLmNoYXNzaXNCb2R5LCB2ZWhpY2xlLmdyb3VuZEJvZHkpO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5mb3J3YXJkRXF1YXRpb24sXG4gICAgICAgIHRoaXMuc2lkZUVxdWF0aW9uXG4gICAgKTtcblxuICAgIHRoaXMuc2V0QnJha2VGb3JjZSgwKTtcbn1cbldoZWVsQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0Rm9yd2FyZEZyaWN0aW9uXG4gKi9cbldoZWVsQ29uc3RyYWludC5wcm90b3R5cGUuc2V0QnJha2VGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlKXtcbiAgICB0aGlzLmZvcndhcmRFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFNpZGVGcmljdGlvblxuICovXG5XaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLnNldFNpZGVGcmljdGlvbiA9IGZ1bmN0aW9uKGZvcmNlKXtcbiAgICB0aGlzLnNpZGVFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xufTtcblxudmFyIHdvcmxkVmVsb2NpdHkgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbGF0aXZlUG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0U3BlZWRcbiAqL1xuV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5nZXRTcGVlZCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxhdGl2ZVBvaW50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvcik7XG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRQb2ludCh3b3JsZFZlbG9jaXR5LCByZWxhdGl2ZVBvaW50KTtcbiAgICByZXR1cm4gdmVjMi5kb3Qod29ybGRWZWxvY2l0eSwgcmVsYXRpdmVQb2ludCk7XG59O1xuXG52YXIgdG1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5XaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBEaXJlY3Rpb25hbFxuICAgIHRoaXMudmVoaWNsZS5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5mb3J3YXJkRXF1YXRpb24udCwgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IpO1xuICAgIHZlYzIucm90YXRlKHRoaXMuc2lkZUVxdWF0aW9uLnQsIHRoaXMubG9jYWxGb3J3YXJkVmVjdG9yLCBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnNpZGVFcXVhdGlvbi50LCB0aGlzLnNpZGVFcXVhdGlvbi50KTtcblxuICAgIHZlYzIucm90YXRlKHRoaXMuZm9yd2FyZEVxdWF0aW9uLnQsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLnQsIHRoaXMuc3RlZXJWYWx1ZSk7XG4gICAgdmVjMi5yb3RhdGUodGhpcy5zaWRlRXF1YXRpb24udCwgdGhpcy5zaWRlRXF1YXRpb24udCwgdGhpcy5zdGVlclZhbHVlKTtcblxuICAgIC8vIEF0dGFjaG1lbnQgcG9pbnRcbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkudG9Xb3JsZEZyYW1lKHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHRoaXMubG9jYWxQb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KHRoaXMuc2lkZUVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEIpO1xuXG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB0aGlzLmxvY2FsUG9zaXRpb24pO1xuICAgIHZlYzIuY29weSh0aGlzLnNpZGVFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB0aGlzLmZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRBKTtcblxuICAgIC8vIEFkZCBlbmdpbmUgZm9yY2VcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0bXBWZWMsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLnQpO1xuICAgIHZlYzIuc2NhbGUodG1wVmVjLCB0bXBWZWMsIHRoaXMuZW5naW5lRm9yY2UpO1xuXG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LmFwcGx5Rm9yY2UodG1wVmVjLCB0aGlzLmZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRBKTtcbn07XG59LHtcIi4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjoxNCxcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1N31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIEV4cG9ydCBwMiBjbGFzc2VzXG52YXIgcDIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQUJCIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0FBQkInKSxcbiAgICBBbmdsZUxvY2tFcXVhdGlvbiA6ICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJyksXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvQm9keScpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENhcHN1bGUgOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2Fwc3VsZScpLFxuICAgIENpcmNsZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0RXF1YXRpb24gOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgIENvbnRhY3RFcXVhdGlvblBvb2wgOiAgICAgICAgICAgX2RlcmVxXygnLi91dGlscy9Db250YWN0RXF1YXRpb25Qb29sJyksXG4gICAgQ29udGFjdE1hdGVyaWFsIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbCcpLFxuICAgIENvbnZleCA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ29udmV4JyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudEVtaXR0ZXIgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXZlbnRzL0V2ZW50RW1pdHRlcicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb24gOiAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb25Qb29sIDogICAgICAgICAgX2RlcmVxXygnLi91dGlscy9GcmljdGlvbkVxdWF0aW9uUG9vbCcpLFxuICAgIEdlYXJDb25zdHJhaW50IDogICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludCcpLFxuICAgIEdTU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvR1NTb2x2ZXInKSxcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXG4gICAgTGluZSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9MaW5lJyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0ZXJpYWwgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGVyaWFsL01hdGVyaWFsJyksXG4gICAgTmFycm93cGhhc2UgOiAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYXJyb3dwaGFzZScpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgUGFydGljbGUgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIFBsYW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUGxhbmUnKSxcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvUG9vbCcpLFxuICAgIFJldm9sdXRlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKSxcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50IDogICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXG4gICAgQm94IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9Cb3gnKSxcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA6ICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJyksXG4gICAgU0FQQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJyksXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9TaGFwZScpLFxuICAgIFNvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvU29sdmVyJyksXG4gICAgU3ByaW5nIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgVG9wRG93blZlaGljbGUgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvVG9wRG93blZlaGljbGUnKSxcbiAgICBMaW5lYXJTcHJpbmcgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKSxcbiAgICBSb3RhdGlvbmFsU3ByaW5nIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nJyksXG4gICAgVXRpbHMgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3V0aWxzL1V0aWxzJyksXG4gICAgV29ybGQgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3dvcmxkL1dvcmxkJyksXG4gICAgdmVjMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGgvdmVjMicpLFxuICAgIHZlcnNpb24gOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwMiwgJ1JlY3RhbmdsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBSZWN0YW5nbGUgY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB0byBCb3guJyk7XG4gICAgICAgIHJldHVybiB0aGlzLkJveDtcbiAgICB9XG59KTtcbn0se1wiLi4vcGFja2FnZS5qc29uXCI6NixcIi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo5LFwiLi9jb2xsaXNpb24vTmFycm93cGhhc2VcIjoxMCxcIi4vY29sbGlzaW9uL1JheVwiOjExLFwiLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEyLFwiLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjEzLFwiLi9jb25zdHJhaW50cy9Db25zdHJhaW50XCI6MTQsXCIuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludFwiOjE1LFwiLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE2LFwiLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludFwiOjE3LFwiLi9jb25zdHJhaW50cy9QcmlzbWF0aWNDb25zdHJhaW50XCI6MTgsXCIuL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjE5LFwiLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb25cIjoyMCxcIi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIxLFwiLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMixcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMyxcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXCI6MjUsXCIuL2V2ZW50cy9FdmVudEVtaXR0ZXJcIjoyNixcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjcsXCIuL21hdGVyaWFsL01hdGVyaWFsXCI6MjgsXCIuL21hdGgvdmVjMlwiOjMwLFwiLi9vYmplY3RzL0JvZHlcIjozMSxcIi4vb2JqZWN0cy9MaW5lYXJTcHJpbmdcIjozMixcIi4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nXCI6MzMsXCIuL29iamVjdHMvU3ByaW5nXCI6MzQsXCIuL29iamVjdHMvVG9wRG93blZlaGljbGVcIjozNSxcIi4vc2hhcGVzL0JveFwiOjM3LFwiLi9zaGFwZXMvQ2Fwc3VsZVwiOjM4LFwiLi9zaGFwZXMvQ2lyY2xlXCI6MzksXCIuL3NoYXBlcy9Db252ZXhcIjo0MCxcIi4vc2hhcGVzL0hlaWdodGZpZWxkXCI6NDEsXCIuL3NoYXBlcy9MaW5lXCI6NDIsXCIuL3NoYXBlcy9QYXJ0aWNsZVwiOjQzLFwiLi9zaGFwZXMvUGxhbmVcIjo0NCxcIi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuL3V0aWxzL0NvbnRhY3RFcXVhdGlvblBvb2xcIjo0OCxcIi4vdXRpbHMvRnJpY3Rpb25FcXVhdGlvblBvb2xcIjo0OSxcIi4vdXRpbHMvUG9vbFwiOjU1LFwiLi91dGlscy9VdGlsc1wiOjU3LFwiLi93b3JsZC9Xb3JsZFwiOjYxfV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi9Db252ZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3g7XG5cbi8qKlxuICogQm94IHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIEJveFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTFdIFRvdGFsIHdpZHRoIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MV0gVG90YWwgaGVpZ2h0IG9mIHRoZSBib3hcbiAqIEBleHRlbmRzIENvbnZleFxuICovXG5mdW5jdGlvbiBCb3gob3B0aW9ucyl7XG4gICAgaWYodHlwZW9mKGFyZ3VtZW50c1swXSkgPT09ICdudW1iZXInICYmIHR5cGVvZihhcmd1bWVudHNbMV0pID09PSAnbnVtYmVyJyl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgaGVpZ2h0OiBhcmd1bWVudHNbMV1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgUmVjdGFuZ2xlIGhhcyBiZWVuIHJlbmFtZWQgdG8gQm94IGFuZCBpdHMgY29uc3RydWN0b3Igc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBuZXcgQm94KHsgd2lkdGg6IDEsIGhlaWdodDogMSwgLi4uIH0pJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgd2lkdGggb2YgdGhlIGJveFxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMTtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIGhlaWdodCBvZiB0aGUgYm94XG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgMTtcblxuICAgIHZhciB2ZXJ0cyA9IFtcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAtaGVpZ2h0LzIpLFxuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoIHdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgIGhlaWdodC8yKSxcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAgaGVpZ2h0LzIpXG4gICAgXTtcbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKDEsIDApLFxuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoMCwgMSlcbiAgICBdO1xuXG4gICAgb3B0aW9ucy52ZXJ0aWNlcyA9IHZlcnRzO1xuICAgIG9wdGlvbnMuYXhlcyA9IGF4ZXM7XG4gICAgb3B0aW9ucy50eXBlID0gU2hhcGUuQk9YO1xuICAgIENvbnZleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuQm94LnByb3RvdHlwZSA9IG5ldyBDb252ZXgoKTtcbkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3g7XG5cbi8qKlxuICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQm94LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1c1xuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHcqdyArIGgqaCkgLyAyO1xufTtcblxudmFyIGNvcm5lcjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjMgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5Cb3gucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHRoaXMudmVydGljZXMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbn07XG5cblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4vQ29udmV4XCI6NDAsXCIuL1NoYXBlXCI6NDV9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDYXBzdWxlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENhcHN1bGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVuZ3RoPTFdIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIFJhZGl1cyBvZiB0aGUgY2Fwc3VsZVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgY2Fwc3VsZVNoYXBlID0gbmV3IENhcHN1bGUoe1xuICogICAgICAgICBsZW5ndGg6IDEsXG4gKiAgICAgICAgIHJhZGl1czogMlxuICogICAgIH0pO1xuICogICAgIGJvZHkuYWRkU2hhcGUoY2Fwc3VsZVNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ2Fwc3VsZShvcHRpb25zKXtcbiAgICBpZih0eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxlbmd0aDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgcmFkaXVzOiBhcmd1bWVudHNbMV1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgQ2Fwc3VsZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IG5ldyBDYXBzdWxlKHsgcmFkaXVzOiAxLCBsZW5ndGg6IDEgfSknKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2Fwc3VsZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAxO1xuXG4gICAgb3B0aW9ucy50eXBlID0gU2hhcGUuQ0FQU1VMRTtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuQ2Fwc3VsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNhcHN1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDYXBzdWxlLlxuICogQG1ldGhvZCBjb25wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0b2RvXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIHJlY3RhbmdsZVxuICAgIHZhciByID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIHcgPSB0aGlzLmxlbmd0aCArIHIsIC8vIDIqciBpcyB0b28gbXVjaCwgMCBpcyB0b28gbGl0dGxlXG4gICAgICAgIGggPSByKjI7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXMgKyB0aGlzLmxlbmd0aC8yO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKyB0aGlzLnJhZGl1cyAqIDIgKiB0aGlzLmxlbmd0aDtcbn07XG5cbnZhciByID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXG4gICAgLy8gQ29tcHV0ZSBjZW50ZXIgcG9zaXRpb24gb2Ygb25lIG9mIHRoZSB0aGUgY2lyY2xlcywgd29ybGQgb3JpZW50ZWQsIGJ1dCB3aXRoIGxvY2FsIG9mZnNldFxuICAgIHZlYzIuc2V0KHIsdGhpcy5sZW5ndGggLyAyLDApO1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUocixyLGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYm91bmRzXG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICBNYXRoLm1heChyWzBdK3JhZGl1cywgLXJbMF0rcmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJbMV0rcmFkaXVzLCAtclsxXStyYWRpdXMpKTtcbiAgICB2ZWMyLnNldChvdXQubG93ZXJCb3VuZCwgIE1hdGgubWluKHJbMF0tcmFkaXVzLCAtclswXS1yYWRpdXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oclsxXS1yYWRpdXMsIC1yWzFdLXJhZGl1cykpO1xuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIHZlYzIuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xufTtcblxudmFyIGludGVyc2VjdENhcHN1bGVfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENhcHN1bGVfbDAgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENhcHN1bGVfbDEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENhcHN1bGVfdW5pdF95ID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuXG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RDYXBzdWxlX2hpdFBvaW50V29ybGQ7XG4gICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdENhcHN1bGVfbm9ybWFsO1xuICAgIHZhciBsMCA9IGludGVyc2VjdENhcHN1bGVfbDA7XG4gICAgdmFyIGwxID0gaW50ZXJzZWN0Q2Fwc3VsZV9sMTtcblxuICAgIC8vIFRoZSBzaWRlc1xuICAgIHZhciBoYWxmTGVuID0gdGhpcy5sZW5ndGggLyAyO1xuICAgIGZvcih2YXIgaT0wOyBpPDI7IGkrKyl7XG5cbiAgICAgICAgLy8gZ2V0IHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgdmFyIHkgPSB0aGlzLnJhZGl1cyAqIChpKjItMSk7XG4gICAgICAgIHZlYzIuc2V0KGwwLCAtaGFsZkxlbiwgeSk7XG4gICAgICAgIHZlYzIuc2V0KGwxLCBoYWxmTGVuLCB5KTtcbiAgICAgICAgdmVjMi50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcbiAgICAgICAgdmVjMi50b0dsb2JhbEZyYW1lKGwxLCBsMSwgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgICAgICB2YXIgZGVsdGEgPSB2ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uKGZyb20sIHRvLCBsMCwgbDEpO1xuICAgICAgICBpZihkZWx0YSA+PSAwKXtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKG5vcm1hbCwgaW50ZXJzZWN0Q2Fwc3VsZV91bml0X3ksIGFuZ2xlKTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUobm9ybWFsLCBub3JtYWwsIChpKjItMSkpO1xuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcbiAgICAgICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENpcmNsZXNcbiAgICB2YXIgZGlhZ29uYWxMZW5ndGhTcXVhcmVkID0gTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICsgTWF0aC5wb3coaGFsZkxlbiwgMik7XG4gICAgZm9yKHZhciBpPTA7IGk8MjsgaSsrKXtcbiAgICAgICAgdmVjMi5zZXQobDAsIGhhbGZMZW4gKiAoaSoyLTEpLCAwKTtcbiAgICAgICAgdmVjMi50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgICAgICB2YXIgYSA9IE1hdGgucG93KHRvWzBdIC0gZnJvbVswXSwgMikgKyBNYXRoLnBvdyh0b1sxXSAtIGZyb21bMV0sIDIpO1xuICAgICAgICB2YXIgYiA9IDIgKiAoKHRvWzBdIC0gZnJvbVswXSkgKiAoZnJvbVswXSAtIGwwWzBdKSArICh0b1sxXSAtIGZyb21bMV0pICogKGZyb21bMV0gLSBsMFsxXSkpO1xuICAgICAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBsMFswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gbDBbMV0sIDIpIC0gTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcblxuICAgICAgICBpZihkZWx0YSA8IDApe1xuICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICAgICAgdmVjMi5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkZWx0YSk7XG5cbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNxcnREZWx0YSA9IE1hdGguc3FydChkZWx0YSk7XG4gICAgICAgICAgICB2YXIgaW52MmEgPSAxIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIHZhciBkMSA9ICgtIGIgLSBzcXJ0RGVsdGEpICogaW52MmE7XG4gICAgICAgICAgICB2YXIgZDIgPSAoLSBiICsgc3FydERlbHRhKSAqIGludjJhO1xuXG4gICAgICAgICAgICBpZihkMSA+PSAwICYmIGQxIDw9IDEpe1xuICAgICAgICAgICAgICAgIHZlYzIubGVycChoaXRQb2ludFdvcmxkLCBmcm9tLCB0bywgZDEpO1xuICAgICAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgbDApO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnNob3VsZFN0b3AocmF5KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGQyID49IDAgJiYgZDIgPD0gMSl7XG4gICAgICAgICAgICAgICAgdmVjMi5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkMik7XG4gICAgICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZDIsIG5vcm1hbCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TaGFwZVwiOjQ1fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XG5cbi8qKlxuICogQ2lyY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENpcmNsZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvcHRpb25zfSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIFRoZSByYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjaXJjbGVTaGFwZSA9IG5ldyBDaXJjbGUoeyByYWRpdXM6IDEgfSk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENpcmNsZShvcHRpb25zKXtcbiAgICBpZih0eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ251bWJlcicpe1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmFkaXVzOiBhcmd1bWVudHNbMF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgQ2lyY2xlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICAgKiBAcHJvcGVydHkgcmFkaXVzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDE7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5DSVJDTEU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cbkNpcmNsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gbWFzcyAqIHIgKiByIC8gMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHZlYzIuc2V0KG91dC51cHBlckJvdW5kLCAgciwgIHIpO1xuICAgIHZlYzIuc2V0KG91dC5sb3dlckJvdW5kLCAtciwgLXIpO1xuICAgIGlmKHBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIH1cbn07XG5cbnZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24ocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGZyb20gPSByYXkuZnJvbSxcbiAgICAgICAgdG8gPSByYXkudG8sXG4gICAgICAgIHIgPSB0aGlzLnJhZGl1cztcblxuICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XG4gICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBwb3NpdGlvblswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gcG9zaXRpb25bMV0pKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBwb3NpdGlvblswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gcG9zaXRpb25bMV0sIDIpIC0gTWF0aC5wb3cociwgMik7XG4gICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGRlbHRhKTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCAtMSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcbiAgICAgICAgdmFyIGludjJhID0gMSAvICgyICogYSk7XG4gICAgICAgIHZhciBkMSA9ICgtIGIgLSBzcXJ0RGVsdGEpICogaW52MmE7XG4gICAgICAgIHZhciBkMiA9ICgtIGIgKyBzcXJ0RGVsdGEpICogaW52MmE7XG5cbiAgICAgICAgaWYoZDEgPj0gMCAmJiBkMSA8PSAxKXtcbiAgICAgICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGQxKTtcblxuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMSwgbm9ybWFsLCAtMSk7XG5cbiAgICAgICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGQyID49IDAgJiYgZDIgPD0gMSl7XG4gICAgICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMik7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZDIsIG5vcm1hbCwgLTEpO1xuICAgICAgICB9XG4gICAgfVxufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL1NoYXBlXCI6NDV9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBwb2x5ayA9IF9kZXJlcV8oJy4uL21hdGgvcG9seWsnKVxuLCAgIGRlY29tcCA9IF9kZXJlcV8oJ3BvbHktZGVjb21wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmV4O1xuXG4vKipcbiAqIENvbnZleCBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDb252ZXhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy52ZXJ0aWNlc10gQW4gYXJyYXkgb2YgdmVydGljZXMgdGhhdCBzcGFuIHRoaXMgc2hhcGUuIFZlcnRpY2VzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSAoQ0NXKSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5heGVzXSBBbiBhcnJheSBvZiB1bml0IGxlbmd0aCB2ZWN0b3JzLCByZXByZXNlbnRpbmcgdGhlIHN5bW1ldHJ5IGF4ZXMgaW4gdGhlIGNvbnZleC5cbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gQ3JlYXRlIGEgYm94XG4gKiAgICAgdmFyIHZlcnRpY2VzID0gW1stMSwtMV0sIFsxLC0xXSwgWzEsMV0sIFstMSwxXV07XG4gKiAgICAgdmFyIGNvbnZleFNoYXBlID0gbmV3IENvbnZleCh7IHZlcnRpY2VzOiB2ZXJ0aWNlcyB9KTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNvbnZleFNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ29udmV4KG9wdGlvbnMpe1xuICAgIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB2ZXJ0aWNlczogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXhlczogYXJndW1lbnRzWzFdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIENvbnZleCBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IG5ldyBDb252ZXgoeyB2ZXJ0aWNlczogWy4uLl0sIC4uLiB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG5cbiAgICAvLyBDb3B5IHRoZSB2ZXJ0c1xuICAgIHZhciB2ZXJ0aWNlcyA9IG9wdGlvbnMudmVydGljZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudmVydGljZXMgOiBbXTtcbiAgICBmb3IodmFyIGk9MDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICB2ZWMyLmNvcHkodiwgdmVydGljZXNbaV0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2godik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXhlcyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4ZXMgPSBbXTtcblxuICAgIGlmKG9wdGlvbnMuYXhlcyl7XG5cbiAgICAgICAgLy8gQ29weSB0aGUgYXhlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IG9wdGlvbnMuYXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkoYXhpcywgb3B0aW9ucy5heGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKGF4aXMpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBheGVzIGZyb20gdGhlIHZlcnRleCBkYXRhXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHRoaXMudmVydGljZXNbKGkrMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xuXG4gICAgICAgICAgICB0aGlzLmF4ZXMucHVzaChub3JtYWwpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIENvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBjZW50ZXJPZk1hc3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJPZk1hc3MgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWFuZ3VsYXRlZCB2ZXJzaW9uIG9mIHRoaXMgY29udmV4LiBUaGUgc3RydWN0dXJlIGlzIEFycmF5IG9mIDMtQXJyYXlzLCBhbmQgZWFjaCBzdWJhcnJheSBjb250YWlucyAzIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgdmVydGljZXMuXG4gICAgICogQHByb3BlcnR5IHRyaWFuZ2xlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYodGhpcy52ZXJ0aWNlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGNvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5DT05WRVg7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbiAgICBpZih0aGlzLmFyZWEgPCAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4IHZlcnRpY2VzIG11c3QgYmUgZ2l2ZW4gaW4gY29udGVyLWNsb2Nrd2lzZSB3aW5kaW5nLlwiKTtcbiAgICB9XG59XG5Db252ZXgucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Db252ZXgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4O1xuXG52YXIgdG1wVmVjMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdG1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogUHJvamVjdCBhIENvbnZleCBvbnRvIGEgd29ybGQtb3JpZW50ZWQgYXhpc1xuICogQG1ldGhvZCBwcm9qZWN0T250b0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEF4aXNcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqL1xuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b0xvY2FsQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgcmVzdWx0KXtcbiAgICB2YXIgbWF4PW51bGwsXG4gICAgICAgIG1pbj1udWxsLFxuICAgICAgICB2LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbG9jYWxBeGlzID0gdG1wVmVjMTtcblxuICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IHZlYzIuZG90KHYsIGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIHZlYzIuc2V0KHJlc3VsdCwgbWluLCBtYXgpO1xufTtcblxuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b1dvcmxkQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgc2hhcGVPZmZzZXQsIHNoYXBlQW5nbGUsIHJlc3VsdCl7XG4gICAgdmFyIHdvcmxkQXhpcyA9IHRtcFZlYzI7XG5cbiAgICB0aGlzLnByb2plY3RPbnRvTG9jYWxBeGlzKGxvY2FsQXhpcywgcmVzdWx0KTtcblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICBpZihzaGFwZUFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBeGlzLCBsb2NhbEF4aXMsIHNoYXBlQW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmxkQXhpcyA9IGxvY2FsQXhpcztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHZlYzIuZG90KHNoYXBlT2Zmc2V0LCB3b3JsZEF4aXMpO1xuXG4gICAgdmVjMi5zZXQocmVzdWx0LCByZXN1bHRbMF0gKyBvZmZzZXQsIHJlc3VsdFsxXSArIG9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAudHJpYW5nbGVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZVRyaWFuZ2xlc1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZVRyaWFuZ2xlcyA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnRyaWFuZ2xlcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmV3cml0ZSBvbiBwb2x5ayBub3RhdGlvbiwgYXJyYXkgb2YgbnVtYmVyc1xuICAgIHZhciBwb2x5a1ZlcnRzID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgcG9seWtWZXJ0cy5wdXNoKHZbMF0sdlsxXSk7XG4gICAgfVxuXG4gICAgLy8gVHJpYW5ndWxhdGVcbiAgICB2YXIgdHJpYW5nbGVzID0gcG9seWsuVHJpYW5ndWxhdGUocG9seWtWZXJ0cyk7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHRyaWFuZ2xlcywgYWRkIHRoZWlyIGluZXJ0aWEgY29udHJpYnV0aW9ucyB0byBJXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpYW5nbGVzLmxlbmd0aDsgaSs9Myl7XG4gICAgICAgIHZhciBpZDEgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBpZDIgPSB0cmlhbmdsZXNbaSsxXSxcbiAgICAgICAgICAgIGlkMyA9IHRyaWFuZ2xlc1tpKzJdO1xuXG4gICAgICAgIC8vIEFkZCB0byB0cmlhbmdsZXNcbiAgICAgICAgdGhpcy50cmlhbmdsZXMucHVzaChbaWQxLGlkMixpZDNdKTtcbiAgICB9XG59O1xuXG52YXIgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19iID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2FjID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jYiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmNlbnRlck9mTWFzcyBwcm9wZXJ0eS5cbiAqIEBtZXRob2QgdXBkYXRlQ2VudGVyT2ZNYXNzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQ2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgY20gPSB0aGlzLmNlbnRlck9mTWFzcyxcbiAgICAgICAgY2VudHJvaWQgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQsXG4gICAgICAgIG4gPSB1cGRhdGVDZW50ZXJPZk1hc3NfbixcbiAgICAgICAgYSA9IHVwZGF0ZUNlbnRlck9mTWFzc19hLFxuICAgICAgICBiID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2IsXG4gICAgICAgIGMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYyxcbiAgICAgICAgYWMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYWMsXG4gICAgICAgIGNhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NhLFxuICAgICAgICBjYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19jYixcbiAgICAgICAgY2VudHJvaWRfdGltZXNfbWFzcyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzO1xuXG4gICAgdmVjMi5zZXQoY20sMCwwKTtcbiAgICB2YXIgdG90YWxBcmVhID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBhID0gdmVydHNbdFswXV0sXG4gICAgICAgICAgICBiID0gdmVydHNbdFsxXV0sXG4gICAgICAgICAgICBjID0gdmVydHNbdFsyXV07XG5cbiAgICAgICAgdmVjMi5jZW50cm9pZChjZW50cm9pZCxhLGIsYyk7XG5cbiAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcbiAgICAgICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzgwMTk4L2FyZWEtb2YtdHJpYW5nbGUtdmlhLXZlY3RvcnNcbiAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsYixjKTtcbiAgICAgICAgdG90YWxBcmVhICs9IG07XG5cbiAgICAgICAgLy8gQWRkIHRvIGNlbnRlciBvZiBtYXNzXG4gICAgICAgIHZlYzIuc2NhbGUoY2VudHJvaWRfdGltZXNfbWFzcywgY2VudHJvaWQsIG0pO1xuICAgICAgICB2ZWMyLmFkZChjbSwgY20sIGNlbnRyb2lkX3RpbWVzX21hc3MpO1xuICAgIH1cblxuICAgIHZlYzIuc2NhbGUoY20sY20sMS90b3RhbEFyZWEpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDb252ZXguXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzM0MjgyMi1tb21lbnQtb2YtaW5lcnRpYS1vZi1hLXBvbHlnb24tMmQvXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciBkZW5vbSA9IDAuMCxcbiAgICAgICAgbnVtZXIgPSAwLjAsXG4gICAgICAgIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBmb3IodmFyIGogPSBOLTEsIGkgPSAwOyBpIDwgTjsgaiA9IGksIGkgKyspe1xuICAgICAgICB2YXIgcDAgPSB0aGlzLnZlcnRpY2VzW2pdO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YXIgYSA9IE1hdGguYWJzKHZlYzIuY3Jvc3NMZW5ndGgocDAscDEpKTtcbiAgICAgICAgdmFyIGIgPSB2ZWMyLmRvdChwMSxwMSkgKyB2ZWMyLmRvdChwMSxwMCkgKyB2ZWMyLmRvdChwMCxwMCk7XG4gICAgICAgIGRlbm9tICs9IGEgKiBiO1xuICAgICAgICBudW1lciArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gKG1hc3MgLyA2LjApICogKGRlbm9tIC8gbnVtZXIpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSAuYm91bmRpbmdSYWRpdXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcjIgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBsMiA9IHZlYzIuc3F1YXJlZExlbmd0aCh2ZXJ0c1tpXSk7XG4gICAgICAgIGlmKGwyID4gcjIpe1xuICAgICAgICAgICAgcjIgPSBsMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQocjIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIHBvaW50cyBhLCBiLCBjLiBUaGUgYXJlYSBpcyBwb3NpdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciwgb3RoZXJ3aXNlIG5lZ2F0aXZlLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCB0cmlhbmdsZUFyZWFcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ29udmV4LnRyaWFuZ2xlQXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKSAqIDAuNTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYVxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT10cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGEgPSB2ZXJ0c1t0WzBdXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0c1t0WzFdXSxcbiAgICAgICAgICAgIGMgPSB2ZXJ0c1t0WzJdXTtcblxuICAgICAgICAvLyBHZXQgbWFzcyBmb3IgdGhlIHRyaWFuZ2xlIChkZW5zaXR5PTEgaW4gdGhpcyBjYXNlKVxuICAgICAgICB2YXIgbSA9IENvbnZleC50cmlhbmdsZUFyZWEoYSxiLGMpO1xuICAgICAgICB0aGlzLmFyZWEgKz0gbTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcbn07XG5cbnZhciBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENvbnZleF9yYXlFbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByYXlTdGFydCA9IGludGVyc2VjdENvbnZleF9yYXlTdGFydDtcbiAgICB2YXIgcmF5RW5kID0gaW50ZXJzZWN0Q29udmV4X3JheUVuZDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X25vcm1hbDtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRvIGxvY2FsIHNoYXBlIHNwYWNlXG4gICAgdmVjMi50b0xvY2FsRnJhbWUocmF5U3RhcnQsIHJheS5mcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKHJheUVuZCwgcmF5LnRvLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgdmFyIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgIXJlc3VsdC5zaG91bGRTdG9wKHJheSk7IGkrKykge1xuICAgICAgICB2YXIgcTEgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFyIHEyID0gdmVydGljZXNbKGkrMSkgJSBuXTtcbiAgICAgICAgdmFyIGRlbHRhID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihyYXlTdGFydCwgcmF5RW5kLCBxMSwgcTIpO1xuXG4gICAgICAgIGlmKGRlbHRhID49IDApe1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBxMiwgcTEpO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBub3JtYWwsIC1NYXRoLlBJIC8gMiArIGFuZ2xlKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0se1wiLi4vbWF0aC9wb2x5a1wiOjI5LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL1NoYXBlXCI6NDUsXCJwb2x5LWRlY29tcFwiOjV9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHRmaWVsZDtcblxuLyoqXG4gKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZGlzdGFuY2UgXCJlbGVtZW50V2lkdGhcIi5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmhlaWdodHNdIEFuIGFycmF5IG9mIFkgdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdGVycmFpbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5WYWx1ZV0gTWluaW11bSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuIFdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiBub3QgZ2l2ZW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VmFsdWVdIE1heGltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWxlbWVudFdpZHRoPTAuMV0gV29ybGQgc3BhY2luZyBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cbiAqICAgICB2YXIgaGVpZ2h0cyA9IFtdO1xuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xuICogICAgICAgICBoZWlnaHRzLnB1c2goeSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIGhlaWdodGZpZWxkIHNoYXBlXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoe1xuICogICAgICAgICBoZWlnaHRzOiBoZWlnaHRzLFxuICogICAgICAgICBlbGVtZW50V2lkdGg6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb25cbiAqICAgICB9KTtcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICpcbiAqIEB0b2RvIFNob3VsZCB1c2UgYSBzY2FsZSBwcm9wZXJ0eSB3aXRoIFggYW5kIFkgZGlyZWN0aW9uIGluc3RlYWQgb2YganVzdCBlbGVtZW50V2lkdGhcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0ZmllbGQob3B0aW9ucyl7XG4gICAgaWYoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlaWdodHM6IGFyZ3VtZW50c1swXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKHR5cGVvZihhcmd1bWVudHNbMV0pID09PSAnb2JqZWN0Jyl7XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBhcmd1bWVudHNbMV0pe1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IGFyZ3VtZW50c1sxXVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgSGVpZ2h0ZmllbGQgY29uc3RydWN0b3Igc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBuZXcgSGVpZ2h0ZmllbGQoeyBoZWlnaHRzOiBbLi4uXSwgLi4uIH0pJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhlaWdodHNcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodHMgPSBvcHRpb25zLmhlaWdodHMgPyBvcHRpb25zLmhlaWdodHMuc2xpY2UoMCkgOiBbXTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgaGVpZ2h0c1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGhlaWdodHNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1pblZhbHVlID0gb3B0aW9ucy5taW5WYWx1ZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50V2lkdGhcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRXaWR0aCA9IG9wdGlvbnMuZWxlbWVudFdpZHRoIHx8IDAuMTtcblxuICAgIGlmKG9wdGlvbnMubWF4VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1pblZhbHVlID09PSB1bmRlZmluZWQpe1xuICAgICAgICB0aGlzLnVwZGF0ZU1heE1pblZhbHVlcygpO1xuICAgIH1cblxuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLkhFSUdIVEZJRUxEO1xuICAgIFNoYXBlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIGFuZCB0aGUgLm1heFZhbHVlXG4gKiBAbWV0aG9kIHVwZGF0ZU1heE1pblZhbHVlc1xuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlTWF4TWluVmFsdWVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cztcbiAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdO1xuICAgIHZhciBtaW5WYWx1ZSA9IGRhdGFbMF07XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IGRhdGFbaV07XG4gICAgICAgIGlmKHYgPiBtYXhWYWx1ZSl7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgaWYodiA8IG1pblZhbHVlKXtcbiAgICAgICAgICAgIG1pblZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1heFZhbHVlID0gbWF4VmFsdWU7XG4gICAgdGhpcy5taW5WYWx1ZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cyxcbiAgICAgICAgYXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgYXJlYSArPSAoZGF0YVtpXStkYXRhW2krMV0pIC8gMiAqIHRoaXMuZWxlbWVudFdpZHRoO1xuICAgIH1cbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xufTtcblxudmFyIHBvaW50cyA9IFtcbiAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIHZlYzIuY3JlYXRlKCksXG4gICAgdmVjMi5jcmVhdGUoKSxcbiAgICB2ZWMyLmNyZWF0ZSgpXG5dO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmVjMi5zZXQocG9pbnRzWzBdLCAwLCB0aGlzLm1heFZhbHVlKTtcbiAgICB2ZWMyLnNldChwb2ludHNbMV0sIHRoaXMuZWxlbWVudFdpZHRoICogdGhpcy5oZWlnaHRzLmxlbmd0aCwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzJdLCB0aGlzLmVsZW1lbnRXaWR0aCAqIHRoaXMuaGVpZ2h0cy5sZW5ndGgsIHRoaXMubWluVmFsdWUpO1xuICAgIHZlYzIuc2V0KHBvaW50c1szXSwgMCwgdGhpcy5taW5WYWx1ZSk7XG4gICAgb3V0LnNldEZyb21Qb2ludHMocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBsaW5lIHNlZ21lbnQgaW4gdGhlIGhlaWdodGZpZWxkXG4gKiBAbWV0aG9kIGdldExpbmVTZWdtZW50XG4gKiBAcGFyYW0gIHthcnJheX0gc3RhcnQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzdGFydCBwb2ludFxuICogQHBhcmFtICB7YXJyYXl9IGVuZCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIGVuZCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRMaW5lU2VnbWVudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGkpe1xuICAgIHZhciBkYXRhID0gdGhpcy5oZWlnaHRzO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZWxlbWVudFdpZHRoO1xuICAgIHZlYzIuc2V0KHN0YXJ0LCBpICogd2lkdGgsIGRhdGFbaV0pO1xuICAgIHZlYzIuc2V0KGVuZCwgKGkgKyAxKSAqIHdpZHRoLCBkYXRhW2kgKyAxXSk7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24ocG9zaXRpb24pe1xuICAgIHJldHVybiBNYXRoLmZsb29yKHBvc2l0aW9uWzBdIC8gdGhpcy5lbGVtZW50V2lkdGgpO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENsYW1wZWRTZWdtZW50SW5kZXggPSBmdW5jdGlvbihwb3NpdGlvbil7XG4gICAgdmFyIGkgPSB0aGlzLmdldFNlZ21lbnRJbmRleChwb3NpdGlvbik7XG4gICAgaSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0cy5sZW5ndGgsIE1hdGgubWF4KGksIDApKTsgLy8gY2xhbXBcbiAgICByZXR1cm4gaTtcbn07XG5cbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbDAgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2wxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbEZyb20gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsVG8gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX3VuaXRfeSA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG4vLyBSZXR1cm5zIDEgaWYgdGhlIGxpbmVzIGludGVyc2VjdCwgb3RoZXJ3aXNlIDAuXG5mdW5jdGlvbiBnZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb24gKG91dCwgcDAsIHAxLCBwMiwgcDMpIHtcblxuICAgIHZhciBzMV94LCBzMV95LCBzMl94LCBzMl95O1xuICAgIHMxX3ggPSBwMVswXSAtIHAwWzBdO1xuICAgIHMxX3kgPSBwMVsxXSAtIHAwWzFdO1xuICAgIHMyX3ggPSBwM1swXSAtIHAyWzBdO1xuICAgIHMyX3kgPSBwM1sxXSAtIHAyWzFdO1xuXG4gICAgdmFyIHMsIHQ7XG4gICAgcyA9ICgtczFfeSAqIChwMFswXSAtIHAyWzBdKSArIHMxX3ggKiAocDBbMV0gLSBwMlsxXSkpIC8gKC1zMl94ICogczFfeSArIHMxX3ggKiBzMl95KTtcbiAgICB0ID0gKCBzMl94ICogKHAwWzFdIC0gcDJbMV0pIC0gczJfeSAqIChwMFswXSAtIHAyWzBdKSkgLyAoLXMyX3ggKiBzMV95ICsgczFfeCAqIHMyX3kpO1xuICAgIGlmIChzID49IDAgJiYgcyA8PSAxICYmIHQgPj0gMCAmJiB0IDw9IDEpIHsgLy8gQ29sbGlzaW9uIGRldGVjdGVkXG4gICAgICAgIHZhciBpbnRYID0gcDBbMF0gKyAodCAqIHMxX3gpO1xuICAgICAgICB2YXIgaW50WSA9IHAwWzFdICsgKHQgKiBzMV95KTtcbiAgICAgICAgb3V0WzBdID0gaW50WDtcbiAgICAgICAgb3V0WzFdID0gaW50WTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHJldHVybiAtMTsgLy8gTm8gY29sbGlzaW9uXG59XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuXG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9oaXRQb2ludFdvcmxkO1xuICAgIHZhciB3b3JsZE5vcm1hbCA9IGludGVyc2VjdEhlaWdodGZpZWxkX3dvcmxkTm9ybWFsO1xuICAgIHZhciBsMCA9IGludGVyc2VjdEhlaWdodGZpZWxkX2wwO1xuICAgIHZhciBsMSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2wxO1xuICAgIHZhciBsb2NhbEZyb20gPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbEZyb207XG4gICAgdmFyIGxvY2FsVG8gPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFRvO1xuXG4gICAgLy8gZ2V0IGxvY2FsIHJheSBzdGFydCBhbmQgZW5kXG4gICAgdmVjMi50b0xvY2FsRnJhbWUobG9jYWxGcm9tLCBmcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKGxvY2FsVG8sIHRvLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgLy8gR2V0IHRoZSBzZWdtZW50IHJhbmdlXG4gICAgdmFyIGkwID0gdGhpcy5nZXRDbGFtcGVkU2VnbWVudEluZGV4KGxvY2FsRnJvbSk7XG4gICAgdmFyIGkxID0gdGhpcy5nZXRDbGFtcGVkU2VnbWVudEluZGV4KGxvY2FsVG8pO1xuICAgIGlmKGkwID4gaTEpe1xuICAgICAgICB2YXIgdG1wID0gaTA7XG4gICAgICAgIGkwID0gaTE7XG4gICAgICAgIGkxID0gdG1wO1xuICAgIH1cblxuICAgIC8vIFRoZSBzZWdtZW50c1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICB0aGlzLmdldExpbmVTZWdtZW50KGwwLCBsMSwgaSk7XG4gICAgICAgIHZhciB0ID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsb2NhbEZyb20sIGxvY2FsVG8sIGwwLCBsMSk7XG4gICAgICAgIGlmKHQgPj0gMCl7XG4gICAgICAgICAgICB2ZWMyLnN1Yih3b3JsZE5vcm1hbCwgbDEsIGwwKTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgYW5nbGUgKyBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIHQsIHdvcmxkTm9ybWFsLCAtMSk7XG4gICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTcsXCIuL1NoYXBlXCI6NDV9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuLyoqXG4gKiBMaW5lIHNoYXBlIGNsYXNzLiBUaGUgbGluZSBzaGFwZSBpcyBhbG9uZyB0aGUgeCBkaXJlY3Rpb24sIGFuZCBzdHJldGNoZXMgZnJvbSBbLWxlbmd0aC8yLCAwXSB0byBbbGVuZ3RoLzIsMF0uXG4gKiBAY2xhc3MgTGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MV0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbGluZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMaW5lKG9wdGlvbnMpe1xuICAgIGlmKHR5cGVvZihhcmd1bWVudHNbMF0pID09PSAnbnVtYmVyJyl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsZW5ndGg6IGFyZ3VtZW50c1swXVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBMaW5lIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogbmV3IExpbmUoeyBsZW5ndGg6IDEsIC4uLiB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aCBvZiB0aGlzIGxpbmVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgMTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLkxJTkU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cbkxpbmUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmU7XG5cbkxpbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gbWFzcyAqIE1hdGgucG93KHRoaXMubGVuZ3RoLDIpIC8gMTI7XG59O1xuXG5MaW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMubGVuZ3RoLzI7XG59O1xuXG52YXIgcG9pbnRzID0gW3ZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKV07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkxpbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBsMiA9IHRoaXMubGVuZ3RoIC8gMjtcbiAgICB2ZWMyLnNldChwb2ludHNbMF0sIC1sMiwgIDApO1xuICAgIHZlYzIuc2V0KHBvaW50c1sxXSwgIGwyLCAgMCk7XG4gICAgb3V0LnNldEZyb21Qb2ludHMocG9pbnRzLHBvc2l0aW9uLGFuZ2xlLDApO1xufTtcblxudmFyIHJheWNhc3RfaGl0UG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJheWNhc3Rfbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcbnZhciByYXljYXN0X2wwID0gdmVjMi5jcmVhdGUoKTtcbnZhciByYXljYXN0X2wxID0gdmVjMi5jcmVhdGUoKTtcbnZhciByYXljYXN0X3VuaXRfeSA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG4vKipcbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKi9cbkxpbmUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbihyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xuICAgIHZhciB0byA9IHJheS50bztcblxuICAgIHZhciBsMCA9IHJheWNhc3RfbDA7XG4gICAgdmFyIGwxID0gcmF5Y2FzdF9sMTtcblxuICAgIC8vIGdldCBzdGFydCBhbmQgZW5kIG9mIHRoZSBsaW5lXG4gICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XG4gICAgdmVjMi5zZXQobDAsIC1oYWxmTGVuLCAwKTtcbiAgICB2ZWMyLnNldChsMSwgaGFsZkxlbiwgMCk7XG4gICAgdmVjMi50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcbiAgICB2ZWMyLnRvR2xvYmFsRnJhbWUobDEsIGwxLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgdmFyIGZyYWN0aW9uID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsMCwgbDEsIGZyb20sIHRvKTtcbiAgICBpZihmcmFjdGlvbiA+PSAwKXtcbiAgICAgICAgdmFyIG5vcm1hbCA9IHJheWNhc3Rfbm9ybWFsO1xuICAgICAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIHJheWNhc3RfdW5pdF95LCBhbmdsZSk7IC8vIHRvZG86IHRoaXMgc2hvdWxkIGRlcGVuZCBvbiB3aGljaCBzaWRlIHRoZSByYXkgY29tZXMgZnJvbVxuICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZnJhY3Rpb24sIG5vcm1hbCwgLTEpO1xuICAgIH1cbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TaGFwZVwiOjQ1fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG4vKipcbiAqIFBhcnRpY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy50eXBlID0gU2hhcGUuUEFSVElDTEU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIDA7IC8vIENhbid0IHJvdGF0ZSBhIHBhcnRpY2xlXG59O1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TaGFwZVwiOjQ1fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gIF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gIF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcblxuLyoqXG4gKiBQbGFuZSBzaGFwZSBjbGFzcy4gVGhlIHBsYW5lIGlzIGZhY2luZyBpbiB0aGUgWSBkaXJlY3Rpb24uXG4gKiBAY2xhc3MgUGxhbmVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKi9cbmZ1bmN0aW9uIFBsYW5lKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLlBMQU5FO1xuICAgIFNoYXBlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBhID0gYW5nbGUgJSAoMiAqIE1hdGguUEkpO1xuICAgIHZhciBzZXQgPSB2ZWMyLnNldDtcbiAgICB2YXIgbWF4ID0gMWU3O1xuICAgIHZhciBsb3dlckJvdW5kID0gb3V0Lmxvd2VyQm91bmQ7XG4gICAgdmFyIHVwcGVyQm91bmQgPSBvdXQudXBwZXJCb3VuZDtcblxuICAgIC8vIFNldCBtYXggYm91bmRzXG4gICAgc2V0KGxvd2VyQm91bmQsIC1tYXgsIC1tYXgpO1xuICAgIHNldCh1cHBlckJvdW5kLCAgbWF4LCAgbWF4KTtcblxuICAgIGlmKGEgPT09IDApe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgdXBwZXJCb3VuZFsxXSA9IDA7XG4gICAgICAgIC8vIHNldChsb3dlckJvdW5kLCAtbWF4LCAtbWF4KTtcbiAgICAgICAgLy8gc2V0KHVwcGVyQm91bmQsICBtYXgsICAwKTtcblxuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJIC8gMil7XG5cbiAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgbG93ZXJCb3VuZFswXSA9IDA7XG4gICAgICAgIC8vIHNldChsb3dlckJvdW5kLCAwLCAtbWF4KTtcbiAgICAgICAgLy8gc2V0KHVwcGVyQm91bmQsICAgICAgbWF4LCAgbWF4KTtcblxuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJKXtcblxuICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBsb3dlckJvdW5kWzFdID0gMDtcbiAgICAgICAgLy8gc2V0KGxvd2VyQm91bmQsIC1tYXgsIDApO1xuICAgICAgICAvLyBzZXQodXBwZXJCb3VuZCwgIG1heCwgbWF4KTtcblxuICAgIH0gZWxzZSBpZihhID09PSAzKk1hdGguUEkvMil7XG5cbiAgICAgICAgLy8geCBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHVwcGVyQm91bmRbMF0gPSAwO1xuICAgICAgICAvLyBzZXQobG93ZXJCb3VuZCwgLW1heCwgICAgIC1tYXgpO1xuICAgICAgICAvLyBzZXQodXBwZXJCb3VuZCwgIDAsICBtYXgpO1xuXG4gICAgfVxufTtcblxuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG52YXIgaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfZGlyX3NjYWxlZF93aXRoX3QgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2hpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2xlbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5QbGFuZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcbiAgICB2YXIgZGlyX3NjYWxlZF93aXRoX3QgPSBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdDtcbiAgICB2YXIgaGl0UG9pbnQgPSBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfbm9ybWFsO1xuICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XG5cbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5zZXQobm9ybWFsLCAwLCAxKTtcbiAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xuXG4gICAgdmVjMi5zdWIobGVuLCBmcm9tLCBwb3NpdGlvbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gdmVjMi5kb3QobGVuLCBub3JtYWwpO1xuICAgIHZlYzIuc3ViKGxlbiwgdG8sIHBvc2l0aW9uKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gdmVjMi5kb3QobGVuLCBub3JtYWwpO1xuXG4gICAgaWYocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKXtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGZyb20sIHRvKSA8IHBsYW5lVG9Gcm9tICogcGxhbmVUb0Zyb20pe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5fZG90X2RpciA9IHZlYzIuZG90KG5vcm1hbCwgZGlyZWN0aW9uKTtcblxuICAgIHZlYzIuc3ViKHBsYW5lUG9pbnRUb0Zyb20sIGZyb20sIHBvc2l0aW9uKTtcbiAgICB2YXIgdCA9IC12ZWMyLmRvdChub3JtYWwsIHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyIC8gcmF5Lmxlbmd0aDtcblxuICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCBub3JtYWwsIC0xKTtcbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1NyxcIi4vU2hhcGVcIjo0NX1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igc2hhcGVzLlxuICogQGNsYXNzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPTFdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbnNvcj1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50eXBlPTBdXG4gKi9cbmZ1bmN0aW9uIFNoYXBlKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgdGhpcyBzaGFwZSBpcyBhdHRhY2hlZCB0by4gQSBzaGFwZSBjYW4gb25seSBiZSBhdHRhY2hlZCB0byBhIHNpbmdsZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5LWxvY2FsIHBvc2l0aW9uIG9mIHRoZSBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvZHktbG9jYWwgYW5nbGUgb2YgdGhlIHNoYXBlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUuIE9uZSBvZjpcbiAgICAgKlxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ0lSQ0xFOnByb3BlcnR5XCJ9fVNoYXBlLkNJUkNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QQVJUSUNMRTpwcm9wZXJ0eVwifX1TaGFwZS5QQVJUSUNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QTEFORTpwcm9wZXJ0eVwifX1TaGFwZS5QTEFORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DT05WRVg6cHJvcGVydHlcIn19U2hhcGUuQ09OVkVYe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0xJTkU6cHJvcGVydHlcIn19U2hhcGUuTElORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9CT1g6cHJvcGVydHlcIn19U2hhcGUuQk9Ye3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NBUFNVTEU6cHJvcGVydHlcIn19U2hhcGUuQ0FQU1VMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9IRUlHSFRGSUVMRDpwcm9wZXJ0eVwifX1TaGFwZS5IRUlHSFRGSUVMRHt7L2Nyb3NzTGlua319XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogU2hhcGUgb2JqZWN0IGlkZW50aWZpZXIuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIGdyb3VwIHRoYXQgdGhpcyBzaGFwZSBiZWxvbmdzIHRvIChiaXQgbWFzaykuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hdXJlbGllbnJpYm9uLmNvbS9ibG9nLzIwMTEvMDcvYm94MmQtdHV0b3JpYWwtY29sbGlzaW9uLWZpbHRlcmluZy9cIj50aGlzIHR1dG9yaWFsPC9hPi5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uR3JvdXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFNldHVwIGJpdHMgZm9yIGVhY2ggYXZhaWxhYmxlIGdyb3VwXG4gICAgICogICAgIHZhciBQTEFZRVIgPSBNYXRoLnBvdygyLDApLFxuICAgICAqICAgICAgICAgRU5FTVkgPSAgTWF0aC5wb3coMiwxKSxcbiAgICAgKiAgICAgICAgIEdST1VORCA9IE1hdGgucG93KDIsMilcbiAgICAgKlxuICAgICAqICAgICAvLyBQdXQgc2hhcGVzIGludG8gdGhlaXIgZ3JvdXBzXG4gICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uR3JvdXAgPSBFTkVNWTtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbkdyb3VwID0gR1JPVU5EO1xuICAgICAqXG4gICAgICogICAgIC8vIEFzc2lnbiBncm91cHMgdGhhdCBlYWNoIHNoYXBlIGNvbGxpZGUgd2l0aC5cbiAgICAgKiAgICAgLy8gTm90ZSB0aGF0IHRoZSBwbGF5ZXJzIGNhbiBjb2xsaWRlIHdpdGggZ3JvdW5kIGFuZCBlbmVtaWVzLCBidXQgbm90IHdpdGggb3RoZXIgcGxheWVycy5cbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBHUk9VTkQ7XG4gICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgRU5FTVk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBIb3cgY29sbGlzaW9uIGNoZWNrIGlzIGRvbmVcbiAgICAgKiAgICAgaWYoc2hhcGVBLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVCLmNvbGxpc2lvbk1hc2spIT0wICYmIChzaGFwZUIuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUEuY29sbGlzaW9uTWFzaykhPTApe1xuICAgICAqICAgICAgICAgLy8gVGhlIHNoYXBlcyB3aWxsIGNvbGxpZGVcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkdyb3VwIDogMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4gVGhhdCBtZWFucyB0aGF0IHRoaXMgc2hhcGUgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9keSBzaGFwZXMsIGJ1dCBpdCB3aWxsIHN0aWxsIHRyaWdnZXIgY29udGFjdCBldmVudHMsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IG9wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2UgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIG1hc2sgb2YgdGhpcyBzaGFwZS4gU2VlIC5jb2xsaXNpb25Hcm91cC5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uTWFza1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAxO1xuXG4gICAgLyoqXG4gICAgICogTWF0ZXJpYWwgdG8gdXNlIGluIGNvbGxpc2lvbnMgZm9yIHRoaXMgU2hhcGUuIElmIHRoaXMgaXMgc2V0IHRvIG51bGwsIHRoZSB3b3JsZCB3aWxsIHVzZSBkZWZhdWx0IG1hdGVyaWFsIHByb3BlcnRpZXMgaW5zdGVhZC5cbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFyZWEgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkgYXJlYVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hcmVhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoaXMgc2hhcGUgdG8gYmUgYSBzZW5zb3IuIEEgc2Vuc29yIGRvZXMgbm90IGdlbmVyYXRlIGNvbnRhY3RzLCBidXQgaXQgc3RpbGwgcmVwb3J0cyBjb250YWN0IGV2ZW50cy4gVGhpcyBpcyBnb29kIGlmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBzaGFwZSBpcyBvdmVybGFwcGluZyBhbm90aGVyIHNoYXBlLCB3aXRob3V0IHRoZW0gZ2VuZXJhdGluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlbnNvclxuICAgICAqL1xuICAgIHRoaXMuc2Vuc29yID0gb3B0aW9ucy5zZW5zb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2Vuc29yIDogZmFsc2U7XG5cbiAgICBpZih0aGlzLnR5cGUpe1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBcmVhKCk7XG59XG5cblNoYXBlLmlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENJUkNMRVxuICovXG5TaGFwZS5DSVJDTEUgPSAgICAgIDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFBBUlRJQ0xFXG4gKi9cblNoYXBlLlBBUlRJQ0xFID0gICAgMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUExBTkVcbiAqL1xuU2hhcGUuUExBTkUgPSAgICAgICA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDT05WRVhcbiAqL1xuU2hhcGUuQ09OVkVYID0gICAgICA4O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMSU5FXG4gKi9cblNoYXBlLkxJTkUgPSAgICAgICAgMTY7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPWFxuICovXG5TaGFwZS5CT1ggPSAgIDMyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhcGUsICdSRUNUQU5HTEUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTaGFwZS5SRUNUQU5HTEUgaXMgZGVwcmVjYXRlZCwgdXNlIFNoYXBlLkJPWCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gU2hhcGUuQk9YO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDQVBTVUxFXG4gKi9cblNoYXBlLkNBUFNVTEUgPSAgICAgNjQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEhFSUdIVEZJRUxEXG4gKi9cblNoYXBlLkhFSUdIVEZJRUxEID0gMTI4O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gdGhlIG1vbWVudCBvZiBpbmVydGlhIGFyb3VuZCB0aGUgWiBheGlzIG9mIHRoZSBib2R5IGdpdmVuIHRoZSB0b3RhbCBtYXNzLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcIj5XaWtpcGVkaWEncyBsaXN0IG9mIG1vbWVudHMgb2YgaW5lcnRpYTwvYT4uXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfSBJZiB0aGUgaW5lcnRpYSBpcyBpbmZpbml0eSBvciBpZiB0aGUgb2JqZWN0IHNpbXBseSBpc24ndCBwb3NzaWJsZSB0byByb3RhdGUsIHJldHVybiAwLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe307XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2lyY2xlIHJhZGl1cyBvZiB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe307XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYSBwcm9wZXJ0eSBvZiB0aGUgc2hhcGUuXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGluIGFsbCBzdWJjbGFzc2VzXG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHdvcmxkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggKEFBQkIpIG9mIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBvdXQgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9IHBvc2l0aW9uIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGUgV29ybGQgYW5nbGUgb2YgdGhlIHNoYXBlLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHJheWNhc3Rpbmcgb24gdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5UmVzdWx0fSByZXN1bHQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBkYXRhLlxuICogQHBhcmFtICB7UmF5fSByYXkgVGhlIFJheSB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgcmF5Y2FzdGluZy5cbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvbiBXb3JsZCBwb3NpdGlvbiBvZiB0aGUgc2hhcGUgKHRoZSAucG9zaXRpb24gcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkKS5cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgV29ybGQgYW5nbGUgb2YgdGhlIHNoYXBlICh0aGUgLmFuZ2xlIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZCkuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24ocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzB9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdTU29sdmVyO1xuXG4vKipcbiAqIEl0ZXJhdGl2ZSBHYXVzcy1TZWlkZWwgY29uc3RyYWludCBlcXVhdGlvbiBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIEdTU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNvbHZlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLml0ZXJhdGlvbnM9MTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9sZXJhbmNlPTBdXG4gKi9cbmZ1bmN0aW9uIEdTU29sdmVyKG9wdGlvbnMpe1xuICAgIFNvbHZlci5jYWxsKHRoaXMsb3B0aW9ucyxTb2x2ZXIuR1MpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBkbyB3aGVuIHNvbHZpbmcuIE1vcmUgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMsIGJ1dCBpcyBtb3JlIGV4cGVuc2l2ZS5cbiAgICAgKiBAcHJvcGVydHkgaXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zIHx8IDEwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVycm9yIHRvbGVyYW5jZSwgcGVyIGNvbnN0cmFpbnQuIElmIHRoZSB0b3RhbCBlcnJvciBpcyBiZWxvdyB0aGlzIGxpbWl0LCB0aGUgc29sdmVyIHdpbGwgc3RvcCBpdGVyYXRpbmcuIFNldCB0byB6ZXJvIGZvciBhcyBnb29kIHNvbHV0aW9uIGFzIHBvc3NpYmxlLCBidXQgdG8gc29tZXRoaW5nIGxhcmdlciB0aGFuIHplcm8gdG8gbWFrZSBjb21wdXRhdGlvbnMgZmFzdGVyLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFlLTdcbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZSA9IG9wdGlvbnMudG9sZXJhbmNlIHx8IDFlLTc7XG5cbiAgICB0aGlzLmFycmF5U3RlcCA9IDMwO1xuICAgIHRoaXMubGFtYmRhID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuQnMgPSAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuaW52Q3MgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2V0IGFsbCByaWdodCBoYW5kIHNpZGUgdGVybXMgdG8gemVybyB3aGVuIHNvbHZpbmcuIENhbiBiZSBoYW5keSBmb3IgYSBmZXcgYXBwbGljYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB1c2VaZXJvUkhTXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHRvZG8gUmVtb3ZlLCBub3QgdXNlZFxuICAgICAqL1xuICAgIHRoaXMudXNlWmVyb1JIUyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIHRoYXQgYXJlIHVzZWQgdG8gYXBwcm94aW1hdGUgbm9ybWFsIGZvcmNlcyB1c2VkIGZvciBmcmljdGlvbiAoRl9mcmljdGlvbiA9IG11ICogRl9ub3JtYWwpLiBUaGVzZSBmcmljdGlvbiBmb3JjZXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgZnJpY3Rpb24gZm9yY2VzIHRoYXQgYXJlIHNldC4gSWYgeW91IHNldCBmcmljdGlvbkl0ZXJhdGlvbnMgPSAwLCB0aGVuIHRoaXMgZmVhdHVyZSB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVXNlIG9ubHkgZnJpY3Rpb25JdGVyYXRpb25zID4gMCBpZiB0aGUgYXBwcm94aW1hdGVkIG5vcm1hbCBmb3JjZSAoRl9ub3JtYWwgPSBtYXNzICogZ3Jhdml0eSkgaXMgbm90IGdvb2QgZW5vdWdoLiBFeGFtcGxlcyBvZiB3aGVyZSBpdCBjYW4gaGFwcGVuIGlzIGluIHNwYWNlIGdhbWVzIHdoZXJlIGdyYXZpdHkgaXMgemVybywgb3IgaW4gdGFsbCBzdGFja3Mgd2hlcmUgdGhlIG5vcm1hbCBmb3JjZSBpcyBsYXJnZSBhdCBib3R0b20gYnV0IHNtYWxsIGF0IHRvcC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyA9IG9wdGlvbnMuZnJpY3Rpb25JdGVyYXRpb25zICE9PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5mcmljdGlvbkl0ZXJhdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCB3ZXJlIG1hZGUgZHVyaW5nIHRoZSBsYXN0IHNvbHZlLiBJZiAudG9sZXJhbmNlIGlzIHplcm8sIHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgZXF1YWwgdG8gLml0ZXJhdGlvbnMsIGJ1dCBpZiAudG9sZXJhbmNlIGlzIGxhcmdlciB0aGFuIHplcm8sIGFuZCB0aGUgc29sdmVyIGNhbiBxdWl0IGVhcmx5LCB0aGVuIHRoaXMgbnVtYmVyIHdpbGwgYmUgc29tZXdoZXJlIGJldHdlZW4gMSBhbmQgLml0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVzZWRJdGVyYXRpb25zXG4gICAgICovXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG59XG5HU1NvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5HU1NvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHU1NvbHZlcjtcblxuZnVuY3Rpb24gc2V0QXJyYXlaZXJvKGFycmF5KXtcbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBhcnJheVtsXSA9ICswLjA7XG4gICAgfVxufVxuXG4vKipcbiAqIFNvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgIFRpbWUgc3RlcFxuICogQHBhcmFtICB7V29ybGR9ICAgd29ybGQgICAgV29ybGQgdG8gc29sdmVcbiAqL1xuR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oaCwgd29ybGQpe1xuXG4gICAgdGhpcy5zb3J0RXF1YXRpb25zKCk7XG5cbiAgICB2YXIgaXRlciA9IDAsXG4gICAgICAgIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsXG4gICAgICAgIG1heEZyaWN0aW9uSXRlciA9IHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgdG9sU3F1YXJlZCA9IE1hdGgucG93KHRoaXMudG9sZXJhbmNlKk5lcSwgMiksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgTmJvZGllcyA9IHdvcmxkLmJvZGllcy5sZW5ndGgsXG4gICAgICAgIGFkZCA9IHZlYzIuYWRkLFxuICAgICAgICBzZXQgPSB2ZWMyLnNldCxcbiAgICAgICAgdXNlWmVyb1JIUyA9IHRoaXMudXNlWmVyb1JIUyxcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGE7XG5cbiAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcblxuICAgIGlmKE5lcSl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgICAgICAgICAgYi51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIGlmKGxhbWJkYS5sZW5ndGggPCBOZXEpe1xuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYSA9ICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuQnMgPSAgICAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICAgICAgdGhpcy5pbnZDcyA9ICAgICAgICAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgIH1cbiAgICBzZXRBcnJheVplcm8obGFtYmRhKTtcbiAgICB2YXIgaW52Q3MgPSB0aGlzLmludkNzLFxuICAgICAgICBCcyA9IHRoaXMuQnMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1lcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoYy50aW1lU3RlcCAhPT0gaCB8fCBjLm5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGMudGltZVN0ZXAgPSBoO1xuICAgICAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBCc1tpXSA9ICAgICBjLmNvbXB1dGVCKGMuYSxjLmIsaCk7XG4gICAgICAgIGludkNzW2ldID0gIGMuY29tcHV0ZUludkMoYy5lcHNpbG9uKTtcbiAgICB9XG5cbiAgICB2YXIgcSwgQiwgYywgZGVsdGFsYW1iZGFUb3QsaSxqO1xuXG4gICAgaWYoTmVxICE9PSAwKXtcblxuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB2bGFtYmRhXG4gICAgICAgICAgICBiLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYXhGcmljdGlvbkl0ZXIpe1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGNvbnRhY3QgZXF1YXRpb25zIHRvIGdldCBub3JtYWwgZm9yY2VzXG4gICAgICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4RnJpY3Rpb25JdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDw9IHRvbFNxdWFyZWQpe1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEdTU29sdmVyLnVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgbGFtYmRhLCAxL2gpO1xuXG4gICAgICAgICAgICAvLyBTZXQgY29tcHV0ZWQgZnJpY3Rpb24gZm9yY2VcbiAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgICAgIGlmKGVxIGluc3RhbmNlb2YgRnJpY3Rpb25FcXVhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgayE9PWVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBlcS5jb250YWN0RXF1YXRpb25zW2tdLm11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZiAqPSBlcS5mcmljdGlvbkNvZWZmaWNpZW50IC8gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlID0gIGY7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1pbkZvcmNlID0gLWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlcXVhdGlvbnNcbiAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEl0ZXI7IGl0ZXIrKyl7XG5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IE1hdGguYWJzKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG4gICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uYWRkQ29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcbiAgICB9XG59O1xuXG4vLyBTZXRzIHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG5HU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyA9IGZ1bmN0aW9uKGVxdWF0aW9ucywgbGFtYmRhLCBpbnZEdCl7XG4gICAgLy8gU2V0IHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG4gICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7XG4gICAgfVxufTtcblxuR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uID0gZnVuY3Rpb24oaixlcSxlcHMsQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsZHQsaXRlcil7XG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgQiA9IEJzW2pdLFxuICAgICAgICBpbnZDID0gaW52Q3Nbal0sXG4gICAgICAgIGxhbWJkYWogPSBsYW1iZGFbal0sXG4gICAgICAgIEdXbGFtYmRhID0gZXEuY29tcHV0ZUdXbGFtYmRhKCk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSBlcS5tYXhGb3JjZSxcbiAgICAgICAgbWluRm9yY2UgPSBlcS5taW5Gb3JjZTtcblxuICAgIGlmKHVzZVplcm9SSFMpe1xuICAgICAgICBCID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFsYW1iZGEgPSBpbnZDICogKCBCIC0gR1dsYW1iZGEgLSBlcHMgKiBsYW1iZGFqICk7XG5cbiAgICAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbFxuICAgIHZhciBsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPSBsYW1iZGFqICsgZGVsdGFsYW1iZGE7XG4gICAgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhIDwgbWluRm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1pbkZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9IGVsc2UgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID4gbWF4Rm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1heEZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9XG4gICAgbGFtYmRhW2pdICs9IGRlbHRhbGFtYmRhO1xuICAgIGVxLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XG5cbiAgICByZXR1cm4gZGVsdGFsYW1iZGE7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTcsXCIuL1NvbHZlclwiOjQ3fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJy4uL2V2ZW50cy9FdmVudEVtaXR0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBzb2x2ZXJzLlxuICogQGNsYXNzIFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuZnVuY3Rpb24gU29sdmVyKG9wdGlvbnMsdHlwZSl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGUgc29sdmVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNvcnQgYWxsIGVxdWF0aW9ucyBiZWZvcmUgZWFjaCBzb2x2ZS5cbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25Tb3J0RnVuY3Rpb25cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb258Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uID0gb3B0aW9ucy5lcXVhdGlvblNvcnRGdW5jdGlvbiB8fCBmYWxzZTtcbn1cblNvbHZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Tb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29sdmVyO1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGR0LHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb2x2ZXIuc29sdmUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMhXCIpO1xufTtcblxudmFyIG1vY2tXb3JsZCA9IHtib2RpZXM6W119O1xuXG4vKipcbiAqIFNvbHZlcyBhbGwgY29uc3RyYWludHMgaW4gYW4gaXNsYW5kLlxuICogQG1ldGhvZCBzb2x2ZUlzbGFuZFxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7SXNsYW5kfSBpc2xhbmRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uKGR0LGlzbGFuZCl7XG5cbiAgICB0aGlzLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICB0aGlzLmFkZEVxdWF0aW9ucyhpc2xhbmQuZXF1YXRpb25zKTtcbiAgICAgICAgbW9ja1dvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICBpc2xhbmQuZ2V0Qm9kaWVzKG1vY2tXb3JsZC5ib2RpZXMpO1xuXG4gICAgICAgIC8vIFNvbHZlXG4gICAgICAgIGlmKG1vY2tXb3JsZC5ib2RpZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc29sdmUoZHQsbW9ja1dvcmxkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU29ydCBhbGwgZXF1YXRpb25zIHVzaW5nIHRoZSAuZXF1YXRpb25Tb3J0RnVuY3Rpb24uIFNob3VsZCBiZSBjYWxsZWQgYnkgc3ViY2xhc3NlcyBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2Qgc29ydEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvcnRFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zb3J0KHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uIHRvIGJlIHNvbHZlZC5cbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmKGVxLmVuYWJsZWQpe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBlcXVhdGlvbnMuIFNhbWUgYXMgLmFkZEVxdWF0aW9uLCBidXQgdGhpcyB0aW1lIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBFcXVhdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gZXFzXG4gKi9cblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb25zID0gZnVuY3Rpb24oZXFzKXtcbiAgICAvL1V0aWxzLmFwcGVuZEFycmF5KHRoaXMuZXF1YXRpb25zLGVxcyk7XG4gICAgZm9yKHZhciBpPTAsIE49ZXFzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgaWYoZXEuZW5hYmxlZCl7XG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlRXF1YXRpb25cbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjdXJyZW50bHkgYWRkZWQgZXF1YXRpb25zLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGg9MDtcbn07XG5cblNvbHZlci5HUyA9IDE7XG5Tb2x2ZXIuSVNMQU5EID0gMjtcblxufSx7XCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjYsXCIuLi91dGlscy9VdGlsc1wiOjU3fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250YWN0RXF1YXRpb25Qb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb259XG4gKi9cbkNvbnRhY3RFcXVhdGlvblBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBDb250YWN0RXF1YXRpb24oKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25cbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvblBvb2x9XG4gKi9cbkNvbnRhY3RFcXVhdGlvblBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcblx0ZXF1YXRpb24uYm9keUEgPSBlcXVhdGlvbi5ib2R5QiA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MjEsXCIuL1Bvb2xcIjo1NX1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb25Qb29sKCkge1xuXHRQb29sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5GcmljdGlvbkVxdWF0aW9uUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XG4gKi9cbkZyaWN0aW9uRXF1YXRpb25Qb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgRnJpY3Rpb25FcXVhdGlvbigpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSB7RnJpY3Rpb25FcXVhdGlvbn0gZXF1YXRpb25cbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb25Qb29sfVxuICovXG5GcmljdGlvbkVxdWF0aW9uUG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcXVhdGlvbikge1xuXHRlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjMsXCIuL1Bvb2xcIjo1NX1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBJc2xhbmROb2RlID0gX2RlcmVxXygnLi4vd29ybGQvSXNsYW5kTm9kZScpO1xudmFyIFBvb2wgPSBfZGVyZXFfKCcuL1Bvb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmROb2RlUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTm9kZVBvb2woKSB7XG5cdFBvb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbklzbGFuZE5vZGVQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5Jc2xhbmROb2RlUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJc2xhbmROb2RlUG9vbDtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7SXNsYW5kTm9kZX1cbiAqL1xuSXNsYW5kTm9kZVBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBJc2xhbmROb2RlKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGVzdHJveVxuICogQHBhcmFtIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtJc2xhbmROb2RlUG9vbH1cbiAqL1xuSXNsYW5kTm9kZVBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRub2RlLnJlc2V0KCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuLi93b3JsZC9Jc2xhbmROb2RlXCI6NjAsXCIuL1Bvb2xcIjo1NX1dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBJc2xhbmQgPSBfZGVyZXFfKCcuLi93b3JsZC9Jc2xhbmQnKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gSXNsYW5kUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuSXNsYW5kUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuSXNsYW5kUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJc2xhbmRQb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtJc2xhbmR9XG4gKi9cbklzbGFuZFBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBJc2xhbmQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge0lzbGFuZH0gaXNsYW5kXG4gKiBAcmV0dXJuIHtJc2xhbmRQb29sfVxuICovXG5Jc2xhbmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGlzbGFuZCkge1xuXHRpc2xhbmQucmVzZXQoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG59LHtcIi4uL3dvcmxkL0lzbGFuZFwiOjU4LFwiLi9Qb29sXCI6NTV9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVHVwbGVEaWN0aW9uYXJ5ID0gX2RlcmVxXygnLi9UdXBsZURpY3Rpb25hcnknKTtcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gX2RlcmVxXygnLi9PdmVybGFwS2VlcGVyUmVjb3JkJyk7XG52YXIgT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wgPSBfZGVyZXFfKCcuL092ZXJsYXBLZWVwZXJSZWNvcmRQb29sJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcEtlZXBlcjtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBvdmVybGFwcyBpbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIGxhc3Qgc3RlcCBzdGF0ZS5cbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcEtlZXBlcigpIHtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG4gICAgdGhpcy5yZWNvcmRQb29sID0gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sKHsgc2l6ZTogMTYgfSk7XG4gICAgdGhpcy50bXBEaWN0ID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMudG1wQXJyYXkxID0gW107XG59XG5cbi8qKlxuICogVGlja3Mgb25lIHN0ZXAgZm9yd2FyZCBpbiB0aW1lLiBUaGlzIHdpbGwgbW92ZSB0aGUgY3VycmVudCBvdmVybGFwIHN0YXRlIHRvIHRoZSBcIm9sZFwiIG92ZXJsYXAgc3RhdGUsIGFuZCBjcmVhdGUgYSBuZXcgb25lIGFzIGN1cnJlbnQuXG4gKiBAbWV0aG9kIHRpY2tcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG5cbiAgICAvLyBTYXZlIG9sZCBvYmplY3RzIGludG8gcG9vbFxuICAgIHZhciBsID0gbGFzdC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gbGFzdC5rZXlzW2xdO1xuICAgICAgICB2YXIgbGFzdE9iamVjdCA9IGxhc3QuZ2V0QnlLZXkoa2V5KTtcbiAgICAgICAgdmFyIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIGlmKGxhc3RPYmplY3Qpe1xuICAgICAgICAgICAgLy8gVGhlIHJlY29yZCBpcyBvbmx5IHVzZWQgaW4gdGhlIFwibGFzdFwiIGRpY3QsIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFdlIG1pZ2h0IGFzIHdlbGwgcG9vbCBpdC5cbiAgICAgICAgICAgIHRoaXMucmVjb3JkUG9vbC5yZWxlYXNlKGxhc3RPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgbGFzdCBvYmplY3RcbiAgICBsYXN0LnJlc2V0KCk7XG5cbiAgICAvLyBUcmFuc2ZlciBmcm9tIG5ldyBvYmplY3QgdG8gb2xkXG4gICAgbGFzdC5jb3B5KGN1cnJlbnQpO1xuXG4gICAgLy8gQ2xlYXIgY3VycmVudCBvYmplY3RcbiAgICBjdXJyZW50LnJlc2V0KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0T3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gc2hhcGVBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQlxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXRPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU3RvcmUgY3VycmVudCBjb250YWN0IHN0YXRlXG4gICAgaWYoIWN1cnJlbnQuZ2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkKSl7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWNvcmRQb29sLmdldCgpO1xuICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgY3VycmVudC5zZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQsIGRhdGEpO1xuICAgIH1cbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldE5ld092ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGJvZGllcyBhcmUgY3VycmVudGx5IG92ZXJsYXBwaW5nLlxuICogQG1ldGhvZCBib2RpZXNBcmVPdmVybGFwcGluZ1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5ib2RpZXNBcmVPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuICAgICAgICBpZigoZGF0YS5ib2R5QSA9PT0gYm9keUEgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUIpIHx8IGRhdGEuYm9keUEgPT09IGJvZHlCICYmIGRhdGEuYm9keUIgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbihkaWN0QSwgZGljdEIsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgbGFzdCA9IGRpY3RBO1xuICAgIHZhciBjdXJyZW50ID0gZGljdEI7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuXG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5ICcra2V5KycgaGFkIG5vIGRhdGEhJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERhdGEgPSBsYXN0LmRhdGFba2V5XTtcbiAgICAgICAgaWYoIWxhc3REYXRhKXtcbiAgICAgICAgICAgIC8vIE5vdCBvdmVybGFwcGluZyBpbiBsYXN0IHN0YXRlLCBidXQgaW4gY3VycmVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmlzTmV3T3ZlcmxhcCA9IGZ1bmN0aW9uKHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgaWRBID0gc2hhcGVBLmlkfDAsXG4gICAgICAgIGlkQiA9IHNoYXBlQi5pZHwwO1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG4gICAgLy8gTm90IGluIGxhc3QgYnV0IGluIG5ld1xuICAgIHJldHVybiAhISFsYXN0LmdldChpZEEsIGlkQikgJiYgISFjdXJyZW50LmdldChpZEEsIGlkQik7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXROZXdPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXRFbmRPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRCb2R5RGlmZiA9IGZ1bmN0aW9uKG92ZXJsYXBzLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgYWNjdW11bGF0b3IgPSB0aGlzLnRtcERpY3Q7XG5cbiAgICB2YXIgbCA9IG92ZXJsYXBzLmxlbmd0aDtcblxuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gb3ZlcmxhcHNbbF07XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgdXNlIGJvZHkgaWQncyBmb3IgdGhlIGFjY3VtdWxhdG9yLCB0aGVzZSB3aWxsIGJlIGEgc3Vic2V0IG9mIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgICAgYWNjdW11bGF0b3Iuc2V0KGRhdGEuYm9keUEuaWR8MCwgZGF0YS5ib2R5Qi5pZHwwLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsID0gYWNjdW11bGF0b3Iua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhY2N1bXVsYXRvci5nZXRCeUtleShhY2N1bXVsYXRvci5rZXlzW2xdKTtcbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhLmJvZHlBLCBkYXRhLmJvZHlCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjY3VtdWxhdG9yLnJlc2V0KCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuL092ZXJsYXBLZWVwZXJSZWNvcmRcIjo1MyxcIi4vT3ZlcmxhcEtlZXBlclJlY29yZFBvb2xcIjo1NCxcIi4vVHVwbGVEaWN0aW9uYXJ5XCI6NTYsXCIuL1V0aWxzXCI6NTd9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXJSZWNvcmQ7XG5cbi8qKlxuICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVBXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVCXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQuY2FsbCh0aGlzLCBib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbn07XG5cbn0se31dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gX2RlcmVxXygnLi9PdmVybGFwS2VlcGVyUmVjb3JkJyk7XG52YXIgUG9vbCA9IF9kZXJlcV8oJy4vUG9vbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wucHJvdG90eXBlID0gbmV3IFBvb2woKTtcbk92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtPdmVybGFwS2VlcGVyUmVjb3JkfVxuICovXG5PdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge092ZXJsYXBLZWVwZXJSZWNvcmR9IHJlY29yZFxuICogQHJldHVybiB7T3ZlcmxhcEtlZXBlclJlY29yZFBvb2x9XG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuXHRyZWNvcmQuYm9keUEgPSByZWNvcmQuYm9keUIgPSByZWNvcmQuc2hhcGVBID0gcmVjb3JkLnNoYXBlQiA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuL092ZXJsYXBLZWVwZXJSZWNvcmRcIjo1MyxcIi4vUG9vbFwiOjU1fV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBQb29sO1xuXG4vKipcbiAqIEBjbGFzcyBPYmplY3QgcG9vbGluZyB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBQb29sKG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblx0dGhpcy5vYmplY3RzID0gW107XG5cblx0aWYob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpe1xuXHRcdHRoaXMucmVzaXplKG9wdGlvbnMuc2l6ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEByZXR1cm4ge1Bvb2x9IFNlbGYsIGZvciBjaGFpbmluZ1xuICovXG5Qb29sLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHR2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcblxuXHR3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XG5cdFx0b2JqZWN0cy5wb3AoKTtcblx0fVxuXG5cdHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcblx0XHRvYmplY3RzLnB1c2godGhpcy5jcmVhdGUoKSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCBmcm9tIHRoZSBwb29sIG9yIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAqIEBtZXRob2QgZ2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblBvb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XG5cdHJldHVybiBvYmplY3RzLmxlbmd0aCA/IG9iamVjdHMucG9wKCkgOiB0aGlzLmNyZWF0ZSgpO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBhbmQgcHV0IHRoZSBvYmplY3QgYmFjayBpbnRvIHRoZSBwb29sIGZvciBsYXRlciB1c2UuXG4gKiBAbWV0aG9kIHJlbGVhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1Bvb2x9IFNlbGYgZm9yIGNoYWluaW5nXG4gKi9cblBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHRoaXMuZGVzdHJveShvYmplY3QpO1xuXHR0aGlzLm9iamVjdHMucHVzaChvYmplY3QpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbn0se31dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4vVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XG5cbi8qKlxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBLZXlzIHRoYXQgYXJlIGN1cnJlbnRseSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGtleXNcbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBnaXZlbiB0d28gaW50ZWdlcnNcbiAqIEBtZXRob2QgZ2V0S2V5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge251bWJlcn0galxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKGlkMSwgaWQyKSB7XG4gICAgaWQxID0gaWQxfDA7XG4gICAgaWQyID0gaWQyfDA7XG5cbiAgICBpZiAoIChpZDF8MCkgPT09IChpZDJ8MCkgKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHZhbGlkIGZvciB2YWx1ZXMgPCAyXjE2XG4gICAgcmV0dXJuICgoaWQxfDApID4gKGlkMnwwKSA/XG4gICAgICAgIChpZDEgPDwgMTYpIHwgKGlkMiAmIDB4RkZGRikgOlxuICAgICAgICAoaWQyIDw8IDE2KSB8IChpZDEgJiAweEZGRkYpKXwwXG4gICAgICAgIDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRCeUtleVxuICogQHBhcmFtICB7TnVtYmVyfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRCeUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IGtleXwwO1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5nZXRLZXkoaSwgaildO1xufTtcblxuLyoqXG4gKiBTZXQgYSB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZighdmFsdWUpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoaSwgaik7XG5cbiAgICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICBpZighdGhpcy5kYXRhW2tleV0pe1xuICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAga2V5cyA9IHRoaXMua2V5cztcblxuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleXNbbF1dO1xuICAgIH1cblxuICAgIGtleXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ29weSBhbm90aGVyIFR1cGxlRGljdGlvbmFyeS4gTm90ZSB0aGF0IGFsbCBkYXRhIGluIHRoaXMgZGljdGlvbmFyeSB3aWxsIGJlIHJlbW92ZWQuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VHVwbGVEaWN0aW9uYXJ5fSBkaWN0IFRoZSBUdXBsZURpY3Rpb25hcnkgdG8gY29weSBpbnRvIHRoaXMgb25lLlxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihkaWN0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMua2V5cywgZGljdC5rZXlzKTtcbiAgICB2YXIgbCA9IGRpY3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGRpY3Qua2V5c1tsXTtcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkaWN0LmRhdGFba2V5XTtcbiAgICB9XG59O1xuXG59LHtcIi4vVXRpbHNcIjo1N31dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogTWlzYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQGNsYXNzIFV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbi8qKlxuICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cbiAqIEBtZXRob2QgYXBwZW5kQXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICovXG5VdGlscy5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uKGEsYil7XG4gICAgaWYgKGIubGVuZ3RoIDwgMTUwMDAwKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYi5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXG4gKiBAbWV0aG9kIHNwbGljZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcbiAqL1xuVXRpbHMuc3BsaWNlID0gZnVuY3Rpb24oYXJyYXksaW5kZXgsaG93bWFueSl7XG4gICAgaG93bWFueSA9IGhvd21hbnkgfHwgMTtcbiAgICBmb3IgKHZhciBpPWluZGV4LCBsZW49YXJyYXkubGVuZ3RoLWhvd21hbnk7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSBsZW47XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSB0eXBlIHRvIHVzZSBmb3IgaW50ZXJuYWwgbnVtZXJpYyBjb21wdXRhdGlvbnMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gRmxvYXQzMkFycmF5IGlzIHVzZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBidXQgZmFsbHMgYmFjayBvbiBBcnJheS4gSWYgeW91IHdhbnQgdG8gc2V0IGFycmF5IHR5cGUgbWFudWFsbHksIGluamVjdCBpdCB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBQMl9BUlJBWV9UWVBFLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IEFSUkFZX1RZUEVcbiAqIEBleGFtcGxlXG4gKiAgICAgPHNjcmlwdD5cbiAqICAgICAgICAgPCEtLSBJbmplY3QgeW91ciBwcmVmZXJyZWQgYXJyYXkgdHlwZSBiZWZvcmUgbG9hZGluZyBwMi5qcyAtLT5cbiAqICAgICAgICAgUDJfQVJSQVlfVFlQRSA9IEFycmF5O1xuICogICAgIDxzY3JpcHQgc3JjPVwicDIuanNcIj5cbiAqL1xuaWYodHlwZW9mIFAyX0FSUkFZX1RZUEUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IFAyX0FSUkFZX1RZUEU7XG59IGVsc2UgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKXtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gRmxvYXQzMkFycmF5O1xufSBlbHNlIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gQXJyYXk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFcbiAqIEBwYXJhbSAge29iamVjdH0gYlxuICovXG5VdGlscy5leHRlbmQgPSBmdW5jdGlvbihhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbn0se31dLDU4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kO1xuXG4vKipcbiAqIEFuIGlzbGFuZCBvZiBib2RpZXMgY29ubmVjdGVkIHdpdGggZXF1YXRpb25zLlxuICogQGNsYXNzIElzbGFuZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElzbGFuZCgpe1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBib2RpZXMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xufVxuXG4vKipcbiAqIENsZWFuIHRoaXMgaXNsYW5kIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuYm9kaWVzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgYm9keUlkcyA9IFtdO1xuXG4vKipcbiAqIEdldCBhbGwgdW5pcXVlIGJvZGllcyBpbiB0aGlzIGlzbGFuZC5cbiAqIEBtZXRob2QgZ2V0Qm9kaWVzXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgQm9keVxuICovXG5Jc2xhbmQucHJvdG90eXBlLmdldEJvZGllcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIGJvZGllcyA9IHJlc3VsdCB8fCBbXSxcbiAgICAgICAgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgYm9keUlkcy5sZW5ndGggPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpIT09ZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUEuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUEpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlBLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUIuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUIpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlCLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm9kaWVzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZW50aXJlIGlzbGFuZCB3YW50cyB0byBzbGVlcC5cbiAqIEBtZXRob2Qgd2FudHNUb1NsZWVwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Jc2xhbmQucHJvdG90eXBlLndhbnRzVG9TbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJiAhYi53YW50c1RvU2xlZXApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYWtlIGFsbCBib2RpZXMgaW4gdGhlIGlzbGFuZCBzbGVlcC5cbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBiLnNsZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxufSx7XCIuLi9vYmplY3RzL0JvZHlcIjozMX1dLDU5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBJc2xhbmQgPSBfZGVyZXFfKCcuL0lzbGFuZCcpXG4sICAgSXNsYW5kTm9kZSA9IF9kZXJlcV8oJy4vSXNsYW5kTm9kZScpXG4sICAgSXNsYW5kTm9kZVBvb2wgPSBfZGVyZXFfKCcuLy4uL3V0aWxzL0lzbGFuZE5vZGVQb29sJylcbiwgICBJc2xhbmRQb29sID0gX2RlcmVxXygnLi8uLi91dGlscy9Jc2xhbmRQb29sJylcbiwgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kTWFuYWdlcjtcblxuLyoqXG4gKiBTcGxpdHMgdGhlIHN5c3RlbSBvZiBib2RpZXMgYW5kIGVxdWF0aW9ucyBpbnRvIGluZGVwZW5kZW50IGlzbGFuZHNcbiAqXG4gKiBAY2xhc3MgSXNsYW5kTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTWFuYWdlcihvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBub2RlUG9vbFxuICAgICAqIEB0eXBlIHtJc2xhbmROb2RlUG9vbH1cbiAgICAgKi9cbiAgICB0aGlzLm5vZGVQb29sID0gbmV3IElzbGFuZE5vZGVQb29sKHsgc2l6ZTogMTYgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaXNsYW5kUG9vbFxuICAgICAqIEB0eXBlIHtJc2xhbmRQb29sfVxuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kUG9vbCA9IG5ldyBJc2xhbmRQb29sKHsgc2l6ZTogOCB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcXVhdGlvbnMgdG8gc3BsaXQuIE1hbnVhbGx5IGZpbGwgdGhpcyBhcnJheSBiZWZvcmUgcnVubmluZyAuc3BsaXQoKS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyB7eyNjcm9zc0xpbmsgXCJJc2xhbmRcIn19e3svY3Jvc3NMaW5rfX1zLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGlzbGFuZHNcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgZ3JhcGggbm9kZXMuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbm9kZXNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSBxdWV1ZSwgdXNlZCB3aGVuIHRyYXZlcnNpbmcgdGhlIGdyYXBoIG9mIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcXVldWVcbiAgICAgKi9cbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG5cbi8qKlxuICogR2V0IGFuIHVudmlzaXRlZCBub2RlIGZyb20gYSBsaXN0IG9mIG5vZGVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRVbnZpc2l0ZWROb2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gbm9kZXNcbiAqIEByZXR1cm4ge0lzbGFuZE5vZGV8Ym9vbGVhbn0gVGhlIG5vZGUgaWYgZm91bmQsIGVsc2UgZmFsc2UuXG4gKi9cbklzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZSA9IGZ1bmN0aW9uKG5vZGVzKXtcbiAgICB2YXIgTm5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09Tm5vZGVzOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZighbm9kZS52aXNpdGVkICYmIG5vZGUuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBWaXNpdCBhIG5vZGUuXG4gKiBAbWV0aG9kIHZpc2l0XG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzXG4gKiBAcGFyYW0gIHtBcnJheX0gZXFzXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsYmRzLGVxcyl7XG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXF1YXRpb25zLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXF1YXRpb25zW2ldO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXsgLy8gQWxyZWFkeSBhZGRlZD9cbiAgICAgICAgICAgIGVxcy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUnVucyB0aGUgc2VhcmNoIGFsZ29yaXRobSwgc3RhcnRpbmcgYXQgYSByb290IG5vZGUuIFRoZSByZXN1bHRpbmcgYm9kaWVzIGFuZCBlcXVhdGlvbnMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAqIEBtZXRob2QgYmZzXG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSByb290IFRoZSBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSAge0FycmF5fSBiZHMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgQm9kaWVzIHRvLlxuICogQHBhcmFtICB7QXJyYXl9IGVxcyAgQW4gYXJyYXkgdG8gYXBwZW5kIHJlc3VsdGluZyBFcXVhdGlvbnMgdG8uXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLmJmcyA9IGZ1bmN0aW9uKHJvb3QsYmRzLGVxcyl7XG5cbiAgICAvLyBSZXNldCB0aGUgdmlzaXQgcXVldWVcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgcm9vdCBub2RlIHRvIHF1ZXVlXG4gICAgcXVldWUucHVzaChyb290KTtcbiAgICByb290LnZpc2l0ZWQgPSB0cnVlO1xuICAgIHRoaXMudmlzaXQocm9vdCxiZHMsZXFzKTtcblxuICAgIC8vIFByb2Nlc3MgYWxsIHF1ZXVlZCBub2Rlc1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuXG4gICAgICAgIC8vIEdldCBuZXh0IG5vZGUgaW4gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG5cbiAgICAgICAgLy8gVmlzaXQgdW52aXNpdGVkIG5laWdoYm9yaW5nIG5vZGVzXG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGUubmVpZ2hib3JzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZCxiZHMsZXFzKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIGlmIGl0J3MgZHluYW1pY1xuICAgICAgICAgICAgaWYoY2hpbGQuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgd29ybGQgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzLiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiAuaXNsYW5kcy5cbiAqIEBtZXRob2Qgc3BsaXRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9IFRoZSBnZW5lcmF0ZWQgaXNsYW5kc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBub2RlcyA9IHRoaXMubm9kZXMsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zO1xuXG4gICAgLy8gTW92ZSBvbGQgbm9kZXMgdG8gdGhlIG5vZGUgcG9vbFxuICAgIHdoaWxlKG5vZGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMubm9kZVBvb2wucmVsZWFzZShub2Rlcy5wb3AoKSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlUG9vbC5nZXQoKTtcbiAgICAgICAgbm9kZS5ib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAvLyBpZih0aGlzLm5vZGVQb29sLmxlbmd0aCl7XG4gICAgICAgIC8vICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVBvb2wucG9wKCk7XG4gICAgICAgIC8vICAgICBub2RlLnJlc2V0KCk7XG4gICAgICAgIC8vICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIC8vICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgbm9kZXMucHVzaChuZXcgSXNsYW5kTm9kZShib2RpZXNbaV0pKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb25uZWN0aXZpdHkgZGF0YS4gRWFjaCBlcXVhdGlvbiBjb25uZWN0cyAyIGJvZGllcy5cbiAgICBmb3IodmFyIGs9MDsgayE9PWVxdWF0aW9ucy5sZW5ndGg7IGsrKyl7XG4gICAgICAgIHZhciBlcT1lcXVhdGlvbnNba10sXG4gICAgICAgICAgICBpPWJvZGllcy5pbmRleE9mKGVxLmJvZHlBKSxcbiAgICAgICAgICAgIGo9Ym9kaWVzLmluZGV4T2YoZXEuYm9keUIpLFxuICAgICAgICAgICAgbmk9bm9kZXNbaV0sXG4gICAgICAgICAgICBuaj1ub2Rlc1tqXTtcbiAgICAgICAgbmkubmVpZ2hib3JzLnB1c2gobmopO1xuICAgICAgICBuai5uZWlnaGJvcnMucHVzaChuaSk7XG4gICAgICAgIG5pLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgbmouZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgb2xkIGlzbGFuZHMgdG8gdGhlIGlzbGFuZCBwb29sXG4gICAgdmFyIGlzbGFuZHMgPSB0aGlzLmlzbGFuZHM7XG4gICAgZm9yKHZhciBpPTA7IGk8aXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuaXNsYW5kUG9vbC5yZWxlYXNlKGlzbGFuZHNbaV0pO1xuICAgIH1cbiAgICBpc2xhbmRzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBHZXQgaXNsYW5kc1xuICAgIHZhciBjaGlsZDtcbiAgICB3aGlsZSgoY2hpbGQgPSBJc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUobm9kZXMpKSl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpc2xhbmRcbiAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kUG9vbC5nZXQoKTtcblxuICAgICAgICAvLyBHZXQgYWxsIGVxdWF0aW9ucyBhbmQgYm9kaWVzIGluIHRoaXMgaXNsYW5kXG4gICAgICAgIHRoaXMuYmZzKGNoaWxkLCBpc2xhbmQuYm9kaWVzLCBpc2xhbmQuZXF1YXRpb25zKTtcblxuICAgICAgICBpc2xhbmRzLnB1c2goaXNsYW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNsYW5kcztcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMSxcIi4vLi4vdXRpbHMvSXNsYW5kTm9kZVBvb2xcIjo1MCxcIi4vLi4vdXRpbHMvSXNsYW5kUG9vbFwiOjUxLFwiLi9Jc2xhbmRcIjo1OCxcIi4vSXNsYW5kTm9kZVwiOjYwfV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmROb2RlO1xuXG4vKipcbiAqIEhvbGRzIGEgYm9keSBhbmQga2VlcHMgdHJhY2sgb2Ygc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgbmVlZGVkIGZvciBncmFwaCB0cmF2ZXJzYWwuXG4gKiBAY2xhc3MgSXNsYW5kTm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTm9kZShib2R5KXtcblxuXHQvKipcblx0ICogVGhlIGJvZHkgdGhhdCBpcyBjb250YWluZWQgaW4gdGhpcyBub2RlLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIC8qKlxuICAgICAqIE5laWdoYm9yaW5nIElzbGFuZE5vZGVzXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbmVpZ2hib3JzXG4gICAgICovXG4gICAgdGhpcy5uZWlnaGJvcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG5vZGUgd2FzIHZpc2l0aW5nIGR1cmluZyB0aGUgZ3JhcGggdHJhdmVyc2FsLlxuICAgICAqIEBwcm9wZXJ0eSB2aXNpdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogQ2xlYW4gdGhpcyBub2RlIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZE5vZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHRoaXMubmVpZ2hib3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciAgR1NTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvR1NTb2x2ZXInKVxuLCAgICBTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvU29sdmVyJylcbiwgICAgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgIExpbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvTGluZScpXG4sICAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJylcbiwgICAgQ2Fwc3VsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DYXBzdWxlJylcbiwgICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJylcbiwgICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJylcbiwgICAgTGluZWFyU3ByaW5nID0gX2RlcmVxXygnLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKVxuLCAgICBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJylcbiwgICAgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJylcbiwgICAgRGlzdGFuY2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JylcbiwgICAgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKVxuLCAgICBMb2NrQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JylcbiwgICAgUmV2b2x1dGVDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JylcbiwgICAgUHJpc21hdGljQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKVxuLCAgICBHZWFyQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JylcbiwgICAgcGtnID0gX2RlcmVxXygnLi4vLi4vcGFja2FnZS5qc29uJylcbiwgICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICAgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICAgU0FQQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJylcbiwgICAgTmFycm93cGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICAgT3ZlcmxhcEtlZXBlciA9IF9kZXJlcV8oJy4uL3V0aWxzL092ZXJsYXBLZWVwZXInKVxuLCAgICBJc2xhbmRNYW5hZ2VyID0gX2RlcmVxXygnLi9Jc2xhbmRNYW5hZ2VyJylcbiwgICAgUm90YXRpb25hbFNwcmluZyA9IF9kZXJlcV8oJy4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG4vKipcbiAqIFRoZSBkeW5hbWljcyB3b3JsZCwgd2hlcmUgYWxsIGJvZGllcyBhbmQgY29uc3RyYWludHMgbGl2ZS5cbiAqXG4gKiBAY2xhc3MgV29ybGRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl0gRGVmYXVsdHMgdG8gR1NTb2x2ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5ncmF2aXR5XSBEZWZhdWx0cyB0byB5PS05Ljc4LlxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXSBEZWZhdWx0cyB0byBTQVBCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzbGFuZFNwbGl0PXRydWVdXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XG4gKiAgICAgICAgIGdyYXZpdHk6IFswLCAtMTBdLFxuICogICAgICAgICBicm9hZHBoYXNlOiBuZXcgU0FQQnJvYWRwaGFzZSgpXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShuZXcgQm9keSgpKTtcbiAqL1xuZnVuY3Rpb24gV29ybGQob3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ByaW5ncyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIHNwcmluZyB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRTcHJpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpbmdzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29sdmVyIHVzZWQgdG8gc2F0aXNmeSBjb25zdHJhaW50cyBhbmQgY29udGFjdHMuIERlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiR1NTb2x2ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtTb2x2ZXJ9IHNvbHZlclxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgfHwgbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFycm93cGhhc2UgdG8gdXNlIHRvIGdlbmVyYXRlIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXNsYW5kIG1hbmFnZXIgb2YgdGhpcyB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkge0lzbGFuZE1hbmFnZXJ9IGlzbGFuZE1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZE1hbmFnZXIgPSBuZXcgSXNsYW5kTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgLTkuNzgpO1xuICAgIGlmKG9wdGlvbnMuZ3Jhdml0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmdyYXZpdHksIG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eSBpcyB6ZXJvLCBhbmQgLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5PXRydWUsIHRoZW4gc3dpdGNoIHRvIHVzaW5nIC5mcmljdGlvbkdyYXZpdHkgZm9yIGZyaWN0aW9uIGluc3RlYWQuIFRoaXMgZmFsbGJhY2sgaXMgdXNlZnVsIGZvciBncmF2aXR5bGVzcyBnYW1lcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHlcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm9hZHBoYXNlIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnJvYWRwaGFzZVxuICAgICAqIEB0eXBlIHtCcm9hZHBoYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRwaGFzZSA9IG9wdGlvbnMuYnJvYWRwaGFzZSB8fCBuZXcgU0FQQnJvYWRwaGFzZSgpO1xuICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFVzZXItYWRkZWQgY29uc3RyYWludHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRHVtbXkgZGVmYXVsdCBtYXRlcmlhbCBpbiB0aGUgd29ybGQsIHVzZWQgaW4gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBkZWZhdWx0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbCB0byB1c2UsIGlmIG5vIGNvbnRhY3QgbWF0ZXJpYWwgd2FzIHNldCBmb3IgdGhlIGNvbGxpZGluZyBtYXRlcmlhbHMuXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0TWF0ZXJpYWx9IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKHRoaXMuZGVmYXVsdE1hdGVyaWFsLHRoaXMuZGVmYXVsdE1hdGVyaWFsKTtcblxuICAgIC8qKlxuICAgICAqIEZvciBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgdGltZSBzdGVwIHNpemUgd2UgdXNlZCBsYXN0IHN0ZXBcbiAgICAgKiBAcHJvcGVydHkgbGFzdFRpbWVTdGVwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IDEvNjA7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBzcHJpbmcgZm9yY2VzIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlTcHJpbmdGb3JjZXNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBib2R5IGRhbXBpbmcgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseURhbXBpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hcHBseURhbXBpbmcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZ3Jhdml0eSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5R3Jhdml0eVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5R3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBjb25zdHJhaW50IHNvbHZpbmcgaW4gZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZUNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29udGFjdE1hdGVyaWFscyBhZGRlZCB0byB0aGUgV29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RNYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCB0aW1lLlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG4gICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0cnVlIGR1cmluZyBzdGVwKCkuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdGVwcGluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEJvZGllcyB0aGF0IGFyZSBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZSBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJvZGllc1RvQmVSZW1vdmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBpc2xhbmQgc3BsaXR0aW5nLiBJc2xhbmQgc3BsaXR0aW5nIGNhbiBiZSBhbiBhZHZhbnRhZ2UgZm9yIGJvdGggcHJlY2lzaW9uIGFuZCBwZXJmb3JtYW5jZS4gU2VlIHt7I2Nyb3NzTGluayBcIklzbGFuZE1hbmFnZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZFNwbGl0ID0gdHlwZW9mKG9wdGlvbnMuaXNsYW5kU3BsaXQpIT09XCJ1bmRlZmluZWRcIiA/ICEhb3B0aW9ucy5pc2xhbmRTcGxpdCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbWl0SW1wYWN0RXZlbnQgPSB0cnVlO1xuXG4gICAgLy8gSWQgY291bnRlcnNcbiAgICB0aGlzLl9jb25zdHJhaW50SWRDb3VudGVyID0gMDtcbiAgICB0aGlzLl9ib2R5SWRDb3VudGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGFmdGVyIHRoZSBzdGVwKCkuXG4gICAgICogQGV2ZW50IHBvc3RTdGVwXG4gICAgICovXG4gICAgdGhpcy5wb3N0U3RlcEV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJwb3N0U3RlcFwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkU3ByaW5nXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZFNwcmluZ1wiLFxuICAgICAgICBzcHJpbmcgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBmaXJzdCBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGlzIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIGRvbmUuXG4gICAgICogQGV2ZW50IGltcGFjdFxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5pbXBhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJpbXBhY3RcIixcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIHNoYXBlQSA6IG51bGwsXG4gICAgICAgIHNoYXBlQiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbiA6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIEJyb2FkcGhhc2UgaGFzIGNvbGxlY3RlZCBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHdvcmxkLlxuICAgICAqIEluc2lkZSB0aGUgZXZlbnQgaGFuZGxlciwgeW91IGNhbiBtb2RpZnkgdGhlIHBhaXJzIGFycmF5IGFzIHlvdSBsaWtlLCB0b1xuICAgICAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIG9iamVjdHMgdGhhdCB5b3UgZG9uJ3Qgd2FudC5cbiAgICAgKiBAZXZlbnQgcG9zdEJyb2FkcGhhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiBjb2xsaXNpb24gcGFpcnMuIElmIHRoaXMgYXJyYXkgaXMgW2JvZHkxLGJvZHkyLGJvZHkzLGJvZHk0XSwgdGhlbiB0aGUgYm9keSBwYWlycyAxLDIgYW5kIDMsNCB3b3VsZCBhZHZhbmNlIHRvIG5hcnJvd3BoYXNlLlxuICAgICAqL1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJwb3N0QnJvYWRwaGFzZVwiLFxuICAgICAgICBwYWlyczogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdG8gZGVhY3RpdmF0ZSBib2RpZXMgZHVyaW5nIHNpbXVsYXRpb24uIFBvc3NpYmxlIG1vZGVzIGFyZToge3sjY3Jvc3NMaW5rIFwiV29ybGQvTk9fU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuTk9fU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiV29ybGQvQk9EWV9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5CT0RZX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIldvcmxkL0lTTEFORF9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5JU0xBTkRfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBJZiBzbGVlcGluZyBpcyBlbmFibGVkLCB5b3UgbWlnaHQgbmVlZCB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L3dha2VVcDptZXRob2RcIn19d2FrZSB1cHt7L2Nyb3NzTGlua319IHRoZSBib2RpZXMgaWYgdGhleSBmYWxsIGFzbGVlcCB3aGVuIHRoZXkgc2hvdWxkbid0LiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHdvcmxkLCBidXQgd2FudCB0byBkaXNhYmxlIGl0IGZvciBhIHBhcnRpY3VsYXIgYm9keSwgc2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvYWxsb3dTbGVlcDpwcm9wZXJ0eVwifX1Cb2R5LmFsbG93U2xlZXB7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBNb2RlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBXb3JsZC5OT19TTEVFUElOR1xuICAgICAqL1xuICAgIHRoaXMuc2xlZXBNb2RlID0gV29ybGQuTk9fU0xFRVBJTkc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RhcnRzIHN0YXJ0IHRvIG92ZXJsYXAuIEZpcmVkIGluIHRoZSBuYXJyb3dwaGFzZSwgZHVyaW5nIHN0ZXAuXG4gICAgICogQGV2ZW50IGJlZ2luQ29udGFjdFxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5iZWdpbkNvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJiZWdpbkNvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBOiBudWxsLFxuICAgICAgICBzaGFwZUI6IG51bGwsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbCxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uczogW11cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxuICAgICAqIEBldmVudCBlbmRDb250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuZW5kQ29udGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVuZENvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBOiBudWxsLFxuICAgICAgICBzaGFwZUI6IG51bGwsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBlcXVhdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIgdG8gYmUgc29sdmVkLiBDYW4gYmUgdXNlZCB0byBjb250cm9sIHdoYXQgZXF1YXRpb25zIGdvZXMgaW50byB0aGUgc29sdmVyLlxuICAgICAqIEBldmVudCBwcmVTb2x2ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnMgIEFuIGFycmF5IG9mIGNvbnRhY3RzIHRvIGJlIHNvbHZlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmcmljdGlvbkVxdWF0aW9ucyBBbiBhcnJheSBvZiBmcmljdGlvbiBlcXVhdGlvbnMgdG8gYmUgc29sdmVkLlxuICAgICAqL1xuICAgIHRoaXMucHJlU29sdmVFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJwcmVTb2x2ZVwiLFxuICAgICAgICBjb250YWN0RXF1YXRpb25zOiBudWxsLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uczogbnVsbFxuICAgIH07XG5cbiAgICAvLyBGb3Iga2VlcGluZyB0cmFjayBvZiBvdmVybGFwcGluZyBzaGFwZXNcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0geyBrZXlzOltdIH07XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IHsga2V5czpbXSB9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtPdmVybGFwS2VlcGVyfSBvdmVybGFwS2VlcGVyXG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Xb3JsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JsZDtcblxuLyoqXG4gKiBOZXZlciBkZWFjdGl2YXRlIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19TTEVFUElOR1xuICovXG5Xb3JsZC5OT19TTEVFUElORyA9IDE7XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xuICovXG5Xb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcblxuLyoqXG4gKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xuICovXG5Xb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpe1xuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbn07XG5cbi8qKlxuICogQWRkIGEgQ29udGFjdE1hdGVyaWFsIHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjb250YWN0TWF0ZXJpYWxcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNvbnRhY3RNYXRlcmlhbCl7XG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzLnB1c2goY29udGFjdE1hdGVyaWFsKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWxcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjbSl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29udGFjdE1hdGVyaWFscy5pbmRleE9mKGNtKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnRhY3RNYXRlcmlhbHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29udGFjdCBtYXRlcmlhbCBnaXZlbiB0d28gbWF0ZXJpYWxzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgb3IgZmFsc2Ugb24gZmFpbC5cbiAqIEB0b2RvIFVzZSBmYXN0ZXIgaGFzaCBtYXAgdG8gbG9va3VwIGZyb20gbWF0ZXJpYWwgaWQnc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWxBLG1hdGVyaWFsQil7XG4gICAgdmFyIGNtYXRzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT0wLCBOPWNtYXRzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBjbSA9IGNtYXRzW2ldO1xuICAgICAgICBpZiggKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxBLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEIuaWQpIHx8XG4gICAgICAgICAgICAoY20ubWF0ZXJpYWxBLmlkID09PSBtYXRlcmlhbEIuaWQpICYmIChjbS5tYXRlcmlhbEIuaWQgPT09IG1hdGVyaWFsQS5pZCkgKXtcbiAgICAgICAgICAgIHJldHVybiBjbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKlxuICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb25zdHJhaW50KXtcbiAgICB2YXIgaWR4ID0gdGhpcy5jb25zdHJhaW50cy5pbmRleE9mKGNvbnN0cmFpbnQpO1xuICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuY29uc3RyYWludHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbnZhciBzdGVwX3IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfcnVuaXQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdSA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9mID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX2ZoTWludiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfbWcgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhpdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHhqdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHplcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBpbnRlcnB2ZWxvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXG4gKlxuICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWQ9MF0gIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFNpbXBsZSBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgdmFyIGZpeGVkVGltZVN0ZXAgPSAxIC8gNjA7XG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqXG4gKiAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpe1xuICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCk7XG4gKiAgICAgICAgIHJlbmRlckJvZHkoYm9keS5wb3NpdGlvbiwgYm9keS5hbmdsZSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEZpeGVkIHRpbWVzdGVwcGluZyB3aXRoIGludGVycG9sYXRpb25cbiAqICAgICB2YXIgbWF4U3ViU3RlcHMgPSAxMDtcbiAqICAgICB2YXIgbGFzdFRpbWVTZWNvbmRzO1xuICpcbiAqICAgICBmdW5jdGlvbiBhbmltYXRlKHQpe1xuICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICAgIHRpbWVTZWNvbmRzID0gdCAvIDEwMDA7XG4gKiAgICAgICAgIGxhc3RUaW1lU2Vjb25kcyA9IGxhc3RUaW1lU2Vjb25kcyB8fCB0aW1lU2Vjb25kcztcbiAqXG4gKiAgICAgICAgIGRlbHRhVGltZSA9IHRpbWVTZWNvbmRzIC0gbGFzdFRpbWVTZWNvbmRzO1xuICogICAgICAgICB3b3JsZC5zdGVwKGZpeGVkVGltZVN0ZXAsIGRlbHRhVGltZSwgbWF4U3ViU3RlcHMpO1xuICpcbiAqICAgICAgICAgcmVuZGVyQm9keShib2R5LmludGVycG9sYXRlZFBvc2l0aW9uLCBib2R5LmludGVycG9sYXRlZEFuZ2xlKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBsb29wXG4gKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICpcbiAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oZHQsdGltZVNpbmNlTGFzdENhbGxlZCxtYXhTdWJTdGVwcyl7XG4gICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcbiAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xuXG4gICAgaWYodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCl7IC8vIEZpeGVkLCBzaW1wbGUgc3RlcHBpbmdcblxuICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XG4gICAgICAgIHZhciBzdWJzdGVwcyA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHtcbiAgICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0O1xuICAgICAgICAgICAgc3Vic3RlcHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gKHRoaXMuYWNjdW11bGF0b3IgJSBkdCkgLyBkdDtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT10aGlzLmJvZGllcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xuICAgICAgICAgICAgdmVjMi5sZXJwKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucHJldmlvdXNQb3NpdGlvbiwgYi5wb3NpdGlvbiwgdCk7XG4gICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5wcmV2aW91c0FuZ2xlICsgdCAqIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBlbmRPdmVybGFwcyA9IFtdO1xuXG4vKipcbiAqIE1ha2UgYSBmaXhlZCBzdGVwLlxuICogQG1ldGhvZCBpbnRlcm5hbFN0ZXBcbiAqIEBwYXJhbSAge251bWJlcn0gZHRcbiAqIEBwcml2YXRlXG4gKi9cbldvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbihkdCl7XG4gICAgdGhpcy5zdGVwcGluZyA9IHRydWU7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCxcbiAgICAgICAgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncyxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGcgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICBucCA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgdDAsIHQxLFxuICAgICAgICBmaE1pbnYgPSBzdGVwX2ZoTWludixcbiAgICAgICAgdmVsb2R0ID0gc3RlcF92ZWxvZHQsXG4gICAgICAgIG1nID0gc3RlcF9tZyxcbiAgICAgICAgc2NhbGUgPSB2ZWMyLnNjYWxlLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgcm90YXRlID0gdmVjMi5yb3RhdGUsXG4gICAgICAgIGlzbGFuZE1hbmFnZXIgPSB0aGlzLmlzbGFuZE1hbmFnZXI7XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIudGljaygpO1xuXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcblxuICAgIC8vIFVwZGF0ZSBhcHByb3hpbWF0ZSBmcmljdGlvbiBncmF2aXR5LlxuICAgIGlmKHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkpe1xuICAgICAgICB2YXIgZ3Jhdml0eUxlbiA9IHZlYzIubGVuZ3RoKHRoaXMuZ3Jhdml0eSk7XG4gICAgICAgIGlmKCEoZ3Jhdml0eUxlbiA9PT0gMCAmJiB0aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkpKXtcbiAgICAgICAgICAgIC8vIE5vbnplcm8gZ3Jhdml0eS4gVXNlIGl0LlxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkdyYXZpdHkgPSBncmF2aXR5TGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGdyYXZpdHkgdG8gYm9kaWVzXG4gICAgaWYodGhpcy5hcHBseUdyYXZpdHkpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBmaSA9IGIuZm9yY2U7XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuRFlOQU1JQyB8fCBiLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVjMi5zY2FsZShtZyxnLGIubWFzcypiLmdyYXZpdHlTY2FsZSk7IC8vIEY9bSpnXG4gICAgICAgICAgICBhZGQoZmksZmksbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIHNwcmluZyBmb3JjZXNcbiAgICBpZih0aGlzLmFwcGx5U3ByaW5nRm9yY2VzKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1Oc3ByaW5nczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzID0gc3ByaW5nc1tpXTtcbiAgICAgICAgICAgIHMuYXBwbHlGb3JjZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5hcHBseURhbXBpbmcpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmKGIudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBiLmFwcGx5RGFtcGluZyhkdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCcm9hZHBoYXNlXG4gICAgdmFyIHJlc3VsdCA9IGJyb2FkcGhhc2UuZ2V0Q29sbGlzaW9uUGFpcnModGhpcyk7XG5cbiAgICAvLyBSZW1vdmUgaWdub3JlZCBjb2xsaXNpb24gcGFpcnNcbiAgICB2YXIgaWdub3JlZFBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcbiAgICBmb3IodmFyIGk9aWdub3JlZFBhaXJzLmxlbmd0aC0yOyBpPj0wOyBpLT0yKXtcbiAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICBpZiggKGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbal0gJiYgaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgIChpZ25vcmVkUGFpcnNbaSsxXSA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbaisxXSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjb25zdHJhaW5lZCBwYWlycyB3aXRoIGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2VcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29uc3RyYWludHNbaV07XG4gICAgICAgIGlmKCFjLmNvbGxpZGVDb25uZWN0ZWQpe1xuICAgICAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICAgICAgaWYoIChjLmJvZHlBID09PSByZXN1bHRbal0gJiYgYy5ib2R5QiA9PT0gcmVzdWx0W2orMV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSByZXN1bHRbal0gJiYgYy5ib2R5QSA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvc3RCcm9hZHBoYXNlIGV2ZW50XG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gcmVzdWx0O1xuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RCcm9hZHBoYXNlRXZlbnQpO1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IG51bGw7XG5cbiAgICAvLyBOYXJyb3dwaGFzZVxuICAgIG5wLnJlc2V0KHRoaXMpO1xuICAgIGZvcih2YXIgaT0wLCBOcmVzdWx0cz1yZXN1bHQubGVuZ3RoOyBpIT09TnJlc3VsdHM7IGkrPTIpe1xuICAgICAgICB2YXIgYmkgPSByZXN1bHRbaV0sXG4gICAgICAgICAgICBiaiA9IHJlc3VsdFtpKzFdO1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHkgaVxuICAgICAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ymkuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICAgICAgdmFyIHNpID0gYmkuc2hhcGVzW2tdLFxuICAgICAgICAgICAgICAgIHhpID0gc2kucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgYWkgPSBzaS5hbmdsZTtcblxuICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1iai5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNqID0gYmouc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgICAgICB4aiA9IHNqLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhaiA9IHNqLmFuZ2xlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmKHNpLm1hdGVyaWFsICYmIHNqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG1wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5OYXJyb3dwaGFzZShucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSx0aGlzLmZyaWN0aW9uR3Jhdml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWtlIHVwIGJvZGllc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2Upe1xuICAgICAgICAgICAgYm9keS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtaXQgZW5kIG92ZXJsYXAgZXZlbnRzXG4gICAgaWYodGhpcy5oYXMoJ2VuZENvbnRhY3QnKSl7XG4gICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5nZXRFbmRPdmVybGFwcyhlbmRPdmVybGFwcyk7XG4gICAgICAgIHZhciBlID0gdGhpcy5lbmRDb250YWN0RXZlbnQ7XG4gICAgICAgIHZhciBsID0gZW5kT3ZlcmxhcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZShsLS0pe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmRPdmVybGFwc1tsXTtcbiAgICAgICAgICAgIGUuc2hhcGVBID0gZGF0YS5zaGFwZUE7XG4gICAgICAgICAgICBlLnNoYXBlQiA9IGRhdGEuc2hhcGVCO1xuICAgICAgICAgICAgZS5ib2R5QSA9IGRhdGEuYm9keUE7XG4gICAgICAgICAgICBlLmJvZHlCID0gZGF0YS5ib2R5QjtcbiAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRPdmVybGFwcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHZhciBwcmVTb2x2ZUV2ZW50ID0gdGhpcy5wcmVTb2x2ZUV2ZW50O1xuICAgIHByZVNvbHZlRXZlbnQuY29udGFjdEVxdWF0aW9ucyA9IG5wLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgcHJlU29sdmVFdmVudC5mcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zO1xuICAgIHRoaXMuZW1pdChwcmVTb2x2ZUV2ZW50KTtcbiAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBwcmVTb2x2ZUV2ZW50LmZyaWN0aW9uRXF1YXRpb25zID0gbnVsbDtcblxuICAgIC8vIHVwZGF0ZSBjb25zdHJhaW50IGVxdWF0aW9uc1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgY29uc3RyYWludHNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYobnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggfHwgbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIHx8IE5jb25zdHJhaW50cyl7XG4gICAgICAgIGlmKHRoaXMuaXNsYW5kU3BsaXQpe1xuICAgICAgICAgICAgLy8gU3BsaXQgaW50byBpc2xhbmRzXG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIGNvbnN0cmFpbnRzW2ldLmVxdWF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLnNwbGl0KHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWlzbGFuZE1hbmFnZXIuaXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZCA9IGlzbGFuZE1hbmFnZXIuaXNsYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpZihpc2xhbmQuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZUlzbGFuZChkdCxpc2xhbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBBZGQgY29udGFjdCBlcXVhdGlvbnMgdG8gc29sdmVyXG4gICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5mcmljdGlvbkVxdWF0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB1c2VyLWRlZmluZWQgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnNvbHZlQ29uc3RyYWludHMpe1xuICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZShkdCx0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RlcCBmb3J3YXJkXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAvLyBpZihib2R5LnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keS50eXBlICE9PSBCb2R5LlNUQVRJQyl7XG4gICAgICAgIGJvZHkuaW50ZWdyYXRlKGR0KTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGZvcmNlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICBib2RpZXNbaV0uc2V0WmVyb0ZvcmNlKCk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcbiAgICBpZih0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0Jykpe1xuICAgICAgICB2YXIgZXYgPSB0aGlzLmltcGFjdEV2ZW50O1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmKGVxLmZpcnN0SW1wYWN0KXtcbiAgICAgICAgICAgICAgICBldi5ib2R5QSA9IGVxLmJvZHlBO1xuICAgICAgICAgICAgICAgIGV2LmJvZHlCID0gZXEuYm9keUI7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVBID0gZXEuc2hhcGVBO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQiA9IGVxLnNoYXBlQjtcbiAgICAgICAgICAgICAgICBldi5jb250YWN0RXF1YXRpb24gPSBlcTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpe1xuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCBmYWxzZSwgZHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgJiYgdGhpcy5pc2xhbmRTcGxpdCl7XG5cbiAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGlzbGFuZHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgaWYoaXNsYW5kLndhbnRzVG9TbGVlcCgpKXtcbiAgICAgICAgICAgICAgICBpc2xhbmQuc2xlZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBib2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmFsXG4gICAgdmFyIGJvZGllc1RvQmVSZW1vdmVkID0gdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllc1RvQmVSZW1vdmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1RvQmVSZW1vdmVkW2ldKTtcbiAgICB9XG4gICAgYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RTdGVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSdW5zIG5hcnJvd3BoYXNlIGZvciB0aGUgc2hhcGUgcGFpciBpIGFuZCBqLlxuICogQG1ldGhvZCBydW5OYXJyb3dwaGFzZVxuICogQHBhcmFtICB7TmFycm93cGhhc2V9IG5wXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7U2hhcGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2pcbiAqIEBwYXJhbSAge0FycmF5fSB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICogQHBhcmFtICB7TnVtYmVyfSBtdVxuICovXG5Xb3JsZC5wcm90b3R5cGUucnVuTmFycm93cGhhc2UgPSBmdW5jdGlvbihucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSxnbGVuKXtcblxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBncm91cHMgYW5kIG1hc2tzXG4gICAgaWYoISgoc2kuY29sbGlzaW9uR3JvdXAgJiBzai5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2ouY29sbGlzaW9uR3JvdXAgJiBzaS5jb2xsaXNpb25NYXNrKSAhPT0gMCkpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHdvcmxkIHBvc2l0aW9uIGFuZCBhbmdsZSBvZiBlYWNoIHNoYXBlXG4gICAgdmVjMi5yb3RhdGUoeGl3LCB4aSwgYmkuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHhqdywgeGosIGJqLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh4aXcsIHhpdywgYmkucG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKHhqdywgeGp3LCBiai5wb3NpdGlvbik7XG4gICAgdmFyIGFpdyA9IGFpICsgYmkuYW5nbGU7XG4gICAgdmFyIGFqdyA9IGFqICsgYmouYW5nbGU7XG5cbiAgICBucC5lbmFibGVGcmljdGlvbiA9IGNtLmZyaWN0aW9uID4gMDtcbiAgICBucC5mcmljdGlvbkNvZWZmaWNpZW50ID0gY20uZnJpY3Rpb247XG4gICAgdmFyIHJlZHVjZWRNYXNzO1xuICAgIGlmKGJpLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IGJpLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiai5tYXNzO1xuICAgIH0gZWxzZSBpZihiai50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiai50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmkubWFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y2VkTWFzcyA9IChiaS5tYXNzKmJqLm1hc3MpLyhiaS5tYXNzK2JqLm1hc3MpO1xuICAgIH1cbiAgICBucC5zbGlwRm9yY2UgPSBjbS5mcmljdGlvbipnbGVuKnJlZHVjZWRNYXNzO1xuICAgIG5wLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG4gICAgbnAuc3VyZmFjZVZlbG9jaXR5ID0gY20uc3VyZmFjZVZlbG9jaXR5O1xuICAgIG5wLmZyaWN0aW9uU3RpZmZuZXNzID0gY20uZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgbnAuZnJpY3Rpb25SZWxheGF0aW9uID0gY20uZnJpY3Rpb25SZWxheGF0aW9uO1xuICAgIG5wLnN0aWZmbmVzcyA9IGNtLnN0aWZmbmVzcztcbiAgICBucC5yZWxheGF0aW9uID0gY20ucmVsYXhhdGlvbjtcbiAgICBucC5jb250YWN0U2tpblNpemUgPSBjbS5jb250YWN0U2tpblNpemU7XG4gICAgbnAuZW5hYmxlZEVxdWF0aW9ucyA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgdmFyIHJlc29sdmVyID0gbnBbc2kudHlwZSB8IHNqLnR5cGVdLFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG4gICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgIHZhciBzZW5zb3IgPSBzaS5zZW5zb3IgfHwgc2ouc2Vuc29yO1xuICAgICAgICB2YXIgbnVtRnJpY3Rpb25CZWZvcmUgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmIChzaS50eXBlIDwgc2oudHlwZSkge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaSxzaSx4aXcsYWl3LCBiaixzaix4ancsYWp3LCBzZW5zb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaixzaix4ancsYWp3LCBiaSxzaSx4aXcsYWl3LCBzZW5zb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1GcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCAtIG51bUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgICAgIGlmKG51bUNvbnRhY3RzKXtcblxuICAgICAgICAgICAgaWYoIGJpLmFsbG93U2xlZXAgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LkFXQUtFICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkU3F1YXJlZEIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoYmoudmVsb2NpdHkpICsgTWF0aC5wb3coYmouYW5ndWxhclZlbG9jaXR5LDIpO1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEIgPSBNYXRoLnBvdyhiai5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICAgICAgaWYoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIqMil7XG4gICAgICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJpLnZlbG9jaXR5KSArIE1hdGgucG93KGJpLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgICAgICBiai5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuc2V0T3ZlcmxhcHBpbmcoYmksIHNpLCBiaiwgc2opO1xuICAgICAgICAgICAgaWYodGhpcy5oYXMoJ2JlZ2luQ29udGFjdCcpICYmIHRoaXMub3ZlcmxhcEtlZXBlci5pc05ld092ZXJsYXAoc2ksIHNqKSl7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBvcnQgbmV3IHNoYXBlIG92ZXJsYXBcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuYmVnaW5Db250YWN0RXZlbnQ7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUEgPSBzaTtcbiAgICAgICAgICAgICAgICBlLnNoYXBlQiA9IHNqO1xuICAgICAgICAgICAgICAgIGUuYm9keUEgPSBiaTtcbiAgICAgICAgICAgICAgICBlLmJvZHlCID0gYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGgtbnVtQ29udGFjdHM7IGk8bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMucHVzaChucC5jb250YWN0RXF1YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGl2aWRlIHRoZSBtYXggZnJpY3Rpb24gZm9yY2UgYnkgdGhlIG51bWJlciBvZiBjb250YWN0c1xuICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIgJiYgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPiAxKXsgLy8gV2h5IGRpdmlkZSBieSAxP1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT1ucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGgtbnVtRnJpY3Rpb25FcXVhdGlvbnM7IGk8bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG5wLmZyaWN0aW9uRXF1YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBmLnNldFNsaXBGb3JjZShmLmdldFNsaXBGb3JjZSgpIC8gbnVtRnJpY3Rpb25FcXVhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBBZGQgYSBzcHJpbmcgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZFNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkU3ByaW5nID0gZnVuY3Rpb24oc3ByaW5nKXtcbiAgICB0aGlzLnNwcmluZ3MucHVzaChzcHJpbmcpO1xuICAgIHZhciBldnQgPSB0aGlzLmFkZFNwcmluZ0V2ZW50O1xuICAgIGV2dC5zcHJpbmcgPSBzcHJpbmc7XG4gICAgdGhpcy5lbWl0KGV2dCk7XG4gICAgZXZ0LnNwcmluZyA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNwcmluZ1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlU3ByaW5nXG4gKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVTcHJpbmcgPSBmdW5jdGlvbihzcHJpbmcpe1xuICAgIHZhciBpZHggPSB0aGlzLnNwcmluZ3MuaW5kZXhPZihzcHJpbmcpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5zcHJpbmdzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGJvZHkgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZEJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCksXG4gKiAgICAgICAgIGJvZHkgPSBuZXcgQm9keSgpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XG4gKiBAdG9kbyBXaGF0IGlmIHRoaXMgaXMgZG9uZSBkdXJpbmcgc3RlcD9cbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpID09PSAtMSl7XG4gICAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgICAgICB2YXIgZXZ0ID0gdGhpcy5hZGRCb2R5RXZlbnQ7XG4gICAgICAgIGV2dC5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5lbWl0KGV2dCk7XG4gICAgICAgIGV2dC5ib2R5ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGJvZHkgZnJvbSB0aGUgc2ltdWxhdGlvbi4gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZyBzdGVwKCksIHRoZSBib2R5IHJlbW92YWwgaXMgc2NoZWR1bGVkIHRvIGFmdGVyIHRoZSBzdGVwLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24oYm9keSl7XG4gICAgaWYodGhpcy5zdGVwcGluZyl7XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQucHVzaChib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LndvcmxkID0gbnVsbDtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSk7XG4gICAgICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmJvZGllcyxpZHgsMSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIGJvZHkucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgYm9keSBieSBpdHMgaWQuXG4gKiBAbWV0aG9kIGdldEJvZHlCeUlkXG4gKiBAcGFyYW0ge251bWJlcn0gaWRcbiAqIEByZXR1cm4ge0JvZHl9IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiLmlkID09PSBpZCl7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2FibGUgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBkaXNhYmxlQm9keUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZGlzYWJsZUJvZHlDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG4gICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycy5wdXNoKGJvZHlBLGJvZHlCKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGNvbGxpc2lvbnMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBlbmFibGVCb2R5Q29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5lbmFibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPTA7IGk8cGFpcnMubGVuZ3RoOyBpKz0yKXtcbiAgICAgICAgaWYoKHBhaXJzW2ldID09PSBib2R5QSAmJiBwYWlyc1tpKzFdID09PSBib2R5QikgfHwgKHBhaXJzW2krMV0gPT09IGJvZHlBICYmIHBhaXJzW2ldID09PSBib2R5Qikpe1xuICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksMik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgV29ybGQsIHJlbW92ZXMgYWxsIGJvZGllcywgY29uc3RyYWludHMgYW5kIHNwcmluZ3MuXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy50aW1lID0gMDtcblxuICAgIC8vIFJlbW92ZSBhbGwgc29sdmVyIGVxdWF0aW9uc1xuICAgIGlmKHRoaXMuc29sdmVyICYmIHRoaXMuc29sdmVyLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBmb3IodmFyIGk9Y3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBib2RpZXNcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPWJvZGllcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzcHJpbmdzXG4gICAgdmFyIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgZm9yKHZhciBpPXNwcmluZ3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY21zID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT1jbXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XG4gICAgfVxuXG4gICAgV29ybGQuYXBwbHkodGhpcyk7XG59O1xuXG52YXIgaGl0VGVzdF90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBoaXRUZXN0X3plcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBoaXRUZXN0X3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBUZXN0IGlmIGEgd29ybGQgcG9pbnQgb3ZlcmxhcHMgYm9kaWVzXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqIEBwYXJhbSAge0FycmF5fSAgd29ybGRQb2ludCAgUG9pbnQgdG8gdXNlIGZvciBpbnRlcnNlY3Rpb24gdGVzdHNcbiAqIEBwYXJhbSAge0FycmF5fSAgYm9kaWVzICAgICAgQSBsaXN0IG9mIG9iamVjdHMgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBVc2VkIGZvciBtYXRjaGluZyBhZ2FpbnN0IHBhcnRpY2xlcyBhbmQgbGluZXMuIEFkZHMgc29tZSBtYXJnaW4gdG8gdGhlc2UgaW5maW5pdGVzaW1hbCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBBcnJheSBvZiBib2RpZXMgdGhhdCBvdmVybGFwIHRoZSBwb2ludFxuICogQHRvZG8gU2hvdWxkIHVzZSBhbiBhcGkgc2ltaWxhciB0byB0aGUgcmF5Y2FzdCBmdW5jdGlvblxuICogQHRvZG8gU2hvdWxkIHByb2JhYmx5IGltcGxlbWVudCBhIC5jb250YWluc1BvaW50IG1ldGhvZCBmb3IgYWxsIHNoYXBlcy4gV291bGQgYmUgbW9yZSBlZmZpY2llbnRcbiAqIEB0b2RvIFNob3VsZCB1c2UgdGhlIGJyb2FkcGhhc2VcbiAqL1xuV29ybGQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbih3b3JsZFBvaW50LGJvZGllcyxwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcbiAgICB2YXIgcGIgPSBuZXcgQm9keSh7IHBvc2l0aW9uOndvcmxkUG9pbnQgfSksXG4gICAgICAgIHBzID0gbmV3IFBhcnRpY2xlKCksXG4gICAgICAgIHB4ID0gd29ybGRQb2ludCxcbiAgICAgICAgcGEgPSAwLFxuICAgICAgICB4ID0gaGl0VGVzdF90bXAxLFxuICAgICAgICB6ZXJvID0gaGl0VGVzdF96ZXJvLFxuICAgICAgICB0bXAgPSBoaXRUZXN0X3RtcDI7XG4gICAgcGIuYWRkU2hhcGUocHMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIC8vIENoZWNrIGJvZGllc1xuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MCwgTlM9Yi5zaGFwZXMubGVuZ3RoOyBqIT09TlM7IGorKyl7XG4gICAgICAgICAgICB2YXIgcyA9IGIuc2hhcGVzW2pdO1xuXG4gICAgICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcG9zaXRpb24gKyBhbmdsZVxuICAgICAgICAgICAgdmVjMi5yb3RhdGUoeCwgcy5wb3NpdGlvbiwgYi5hbmdsZSk7XG4gICAgICAgICAgICB2ZWMyLmFkZCh4LCB4LCBiLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBhID0gcy5hbmdsZSArIGIuYW5nbGU7XG5cbiAgICAgICAgICAgIGlmKCAocyBpbnN0YW5jZW9mIENpcmNsZSAgICAmJiBuLmNpcmNsZVBhcnRpY2xlICAoYixzLHgsYSwgICAgIHBiLHBzLHB4LHBhLCB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENvbnZleCAgICAmJiBuLnBhcnRpY2xlQ29udmV4ICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBsYW5lICAgICAmJiBuLnBhcnRpY2xlUGxhbmUgICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENhcHN1bGUgICAmJiBuLnBhcnRpY2xlQ2Fwc3VsZSAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBhcnRpY2xlICAmJiB2ZWMyLnNxdWFyZWRMZW5ndGgodmVjMi5zdWIodG1wLHgsd29ybGRQb2ludCkpIDwgcHJlY2lzaW9uKnByZWNpc2lvbilcbiAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdGlmZm5lc3MgZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxTdGlmZm5lc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb25zdHJhaW50c1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY29udGFjdE1hdGVyaWFscyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJlbGF4YXRpb24gZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxSZWxheGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsUmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuXG4gICAgLy8gU2V0IGZvciBhbGwgY29uc3RyYWludHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb250YWN0IG1hdGVyaWFsc1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xufTtcblxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5ID0gW107XG5cbi8qKlxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHJheSA9IG5ldyBSYXkoe1xuICogICAgICAgICBtb2RlOiBSYXkuQ0xPU0VTVCwgLy8gb3IgQU5ZXG4gKiAgICAgICAgIGZyb206IFswLCAwXSxcbiAqICAgICAgICAgdG86IFsxMCwgMF0sXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG4gKiAgICAgd29ybGQucmF5Y2FzdChyZXN1bHQsIHJheSk7XG4gKlxuICogICAgIC8vIEdldCB0aGUgaGl0IHBvaW50XG4gKiAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbiAqICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoaGl0UG9pbnQsIHJheSk7XG4gKiAgICAgY29uc29sZS5sb2coJ0hpdCBwb2ludDogJywgaGl0UG9pbnRbMF0sIGhpdFBvaW50WzFdLCAnIGF0IGRpc3RhbmNlICcgKyByZXN1bHQuZ2V0SGl0RGlzdGFuY2UocmF5KSk7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgcmF5ID0gbmV3IFJheSh7XG4gKiAgICAgICAgIG1vZGU6IFJheS5BTEwsXG4gKiAgICAgICAgIGZyb206IFswLCAwXSxcbiAqICAgICAgICAgdG86IFsxMCwgMF0sXG4gKiAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihyZXN1bHQpe1xuICpcbiAqICAgICAgICAgICAgIC8vIFByaW50IHNvbWUgaW5mbyBhYm91dCB0aGUgaGl0XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGl0IGJvZHkgYW5kIHNoYXBlOiAnLCByZXN1bHQuYm9keSwgcmVzdWx0LnNoYXBlKTtcbiAqXG4gKiAgICAgICAgICAgICAvLyBHZXQgdGhlIGhpdCBwb2ludFxuICogICAgICAgICAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbiAqICAgICAgICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChoaXRQb2ludCwgcmF5KTtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaXQgcG9pbnQ6ICcsIGhpdFBvaW50WzBdLCBoaXRQb2ludFsxXSwgJyBhdCBkaXN0YW5jZSAnICsgcmVzdWx0LmdldEhpdERpc3RhbmNlKHJheSkpO1xuICpcbiAqICAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgaGFwcHkgd2l0aCB0aGUgaGl0cyB5b3UgZ290IHRoaXMgZmFyLCB5b3UgY2FuIHN0b3AgdGhlIHRyYXZlcnNhbCBoZXJlOlxuICogICAgICAgICAgICAgcmVzdWx0LnN0b3AoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIHZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICogICAgIHdvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5KXtcblxuICAgIC8vIEdldCBhbGwgYm9kaWVzIHdpdGhpbiB0aGUgcmF5IEFBQkJcbiAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0aGlzLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHRoaXMsIHRtcEFBQkIsIHRtcEFycmF5KTtcbiAgICByYXkuaW50ZXJzZWN0Qm9kaWVzKHJlc3VsdCwgdG1wQXJyYXkpO1xuICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gcmVzdWx0Lmhhc0hpdCgpO1xufTtcblxufSx7XCIuLi8uLi9wYWNrYWdlLmpzb25cIjo2LFwiLi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vY29sbGlzaW9uL05hcnJvd3BoYXNlXCI6MTAsXCIuLi9jb2xsaXNpb24vUmF5XCI6MTEsXCIuLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjEzLFwiLi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjE0LFwiLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTUsXCIuLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE2LFwiLi4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnRcIjoxNyxcIi4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnRcIjoxOCxcIi4uL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjE5LFwiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI2LFwiLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjcsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI4LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMSxcIi4uL29iamVjdHMvTGluZWFyU3ByaW5nXCI6MzIsXCIuLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmdcIjozMyxcIi4uL3NoYXBlcy9DYXBzdWxlXCI6MzgsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzksXCIuLi9zaGFwZXMvQ29udmV4XCI6NDAsXCIuLi9zaGFwZXMvTGluZVwiOjQyLFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDMsXCIuLi9zaGFwZXMvUGxhbmVcIjo0NCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuLi91dGlscy9PdmVybGFwS2VlcGVyXCI6NTIsXCIuLi91dGlscy9VdGlsc1wiOjU3LFwiLi9Jc2xhbmRNYW5hZ2VyXCI6NTl9XX0se30sWzM2XSlcbigzNilcbn0pOyJdLCJuYW1lcyI6WyJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwicDIiLCJ0IiwibiIsInIiLCJzIiwibyIsInUiLCJhIiwicmVxdWlyZSIsImkiLCJFcnJvciIsImNhbGwiLCJsZW5ndGgiLCJfZGVyZXFfIiwiU2NhbGFyIiwiTGluZSIsImxpbmVJbnQiLCJsMSIsImwyIiwicHJlY2lzaW9uIiwiYTEiLCJiMSIsImMxIiwiYTIiLCJiMiIsImMyIiwiZGV0IiwiZXEiLCJzZWdtZW50c0ludGVyc2VjdCIsInAxIiwicTEiLCJxMiIsImR4IiwiZHkiLCJkYSIsImRiIiwiUG9pbnQiLCJhcmVhIiwiYiIsImMiLCJsZWZ0IiwibGVmdE9uIiwicmlnaHQiLCJyaWdodE9uIiwidG1wUG9pbnQxIiwidG1wUG9pbnQyIiwiY29sbGluZWFyIiwidGhyZXNob2xkQW5nbGUiLCJhYiIsImJjIiwiZG90IiwibWFnQSIsIk1hdGgiLCJzcXJ0IiwibWFnQiIsImFuZ2xlIiwiYWNvcyIsInNxZGlzdCIsIlBvbHlnb24iLCJ2ZXJ0aWNlcyIsInByb3RvdHlwZSIsImF0IiwidiIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwiYXBwZW5kIiwicG9seSIsImZyb20iLCJ0byIsInB1c2giLCJtYWtlQ0NXIiwiYnIiLCJyZXZlcnNlIiwidG1wIiwiTiIsInBvcCIsImlzUmVmbGV4IiwidG1wTGluZTEiLCJ0bXBMaW5lMiIsImNhblNlZSIsInAiLCJkaXN0IiwiY29weSIsImoiLCJ0YXJnZXRQb2x5IiwiayIsImdldEN1dEVkZ2VzIiwibWluIiwidG1wMSIsInRtcDIiLCJ0bXBQb2x5IiwibkRpYWdzIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZGVjb21wIiwiZWRnZXMiLCJzbGljZSIsImN1dEVkZ2VzIiwiQXJyYXkiLCJwb2x5cyIsImN1dEVkZ2UiLCJyZXN1bHQiLCJzcGxpY2UiLCJpbmRleE9mIiwiaXNTaW1wbGUiLCJwYXRoIiwiZ2V0SW50ZXJzZWN0aW9uUG9pbnQiLCJkZWx0YSIsInF1aWNrRGVjb21wIiwicmVmbGV4VmVydGljZXMiLCJzdGVpbmVyUG9pbnRzIiwibWF4bGV2ZWwiLCJsZXZlbCIsInVwcGVySW50IiwibG93ZXJJbnQiLCJ1cHBlckRpc3QiLCJsb3dlckRpc3QiLCJkIiwiY2xvc2VzdERpc3QiLCJ1cHBlckluZGV4IiwibG93ZXJJbmRleCIsImNsb3Nlc3RJbmRleCIsImxvd2VyUG9seSIsInVwcGVyUG9seSIsImNvbnNvbGUiLCJ3YXJuIiwicmVtb3ZlQ29sbGluZWFyUG9pbnRzIiwibnVtIiwiYWJzIiwidmVjMiIsIlV0aWxzIiwiQUFCQiIsIm9wdGlvbnMiLCJsb3dlckJvdW5kIiwiY3JlYXRlIiwidXBwZXJCb3VuZCIsInNldEZyb21Qb2ludHMiLCJwb2ludHMiLCJwb3NpdGlvbiIsInNraW5TaXplIiwibCIsInJvdGF0ZSIsImNvc0FuZ2xlIiwiY29zIiwic2luQW5nbGUiLCJzaW4iLCJ4IiwieSIsImFkZCIsImFhYmIiLCJleHRlbmQiLCJvdmVybGFwcyIsInUxIiwidTIiLCJjb250YWluc1BvaW50IiwicG9pbnQiLCJvdmVybGFwc1JheSIsInJheSIsImRpckZyYWNYIiwiZGlyZWN0aW9uIiwiZGlyRnJhY1kiLCJ0MSIsInQyIiwidDMiLCJ0NCIsInRtaW4iLCJtYXgiLCJ0bWF4IiwiQm9keSIsIkJyb2FkcGhhc2UiLCJ0eXBlIiwid29ybGQiLCJib3VuZGluZ1ZvbHVtZVR5cGUiLCJCT1VORElOR19DSVJDTEUiLCJzZXRXb3JsZCIsImdldENvbGxpc2lvblBhaXJzIiwiYm91bmRpbmdSYWRpdXNDaGVjayIsImJvZHlBIiwiYm9keUIiLCJzdWIiLCJkMiIsInNxdWFyZWRMZW5ndGgiLCJib3VuZGluZ1JhZGl1cyIsImFhYmJDaGVjayIsImdldEFBQkIiLCJib3VuZGluZ1ZvbHVtZUNoZWNrIiwiY2FuQ29sbGlkZSIsIktJTkVNQVRJQyIsIlNUQVRJQyIsInNsZWVwU3RhdGUiLCJTTEVFUElORyIsIk5BSVZFIiwiU0FQIiwiQ2lyY2xlIiwiUGxhbmUiLCJTaGFwZSIsIlBhcnRpY2xlIiwiTmFpdmVCcm9hZHBoYXNlIiwiY29uc3RydWN0b3IiLCJib2RpZXMiLCJOY29sbGlkaW5nIiwiYmkiLCJiaiIsImFhYmJRdWVyeSIsImFhYmJOZWVkc1VwZGF0ZSIsInVwZGF0ZUFBQkIiLCJDb250YWN0RXF1YXRpb25Qb29sIiwiRnJpY3Rpb25FcXVhdGlvblBvb2wiLCJUdXBsZURpY3Rpb25hcnkiLCJFcXVhdGlvbiIsIkNvbnRhY3RFcXVhdGlvbiIsIkZyaWN0aW9uRXF1YXRpb24iLCJDb252ZXgiLCJCb3giLCJOYXJyb3dwaGFzZSIsInlBeGlzIiwiZnJvbVZhbHVlcyIsInRtcDMiLCJ0bXA0IiwidG1wNSIsInRtcDYiLCJ0bXA3IiwidG1wOCIsInRtcDkiLCJ0bXAxMCIsInRtcDExIiwidG1wMTIiLCJ0bXAxMyIsInRtcDE0IiwidG1wMTUiLCJ0bXAxNiIsInRtcDE3IiwidG1wMTgiLCJ0bXBBcnJheSIsImNvbnRhY3RFcXVhdGlvbnMiLCJmcmljdGlvbkVxdWF0aW9ucyIsImVuYWJsZUZyaWN0aW9uIiwiZW5hYmxlZEVxdWF0aW9ucyIsInNsaXBGb3JjZSIsImZyaWN0aW9uQ29lZmZpY2llbnQiLCJzdXJmYWNlVmVsb2NpdHkiLCJjb250YWN0RXF1YXRpb25Qb29sIiwic2l6ZSIsImZyaWN0aW9uRXF1YXRpb25Qb29sIiwicmVzdGl0dXRpb24iLCJzdGlmZm5lc3MiLCJERUZBVUxUX1NUSUZGTkVTUyIsInJlbGF4YXRpb24iLCJERUZBVUxUX1JFTEFYQVRJT04iLCJmcmljdGlvblN0aWZmbmVzcyIsImZyaWN0aW9uUmVsYXhhdGlvbiIsImVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uIiwiY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAiLCJjb250YWN0U2tpblNpemUiLCJib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BIiwiYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQiIsImJvZGllc092ZXJsYXAiLCJzaGFwZVBvc2l0aW9uQSIsInNoYXBlUG9zaXRpb25CIiwiTnNoYXBlc2kiLCJzaGFwZXMiLCJzaGFwZUEiLCJ0b1dvcmxkRnJhbWUiLCJOc2hhcGVzaiIsInNoYXBlQiIsImNvbGxpZGVkTGFzdFN0ZXAiLCJpZDEiLCJpZCIsImlkMiIsImdldCIsInJlc2V0IiwiZXFzIiwic2V0IiwiY2UiLCJmZSIsInJlbGVhc2UiLCJjcmVhdGVDb250YWN0RXF1YXRpb24iLCJmaXJzdEltcGFjdCIsIm5lZWRzVXBkYXRlIiwiZW5hYmxlZCIsIm9mZnNldCIsImNyZWF0ZUZyaWN0aW9uRXF1YXRpb24iLCJzZXRTbGlwRm9yY2UiLCJyZWxhdGl2ZVZlbG9jaXR5IiwiY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdCIsImNvbnRhY3RQb2ludEEiLCJjb250YWN0UG9pbnRCIiwicm90YXRlOTBjdyIsIm5vcm1hbEEiLCJjcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlIiwibnVtQ29udGFjdHMiLCJpbnZOdW1Db250YWN0cyIsInNjYWxlIiwibm9ybWFsaXplIiwiTElORSIsIkNPTlZFWCIsImNvbnZleExpbmUiLCJjb252ZXhCb2R5IiwiY29udmV4U2hhcGUiLCJjb252ZXhPZmZzZXQiLCJjb252ZXhBbmdsZSIsImxpbmVCb2R5IiwibGluZVNoYXBlIiwibGluZU9mZnNldCIsImxpbmVBbmdsZSIsImp1c3RUZXN0IiwiQk9YIiwibGluZUJveCIsImJveEJvZHkiLCJib3hTaGFwZSIsImJveE9mZnNldCIsImJveEFuZ2xlIiwic2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUiLCJjYXBzdWxlU2hhcGUiLCJyYWRpdXMiLCJjb252ZXhDYXBzdWxlX3RlbXBSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJjb252ZXhDYXBzdWxlX3RlbXBWZWMiLCJDQVBTVUxFIiwiY29udmV4Q2Fwc3VsZSIsImNvbnZleFBvc2l0aW9uIiwiY2Fwc3VsZUJvZHkiLCJjYXBzdWxlUG9zaXRpb24iLCJjYXBzdWxlQW5nbGUiLCJjaXJjbGVQb3MiLCJyZXN1bHQxIiwiY2lyY2xlQ29udmV4IiwicmVzdWx0MiIsImNvbnZleENvbnZleCIsImxpbmVDYXBzdWxlIiwibGluZVBvc2l0aW9uIiwiY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEiLCJjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiIsImNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MSIsImNhcHN1bGVDYXBzdWxlIiwic2kiLCJ4aSIsImFpIiwic2oiLCJ4aiIsImFqIiwiZW5hYmxlRnJpY3Rpb25CZWZvcmUiLCJjaXJjbGVQb3NpIiwiY2lyY2xlUG9zaiIsImNpcmNsZUNpcmNsZSIsInJlY3QiLCJsaW5lTGluZSIsInBvc2l0aW9uQSIsImFuZ2xlQSIsInBvc2l0aW9uQiIsImFuZ2xlQiIsIlBMQU5FIiwicGxhbmVMaW5lIiwicGxhbmVCb2R5IiwicGxhbmVTaGFwZSIsInBsYW5lT2Zmc2V0IiwicGxhbmVBbmdsZSIsIndvcmxkVmVydGV4MCIsIndvcmxkVmVydGV4MSIsIndvcmxkVmVydGV4MDEiLCJ3b3JsZFZlcnRleDExIiwid29ybGRFZGdlIiwid29ybGRFZGdlVW5pdCIsIndvcmxkTm9ybWFsIiwid29ybGRUYW5nZW50IiwidmVydHMiLCJQQVJUSUNMRSIsInBhcnRpY2xlQ2Fwc3VsZSIsInBhcnRpY2xlQm9keSIsInBhcnRpY2xlU2hhcGUiLCJwYXJ0aWNsZVBvc2l0aW9uIiwicGFydGljbGVBbmdsZSIsImNpcmNsZUxpbmUiLCJDSVJDTEUiLCJjaXJjbGVCb2R5IiwiY2lyY2xlU2hhcGUiLCJjaXJjbGVPZmZzZXQiLCJjaXJjbGVBbmdsZSIsImxpbmVSYWRpdXMiLCJjaXJjbGVSYWRpdXMiLCJvcnRob0Rpc3QiLCJsaW5lVG9DaXJjbGVPcnRob1VuaXQiLCJwcm9qZWN0ZWRQb2ludCIsImNlbnRlckRpc3QiLCJsaW5lVG9DaXJjbGUiLCJsaW5lRW5kVG9MaW5lUmFkaXVzIiwicmFkaXVzU3VtIiwicG9zIiwicG9zMCIsInBvczEiLCJwb3ciLCJjaXJjbGVDYXBzdWxlIiwiY29udmV4VG9DaXJjbGUiLCJ3b3JsZFZlcnRleCIsImNsb3Nlc3RFZGdlIiwiY2xvc2VzdEVkZ2VEaXN0YW5jZSIsImNsb3Nlc3RFZGdlT3J0aG9EaXN0IiwiY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCIsImNhbmRpZGF0ZSIsImNhbmRpZGF0ZURpc3QiLCJtaW5DYW5kaWRhdGUiLCJmb3VuZCIsIm1pbkNhbmRpZGF0ZURpc3RhbmNlIiwibnVtUmVwb3J0ZWQiLCJ2MCIsInYxIiwicG9pbnRJbkNvbnZleCIsImNhbmRpZGF0ZURpc3RhbmNlIiwibG9jYWxWZXJ0ZXgiLCJwaWNfd29ybGRWZXJ0ZXgwIiwicGljX3dvcmxkVmVydGV4MSIsInBpY19yMCIsInBpY19yMSIsIndvcmxkUG9pbnQiLCJyMCIsInIxIiwibGFzdENyb3NzIiwiY3Jvc3MiLCJjcm9zc0xlbmd0aCIsInBhcnRpY2xlQ29udmV4IiwicGFydGljbGVPZmZzZXQiLCJjb252ZXhUb3BhcnRpY2xlIiwibG9jYWxQb2ludCIsIm1pbkVkZ2VOb3JtYWwiLCJvZmZzZXRBIiwib2Zmc2V0QiIsInJhZGl1c0EiLCJyYWRpdXNCIiwicGxhbmVDb252ZXgiLCJwYXJ0aWNsZVBsYW5lIiwiY2lyY2xlUGFydGljbGUiLCJwbGFuZUNhcHN1bGVfdG1wQ2lyY2xlIiwicGxhbmVDYXBzdWxlX3RtcDEiLCJwbGFuZUNhcHN1bGVfdG1wMiIsInBsYW5lQ2Fwc3VsZV90bXAzIiwicGxhbmVDYXBzdWxlIiwiY2Fwc3VsZU9mZnNldCIsImVuZDEiLCJlbmQyIiwiY2lyY2xlIiwiZHN0IiwibnVtQ29udGFjdHMxIiwiY2lyY2xlUGxhbmUiLCJudW1Db250YWN0czIiLCJudW1Ub3RhbCIsInBsYW5lVG9DaXJjbGUiLCJ0ZW1wIiwiY29udGFjdCIsInNlcEF4aXMiLCJ3b3JsZFBvaW50MCIsIndvcmxkUG9pbnQxIiwicHJvamVjdGVkIiwicGVuZXRyYXRpb25WZWMiLCJmaW5kU2VwYXJhdGluZ0F4aXMiLCJjbG9zZXN0RWRnZTEiLCJnZXRDbG9zZXN0RWRnZSIsImNsb3Nlc3RFZGdlMiIsImNsb3Nlc3RFZGdlQSIsImNsb3Nlc3RFZGdlQiIsImluc2lkZU51bUVkZ2VzIiwicGNvYV90bXAxIiwicHJvamVjdENvbnZleE9udG9BeGlzIiwid29ybGRBeGlzIiwidmFsdWUiLCJsb2NhbEF4aXMiLCJmc2FfdG1wMSIsImZzYV90bXAyIiwiZnNhX3RtcDMiLCJmc2FfdG1wNCIsImZzYV90bXA1IiwiZnNhX3RtcDYiLCJvZmZzZXQxIiwiYW5nbGUxIiwib2Zmc2V0MiIsImFuZ2xlMiIsIm1heERpc3QiLCJvdmVybGFwIiwiZWRnZSIsIm5vcm1hbCIsInNwYW4xIiwic3BhbjIiLCJzd2FwcGVkIiwiZ2NlX3RtcDEiLCJnY2VfdG1wMiIsImdjZV90bXAzIiwiYXhpcyIsImZsaXAiLCJtYXhEb3QiLCJjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUiLCJjaXJjbGVIZWlnaHRmaWVsZF9kaXN0IiwiY2lyY2xlSGVpZ2h0ZmllbGRfdjAiLCJjaXJjbGVIZWlnaHRmaWVsZF92MSIsImNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSIsImNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsIiwiY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsIiwiSEVJR0hURklFTEQiLCJjaXJjbGVIZWlnaHRmaWVsZCIsImhmQm9keSIsImhmU2hhcGUiLCJoZlBvcyIsImhmQW5nbGUiLCJkYXRhIiwiaGVpZ2h0cyIsInciLCJlbGVtZW50V2lkdGgiLCJtaW5DYW5kaWRhdGVOb3JtYWwiLCJpZHhBIiwiZmxvb3IiLCJpZHhCIiwiY2VpbCIsIlBJIiwiY29udmV4SGVpZ2h0ZmllbGRfdjAiLCJjb252ZXhIZWlnaHRmaWVsZF92MSIsImNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MiLCJjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGUiLCJjb252ZXhIZWlnaHRmaWVsZCIsImNvbnZleFBvcyIsInRpbGVQb3MiLCJ0aWxlQ29udmV4IiwidGlsZUhlaWdodCIsIlJheSIsIlJheWNhc3RSZXN1bHQiLCJjaGVja0NvbGxpc2lvblJlc3BvbnNlIiwidW5kZWZpbmVkIiwic2tpcEJhY2tmYWNlcyIsImNvbGxpc2lvbk1hc2siLCJjb2xsaXNpb25Hcm91cCIsIm1vZGUiLCJBTlkiLCJjYWxsYmFjayIsInVwZGF0ZSIsIkNMT1NFU1QiLCJBTEwiLCJpbnRlcnNlY3RCb2RpZXMiLCJzaG91bGRTdG9wIiwiYm9keSIsImludGVyc2VjdEJvZHkiLCJpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb24iLCJjb2xsaXNpb25SZXNwb25zZSIsIndvcmxkUG9zaXRpb24iLCJzaGFwZSIsIndvcmxkQW5nbGUiLCJpbnRlcnNlY3RTaGFwZSIsImRpc3RhbmNlIiwiZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZCIsIl9jdXJyZW50Qm9keSIsIl9jdXJyZW50U2hhcGUiLCJyYXljYXN0IiwiaGl0UG9pbnRXb3JsZCIsInJlcG9ydEludGVyc2VjdGlvbiIsImZyYWN0aW9uIiwiZmFjZUluZGV4IiwiaGFzSGl0IiwiaW50ZXJzZWN0Iiwic3F1YXJlZERpc3RhbmNlIiwiaXNTdG9wcGVkIiwiZ2V0SGl0RGlzdGFuY2UiLCJnZXRIaXRQb2ludCIsIm91dCIsImxlcnAiLCJzdG9wIiwiU0FQQnJvYWRwaGFzZSIsImF4aXNMaXN0IiwiYXhpc0luZGV4IiwidGhhdCIsIl9hZGRCb2R5SGFuZGxlciIsIl9yZW1vdmVCb2R5SGFuZGxlciIsImlkeCIsImFwcGVuZEFycmF5Iiwib2ZmIiwib24iLCJzb3J0QXhpc0xpc3QiLCJzb3J0TGlzdCIsImxvd2VyIiwidXBwZXIiLCJDb25zdHJhaW50IiwiZGVmYXVsdHMiLCJjb2xsaWRlQ29ubmVjdGVkIiwid2FrZVVwQm9kaWVzIiwiZXF1YXRpb25zIiwid2FrZVVwIiwiRElTVEFOQ0UiLCJHRUFSIiwiTE9DSyIsIlBSSVNNQVRJQyIsIlJFVk9MVVRFIiwic2V0U3RpZmZuZXNzIiwic2V0UmVsYXhhdGlvbiIsIkRpc3RhbmNlQ29uc3RyYWludCIsImxvY2FsQW5jaG9yQSIsImxvY2FsQW5jaG9yQiIsIndvcmxkQW5jaG9yQSIsIndvcmxkQW5jaG9yQiIsIm1heEZvcmNlIiwicmkiLCJyaiIsImNvbXB1dGVHcSIsInNldE1heEZvcmNlIiwidXBwZXJMaW1pdEVuYWJsZWQiLCJ1cHBlckxpbWl0IiwibG93ZXJMaW1pdEVuYWJsZWQiLCJsb3dlckxpbWl0Iiwibm9ybWFsRXF1YXRpb24iLCJHIiwidmlvbGF0aW5nIiwibWluRm9yY2UiLCJyaXhuIiwicmp4biIsImdldE1heEZvcmNlIiwiQW5nbGVMb2NrRXF1YXRpb24iLCJHZWFyQ29uc3RyYWludCIsInJhdGlvIiwibWF4VG9ycXVlIiwic2V0TWF4VG9ycXVlIiwic2V0UmF0aW8iLCJ0b3JxdWUiLCJnZXRNYXhUb3JxdWUiLCJMb2NrQ29uc3RyYWludCIsImxvY2FsQW5nbGVCIiwicm90IiwiZyIsImxvY2FsT2Zmc2V0QiIsImZvcmNlIiwieEF4aXMiLCJSb3RhdGlvbmFsTG9ja0VxdWF0aW9uIiwiUHJpc21hdGljQ29uc3RyYWludCIsImxvY2FsQXhpc0EiLCJ0cmFucyIsImdnIiwidXBkYXRlSmFjb2JpYW4iLCJkaXNhYmxlUm90YXRpb25hbExvY2siLCJ2ZWxvY2l0eSIsInVwcGVyTGltaXRFcXVhdGlvbiIsImxvd2VyTGltaXRFcXVhdGlvbiIsIm1vdG9yRXF1YXRpb24iLCJtb3RvckVuYWJsZWQiLCJtb3RvclNwZWVkIiwib2xkIiwiY29tcHV0ZUdXIiwidmkiLCJ2aiIsIndpIiwiYW5ndWxhclZlbG9jaXR5Iiwid2oiLCJnbXVsdCIsIndvcmxkQXhpc0EiLCJvcmllbnRlZEFuY2hvckEiLCJvcmllbnRlZEFuY2hvckIiLCJyZWxQb3NpdGlvbiIsImVuYWJsZU1vdG9yIiwiZGlzYWJsZU1vdG9yIiwic2V0TGltaXRzIiwiUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24iLCJSZXZvbHV0ZUNvbnN0cmFpbnQiLCJ3b3JsZFBpdm90QSIsIndvcmxkUGl2b3RCIiwicGl2b3RBIiwicGl2b3RCIiwid29ybGRQaXZvdCIsImxvY2FsUGl2b3RBIiwibG9jYWxQaXZvdEIiLCJ0YW5nZW50IiwicmVsQW5nbGUiLCJtb3RvcklzRW5hYmxlZCIsInNldE1vdG9yU3BlZWQiLCJzcGVlZCIsImdldE1vdG9yU3BlZWQiLCJjb21wdXRlQiIsImgiLCJHVyIsIkdxIiwiR2lNZiIsImNvbXB1dGVHaU1mIiwiQiIsInJlbFZlbCIsImdldFZlbG9jaXR5QWxvbmdOb3JtYWwiLCJnZXRWZWxvY2l0eUF0UG9pbnQiLCJzdWJ0cmFjdCIsIkFSUkFZX1RZUEUiLCJlcHNpbG9uIiwidGltZVN0ZXAiLCJtdWx0aXBsaWVyIiwicWkiLCJxaiIsImNvbXB1dGVHV2xhbWJkYSIsInZsYW1iZGEiLCJ3bGFtYmRhIiwiaU1maSIsImlNZmoiLCJmaSIsInRpIiwiYW5ndWxhckZvcmNlIiwiZmoiLCJ0aiIsImludk1hc3NpIiwiaW52TWFzc1NvbHZlIiwiaW52TWFzc2oiLCJpbnZJaSIsImludkluZXJ0aWFTb2x2ZSIsImludklqIiwibXVsdGlwbHkiLCJtYXNzTXVsdGlwbGllciIsImNvbXB1dGVHaU1HdCIsImFkZFRvV2xhbWJkYV90ZW1wIiwiYWRkVG9XbGFtYmRhX0dpIiwiYWRkVG9XbGFtYmRhX0dqIiwiYWRkVG9XbGFtYmRhX3JpIiwiYWRkVG9XbGFtYmRhX3JqIiwiYWRkVG9XbGFtYmRhX01kaWFnIiwiYWRkVG9XbGFtYmRhIiwiZGVsdGFsYW1iZGEiLCJHaSIsIkdqIiwiTWRpYWciLCJjb21wdXRlSW52QyIsImVwcyIsImdldFNsaXBGb3JjZSIsIndvcmxkVmVjdG9yQSIsIndvcmxkVmVjdG9yQiIsIkV2ZW50RW1pdHRlciIsImxpc3RlbmVyIiwiY29udGV4dCIsIl9saXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJoYXMiLCJpbmRleCIsImVtaXQiLCJldmVudCIsImxpc3RlbmVyQXJyYXkiLCJ0YXJnZXQiLCJNYXRlcmlhbCIsIkNvbnRhY3RNYXRlcmlhbCIsIm1hdGVyaWFsQSIsIm1hdGVyaWFsQiIsImlkQ291bnRlciIsImZyaWN0aW9uIiwiUG9seUsiLCJHZXRBcmVhIiwic3VtIiwiVHJpYW5ndWxhdGUiLCJ0Z3MiLCJhdmwiLCJhbCIsImkwIiwiaTEiLCJpMiIsImF4IiwiYXkiLCJieCIsImJ5IiwiY3giLCJjeSIsImVhckZvdW5kIiwiX2NvbnZleCIsIl9Qb2ludEluVHJpYW5nbGUiLCJweCIsInB5IiwidjB4IiwidjB5IiwidjF4IiwidjF5IiwidjJ4IiwidjJ5IiwiZG90MDAiLCJkb3QwMSIsImRvdDAyIiwiZG90MTEiLCJkb3QxMiIsImludkRlbm9tIiwiY3Jvc3NWWiIsInZlYyIsInpjb21wIiwiY3Jvc3NaViIsInRvTG9jYWxGcmFtZSIsImZyYW1lUG9zaXRpb24iLCJmcmFtZUFuZ2xlIiwidG9HbG9iYWxGcmFtZSIsInZlY3RvclRvTG9jYWxGcmFtZSIsIndvcmxkVmVjdG9yIiwidmVjdG9yVG9HbG9iYWxGcmFtZSIsImxvY2FsVmVjdG9yIiwiY2VudHJvaWQiLCJjbG9uZSIsIm11bCIsImRpdmlkZSIsImRpdiIsInNxckRpc3QiLCJsZW4iLCJzcXJMZW4iLCJuZWdhdGUiLCJzdHIiLCJyZWZsZWN0IiwidmVjdG9yIiwiZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uIiwicDAiLCJwMyIsImdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uIiwiczFfeCIsInMxX3kiLCJzMl94IiwiczJfeSIsIl9pZENvdW50ZXIiLCJtYXNzIiwiaW52TWFzcyIsImluZXJ0aWEiLCJpbnZJbmVydGlhIiwiZml4ZWRSb3RhdGlvbiIsImZpeGVkWCIsImZpeGVkWSIsImludGVycG9sYXRlZFBvc2l0aW9uIiwiaW50ZXJwb2xhdGVkQW5nbGUiLCJwcmV2aW91c1Bvc2l0aW9uIiwicHJldmlvdXNBbmdsZSIsImRhbXBpbmciLCJhbmd1bGFyRGFtcGluZyIsIkRZTkFNSUMiLCJhbGxvd1NsZWVwIiwid2FudHNUb1NsZWVwIiwiQVdBS0UiLCJzbGVlcFNwZWVkTGltaXQiLCJzbGVlcFRpbWVMaW1pdCIsImdyYXZpdHlTY2FsZSIsImlkbGVUaW1lIiwidGltZUxhc3RTbGVlcHkiLCJjY2RTcGVlZFRocmVzaG9sZCIsImNjZEl0ZXJhdGlvbnMiLCJjb25jYXZlUGF0aCIsIl93YWtlVXBBZnRlck5hcnJvd3BoYXNlIiwidXBkYXRlTWFzc1Byb3BlcnRpZXMiLCJ1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzIiwic2V0RGVuc2l0eSIsImRlbnNpdHkiLCJ0b3RhbEFyZWEiLCJnZXRBcmVhIiwic2hhcGVBQUJCIiwiYm9keUFuZ2xlIiwiY29tcHV0ZUFBQkIiLCJ1cGRhdGVCb3VuZGluZ1JhZGl1cyIsImFkZFNoYXBlIiwicmVtb3ZlU2hhcGUiLCJtIiwiSSIsInIyIiwiSWNtIiwiY29tcHV0ZU1vbWVudE9mSW5lcnRpYSIsIkJvZHlfYXBwbHlGb3JjZV9yIiwiYXBwbHlGb3JjZSIsInJlbGF0aXZlUG9pbnQiLCJyb3RGb3JjZSIsIkJvZHlfYXBwbHlGb3JjZV9mb3JjZVdvcmxkIiwiQm9keV9hcHBseUZvcmNlX3BvaW50V29ybGQiLCJCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbCIsImFwcGx5Rm9yY2VMb2NhbCIsImxvY2FsRm9yY2UiLCJ3b3JsZEZvcmNlIiwidmVjdG9yVG9Xb3JsZEZyYW1lIiwiQm9keV9hcHBseUltcHVsc2VfdmVsbyIsImFwcGx5SW1wdWxzZSIsImltcHVsc2VWZWN0b3IiLCJ2ZWxvIiwicm90VmVsbyIsIkJvZHlfYXBwbHlJbXB1bHNlX2ltcHVsc2VXb3JsZCIsIkJvZHlfYXBwbHlJbXB1bHNlX3BvaW50V29ybGQiLCJCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsIiwiYXBwbHlJbXB1bHNlTG9jYWwiLCJsb2NhbEltcHVsc2UiLCJ3b3JsZEltcHVsc2UiLCJmcm9tUG9seWdvbiIsInNraXBTaW1wbGVDaGVjayIsImNvbnZleGVzIiwib3B0aW1hbERlY29tcCIsImNtIiwiY2VudGVyT2ZNYXNzIiwidXBkYXRlVHJpYW5nbGVzIiwidXBkYXRlQ2VudGVyT2ZNYXNzIiwiYWRqdXN0Q2VudGVyT2ZNYXNzIiwiYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDEiLCJhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiIsImFkanVzdENlbnRlck9mTWFzc190bXAzIiwiYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQiLCJvZmZzZXRfdGltZXNfYXJlYSIsInNldFplcm9Gb3JjZSIsInJlc2V0Q29uc3RyYWludFZlbG9jaXR5IiwiYWRkQ29uc3RyYWludFZlbG9jaXR5IiwiYXBwbHlEYW1waW5nIiwiZHQiLCJ3YWtlVXBFdmVudCIsInNsZWVwIiwic2xlZXBFdmVudCIsInNsZWVwVGljayIsInRpbWUiLCJkb250U2xlZXAiLCJzcGVlZFNxdWFyZWQiLCJzcGVlZExpbWl0U3F1YXJlZCIsIlNMRUVQWSIsIm92ZXJsYXBLZWVwZXIiLCJib2RpZXNBcmVPdmVybGFwcGluZyIsImludGVncmF0ZV9maE1pbnYiLCJpbnRlZ3JhdGVfdmVsb2R0IiwiaW50ZWdyYXRlIiwibWludiIsImludGVncmF0ZVRvVGltZU9mSW1wYWN0IiwiZW5kIiwic3RhcnRUb0VuZCIsInJlbWVtYmVyUG9zaXRpb24iLCJzdGFydFRvRW5kQW5nbGUiLCJ0aW1lT2ZJbXBhY3QiLCJoaXQiLCJyZW1lbWJlckFuZ2xlIiwiaXRlciIsInRtaWQiLCJuYXJyb3dwaGFzZSIsInNsZWVweUV2ZW50IiwiU3ByaW5nIiwiTGluZWFyU3ByaW5nIiwic2V0V29ybGRBbmNob3JBIiwic2V0V29ybGRBbmNob3JCIiwiZ2V0V29ybGRBbmNob3JBIiwiZ2V0V29ybGRBbmNob3JCIiwid29ybGREaXN0YW5jZSIsInJlc3RMZW5ndGgiLCJhcHBseUZvcmNlX3IiLCJhcHBseUZvcmNlX3JfdW5pdCIsImFwcGx5Rm9yY2VfdSIsImFwcGx5Rm9yY2VfZiIsImFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBIiwiYXBwbHlGb3JjZV93b3JsZEFuY2hvckIiLCJhcHBseUZvcmNlX3JpIiwiYXBwbHlGb3JjZV9yaiIsImFwcGx5Rm9yY2VfdG1wIiwicl91bml0IiwicmxlbiIsInJpX3hfZiIsInJqX3hfZiIsIlJvdGF0aW9uYWxTcHJpbmciLCJyZXN0QW5nbGUiLCJUb3BEb3duVmVoaWNsZSIsImNoYXNzaXNCb2R5Iiwid2hlZWxzIiwiZ3JvdW5kQm9keSIsInByZVN0ZXBDYWxsYmFjayIsImFkZFRvV29ybGQiLCJhZGRCb2R5Iiwid2hlZWwiLCJhZGRDb25zdHJhaW50IiwicmVtb3ZlRnJvbVdvcmxkIiwicmVtb3ZlQm9keSIsInJlbW92ZUNvbnN0cmFpbnQiLCJhZGRXaGVlbCIsIndoZWVsT3B0aW9ucyIsIldoZWVsQ29uc3RyYWludCIsInZlaGljbGUiLCJmb3J3YXJkRXF1YXRpb24iLCJzaWRlRXF1YXRpb24iLCJzdGVlclZhbHVlIiwiZW5naW5lRm9yY2UiLCJzZXRTaWRlRnJpY3Rpb24iLCJzaWRlRnJpY3Rpb24iLCJsb2NhbEZvcndhcmRWZWN0b3IiLCJsb2NhbFBvc2l0aW9uIiwiYXBwbHkiLCJzZXRCcmFrZUZvcmNlIiwid29ybGRWZWxvY2l0eSIsImdldFNwZWVkIiwidG1wVmVjIiwiQ2Fwc3VsZSIsIkdTU29sdmVyIiwiSGVpZ2h0ZmllbGQiLCJQb29sIiwiU29sdmVyIiwiV29ybGQiLCJ2ZXJzaW9uIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJhcmd1bWVudHMiLCJheGVzIiwiY29ybmVyMSIsImNvcm5lcjIiLCJjb3JuZXIzIiwiY29ybmVyNCIsInVwZGF0ZUFyZWEiLCJpbnRlcnNlY3RDYXBzdWxlX2hpdFBvaW50V29ybGQiLCJpbnRlcnNlY3RDYXBzdWxlX25vcm1hbCIsImludGVyc2VjdENhcHN1bGVfbDAiLCJpbnRlcnNlY3RDYXBzdWxlX2wxIiwiaW50ZXJzZWN0Q2Fwc3VsZV91bml0X3kiLCJsMCIsImhhbGZMZW4iLCJkaWFnb25hbExlbmd0aFNxdWFyZWQiLCJzcXJ0RGVsdGEiLCJpbnYyYSIsImQxIiwiUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCIsIlJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsIiwiaW50ZXJzZWN0aW9uUG9pbnQiLCJwb2x5ayIsImlzQXJyYXkiLCJ0cmlhbmdsZXMiLCJ0bXBWZWMxIiwidG1wVmVjMiIsInByb2plY3RPbnRvTG9jYWxBeGlzIiwicHJvamVjdE9udG9Xb3JsZEF4aXMiLCJzaGFwZU9mZnNldCIsInNoYXBlQW5nbGUiLCJwb2x5a1ZlcnRzIiwiaWQzIiwidXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkIiwidXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkX3RpbWVzX21hc3MiLCJ1cGRhdGVDZW50ZXJPZk1hc3NfYSIsInVwZGF0ZUNlbnRlck9mTWFzc19iIiwidXBkYXRlQ2VudGVyT2ZNYXNzX2MiLCJ1cGRhdGVDZW50ZXJPZk1hc3NfYWMiLCJ1cGRhdGVDZW50ZXJPZk1hc3NfY2EiLCJ1cGRhdGVDZW50ZXJPZk1hc3NfY2IiLCJ1cGRhdGVDZW50ZXJPZk1hc3NfbiIsImFjIiwiY2EiLCJjYiIsImNlbnRyb2lkX3RpbWVzX21hc3MiLCJ0cmlhbmdsZUFyZWEiLCJkZW5vbSIsIm51bWVyIiwiaW50ZXJzZWN0Q29udmV4X3JheVN0YXJ0IiwiaW50ZXJzZWN0Q29udmV4X3JheUVuZCIsImludGVyc2VjdENvbnZleF9ub3JtYWwiLCJyYXlTdGFydCIsInJheUVuZCIsImtleSIsIm1heFZhbHVlIiwibWluVmFsdWUiLCJ1cGRhdGVNYXhNaW5WYWx1ZXMiLCJnZXRMaW5lU2VnbWVudCIsInN0YXJ0IiwiZ2V0U2VnbWVudEluZGV4IiwiZ2V0Q2xhbXBlZFNlZ21lbnRJbmRleCIsImludGVyc2VjdEhlaWdodGZpZWxkX2hpdFBvaW50V29ybGQiLCJpbnRlcnNlY3RIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCIsImludGVyc2VjdEhlaWdodGZpZWxkX2wwIiwiaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbDEiLCJpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbEZyb20iLCJpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFRvIiwiaW50ZXJzZWN0SGVpZ2h0ZmllbGRfdW5pdF95IiwiaW50WCIsImludFkiLCJsb2NhbEZyb20iLCJsb2NhbFRvIiwicmF5Y2FzdF9oaXRQb2ludCIsInJheWNhc3Rfbm9ybWFsIiwicmF5Y2FzdF9sMCIsInJheWNhc3RfbDEiLCJyYXljYXN0X3VuaXRfeSIsImludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb20iLCJpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdCIsImludGVyc2VjdFBsYW5lX2hpdFBvaW50IiwiaW50ZXJzZWN0UGxhbmVfbm9ybWFsIiwiaW50ZXJzZWN0UGxhbmVfbGVuIiwicGxhbmVQb2ludFRvRnJvbSIsImRpcl9zY2FsZWRfd2l0aF90IiwiaGl0UG9pbnQiLCJwbGFuZVRvRnJvbSIsInBsYW5lVG9UbyIsIm5fZG90X2RpciIsIm1hdGVyaWFsIiwic2Vuc29yIiwiR1MiLCJpdGVyYXRpb25zIiwidG9sZXJhbmNlIiwiYXJyYXlTdGVwIiwibGFtYmRhIiwiQnMiLCJpbnZDcyIsInVzZVplcm9SSFMiLCJmcmljdGlvbkl0ZXJhdGlvbnMiLCJ1c2VkSXRlcmF0aW9ucyIsInNldEFycmF5WmVybyIsImFycmF5Iiwic29sdmUiLCJzb3J0RXF1YXRpb25zIiwibWF4SXRlciIsIm1heEZyaWN0aW9uSXRlciIsIk5lcSIsInRvbFNxdWFyZWQiLCJOYm9kaWVzIiwicSIsImRlbHRhbGFtYmRhVG90IiwiaXRlcmF0ZUVxdWF0aW9uIiwidXBkYXRlTXVsdGlwbGllcnMiLCJpbnZEdCIsImludkMiLCJsYW1iZGFqIiwiR1dsYW1iZGEiLCJsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEiLCJlcXVhdGlvblNvcnRGdW5jdGlvbiIsIm1vY2tXb3JsZCIsInNvbHZlSXNsYW5kIiwiaXNsYW5kIiwicmVtb3ZlQWxsRXF1YXRpb25zIiwiYWRkRXF1YXRpb25zIiwiZ2V0Qm9kaWVzIiwic29ydCIsImFkZEVxdWF0aW9uIiwicmVtb3ZlRXF1YXRpb24iLCJJU0xBTkQiLCJkZXN0cm95IiwiZXF1YXRpb24iLCJJc2xhbmROb2RlIiwiSXNsYW5kTm9kZVBvb2wiLCJub2RlIiwiSXNsYW5kIiwiSXNsYW5kUG9vbCIsIk92ZXJsYXBLZWVwZXJSZWNvcmQiLCJPdmVybGFwS2VlcGVyUmVjb3JkUG9vbCIsIk92ZXJsYXBLZWVwZXIiLCJvdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSIsIm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlIiwicmVjb3JkUG9vbCIsInRtcERpY3QiLCJ0bXBBcnJheTEiLCJ0aWNrIiwiY3VycmVudCIsImtleXMiLCJsYXN0T2JqZWN0IiwiZ2V0QnlLZXkiLCJjdXJyZW50T2JqZWN0Iiwic2V0T3ZlcmxhcHBpbmciLCJnZXROZXdPdmVybGFwcyIsImdldERpZmYiLCJnZXRFbmRPdmVybGFwcyIsImRpY3RBIiwiZGljdEIiLCJsYXN0RGF0YSIsImlzTmV3T3ZlcmxhcCIsImlkQSIsImlkQiIsImdldE5ld0JvZHlPdmVybGFwcyIsImdldEJvZHlEaWZmIiwiZ2V0RW5kQm9keU92ZXJsYXBzIiwiYWNjdW11bGF0b3IiLCJyZWNvcmQiLCJvYmplY3RzIiwicmVzaXplIiwib2JqZWN0IiwiZ2V0S2V5IiwiZGljdCIsImhvd21hbnkiLCJQMl9BUlJBWV9UWVBFIiwiRmxvYXQzMkFycmF5IiwiYm9keUlkcyIsIklzbGFuZE1hbmFnZXIiLCJub2RlUG9vbCIsImlzbGFuZFBvb2wiLCJpc2xhbmRzIiwibm9kZXMiLCJxdWV1ZSIsImdldFVudmlzaXRlZE5vZGUiLCJObm9kZXMiLCJ2aXNpdGVkIiwidmlzaXQiLCJiZHMiLCJOZXFzIiwiYmZzIiwicm9vdCIsImNoaWxkIiwibmVpZ2hib3JzIiwic3BsaXQiLCJuaSIsIm5qIiwicGtnIiwic3ByaW5ncyIsImRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzIiwic29sdmVyIiwiaXNsYW5kTWFuYWdlciIsImdyYXZpdHkiLCJmcmljdGlvbkdyYXZpdHkiLCJ1c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eSIsInVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkiLCJicm9hZHBoYXNlIiwiY29uc3RyYWludHMiLCJkZWZhdWx0TWF0ZXJpYWwiLCJkZWZhdWx0Q29udGFjdE1hdGVyaWFsIiwibGFzdFRpbWVTdGVwIiwiYXBwbHlTcHJpbmdGb3JjZXMiLCJhcHBseUdyYXZpdHkiLCJzb2x2ZUNvbnN0cmFpbnRzIiwiY29udGFjdE1hdGVyaWFscyIsInN0ZXBwaW5nIiwiYm9kaWVzVG9CZVJlbW92ZWQiLCJpc2xhbmRTcGxpdCIsImVtaXRJbXBhY3RFdmVudCIsIl9jb25zdHJhaW50SWRDb3VudGVyIiwiX2JvZHlJZENvdW50ZXIiLCJwb3N0U3RlcEV2ZW50IiwiYWRkQm9keUV2ZW50IiwicmVtb3ZlQm9keUV2ZW50IiwiYWRkU3ByaW5nRXZlbnQiLCJzcHJpbmciLCJpbXBhY3RFdmVudCIsImNvbnRhY3RFcXVhdGlvbiIsInBvc3RCcm9hZHBoYXNlRXZlbnQiLCJwYWlycyIsInNsZWVwTW9kZSIsIk5PX1NMRUVQSU5HIiwiYmVnaW5Db250YWN0RXZlbnQiLCJlbmRDb250YWN0RXZlbnQiLCJwcmVTb2x2ZUV2ZW50IiwiQk9EWV9TTEVFUElORyIsIklTTEFORF9TTEVFUElORyIsImNvbnN0cmFpbnQiLCJhZGRDb250YWN0TWF0ZXJpYWwiLCJjb250YWN0TWF0ZXJpYWwiLCJyZW1vdmVDb250YWN0TWF0ZXJpYWwiLCJnZXRDb250YWN0TWF0ZXJpYWwiLCJjbWF0cyIsInN0ZXBfciIsInN0ZXBfcnVuaXQiLCJzdGVwX3UiLCJzdGVwX2YiLCJzdGVwX2ZoTWludiIsInN0ZXBfdmVsb2R0Iiwic3RlcF9tZyIsInhpdyIsInhqdyIsInplcm8iLCJpbnRlcnB2ZWxvIiwic3RlcCIsInRpbWVTaW5jZUxhc3RDYWxsZWQiLCJtYXhTdWJTdGVwcyIsImludGVybmFsU3RlcCIsInN1YnN0ZXBzIiwiZW5kT3ZlcmxhcHMiLCJOc3ByaW5ncyIsIm5wIiwidDAiLCJmaE1pbnYiLCJ2ZWxvZHQiLCJtZyIsImdyYXZpdHlMZW4iLCJpZ25vcmVkUGFpcnMiLCJOY29uc3RyYWludHMiLCJOcmVzdWx0cyIsInJ1bk5hcnJvd3BoYXNlIiwiZXYiLCJnbGVuIiwiYWl3IiwiYWp3IiwicmVkdWNlZE1hc3MiLCJyZXNvbHZlciIsIm51bUZyaWN0aW9uQmVmb3JlIiwibnVtRnJpY3Rpb25FcXVhdGlvbnMiLCJzcGVlZFNxdWFyZWRCIiwic3BlZWRMaW1pdFNxdWFyZWRCIiwic3BlZWRTcXVhcmVkQSIsInNwZWVkTGltaXRTcXVhcmVkQSIsImFkZFNwcmluZyIsImV2dCIsInJlbW92ZVNwcmluZyIsImdldEJvZHlCeUlkIiwiZGlzYWJsZUJvZHlDb2xsaXNpb24iLCJlbmFibGVCb2R5Q29sbGlzaW9uIiwiY3MiLCJjbXMiLCJoaXRUZXN0X3RtcDEiLCJoaXRUZXN0X3plcm8iLCJoaXRUZXN0X3RtcDIiLCJoaXRUZXN0IiwicGIiLCJwcyIsInBhIiwiTlMiLCJzZXRHbG9iYWxTdGlmZm5lc3MiLCJz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