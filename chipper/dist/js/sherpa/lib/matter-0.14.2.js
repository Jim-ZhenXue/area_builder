/**
* matter-js 0.14.2 by @liabru 2018-06-11
* http://brm.io/matter-js/
* License MIT
*/ /**
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */ (function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }
        g.Matter = f();
    }
})(function() {
    var define1, module1, exports1;
    return (function() {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a;
                    }
                    var p = n[i] = {
                        exports: {}
                    };
                    e[i][0].call(p.exports, function(r) {
                        var n = e[i][1][r];
                        return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }
                return n[i].exports;
            }
            for(var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]);
            return o;
        }
        return r;
    })()({
        1: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/ var Body = {};
                module1.exports = Body;
                var Vertices = _dereq_('../geometry/Vertices');
                var Vector = _dereq_('../geometry/Vector');
                var Sleeping = _dereq_('../core/Sleeping');
                var Render = _dereq_('../render/Render');
                var Common = _dereq_('../core/Common');
                var Bounds = _dereq_('../geometry/Bounds');
                var Axes = _dereq_('../geometry/Axes');
                (function() {
                    Body._inertiaScale = 4;
                    Body._nextCollidingGroupId = 1;
                    Body._nextNonCollidingGroupId = -1;
                    Body._nextCategory = 0x0001;
                    /**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */ Body.create = function(options) {
                        var defaults = {
                            id: Common.nextId(),
                            type: 'body',
                            label: 'Body',
                            parts: [],
                            plugin: {},
                            angle: 0,
                            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
                            position: {
                                x: 0,
                                y: 0
                            },
                            force: {
                                x: 0,
                                y: 0
                            },
                            torque: 0,
                            positionImpulse: {
                                x: 0,
                                y: 0
                            },
                            constraintImpulse: {
                                x: 0,
                                y: 0,
                                angle: 0
                            },
                            totalContacts: 0,
                            speed: 0,
                            angularSpeed: 0,
                            velocity: {
                                x: 0,
                                y: 0
                            },
                            angularVelocity: 0,
                            isSensor: false,
                            isStatic: false,
                            isSleeping: false,
                            motion: 0,
                            sleepThreshold: 60,
                            density: 0.001,
                            restitution: 0,
                            friction: 0.1,
                            frictionStatic: 0.5,
                            frictionAir: 0.01,
                            collisionFilter: {
                                category: 0x0001,
                                mask: 0xFFFFFFFF,
                                group: 0
                            },
                            slop: 0.05,
                            timeScale: 1,
                            render: {
                                visible: true,
                                opacity: 1,
                                sprite: {
                                    xScale: 1,
                                    yScale: 1,
                                    xOffset: 0,
                                    yOffset: 0
                                },
                                lineWidth: 0
                            }
                        };
                        var body = Common.extend(defaults, options);
                        _initProperties(body, options);
                        return body;
                    };
                    /**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */ Body.nextGroup = function(isNonColliding) {
                        if (isNonColliding) return Body._nextNonCollidingGroupId--;
                        return Body._nextCollidingGroupId++;
                    };
                    /**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */ Body.nextCategory = function() {
                        Body._nextCategory = Body._nextCategory << 1;
                        return Body._nextCategory;
                    };
                    /**
     * Initialises body properties.
     * @method _initProperties
     * @private
     * @param {body} body
     * @param {} [options]
     */ var _initProperties = function(body, options) {
                        options = options || {};
                        // init required properties (order is important)
                        Body.set(body, {
                            bounds: body.bounds || Bounds.create(body.vertices),
                            positionPrev: body.positionPrev || Vector.clone(body.position),
                            anglePrev: body.anglePrev || body.angle,
                            vertices: body.vertices,
                            parts: body.parts || [
                                body
                            ],
                            isStatic: body.isStatic,
                            isSleeping: body.isSleeping,
                            parent: body.parent || body
                        });
                        Vertices.rotate(body.vertices, body.angle, body.position);
                        Axes.rotate(body.axes, body.angle);
                        Bounds.update(body.bounds, body.vertices, body.velocity);
                        // allow options to override the automatically calculated properties
                        Body.set(body, {
                            axes: options.axes || body.axes,
                            area: options.area || body.area,
                            mass: options.mass || body.mass,
                            inertia: options.inertia || body.inertia
                        });
                        // render properties
                        var defaultFillStyle = body.isStatic ? '#2e2b44' : Common.choose([
                            '#006BA6',
                            '#0496FF',
                            '#FFBC42',
                            '#D81159',
                            '#8F2D56'
                        ]), defaultStrokeStyle = '#000';
                        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
                        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
                        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
                        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
                    };
                    /**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */ Body.set = function(body, settings, value) {
                        var property;
                        if (typeof settings === 'string') {
                            property = settings;
                            settings = {};
                            settings[property] = value;
                        }
                        for(property in settings){
                            value = settings[property];
                            if (!settings.hasOwnProperty(property)) continue;
                            switch(property){
                                case 'isStatic':
                                    Body.setStatic(body, value);
                                    break;
                                case 'isSleeping':
                                    Sleeping.set(body, value);
                                    break;
                                case 'mass':
                                    Body.setMass(body, value);
                                    break;
                                case 'density':
                                    Body.setDensity(body, value);
                                    break;
                                case 'inertia':
                                    Body.setInertia(body, value);
                                    break;
                                case 'vertices':
                                    Body.setVertices(body, value);
                                    break;
                                case 'position':
                                    Body.setPosition(body, value);
                                    break;
                                case 'angle':
                                    Body.setAngle(body, value);
                                    break;
                                case 'velocity':
                                    Body.setVelocity(body, value);
                                    break;
                                case 'angularVelocity':
                                    Body.setAngularVelocity(body, value);
                                    break;
                                case 'parts':
                                    Body.setParts(body, value);
                                    break;
                                default:
                                    body[property] = value;
                            }
                        }
                    };
                    /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */ Body.setStatic = function(body, isStatic) {
                        for(var i = 0; i < body.parts.length; i++){
                            var part = body.parts[i];
                            part.isStatic = isStatic;
                            if (isStatic) {
                                part._original = {
                                    restitution: part.restitution,
                                    friction: part.friction,
                                    mass: part.mass,
                                    inertia: part.inertia,
                                    density: part.density,
                                    inverseMass: part.inverseMass,
                                    inverseInertia: part.inverseInertia
                                };
                                part.restitution = 0;
                                part.friction = 1;
                                part.mass = part.inertia = part.density = Infinity;
                                part.inverseMass = part.inverseInertia = 0;
                                part.positionPrev.x = part.position.x;
                                part.positionPrev.y = part.position.y;
                                part.anglePrev = part.angle;
                                part.angularVelocity = 0;
                                part.speed = 0;
                                part.angularSpeed = 0;
                                part.motion = 0;
                            } else if (part._original) {
                                part.restitution = part._original.restitution;
                                part.friction = part._original.friction;
                                part.mass = part._original.mass;
                                part.inertia = part._original.inertia;
                                part.density = part._original.density;
                                part.inverseMass = part._original.inverseMass;
                                part.inverseInertia = part._original.inverseInertia;
                                delete part._original;
                            }
                        }
                    };
                    /**
     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */ Body.setMass = function(body, mass) {
                        var moment = body.inertia / (body.mass / 6);
                        body.inertia = moment * (mass / 6);
                        body.inverseInertia = 1 / body.inertia;
                        body.mass = mass;
                        body.inverseMass = 1 / body.mass;
                        body.density = body.mass / body.area;
                    };
                    /**
     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */ Body.setDensity = function(body, density) {
                        Body.setMass(body, density * body.area);
                        body.density = density;
                    };
                    /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */ Body.setInertia = function(body, inertia) {
                        body.inertia = inertia;
                        body.inverseInertia = 1 / body.inertia;
                    };
                    /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */ Body.setVertices = function(body, vertices) {
                        // change vertices
                        if (vertices[0].body === body) {
                            body.vertices = vertices;
                        } else {
                            body.vertices = Vertices.create(vertices, body);
                        }
                        // update properties
                        body.axes = Axes.fromVertices(body.vertices);
                        body.area = Vertices.area(body.vertices);
                        Body.setMass(body, body.density * body.area);
                        // orient vertices around the centre of mass at origin (0, 0)
                        var centre = Vertices.centre(body.vertices);
                        Vertices.translate(body.vertices, centre, -1);
                        // update inertia while vertices are at origin (0, 0)
                        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
                        // update geometry
                        Vertices.translate(body.vertices, body.position);
                        Bounds.update(body.bounds, body.vertices, body.velocity);
                    };
                    /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */ Body.setParts = function(body, parts, autoHull) {
                        var i;
                        // add all the parts, ensuring that the first part is always the parent body
                        parts = parts.slice(0);
                        body.parts.length = 0;
                        body.parts.push(body);
                        body.parent = body;
                        for(i = 0; i < parts.length; i++){
                            var part = parts[i];
                            if (part !== body) {
                                part.parent = body;
                                body.parts.push(part);
                            }
                        }
                        if (body.parts.length === 1) return;
                        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;
                        // find the convex hull of all parts to set on the parent body
                        if (autoHull) {
                            var vertices = [];
                            for(i = 0; i < parts.length; i++){
                                vertices = vertices.concat(parts[i].vertices);
                            }
                            Vertices.clockwiseSort(vertices);
                            var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
                            Body.setVertices(body, hull);
                            Vertices.translate(body.vertices, hullCentre);
                        }
                        // sum the properties of all compound parts of the parent body
                        var total = Body._totalProperties(body);
                        body.area = total.area;
                        body.parent = body;
                        body.position.x = total.centre.x;
                        body.position.y = total.centre.y;
                        body.positionPrev.x = total.centre.x;
                        body.positionPrev.y = total.centre.y;
                        Body.setMass(body, total.mass);
                        Body.setInertia(body, total.inertia);
                        Body.setPosition(body, total.centre);
                    };
                    /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */ Body.setPosition = function(body, position) {
                        var delta = Vector.sub(position, body.position);
                        body.positionPrev.x += delta.x;
                        body.positionPrev.y += delta.y;
                        for(var i = 0; i < body.parts.length; i++){
                            var part = body.parts[i];
                            part.position.x += delta.x;
                            part.position.y += delta.y;
                            Vertices.translate(part.vertices, delta);
                            Bounds.update(part.bounds, part.vertices, body.velocity);
                        }
                    };
                    /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */ Body.setAngle = function(body, angle) {
                        var delta = angle - body.angle;
                        body.anglePrev += delta;
                        for(var i = 0; i < body.parts.length; i++){
                            var part = body.parts[i];
                            part.angle += delta;
                            Vertices.rotate(part.vertices, delta, body.position);
                            Axes.rotate(part.axes, delta);
                            Bounds.update(part.bounds, part.vertices, body.velocity);
                            if (i > 0) {
                                Vector.rotateAbout(part.position, delta, body.position, part.position);
                            }
                        }
                    };
                    /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */ Body.setVelocity = function(body, velocity) {
                        body.positionPrev.x = body.position.x - velocity.x;
                        body.positionPrev.y = body.position.y - velocity.y;
                        body.velocity.x = velocity.x;
                        body.velocity.y = velocity.y;
                        body.speed = Vector.magnitude(body.velocity);
                    };
                    /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */ Body.setAngularVelocity = function(body, velocity) {
                        body.anglePrev = body.angle - velocity;
                        body.angularVelocity = velocity;
                        body.angularSpeed = Math.abs(body.angularVelocity);
                    };
                    /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */ Body.translate = function(body, translation) {
                        Body.setPosition(body, Vector.add(body.position, translation));
                    };
                    /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     * @param {vector} [point]
     */ Body.rotate = function(body, rotation, point) {
                        if (!point) {
                            Body.setAngle(body, body.angle + rotation);
                        } else {
                            var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
                            Body.setPosition(body, {
                                x: point.x + (dx * cos - dy * sin),
                                y: point.y + (dx * sin + dy * cos)
                            });
                            Body.setAngle(body, body.angle + rotation);
                        }
                    };
                    /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */ Body.scale = function(body, scaleX, scaleY, point) {
                        var totalArea = 0, totalInertia = 0;
                        point = point || body.position;
                        for(var i = 0; i < body.parts.length; i++){
                            var part = body.parts[i];
                            // scale vertices
                            Vertices.scale(part.vertices, scaleX, scaleY, point);
                            // update properties
                            part.axes = Axes.fromVertices(part.vertices);
                            part.area = Vertices.area(part.vertices);
                            Body.setMass(part, body.density * part.area);
                            // update inertia (requires vertices to be at origin)
                            Vertices.translate(part.vertices, {
                                x: -part.position.x,
                                y: -part.position.y
                            });
                            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
                            Vertices.translate(part.vertices, {
                                x: part.position.x,
                                y: part.position.y
                            });
                            if (i > 0) {
                                totalArea += part.area;
                                totalInertia += part.inertia;
                            }
                            // scale position
                            part.position.x = point.x + (part.position.x - point.x) * scaleX;
                            part.position.y = point.y + (part.position.y - point.y) * scaleY;
                            // update bounds
                            Bounds.update(part.bounds, part.vertices, body.velocity);
                        }
                        // handle parent body
                        if (body.parts.length > 1) {
                            body.area = totalArea;
                            if (!body.isStatic) {
                                Body.setMass(body, body.density * totalArea);
                                Body.setInertia(body, totalInertia);
                            }
                        }
                        // handle circles
                        if (body.circleRadius) {
                            if (scaleX === scaleY) {
                                body.circleRadius *= scaleX;
                            } else {
                                // body is no longer a circle
                                body.circleRadius = null;
                            }
                        }
                    };
                    /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */ Body.update = function(body, deltaTime, timeScale, correction) {
                        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);
                        // from the previous step
                        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale, velocityPrevX = body.position.x - body.positionPrev.x, velocityPrevY = body.position.y - body.positionPrev.y;
                        // update velocity with Verlet integration
                        body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;
                        body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;
                        body.positionPrev.x = body.position.x;
                        body.positionPrev.y = body.position.y;
                        body.position.x += body.velocity.x;
                        body.position.y += body.velocity.y;
                        // update angular velocity with Verlet integration
                        body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
                        body.anglePrev = body.angle;
                        body.angle += body.angularVelocity;
                        // track speed and acceleration
                        body.speed = Vector.magnitude(body.velocity);
                        body.angularSpeed = Math.abs(body.angularVelocity);
                        // transform the body geometry
                        for(var i = 0; i < body.parts.length; i++){
                            var part = body.parts[i];
                            Vertices.translate(part.vertices, body.velocity);
                            if (i > 0) {
                                part.position.x += body.velocity.x;
                                part.position.y += body.velocity.y;
                            }
                            if (body.angularVelocity !== 0) {
                                Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                                Axes.rotate(part.axes, body.angularVelocity);
                                if (i > 0) {
                                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                                }
                            }
                            Bounds.update(part.bounds, part.vertices, body.velocity);
                        }
                    };
                    /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */ Body.applyForce = function(body, position, force) {
                        body.force.x += force.x;
                        body.force.y += force.y;
                        var offset = {
                            x: position.x - body.position.x,
                            y: position.y - body.position.y
                        };
                        body.torque += offset.x * force.y - offset.y * force.x;
                    };
                    /**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */ Body._totalProperties = function(body) {
                        // from equations at:
                        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
                        // http://output.to/sideway/default.asp?qno=121100087
                        var properties = {
                            mass: 0,
                            area: 0,
                            inertia: 0,
                            centre: {
                                x: 0,
                                y: 0
                            }
                        };
                        // sum the properties of all compound parts of the parent body
                        for(var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++){
                            var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;
                            properties.mass += mass;
                            properties.area += part.area;
                            properties.inertia += part.inertia;
                            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
                        }
                        properties.centre = Vector.div(properties.centre, properties.mass);
                        return properties;
                    };
                /*
    *
    *  Events Documentation
    *
    */ /**
    * Fired when a body starts sleeping (where `this` is the body).
    *
    * @event sleepStart
    * @this {body} The body that has started sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when a body ends sleeping (where `this` is the body).
    *
    * @event sleepEnd
    * @this {body} The body that has ended sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */ /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "body"
     * @readOnly
     */ /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Body"
     */ /**
     * An array of bodies that make up this body. 
     * The first body in the array must always be a self reference to the current body instance.
     * All bodies in the `parts` array together form a single rigid compound body.
     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
     * Parts themselves should never be added to a `World`, only the parent body should be.
     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
     *
     * @property parts
     * @type body[]
     */ /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */ /**
     * A self reference if the body is _not_ a part of another body.
     * Otherwise this is a reference to the body that this is a part of.
     * See `body.parts`.
     *
     * @property parent
     * @type body
     */ /**
     * A `Number` specifying the angle of the body, in radians.
     *
     * @property angle
     * @type number
     * @default 0
     */ /**
     * An array of `Vector` objects that specify the convex hull of the rigid body.
     * These should be provided about the origin `(0, 0)`. E.g.
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. 
     *
     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
     *
     * @property vertices
     * @type vector[]
     */ /**
     * A `Vector` that specifies the current world-space position of the body.
     *
     * @property position
     * @type vector
     * @default { x: 0, y: 0 }
     */ /**
     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
     *
     * @property force
     * @type vector
     * @default { x: 0, y: 0 }
     */ /**
     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
     *
     * @property torque
     * @type number
     * @default 0
     */ /**
     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
     *
     * @readOnly
     * @property speed
     * @type number
     * @default 0
     */ /**
     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
     *
     * @readOnly
     * @property angularSpeed
     * @type number
     * @default 0
     */ /**
     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property velocity
     * @type vector
     * @default { x: 0, y: 0 }
     */ /**
     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property angularVelocity
     * @type number
     * @default 0
     */ /**
     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
     *
     * @property isStatic
     * @type boolean
     * @default false
     */ /**
     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
     *
     * @property isSensor
     * @type boolean
     * @default false
     */ /**
     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
     *
     * @property isSleeping
     * @type boolean
     * @default false
     */ /**
     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
     *
     * @readOnly
     * @property motion
     * @type number
     * @default 0
     */ /**
     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
     *
     * @property sleepThreshold
     * @type number
     * @default 60
     */ /**
     * A `Number` that defines the density of the body, that is its mass per unit area.
     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
     *
     * @property density
     * @type number
     * @default 0.001
     */ /**
     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
     *
     * @property mass
     * @type number
     */ /**
     * A `Number` that defines the inverse mass of the body (`1 / mass`).
     * If you modify this value, you must also modify the `body.mass` property.
     *
     * @property inverseMass
     * @type number
     */ /**
     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
     *
     * @property inertia
     * @type number
     */ /**
     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
     * If you modify this value, you must also modify the `body.inertia` property.
     *
     * @property inverseInertia
     * @type number
     */ /**
     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. 
     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:
     *
     *     Math.max(bodyA.restitution, bodyB.restitution)
     *
     * @property restitution
     * @type number
     * @default 0
     */ /**
     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means that the body may slide indefinitely.
     * A value of `1` means the body may come to a stop almost instantly after a force is applied.
     *
     * The effects of the value may be non-linear. 
     * High values may be unstable depending on the body.
     * The engine uses a Coulomb friction model including static and kinetic friction.
     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:
     *
     *     Math.min(bodyA.friction, bodyB.friction)
     *
     * @property friction
     * @type number
     * @default 0.1
     */ /**
     * A `Number` that defines the static friction of the body (in the Coulomb friction model). 
     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
     *
     * @property frictionStatic
     * @type number
     * @default 0.5
     */ /**
     * A `Number` that defines the air friction of the body (air resistance). 
     * A value of `0` means the body will never slow as it moves through space.
     * The higher the value, the faster a body slows when moving through space.
     * The effects of the value are non-linear. 
     *
     * @property frictionAir
     * @type number
     * @default 0.01
     */ /**
     * An `Object` that specifies the collision filtering properties of this body.
     *
     * Collisions between two bodies will obey the following rules:
     * - If the two bodies have the same non-zero value of `collisionFilter.group`,
     *   they will always collide if the value is positive, and they will never collide
     *   if the value is negative.
     * - If the two bodies have different values of `collisionFilter.group` or if one
     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:
     *
     * Each body belongs to a collision category, given by `collisionFilter.category`. This
     * value is used as a bit field and the category should have only one bit set, meaning that
     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
     * different collision categories available.
     *
     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
     * the categories it collides with (the value is the bitwise AND value of all these categories).
     *
     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
     * are both true.
     *
     * @property collisionFilter
     * @type object
     */ /**
     * An Integer `Number`, that specifies the collision group this body belongs to.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.group
     * @type object
     * @default 0
     */ /**
     * A bit field that specifies the collision category this body belongs to.
     * The category value should have only one bit set, for example `0x0001`.
     * This means there are up to 32 unique collision categories available.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.category
     * @type object
     * @default 1
     */ /**
     * A bit mask that specifies the collision categories this body may collide with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.mask
     * @type object
     * @default -1
     */ /**
     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
     * The default should generally suffice, although very large bodies may require larger values for stable stacking.
     *
     * @property slop
     * @type number
     * @default 0.05
     */ /**
     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
     *
     * @property timeScale
     * @type number
     * @default 1
     */ /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */ /**
     * A flag that indicates if the body should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */ /**
     * Sets the opacity to use when rendering.
     *
     * @property render.opacity
     * @type number
     * @default 1
    */ /**
     * An `Object` that defines the sprite properties to use when rendering, if any.
     *
     * @property render.sprite
     * @type object
     */ /**
     * An `String` that defines the path to the image to use as the sprite texture, if any.
     *
     * @property render.sprite.texture
     * @type string
     */ /**
     * A `Number` that defines the scaling in the x-axis for the sprite, if any.
     *
     * @property render.sprite.xScale
     * @type number
     * @default 1
     */ /**
     * A `Number` that defines the scaling in the y-axis for the sprite, if any.
     *
     * @property render.sprite.yScale
     * @type number
     * @default 1
     */ /**
      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
      *
      * @property render.sprite.xOffset
      * @type number
      * @default 0
      */ /**
      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
      *
      * @property render.sprite.yOffset
      * @type number
      * @default 0
      */ /**
     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 0
     */ /**
     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.fillStyle
     * @type string
     * @default a random colour
     */ /**
     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */ /**
     * An array of unique axis vectors (edge normals) used for collision detection.
     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
     * They are constantly updated by `Body.update` during the simulation.
     *
     * @property axes
     * @type vector[]
     */ /**
     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
     *
     * @property area
     * @type string
     * @default 
     */ /**
     * A `Bounds` object that defines the AABB region for the body.
     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
     *
     * @property bounds
     * @type bounds
     */ })();
            },
            {
                "../core/Common": 14,
                "../core/Sleeping": 22,
                "../geometry/Axes": 25,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29,
                "../render/Render": 31
            }
        ],
        2: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/ var Composite = {};
                module1.exports = Composite;
                var Events = _dereq_('../core/Events');
                var Common = _dereq_('../core/Common');
                var Bounds = _dereq_('../geometry/Bounds');
                var Body = _dereq_('./Body');
                (function() {
                    /**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */ Composite.create = function(options) {
                        return Common.extend({
                            id: Common.nextId(),
                            type: 'composite',
                            parent: null,
                            isModified: false,
                            bodies: [],
                            constraints: [],
                            composites: [],
                            label: 'Composite',
                            plugin: {}
                        }, options);
                    };
                    /**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */ Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
                        composite.isModified = isModified;
                        if (updateParents && composite.parent) {
                            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
                        }
                        if (updateChildren) {
                            for(var i = 0; i < composite.composites.length; i++){
                                var childComposite = composite.composites[i];
                                Composite.setModified(childComposite, isModified, updateParents, updateChildren);
                            }
                        }
                    };
                    /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */ Composite.add = function(composite, object) {
                        var objects = [].concat(object);
                        Events.trigger(composite, 'beforeAdd', {
                            object: object
                        });
                        for(var i = 0; i < objects.length; i++){
                            var obj = objects[i];
                            switch(obj.type){
                                case 'body':
                                    // skip adding compound parts
                                    if (obj.parent !== obj) {
                                        Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');
                                        break;
                                    }
                                    Composite.addBody(composite, obj);
                                    break;
                                case 'constraint':
                                    Composite.addConstraint(composite, obj);
                                    break;
                                case 'composite':
                                    Composite.addComposite(composite, obj);
                                    break;
                                case 'mouseConstraint':
                                    Composite.addConstraint(composite, obj.constraint);
                                    break;
                            }
                        }
                        Events.trigger(composite, 'afterAdd', {
                            object: object
                        });
                        return composite;
                    };
                    /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */ Composite.remove = function(composite, object, deep) {
                        var objects = [].concat(object);
                        Events.trigger(composite, 'beforeRemove', {
                            object: object
                        });
                        for(var i = 0; i < objects.length; i++){
                            var obj = objects[i];
                            switch(obj.type){
                                case 'body':
                                    Composite.removeBody(composite, obj, deep);
                                    break;
                                case 'constraint':
                                    Composite.removeConstraint(composite, obj, deep);
                                    break;
                                case 'composite':
                                    Composite.removeComposite(composite, obj, deep);
                                    break;
                                case 'mouseConstraint':
                                    Composite.removeConstraint(composite, obj.constraint);
                                    break;
                            }
                        }
                        Events.trigger(composite, 'afterRemove', {
                            object: object
                        });
                        return composite;
                    };
                    /**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */ Composite.addComposite = function(compositeA, compositeB) {
                        compositeA.composites.push(compositeB);
                        compositeB.parent = compositeA;
                        Composite.setModified(compositeA, true, true, false);
                        return compositeA;
                    };
                    /**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */ Composite.removeComposite = function(compositeA, compositeB, deep) {
                        var position = Common.indexOf(compositeA.composites, compositeB);
                        if (position !== -1) {
                            Composite.removeCompositeAt(compositeA, position);
                            Composite.setModified(compositeA, true, true, false);
                        }
                        if (deep) {
                            for(var i = 0; i < compositeA.composites.length; i++){
                                Composite.removeComposite(compositeA.composites[i], compositeB, true);
                            }
                        }
                        return compositeA;
                    };
                    /**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */ Composite.removeCompositeAt = function(composite, position) {
                        composite.composites.splice(position, 1);
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */ Composite.addBody = function(composite, body) {
                        composite.bodies.push(body);
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */ Composite.removeBody = function(composite, body, deep) {
                        var position = Common.indexOf(composite.bodies, body);
                        if (position !== -1) {
                            Composite.removeBodyAt(composite, position);
                            Composite.setModified(composite, true, true, false);
                        }
                        if (deep) {
                            for(var i = 0; i < composite.composites.length; i++){
                                Composite.removeBody(composite.composites[i], body, true);
                            }
                        }
                        return composite;
                    };
                    /**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */ Composite.removeBodyAt = function(composite, position) {
                        composite.bodies.splice(position, 1);
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */ Composite.addConstraint = function(composite, constraint) {
                        composite.constraints.push(constraint);
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */ Composite.removeConstraint = function(composite, constraint, deep) {
                        var position = Common.indexOf(composite.constraints, constraint);
                        if (position !== -1) {
                            Composite.removeConstraintAt(composite, position);
                        }
                        if (deep) {
                            for(var i = 0; i < composite.composites.length; i++){
                                Composite.removeConstraint(composite.composites[i], constraint, true);
                            }
                        }
                        return composite;
                    };
                    /**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */ Composite.removeConstraintAt = function(composite, position) {
                        composite.constraints.splice(position, 1);
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */ Composite.clear = function(composite, keepStatic, deep) {
                        if (deep) {
                            for(var i = 0; i < composite.composites.length; i++){
                                Composite.clear(composite.composites[i], keepStatic, true);
                            }
                        }
                        if (keepStatic) {
                            composite.bodies = composite.bodies.filter(function(body) {
                                return body.isStatic;
                            });
                        } else {
                            composite.bodies.length = 0;
                        }
                        composite.constraints.length = 0;
                        composite.composites.length = 0;
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */ Composite.allBodies = function(composite) {
                        var bodies = [].concat(composite.bodies);
                        for(var i = 0; i < composite.composites.length; i++)bodies = bodies.concat(Composite.allBodies(composite.composites[i]));
                        return bodies;
                    };
                    /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */ Composite.allConstraints = function(composite) {
                        var constraints = [].concat(composite.constraints);
                        for(var i = 0; i < composite.composites.length; i++)constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));
                        return constraints;
                    };
                    /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */ Composite.allComposites = function(composite) {
                        var composites = [].concat(composite.composites);
                        for(var i = 0; i < composite.composites.length; i++)composites = composites.concat(Composite.allComposites(composite.composites[i]));
                        return composites;
                    };
                    /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */ Composite.get = function(composite, id, type) {
                        var objects, object;
                        switch(type){
                            case 'body':
                                objects = Composite.allBodies(composite);
                                break;
                            case 'constraint':
                                objects = Composite.allConstraints(composite);
                                break;
                            case 'composite':
                                objects = Composite.allComposites(composite).concat(composite);
                                break;
                        }
                        if (!objects) return null;
                        object = objects.filter(function(object) {
                            return object.id.toString() === id.toString();
                        });
                        return object.length === 0 ? null : object[0];
                    };
                    /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */ Composite.move = function(compositeA, objects, compositeB) {
                        Composite.remove(compositeA, objects);
                        Composite.add(compositeB, objects);
                        return compositeA;
                    };
                    /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */ Composite.rebase = function(composite) {
                        var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
                        for(var i = 0; i < objects.length; i++){
                            objects[i].id = Common.nextId();
                        }
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */ Composite.translate = function(composite, translation, recursive) {
                        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
                        for(var i = 0; i < bodies.length; i++){
                            Body.translate(bodies[i], translation);
                        }
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */ Composite.rotate = function(composite, rotation, point, recursive) {
                        var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                            Body.setPosition(body, {
                                x: point.x + (dx * cos - dy * sin),
                                y: point.y + (dx * sin + dy * cos)
                            });
                            Body.rotate(body, rotation);
                        }
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */ Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
                        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                            Body.setPosition(body, {
                                x: point.x + dx * scaleX,
                                y: point.y + dy * scaleY
                            });
                            Body.scale(body, scaleX, scaleY);
                        }
                        Composite.setModified(composite, true, true, false);
                        return composite;
                    };
                    /**
     * Returns the union of the bounds of all of the composite's bodies.
     * @method bounds
     * @param {composite} composite The composite.
     * @returns {bounds} The composite bounds.
     */ Composite.bounds = function(composite) {
                        var bodies = Composite.allBodies(composite), vertices = [];
                        for(var i = 0; i < bodies.length; i += 1){
                            var body = bodies[i];
                            vertices.push(body.bounds.min, body.bounds.max);
                        }
                        return Bounds.create(vertices);
                    };
                /*
    *
    *  Events Documentation
    *
    */ /**
    * Fired when a call to `Composite.add` is made, before objects have been added.
    *
    * @event beforeAdd
    * @param {} event An event object
    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when a call to `Composite.add` is made, after objects have been added.
    *
    * @event afterAdd
    * @param {} event An event object
    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when a call to `Composite.remove` is made, before objects have been removed.
    *
    * @event beforeRemove
    * @param {} event An event object
    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when a call to `Composite.remove` is made, after objects have been removed.
    *
    * @event afterRemove
    * @param {} event An event object
    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */ /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "composite"
     * @readOnly
     */ /**
     * An arbitrary `String` name to help the user identify and manage composites.
     *
     * @property label
     * @type string
     * @default "Composite"
     */ /**
     * A flag that specifies whether the composite has been modified during the current step.
     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
     * If you need to change it manually, you should use the `Composite.setModified` method.
     *
     * @property isModified
     * @type boolean
     * @default false
     */ /**
     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
     *
     * @property parent
     * @type composite
     * @default null
     */ /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     *
     * @property bodies
     * @type body[]
     * @default []
     */ /**
     * An array of `Constraint` that are _direct_ children of this composite.
     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
     *
     * @property constraints
     * @type constraint[]
     * @default []
     */ /**
     * An array of `Composite` that are _direct_ children of this composite.
     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
     *
     * @property composites
     * @type composite[]
     * @default []
     */ /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */ })();
            },
            {
                "../core/Common": 14,
                "../core/Events": 16,
                "../geometry/Bounds": 26,
                "./Body": 1
            }
        ],
        3: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/ var World = {};
                module1.exports = World;
                var Composite = _dereq_('./Composite');
                var Constraint = _dereq_('../constraint/Constraint');
                var Common = _dereq_('../core/Common');
                (function() {
                    /**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */ World.create = function(options) {
                        var composite = Composite.create();
                        var defaults = {
                            label: 'World',
                            gravity: {
                                x: 0,
                                y: 1,
                                scale: 0.001
                            },
                            bounds: {
                                min: {
                                    x: -Infinity,
                                    y: -Infinity
                                },
                                max: {
                                    x: Infinity,
                                    y: Infinity
                                }
                            }
                        };
                        return Common.extend(composite, defaults, options);
                    };
                /*
    *
    *  Properties Documentation
    *
    */ /**
     * The gravity to apply on the world.
     *
     * @property gravity
     * @type object
     */ /**
     * The gravity x component.
     *
     * @property gravity.x
     * @type object
     * @default 0
     */ /**
     * The gravity y component.
     *
     * @property gravity.y
     * @type object
     * @default 1
     */ /**
     * The gravity scale factor.
     *
     * @property gravity.scale
     * @type object
     * @default 0.001
     */ /**
     * A `Bounds` object that defines the world bounds for collision detection.
     *
     * @property bounds
     * @type bounds
     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }
     */ // World is a Composite body
                // see src/module/Outro.js for these aliases:
                /**
     * An alias for Composite.add
     * @method add
     * @param {world} world
     * @param {} object
     * @return {composite} The original world with the objects added
     */ /**
     * An alias for Composite.remove
     * @method remove
     * @param {world} world
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original world with the objects removed
     */ /**
     * An alias for Composite.clear
     * @method clear
     * @param {world} world
     * @param {boolean} keepStatic
     */ /**
     * An alias for Composite.addComposite
     * @method addComposite
     * @param {world} world
     * @param {composite} composite
     * @return {world} The original world with the objects from composite added
     */ /**
      * An alias for Composite.addBody
      * @method addBody
      * @param {world} world
      * @param {body} body
      * @return {world} The original world with the body added
      */ /**
      * An alias for Composite.addConstraint
      * @method addConstraint
      * @param {world} world
      * @param {constraint} constraint
      * @return {world} The original world with the constraint added
      */ })();
            },
            {
                "../constraint/Constraint": 12,
                "../core/Common": 14,
                "./Composite": 2
            }
        ],
        4: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/ var Contact = {};
                module1.exports = Contact;
                (function() {
                    /**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */ Contact.create = function(vertex) {
                        return {
                            id: Contact.id(vertex),
                            vertex: vertex,
                            normalImpulse: 0,
                            tangentImpulse: 0
                        };
                    };
                    /**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */ Contact.id = function(vertex) {
                        return vertex.body.id + '_' + vertex.index;
                    };
                })();
            },
            {}
        ],
        5: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/ // TODO: speculative contacts
                var Detector = {};
                module1.exports = Detector;
                var SAT = _dereq_('./SAT');
                var Pair = _dereq_('./Pair');
                var Bounds = _dereq_('../geometry/Bounds');
                (function() {
                    /**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */ Detector.collisions = function(broadphasePairs, engine) {
                        var collisions = [], pairsTable = engine.pairs.table;
                        for(var i = 0; i < broadphasePairs.length; i++){
                            var bodyA = broadphasePairs[i][0], bodyB = broadphasePairs[i][1];
                            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping)) continue;
                            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) continue;
                            // mid phase
                            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                                for(var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++){
                                    var partA = bodyA.parts[j];
                                    for(var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++){
                                        var partB = bodyB.parts[k];
                                        if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {
                                            // find a previous collision we could reuse
                                            var pairId = Pair.id(partA, partB), pair = pairsTable[pairId], previousCollision;
                                            if (pair && pair.isActive) {
                                                previousCollision = pair.collision;
                                            } else {
                                                previousCollision = null;
                                            }
                                            // narrow phase
                                            var collision = SAT.collides(partA, partB, previousCollision);
                                            if (collision.collided) {
                                                collisions.push(collision);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return collisions;
                    };
                    /**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */ Detector.canCollide = function(filterA, filterB) {
                        if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;
                        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
                    };
                })();
            },
            {
                "../geometry/Bounds": 26,
                "./Pair": 7,
                "./SAT": 11
            }
        ],
        6: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/ var Grid = {};
                module1.exports = Grid;
                var Pair = _dereq_('./Pair');
                var Detector = _dereq_('./Detector');
                var Common = _dereq_('../core/Common');
                (function() {
                    /**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */ Grid.create = function(options) {
                        var defaults = {
                            controller: Grid,
                            detector: Detector.collisions,
                            buckets: {},
                            pairs: {},
                            pairsList: [],
                            bucketWidth: 48,
                            bucketHeight: 48
                        };
                        return Common.extend(defaults, options);
                    };
                    /**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     */ /**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     */ /**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */ Grid.update = function(grid, bodies, engine, forceUpdate) {
                        var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
                        for(i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (body.isSleeping && !forceUpdate) continue;
                            // don't update out of world bodies
                            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y) continue;
                            var newRegion = Grid._getRegion(grid, body);
                            // if the body has changed grid region
                            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
                                if (!body.region || forceUpdate) body.region = newRegion;
                                var union = Grid._regionUnion(newRegion, body.region);
                                // update grid buckets affected by region change
                                // iterate over the union of both regions
                                for(col = union.startCol; col <= union.endCol; col++){
                                    for(row = union.startRow; row <= union.endRow; row++){
                                        bucketId = Grid._getBucketId(col, row);
                                        bucket = buckets[bucketId];
                                        var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
                                        var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
                                        // remove from old region buckets
                                        if (!isInsideNewRegion && isInsideOldRegion) {
                                            if (isInsideOldRegion) {
                                                if (bucket) Grid._bucketRemoveBody(grid, bucket, body);
                                            }
                                        }
                                        // add to new region buckets
                                        if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                                            if (!bucket) bucket = Grid._createBucket(buckets, bucketId);
                                            Grid._bucketAddBody(grid, bucket, body);
                                        }
                                    }
                                }
                                // set the new region
                                body.region = newRegion;
                                // flag changes so we can update pairs
                                gridChanged = true;
                            }
                        }
                        // update pairs list only if pairs changed (i.e. a body changed region)
                        if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);
                    };
                    /**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */ Grid.clear = function(grid) {
                        grid.buckets = {};
                        grid.pairs = {};
                        grid.pairsList = [];
                    };
                    /**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */ Grid._regionUnion = function(regionA, regionB) {
                        var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
                        return Grid._createRegion(startCol, endCol, startRow, endRow);
                    };
                    /**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */ Grid._getRegion = function(grid, body) {
                        var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
                        return Grid._createRegion(startCol, endCol, startRow, endRow);
                    };
                    /**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */ Grid._createRegion = function(startCol, endCol, startRow, endRow) {
                        return {
                            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,
                            startCol: startCol,
                            endCol: endCol,
                            startRow: startRow,
                            endRow: endRow
                        };
                    };
                    /**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */ Grid._getBucketId = function(column, row) {
                        return 'C' + column + 'R' + row;
                    };
                    /**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */ Grid._createBucket = function(buckets, bucketId) {
                        var bucket = buckets[bucketId] = [];
                        return bucket;
                    };
                    /**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */ Grid._bucketAddBody = function(grid, bucket, body) {
                        // add new pairs
                        for(var i = 0; i < bucket.length; i++){
                            var bodyB = bucket[i];
                            if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue;
                            // keep track of the number of buckets the pair exists in
                            // important for Grid.update to work
                            var pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                            if (pair) {
                                pair[2] += 1;
                            } else {
                                grid.pairs[pairId] = [
                                    body,
                                    bodyB,
                                    1
                                ];
                            }
                        }
                        // add to bodies (after pairs, otherwise pairs with self)
                        bucket.push(body);
                    };
                    /**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */ Grid._bucketRemoveBody = function(grid, bucket, body) {
                        // remove from bucket
                        bucket.splice(Common.indexOf(bucket, body), 1);
                        // update pair counts
                        for(var i = 0; i < bucket.length; i++){
                            // keep track of the number of buckets the pair exists in
                            // important for _createActivePairsList to work
                            var bodyB = bucket[i], pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                            if (pair) pair[2] -= 1;
                        }
                    };
                    /**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */ Grid._createActivePairsList = function(grid) {
                        var pairKeys, pair, pairs = [];
                        // grid.pairs is used as a hashmap
                        pairKeys = Common.keys(grid.pairs);
                        // iterate over grid.pairs
                        for(var k = 0; k < pairKeys.length; k++){
                            pair = grid.pairs[pairKeys[k]];
                            // if pair exists in at least one bucket
                            // it is a pair that needs further collision testing so push it
                            if (pair[2] > 0) {
                                pairs.push(pair);
                            } else {
                                delete grid.pairs[pairKeys[k]];
                            }
                        }
                        return pairs;
                    };
                })();
            },
            {
                "../core/Common": 14,
                "./Detector": 5,
                "./Pair": 7
            }
        ],
        7: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/ var Pair = {};
                module1.exports = Pair;
                var Contact = _dereq_('./Contact');
                (function() {
                    /**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */ Pair.create = function(collision, timestamp) {
                        var bodyA = collision.bodyA, bodyB = collision.bodyB, parentA = collision.parentA, parentB = collision.parentB;
                        var pair = {
                            id: Pair.id(bodyA, bodyB),
                            bodyA: bodyA,
                            bodyB: bodyB,
                            contacts: {},
                            activeContacts: [],
                            separation: 0,
                            isActive: true,
                            isSensor: bodyA.isSensor || bodyB.isSensor,
                            timeCreated: timestamp,
                            timeUpdated: timestamp,
                            inverseMass: parentA.inverseMass + parentB.inverseMass,
                            friction: Math.min(parentA.friction, parentB.friction),
                            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),
                            restitution: Math.max(parentA.restitution, parentB.restitution),
                            slop: Math.max(parentA.slop, parentB.slop)
                        };
                        Pair.update(pair, collision, timestamp);
                        return pair;
                    };
                    /**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */ Pair.update = function(pair, collision, timestamp) {
                        var contacts = pair.contacts, supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB;
                        pair.collision = collision;
                        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
                        pair.friction = Math.min(parentA.friction, parentB.friction);
                        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
                        pair.restitution = Math.max(parentA.restitution, parentB.restitution);
                        pair.slop = Math.max(parentA.slop, parentB.slop);
                        activeContacts.length = 0;
                        if (collision.collided) {
                            for(var i = 0; i < supports.length; i++){
                                var support = supports[i], contactId = Contact.id(support), contact = contacts[contactId];
                                if (contact) {
                                    activeContacts.push(contact);
                                } else {
                                    activeContacts.push(contacts[contactId] = Contact.create(support));
                                }
                            }
                            pair.separation = collision.depth;
                            Pair.setActive(pair, true, timestamp);
                        } else {
                            if (pair.isActive === true) Pair.setActive(pair, false, timestamp);
                        }
                    };
                    /**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */ Pair.setActive = function(pair, isActive, timestamp) {
                        if (isActive) {
                            pair.isActive = true;
                            pair.timeUpdated = timestamp;
                        } else {
                            pair.isActive = false;
                            pair.activeContacts.length = 0;
                        }
                    };
                    /**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */ Pair.id = function(bodyA, bodyB) {
                        if (bodyA.id < bodyB.id) {
                            return 'A' + bodyA.id + 'B' + bodyB.id;
                        } else {
                            return 'A' + bodyB.id + 'B' + bodyA.id;
                        }
                    };
                })();
            },
            {
                "./Contact": 4
            }
        ],
        8: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/ var Pairs = {};
                module1.exports = Pairs;
                var Pair = _dereq_('./Pair');
                var Common = _dereq_('../core/Common');
                (function() {
                    Pairs._pairMaxIdleLife = 1000;
                    /**
     * Creates a new pairs structure.
     * @method create
     * @param {object} [options]
     * @return {pairs} A new pairs structure
     */ Pairs.create = function(options) {
                        return Common.extend({
                            table: {},
                            list: [],
                            collisionStart: [],
                            collisionActive: [],
                            collisionEnd: []
                        }, options);
                    };
                    /**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */ Pairs.update = function(pairs, collisions, timestamp) {
                        var pairsList = pairs.list, pairsTable = pairs.table, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, activePairIds = [], collision, pairId, pair, i;
                        // clear collision state arrays, but maintain old reference
                        collisionStart.length = 0;
                        collisionEnd.length = 0;
                        collisionActive.length = 0;
                        for(i = 0; i < collisions.length; i++){
                            collision = collisions[i];
                            if (collision.collided) {
                                pairId = Pair.id(collision.bodyA, collision.bodyB);
                                activePairIds.push(pairId);
                                pair = pairsTable[pairId];
                                if (pair) {
                                    // pair already exists (but may or may not be active)
                                    if (pair.isActive) {
                                        // pair exists and is active
                                        collisionActive.push(pair);
                                    } else {
                                        // pair exists but was inactive, so a collision has just started again
                                        collisionStart.push(pair);
                                    }
                                    // update the pair
                                    Pair.update(pair, collision, timestamp);
                                } else {
                                    // pair did not exist, create a new pair
                                    pair = Pair.create(collision, timestamp);
                                    pairsTable[pairId] = pair;
                                    // push the new pair
                                    collisionStart.push(pair);
                                    pairsList.push(pair);
                                }
                            }
                        }
                        // deactivate previously active pairs that are now inactive
                        for(i = 0; i < pairsList.length; i++){
                            pair = pairsList[i];
                            if (pair.isActive && Common.indexOf(activePairIds, pair.id) === -1) {
                                Pair.setActive(pair, false, timestamp);
                                collisionEnd.push(pair);
                            }
                        }
                    };
                    /**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */ Pairs.removeOld = function(pairs, timestamp) {
                        var pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], pair, collision, pairIndex, i;
                        for(i = 0; i < pairsList.length; i++){
                            pair = pairsList[i];
                            collision = pair.collision;
                            // never remove sleeping pairs
                            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                                pair.timeUpdated = timestamp;
                                continue;
                            }
                            // if pair is inactive for too long, mark it to be removed
                            if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
                                indexesToRemove.push(i);
                            }
                        }
                        // remove marked pairs
                        for(i = 0; i < indexesToRemove.length; i++){
                            pairIndex = indexesToRemove[i] - i;
                            pair = pairsList[pairIndex];
                            delete pairsTable[pair.id];
                            pairsList.splice(pairIndex, 1);
                        }
                    };
                    /**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */ Pairs.clear = function(pairs) {
                        pairs.table = {};
                        pairs.list.length = 0;
                        pairs.collisionStart.length = 0;
                        pairs.collisionActive.length = 0;
                        pairs.collisionEnd.length = 0;
                        return pairs;
                    };
                })();
            },
            {
                "../core/Common": 14,
                "./Pair": 7
            }
        ],
        9: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/ var Query = {};
                module1.exports = Query;
                var Vector = _dereq_('../geometry/Vector');
                var SAT = _dereq_('./SAT');
                var Bounds = _dereq_('../geometry/Bounds');
                var Bodies = _dereq_('../factory/Bodies');
                var Vertices = _dereq_('../geometry/Vertices');
                (function() {
                    /**
     * Returns a list of collisions between `body` and `bodies`.
     * @method collides
     * @param {body} body
     * @param {body[]} bodies
     * @return {object[]} Collisions
     */ Query.collides = function(body, bodies) {
                        var collisions = [];
                        for(var i = 0; i < bodies.length; i++){
                            var bodyA = bodies[i];
                            if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
                                for(var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++){
                                    var part = bodyA.parts[j];
                                    if (Bounds.overlaps(part.bounds, body.bounds)) {
                                        var collision = SAT.collides(part, body);
                                        if (collision.collided) {
                                            collisions.push(collision);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        return collisions;
                    };
                    /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */ Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
                        rayWidth = rayWidth || 1e-100;
                        var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {
                            angle: rayAngle
                        }), collisions = Query.collides(ray, bodies);
                        for(var i = 0; i < collisions.length; i += 1){
                            var collision = collisions[i];
                            collision.body = collision.bodyB = collision.bodyA;
                        }
                        return collisions;
                    };
                    /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */ Query.region = function(bodies, bounds, outside) {
                        var result = [];
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);
                            if (overlaps && !outside || !overlaps && outside) result.push(body);
                        }
                        return result;
                    };
                    /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */ Query.point = function(bodies, point) {
                        var result = [];
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (Bounds.contains(body.bounds, point)) {
                                for(var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++){
                                    var part = body.parts[j];
                                    if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
                                        result.push(body);
                                        break;
                                    }
                                }
                            }
                        }
                        return result;
                    };
                })();
            },
            {
                "../factory/Bodies": 23,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29,
                "./SAT": 11
            }
        ],
        10: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/ var Resolver = {};
                module1.exports = Resolver;
                var Vertices = _dereq_('../geometry/Vertices');
                var Vector = _dereq_('../geometry/Vector');
                var Common = _dereq_('../core/Common');
                var Bounds = _dereq_('../geometry/Bounds');
                (function() {
                    Resolver._restingThresh = 4;
                    Resolver._restingThreshTangent = 6;
                    Resolver._positionDampen = 0.9;
                    Resolver._positionWarming = 0.8;
                    Resolver._frictionNormalMultiplier = 5;
                    /**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */ Resolver.preSolvePosition = function(pairs) {
                        var i, pair, activeCount;
                        // find total contacts on each body
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive) continue;
                            activeCount = pair.activeContacts.length;
                            pair.collision.parentA.totalContacts += activeCount;
                            pair.collision.parentB.totalContacts += activeCount;
                        }
                    };
                    /**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */ Resolver.solvePosition = function(pairs, timeScale) {
                        var i, pair, collision, bodyA, bodyB, normal, bodyBtoA, contactShare, positionImpulse, contactCount = {}, tempA = Vector._temp[0], tempB = Vector._temp[1], tempC = Vector._temp[2], tempD = Vector._temp[3];
                        // find impulses required to resolve penetration
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive || pair.isSensor) continue;
                            collision = pair.collision;
                            bodyA = collision.parentA;
                            bodyB = collision.parentB;
                            normal = collision.normal;
                            // get current separation between body edges involved in collision
                            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), Vector.add(bodyA.positionImpulse, Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);
                            pair.separation = Vector.dot(normal, bodyBtoA);
                        }
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive || pair.isSensor) continue;
                            collision = pair.collision;
                            bodyA = collision.parentA;
                            bodyB = collision.parentB;
                            normal = collision.normal;
                            positionImpulse = (pair.separation - pair.slop) * timeScale;
                            if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;
                            if (!(bodyA.isStatic || bodyA.isSleeping)) {
                                contactShare = Resolver._positionDampen / bodyA.totalContacts;
                                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
                            }
                            if (!(bodyB.isStatic || bodyB.isSleeping)) {
                                contactShare = Resolver._positionDampen / bodyB.totalContacts;
                                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
                            }
                        }
                    };
                    /**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */ Resolver.postSolvePosition = function(bodies) {
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            // reset contact count
                            body.totalContacts = 0;
                            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                                // update body geometry
                                for(var j = 0; j < body.parts.length; j++){
                                    var part = body.parts[j];
                                    Vertices.translate(part.vertices, body.positionImpulse);
                                    Bounds.update(part.bounds, part.vertices, body.velocity);
                                    part.position.x += body.positionImpulse.x;
                                    part.position.y += body.positionImpulse.y;
                                }
                                // move the body without changing velocity
                                body.positionPrev.x += body.positionImpulse.x;
                                body.positionPrev.y += body.positionImpulse.y;
                                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                                    // reset cached impulse if the body has velocity along it
                                    body.positionImpulse.x = 0;
                                    body.positionImpulse.y = 0;
                                } else {
                                    // warm the next iteration
                                    body.positionImpulse.x *= Resolver._positionWarming;
                                    body.positionImpulse.y *= Resolver._positionWarming;
                                }
                            }
                        }
                    };
                    /**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */ Resolver.preSolveVelocity = function(pairs) {
                        var i, j, pair, contacts, collision, bodyA, bodyB, normal, tangent, contact, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector._temp[0], tempA = Vector._temp[1];
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive || pair.isSensor) continue;
                            contacts = pair.activeContacts;
                            collision = pair.collision;
                            bodyA = collision.parentA;
                            bodyB = collision.parentB;
                            normal = collision.normal;
                            tangent = collision.tangent;
                            // resolve each contact
                            for(j = 0; j < contacts.length; j++){
                                contact = contacts[j];
                                contactVertex = contact.vertex;
                                normalImpulse = contact.normalImpulse;
                                tangentImpulse = contact.tangentImpulse;
                                if (normalImpulse !== 0 || tangentImpulse !== 0) {
                                    // total impulse from contact
                                    impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                                    impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                                    // apply impulse from contact
                                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                                        offset = Vector.sub(contactVertex, bodyA.position, tempA);
                                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                                    }
                                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                                        offset = Vector.sub(contactVertex, bodyB.position, tempA);
                                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                                    }
                                }
                            }
                        }
                    };
                    /**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */ Resolver.solveVelocity = function(pairs, timeScale) {
                        var timeScaleSquared = timeScale * timeScale, impulse = Vector._temp[0], tempA = Vector._temp[1], tempB = Vector._temp[2], tempC = Vector._temp[3], tempD = Vector._temp[4], tempE = Vector._temp[5];
                        for(var i = 0; i < pairs.length; i++){
                            var pair = pairs[i];
                            if (!pair.isActive || pair.isSensor) continue;
                            var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, contacts = pair.activeContacts, contactShare = 1 / contacts.length;
                            // update body velocities
                            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
                            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
                            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
                            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
                            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
                            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
                            // resolve each contact
                            for(var j = 0; j < contacts.length; j++){
                                var contact = contacts[j], contactVertex = contact.vertex, offsetA = Vector.sub(contactVertex, bodyA.position, tempA), offsetB = Vector.sub(contactVertex, bodyB.position, tempB), velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC), velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE), normalVelocity = Vector.dot(normal, relativeVelocity);
                                var tangentVelocity = Vector.dot(tangent, relativeVelocity), tangentSpeed = Math.abs(tangentVelocity), tangentVelocityDirection = Common.sign(tangentVelocity);
                                // raw impulses
                                var normalImpulse = (1 + pair.restitution) * normalVelocity, normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;
                                // coulomb friction
                                var tangentImpulse = tangentVelocity, maxFriction = Infinity;
                                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                                    maxFriction = tangentSpeed;
                                    tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);
                                }
                                // modify impulses accounting for mass, inertia and offset
                                var oAcN = Vector.cross(offsetA, normal), oBcN = Vector.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                                normalImpulse *= share;
                                tangentImpulse *= share;
                                // handle high velocity and resting collisions separately
                                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                                    // high normal velocity so clear cached contact normal impulse
                                    contact.normalImpulse = 0;
                                } else {
                                    // solve resting collision constraints using Erin Catto's method (GDC08)
                                    // impulse constraint tends to 0
                                    var contactNormalImpulse = contact.normalImpulse;
                                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                                }
                                // handle high velocity and resting collisions separately
                                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                                    // high tangent velocity so clear cached contact tangent impulse
                                    contact.tangentImpulse = 0;
                                } else {
                                    // solve resting collision constraints using Erin Catto's method (GDC08)
                                    // tangent impulse tends to -tangentSpeed or +tangentSpeed
                                    var contactTangentImpulse = contact.tangentImpulse;
                                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                                }
                                // total impulse from contact
                                impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                                impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                                // apply impulse from contact
                                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                                }
                                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                                }
                            }
                        }
                    };
                })();
            },
            {
                "../core/Common": 14,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29
            }
        ],
        11: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/ // TODO: true circles and curves
                var SAT = {};
                module1.exports = SAT;
                var Vertices = _dereq_('../geometry/Vertices');
                var Vector = _dereq_('../geometry/Vector');
                (function() {
                    /**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */ SAT.collides = function(bodyA, bodyB, previousCollision) {
                        var overlapAB, overlapBA, minOverlap, collision, canReusePrevCol = false;
                        if (previousCollision) {
                            // estimate total motion
                            var parentA = bodyA.parent, parentB = bodyB.parent, motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;
                            // we may be able to (partially) reuse collision result 
                            // but only safe if collision was resting
                            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;
                            // reuse collision object
                            collision = previousCollision;
                        } else {
                            collision = {
                                collided: false,
                                bodyA: bodyA,
                                bodyB: bodyB
                            };
                        }
                        if (previousCollision && canReusePrevCol) {
                            // if we can reuse the collision result
                            // we only need to test the previously found axis
                            var axisBodyA = collision.axisBody, axisBodyB = axisBodyA === bodyA ? bodyB : bodyA, axes = [
                                axisBodyA.axes[previousCollision.axisNumber]
                            ];
                            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
                            collision.reused = true;
                            if (minOverlap.overlap <= 0) {
                                collision.collided = false;
                                return collision;
                            }
                        } else {
                            // if we can't reuse a result, perform a full SAT test
                            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);
                            if (overlapAB.overlap <= 0) {
                                collision.collided = false;
                                return collision;
                            }
                            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);
                            if (overlapBA.overlap <= 0) {
                                collision.collided = false;
                                return collision;
                            }
                            if (overlapAB.overlap < overlapBA.overlap) {
                                minOverlap = overlapAB;
                                collision.axisBody = bodyA;
                            } else {
                                minOverlap = overlapBA;
                                collision.axisBody = bodyB;
                            }
                            // important for reuse later
                            collision.axisNumber = minOverlap.axisNumber;
                        }
                        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
                        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
                        collision.collided = true;
                        collision.depth = minOverlap.overlap;
                        collision.parentA = collision.bodyA.parent;
                        collision.parentB = collision.bodyB.parent;
                        bodyA = collision.bodyA;
                        bodyB = collision.bodyB;
                        // ensure normal is facing away from bodyA
                        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
                            collision.normal = {
                                x: minOverlap.axis.x,
                                y: minOverlap.axis.y
                            };
                        } else {
                            collision.normal = {
                                x: -minOverlap.axis.x,
                                y: -minOverlap.axis.y
                            };
                        }
                        collision.tangent = Vector.perp(collision.normal);
                        collision.penetration = collision.penetration || {};
                        collision.penetration.x = collision.normal.x * collision.depth;
                        collision.penetration.y = collision.normal.y * collision.depth;
                        // find support points, there is always either exactly one or two
                        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal), supports = [];
                        // find the supports from bodyB that are inside bodyA
                        if (Vertices.contains(bodyA.vertices, verticesB[0])) supports.push(verticesB[0]);
                        if (Vertices.contains(bodyA.vertices, verticesB[1])) supports.push(verticesB[1]);
                        // find the supports from bodyA that are inside bodyB
                        if (supports.length < 2) {
                            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                            if (Vertices.contains(bodyB.vertices, verticesA[0])) supports.push(verticesA[0]);
                            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1])) supports.push(verticesA[1]);
                        }
                        // account for the edge case of overlapping but no vertex containment
                        if (supports.length < 1) supports = [
                            verticesB[0]
                        ];
                        collision.supports = supports;
                        return collision;
                    };
                    /**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */ SAT._overlapAxes = function(verticesA, verticesB, axes) {
                        var projectionA = Vector._temp[0], projectionB = Vector._temp[1], result = {
                            overlap: Number.MAX_VALUE
                        }, overlap, axis;
                        for(var i = 0; i < axes.length; i++){
                            axis = axes[i];
                            SAT._projectToAxis(projectionA, verticesA, axis);
                            SAT._projectToAxis(projectionB, verticesB, axis);
                            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
                            if (overlap <= 0) {
                                result.overlap = overlap;
                                return result;
                            }
                            if (overlap < result.overlap) {
                                result.overlap = overlap;
                                result.axis = axis;
                                result.axisNumber = i;
                            }
                        }
                        return result;
                    };
                    /**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */ SAT._projectToAxis = function(projection, vertices, axis) {
                        var min = Vector.dot(vertices[0], axis), max = min;
                        for(var i = 1; i < vertices.length; i += 1){
                            var dot = Vector.dot(vertices[i], axis);
                            if (dot > max) {
                                max = dot;
                            } else if (dot < min) {
                                min = dot;
                            }
                        }
                        projection.min = min;
                        projection.max = max;
                    };
                    /**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */ SAT._findSupports = function(bodyA, bodyB, normal) {
                        var nearestDistance = Number.MAX_VALUE, vertexToBody = Vector._temp[0], vertices = bodyB.vertices, bodyAPosition = bodyA.position, distance, vertex, vertexA, vertexB;
                        // find closest vertex on bodyB
                        for(var i = 0; i < vertices.length; i++){
                            vertex = vertices[i];
                            vertexToBody.x = vertex.x - bodyAPosition.x;
                            vertexToBody.y = vertex.y - bodyAPosition.y;
                            distance = -Vector.dot(normal, vertexToBody);
                            if (distance < nearestDistance) {
                                nearestDistance = distance;
                                vertexA = vertex;
                            }
                        }
                        // find next closest vertex using the two connected to it
                        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
                        vertex = vertices[prevIndex];
                        vertexToBody.x = vertex.x - bodyAPosition.x;
                        vertexToBody.y = vertex.y - bodyAPosition.y;
                        nearestDistance = -Vector.dot(normal, vertexToBody);
                        vertexB = vertex;
                        var nextIndex = (vertexA.index + 1) % vertices.length;
                        vertex = vertices[nextIndex];
                        vertexToBody.x = vertex.x - bodyAPosition.x;
                        vertexToBody.y = vertex.y - bodyAPosition.y;
                        distance = -Vector.dot(normal, vertexToBody);
                        if (distance < nearestDistance) {
                            vertexB = vertex;
                        }
                        return [
                            vertexA,
                            vertexB
                        ];
                    };
                })();
            },
            {
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29
            }
        ],
        12: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/ var Constraint = {};
                module1.exports = Constraint;
                var Vertices = _dereq_('../geometry/Vertices');
                var Vector = _dereq_('../geometry/Vector');
                var Sleeping = _dereq_('../core/Sleeping');
                var Bounds = _dereq_('../geometry/Bounds');
                var Axes = _dereq_('../geometry/Axes');
                var Common = _dereq_('../core/Common');
                (function() {
                    Constraint._warming = 0.4;
                    Constraint._torqueDampen = 1;
                    Constraint._minLength = 0.000001;
                    /**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.
     * For compound bodies, constraints must be applied to the parent body (not one of its parts).
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */ Constraint.create = function(options) {
                        var constraint = options;
                        // if bodies defined but no points, use body centre
                        if (constraint.bodyA && !constraint.pointA) constraint.pointA = {
                            x: 0,
                            y: 0
                        };
                        if (constraint.bodyB && !constraint.pointB) constraint.pointB = {
                            x: 0,
                            y: 0
                        };
                        // calculate static length using initial world space points
                        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
                        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;
                        // option defaults
                        constraint.id = constraint.id || Common.nextId();
                        constraint.label = constraint.label || 'Constraint';
                        constraint.type = 'constraint';
                        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
                        constraint.damping = constraint.damping || 0;
                        constraint.angularStiffness = constraint.angularStiffness || 0;
                        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
                        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
                        constraint.plugin = {};
                        // render
                        var render = {
                            visible: true,
                            lineWidth: 2,
                            strokeStyle: '#ffffff',
                            type: 'line',
                            anchors: true
                        };
                        if (constraint.length === 0 && constraint.stiffness > 0.1) {
                            render.type = 'pin';
                            render.anchors = false;
                        } else if (constraint.stiffness < 0.9) {
                            render.type = 'spring';
                        }
                        constraint.render = Common.extend(render, constraint.render);
                        return constraint;
                    };
                    /**
     * Prepares for solving by constraint warming.
     * @private
     * @method preSolveAll
     * @param {body[]} bodies
     */ Constraint.preSolveAll = function(bodies) {
                        for(var i = 0; i < bodies.length; i += 1){
                            var body = bodies[i], impulse = body.constraintImpulse;
                            if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                                continue;
                            }
                            body.position.x += impulse.x;
                            body.position.y += impulse.y;
                            body.angle += impulse.angle;
                        }
                    };
                    /**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */ Constraint.solveAll = function(constraints, timeScale) {
                        // Solve fixed constraints first.
                        for(var i = 0; i < constraints.length; i += 1){
                            var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                            if (fixedA || fixedB) {
                                Constraint.solve(constraints[i], timeScale);
                            }
                        }
                        // Solve free constraints last.
                        for(i = 0; i < constraints.length; i += 1){
                            constraint = constraints[i];
                            fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
                            fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                            if (!fixedA && !fixedB) {
                                Constraint.solve(constraints[i], timeScale);
                            }
                        }
                    };
                    /**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */ Constraint.solve = function(constraint, timeScale) {
                        var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
                        if (!bodyA && !bodyB) return;
                        // update reference angle
                        if (bodyA && !bodyA.isStatic) {
                            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
                            constraint.angleA = bodyA.angle;
                        }
                        // update reference angle
                        if (bodyB && !bodyB.isStatic) {
                            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
                            constraint.angleB = bodyB.angle;
                        }
                        var pointAWorld = pointA, pointBWorld = pointB;
                        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);
                        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);
                        if (!pointAWorld || !pointBWorld) return;
                        var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
                        // prevent singularity
                        if (currentLength < Constraint._minLength) {
                            currentLength = Constraint._minLength;
                        }
                        // solve distance constraint with Gauss-Siedel method
                        var difference = (currentLength - constraint.length) / currentLength, stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
                        if (constraint.damping) {
                            var zero = Vector.create();
                            normal = Vector.div(delta, currentLength);
                            relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
                            normalVelocity = Vector.dot(normal, relativeVelocity);
                        }
                        if (bodyA && !bodyA.isStatic) {
                            share = bodyA.inverseMass / massTotal;
                            // keep track of applied impulses for post solving
                            bodyA.constraintImpulse.x -= force.x * share;
                            bodyA.constraintImpulse.y -= force.y * share;
                            // apply forces
                            bodyA.position.x -= force.x * share;
                            bodyA.position.y -= force.y * share;
                            // apply damping
                            if (constraint.damping) {
                                bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
                                bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
                            }
                            // apply torque
                            torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
                            bodyA.constraintImpulse.angle -= torque;
                            bodyA.angle -= torque;
                        }
                        if (bodyB && !bodyB.isStatic) {
                            share = bodyB.inverseMass / massTotal;
                            // keep track of applied impulses for post solving
                            bodyB.constraintImpulse.x += force.x * share;
                            bodyB.constraintImpulse.y += force.y * share;
                            // apply forces
                            bodyB.position.x += force.x * share;
                            bodyB.position.y += force.y * share;
                            // apply damping
                            if (constraint.damping) {
                                bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
                                bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
                            }
                            // apply torque
                            torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
                            bodyB.constraintImpulse.angle += torque;
                            bodyB.angle += torque;
                        }
                    };
                    /**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */ Constraint.postSolveAll = function(bodies) {
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i], impulse = body.constraintImpulse;
                            if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                                continue;
                            }
                            Sleeping.set(body, false);
                            // update geometry and reset
                            for(var j = 0; j < body.parts.length; j++){
                                var part = body.parts[j];
                                Vertices.translate(part.vertices, impulse);
                                if (j > 0) {
                                    part.position.x += impulse.x;
                                    part.position.y += impulse.y;
                                }
                                if (impulse.angle !== 0) {
                                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                                    Axes.rotate(part.axes, impulse.angle);
                                    if (j > 0) {
                                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                                    }
                                }
                                Bounds.update(part.bounds, part.vertices, body.velocity);
                            }
                            // dampen the cached impulse for warming next step
                            impulse.angle *= Constraint._warming;
                            impulse.x *= Constraint._warming;
                            impulse.y *= Constraint._warming;
                        }
                    };
                /*
    *
    *  Properties Documentation
    *
    */ /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */ /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */ /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Constraint"
     */ /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */ /**
     * A flag that indicates if the constraint should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */ /**
     * A `Number` that defines the line width to use when rendering the constraint outline.
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 2
     */ /**
     * A `String` that defines the stroke style to use when rendering the constraint outline.
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */ /**
     * A `String` that defines the constraint rendering type. 
     * The possible values are 'line', 'pin', 'spring'.
     * An appropriate render type will be automatically chosen unless one is given in options.
     *
     * @property render.type
     * @type string
     * @default 'line'
     */ /**
     * A `Boolean` that defines if the constraint's anchor points should be rendered.
     *
     * @property render.anchors
     * @type boolean
     * @default true
     */ /**
     * The first possible `Body` that this constraint is attached to.
     *
     * @property bodyA
     * @type body
     * @default null
     */ /**
     * The second possible `Body` that this constraint is attached to.
     *
     * @property bodyB
     * @type body
     * @default null
     */ /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointA
     * @type vector
     * @default { x: 0, y: 0 }
     */ /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.
     *
     * @property pointB
     * @type vector
     * @default { x: 0, y: 0 }
     */ /**
     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
     * A value of `1` means the constraint should be very stiff.
     * A value of `0.2` means the constraint acts like a soft spring.
     *
     * @property stiffness
     * @type number
     * @default 1
     */ /**
     * A `Number` that specifies the damping of the constraint, 
     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.
     * Damping will only be apparent when the constraint also has a very low `stiffness`.
     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.
     * A value of `0` means the constraint will apply no damping.
     *
     * @property damping
     * @type number
     * @default 0
     */ /**
     * A `Number` that specifies the target resting length of the constraint. 
     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     *
     * @property length
     * @type number
     */ /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */ })();
            },
            {
                "../core/Common": 14,
                "../core/Sleeping": 22,
                "../geometry/Axes": 25,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29
            }
        ],
        13: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/ var MouseConstraint = {};
                module1.exports = MouseConstraint;
                var Vertices = _dereq_('../geometry/Vertices');
                var Sleeping = _dereq_('../core/Sleeping');
                var Mouse = _dereq_('../core/Mouse');
                var Events = _dereq_('../core/Events');
                var Detector = _dereq_('../collision/Detector');
                var Constraint = _dereq_('./Constraint');
                var Composite = _dereq_('../body/Composite');
                var Common = _dereq_('../core/Common');
                var Bounds = _dereq_('../geometry/Bounds');
                (function() {
                    /**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */ MouseConstraint.create = function(engine, options) {
                        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);
                        if (!mouse) {
                            if (engine && engine.render && engine.render.canvas) {
                                mouse = Mouse.create(engine.render.canvas);
                            } else if (options && options.element) {
                                mouse = Mouse.create(options.element);
                            } else {
                                mouse = Mouse.create();
                                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');
                            }
                        }
                        var constraint = Constraint.create({
                            label: 'Mouse Constraint',
                            pointA: mouse.position,
                            pointB: {
                                x: 0,
                                y: 0
                            },
                            length: 0.01,
                            stiffness: 0.1,
                            angularStiffness: 1,
                            render: {
                                strokeStyle: '#90EE90',
                                lineWidth: 3
                            }
                        });
                        var defaults = {
                            type: 'mouseConstraint',
                            mouse: mouse,
                            element: null,
                            body: null,
                            constraint: constraint,
                            collisionFilter: {
                                category: 0x0001,
                                mask: 0xFFFFFFFF,
                                group: 0
                            }
                        };
                        var mouseConstraint = Common.extend(defaults, options);
                        Events.on(engine, 'beforeUpdate', function() {
                            var allBodies = Composite.allBodies(engine.world);
                            MouseConstraint.update(mouseConstraint, allBodies);
                            MouseConstraint._triggerEvents(mouseConstraint);
                        });
                        return mouseConstraint;
                    };
                    /**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */ MouseConstraint.update = function(mouseConstraint, bodies) {
                        var mouse = mouseConstraint.mouse, constraint = mouseConstraint.constraint, body = mouseConstraint.body;
                        if (mouse.button === 0) {
                            if (!constraint.bodyB) {
                                for(var i = 0; i < bodies.length; i++){
                                    body = bodies[i];
                                    if (Bounds.contains(body.bounds, mouse.position) && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                                        for(var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++){
                                            var part = body.parts[j];
                                            if (Vertices.contains(part.vertices, mouse.position)) {
                                                constraint.pointA = mouse.position;
                                                constraint.bodyB = mouseConstraint.body = body;
                                                constraint.pointB = {
                                                    x: mouse.position.x - body.position.x,
                                                    y: mouse.position.y - body.position.y
                                                };
                                                constraint.angleB = body.angle;
                                                Sleeping.set(body, false);
                                                Events.trigger(mouseConstraint, 'startdrag', {
                                                    mouse: mouse,
                                                    body: body
                                                });
                                                break;
                                            }
                                        }
                                    }
                                }
                            } else {
                                Sleeping.set(constraint.bodyB, false);
                                constraint.pointA = mouse.position;
                            }
                        } else {
                            constraint.bodyB = mouseConstraint.body = null;
                            constraint.pointB = null;
                            if (body) Events.trigger(mouseConstraint, 'enddrag', {
                                mouse: mouse,
                                body: body
                            });
                        }
                    };
                    /**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */ MouseConstraint._triggerEvents = function(mouseConstraint) {
                        var mouse = mouseConstraint.mouse, mouseEvents = mouse.sourceEvents;
                        if (mouseEvents.mousemove) Events.trigger(mouseConstraint, 'mousemove', {
                            mouse: mouse
                        });
                        if (mouseEvents.mousedown) Events.trigger(mouseConstraint, 'mousedown', {
                            mouse: mouse
                        });
                        if (mouseEvents.mouseup) Events.trigger(mouseConstraint, 'mouseup', {
                            mouse: mouse
                        });
                        // reset the mouse state ready for the next step
                        Mouse.clearSourceEvents(mouse);
                    };
                /*
    *
    *  Events Documentation
    *
    */ /**
    * Fired when the mouse has moved (or a touch moves) during the last step
    *
    * @event mousemove
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when the mouse is down (or a touch has started) during the last step
    *
    * @event mousedown
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when the mouse is up (or a touch has ended) during the last step
    *
    * @event mouseup
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when the user starts dragging a body
    *
    * @event startdrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired when the user ends dragging a body
    *
    * @event enddrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body that has stopped being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */ /**
     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
     *
     * @property mouse
     * @type mouse
     * @default mouse
     */ /**
     * The `Body` that is currently being moved by the user, or `null` if no body.
     *
     * @property body
     * @type body
     * @default null
     */ /**
     * The `Constraint` object that is used to move the body during interaction.
     *
     * @property constraint
     * @type constraint
     */ /**
     * An `Object` that specifies the collision filter properties.
     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter
     * @type object
     */ })();
            },
            {
                "../body/Composite": 2,
                "../collision/Detector": 5,
                "../core/Common": 14,
                "../core/Events": 16,
                "../core/Mouse": 19,
                "../core/Sleeping": 22,
                "../geometry/Bounds": 26,
                "../geometry/Vertices": 29,
                "./Constraint": 12
            }
        ],
        14: [
            function(_dereq_, module1, exports1) {
                (function(global1) {
                    /**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/ var Common = {};
                    module1.exports = Common;
                    (function() {
                        Common._nextId = 0;
                        Common._seed = 0;
                        Common._nowStartTime = +new Date();
                        /**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */ Common.extend = function(obj, deep) {
                            var argsStart, args, deepClone;
                            if (typeof deep === 'boolean') {
                                argsStart = 2;
                                deepClone = deep;
                            } else {
                                argsStart = 1;
                                deepClone = true;
                            }
                            for(var i = argsStart; i < arguments.length; i++){
                                var source = arguments[i];
                                if (source) {
                                    for(var prop in source){
                                        if (deepClone && source[prop] && source[prop].constructor === Object) {
                                            if (!obj[prop] || obj[prop].constructor === Object) {
                                                obj[prop] = obj[prop] || {};
                                                Common.extend(obj[prop], deepClone, source[prop]);
                                            } else {
                                                obj[prop] = source[prop];
                                            }
                                        } else {
                                            obj[prop] = source[prop];
                                        }
                                    }
                                }
                            }
                            return obj;
                        };
                        /**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */ Common.clone = function(obj, deep) {
                            return Common.extend({}, deep, obj);
                        };
                        /**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */ Common.keys = function(obj) {
                            if (Object.keys) return Object.keys(obj);
                            // avoid hasOwnProperty for performance
                            var keys = [];
                            for(var key in obj)keys.push(key);
                            return keys;
                        };
                        /**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */ Common.values = function(obj) {
                            var values = [];
                            if (Object.keys) {
                                var keys = Object.keys(obj);
                                for(var i = 0; i < keys.length; i++){
                                    values.push(obj[keys[i]]);
                                }
                                return values;
                            }
                            // avoid hasOwnProperty for performance
                            for(var key in obj)values.push(obj[key]);
                            return values;
                        };
                        /**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */ Common.get = function(obj, path, begin, end) {
                            path = path.split('.').slice(begin, end);
                            for(var i = 0; i < path.length; i += 1){
                                obj = obj[path[i]];
                            }
                            return obj;
                        };
                        /**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */ Common.set = function(obj, path, val, begin, end) {
                            var parts = path.split('.').slice(begin, end);
                            Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
                            return val;
                        };
                        /**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */ Common.shuffle = function(array) {
                            for(var i = array.length - 1; i > 0; i--){
                                var j = Math.floor(Common.random() * (i + 1));
                                var temp = array[i];
                                array[i] = array[j];
                                array[j] = temp;
                            }
                            return array;
                        };
                        /**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */ Common.choose = function(choices) {
                            return choices[Math.floor(Common.random() * choices.length)];
                        };
                        /**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */ Common.isElement = function(obj) {
                            if (typeof HTMLElement !== 'undefined') {
                                return obj instanceof HTMLElement;
                            }
                            return !!(obj && obj.nodeType && obj.nodeName);
                        };
                        /**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */ Common.isArray = function(obj) {
                            return Object.prototype.toString.call(obj) === '[object Array]';
                        };
                        /**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */ Common.isFunction = function(obj) {
                            return typeof obj === "function";
                        };
                        /**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */ Common.isPlainObject = function(obj) {
                            return typeof obj === 'object' && obj.constructor === Object;
                        };
                        /**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */ Common.isString = function(obj) {
                            return toString.call(obj) === '[object String]';
                        };
                        /**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */ Common.clamp = function(value, min, max) {
                            if (value < min) return min;
                            if (value > max) return max;
                            return value;
                        };
                        /**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */ Common.sign = function(value) {
                            return value < 0 ? -1 : 1;
                        };
                        /**
     * Returns the current timestamp since the time origin (e.g. from page load).
     * The result will be high-resolution including decimal places if available.
     * @method now
     * @return {number} the current timestamp
     */ Common.now = function() {
                            if (window.performance) {
                                if (window.performance.now) {
                                    return window.performance.now();
                                } else if (window.performance.webkitNow) {
                                    return window.performance.webkitNow();
                                }
                            }
                            return new Date() - Common._nowStartTime;
                        };
                        /**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */ Common.random = function(min, max) {
                            min = typeof min !== "undefined" ? min : 0;
                            max = typeof max !== "undefined" ? max : 1;
                            return min + _seededRandom() * (max - min);
                        };
                        var _seededRandom = function() {
                            // https://en.wikipedia.org/wiki/Linear_congruential_generator
                            Common._seed = (Common._seed * 9301 + 49297) % 233280;
                            return Common._seed / 233280;
                        };
                        /**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */ Common.colorToNumber = function(colorString) {
                            colorString = colorString.replace('#', '');
                            if (colorString.length == 3) {
                                colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
                            }
                            return parseInt(colorString, 16);
                        };
                        /**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */ Common.logLevel = 1;
                        /**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */ Common.log = function() {
                            if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                                console.log.apply(console, [
                                    'matter-js:'
                                ].concat(Array.prototype.slice.call(arguments)));
                            }
                        };
                        /**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */ Common.info = function() {
                            if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
                                console.info.apply(console, [
                                    'matter-js:'
                                ].concat(Array.prototype.slice.call(arguments)));
                            }
                        };
                        /**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */ Common.warn = function() {
                            if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                                console.warn.apply(console, [
                                    'matter-js:'
                                ].concat(Array.prototype.slice.call(arguments)));
                            }
                        };
                        /**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */ Common.nextId = function() {
                            return Common._nextId++;
                        };
                        /**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */ Common.indexOf = function(haystack, needle) {
                            if (haystack.indexOf) return haystack.indexOf(needle);
                            for(var i = 0; i < haystack.length; i++){
                                if (haystack[i] === needle) return i;
                            }
                            return -1;
                        };
                        /**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */ Common.map = function(list, func) {
                            if (list.map) {
                                return list.map(func);
                            }
                            var mapped = [];
                            for(var i = 0; i < list.length; i += 1){
                                mapped.push(func(list[i]));
                            }
                            return mapped;
                        };
                        /**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */ Common.topologicalSort = function(graph) {
                            // https://github.com/mgechev/javascript-algorithms
                            // Copyright (c) Minko Gechev (MIT license)
                            // Modifications: tidy formatting and naming
                            var result = [], visited = [], temp = [];
                            for(var node in graph){
                                if (!visited[node] && !temp[node]) {
                                    Common._topologicalSort(node, visited, temp, graph, result);
                                }
                            }
                            return result;
                        };
                        Common._topologicalSort = function(node, visited, temp, graph, result) {
                            var neighbors = graph[node] || [];
                            temp[node] = true;
                            for(var i = 0; i < neighbors.length; i += 1){
                                var neighbor = neighbors[i];
                                if (temp[neighbor]) {
                                    continue;
                                }
                                if (!visited[neighbor]) {
                                    Common._topologicalSort(neighbor, visited, temp, graph, result);
                                }
                            }
                            temp[node] = false;
                            visited[node] = true;
                            result.push(node);
                        };
                        /**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */ Common.chain = function() {
                            var funcs = [];
                            for(var i = 0; i < arguments.length; i += 1){
                                var func = arguments[i];
                                if (func._chained) {
                                    // flatten already chained functions
                                    funcs.push.apply(funcs, func._chained);
                                } else {
                                    funcs.push(func);
                                }
                            }
                            var chain = function() {
                                // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
                                var lastResult, args = new Array(arguments.length);
                                for(var i = 0, l = arguments.length; i < l; i++){
                                    args[i] = arguments[i];
                                }
                                for(i = 0; i < funcs.length; i += 1){
                                    var result = funcs[i].apply(lastResult, args);
                                    if (typeof result !== 'undefined') {
                                        lastResult = result;
                                    }
                                }
                                return lastResult;
                            };
                            chain._chained = funcs;
                            return chain;
                        };
                        /**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */ Common.chainPathBefore = function(base, path, func) {
                            return Common.set(base, path, Common.chain(func, Common.get(base, path)));
                        };
                        /**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */ Common.chainPathAfter = function(base, path, func) {
                            return Common.set(base, path, Common.chain(Common.get(base, path), func));
                        };
                        /**
     * Used to require external libraries outside of the bundle.
     * It first looks for the `globalName` on the environment's global namespace.
     * If the global is not found, it will fall back to using the standard `require` using the `moduleName`.
     * @private
     * @method _requireGlobal
     * @param {string} globalName The global module name
     * @param {string} moduleName The fallback CommonJS module name
     * @return {} The loaded module
     */ Common._requireGlobal = function(globalName, moduleName) {
                            var obj = typeof window !== 'undefined' ? window[globalName] : typeof global1 !== 'undefined' ? global1[globalName] : null;
                            return obj || _dereq_(moduleName);
                        };
                    })();
                }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            },
            {}
        ],
        15: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/ var Engine = {};
                module1.exports = Engine;
                var World = _dereq_('../body/World');
                var Sleeping = _dereq_('./Sleeping');
                var Resolver = _dereq_('../collision/Resolver');
                var Render = _dereq_('../render/Render');
                var Pairs = _dereq_('../collision/Pairs');
                var Metrics = _dereq_('./Metrics');
                var Grid = _dereq_('../collision/Grid');
                var Events = _dereq_('./Events');
                var Composite = _dereq_('../body/Composite');
                var Constraint = _dereq_('../constraint/Constraint');
                var Common = _dereq_('./Common');
                var Body = _dereq_('../body/Body');
                (function() {
                    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */ Engine.create = function(element, options) {
                        // options may be passed as the first (and only) argument
                        options = Common.isElement(element) ? options : element;
                        element = Common.isElement(element) ? element : null;
                        options = options || {};
                        if (element || options.render) {
                            Common.warn('Engine.create: engine.render is deprecated (see docs)');
                        }
                        var defaults = {
                            positionIterations: 6,
                            velocityIterations: 4,
                            constraintIterations: 2,
                            enableSleeping: false,
                            events: [],
                            plugin: {},
                            timing: {
                                timestamp: 0,
                                timeScale: 1
                            },
                            broadphase: {
                                controller: Grid
                            }
                        };
                        var engine = Common.extend(defaults, options);
                        // @deprecated
                        if (element || engine.render) {
                            var renderDefaults = {
                                element: element,
                                controller: Render
                            };
                            engine.render = Common.extend(renderDefaults, engine.render);
                        }
                        // @deprecated
                        if (engine.render && engine.render.controller) {
                            engine.render = engine.render.controller.create(engine.render);
                        }
                        // @deprecated
                        if (engine.render) {
                            engine.render.engine = engine;
                        }
                        engine.world = options.world || World.create(engine.world);
                        engine.pairs = Pairs.create();
                        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
                        engine.metrics = engine.metrics || {
                            extended: false
                        };
                        return engine;
                    };
                    /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */ Engine.update = function(engine, delta, correction) {
                        delta = delta || 1000 / 60;
                        correction = correction || 1;
                        var world = engine.world, timing = engine.timing, broadphase = engine.broadphase, broadphasePairs = [], i;
                        // increment timestamp
                        timing.timestamp += delta * timing.timeScale;
                        // create an event object
                        var event = {
                            timestamp: timing.timestamp
                        };
                        Events.trigger(engine, 'beforeUpdate', event);
                        // get lists of all bodies and constraints, no matter what composites they are in
                        var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);
                        // if sleeping enabled, call the sleeping controller
                        if (engine.enableSleeping) Sleeping.update(allBodies, timing.timeScale);
                        // applies gravity to all bodies
                        Engine._bodiesApplyGravity(allBodies, world.gravity);
                        // update all body position and rotation by integration
                        Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);
                        // update all constraints (first pass)
                        Constraint.preSolveAll(allBodies);
                        for(i = 0; i < engine.constraintIterations; i++){
                            Constraint.solveAll(allConstraints, timing.timeScale);
                        }
                        Constraint.postSolveAll(allBodies);
                        // broadphase pass: find potential collision pairs
                        if (broadphase.controller) {
                            // if world is dirty, we must flush the whole grid
                            if (world.isModified) broadphase.controller.clear(broadphase);
                            // update the grid buckets based on current bodies
                            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
                            broadphasePairs = broadphase.pairsList;
                        } else {
                            // if no broadphase set, we just pass all bodies
                            broadphasePairs = allBodies;
                        }
                        // clear all composite modified flags
                        if (world.isModified) {
                            Composite.setModified(world, false, false, true);
                        }
                        // narrowphase pass: find actual collisions, then create or update collision pairs
                        var collisions = broadphase.detector(broadphasePairs, engine);
                        // update collision pairs
                        var pairs = engine.pairs, timestamp = timing.timestamp;
                        Pairs.update(pairs, collisions, timestamp);
                        Pairs.removeOld(pairs, timestamp);
                        // wake up bodies involved in collisions
                        if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list, timing.timeScale);
                        // trigger collision events
                        if (pairs.collisionStart.length > 0) Events.trigger(engine, 'collisionStart', {
                            pairs: pairs.collisionStart
                        });
                        // iteratively resolve position between collisions
                        Resolver.preSolvePosition(pairs.list);
                        for(i = 0; i < engine.positionIterations; i++){
                            Resolver.solvePosition(pairs.list, timing.timeScale);
                        }
                        Resolver.postSolvePosition(allBodies);
                        // update all constraints (second pass)
                        Constraint.preSolveAll(allBodies);
                        for(i = 0; i < engine.constraintIterations; i++){
                            Constraint.solveAll(allConstraints, timing.timeScale);
                        }
                        Constraint.postSolveAll(allBodies);
                        // iteratively resolve velocity between collisions
                        Resolver.preSolveVelocity(pairs.list);
                        for(i = 0; i < engine.velocityIterations; i++){
                            Resolver.solveVelocity(pairs.list, timing.timeScale);
                        }
                        // trigger collision events
                        if (pairs.collisionActive.length > 0) Events.trigger(engine, 'collisionActive', {
                            pairs: pairs.collisionActive
                        });
                        if (pairs.collisionEnd.length > 0) Events.trigger(engine, 'collisionEnd', {
                            pairs: pairs.collisionEnd
                        });
                        // clear force buffers
                        Engine._bodiesClearForces(allBodies);
                        Events.trigger(engine, 'afterUpdate', event);
                        return engine;
                    };
                    /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */ Engine.merge = function(engineA, engineB) {
                        Common.extend(engineA, engineB);
                        if (engineB.world) {
                            engineA.world = engineB.world;
                            Engine.clear(engineA);
                            var bodies = Composite.allBodies(engineA.world);
                            for(var i = 0; i < bodies.length; i++){
                                var body = bodies[i];
                                Sleeping.set(body, false);
                                body.id = Common.nextId();
                            }
                        }
                    };
                    /**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */ Engine.clear = function(engine) {
                        var world = engine.world;
                        Pairs.clear(engine.pairs);
                        var broadphase = engine.broadphase;
                        if (broadphase.controller) {
                            var bodies = Composite.allBodies(world);
                            broadphase.controller.clear(broadphase);
                            broadphase.controller.update(broadphase, bodies, engine, true);
                        }
                    };
                    /**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method _bodiesClearForces
     * @private
     * @param {body[]} bodies
     */ Engine._bodiesClearForces = function(bodies) {
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            // reset force buffers
                            body.force.x = 0;
                            body.force.y = 0;
                            body.torque = 0;
                        }
                    };
                    /**
     * Applys a mass dependant force to all given bodies.
     * @method _bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */ Engine._bodiesApplyGravity = function(bodies, gravity) {
                        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;
                        if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
                            return;
                        }
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (body.isStatic || body.isSleeping) continue;
                            // apply gravity
                            body.force.y += body.mass * gravity.y * gravityScale;
                            body.force.x += body.mass * gravity.x * gravityScale;
                        }
                    };
                    /**
     * Applys `Body.update` to all given `bodies`.
     * @method _bodiesUpdate
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */ Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (body.isStatic || body.isSleeping) continue;
                            Body.update(body, deltaTime, timeScale, correction);
                        }
                    };
                /**
     * An alias for `Runner.run`, see `Matter.Runner` for more information.
     * @method run
     * @param {engine} engine
     */ /**
    * Fired just before an update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after engine update and all collision events
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
    *
    * @event collisionStart
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
    *
    * @event collisionActive
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
    *
    * @event collisionEnd
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property positionIterations
     * @type number
     * @default 6
     */ /**
     * An integer `Number` that specifies the number of velocity iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property velocityIterations
     * @type number
     * @default 4
     */ /**
     * An integer `Number` that specifies the number of constraint iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * The default value of `2` is usually very adequate.
     *
     * @property constraintIterations
     * @type number
     * @default 2
     */ /**
     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
     * Sleeping can improve stability and performance, but often at the expense of accuracy.
     *
     * @property enableSleeping
     * @type boolean
     * @default false
     */ /**
     * An `Object` containing properties regarding the timing systems of the engine. 
     *
     * @property timing
     * @type object
     */ /**
     * A `Number` that specifies the global scaling factor of time for all bodies.
     * A value of `0` freezes the simulation.
     * A value of `0.1` gives a slow-motion effect.
     * A value of `1.2` gives a speed-up effect.
     *
     * @property timing.timeScale
     * @type number
     * @default 1
     */ /**
     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. 
     * It is incremented on every `Engine.update` by the given `delta` argument. 
     *
     * @property timing.timestamp
     * @type number
     * @default 0
     */ /**
     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
     *
     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
     *
     * @property render
     * @type render
     * @deprecated see Demo.js for an example of creating a renderer
     * @default a Matter.Render instance
     */ /**
     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
     *
     * @property broadphase
     * @type grid
     * @default a Matter.Grid instance
     */ /**
     * A `World` composite object that will contain all simulated bodies and constraints.
     *
     * @property world
     * @type world
     * @default a Matter.World instance
     */ /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */ })();
            },
            {
                "../body/Body": 1,
                "../body/Composite": 2,
                "../body/World": 3,
                "../collision/Grid": 6,
                "../collision/Pairs": 8,
                "../collision/Resolver": 10,
                "../constraint/Constraint": 12,
                "../render/Render": 31,
                "./Common": 14,
                "./Events": 16,
                "./Metrics": 18,
                "./Sleeping": 22
            }
        ],
        16: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/ var Events = {};
                module1.exports = Events;
                var Common = _dereq_('./Common');
                (function() {
                    /**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */ Events.on = function(object, eventNames, callback) {
                        var names = eventNames.split(' '), name;
                        for(var i = 0; i < names.length; i++){
                            name = names[i];
                            object.events = object.events || {};
                            object.events[name] = object.events[name] || [];
                            object.events[name].push(callback);
                        }
                        return callback;
                    };
                    /**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */ Events.off = function(object, eventNames, callback) {
                        if (!eventNames) {
                            object.events = {};
                            return;
                        }
                        // handle Events.off(object, callback)
                        if (typeof eventNames === 'function') {
                            callback = eventNames;
                            eventNames = Common.keys(object.events).join(' ');
                        }
                        var names = eventNames.split(' ');
                        for(var i = 0; i < names.length; i++){
                            var callbacks = object.events[names[i]], newCallbacks = [];
                            if (callback && callbacks) {
                                for(var j = 0; j < callbacks.length; j++){
                                    if (callbacks[j] !== callback) newCallbacks.push(callbacks[j]);
                                }
                            }
                            object.events[names[i]] = newCallbacks;
                        }
                    };
                    /**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */ Events.trigger = function(object, eventNames, event) {
                        var names, name, callbacks, eventClone;
                        if (object.events) {
                            if (!event) event = {};
                            names = eventNames.split(' ');
                            for(var i = 0; i < names.length; i++){
                                name = names[i];
                                callbacks = object.events[name];
                                if (callbacks) {
                                    eventClone = Common.clone(event, false);
                                    eventClone.name = name;
                                    eventClone.source = object;
                                    for(var j = 0; j < callbacks.length; j++){
                                        callbacks[j].apply(object, [
                                            eventClone
                                        ]);
                                    }
                                }
                            }
                        }
                    };
                })();
            },
            {
                "./Common": 14
            }
        ],
        17: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/ var Matter = {};
                module1.exports = Matter;
                var Plugin = _dereq_('./Plugin');
                var Common = _dereq_('./Common');
                (function() {
                    /**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */ Matter.name = 'matter-js';
                    /**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */ Matter.version = '0.14.2';
                    /**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */ Matter.uses = [];
                    /**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */ Matter.used = [];
                    /**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */ Matter.use = function() {
                        Plugin.use(Matter, Array.prototype.slice.call(arguments));
                    };
                    /**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */ Matter.before = function(path, func) {
                        path = path.replace(/^Matter./, '');
                        return Common.chainPathBefore(Matter, path, func);
                    };
                    /**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */ Matter.after = function(path, func) {
                        path = path.replace(/^Matter./, '');
                        return Common.chainPathAfter(Matter, path, func);
                    };
                })();
            },
            {
                "./Common": 14,
                "./Plugin": 20
            }
        ],
        18: [
            function(_dereq_, module1, exports1) {},
            {
                "../body/Composite": 2,
                "./Common": 14
            }
        ],
        19: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/ var Mouse = {};
                module1.exports = Mouse;
                var Common = _dereq_('../core/Common');
                (function() {
                    /**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */ Mouse.create = function(element) {
                        var mouse = {};
                        if (!element) {
                            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');
                        }
                        mouse.element = element || document.body;
                        mouse.absolute = {
                            x: 0,
                            y: 0
                        };
                        mouse.position = {
                            x: 0,
                            y: 0
                        };
                        mouse.mousedownPosition = {
                            x: 0,
                            y: 0
                        };
                        mouse.mouseupPosition = {
                            x: 0,
                            y: 0
                        };
                        mouse.offset = {
                            x: 0,
                            y: 0
                        };
                        mouse.scale = {
                            x: 1,
                            y: 1
                        };
                        mouse.wheelDelta = 0;
                        mouse.button = -1;
                        mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;
                        mouse.sourceEvents = {
                            mousemove: null,
                            mousedown: null,
                            mouseup: null,
                            mousewheel: null
                        };
                        mouse.mousemove = function(event) {
                            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;
                            if (touches) {
                                mouse.button = 0;
                                event.preventDefault();
                            }
                            mouse.absolute.x = position.x;
                            mouse.absolute.y = position.y;
                            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                            mouse.sourceEvents.mousemove = event;
                        };
                        mouse.mousedown = function(event) {
                            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;
                            if (touches) {
                                mouse.button = 0;
                                event.preventDefault();
                            } else {
                                mouse.button = event.button;
                            }
                            mouse.absolute.x = position.x;
                            mouse.absolute.y = position.y;
                            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                            mouse.mousedownPosition.x = mouse.position.x;
                            mouse.mousedownPosition.y = mouse.position.y;
                            mouse.sourceEvents.mousedown = event;
                        };
                        mouse.mouseup = function(event) {
                            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;
                            if (touches) {
                                event.preventDefault();
                            }
                            mouse.button = -1;
                            mouse.absolute.x = position.x;
                            mouse.absolute.y = position.y;
                            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                            mouse.mouseupPosition.x = mouse.position.x;
                            mouse.mouseupPosition.y = mouse.position.y;
                            mouse.sourceEvents.mouseup = event;
                        };
                        mouse.mousewheel = function(event) {
                            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
                            event.preventDefault();
                        };
                        Mouse.setElement(mouse, mouse.element);
                        return mouse;
                    };
                    /**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */ Mouse.setElement = function(mouse, element) {
                        mouse.element = element;
                        element.addEventListener('mousemove', mouse.mousemove);
                        element.addEventListener('mousedown', mouse.mousedown);
                        element.addEventListener('mouseup', mouse.mouseup);
                        element.addEventListener('mousewheel', mouse.mousewheel);
                        element.addEventListener('DOMMouseScroll', mouse.mousewheel);
                        element.addEventListener('touchmove', mouse.mousemove);
                        element.addEventListener('touchstart', mouse.mousedown);
                        element.addEventListener('touchend', mouse.mouseup);
                    };
                    /**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */ Mouse.clearSourceEvents = function(mouse) {
                        mouse.sourceEvents.mousemove = null;
                        mouse.sourceEvents.mousedown = null;
                        mouse.sourceEvents.mouseup = null;
                        mouse.sourceEvents.mousewheel = null;
                        mouse.wheelDelta = 0;
                    };
                    /**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */ Mouse.setOffset = function(mouse, offset) {
                        mouse.offset.x = offset.x;
                        mouse.offset.y = offset.y;
                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                    };
                    /**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */ Mouse.setScale = function(mouse, scale) {
                        mouse.scale.x = scale.x;
                        mouse.scale.y = scale.y;
                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                    };
                    /**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */ Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {
                        var elementBounds = element.getBoundingClientRect(), rootNode = document.documentElement || document.body.parentNode || document.body, scrollX = window.pageXOffset !== undefined ? window.pageXOffset : rootNode.scrollLeft, scrollY = window.pageYOffset !== undefined ? window.pageYOffset : rootNode.scrollTop, touches = event.changedTouches, x, y;
                        if (touches) {
                            x = touches[0].pageX - elementBounds.left - scrollX;
                            y = touches[0].pageY - elementBounds.top - scrollY;
                        } else {
                            x = event.pageX - elementBounds.left - scrollX;
                            y = event.pageY - elementBounds.top - scrollY;
                        }
                        return {
                            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
                            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
                        };
                    };
                })();
            },
            {
                "../core/Common": 14
            }
        ],
        20: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/ var Plugin = {};
                module1.exports = Plugin;
                var Common = _dereq_('./Common');
                (function() {
                    Plugin._registry = {};
                    /**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */ Plugin.register = function(plugin) {
                        if (!Plugin.isPlugin(plugin)) {
                            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');
                        }
                        if (plugin.name in Plugin._registry) {
                            var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
                            if (pluginVersion > registeredVersion) {
                                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));
                                Plugin._registry[plugin.name] = plugin;
                            } else if (pluginVersion < registeredVersion) {
                                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));
                            } else if (plugin !== registered) {
                                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');
                            }
                        } else {
                            Plugin._registry[plugin.name] = plugin;
                        }
                        return plugin;
                    };
                    /**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */ Plugin.resolve = function(dependency) {
                        return Plugin._registry[Plugin.dependencyParse(dependency).name];
                    };
                    /**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */ Plugin.toString = function(plugin) {
                        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');
                    };
                    /**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */ Plugin.isPlugin = function(obj) {
                        return obj && obj.name && obj.version && obj.install;
                    };
                    /**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */ Plugin.isUsed = function(module1, name) {
                        return module1.used.indexOf(name) > -1;
                    };
                    /**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */ Plugin.isFor = function(plugin, module1) {
                        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
                        return !plugin.for || module1.name === parsed.name && Plugin.versionSatisfies(module1.version, parsed.range);
                    };
                    /**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick  indicates a dependency was resolved and installed.
     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross  indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */ Plugin.use = function(module1, plugins) {
                        module1.uses = (module1.uses || []).concat(plugins || []);
                        if (module1.uses.length === 0) {
                            Common.warn('Plugin.use:', Plugin.toString(module1), 'does not specify any dependencies to install.');
                            return;
                        }
                        var dependencies = Plugin.dependencies(module1), sortedDependencies = Common.topologicalSort(dependencies), status = [];
                        for(var i = 0; i < sortedDependencies.length; i += 1){
                            if (sortedDependencies[i] === module1.name) {
                                continue;
                            }
                            var plugin = Plugin.resolve(sortedDependencies[i]);
                            if (!plugin) {
                                status.push(' ' + sortedDependencies[i]);
                                continue;
                            }
                            if (Plugin.isUsed(module1, plugin.name)) {
                                continue;
                            }
                            if (!Plugin.isFor(plugin, module1)) {
                                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module1) + '.');
                                plugin._warned = true;
                            }
                            if (plugin.install) {
                                plugin.install(module1);
                            } else {
                                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');
                                plugin._warned = true;
                            }
                            if (plugin._warned) {
                                status.push(' ' + Plugin.toString(plugin));
                                delete plugin._warned;
                            } else {
                                status.push(' ' + Plugin.toString(plugin));
                            }
                            module1.used.push(plugin.name);
                        }
                        if (status.length > 0) {
                            Common.info(status.join('  '));
                        }
                    };
                    /**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */ Plugin.dependencies = function(module1, tracked) {
                        var parsedBase = Plugin.dependencyParse(module1), name = parsedBase.name;
                        tracked = tracked || {};
                        if (name in tracked) {
                            return;
                        }
                        module1 = Plugin.resolve(module1) || module1;
                        tracked[name] = Common.map(module1.uses || [], function(dependency) {
                            if (Plugin.isPlugin(dependency)) {
                                Plugin.register(dependency);
                            }
                            var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
                            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                                Common.warn('Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy', Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.');
                                resolved._warned = true;
                                module1._warned = true;
                            } else if (!resolved) {
                                Common.warn('Plugin.dependencies:', Plugin.toString(dependency), 'used by', Plugin.toString(parsedBase), 'could not be resolved.');
                                module1._warned = true;
                            }
                            return parsed.name;
                        });
                        for(var i = 0; i < tracked[name].length; i += 1){
                            Plugin.dependencies(tracked[name][i], tracked);
                        }
                        return tracked;
                    };
                    /**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */ Plugin.dependencyParse = function(dependency) {
                        if (Common.isString(dependency)) {
                            var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
                            if (!pattern.test(dependency)) {
                                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');
                            }
                            return {
                                name: dependency.split('@')[0],
                                range: dependency.split('@')[1] || '*'
                            };
                        }
                        return {
                            name: dependency.name,
                            range: dependency.range || dependency.version
                        };
                    };
                    /**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */ Plugin.versionParse = function(range) {
                        var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;
                        if (!pattern.test(range)) {
                            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');
                        }
                        var identifiers = range.split('-');
                        range = identifiers[0];
                        var isRange = isNaN(Number(range[0])), version = isRange ? range.substr(1) : range, parts = Common.map(version.split('.'), function(part) {
                            return Number(part);
                        });
                        return {
                            isRange: isRange,
                            version: version,
                            range: range,
                            operator: isRange ? range[0] : '',
                            parts: parts,
                            prerelease: identifiers[1],
                            number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
                        };
                    };
                    /**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */ Plugin.versionSatisfies = function(version, range) {
                        range = range || '*';
                        var rangeParsed = Plugin.versionParse(range), rangeParts = rangeParsed.parts, versionParsed = Plugin.versionParse(version), versionParts = versionParsed.parts;
                        if (rangeParsed.isRange) {
                            if (rangeParsed.operator === '*' || version === '*') {
                                return true;
                            }
                            if (rangeParsed.operator === '~') {
                                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                            }
                            if (rangeParsed.operator === '^') {
                                if (rangeParts[0] > 0) {
                                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                                }
                                if (rangeParts[1] > 0) {
                                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                                }
                                return versionParts[2] === rangeParts[2];
                            }
                        }
                        return version === range || version === '*';
                    };
                })();
            },
            {
                "./Common": 14
            }
        ],
        21: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/ var Runner = {};
                module1.exports = Runner;
                var Events = _dereq_('./Events');
                var Engine = _dereq_('./Engine');
                var Common = _dereq_('./Common');
                (function() {
                    var _requestAnimationFrame, _cancelAnimationFrame;
                    if (typeof window !== 'undefined') {
                        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
                        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
                    }
                    if (!_requestAnimationFrame) {
                        var _frameTimeout;
                        _requestAnimationFrame = function(callback) {
                            _frameTimeout = setTimeout(function() {
                                callback(Common.now());
                            }, 1000 / 60);
                        };
                        _cancelAnimationFrame = function() {
                            clearTimeout(_frameTimeout);
                        };
                    }
                    /**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */ Runner.create = function(options) {
                        var defaults = {
                            fps: 60,
                            correction: 1,
                            deltaSampleSize: 60,
                            counterTimestamp: 0,
                            frameCounter: 0,
                            deltaHistory: [],
                            timePrev: null,
                            timeScalePrev: 1,
                            frameRequestId: null,
                            isFixed: false,
                            enabled: true
                        };
                        var runner = Common.extend(defaults, options);
                        runner.delta = runner.delta || 1000 / runner.fps;
                        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;
                        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);
                        runner.fps = 1000 / runner.delta;
                        return runner;
                    };
                    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method run
     * @param {engine} engine
     */ Runner.run = function(runner, engine) {
                        // create runner if engine is first argument
                        if (typeof runner.positionIterations !== 'undefined') {
                            engine = runner;
                            runner = Runner.create();
                        }
                        (function render(time) {
                            runner.frameRequestId = _requestAnimationFrame(render);
                            if (time && runner.enabled) {
                                Runner.tick(runner, engine, time);
                            }
                        })();
                        return runner;
                    };
                    /**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
     * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method tick
     * @param {runner} runner
     * @param {engine} engine
     * @param {number} time
     */ Runner.tick = function(runner, engine, time) {
                        var timing = engine.timing, correction = 1, delta;
                        // create an event object
                        var event = {
                            timestamp: timing.timestamp
                        };
                        Events.trigger(runner, 'beforeTick', event);
                        Events.trigger(engine, 'beforeTick', event); // @deprecated
                        if (runner.isFixed) {
                            // fixed timestep
                            delta = runner.delta;
                        } else {
                            // dynamic timestep based on wall clock between calls
                            delta = time - runner.timePrev || runner.delta;
                            runner.timePrev = time;
                            // optimistically filter delta over a few frames, to improve stability
                            runner.deltaHistory.push(delta);
                            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
                            delta = Math.min.apply(null, runner.deltaHistory);
                            // limit delta
                            delta = delta < runner.deltaMin ? runner.deltaMin : delta;
                            delta = delta > runner.deltaMax ? runner.deltaMax : delta;
                            // correction for delta
                            correction = delta / runner.delta;
                            // update engine timing object
                            runner.delta = delta;
                        }
                        // time correction for time scaling
                        if (runner.timeScalePrev !== 0) correction *= timing.timeScale / runner.timeScalePrev;
                        if (timing.timeScale === 0) correction = 0;
                        runner.timeScalePrev = timing.timeScale;
                        runner.correction = correction;
                        // fps counter
                        runner.frameCounter += 1;
                        if (time - runner.counterTimestamp >= 1000) {
                            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);
                            runner.counterTimestamp = time;
                            runner.frameCounter = 0;
                        }
                        Events.trigger(runner, 'tick', event);
                        Events.trigger(engine, 'tick', event); // @deprecated
                        // if world has been modified, clear the render scene graph
                        if (engine.world.isModified && engine.render && engine.render.controller && engine.render.controller.clear) {
                            engine.render.controller.clear(engine.render); // @deprecated
                        }
                        // update
                        Events.trigger(runner, 'beforeUpdate', event);
                        Engine.update(engine, delta, correction);
                        Events.trigger(runner, 'afterUpdate', event);
                        // render
                        // @deprecated
                        if (engine.render && engine.render.controller) {
                            Events.trigger(runner, 'beforeRender', event);
                            Events.trigger(engine, 'beforeRender', event); // @deprecated
                            engine.render.controller.world(engine.render);
                            Events.trigger(runner, 'afterRender', event);
                            Events.trigger(engine, 'afterRender', event); // @deprecated
                        }
                        Events.trigger(runner, 'afterTick', event);
                        Events.trigger(engine, 'afterTick', event); // @deprecated
                    };
                    /**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method stop
     * @param {runner} runner
     */ Runner.stop = function(runner) {
                        _cancelAnimationFrame(runner.frameRequestId);
                    };
                    /**
     * Alias for `Runner.run`.
     * @method start
     * @param {runner} runner
     * @param {engine} engine
     */ Runner.start = function(runner, engine) {
                        Runner.run(runner, engine);
                    };
                /*
    *
    *  Events Documentation
    *
    */ /**
    * Fired at the start of a tick, before any updates to the engine or timing
    *
    * @event beforeTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after engine timing updated, but just before update
    *
    * @event tick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired at the end of a tick, after engine update and after rendering
    *
    * @event afterTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired before update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after update
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */ /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * A flag that specifies whether the runner is running or not.
     *
     * @property enabled
     * @type boolean
     * @default true
     */ /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     *
     * @property isFixed
     * @type boolean
     * @default false
     */ /**
     * A `Number` that specifies the time step between updates in milliseconds.
     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
     *
     * @property delta
     * @type number
     * @default 1000 / 60
     */ })();
            },
            {
                "./Common": 14,
                "./Engine": 15,
                "./Events": 16
            }
        ],
        22: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/ var Sleeping = {};
                module1.exports = Sleeping;
                var Events = _dereq_('./Events');
                (function() {
                    Sleeping._motionWakeThreshold = 0.18;
                    Sleeping._motionSleepThreshold = 0.08;
                    Sleeping._minBias = 0.9;
                    /**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */ Sleeping.update = function(bodies, timeScale) {
                        var timeFactor = timeScale * timeScale * timeScale;
                        // update bodies sleeping status
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i], motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
                            // wake up bodies if they have a force applied
                            if (body.force.x !== 0 || body.force.y !== 0) {
                                Sleeping.set(body, false);
                                continue;
                            }
                            var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
                            // biased average motion estimation between frames
                            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
                            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                                body.sleepCounter += 1;
                                if (body.sleepCounter >= body.sleepThreshold) Sleeping.set(body, true);
                            } else if (body.sleepCounter > 0) {
                                body.sleepCounter -= 1;
                            }
                        }
                    };
                    /**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */ Sleeping.afterCollisions = function(pairs, timeScale) {
                        var timeFactor = timeScale * timeScale * timeScale;
                        // wake up bodies involved in collisions
                        for(var i = 0; i < pairs.length; i++){
                            var pair = pairs[i];
                            // don't wake inactive pairs
                            if (!pair.isActive) continue;
                            var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
                            // don't wake if at least one body is static
                            if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;
                            if (bodyA.isSleeping || bodyB.isSleeping) {
                                var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                                    Sleeping.set(sleepingBody, false);
                                }
                            }
                        }
                    };
                    /**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */ Sleeping.set = function(body, isSleeping) {
                        var wasSleeping = body.isSleeping;
                        if (isSleeping) {
                            body.isSleeping = true;
                            body.sleepCounter = body.sleepThreshold;
                            body.positionImpulse.x = 0;
                            body.positionImpulse.y = 0;
                            body.positionPrev.x = body.position.x;
                            body.positionPrev.y = body.position.y;
                            body.anglePrev = body.angle;
                            body.speed = 0;
                            body.angularSpeed = 0;
                            body.motion = 0;
                            if (!wasSleeping) {
                                Events.trigger(body, 'sleepStart');
                            }
                        } else {
                            body.isSleeping = false;
                            body.sleepCounter = 0;
                            if (wasSleeping) {
                                Events.trigger(body, 'sleepEnd');
                            }
                        }
                    };
                })();
            },
            {
                "./Events": 16
            }
        ],
        23: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/ // TODO: true circle bodies
                var Bodies = {};
                module1.exports = Bodies;
                var Vertices = _dereq_('../geometry/Vertices');
                var Common = _dereq_('../core/Common');
                var Body = _dereq_('../body/Body');
                var Bounds = _dereq_('../geometry/Bounds');
                var Vector = _dereq_('../geometry/Vector');
                var decomp;
                (function() {
                    /**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */ Bodies.rectangle = function(x, y, width, height, options) {
                        options = options || {};
                        var rectangle = {
                            label: 'Rectangle Body',
                            position: {
                                x: x,
                                y: y
                            },
                            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)
                        };
                        if (options.chamfer) {
                            var chamfer = options.chamfer;
                            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                            delete options.chamfer;
                        }
                        return Body.create(Common.extend({}, rectangle, options));
                    };
                    /**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */ Bodies.trapezoid = function(x, y, width, height, slope, options) {
                        options = options || {};
                        slope *= 0.5;
                        var roof = (1 - slope * 2) * width;
                        var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;
                        if (slope < 0.5) {
                            verticesPath = 'L 0 0 L ' + x1 + ' ' + -height + ' L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';
                        } else {
                            verticesPath = 'L 0 0 L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';
                        }
                        var trapezoid = {
                            label: 'Trapezoid Body',
                            position: {
                                x: x,
                                y: y
                            },
                            vertices: Vertices.fromPath(verticesPath)
                        };
                        if (options.chamfer) {
                            var chamfer = options.chamfer;
                            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                            delete options.chamfer;
                        }
                        return Body.create(Common.extend({}, trapezoid, options));
                    };
                    /**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */ Bodies.circle = function(x, y, radius, options, maxSides) {
                        options = options || {};
                        var circle = {
                            label: 'Circle Body',
                            circleRadius: radius
                        };
                        // approximate circles with polygons until true circles implemented in SAT
                        maxSides = maxSides || 25;
                        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
                        // optimisation: always use even number of sides (half the number of unique axes)
                        if (sides % 2 === 1) sides += 1;
                        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
                    };
                    /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */ Bodies.polygon = function(x, y, sides, radius, options) {
                        options = options || {};
                        if (sides < 3) return Bodies.circle(x, y, radius, options);
                        var theta = 2 * Math.PI / sides, path = '', offset = theta * 0.5;
                        for(var i = 0; i < sides; i += 1){
                            var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
                            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
                        }
                        var polygon = {
                            label: 'Polygon Body',
                            position: {
                                x: x,
                                y: y
                            },
                            vertices: Vertices.fromPath(path)
                        };
                        if (options.chamfer) {
                            var chamfer = options.chamfer;
                            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                            delete options.chamfer;
                        }
                        return Body.create(Common.extend({}, polygon, options));
                    };
                    /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */ Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
                        if (!decomp) {
                            decomp = Common._requireGlobal('decomp', 'poly-decomp');
                        }
                        var body, parts, isConvex, vertices, i, j, k, v, z;
                        options = options || {};
                        parts = [];
                        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;
                        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;
                        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;
                        if (!decomp) {
                            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');
                        }
                        // ensure vertexSets is an array of arrays
                        if (!Common.isArray(vertexSets[0])) {
                            vertexSets = [
                                vertexSets
                            ];
                        }
                        for(v = 0; v < vertexSets.length; v += 1){
                            vertices = vertexSets[v];
                            isConvex = Vertices.isConvex(vertices);
                            if (isConvex || !decomp) {
                                if (isConvex) {
                                    vertices = Vertices.clockwiseSort(vertices);
                                } else {
                                    // fallback to convex hull when decomposition is not possible
                                    vertices = Vertices.hull(vertices);
                                }
                                parts.push({
                                    position: {
                                        x: x,
                                        y: y
                                    },
                                    vertices: vertices
                                });
                            } else {
                                // initialise a decomposition
                                var concave = vertices.map(function(vertex) {
                                    return [
                                        vertex.x,
                                        vertex.y
                                    ];
                                });
                                // vertices are concave and simple, we can decompose into parts
                                decomp.makeCCW(concave);
                                if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear);
                                // use the quick decomposition algorithm (Bayazit)
                                var decomposed = decomp.quickDecomp(concave);
                                // for each decomposed chunk
                                for(i = 0; i < decomposed.length; i++){
                                    var chunk = decomposed[i];
                                    // convert vertices into the correct structure
                                    var chunkVertices = chunk.map(function(vertices) {
                                        return {
                                            x: vertices[0],
                                            y: vertices[1]
                                        };
                                    });
                                    // skip small chunks
                                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue;
                                    // create a compound part
                                    parts.push({
                                        position: Vertices.centre(chunkVertices),
                                        vertices: chunkVertices
                                    });
                                }
                            }
                        }
                        // create body parts
                        for(i = 0; i < parts.length; i++){
                            parts[i] = Body.create(Common.extend(parts[i], options));
                        }
                        // flag internal edges (coincident part edges)
                        if (flagInternal) {
                            var coincident_max_dist = 5;
                            for(i = 0; i < parts.length; i++){
                                var partA = parts[i];
                                for(j = i + 1; j < parts.length; j++){
                                    var partB = parts[j];
                                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                                        var pav = partA.vertices, pbv = partB.vertices;
                                        // iterate vertices of both parts
                                        for(k = 0; k < partA.vertices.length; k++){
                                            for(z = 0; z < partB.vertices.length; z++){
                                                // find distances between the vertices
                                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])), db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
                                                // if both vertices are very close, consider the edge concident (internal)
                                                if (da < coincident_max_dist && db < coincident_max_dist) {
                                                    pav[k].isInternal = true;
                                                    pbv[z].isInternal = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (parts.length > 1) {
                            // create the parent body to be returned, that contains generated compound parts
                            body = Body.create(Common.extend({
                                parts: parts.slice(0)
                            }, options));
                            Body.setPosition(body, {
                                x: x,
                                y: y
                            });
                            return body;
                        } else {
                            return parts[0];
                        }
                    };
                })();
            },
            {
                "../body/Body": 1,
                "../core/Common": 14,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29
            }
        ],
        24: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/ var Composites = {};
                module1.exports = Composites;
                var Composite = _dereq_('../body/Composite');
                var Constraint = _dereq_('../constraint/Constraint');
                var Common = _dereq_('../core/Common');
                var Body = _dereq_('../body/Body');
                var Bodies = _dereq_('./Bodies');
                (function() {
                    /**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */ Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
                        var stack = Composite.create({
                            label: 'Stack'
                        }), x = xx, y = yy, lastBody, i = 0;
                        for(var row = 0; row < rows; row++){
                            var maxHeight = 0;
                            for(var column = 0; column < columns; column++){
                                var body = callback(x, y, column, row, lastBody, i);
                                if (body) {
                                    var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                                    if (bodyHeight > maxHeight) maxHeight = bodyHeight;
                                    Body.translate(body, {
                                        x: bodyWidth * 0.5,
                                        y: bodyHeight * 0.5
                                    });
                                    x = body.bounds.max.x + columnGap;
                                    Composite.addBody(stack, body);
                                    lastBody = body;
                                    i += 1;
                                } else {
                                    x += columnGap;
                                }
                            }
                            y += maxHeight + rowGap;
                            x = xx;
                        }
                        return stack;
                    };
                    /**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} [options]
     * @return {composite} A new composite containing objects chained together with constraints
     */ Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
                        var bodies = composite.bodies;
                        for(var i = 1; i < bodies.length; i++){
                            var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
                            var defaults = {
                                bodyA: bodyA,
                                pointA: {
                                    x: bodyAWidth * xOffsetA,
                                    y: bodyAHeight * yOffsetA
                                },
                                bodyB: bodyB,
                                pointB: {
                                    x: bodyBWidth * xOffsetB,
                                    y: bodyBHeight * yOffsetB
                                }
                            };
                            var constraint = Common.extend(defaults, options);
                            Composite.addConstraint(composite, Constraint.create(constraint));
                        }
                        composite.label += ' Chain';
                        return composite;
                    };
                    /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} [options]
     * @return {composite} The composite containing objects meshed together with constraints
     */ Composites.mesh = function(composite, columns, rows, crossBrace, options) {
                        var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
                        for(row = 0; row < rows; row++){
                            for(col = 1; col < columns; col++){
                                bodyA = bodies[col - 1 + row * columns];
                                bodyB = bodies[col + row * columns];
                                Composite.addConstraint(composite, Constraint.create(Common.extend({
                                    bodyA: bodyA,
                                    bodyB: bodyB
                                }, options)));
                            }
                            if (row > 0) {
                                for(col = 0; col < columns; col++){
                                    bodyA = bodies[col + (row - 1) * columns];
                                    bodyB = bodies[col + row * columns];
                                    Composite.addConstraint(composite, Constraint.create(Common.extend({
                                        bodyA: bodyA,
                                        bodyB: bodyB
                                    }, options)));
                                    if (crossBrace && col > 0) {
                                        bodyC = bodies[col - 1 + (row - 1) * columns];
                                        Composite.addConstraint(composite, Constraint.create(Common.extend({
                                            bodyA: bodyC,
                                            bodyB: bodyB
                                        }, options)));
                                    }
                                    if (crossBrace && col < columns - 1) {
                                        bodyC = bodies[col + 1 + (row - 1) * columns];
                                        Composite.addConstraint(composite, Constraint.create(Common.extend({
                                            bodyA: bodyC,
                                            bodyB: bodyB
                                        }, options)));
                                    }
                                }
                            }
                        }
                        composite.label += ' Mesh';
                        return composite;
                    };
                    /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */ Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
                        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
                            var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
                            if (row > actualRows) return;
                            // reverse row order
                            row = actualRows - row;
                            var start = row, end = columns - 1 - row;
                            if (column < start || column > end) return;
                            // retroactively fix the first body's position, since width was unknown
                            if (i === 1) {
                                Body.translate(lastBody, {
                                    x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,
                                    y: 0
                                });
                            }
                            var xOffset = lastBody ? column * lastBodyWidth : 0;
                            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
                        });
                    };
                    /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */ Composites.newtonsCradle = function(xx, yy, number, size, length) {
                        var newtonsCradle = Composite.create({
                            label: 'Newtons Cradle'
                        });
                        for(var i = 0; i < number; i++){
                            var separation = 1.9, circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {
                                inertia: Infinity,
                                restitution: 1,
                                friction: 0,
                                frictionAir: 0.0001,
                                slop: 1
                            }), constraint = Constraint.create({
                                pointA: {
                                    x: xx + i * (size * separation),
                                    y: yy
                                },
                                bodyB: circle
                            });
                            Composite.addBody(newtonsCradle, circle);
                            Composite.addConstraint(newtonsCradle, constraint);
                        }
                        return newtonsCradle;
                    };
                    /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */ Composites.car = function(xx, yy, width, height, wheelSize) {
                        var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
                        var car = Composite.create({
                            label: 'Car'
                        }), body = Bodies.rectangle(xx, yy, width, height, {
                            collisionFilter: {
                                group: group
                            },
                            chamfer: {
                                radius: height * 0.5
                            },
                            density: 0.0002
                        });
                        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {
                            collisionFilter: {
                                group: group
                            },
                            friction: 0.8
                        });
                        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {
                            collisionFilter: {
                                group: group
                            },
                            friction: 0.8
                        });
                        var axelA = Constraint.create({
                            bodyB: body,
                            pointB: {
                                x: wheelAOffset,
                                y: wheelYOffset
                            },
                            bodyA: wheelA,
                            stiffness: 1,
                            length: 0
                        });
                        var axelB = Constraint.create({
                            bodyB: body,
                            pointB: {
                                x: wheelBOffset,
                                y: wheelYOffset
                            },
                            bodyA: wheelB,
                            stiffness: 1,
                            length: 0
                        });
                        Composite.addBody(car, body);
                        Composite.addBody(car, wheelA);
                        Composite.addBody(car, wheelB);
                        Composite.addConstraint(car, axelA);
                        Composite.addConstraint(car, axelB);
                        return car;
                    };
                    /**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */ Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
                        particleOptions = Common.extend({
                            inertia: Infinity
                        }, particleOptions);
                        constraintOptions = Common.extend({
                            stiffness: 0.2,
                            render: {
                                type: 'line',
                                anchors: false
                            }
                        }, constraintOptions);
                        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
                            return Bodies.circle(x, y, particleRadius, particleOptions);
                        });
                        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
                        softBody.label = 'Soft Body';
                        return softBody;
                    };
                })();
            },
            {
                "../body/Body": 1,
                "../body/Composite": 2,
                "../constraint/Constraint": 12,
                "../core/Common": 14,
                "./Bodies": 23
            }
        ],
        25: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/ var Axes = {};
                module1.exports = Axes;
                var Vector = _dereq_('../geometry/Vector');
                var Common = _dereq_('../core/Common');
                (function() {
                    /**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */ Axes.fromVertices = function(vertices) {
                        var axes = {};
                        // find the unique axes, using edge normal gradients
                        for(var i = 0; i < vertices.length; i++){
                            var j = (i + 1) % vertices.length, normal = Vector.normalise({
                                x: vertices[j].y - vertices[i].y,
                                y: vertices[i].x - vertices[j].x
                            }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
                            // limit precision
                            gradient = gradient.toFixed(3).toString();
                            axes[gradient] = normal;
                        }
                        return Common.values(axes);
                    };
                    /**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */ Axes.rotate = function(axes, angle) {
                        if (angle === 0) return;
                        var cos = Math.cos(angle), sin = Math.sin(angle);
                        for(var i = 0; i < axes.length; i++){
                            var axis = axes[i], xx;
                            xx = axis.x * cos - axis.y * sin;
                            axis.y = axis.x * sin + axis.y * cos;
                            axis.x = xx;
                        }
                    };
                })();
            },
            {
                "../core/Common": 14,
                "../geometry/Vector": 28
            }
        ],
        26: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/ var Bounds = {};
                module1.exports = Bounds;
                (function() {
                    /**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */ Bounds.create = function(vertices) {
                        var bounds = {
                            min: {
                                x: 0,
                                y: 0
                            },
                            max: {
                                x: 0,
                                y: 0
                            }
                        };
                        if (vertices) Bounds.update(bounds, vertices);
                        return bounds;
                    };
                    /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */ Bounds.update = function(bounds, vertices, velocity) {
                        bounds.min.x = Infinity;
                        bounds.max.x = -Infinity;
                        bounds.min.y = Infinity;
                        bounds.max.y = -Infinity;
                        for(var i = 0; i < vertices.length; i++){
                            var vertex = vertices[i];
                            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;
                            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;
                            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;
                            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;
                        }
                        if (velocity) {
                            if (velocity.x > 0) {
                                bounds.max.x += velocity.x;
                            } else {
                                bounds.min.x += velocity.x;
                            }
                            if (velocity.y > 0) {
                                bounds.max.y += velocity.y;
                            } else {
                                bounds.min.y += velocity.y;
                            }
                        }
                    };
                    /**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */ Bounds.contains = function(bounds, point) {
                        return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
                    };
                    /**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */ Bounds.overlaps = function(boundsA, boundsB) {
                        return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
                    };
                    /**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */ Bounds.translate = function(bounds, vector) {
                        bounds.min.x += vector.x;
                        bounds.max.x += vector.x;
                        bounds.min.y += vector.y;
                        bounds.max.y += vector.y;
                    };
                    /**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */ Bounds.shift = function(bounds, position) {
                        var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
                        bounds.min.x = position.x;
                        bounds.max.x = position.x + deltaX;
                        bounds.min.y = position.y;
                        bounds.max.y = position.y + deltaY;
                    };
                })();
            },
            {}
        ],
        27: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/ var Svg = {};
                module1.exports = Svg;
                var Bounds = _dereq_('../geometry/Bounds');
                var Common = _dereq_('../core/Common');
                (function() {
                    /**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * You must load the `pathseg.js` polyfill on newer browsers.
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */ Svg.pathToVertices = function(path, sampleLength) {
                        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {
                            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');
                        }
                        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
                        var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;
                        sampleLength = sampleLength || 15;
                        var addPoint = function(px, py, pathSegType) {
                            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
                            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
                            // when the last point doesn't equal the current point add the current point
                            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                                if (lastPoint && isRelative) {
                                    lx = lastPoint.x;
                                    ly = lastPoint.y;
                                } else {
                                    lx = 0;
                                    ly = 0;
                                }
                                var point = {
                                    x: lx + px,
                                    y: ly + py
                                };
                                // set last point
                                if (isRelative || !lastPoint) {
                                    lastPoint = point;
                                }
                                points.push(point);
                                x = lx + px;
                                y = ly + py;
                            }
                        };
                        var addSegmentPoint = function(segment) {
                            var segType = segment.pathSegTypeAsLetter.toUpperCase();
                            // skip path ends
                            if (segType === 'Z') return;
                            // map segment to x and y
                            switch(segType){
                                case 'M':
                                case 'L':
                                case 'T':
                                case 'C':
                                case 'S':
                                case 'Q':
                                    x = segment.x;
                                    y = segment.y;
                                    break;
                                case 'H':
                                    x = segment.x;
                                    break;
                                case 'V':
                                    y = segment.y;
                                    break;
                            }
                            addPoint(x, y, segment.pathSegType);
                        };
                        // ensure path is absolute
                        Svg._svgPathToAbsolute(path);
                        // get total length
                        total = path.getTotalLength();
                        // queue segments
                        segments = [];
                        for(i = 0; i < path.pathSegList.numberOfItems; i += 1)segments.push(path.pathSegList.getItem(i));
                        segmentsQueue = segments.concat();
                        // sample through path
                        while(length < total){
                            // get segment at position
                            segmentIndex = path.getPathSegAtLength(length);
                            segment = segments[segmentIndex];
                            // new segment
                            if (segment != lastSegment) {
                                while(segmentsQueue.length && segmentsQueue[0] != segment)addSegmentPoint(segmentsQueue.shift());
                                lastSegment = segment;
                            }
                            // add points in between when curving
                            // TODO: adaptive sampling
                            switch(segment.pathSegTypeAsLetter.toUpperCase()){
                                case 'C':
                                case 'T':
                                case 'S':
                                case 'Q':
                                case 'A':
                                    point = path.getPointAtLength(length);
                                    addPoint(point.x, point.y, 0);
                                    break;
                            }
                            // increment by sample value
                            length += sampleLength;
                        }
                        // add remaining segments not passed by sampling
                        for(i = 0, il = segmentsQueue.length; i < il; ++i)addSegmentPoint(segmentsQueue[i]);
                        return points;
                    };
                    Svg._svgPathToAbsolute = function(path) {
                        // http://phrogz.net/convert-svg-path-to-all-absolute-commands
                        // Copyright (c) Gavin Kistner
                        // http://phrogz.net/js/_ReuseLicense.txt
                        // Modifications: tidy formatting and naming
                        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;
                        for(var i = 0; i < len; ++i){
                            var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;
                            if (/[MLHVCSQTA]/.test(segType)) {
                                if ('x' in seg) x = seg.x;
                                if ('y' in seg) y = seg.y;
                            } else {
                                if ('x1' in seg) x1 = x + seg.x1;
                                if ('x2' in seg) x2 = x + seg.x2;
                                if ('y1' in seg) y1 = y + seg.y1;
                                if ('y2' in seg) y2 = y + seg.y2;
                                if ('x' in seg) x += seg.x;
                                if ('y' in seg) y += seg.y;
                                switch(segType){
                                    case 'm':
                                        segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                                        break;
                                    case 'l':
                                        segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                                        break;
                                    case 'h':
                                        segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                                        break;
                                    case 'v':
                                        segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                                        break;
                                    case 'c':
                                        segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                                        break;
                                    case 's':
                                        segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                                        break;
                                    case 'q':
                                        segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                                        break;
                                    case 't':
                                        segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                                        break;
                                    case 'a':
                                        segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                                        break;
                                    case 'z':
                                    case 'Z':
                                        x = x0;
                                        y = y0;
                                        break;
                                }
                            }
                            if (segType == 'M' || segType == 'm') {
                                x0 = x;
                                y0 = y;
                            }
                        }
                    };
                })();
            },
            {
                "../core/Common": 14,
                "../geometry/Bounds": 26
            }
        ],
        28: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/ // TODO: consider params for reusing vector objects
                var Vector = {};
                module1.exports = Vector;
                (function() {
                    /**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */ Vector.create = function(x, y) {
                        return {
                            x: x || 0,
                            y: y || 0
                        };
                    };
                    /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */ Vector.clone = function(vector) {
                        return {
                            x: vector.x,
                            y: vector.y
                        };
                    };
                    /**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */ Vector.magnitude = function(vector) {
                        return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                    };
                    /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */ Vector.magnitudeSquared = function(vector) {
                        return vector.x * vector.x + vector.y * vector.y;
                    };
                    /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} [output]
     * @return {vector} The vector rotated about (0, 0)
     */ Vector.rotate = function(vector, angle, output) {
                        var cos = Math.cos(angle), sin = Math.sin(angle);
                        if (!output) output = {};
                        var x = vector.x * cos - vector.y * sin;
                        output.y = vector.x * sin + vector.y * cos;
                        output.x = x;
                        return output;
                    };
                    /**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */ Vector.rotateAbout = function(vector, angle, point, output) {
                        var cos = Math.cos(angle), sin = Math.sin(angle);
                        if (!output) output = {};
                        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
                        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
                        output.x = x;
                        return output;
                    };
                    /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */ Vector.normalise = function(vector) {
                        var magnitude = Vector.magnitude(vector);
                        if (magnitude === 0) return {
                            x: 0,
                            y: 0
                        };
                        return {
                            x: vector.x / magnitude,
                            y: vector.y / magnitude
                        };
                    };
                    /**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */ Vector.dot = function(vectorA, vectorB) {
                        return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
                    };
                    /**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */ Vector.cross = function(vectorA, vectorB) {
                        return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
                    };
                    /**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */ Vector.cross3 = function(vectorA, vectorB, vectorC) {
                        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
                    };
                    /**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */ Vector.add = function(vectorA, vectorB, output) {
                        if (!output) output = {};
                        output.x = vectorA.x + vectorB.x;
                        output.y = vectorA.y + vectorB.y;
                        return output;
                    };
                    /**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */ Vector.sub = function(vectorA, vectorB, output) {
                        if (!output) output = {};
                        output.x = vectorA.x - vectorB.x;
                        output.y = vectorA.y - vectorB.y;
                        return output;
                    };
                    /**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */ Vector.mult = function(vector, scalar) {
                        return {
                            x: vector.x * scalar,
                            y: vector.y * scalar
                        };
                    };
                    /**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */ Vector.div = function(vector, scalar) {
                        return {
                            x: vector.x / scalar,
                            y: vector.y / scalar
                        };
                    };
                    /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */ Vector.perp = function(vector, negate) {
                        negate = negate === true ? -1 : 1;
                        return {
                            x: negate * -vector.y,
                            y: negate * vector.x
                        };
                    };
                    /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */ Vector.neg = function(vector) {
                        return {
                            x: -vector.x,
                            y: -vector.y
                        };
                    };
                    /**
     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */ Vector.angle = function(vectorA, vectorB) {
                        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
                    };
                    /**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */ Vector._temp = [
                        Vector.create(),
                        Vector.create(),
                        Vector.create(),
                        Vector.create(),
                        Vector.create(),
                        Vector.create()
                    ];
                })();
            },
            {}
        ],
        29: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/ var Vertices = {};
                module1.exports = Vertices;
                var Vector = _dereq_('../geometry/Vector');
                var Common = _dereq_('../core/Common');
                (function() {
                    /**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */ Vertices.create = function(points, body) {
                        var vertices = [];
                        for(var i = 0; i < points.length; i++){
                            var point = points[i], vertex = {
                                x: point.x,
                                y: point.y,
                                index: i,
                                body: body,
                                isInternal: false
                            };
                            vertices.push(vertex);
                        }
                        return vertices;
                    };
                    /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */ Vertices.fromPath = function(path, body) {
                        var pathPattern = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig, points = [];
                        path.replace(pathPattern, function(match, x, y) {
                            points.push({
                                x: parseFloat(x),
                                y: parseFloat(y)
                            });
                        });
                        return Vertices.create(points, body);
                    };
                    /**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */ Vertices.centre = function(vertices) {
                        var area = Vertices.area(vertices, true), centre = {
                            x: 0,
                            y: 0
                        }, cross, temp, j;
                        for(var i = 0; i < vertices.length; i++){
                            j = (i + 1) % vertices.length;
                            cross = Vector.cross(vertices[i], vertices[j]);
                            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
                            centre = Vector.add(centre, temp);
                        }
                        return Vector.div(centre, 6 * area);
                    };
                    /**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */ Vertices.mean = function(vertices) {
                        var average = {
                            x: 0,
                            y: 0
                        };
                        for(var i = 0; i < vertices.length; i++){
                            average.x += vertices[i].x;
                            average.y += vertices[i].y;
                        }
                        return Vector.div(average, vertices.length);
                    };
                    /**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */ Vertices.area = function(vertices, signed) {
                        var area = 0, j = vertices.length - 1;
                        for(var i = 0; i < vertices.length; i++){
                            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
                            j = i;
                        }
                        if (signed) return area / 2;
                        return Math.abs(area) / 2;
                    };
                    /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */ Vertices.inertia = function(vertices, mass) {
                        var numerator = 0, denominator = 0, v = vertices, cross, j;
                        // find the polygon's moment of inertia, using second moment of area
                        // from equations at http://www.physicsforums.com/showthread.php?t=25293
                        for(var n = 0; n < v.length; n++){
                            j = (n + 1) % v.length;
                            cross = Math.abs(Vector.cross(v[j], v[n]));
                            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
                            denominator += cross;
                        }
                        return mass / 6 * (numerator / denominator);
                    };
                    /**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */ Vertices.translate = function(vertices, vector, scalar) {
                        var i;
                        if (scalar) {
                            for(i = 0; i < vertices.length; i++){
                                vertices[i].x += vector.x * scalar;
                                vertices[i].y += vector.y * scalar;
                            }
                        } else {
                            for(i = 0; i < vertices.length; i++){
                                vertices[i].x += vector.x;
                                vertices[i].y += vector.y;
                            }
                        }
                        return vertices;
                    };
                    /**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */ Vertices.rotate = function(vertices, angle, point) {
                        if (angle === 0) return;
                        var cos = Math.cos(angle), sin = Math.sin(angle);
                        for(var i = 0; i < vertices.length; i++){
                            var vertice = vertices[i], dx = vertice.x - point.x, dy = vertice.y - point.y;
                            vertice.x = point.x + (dx * cos - dy * sin);
                            vertice.y = point.y + (dx * sin + dy * cos);
                        }
                        return vertices;
                    };
                    /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */ Vertices.contains = function(vertices, point) {
                        for(var i = 0; i < vertices.length; i++){
                            var vertice = vertices[i], nextVertice = vertices[(i + 1) % vertices.length];
                            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                                return false;
                            }
                        }
                        return true;
                    };
                    /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */ Vertices.scale = function(vertices, scaleX, scaleY, point) {
                        if (scaleX === 1 && scaleY === 1) return vertices;
                        point = point || Vertices.centre(vertices);
                        var vertex, delta;
                        for(var i = 0; i < vertices.length; i++){
                            vertex = vertices[i];
                            delta = Vector.sub(vertex, point);
                            vertices[i].x = point.x + delta.x * scaleX;
                            vertices[i].y = point.y + delta.y * scaleY;
                        }
                        return vertices;
                    };
                    /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */ Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
                        if (typeof radius === 'number') {
                            radius = [
                                radius
                            ];
                        } else {
                            radius = radius || [
                                8
                            ];
                        }
                        // quality defaults to -1, which is auto
                        quality = typeof quality !== 'undefined' ? quality : -1;
                        qualityMin = qualityMin || 2;
                        qualityMax = qualityMax || 14;
                        var newVertices = [];
                        for(var i = 0; i < vertices.length; i++){
                            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];
                            if (currentRadius === 0) {
                                newVertices.push(vertex);
                                continue;
                            }
                            var prevNormal = Vector.normalise({
                                x: vertex.y - prevVertex.y,
                                y: prevVertex.x - vertex.x
                            });
                            var nextNormal = Vector.normalise({
                                x: nextVertex.y - vertex.y,
                                y: vertex.x - nextVertex.x
                            });
                            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));
                            var precision = quality;
                            if (quality === -1) {
                                // automatically decide precision
                                precision = Math.pow(currentRadius, 0.32) * 1.75;
                            }
                            precision = Common.clamp(precision, qualityMin, qualityMax);
                            // use an even value for precision, more likely to reduce axes by using symmetry
                            if (precision % 2 === 1) precision += 1;
                            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
                            for(var j = 0; j < precision; j++){
                                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
                            }
                        }
                        return newVertices;
                    };
                    /**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */ Vertices.clockwiseSort = function(vertices) {
                        var centre = Vertices.mean(vertices);
                        vertices.sort(function(vertexA, vertexB) {
                            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
                        });
                        return vertices;
                    };
                    /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */ Vertices.isConvex = function(vertices) {
                        // http://paulbourke.net/geometry/polygonmesh/
                        // Copyright (c) Paul Bourke (use permitted)
                        var flag = 0, n = vertices.length, i, j, k, z;
                        if (n < 3) return null;
                        for(i = 0; i < n; i++){
                            j = (i + 1) % n;
                            k = (i + 2) % n;
                            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
                            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
                            if (z < 0) {
                                flag |= 1;
                            } else if (z > 0) {
                                flag |= 2;
                            }
                            if (flag === 3) {
                                return false;
                            }
                        }
                        if (flag !== 0) {
                            return true;
                        } else {
                            return null;
                        }
                    };
                    /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */ Vertices.hull = function(vertices) {
                        // http://geomalgorithms.com/a10-_hull-1.html
                        var upper = [], lower = [], vertex, i;
                        // sort vertices on x-axis (y-axis for ties)
                        vertices = vertices.slice(0);
                        vertices.sort(function(vertexA, vertexB) {
                            var dx = vertexA.x - vertexB.x;
                            return dx !== 0 ? dx : vertexA.y - vertexB.y;
                        });
                        // build lower hull
                        for(i = 0; i < vertices.length; i += 1){
                            vertex = vertices[i];
                            while(lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0){
                                lower.pop();
                            }
                            lower.push(vertex);
                        }
                        // build upper hull
                        for(i = vertices.length - 1; i >= 0; i -= 1){
                            vertex = vertices[i];
                            while(upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0){
                                upper.pop();
                            }
                            upper.push(vertex);
                        }
                        // concatenation of the lower and upper hulls gives the convex hull
                        // omit last points because they are repeated at the beginning of the other list
                        upper.pop();
                        lower.pop();
                        return upper.concat(lower);
                    };
                })();
            },
            {
                "../core/Common": 14,
                "../geometry/Vector": 28
            }
        ],
        30: [
            function(_dereq_, module1, exports1) {
                var Matter = module1.exports = _dereq_('../core/Matter');
                Matter.Body = _dereq_('../body/Body');
                Matter.Composite = _dereq_('../body/Composite');
                Matter.World = _dereq_('../body/World');
                Matter.Contact = _dereq_('../collision/Contact');
                Matter.Detector = _dereq_('../collision/Detector');
                Matter.Grid = _dereq_('../collision/Grid');
                Matter.Pairs = _dereq_('../collision/Pairs');
                Matter.Pair = _dereq_('../collision/Pair');
                Matter.Query = _dereq_('../collision/Query');
                Matter.Resolver = _dereq_('../collision/Resolver');
                Matter.SAT = _dereq_('../collision/SAT');
                Matter.Constraint = _dereq_('../constraint/Constraint');
                Matter.MouseConstraint = _dereq_('../constraint/MouseConstraint');
                Matter.Common = _dereq_('../core/Common');
                Matter.Engine = _dereq_('../core/Engine');
                Matter.Events = _dereq_('../core/Events');
                Matter.Mouse = _dereq_('../core/Mouse');
                Matter.Runner = _dereq_('../core/Runner');
                Matter.Sleeping = _dereq_('../core/Sleeping');
                Matter.Plugin = _dereq_('../core/Plugin');
                Matter.Bodies = _dereq_('../factory/Bodies');
                Matter.Composites = _dereq_('../factory/Composites');
                Matter.Axes = _dereq_('../geometry/Axes');
                Matter.Bounds = _dereq_('../geometry/Bounds');
                Matter.Svg = _dereq_('../geometry/Svg');
                Matter.Vector = _dereq_('../geometry/Vector');
                Matter.Vertices = _dereq_('../geometry/Vertices');
                Matter.Render = _dereq_('../render/Render');
                Matter.RenderPixi = _dereq_('../render/RenderPixi');
                // aliases
                Matter.World.add = Matter.Composite.add;
                Matter.World.remove = Matter.Composite.remove;
                Matter.World.addComposite = Matter.Composite.addComposite;
                Matter.World.addBody = Matter.Composite.addBody;
                Matter.World.addConstraint = Matter.Composite.addConstraint;
                Matter.World.clear = Matter.Composite.clear;
                Matter.Engine.run = Matter.Runner.run;
            },
            {
                "../body/Body": 1,
                "../body/Composite": 2,
                "../body/World": 3,
                "../collision/Contact": 4,
                "../collision/Detector": 5,
                "../collision/Grid": 6,
                "../collision/Pair": 7,
                "../collision/Pairs": 8,
                "../collision/Query": 9,
                "../collision/Resolver": 10,
                "../collision/SAT": 11,
                "../constraint/Constraint": 12,
                "../constraint/MouseConstraint": 13,
                "../core/Common": 14,
                "../core/Engine": 15,
                "../core/Events": 16,
                "../core/Matter": 17,
                "../core/Metrics": 18,
                "../core/Mouse": 19,
                "../core/Plugin": 20,
                "../core/Runner": 21,
                "../core/Sleeping": 22,
                "../factory/Bodies": 23,
                "../factory/Composites": 24,
                "../geometry/Axes": 25,
                "../geometry/Bounds": 26,
                "../geometry/Svg": 27,
                "../geometry/Vector": 28,
                "../geometry/Vertices": 29,
                "../render/Render": 31,
                "../render/RenderPixi": 32
            }
        ],
        31: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/ var Render = {};
                module1.exports = Render;
                var Common = _dereq_('../core/Common');
                var Composite = _dereq_('../body/Composite');
                var Bounds = _dereq_('../geometry/Bounds');
                var Events = _dereq_('../core/Events');
                var Grid = _dereq_('../collision/Grid');
                var Vector = _dereq_('../geometry/Vector');
                var Mouse = _dereq_('../core/Mouse');
                (function() {
                    var _requestAnimationFrame, _cancelAnimationFrame;
                    if (typeof window !== 'undefined') {
                        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                            window.setTimeout(function() {
                                callback(Common.now());
                            }, 1000 / 60);
                        };
                        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
                    }
                    /**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {render} A new renderer
     */ Render.create = function(options) {
                        var defaults = {
                            controller: Render,
                            engine: null,
                            element: null,
                            canvas: null,
                            mouse: null,
                            frameRequestId: null,
                            options: {
                                width: 800,
                                height: 600,
                                pixelRatio: 1,
                                background: '#18181d',
                                wireframeBackground: '#0f0f13',
                                hasBounds: !!options.bounds,
                                enabled: true,
                                wireframes: true,
                                showSleeping: true,
                                showDebug: false,
                                showBroadphase: false,
                                showBounds: false,
                                showVelocity: false,
                                showCollisions: false,
                                showSeparations: false,
                                showAxes: false,
                                showPositions: false,
                                showAngleIndicator: false,
                                showIds: false,
                                showShadows: false,
                                showVertexNumbers: false,
                                showConvexHulls: false,
                                showInternalEdges: false,
                                showMousePosition: false
                            }
                        };
                        var render = Common.extend(defaults, options);
                        if (render.canvas) {
                            render.canvas.width = render.options.width || render.canvas.width;
                            render.canvas.height = render.options.height || render.canvas.height;
                        }
                        render.mouse = options.mouse;
                        render.engine = options.engine;
                        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);
                        render.context = render.canvas.getContext('2d');
                        render.textures = {};
                        render.bounds = render.bounds || {
                            min: {
                                x: 0,
                                y: 0
                            },
                            max: {
                                x: render.canvas.width,
                                y: render.canvas.height
                            }
                        };
                        if (render.options.pixelRatio !== 1) {
                            Render.setPixelRatio(render, render.options.pixelRatio);
                        }
                        if (Common.isElement(render.element)) {
                            render.element.appendChild(render.canvas);
                        } else if (!render.canvas.parentNode) {
                            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');
                        }
                        return render;
                    };
                    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     */ Render.run = function(render) {
                        (function loop(time) {
                            render.frameRequestId = _requestAnimationFrame(loop);
                            Render.world(render);
                        })();
                    };
                    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     */ Render.stop = function(render) {
                        _cancelAnimationFrame(render.frameRequestId);
                    };
                    /**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method setPixelRatio
     * @param {render} render
     * @param {number} pixelRatio
     */ Render.setPixelRatio = function(render, pixelRatio) {
                        var options = render.options, canvas = render.canvas;
                        if (pixelRatio === 'auto') {
                            pixelRatio = _getPixelRatio(canvas);
                        }
                        options.pixelRatio = pixelRatio;
                        canvas.setAttribute('data-pixel-ratio', pixelRatio);
                        canvas.width = options.width * pixelRatio;
                        canvas.height = options.height * pixelRatio;
                        canvas.style.width = options.width + 'px';
                        canvas.style.height = options.height + 'px';
                        render.context.scale(pixelRatio, pixelRatio);
                    };
                    /**
     * Positions and sizes the viewport around the given object bounds.
     * Objects must have at least one of the following properties:
     * - `object.bounds`
     * - `object.position`
     * - `object.min` and `object.max`
     * - `object.x` and `object.y`
     * @method lookAt
     * @param {render} render
     * @param {object[]} objects
     * @param {vector} [padding]
     * @param {bool} [center=true]
     */ Render.lookAt = function(render, objects, padding, center) {
                        center = typeof center !== 'undefined' ? center : true;
                        objects = Common.isArray(objects) ? objects : [
                            objects
                        ];
                        padding = padding || {
                            x: 0,
                            y: 0
                        };
                        // find bounds of all objects
                        var bounds = {
                            min: {
                                x: Infinity,
                                y: Infinity
                            },
                            max: {
                                x: -Infinity,
                                y: -Infinity
                            }
                        };
                        for(var i = 0; i < objects.length; i += 1){
                            var object = objects[i], min = object.bounds ? object.bounds.min : object.min || object.position || object, max = object.bounds ? object.bounds.max : object.max || object.position || object;
                            if (min && max) {
                                if (min.x < bounds.min.x) bounds.min.x = min.x;
                                if (max.x > bounds.max.x) bounds.max.x = max.x;
                                if (min.y < bounds.min.y) bounds.min.y = min.y;
                                if (max.y > bounds.max.y) bounds.max.y = max.y;
                            }
                        }
                        // find ratios
                        var width = bounds.max.x - bounds.min.x + 2 * padding.x, height = bounds.max.y - bounds.min.y + 2 * padding.y, viewHeight = render.canvas.height, viewWidth = render.canvas.width, outerRatio = viewWidth / viewHeight, innerRatio = width / height, scaleX = 1, scaleY = 1;
                        // find scale factor
                        if (innerRatio > outerRatio) {
                            scaleY = innerRatio / outerRatio;
                        } else {
                            scaleX = outerRatio / innerRatio;
                        }
                        // enable bounds
                        render.options.hasBounds = true;
                        // position and size
                        render.bounds.min.x = bounds.min.x;
                        render.bounds.max.x = bounds.min.x + width * scaleX;
                        render.bounds.min.y = bounds.min.y;
                        render.bounds.max.y = bounds.min.y + height * scaleY;
                        // center
                        if (center) {
                            render.bounds.min.x += width * 0.5 - width * scaleX * 0.5;
                            render.bounds.max.x += width * 0.5 - width * scaleX * 0.5;
                            render.bounds.min.y += height * 0.5 - height * scaleY * 0.5;
                            render.bounds.max.y += height * 0.5 - height * scaleY * 0.5;
                        }
                        // padding
                        render.bounds.min.x -= padding.x;
                        render.bounds.max.x -= padding.x;
                        render.bounds.min.y -= padding.y;
                        render.bounds.max.y -= padding.y;
                        // update mouse
                        if (render.mouse) {
                            Mouse.setScale(render.mouse, {
                                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                            });
                            Mouse.setOffset(render.mouse, render.bounds.min);
                        }
                    };
                    /**
     * Applies viewport transforms based on `render.bounds` to a render context.
     * @method startViewTransform
     * @param {render} render
     */ Render.startViewTransform = function(render) {
                        var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;
                        render.context.scale(1 / boundsScaleX, 1 / boundsScaleY);
                        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);
                    };
                    /**
     * Resets all transforms on the render context.
     * @method endViewTransform
     * @param {render} render
     */ Render.endViewTransform = function(render) {
                        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
                    };
                    /**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method world
     * @param {render} render
     */ Render.world = function(render) {
                        var engine = render.engine, world = engine.world, canvas = render.canvas, context = render.context, options = render.options, allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world), background = options.wireframes ? options.wireframeBackground : options.background, bodies = [], constraints = [], i;
                        var event = {
                            timestamp: engine.timing.timestamp
                        };
                        Events.trigger(render, 'beforeRender', event);
                        // apply background if it has changed
                        if (render.currentBackground !== background) _applyBackground(render, background);
                        // clear the canvas with a transparent fill, to allow the canvas background to show
                        context.globalCompositeOperation = 'source-in';
                        context.fillStyle = "transparent";
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        context.globalCompositeOperation = 'source-over';
                        // handle bounds
                        if (options.hasBounds) {
                            // filter out bodies that are not in view
                            for(i = 0; i < allBodies.length; i++){
                                var body = allBodies[i];
                                if (Bounds.overlaps(body.bounds, render.bounds)) bodies.push(body);
                            }
                            // filter out constraints that are not in view
                            for(i = 0; i < allConstraints.length; i++){
                                var constraint = allConstraints[i], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;
                                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);
                                if (!pointAWorld || !pointBWorld) continue;
                                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld)) constraints.push(constraint);
                            }
                            // transform the view
                            Render.startViewTransform(render);
                            // update mouse
                            if (render.mouse) {
                                Mouse.setScale(render.mouse, {
                                    x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                                    y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                                });
                                Mouse.setOffset(render.mouse, render.bounds.min);
                            }
                        } else {
                            constraints = allConstraints;
                            bodies = allBodies;
                        }
                        if (!options.wireframes || engine.enableSleeping && options.showSleeping) {
                            // fully featured rendering of bodies
                            Render.bodies(render, bodies, context);
                        } else {
                            if (options.showConvexHulls) Render.bodyConvexHulls(render, bodies, context);
                            // optimised method for wireframes only
                            Render.bodyWireframes(render, bodies, context);
                        }
                        if (options.showBounds) Render.bodyBounds(render, bodies, context);
                        if (options.showAxes || options.showAngleIndicator) Render.bodyAxes(render, bodies, context);
                        if (options.showPositions) Render.bodyPositions(render, bodies, context);
                        if (options.showVelocity) Render.bodyVelocity(render, bodies, context);
                        if (options.showIds) Render.bodyIds(render, bodies, context);
                        if (options.showSeparations) Render.separations(render, engine.pairs.list, context);
                        if (options.showCollisions) Render.collisions(render, engine.pairs.list, context);
                        if (options.showVertexNumbers) Render.vertexNumbers(render, bodies, context);
                        if (options.showMousePosition) Render.mousePosition(render, render.mouse, context);
                        Render.constraints(constraints, context);
                        if (options.showBroadphase && engine.broadphase.controller === Grid) Render.grid(render, engine.broadphase, context);
                        if (options.showDebug) Render.debug(render, context);
                        if (options.hasBounds) {
                            // revert view transforms
                            Render.endViewTransform(render);
                        }
                        Events.trigger(render, 'afterRender', event);
                    };
                    /**
     * Description
     * @private
     * @method debug
     * @param {render} render
     * @param {RenderingContext} context
     */ Render.debug = function(render, context) {
                        var c = context, engine = render.engine, world = engine.world, metrics = engine.metrics, options = render.options, bodies = Composite.allBodies(world), space = "    ";
                        if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {
                            var text = "";
                            if (metrics.timing) {
                                text += "fps: " + Math.round(metrics.timing.fps) + space;
                            }
                            render.debugString = text;
                            render.debugTimestamp = engine.timing.timestamp;
                        }
                        if (render.debugString) {
                            c.font = "12px Arial";
                            if (options.wireframes) {
                                c.fillStyle = 'rgba(255,255,255,0.5)';
                            } else {
                                c.fillStyle = 'rgba(0,0,0,0.5)';
                            }
                            var split = render.debugString.split('\n');
                            for(var i = 0; i < split.length; i++){
                                c.fillText(split[i], 50, 50 + i * 18);
                            }
                        }
                    };
                    /**
     * Description
     * @private
     * @method constraints
     * @param {constraint[]} constraints
     * @param {RenderingContext} context
     */ Render.constraints = function(constraints, context) {
                        var c = context;
                        for(var i = 0; i < constraints.length; i++){
                            var constraint = constraints[i];
                            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB) continue;
                            var bodyA = constraint.bodyA, bodyB = constraint.bodyB, start, end;
                            if (bodyA) {
                                start = Vector.add(bodyA.position, constraint.pointA);
                            } else {
                                start = constraint.pointA;
                            }
                            if (constraint.render.type === 'pin') {
                                c.beginPath();
                                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                                c.closePath();
                            } else {
                                if (bodyB) {
                                    end = Vector.add(bodyB.position, constraint.pointB);
                                } else {
                                    end = constraint.pointB;
                                }
                                c.beginPath();
                                c.moveTo(start.x, start.y);
                                if (constraint.render.type === 'spring') {
                                    var delta = Vector.sub(end, start), normal = Vector.perp(Vector.normalise(delta)), coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)), offset;
                                    for(var j = 1; j < coils; j += 1){
                                        offset = j % 2 === 0 ? 1 : -1;
                                        c.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
                                    }
                                }
                                c.lineTo(end.x, end.y);
                            }
                            if (constraint.render.lineWidth) {
                                c.lineWidth = constraint.render.lineWidth;
                                c.strokeStyle = constraint.render.strokeStyle;
                                c.stroke();
                            }
                            if (constraint.render.anchors) {
                                c.fillStyle = constraint.render.strokeStyle;
                                c.beginPath();
                                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);
                                c.closePath();
                                c.fill();
                            }
                        }
                    };
                    /**
     * Description
     * @private
     * @method bodyShadows
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyShadows = function(render, bodies, context) {
                        var c = context, engine = render.engine;
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (!body.render.visible) continue;
                            if (body.circleRadius) {
                                c.beginPath();
                                c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);
                                c.closePath();
                            } else {
                                c.beginPath();
                                c.moveTo(body.vertices[0].x, body.vertices[0].y);
                                for(var j = 1; j < body.vertices.length; j++){
                                    c.lineTo(body.vertices[j].x, body.vertices[j].y);
                                }
                                c.closePath();
                            }
                            var distanceX = body.position.x - render.options.width * 0.5, distanceY = body.position.y - render.options.height * 0.2, distance = Math.abs(distanceX) + Math.abs(distanceY);
                            c.shadowColor = 'rgba(0,0,0,0.15)';
                            c.shadowOffsetX = 0.05 * distanceX;
                            c.shadowOffsetY = 0.05 * distanceY;
                            c.shadowBlur = 1 + 12 * Math.min(1, distance / 1000);
                            c.fill();
                            c.shadowColor = null;
                            c.shadowOffsetX = null;
                            c.shadowOffsetY = null;
                            c.shadowBlur = null;
                        }
                    };
                    /**
     * Description
     * @private
     * @method bodies
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodies = function(render, bodies, context) {
                        var c = context, engine = render.engine, options = render.options, showInternalEdges = options.showInternalEdges || !options.wireframes, body, part, i, k;
                        for(i = 0; i < bodies.length; i++){
                            body = bodies[i];
                            if (!body.render.visible) continue;
                            // handle compound parts
                            for(k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){
                                part = body.parts[k];
                                if (!part.render.visible) continue;
                                if (options.showSleeping && body.isSleeping) {
                                    c.globalAlpha = 0.5 * part.render.opacity;
                                } else if (part.render.opacity !== 1) {
                                    c.globalAlpha = part.render.opacity;
                                }
                                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                                    // part sprite
                                    var sprite = part.render.sprite, texture = _getTexture(render, sprite.texture);
                                    c.translate(part.position.x, part.position.y);
                                    c.rotate(part.angle);
                                    c.drawImage(texture, texture.width * -sprite.xOffset * sprite.xScale, texture.height * -sprite.yOffset * sprite.yScale, texture.width * sprite.xScale, texture.height * sprite.yScale);
                                    // revert translation, hopefully faster than save / restore
                                    c.rotate(-part.angle);
                                    c.translate(-part.position.x, -part.position.y);
                                } else {
                                    // part polygon
                                    if (part.circleRadius) {
                                        c.beginPath();
                                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                                    } else {
                                        c.beginPath();
                                        c.moveTo(part.vertices[0].x, part.vertices[0].y);
                                        for(var j = 1; j < part.vertices.length; j++){
                                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                                c.lineTo(part.vertices[j].x, part.vertices[j].y);
                                            } else {
                                                c.moveTo(part.vertices[j].x, part.vertices[j].y);
                                            }
                                            if (part.vertices[j].isInternal && !showInternalEdges) {
                                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                                            }
                                        }
                                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                                        c.closePath();
                                    }
                                    if (!options.wireframes) {
                                        c.fillStyle = part.render.fillStyle;
                                        if (part.render.lineWidth) {
                                            c.lineWidth = part.render.lineWidth;
                                            c.strokeStyle = part.render.strokeStyle;
                                            c.stroke();
                                        }
                                        c.fill();
                                    } else {
                                        c.lineWidth = 1;
                                        c.strokeStyle = '#bbb';
                                        c.stroke();
                                    }
                                }
                                c.globalAlpha = 1;
                            }
                        }
                    };
                    /**
     * Optimised method for drawing body wireframes in one pass
     * @private
     * @method bodyWireframes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyWireframes = function(render, bodies, context) {
                        var c = context, showInternalEdges = render.options.showInternalEdges, body, part, i, j, k;
                        c.beginPath();
                        // render all bodies
                        for(i = 0; i < bodies.length; i++){
                            body = bodies[i];
                            if (!body.render.visible) continue;
                            // handle compound parts
                            for(k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){
                                part = body.parts[k];
                                c.moveTo(part.vertices[0].x, part.vertices[0].y);
                                for(j = 1; j < part.vertices.length; j++){
                                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                        c.lineTo(part.vertices[j].x, part.vertices[j].y);
                                    } else {
                                        c.moveTo(part.vertices[j].x, part.vertices[j].y);
                                    }
                                    if (part.vertices[j].isInternal && !showInternalEdges) {
                                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                                    }
                                }
                                c.lineTo(part.vertices[0].x, part.vertices[0].y);
                            }
                        }
                        c.lineWidth = 1;
                        c.strokeStyle = '#bbb';
                        c.stroke();
                    };
                    /**
     * Optimised method for drawing body convex hull wireframes in one pass
     * @private
     * @method bodyConvexHulls
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyConvexHulls = function(render, bodies, context) {
                        var c = context, body, part, i, j, k;
                        c.beginPath();
                        // render convex hulls
                        for(i = 0; i < bodies.length; i++){
                            body = bodies[i];
                            if (!body.render.visible || body.parts.length === 1) continue;
                            c.moveTo(body.vertices[0].x, body.vertices[0].y);
                            for(j = 1; j < body.vertices.length; j++){
                                c.lineTo(body.vertices[j].x, body.vertices[j].y);
                            }
                            c.lineTo(body.vertices[0].x, body.vertices[0].y);
                        }
                        c.lineWidth = 1;
                        c.strokeStyle = 'rgba(255,255,255,0.2)';
                        c.stroke();
                    };
                    /**
     * Renders body vertex numbers.
     * @private
     * @method vertexNumbers
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.vertexNumbers = function(render, bodies, context) {
                        var c = context, i, j, k;
                        for(i = 0; i < bodies.length; i++){
                            var parts = bodies[i].parts;
                            for(k = parts.length > 1 ? 1 : 0; k < parts.length; k++){
                                var part = parts[k];
                                for(j = 0; j < part.vertices.length; j++){
                                    c.fillStyle = 'rgba(255,255,255,0.2)';
                                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);
                                }
                            }
                        }
                    };
                    /**
     * Renders mouse position.
     * @private
     * @method mousePosition
     * @param {render} render
     * @param {mouse} mouse
     * @param {RenderingContext} context
     */ Render.mousePosition = function(render, mouse, context) {
                        var c = context;
                        c.fillStyle = 'rgba(255,255,255,0.8)';
                        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);
                    };
                    /**
     * Draws body bounds
     * @private
     * @method bodyBounds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyBounds = function(render, bodies, context) {
                        var c = context, engine = render.engine, options = render.options;
                        c.beginPath();
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (body.render.visible) {
                                var parts = bodies[i].parts;
                                for(var j = parts.length > 1 ? 1 : 0; j < parts.length; j++){
                                    var part = parts[j];
                                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                                }
                            }
                        }
                        if (options.wireframes) {
                            c.strokeStyle = 'rgba(255,255,255,0.08)';
                        } else {
                            c.strokeStyle = 'rgba(0,0,0,0.1)';
                        }
                        c.lineWidth = 1;
                        c.stroke();
                    };
                    /**
     * Draws body angle indicators and axes
     * @private
     * @method bodyAxes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyAxes = function(render, bodies, context) {
                        var c = context, engine = render.engine, options = render.options, part, i, j, k;
                        c.beginPath();
                        for(i = 0; i < bodies.length; i++){
                            var body = bodies[i], parts = body.parts;
                            if (!body.render.visible) continue;
                            if (options.showAxes) {
                                // render all axes
                                for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){
                                    part = parts[j];
                                    for(k = 0; k < part.axes.length; k++){
                                        var axis = part.axes[k];
                                        c.moveTo(part.position.x, part.position.y);
                                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                                    }
                                }
                            } else {
                                for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){
                                    part = parts[j];
                                    for(k = 0; k < part.axes.length; k++){
                                        // render a single axis indicator
                                        c.moveTo(part.position.x, part.position.y);
                                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                                    }
                                }
                            }
                        }
                        if (options.wireframes) {
                            c.strokeStyle = 'indianred';
                            c.lineWidth = 1;
                        } else {
                            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                            c.globalCompositeOperation = 'overlay';
                            c.lineWidth = 2;
                        }
                        c.stroke();
                        c.globalCompositeOperation = 'source-over';
                    };
                    /**
     * Draws body positions
     * @private
     * @method bodyPositions
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyPositions = function(render, bodies, context) {
                        var c = context, engine = render.engine, options = render.options, body, part, i, k;
                        c.beginPath();
                        // render current positions
                        for(i = 0; i < bodies.length; i++){
                            body = bodies[i];
                            if (!body.render.visible) continue;
                            // handle compound parts
                            for(k = 0; k < body.parts.length; k++){
                                part = body.parts[k];
                                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                                c.closePath();
                            }
                        }
                        if (options.wireframes) {
                            c.fillStyle = 'indianred';
                        } else {
                            c.fillStyle = 'rgba(0,0,0,0.5)';
                        }
                        c.fill();
                        c.beginPath();
                        // render previous positions
                        for(i = 0; i < bodies.length; i++){
                            body = bodies[i];
                            if (body.render.visible) {
                                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                                c.closePath();
                            }
                        }
                        c.fillStyle = 'rgba(255,165,0,0.8)';
                        c.fill();
                    };
                    /**
     * Draws body velocity
     * @private
     * @method bodyVelocity
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyVelocity = function(render, bodies, context) {
                        var c = context;
                        c.beginPath();
                        for(var i = 0; i < bodies.length; i++){
                            var body = bodies[i];
                            if (!body.render.visible) continue;
                            c.moveTo(body.position.x, body.position.y);
                            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
                        }
                        c.lineWidth = 3;
                        c.strokeStyle = 'cornflowerblue';
                        c.stroke();
                    };
                    /**
     * Draws body ids
     * @private
     * @method bodyIds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */ Render.bodyIds = function(render, bodies, context) {
                        var c = context, i, j;
                        for(i = 0; i < bodies.length; i++){
                            if (!bodies[i].render.visible) continue;
                            var parts = bodies[i].parts;
                            for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){
                                var part = parts[j];
                                c.font = "12px Arial";
                                c.fillStyle = 'rgba(255,255,255,0.5)';
                                c.fillText(part.id, part.position.x + 10, part.position.y - 10);
                            }
                        }
                    };
                    /**
     * Description
     * @private
     * @method collisions
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */ Render.collisions = function(render, pairs, context) {
                        var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;
                        c.beginPath();
                        // render collision positions
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive) continue;
                            collision = pair.collision;
                            for(j = 0; j < pair.activeContacts.length; j++){
                                var contact = pair.activeContacts[j], vertex = contact.vertex;
                                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);
                            }
                        }
                        if (options.wireframes) {
                            c.fillStyle = 'rgba(255,255,255,0.7)';
                        } else {
                            c.fillStyle = 'orange';
                        }
                        c.fill();
                        c.beginPath();
                        // render collision normals
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive) continue;
                            collision = pair.collision;
                            if (pair.activeContacts.length > 0) {
                                var normalPosX = pair.activeContacts[0].vertex.x, normalPosY = pair.activeContacts[0].vertex.y;
                                if (pair.activeContacts.length === 2) {
                                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;
                                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;
                                }
                                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                                } else {
                                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                                }
                                c.lineTo(normalPosX, normalPosY);
                            }
                        }
                        if (options.wireframes) {
                            c.strokeStyle = 'rgba(255,165,0,0.7)';
                        } else {
                            c.strokeStyle = 'orange';
                        }
                        c.lineWidth = 1;
                        c.stroke();
                    };
                    /**
     * Description
     * @private
     * @method separations
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */ Render.separations = function(render, pairs, context) {
                        var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;
                        c.beginPath();
                        // render separations
                        for(i = 0; i < pairs.length; i++){
                            pair = pairs[i];
                            if (!pair.isActive) continue;
                            collision = pair.collision;
                            bodyA = collision.bodyA;
                            bodyB = collision.bodyB;
                            var k = 1;
                            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
                            if (bodyB.isStatic) k = 0;
                            c.moveTo(bodyB.position.x, bodyB.position.y);
                            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);
                            k = 1;
                            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
                            if (bodyA.isStatic) k = 0;
                            c.moveTo(bodyA.position.x, bodyA.position.y);
                            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);
                        }
                        if (options.wireframes) {
                            c.strokeStyle = 'rgba(255,165,0,0.5)';
                        } else {
                            c.strokeStyle = 'orange';
                        }
                        c.stroke();
                    };
                    /**
     * Description
     * @private
     * @method grid
     * @param {render} render
     * @param {grid} grid
     * @param {RenderingContext} context
     */ Render.grid = function(render, grid, context) {
                        var c = context, options = render.options;
                        if (options.wireframes) {
                            c.strokeStyle = 'rgba(255,180,0,0.1)';
                        } else {
                            c.strokeStyle = 'rgba(255,180,0,0.5)';
                        }
                        c.beginPath();
                        var bucketKeys = Common.keys(grid.buckets);
                        for(var i = 0; i < bucketKeys.length; i++){
                            var bucketId = bucketKeys[i];
                            if (grid.buckets[bucketId].length < 2) continue;
                            var region = bucketId.split(/C|R/);
                            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth, 0.5 + parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
                        }
                        c.lineWidth = 1;
                        c.stroke();
                    };
                    /**
     * Description
     * @private
     * @method inspector
     * @param {inspector} inspector
     * @param {RenderingContext} context
     */ Render.inspector = function(inspector, context) {
                        var engine = inspector.engine, selected = inspector.selected, render = inspector.render, options = render.options, bounds;
                        if (options.hasBounds) {
                            var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;
                            context.scale(1 / boundsScaleX, 1 / boundsScaleY);
                            context.translate(-render.bounds.min.x, -render.bounds.min.y);
                        }
                        for(var i = 0; i < selected.length; i++){
                            var item = selected[i].data;
                            context.translate(0.5, 0.5);
                            context.lineWidth = 1;
                            context.strokeStyle = 'rgba(255,165,0,0.9)';
                            context.setLineDash([
                                1,
                                2
                            ]);
                            switch(item.type){
                                case 'body':
                                    // render body selections
                                    bounds = item.bounds;
                                    context.beginPath();
                                    context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                                    context.closePath();
                                    context.stroke();
                                    break;
                                case 'constraint':
                                    // render constraint selections
                                    var point = item.pointA;
                                    if (item.bodyA) point = item.pointB;
                                    context.beginPath();
                                    context.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                                    context.closePath();
                                    context.stroke();
                                    break;
                            }
                            context.setLineDash([]);
                            context.translate(-0.5, -0.5);
                        }
                        // render selection region
                        if (inspector.selectStart !== null) {
                            context.translate(0.5, 0.5);
                            context.lineWidth = 1;
                            context.strokeStyle = 'rgba(255,165,0,0.6)';
                            context.fillStyle = 'rgba(255,165,0,0.1)';
                            bounds = inspector.selectBounds;
                            context.beginPath();
                            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
                            context.closePath();
                            context.stroke();
                            context.fill();
                            context.translate(-0.5, -0.5);
                        }
                        if (options.hasBounds) context.setTransform(1, 0, 0, 1, 0, 0);
                    };
                    /**
     * Description
     * @method _createCanvas
     * @private
     * @param {} width
     * @param {} height
     * @return canvas
     */ var _createCanvas = function(width, height) {
                        var canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        canvas.oncontextmenu = function() {
                            return false;
                        };
                        canvas.onselectstart = function() {
                            return false;
                        };
                        return canvas;
                    };
                    /**
     * Gets the pixel ratio of the canvas.
     * @method _getPixelRatio
     * @private
     * @param {HTMLElement} canvas
     * @return {Number} pixel ratio
     */ var _getPixelRatio = function(canvas) {
                        var context = canvas.getContext('2d'), devicePixelRatio = window.devicePixelRatio || 1, backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
                        return devicePixelRatio / backingStorePixelRatio;
                    };
                    /**
     * Gets the requested texture (an Image) via its path
     * @method _getTexture
     * @private
     * @param {render} render
     * @param {string} imagePath
     * @return {Image} texture
     */ var _getTexture = function(render, imagePath) {
                        var image = render.textures[imagePath];
                        if (image) return image;
                        image = render.textures[imagePath] = new Image();
                        image.src = imagePath;
                        return image;
                    };
                    /**
     * Applies the background to the canvas using CSS.
     * @method applyBackground
     * @private
     * @param {render} render
     * @param {string} background
     */ var _applyBackground = function(render, background) {
                        var cssBackground = background;
                        if (/(jpg|gif|png)$/.test(background)) cssBackground = 'url(' + background + ')';
                        render.canvas.style.background = cssBackground;
                        render.canvas.style.backgroundSize = "contain";
                        render.currentBackground = background;
                    };
                /*
    *
    *  Events Documentation
    *
    */ /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * A back-reference to the `Matter.Render` module.
     *
     * @property controller
     * @type render
     */ /**
     * A reference to the `Matter.Engine` instance to be used.
     *
     * @property engine
     * @type engine
     */ /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     *
     * @property element
     * @type HTMLElement
     * @default null
     */ /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     *
     * @property canvas
     * @type HTMLCanvasElement
     * @default null
     */ /**
     * The configuration options of the renderer.
     *
     * @property options
     * @type {}
     */ /**
     * The target width in pixels of the `render.canvas` to be created.
     *
     * @property options.width
     * @type number
     * @default 800
     */ /**
     * The target height in pixels of the `render.canvas` to be created.
     *
     * @property options.height
     * @type number
     * @default 600
     */ /**
     * A flag that specifies if `render.bounds` should be used when rendering.
     *
     * @property options.hasBounds
     * @type boolean
     * @default false
     */ /**
     * A `Bounds` object that specifies the drawing view region.
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
     * This allows for creating views that can pan or zoom around the scene.
     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     *
     * @property bounds
     * @type bounds
     */ /**
     * The 2d rendering context from the `render.canvas` element.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */ /**
     * The sprite texture cache.
     *
     * @property textures
     * @type {}
     */ })();
            },
            {
                "../body/Composite": 2,
                "../collision/Grid": 6,
                "../core/Common": 14,
                "../core/Events": 16,
                "../core/Mouse": 19,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28
            }
        ],
        32: [
            function(_dereq_, module1, exports1) {
                /**
* The `Matter.RenderPixi` module is an example renderer using pixi.js.
* See also `Matter.Render` for a canvas based renderer.
*
* @class RenderPixi
* @deprecated the Matter.RenderPixi module will soon be removed from the Matter.js core.
* It will likely be moved to its own repository (but maintenance will be limited).
*/ var RenderPixi = {};
                module1.exports = RenderPixi;
                var Bounds = _dereq_('../geometry/Bounds');
                var Composite = _dereq_('../body/Composite');
                var Common = _dereq_('../core/Common');
                var Events = _dereq_('../core/Events');
                var Vector = _dereq_('../geometry/Vector');
                (function() {
                    var _requestAnimationFrame, _cancelAnimationFrame;
                    if (typeof window !== 'undefined') {
                        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                            window.setTimeout(function() {
                                callback(Common.now());
                            }, 1000 / 60);
                        };
                        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
                    }
                    /**
     * Creates a new Pixi.js WebGL renderer
     * @method create
     * @param {object} [options]
     * @return {RenderPixi} A new renderer
     * @deprecated
     */ RenderPixi.create = function(options) {
                        Common.warn('RenderPixi.create: Matter.RenderPixi is deprecated (see docs)');
                        var defaults = {
                            controller: RenderPixi,
                            engine: null,
                            element: null,
                            frameRequestId: null,
                            canvas: null,
                            renderer: null,
                            container: null,
                            spriteContainer: null,
                            pixiOptions: null,
                            options: {
                                width: 800,
                                height: 600,
                                background: '#fafafa',
                                wireframeBackground: '#222',
                                hasBounds: false,
                                enabled: true,
                                wireframes: true,
                                showSleeping: true,
                                showDebug: false,
                                showBroadphase: false,
                                showBounds: false,
                                showVelocity: false,
                                showCollisions: false,
                                showAxes: false,
                                showPositions: false,
                                showAngleIndicator: false,
                                showIds: false,
                                showShadows: false
                            }
                        };
                        var render = Common.extend(defaults, options), transparent = !render.options.wireframes && render.options.background === 'transparent';
                        // init pixi
                        render.pixiOptions = render.pixiOptions || {
                            view: render.canvas,
                            transparent: transparent,
                            antialias: true,
                            backgroundColor: options.background
                        };
                        render.mouse = options.mouse;
                        render.engine = options.engine;
                        render.renderer = render.renderer || new PIXI.WebGLRenderer(render.options.width, render.options.height, render.pixiOptions);
                        render.container = render.container || new PIXI.Container();
                        render.spriteContainer = render.spriteContainer || new PIXI.Container();
                        render.canvas = render.canvas || render.renderer.view;
                        render.bounds = render.bounds || {
                            min: {
                                x: 0,
                                y: 0
                            },
                            max: {
                                x: render.options.width,
                                y: render.options.height
                            }
                        };
                        // event listeners
                        Events.on(render.engine, 'beforeUpdate', function() {
                            RenderPixi.clear(render);
                        });
                        // caches
                        render.textures = {};
                        render.sprites = {};
                        render.primitives = {};
                        // use a sprite batch for performance
                        render.container.addChild(render.spriteContainer);
                        // insert canvas
                        if (Common.isElement(render.element)) {
                            render.element.appendChild(render.canvas);
                        } else {
                            Common.warn('No "render.element" passed, "render.canvas" was not inserted into document.');
                        }
                        // prevent menus on canvas
                        render.canvas.oncontextmenu = function() {
                            return false;
                        };
                        render.canvas.onselectstart = function() {
                            return false;
                        };
                        return render;
                    };
                    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     * @deprecated
     */ RenderPixi.run = function(render) {
                        (function loop(time) {
                            render.frameRequestId = _requestAnimationFrame(loop);
                            RenderPixi.world(render);
                        })();
                    };
                    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     * @deprecated
     */ RenderPixi.stop = function(render) {
                        _cancelAnimationFrame(render.frameRequestId);
                    };
                    /**
     * Clears the scene graph
     * @method clear
     * @param {RenderPixi} render
     * @deprecated
     */ RenderPixi.clear = function(render) {
                        var container = render.container, spriteContainer = render.spriteContainer;
                        // clear stage container
                        while(container.children[0]){
                            container.removeChild(container.children[0]);
                        }
                        // clear sprite batch
                        while(spriteContainer.children[0]){
                            spriteContainer.removeChild(spriteContainer.children[0]);
                        }
                        var bgSprite = render.sprites['bg-0'];
                        // clear caches
                        render.textures = {};
                        render.sprites = {};
                        render.primitives = {};
                        // set background sprite
                        render.sprites['bg-0'] = bgSprite;
                        if (bgSprite) container.addChildAt(bgSprite, 0);
                        // add sprite batch back into container
                        render.container.addChild(render.spriteContainer);
                        // reset background state
                        render.currentBackground = null;
                        // reset bounds transforms
                        container.scale.set(1, 1);
                        container.position.set(0, 0);
                    };
                    /**
     * Sets the background of the canvas 
     * @method setBackground
     * @param {RenderPixi} render
     * @param {string} background
     * @deprecated
     */ RenderPixi.setBackground = function(render, background) {
                        if (render.currentBackground !== background) {
                            var isColor = background.indexOf && background.indexOf('#') !== -1, bgSprite = render.sprites['bg-0'];
                            if (isColor) {
                                // if solid background color
                                var color = Common.colorToNumber(background);
                                render.renderer.backgroundColor = color;
                                // remove background sprite if existing
                                if (bgSprite) render.container.removeChild(bgSprite);
                            } else {
                                // initialise background sprite if needed
                                if (!bgSprite) {
                                    var texture = _getTexture(render, background);
                                    bgSprite = render.sprites['bg-0'] = new PIXI.Sprite(texture);
                                    bgSprite.position.x = 0;
                                    bgSprite.position.y = 0;
                                    render.container.addChildAt(bgSprite, 0);
                                }
                            }
                            render.currentBackground = background;
                        }
                    };
                    /**
     * Description
     * @method world
     * @param {engine} engine
     * @deprecated
     */ RenderPixi.world = function(render) {
                        var engine = render.engine, world = engine.world, renderer = render.renderer, container = render.container, options = render.options, bodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world), constraints = [], i;
                        if (options.wireframes) {
                            RenderPixi.setBackground(render, options.wireframeBackground);
                        } else {
                            RenderPixi.setBackground(render, options.background);
                        }
                        // handle bounds
                        var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;
                        if (options.hasBounds) {
                            // Hide bodies that are not in view
                            for(i = 0; i < bodies.length; i++){
                                var body = bodies[i];
                                body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
                            }
                            // filter out constraints that are not in view
                            for(i = 0; i < allConstraints.length; i++){
                                var constraint = allConstraints[i], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;
                                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);
                                if (!pointAWorld || !pointBWorld) continue;
                                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld)) constraints.push(constraint);
                            }
                            // transform the view
                            container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
                            container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
                        } else {
                            constraints = allConstraints;
                        }
                        for(i = 0; i < bodies.length; i++)RenderPixi.body(render, bodies[i]);
                        for(i = 0; i < constraints.length; i++)RenderPixi.constraint(render, constraints[i]);
                        renderer.render(container);
                    };
                    /**
     * Description
     * @method constraint
     * @param {engine} engine
     * @param {constraint} constraint
     * @deprecated
     */ RenderPixi.constraint = function(render, constraint) {
                        var engine = render.engine, bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB, container = render.container, constraintRender = constraint.render, primitiveId = 'c-' + constraint.id, primitive = render.primitives[primitiveId];
                        // initialise constraint primitive if not existing
                        if (!primitive) primitive = render.primitives[primitiveId] = new PIXI.Graphics();
                        // don't render if constraint does not have two end points
                        if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {
                            primitive.clear();
                            return;
                        }
                        // add to scene graph if not already there
                        if (Common.indexOf(container.children, primitive) === -1) container.addChild(primitive);
                        // render the constraint on every update, since they can change dynamically
                        primitive.clear();
                        primitive.beginFill(0, 0);
                        primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);
                        if (bodyA) {
                            primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);
                        } else {
                            primitive.moveTo(pointA.x, pointA.y);
                        }
                        if (bodyB) {
                            primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);
                        } else {
                            primitive.lineTo(pointB.x, pointB.y);
                        }
                        primitive.endFill();
                    };
                    /**
     * Description
     * @method body
     * @param {engine} engine
     * @param {body} body
     * @deprecated
     */ RenderPixi.body = function(render, body) {
                        var engine = render.engine, bodyRender = body.render;
                        if (!bodyRender.visible) return;
                        if (bodyRender.sprite && bodyRender.sprite.texture) {
                            var spriteId = 'b-' + body.id, sprite = render.sprites[spriteId], spriteContainer = render.spriteContainer;
                            // initialise body sprite if not existing
                            if (!sprite) sprite = render.sprites[spriteId] = _createBodySprite(render, body);
                            // add to scene graph if not already there
                            if (Common.indexOf(spriteContainer.children, sprite) === -1) spriteContainer.addChild(sprite);
                            // update body sprite
                            sprite.position.x = body.position.x;
                            sprite.position.y = body.position.y;
                            sprite.rotation = body.angle;
                            sprite.scale.x = bodyRender.sprite.xScale || 1;
                            sprite.scale.y = bodyRender.sprite.yScale || 1;
                        } else {
                            var primitiveId = 'b-' + body.id, primitive = render.primitives[primitiveId], container = render.container;
                            // initialise body primitive if not existing
                            if (!primitive) {
                                primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);
                                primitive.initialAngle = body.angle;
                            }
                            // add to scene graph if not already there
                            if (Common.indexOf(container.children, primitive) === -1) container.addChild(primitive);
                            // update body primitive
                            primitive.position.x = body.position.x;
                            primitive.position.y = body.position.y;
                            primitive.rotation = body.angle - primitive.initialAngle;
                        }
                    };
                    /**
     * Creates a body sprite
     * @method _createBodySprite
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Sprite} sprite
     * @deprecated
     */ var _createBodySprite = function(render, body) {
                        var bodyRender = body.render, texturePath = bodyRender.sprite.texture, texture = _getTexture(render, texturePath), sprite = new PIXI.Sprite(texture);
                        sprite.anchor.x = body.render.sprite.xOffset;
                        sprite.anchor.y = body.render.sprite.yOffset;
                        return sprite;
                    };
                    /**
     * Creates a body primitive
     * @method _createBodyPrimitive
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Graphics} graphics
     * @deprecated
     */ var _createBodyPrimitive = function(render, body) {
                        var bodyRender = body.render, options = render.options, primitive = new PIXI.Graphics(), fillStyle = Common.colorToNumber(bodyRender.fillStyle), strokeStyle = Common.colorToNumber(bodyRender.strokeStyle), strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle), strokeStyleWireframe = Common.colorToNumber('#bbb'), strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'), part;
                        primitive.clear();
                        // handle compound parts
                        for(var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){
                            part = body.parts[k];
                            if (!options.wireframes) {
                                primitive.beginFill(fillStyle, 1);
                                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);
                            } else {
                                primitive.beginFill(0, 0);
                                primitive.lineStyle(1, strokeStyleWireframe, 1);
                            }
                            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);
                            for(var j = 1; j < part.vertices.length; j++){
                                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);
                            }
                            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);
                            primitive.endFill();
                            // angle indicator
                            if (options.showAngleIndicator || options.showAxes) {
                                primitive.beginFill(0, 0);
                                if (options.wireframes) {
                                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);
                                } else {
                                    primitive.lineStyle(1, strokeStyleIndicator);
                                }
                                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);
                                primitive.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2 - body.position.x, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2 - body.position.y);
                                primitive.endFill();
                            }
                        }
                        return primitive;
                    };
                    /**
     * Gets the requested texture (a PIXI.Texture) via its path
     * @method _getTexture
     * @private
     * @param {RenderPixi} render
     * @param {string} imagePath
     * @return {PIXI.Texture} texture
     * @deprecated
     */ var _getTexture = function(render, imagePath) {
                        var texture = render.textures[imagePath];
                        if (!texture) texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);
                        return texture;
                    };
                })();
            },
            {
                "../body/Composite": 2,
                "../core/Common": 14,
                "../core/Events": 16,
                "../geometry/Bounds": 26,
                "../geometry/Vector": 28
            }
        ]
    }, {}, [
        30
    ])(30);
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NoZXJwYS9saWIvbWF0dGVyLTAuMTQuMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogbWF0dGVyLWpzIDAuMTQuMiBieSBAbGlhYnJ1IDIwMTgtMDYtMTFcbiogaHR0cDovL2JybS5pby9tYXR0ZXItanMvXG4qIExpY2Vuc2UgTUlUXG4qL1xuXG4vKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIExpYW0gQnJ1bW1pdHQgYW5kIGNvbnRyaWJ1dG9ycy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLk1hdHRlciA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGJvZHkgbW9kZWxzLlxuKiBBIGBNYXR0ZXIuQm9keWAgaXMgYSByaWdpZCBib2R5IHRoYXQgY2FuIGJlIHNpbXVsYXRlZCBieSBhIGBNYXR0ZXIuRW5naW5lYC5cbiogRmFjdG9yaWVzIGZvciBjb21tb25seSB1c2VkIGJvZHkgY29uZmlndXJhdGlvbnMgKHN1Y2ggYXMgcmVjdGFuZ2xlcywgY2lyY2xlcyBhbmQgb3RoZXIgcG9seWdvbnMpIGNhbiBiZSBmb3VuZCBpbiB0aGUgbW9kdWxlIGBNYXR0ZXIuQm9kaWVzYC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cblxuKiBAY2xhc3MgQm9keVxuKi9cblxudmFyIEJvZHkgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb2R5O1xuXG52YXIgVmVydGljZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIFZlY3RvciA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIFNsZWVwaW5nID0gX2RlcmVxXygnLi4vY29yZS9TbGVlcGluZycpO1xudmFyIFJlbmRlciA9IF9kZXJlcV8oJy4uL3JlbmRlci9SZW5kZXInKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xudmFyIEJvdW5kcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xudmFyIEF4ZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9BeGVzJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIEJvZHkuX2luZXJ0aWFTY2FsZSA9IDQ7XG4gICAgQm9keS5fbmV4dENvbGxpZGluZ0dyb3VwSWQgPSAxO1xuICAgIEJvZHkuX25leHROb25Db2xsaWRpbmdHcm91cElkID0gLTE7XG4gICAgQm9keS5fbmV4dENhdGVnb3J5ID0gMHgwMDAxO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFZlcnRpY2VzIG11c3QgYmUgc3BlY2lmaWVkIGluIGNsb2Nrd2lzZSBvcmRlci5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBib2R5XG4gICAgICovXG4gICAgQm9keS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGlkOiBDb21tb24ubmV4dElkKCksXG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBsYWJlbDogJ0JvZHknLFxuICAgICAgICAgICAgcGFydHM6IFtdLFxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcbiAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKCdMIDAgMCBMIDQwIDAgTCA0MCA0MCBMIDAgNDAnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGZvcmNlOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIHRvcnF1ZTogMCxcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZTogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjb25zdHJhaW50SW1wdWxzZTogeyB4OiAwLCB5OiAwLCBhbmdsZTogMCB9LFxuICAgICAgICAgICAgdG90YWxDb250YWN0czogMCxcbiAgICAgICAgICAgIHNwZWVkOiAwLFxuICAgICAgICAgICAgYW5ndWxhclNwZWVkOiAwLFxuICAgICAgICAgICAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwLFxuICAgICAgICAgICAgaXNTZW5zb3I6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgaXNTbGVlcGluZzogZmFsc2UsXG4gICAgICAgICAgICBtb3Rpb246IDAsXG4gICAgICAgICAgICBzbGVlcFRocmVzaG9sZDogNjAsXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAwMSxcbiAgICAgICAgICAgIHJlc3RpdHV0aW9uOiAwLFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuMSxcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiAwLjUsXG4gICAgICAgICAgICBmcmljdGlvbkFpcjogMC4wMSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXG4gICAgICAgICAgICAgICAgbWFzazogMHhGRkZGRkZGRixcbiAgICAgICAgICAgICAgICBncm91cDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3A6IDAuMDUsXG4gICAgICAgICAgICB0aW1lU2NhbGU6IDEsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3ByaXRlOiB7XG4gICAgICAgICAgICAgICAgICAgIHhTY2FsZTogMSxcbiAgICAgICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYm9keSA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIF9pbml0UHJvcGVydGllcyhib2R5LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgZ3JvdXAgaW5kZXggZm9yIHdoaWNoIGJvZGllcyB3aWxsIGNvbGxpZGUuXG4gICAgICogSWYgYGlzTm9uQ29sbGlkaW5nYCBpcyBgdHJ1ZWAsIHJldHVybnMgdGhlIG5leHQgdW5pcXVlIGdyb3VwIGluZGV4IGZvciB3aGljaCBib2RpZXMgd2lsbCBfbm90XyBjb2xsaWRlLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBtZXRob2QgbmV4dEdyb3VwXG4gICAgICogQHBhcmFtIHtib29sfSBbaXNOb25Db2xsaWRpbmc9ZmFsc2VdXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBVbmlxdWUgZ3JvdXAgaW5kZXhcbiAgICAgKi9cbiAgICBCb2R5Lm5leHRHcm91cCA9IGZ1bmN0aW9uKGlzTm9uQ29sbGlkaW5nKSB7XG4gICAgICAgIGlmIChpc05vbkNvbGxpZGluZylcbiAgICAgICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Tm9uQ29sbGlkaW5nR3JvdXBJZC0tO1xuXG4gICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Q29sbGlkaW5nR3JvdXBJZCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBjYXRlZ29yeSBiaXRmaWVsZCAoc3RhcnRpbmcgYWZ0ZXIgdGhlIGluaXRpYWwgZGVmYXVsdCBjYXRlZ29yeSBgMHgwMDAxYCkuXG4gICAgICogVGhlcmUgYXJlIDMyIGF2YWlsYWJsZS4gU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZCBuZXh0Q2F0ZWdvcnlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBjYXRlZ29yeSBiaXRmaWVsZFxuICAgICAqL1xuICAgIEJvZHkubmV4dENhdGVnb3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIEJvZHkuX25leHRDYXRlZ29yeSA9IEJvZHkuX25leHRDYXRlZ29yeSA8PCAxO1xuICAgICAgICByZXR1cm4gQm9keS5fbmV4dENhdGVnb3J5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlcyBib2R5IHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBfaW5pdFByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICB2YXIgX2luaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBpbml0IHJlcXVpcmVkIHByb3BlcnRpZXMgKG9yZGVyIGlzIGltcG9ydGFudClcbiAgICAgICAgQm9keS5zZXQoYm9keSwge1xuICAgICAgICAgICAgYm91bmRzOiBib2R5LmJvdW5kcyB8fCBCb3VuZHMuY3JlYXRlKGJvZHkudmVydGljZXMpLFxuICAgICAgICAgICAgcG9zaXRpb25QcmV2OiBib2R5LnBvc2l0aW9uUHJldiB8fCBWZWN0b3IuY2xvbmUoYm9keS5wb3NpdGlvbiksXG4gICAgICAgICAgICBhbmdsZVByZXY6IGJvZHkuYW5nbGVQcmV2IHx8IGJvZHkuYW5nbGUsXG4gICAgICAgICAgICB2ZXJ0aWNlczogYm9keS52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHBhcnRzOiBib2R5LnBhcnRzIHx8IFtib2R5XSxcbiAgICAgICAgICAgIGlzU3RhdGljOiBib2R5LmlzU3RhdGljLFxuICAgICAgICAgICAgaXNTbGVlcGluZzogYm9keS5pc1NsZWVwaW5nLFxuICAgICAgICAgICAgcGFyZW50OiBib2R5LnBhcmVudCB8fCBib2R5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFZlcnRpY2VzLnJvdGF0ZShib2R5LnZlcnRpY2VzLCBib2R5LmFuZ2xlLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgQXhlcy5yb3RhdGUoYm9keS5heGVzLCBib2R5LmFuZ2xlKTtcbiAgICAgICAgQm91bmRzLnVwZGF0ZShib2R5LmJvdW5kcywgYm9keS52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG5cbiAgICAgICAgLy8gYWxsb3cgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHByb3BlcnRpZXNcbiAgICAgICAgQm9keS5zZXQoYm9keSwge1xuICAgICAgICAgICAgYXhlczogb3B0aW9ucy5heGVzIHx8IGJvZHkuYXhlcyxcbiAgICAgICAgICAgIGFyZWE6IG9wdGlvbnMuYXJlYSB8fCBib2R5LmFyZWEsXG4gICAgICAgICAgICBtYXNzOiBvcHRpb25zLm1hc3MgfHwgYm9keS5tYXNzLFxuICAgICAgICAgICAgaW5lcnRpYTogb3B0aW9ucy5pbmVydGlhIHx8IGJvZHkuaW5lcnRpYVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW5kZXIgcHJvcGVydGllc1xuICAgICAgICB2YXIgZGVmYXVsdEZpbGxTdHlsZSA9IChib2R5LmlzU3RhdGljID8gJyMyZTJiNDQnIDogQ29tbW9uLmNob29zZShbJyMwMDZCQTYnLCAnIzA0OTZGRicsICcjRkZCQzQyJywgJyNEODExNTknLCAnIzhGMkQ1NiddKSksXG4gICAgICAgICAgICBkZWZhdWx0U3Ryb2tlU3R5bGUgPSAnIzAwMCc7XG4gICAgICAgIGJvZHkucmVuZGVyLmZpbGxTdHlsZSA9IGJvZHkucmVuZGVyLmZpbGxTdHlsZSB8fCBkZWZhdWx0RmlsbFN0eWxlO1xuICAgICAgICBib2R5LnJlbmRlci5zdHJva2VTdHlsZSA9IGJvZHkucmVuZGVyLnN0cm9rZVN0eWxlIHx8IGRlZmF1bHRTdHJva2VTdHlsZTtcbiAgICAgICAgYm9keS5yZW5kZXIuc3ByaXRlLnhPZmZzZXQgKz0gLShib2R5LmJvdW5kcy5taW4ueCAtIGJvZHkucG9zaXRpb24ueCkgLyAoYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueCk7XG4gICAgICAgIGJvZHkucmVuZGVyLnNwcml0ZS55T2Zmc2V0ICs9IC0oYm9keS5ib3VuZHMubWluLnkgLSBib2R5LnBvc2l0aW9uLnkpIC8gKGJvZHkuYm91bmRzLm1heC55IC0gYm9keS5ib3VuZHMubWluLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHByb3BlcnR5IGFuZCBhIHZhbHVlIChvciBtYXAgb2YpLCBzZXRzIHRoZSBwcm9wZXJ0eShzKSBvbiB0aGUgYm9keSwgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIHNldHRlciBmdW5jdGlvbnMgaWYgdGhleSBleGlzdC5cbiAgICAgKiBQcmVmZXIgdG8gdXNlIHRoZSBhY3R1YWwgc2V0dGVyIGZ1bmN0aW9ucyBpbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBzaXR1YXRpb25zLlxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt9IHNldHRpbmdzIEEgcHJvcGVydHkgbmFtZSAob3IgbWFwIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcykgdG8gc2V0IG9uIHRoZSBib2R5LlxuICAgICAqIEBwYXJhbSB7fSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGlmIGBzZXR0aW5nc2AgaXMgYSBzaW5nbGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKi9cbiAgICBCb2R5LnNldCA9IGZ1bmN0aW9uKGJvZHksIHNldHRpbmdzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHt9O1xuICAgICAgICAgICAgc2V0dGluZ3NbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzW3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcblxuICAgICAgICAgICAgY2FzZSAnaXNTdGF0aWMnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0U3RhdGljKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzU2xlZXBpbmcnOlxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXNzJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVuc2l0eSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXREZW5zaXR5KGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luZXJ0aWEnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZXJ0aWNlcyc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRWZXJ0aWNlcyhib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmdsZSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRBbmdsZShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZWxvY2l0eSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRWZWxvY2l0eShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmd1bGFyVmVsb2NpdHknOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhcnRzJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldFBhcnRzKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYm9keVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvZHkgYXMgc3RhdGljLCBpbmNsdWRpbmcgaXNTdGF0aWMgZmxhZyBhbmQgc2V0dGluZyBtYXNzIGFuZCBpbmVydGlhIHRvIEluZmluaXR5LlxuICAgICAqIEBtZXRob2Qgc2V0U3RhdGljXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtib29sfSBpc1N0YXRpY1xuICAgICAqL1xuICAgIEJvZHkuc2V0U3RhdGljID0gZnVuY3Rpb24oYm9keSwgaXNTdGF0aWMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG4gICAgICAgICAgICBwYXJ0LmlzU3RhdGljID0gaXNTdGF0aWM7XG5cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICAgICAgICAgIHBhcnQuX29yaWdpbmFsID0ge1xuICAgICAgICAgICAgICAgICAgICByZXN0aXR1dGlvbjogcGFydC5yZXN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb246IHBhcnQuZnJpY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG1hc3M6IHBhcnQubWFzcyxcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYTogcGFydC5pbmVydGlhLFxuICAgICAgICAgICAgICAgICAgICBkZW5zaXR5OiBwYXJ0LmRlbnNpdHksXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VNYXNzOiBwYXJ0LmludmVyc2VNYXNzLFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlSW5lcnRpYTogcGFydC5pbnZlcnNlSW5lcnRpYVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBwYXJ0LnJlc3RpdHV0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBwYXJ0LmZyaWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICBwYXJ0Lm1hc3MgPSBwYXJ0LmluZXJ0aWEgPSBwYXJ0LmRlbnNpdHkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBwYXJ0LmludmVyc2VNYXNzID0gcGFydC5pbnZlcnNlSW5lcnRpYSA9IDA7XG5cbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uUHJldi54ID0gcGFydC5wb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb25QcmV2LnkgPSBwYXJ0LnBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgcGFydC5hbmdsZVByZXYgPSBwYXJ0LmFuZ2xlO1xuICAgICAgICAgICAgICAgIHBhcnQuYW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBwYXJ0LnNwZWVkID0gMDtcbiAgICAgICAgICAgICAgICBwYXJ0LmFuZ3VsYXJTcGVlZCA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5tb3Rpb24gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0Ll9vcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIHBhcnQucmVzdGl0dXRpb24gPSBwYXJ0Ll9vcmlnaW5hbC5yZXN0aXR1dGlvbjtcbiAgICAgICAgICAgICAgICBwYXJ0LmZyaWN0aW9uID0gcGFydC5fb3JpZ2luYWwuZnJpY3Rpb247XG4gICAgICAgICAgICAgICAgcGFydC5tYXNzID0gcGFydC5fb3JpZ2luYWwubWFzcztcbiAgICAgICAgICAgICAgICBwYXJ0LmluZXJ0aWEgPSBwYXJ0Ll9vcmlnaW5hbC5pbmVydGlhO1xuICAgICAgICAgICAgICAgIHBhcnQuZGVuc2l0eSA9IHBhcnQuX29yaWdpbmFsLmRlbnNpdHk7XG4gICAgICAgICAgICAgICAgcGFydC5pbnZlcnNlTWFzcyA9IHBhcnQuX29yaWdpbmFsLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZUluZXJ0aWEgPSBwYXJ0Ll9vcmlnaW5hbC5pbnZlcnNlSW5lcnRpYTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJ0Ll9vcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoZSBib2R5LiBJbnZlcnNlIG1hc3MsIGRlbnNpdHkgYW5kIGluZXJ0aWEgYXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXG4gICAgICogQG1ldGhvZCBzZXRNYXNzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc3NcbiAgICAgKi9cbiAgICBCb2R5LnNldE1hc3MgPSBmdW5jdGlvbihib2R5LCBtYXNzKSB7XG4gICAgICAgIHZhciBtb21lbnQgPSBib2R5LmluZXJ0aWEgLyAoYm9keS5tYXNzIC8gNik7XG4gICAgICAgIGJvZHkuaW5lcnRpYSA9IG1vbWVudCAqIChtYXNzIC8gNik7XG4gICAgICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuXG4gICAgICAgIGJvZHkubWFzcyA9IG1hc3M7XG4gICAgICAgIGJvZHkuaW52ZXJzZU1hc3MgPSAxIC8gYm9keS5tYXNzO1xuICAgICAgICBib2R5LmRlbnNpdHkgPSBib2R5Lm1hc3MgLyBib2R5LmFyZWE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlbnNpdHkgb2YgdGhlIGJvZHkuIE1hc3MgYW5kIGluZXJ0aWEgYXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXG4gICAgICogQG1ldGhvZCBzZXREZW5zaXR5XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcbiAgICAgKi9cbiAgICBCb2R5LnNldERlbnNpdHkgPSBmdW5jdGlvbihib2R5LCBkZW5zaXR5KSB7XG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBkZW5zaXR5ICogYm9keS5hcmVhKTtcbiAgICAgICAgYm9keS5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgKGkuZS4gc2Vjb25kIG1vbWVudCBvZiBhcmVhKSBvZiB0aGUgYm9keSBvZiB0aGUgYm9keS4gXG4gICAgICogSW52ZXJzZSBpbmVydGlhIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuIE1hc3MgaXMgbm90IGNoYW5nZWQuXG4gICAgICogQG1ldGhvZCBzZXRJbmVydGlhXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZXJ0aWFcbiAgICAgKi9cbiAgICBCb2R5LnNldEluZXJ0aWEgPSBmdW5jdGlvbihib2R5LCBpbmVydGlhKSB7XG4gICAgICAgIGJvZHkuaW5lcnRpYSA9IGluZXJ0aWE7XG4gICAgICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib2R5J3MgdmVydGljZXMgYW5kIHVwZGF0ZXMgYm9keSBwcm9wZXJ0aWVzIGFjY29yZGluZ2x5LCBpbmNsdWRpbmcgaW5lcnRpYSwgYXJlYSBhbmQgbWFzcyAod2l0aCByZXNwZWN0IHRvIGBib2R5LmRlbnNpdHlgKS5cbiAgICAgKiBWZXJ0aWNlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgdG8gYmUgb3JpZW50YXRlZCBhcm91bmQgdGhlaXIgY2VudHJlIG9mIG1hc3MgYXMgdGhlIG9yaWdpbi5cbiAgICAgKiBUaGV5IGFyZSB0aGVuIGF1dG9tYXRpY2FsbHkgdHJhbnNsYXRlZCB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBgYm9keS5wb3NpdGlvbmAuXG4gICAgICpcbiAgICAgKiBUaGUgYHZlcnRpY2VzYCBhcmd1bWVudCBzaG91bGQgYmUgcGFzc2VkIGFzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCBwb2ludHMgKG9yIGEgYE1hdHRlci5WZXJ0aWNlc2AgYXJyYXkpLlxuICAgICAqIFZlcnRpY2VzIG11c3QgZm9ybSBhIGNvbnZleCBodWxsLCBjb25jYXZlIGh1bGxzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRWZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yW119IHZlcnRpY2VzXG4gICAgICovXG4gICAgQm9keS5zZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uKGJvZHksIHZlcnRpY2VzKSB7XG4gICAgICAgIC8vIGNoYW5nZSB2ZXJ0aWNlc1xuICAgICAgICBpZiAodmVydGljZXNbMF0uYm9keSA9PT0gYm9keSkge1xuICAgICAgICAgICAgYm9keS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNyZWF0ZSh2ZXJ0aWNlcywgYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgcHJvcGVydGllc1xuICAgICAgICBib2R5LmF4ZXMgPSBBeGVzLmZyb21WZXJ0aWNlcyhib2R5LnZlcnRpY2VzKTtcbiAgICAgICAgYm9keS5hcmVhID0gVmVydGljZXMuYXJlYShib2R5LnZlcnRpY2VzKTtcbiAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIGJvZHkuZGVuc2l0eSAqIGJvZHkuYXJlYSk7XG5cbiAgICAgICAgLy8gb3JpZW50IHZlcnRpY2VzIGFyb3VuZCB0aGUgY2VudHJlIG9mIG1hc3MgYXQgb3JpZ2luICgwLCAwKVxuICAgICAgICB2YXIgY2VudHJlID0gVmVydGljZXMuY2VudHJlKGJvZHkudmVydGljZXMpO1xuICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUoYm9keS52ZXJ0aWNlcywgY2VudHJlLCAtMSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGluZXJ0aWEgd2hpbGUgdmVydGljZXMgYXJlIGF0IG9yaWdpbiAoMCwgMClcbiAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIEJvZHkuX2luZXJ0aWFTY2FsZSAqIFZlcnRpY2VzLmluZXJ0aWEoYm9keS52ZXJ0aWNlcywgYm9keS5tYXNzKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGdlb21ldHJ5XG4gICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgQm91bmRzLnVwZGF0ZShib2R5LmJvdW5kcywgYm9keS52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhcnRzIG9mIHRoZSBgYm9keWAgYW5kIHVwZGF0ZXMgbWFzcywgaW5lcnRpYSBhbmQgY2VudHJvaWQuXG4gICAgICogRWFjaCBwYXJ0IHdpbGwgaGF2ZSBpdHMgcGFyZW50IHNldCB0byBgYm9keWAuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgY29udmV4IGh1bGwgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGFuZCBzZXQgb24gYGJvZHlgLCB1bmxlc3MgYGF1dG9IdWxsYCBpcyBzZXQgdG8gYGZhbHNlLmBcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgdGhhdCB0aGUgZmlyc3QgcGFydCBpbiBgYm9keS5wYXJ0c2Agd2lsbCBhbHdheXMgYmUgdGhlIGBib2R5YC5cbiAgICAgKiBAbWV0aG9kIHNldFBhcnRzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIFtib2R5XSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2F1dG9IdWxsPXRydWVdXG4gICAgICovXG4gICAgQm9keS5zZXRQYXJ0cyA9IGZ1bmN0aW9uKGJvZHksIHBhcnRzLCBhdXRvSHVsbCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBhZGQgYWxsIHRoZSBwYXJ0cywgZW5zdXJpbmcgdGhhdCB0aGUgZmlyc3QgcGFydCBpcyBhbHdheXMgdGhlIHBhcmVudCBib2R5XG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCk7XG4gICAgICAgIGJvZHkucGFydHMubGVuZ3RoID0gMDtcbiAgICAgICAgYm9keS5wYXJ0cy5wdXNoKGJvZHkpO1xuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IGJvZHkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnBhcmVudCA9IGJvZHk7XG4gICAgICAgICAgICAgICAgYm9keS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHkucGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGF1dG9IdWxsID0gdHlwZW9mIGF1dG9IdWxsICE9PSAndW5kZWZpbmVkJyA/IGF1dG9IdWxsIDogdHJ1ZTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBjb252ZXggaHVsbCBvZiBhbGwgcGFydHMgdG8gc2V0IG9uIHRoZSBwYXJlbnQgYm9keVxuICAgICAgICBpZiAoYXV0b0h1bGwpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQocGFydHNbaV0udmVydGljZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0KHZlcnRpY2VzKTtcblxuICAgICAgICAgICAgdmFyIGh1bGwgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKSxcbiAgICAgICAgICAgICAgICBodWxsQ2VudHJlID0gVmVydGljZXMuY2VudHJlKGh1bGwpO1xuXG4gICAgICAgICAgICBCb2R5LnNldFZlcnRpY2VzKGJvZHksIGh1bGwpO1xuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKGJvZHkudmVydGljZXMsIGh1bGxDZW50cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3VtIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHlcbiAgICAgICAgdmFyIHRvdGFsID0gQm9keS5fdG90YWxQcm9wZXJ0aWVzKGJvZHkpO1xuXG4gICAgICAgIGJvZHkuYXJlYSA9IHRvdGFsLmFyZWE7XG4gICAgICAgIGJvZHkucGFyZW50ID0gYm9keTtcbiAgICAgICAgYm9keS5wb3NpdGlvbi54ID0gdG90YWwuY2VudHJlLng7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueSA9IHRvdGFsLmNlbnRyZS55O1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gdG90YWwuY2VudHJlLng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSB0b3RhbC5jZW50cmUueTtcblxuICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgdG90YWwubWFzcyk7XG4gICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB0b3RhbC5pbmVydGlhKTtcbiAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB0b3RhbC5jZW50cmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBpbnN0YW50bHkuIFZlbG9jaXR5LCBhbmdsZSwgZm9yY2UgZXRjLiBhcmUgdW5jaGFuZ2VkLlxuICAgICAqIEBtZXRob2Qgc2V0UG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBCb2R5LnNldFBvc2l0aW9uID0gZnVuY3Rpb24oYm9keSwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGRlbHRhID0gVmVjdG9yLnN1Yihwb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gZGVsdGEueDtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSArPSBkZWx0YS55O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGRlbHRhLng7XG4gICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgKz0gZGVsdGEueTtcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBkZWx0YSk7XG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbmdsZSBvZiB0aGUgYm9keSBpbnN0YW50bHkuIEFuZ3VsYXIgdmVsb2NpdHksIHBvc2l0aW9uLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuXG4gICAgICogQG1ldGhvZCBzZXRBbmdsZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIEJvZHkuc2V0QW5nbGUgPSBmdW5jdGlvbihib2R5LCBhbmdsZSkge1xuICAgICAgICB2YXIgZGVsdGEgPSBhbmdsZSAtIGJvZHkuYW5nbGU7XG4gICAgICAgIGJvZHkuYW5nbGVQcmV2ICs9IGRlbHRhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuICAgICAgICAgICAgcGFydC5hbmdsZSArPSBkZWx0YTtcbiAgICAgICAgICAgIFZlcnRpY2VzLnJvdGF0ZShwYXJ0LnZlcnRpY2VzLCBkZWx0YSwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgICAgICBBeGVzLnJvdGF0ZShwYXJ0LmF4ZXMsIGRlbHRhKTtcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGRlbHRhLCBib2R5LnBvc2l0aW9uLCBwYXJ0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaW5lYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkgaW5zdGFudGx5LiBQb3NpdGlvbiwgYW5nbGUsIGZvcmNlIGV0Yy4gYXJlIHVuY2hhbmdlZC4gU2VlIGFsc28gYEJvZHkuYXBwbHlGb3JjZWAuXG4gICAgICogQG1ldGhvZCBzZXRWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWxvY2l0eVxuICAgICAqL1xuICAgIEJvZHkuc2V0VmVsb2NpdHkgPSBmdW5jdGlvbihib2R5LCB2ZWxvY2l0eSkge1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gYm9keS5wb3NpdGlvbi54IC0gdmVsb2NpdHkueDtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueSAtIHZlbG9jaXR5Lnk7XG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9IHZlbG9jaXR5Lng7XG4gICAgICAgIGJvZHkudmVsb2NpdHkueSA9IHZlbG9jaXR5Lnk7XG4gICAgICAgIGJvZHkuc3BlZWQgPSBWZWN0b3IubWFnbml0dWRlKGJvZHkudmVsb2NpdHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5IGluc3RhbnRseS4gUG9zaXRpb24sIGFuZ2xlLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuIFNlZSBhbHNvIGBCb2R5LmFwcGx5Rm9yY2VgLlxuICAgICAqIEBtZXRob2Qgc2V0QW5ndWxhclZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZlbG9jaXR5XG4gICAgICovXG4gICAgQm9keS5zZXRBbmd1bGFyVmVsb2NpdHkgPSBmdW5jdGlvbihib2R5LCB2ZWxvY2l0eSkge1xuICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGUgLSB2ZWxvY2l0eTtcbiAgICAgICAgYm9keS5hbmd1bGFyVmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgICAgYm9keS5hbmd1bGFyU3BlZWQgPSBNYXRoLmFicyhib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgYm9keSBieSBhIGdpdmVuIHZlY3RvciByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBwb3NpdGlvbiwgd2l0aG91dCBpbXBhcnRpbmcgYW55IHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXG4gICAgICovXG4gICAgQm9keS50cmFuc2xhdGUgPSBmdW5jdGlvbihib2R5LCB0cmFuc2xhdGlvbikge1xuICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIFZlY3Rvci5hZGQoYm9keS5wb3NpdGlvbiwgdHJhbnNsYXRpb24pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhIGJvZHkgYnkgYSBnaXZlbiBhbmdsZSByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBhbmdsZSwgd2l0aG91dCBpbXBhcnRpbmcgYW55IGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW3BvaW50XVxuICAgICAqL1xuICAgIEJvZHkucm90YXRlID0gZnVuY3Rpb24oYm9keSwgcm90YXRpb24sIHBvaW50KSB7XG4gICAgICAgIGlmICghcG9pbnQpIHtcbiAgICAgICAgICAgIEJvZHkuc2V0QW5nbGUoYm9keSwgYm9keS5hbmdsZSArIHJvdGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbiksXG4gICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW4ocm90YXRpb24pLFxuICAgICAgICAgICAgICAgIGR4ID0gYm9keS5wb3NpdGlvbi54IC0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICBkeSA9IGJvZHkucG9zaXRpb24ueSAtIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgKGR4ICogY29zIC0gZHkgKiBzaW4pLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIGJvZHkuYW5nbGUgKyByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIHRoZSBib2R5LCBpbmNsdWRpbmcgdXBkYXRpbmcgcGh5c2ljYWwgcHJvcGVydGllcyAobWFzcywgYXJlYSwgYXhlcywgaW5lcnRpYSksIGZyb20gYSB3b3JsZC1zcGFjZSBwb2ludCAoZGVmYXVsdCBpcyBib2R5IGNlbnRyZSkuXG4gICAgICogQG1ldGhvZCBzY2FsZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtwb2ludF1cbiAgICAgKi9cbiAgICBCb2R5LnNjYWxlID0gZnVuY3Rpb24oYm9keSwgc2NhbGVYLCBzY2FsZVksIHBvaW50KSB7XG4gICAgICAgIHZhciB0b3RhbEFyZWEgPSAwLFxuICAgICAgICAgICAgdG90YWxJbmVydGlhID0gMDtcblxuICAgICAgICBwb2ludCA9IHBvaW50IHx8IGJvZHkucG9zaXRpb247XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG5cbiAgICAgICAgICAgIC8vIHNjYWxlIHZlcnRpY2VzXG4gICAgICAgICAgICBWZXJ0aWNlcy5zY2FsZShwYXJ0LnZlcnRpY2VzLCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgcGFydC5heGVzID0gQXhlcy5mcm9tVmVydGljZXMocGFydC52ZXJ0aWNlcyk7XG4gICAgICAgICAgICBwYXJ0LmFyZWEgPSBWZXJ0aWNlcy5hcmVhKHBhcnQudmVydGljZXMpO1xuICAgICAgICAgICAgQm9keS5zZXRNYXNzKHBhcnQsIGJvZHkuZGVuc2l0eSAqIHBhcnQuYXJlYSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBpbmVydGlhIChyZXF1aXJlcyB2ZXJ0aWNlcyB0byBiZSBhdCBvcmlnaW4pXG4gICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgeyB4OiAtcGFydC5wb3NpdGlvbi54LCB5OiAtcGFydC5wb3NpdGlvbi55IH0pO1xuICAgICAgICAgICAgQm9keS5zZXRJbmVydGlhKHBhcnQsIEJvZHkuX2luZXJ0aWFTY2FsZSAqIFZlcnRpY2VzLmluZXJ0aWEocGFydC52ZXJ0aWNlcywgcGFydC5tYXNzKSk7XG4gICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgeyB4OiBwYXJ0LnBvc2l0aW9uLngsIHk6IHBhcnQucG9zaXRpb24ueSB9KTtcblxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG90YWxBcmVhICs9IHBhcnQuYXJlYTtcbiAgICAgICAgICAgICAgICB0b3RhbEluZXJ0aWEgKz0gcGFydC5pbmVydGlhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzY2FsZSBwb3NpdGlvblxuICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ID0gcG9pbnQueCArIChwYXJ0LnBvc2l0aW9uLnggLSBwb2ludC54KSAqIHNjYWxlWDtcbiAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSA9IHBvaW50LnkgKyAocGFydC5wb3NpdGlvbi55IC0gcG9pbnQueSkgKiBzY2FsZVk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBib3VuZHNcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHBhcmVudCBib2R5XG4gICAgICAgIGlmIChib2R5LnBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGJvZHkuYXJlYSA9IHRvdGFsQXJlYTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LmlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIGJvZHkuZGVuc2l0eSAqIHRvdGFsQXJlYSk7XG4gICAgICAgICAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIHRvdGFsSW5lcnRpYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgY2lyY2xlc1xuICAgICAgICBpZiAoYm9keS5jaXJjbGVSYWRpdXMpIHsgXG4gICAgICAgICAgICBpZiAoc2NhbGVYID09PSBzY2FsZVkpIHtcbiAgICAgICAgICAgICAgICBib2R5LmNpcmNsZVJhZGl1cyAqPSBzY2FsZVg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGJvZHkgaXMgbm8gbG9uZ2VyIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgYm9keS5jaXJjbGVSYWRpdXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgc2ltdWxhdGlvbiBzdGVwIGZvciB0aGUgZ2l2ZW4gYGJvZHlgLCBpbmNsdWRpbmcgdXBkYXRpbmcgcG9zaXRpb24gYW5kIGFuZ2xlIHVzaW5nIFZlcmxldCBpbnRlZ3JhdGlvbi5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvcnJlY3Rpb25cbiAgICAgKi9cbiAgICBCb2R5LnVwZGF0ZSA9IGZ1bmN0aW9uKGJvZHksIGRlbHRhVGltZSwgdGltZVNjYWxlLCBjb3JyZWN0aW9uKSB7XG4gICAgICAgIHZhciBkZWx0YVRpbWVTcXVhcmVkID0gTWF0aC5wb3coZGVsdGFUaW1lICogdGltZVNjYWxlICogYm9keS50aW1lU2NhbGUsIDIpO1xuXG4gICAgICAgIC8vIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgICAgdmFyIGZyaWN0aW9uQWlyID0gMSAtIGJvZHkuZnJpY3Rpb25BaXIgKiB0aW1lU2NhbGUgKiBib2R5LnRpbWVTY2FsZSxcbiAgICAgICAgICAgIHZlbG9jaXR5UHJldlggPSBib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54LFxuICAgICAgICAgICAgdmVsb2NpdHlQcmV2WSA9IGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2Lnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IHdpdGggVmVybGV0IGludGVncmF0aW9uXG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9ICh2ZWxvY2l0eVByZXZYICogZnJpY3Rpb25BaXIgKiBjb3JyZWN0aW9uKSArIChib2R5LmZvcmNlLnggLyBib2R5Lm1hc3MpICogZGVsdGFUaW1lU3F1YXJlZDtcbiAgICAgICAgYm9keS52ZWxvY2l0eS55ID0gKHZlbG9jaXR5UHJldlkgKiBmcmljdGlvbkFpciAqIGNvcnJlY3Rpb24pICsgKGJvZHkuZm9yY2UueSAvIGJvZHkubWFzcykgKiBkZWx0YVRpbWVTcXVhcmVkO1xuXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnk7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueCArPSBib2R5LnZlbG9jaXR5Lng7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueSArPSBib2R5LnZlbG9jaXR5Lnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGFuZ3VsYXIgdmVsb2NpdHkgd2l0aCBWZXJsZXQgaW50ZWdyYXRpb25cbiAgICAgICAgYm9keS5hbmd1bGFyVmVsb2NpdHkgPSAoKGJvZHkuYW5nbGUgLSBib2R5LmFuZ2xlUHJldikgKiBmcmljdGlvbkFpciAqIGNvcnJlY3Rpb24pICsgKGJvZHkudG9ycXVlIC8gYm9keS5pbmVydGlhKSAqIGRlbHRhVGltZVNxdWFyZWQ7XG4gICAgICAgIGJvZHkuYW5nbGVQcmV2ID0gYm9keS5hbmdsZTtcbiAgICAgICAgYm9keS5hbmdsZSArPSBib2R5LmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgICAgICAvLyB0cmFjayBzcGVlZCBhbmQgYWNjZWxlcmF0aW9uXG4gICAgICAgIGJvZHkuc3BlZWQgPSBWZWN0b3IubWFnbml0dWRlKGJvZHkudmVsb2NpdHkpO1xuICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IE1hdGguYWJzKGJvZHkuYW5ndWxhclZlbG9jaXR5KTtcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIGJvZHkgZ2VvbWV0cnlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG5cbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGJvZHkudmVsb2NpdHkueDtcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgKz0gYm9keS52ZWxvY2l0eS55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYm9keS5hbmd1bGFyVmVsb2NpdHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgYm9keS5hbmd1bGFyVmVsb2NpdHksIGJvZHkucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBWZWN0b3Iucm90YXRlQWJvdXQocGFydC5wb3NpdGlvbiwgYm9keS5hbmd1bGFyVmVsb2NpdHksIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGZvcmNlIHRvIGEgYm9keSBmcm9tIGEgZ2l2ZW4gd29ybGQtc3BhY2UgcG9zaXRpb24sIGluY2x1ZGluZyByZXN1bHRpbmcgdG9ycXVlLlxuICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBmb3JjZVxuICAgICAqL1xuICAgIEJvZHkuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGJvZHksIHBvc2l0aW9uLCBmb3JjZSkge1xuICAgICAgICBib2R5LmZvcmNlLnggKz0gZm9yY2UueDtcbiAgICAgICAgYm9keS5mb3JjZS55ICs9IGZvcmNlLnk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB7IHg6IHBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uLnkgfTtcbiAgICAgICAgYm9keS50b3JxdWUgKz0gb2Zmc2V0LnggKiBmb3JjZS55IC0gb2Zmc2V0LnkgKiBmb3JjZS54O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW1zIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHkuXG4gICAgICogQG1ldGhvZCBfdG90YWxQcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHt9XG4gICAgICovXG4gICAgQm9keS5fdG90YWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAvLyBmcm9tIGVxdWF0aW9ucyBhdDpcbiAgICAgICAgLy8gaHR0cHM6Ly9lY291cnNlcy5vdS5lZHUvY2dpLWJpbi9lYm9vay5jZ2k/ZG9jPSZ0b3BpYz1zdCZjaGFwX3NlYz0wNy4yJnBhZ2U9dGhlb3J5XG4gICAgICAgIC8vIGh0dHA6Ly9vdXRwdXQudG8vc2lkZXdheS9kZWZhdWx0LmFzcD9xbm89MTIxMTAwMDg3XG5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgICAgYXJlYTogMCxcbiAgICAgICAgICAgIGluZXJ0aWE6IDAsXG4gICAgICAgICAgICBjZW50cmU6IHsgeDogMCwgeTogMCB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3VtIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHlcbiAgICAgICAgZm9yICh2YXIgaSA9IGJvZHkucGFydHMubGVuZ3RoID09PSAxID8gMCA6IDE7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV0sXG4gICAgICAgICAgICAgICAgbWFzcyA9IHBhcnQubWFzcyAhPT0gSW5maW5pdHkgPyBwYXJ0Lm1hc3MgOiAxO1xuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLm1hc3MgKz0gbWFzcztcbiAgICAgICAgICAgIHByb3BlcnRpZXMuYXJlYSArPSBwYXJ0LmFyZWE7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmluZXJ0aWEgKz0gcGFydC5pbmVydGlhO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jZW50cmUgPSBWZWN0b3IuYWRkKHByb3BlcnRpZXMuY2VudHJlLCBWZWN0b3IubXVsdChwYXJ0LnBvc2l0aW9uLCBtYXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmNlbnRyZSA9IFZlY3Rvci5kaXYocHJvcGVydGllcy5jZW50cmUsIHByb3BlcnRpZXMubWFzcyk7XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBib2R5IHN0YXJ0cyBzbGVlcGluZyAod2hlcmUgYHRoaXNgIGlzIHRoZSBib2R5KS5cbiAgICAqXG4gICAgKiBAZXZlbnQgc2xlZXBTdGFydFxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIHN0YXJ0ZWQgc2xlZXBpbmdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgYm9keSBlbmRzIHNsZWVwaW5nICh3aGVyZSBgdGhpc2AgaXMgdGhlIGJvZHkpLlxuICAgICpcbiAgICAqIEBldmVudCBzbGVlcEVuZFxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIGVuZGVkIHNsZWVwaW5nXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB1bmlxdWVseSBpZGVudGlmeWluZyBudW1iZXIgZ2VuZXJhdGVkIGluIGBCb2R5LmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJib2R5XCJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBib2RpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkJvZHlcIlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYm9kaWVzIHRoYXQgbWFrZSB1cCB0aGlzIGJvZHkuIFxuICAgICAqIFRoZSBmaXJzdCBib2R5IGluIHRoZSBhcnJheSBtdXN0IGFsd2F5cyBiZSBhIHNlbGYgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGJvZHkgaW5zdGFuY2UuXG4gICAgICogQWxsIGJvZGllcyBpbiB0aGUgYHBhcnRzYCBhcnJheSB0b2dldGhlciBmb3JtIGEgc2luZ2xlIHJpZ2lkIGNvbXBvdW5kIGJvZHkuXG4gICAgICogUGFydHMgYXJlIGFsbG93ZWQgdG8gb3ZlcmxhcCwgaGF2ZSBnYXBzIG9yIGhvbGVzIG9yIGV2ZW4gZm9ybSBjb25jYXZlIGJvZGllcy5cbiAgICAgKiBQYXJ0cyB0aGVtc2VsdmVzIHNob3VsZCBuZXZlciBiZSBhZGRlZCB0byBhIGBXb3JsZGAsIG9ubHkgdGhlIHBhcmVudCBib2R5IHNob3VsZCBiZS5cbiAgICAgKiBVc2UgYEJvZHkuc2V0UGFydHNgIHdoZW4gc2V0dGluZyBwYXJ0cyB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBhcnRzXG4gICAgICogQHR5cGUgYm9keVtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVzZXJ2ZWQgZm9yIHN0b3JpbmcgcGx1Z2luLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgc2VsZiByZWZlcmVuY2UgaWYgdGhlIGJvZHkgaXMgX25vdF8gYSBwYXJ0IG9mIGFub3RoZXIgYm9keS5cbiAgICAgKiBPdGhlcndpc2UgdGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgYm9keSB0aGF0IHRoaXMgaXMgYSBwYXJ0IG9mLlxuICAgICAqIFNlZSBgYm9keS5wYXJ0c2AuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XG4gICAgICogQHR5cGUgYm9keVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCBzcGVjaWZ5aW5nIHRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGBWZWN0b3JgIG9iamVjdHMgdGhhdCBzcGVjaWZ5IHRoZSBjb252ZXggaHVsbCBvZiB0aGUgcmlnaWQgYm9keS5cbiAgICAgKiBUaGVzZSBzaG91bGQgYmUgcHJvdmlkZWQgYWJvdXQgdGhlIG9yaWdpbiBgKDAsIDApYC4gRS5nLlxuICAgICAqXG4gICAgICogICAgIFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAyNSwgeTogNTAgfSwgeyB4OiA1MCwgeTogMCB9XVxuICAgICAqXG4gICAgICogV2hlbiBwYXNzZWQgdmlhIGBCb2R5LmNyZWF0ZWAsIHRoZSB2ZXJ0aWNlcyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byBgYm9keS5wb3NpdGlvbmAgKGkuZS4gd29ybGQtc3BhY2UsIGFuZCBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgc2ltdWxhdGlvbikuXG4gICAgICogVGhlIGBWZWN0b3JgIG9iamVjdHMgYXJlIGFsc28gYXVnbWVudGVkIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIGZvciBlZmZpY2llbnQgY29sbGlzaW9uIGRldGVjdGlvbi4gXG4gICAgICpcbiAgICAgKiBPdGhlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgYGluZXJ0aWFgIGFuZCBgYm91bmRzYCBhcmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlIHBhc3NlZCB2ZXJ0aWNlcyAodW5sZXNzIHByb3ZpZGVkIHZpYSBgb3B0aW9uc2ApLlxuICAgICAqIENvbmNhdmUgaHVsbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLiBUaGUgbW9kdWxlIGBNYXR0ZXIuVmVydGljZXNgIGNvbnRhaW5zIHVzZWZ1bCBtZXRob2RzIGZvciB3b3JraW5nIHdpdGggdmVydGljZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB2ZWN0b3JbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgc3BlY2lmaWVzIHRoZSBmb3JjZSB0byBhcHBseSBpbiB0aGUgY3VycmVudCBzdGVwLiBJdCBpcyB6ZXJvZWQgYWZ0ZXIgZXZlcnkgYEJvZHkudXBkYXRlYC4gU2VlIGFsc28gYEJvZHkuYXBwbHlGb3JjZWAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdG9ycXVlICh0dXJuaW5nIGZvcmNlKSB0byBhcHBseSBpbiB0aGUgY3VycmVudCBzdGVwLiBJdCBpcyB6ZXJvZWQgYWZ0ZXIgZXZlcnkgYEJvZHkudXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0b3JxdWVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgY3VycmVudCBzcGVlZCBvZiB0aGUgYm9keSBhZnRlciB0aGUgbGFzdCBgQm9keS51cGRhdGVgLiBJdCBpcyByZWFkLW9ubHkgYW5kIGFsd2F5cyBwb3NpdGl2ZSAoaXQncyB0aGUgbWFnbml0dWRlIG9mIGBib2R5LnZlbG9jaXR5YCkuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgc3BlZWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgY3VycmVudCBhbmd1bGFyIHNwZWVkIG9mIHRoZSBib2R5IGFmdGVyIHRoZSBsYXN0IGBCb2R5LnVwZGF0ZWAuIEl0IGlzIHJlYWQtb25seSBhbmQgYWx3YXlzIHBvc2l0aXZlIChpdCdzIHRoZSBtYWduaXR1ZGUgb2YgYGJvZHkuYW5ndWxhclZlbG9jaXR5YCkuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclNwZWVkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IF9tZWFzdXJlc18gdGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5LiBcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBtb2RpZnkgYSBib2R5J3MgdmVsb2NpdHkgZGlyZWN0bHksIHlvdSBzaG91bGQgZWl0aGVyIGFwcGx5IGEgZm9yY2Ugb3Igc2ltcGx5IGNoYW5nZSB0aGUgYm9keSdzIGBwb3NpdGlvbmAgKGFzIHRoZSBlbmdpbmUgdXNlcyBwb3NpdGlvbi1WZXJsZXQgaW50ZWdyYXRpb24pLlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBfbWVhc3VyZXNfIHRoZSBjdXJyZW50IGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5LiBcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBtb2RpZnkgYSBib2R5J3MgYW5ndWxhciB2ZWxvY2l0eSBkaXJlY3RseSwgeW91IHNob3VsZCBhcHBseSBhIHRvcnF1ZSBvciBzaW1wbHkgY2hhbmdlIHRoZSBib2R5J3MgYGFuZ2xlYCAoYXMgdGhlIGVuZ2luZSB1c2VzIHBvc2l0aW9uLVZlcmxldCBpbnRlZ3JhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBib2R5IGlzIGNvbnNpZGVyZWQgc3RhdGljLiBBIHN0YXRpYyBib2R5IGNhbiBuZXZlciBjaGFuZ2UgcG9zaXRpb24gb3IgYW5nbGUgYW5kIGlzIGNvbXBsZXRlbHkgZml4ZWQuXG4gICAgICogSWYgeW91IG5lZWQgdG8gc2V0IGEgYm9keSBhcyBzdGF0aWMgYWZ0ZXIgaXRzIGNyZWF0aW9uLCB5b3Ugc2hvdWxkIHVzZSBgQm9keS5zZXRTdGF0aWNgIGFzIHRoaXMgcmVxdWlyZXMgbW9yZSB0aGFuIGp1c3Qgc2V0dGluZyB0aGlzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNTdGF0aWNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgYm9keSBpcyBhIHNlbnNvci4gU2Vuc29yIHRyaWdnZXJzIGNvbGxpc2lvbiBldmVudHMsIGJ1dCBkb2Vzbid0IHJlYWN0IHdpdGggY29sbGlkaW5nIGJvZHkgcGh5c2ljYWxseS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc1NlbnNvclxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcGluZy4gQSBzbGVlcGluZyBib2R5IGFjdHMgc2ltaWxhciB0byBhIHN0YXRpYyBib2R5LCBleGNlcHQgaXQgaXMgb25seSB0ZW1wb3JhcnkgYW5kIGNhbiBiZSBhd29rZW4uXG4gICAgICogSWYgeW91IG5lZWQgdG8gc2V0IGEgYm9keSBhcyBzbGVlcGluZywgeW91IHNob3VsZCB1c2UgYFNsZWVwaW5nLnNldGAgYXMgdGhpcyByZXF1aXJlcyBtb3JlIHRoYW4ganVzdCBzZXR0aW5nIHRoaXMgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc1NsZWVwaW5nXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgYW1vdW50IG9mIG1vdmVtZW50IGEgYm9keSBjdXJyZW50bHkgaGFzIChhIGNvbWJpbmF0aW9uIG9mIGBzcGVlZGAgYW5kIGBhbmd1bGFyU3BlZWRgKS4gSXQgaXMgcmVhZC1vbmx5IGFuZCBhbHdheXMgcG9zaXRpdmUuXG4gICAgICogSXQgaXMgdXNlZCBhbmQgdXBkYXRlZCBieSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIGR1cmluZyBzaW11bGF0aW9uIHRvIGRlY2lkZSBpZiBhIGJvZHkgaGFzIGNvbWUgdG8gcmVzdC5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBtb3Rpb25cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIHVwZGF0ZXMgaW4gd2hpY2ggdGhpcyBib2R5IG11c3QgaGF2ZSBuZWFyLXplcm8gdmVsb2NpdHkgYmVmb3JlIGl0IGlzIHNldCBhcyBzbGVlcGluZyBieSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIChpZiBzbGVlcGluZyBpcyBlbmFibGVkIGJ5IHRoZSBlbmdpbmUpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGhyZXNob2xkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgNjBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBkZW5zaXR5IG9mIHRoZSBib2R5LCB0aGF0IGlzIGl0cyBtYXNzIHBlciB1bml0IGFyZWEuXG4gICAgICogSWYgeW91IHBhc3MgdGhlIGRlbnNpdHkgdmlhIGBCb2R5LmNyZWF0ZWAgdGhlIGBtYXNzYCBwcm9wZXJ0eSBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZm9yIHlvdSBiYXNlZCBvbiB0aGUgc2l6ZSAoYXJlYSkgb2YgdGhlIG9iamVjdC5cbiAgICAgKiBUaGlzIGlzIGdlbmVyYWxseSBwcmVmZXJhYmxlIHRvIHNpbXBseSBzZXR0aW5nIG1hc3MgYW5kIGFsbG93cyBmb3IgbW9yZSBpbnR1aXRpdmUgZGVmaW5pdGlvbiBvZiBtYXRlcmlhbHMgKGUuZy4gcm9jayBoYXMgYSBoaWdoZXIgZGVuc2l0eSB0aGFuIHdvb2QpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRlbnNpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG1hc3Mgb2YgdGhlIGJvZHksIGFsdGhvdWdoIGl0IG1heSBiZSBtb3JlIGFwcHJvcHJpYXRlIHRvIHNwZWNpZnkgdGhlIGBkZW5zaXR5YCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIElmIHlvdSBtb2RpZnkgdGhpcyB2YWx1ZSwgeW91IG11c3QgYWxzbyBtb2RpZnkgdGhlIGBib2R5LmludmVyc2VNYXNzYCBwcm9wZXJ0eSAoYDEgLyBtYXNzYCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keSAoYDEgLyBtYXNzYCkuXG4gICAgICogSWYgeW91IG1vZGlmeSB0aGlzIHZhbHVlLCB5b3UgbXVzdCBhbHNvIG1vZGlmeSB0aGUgYGJvZHkubWFzc2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaW52ZXJzZU1hc3NcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBtb21lbnQgb2YgaW5lcnRpYSAoaS5lLiBzZWNvbmQgbW9tZW50IG9mIGFyZWEpIG9mIHRoZSBib2R5LlxuICAgICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgYW5kIGRlbnNpdHkgaW4gYEJvZHkuY3JlYXRlYC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5pbnZlcnNlSW5lcnRpYWAgcHJvcGVydHkgKGAxIC8gaW5lcnRpYWApLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBpbnZlcnNlIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBib2R5IChgMSAvIGluZXJ0aWFgKS5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5pbmVydGlhYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpbnZlcnNlSW5lcnRpYVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHJlc3RpdHV0aW9uIChlbGFzdGljaXR5KSBvZiB0aGUgYm9keS4gVGhlIHZhbHVlIGlzIGFsd2F5cyBwb3NpdGl2ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGAoMCwgMSlgLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIGNvbGxpc2lvbnMgbWF5IGJlIHBlcmZlY3RseSBpbmVsYXN0aWMgYW5kIG5vIGJvdW5jaW5nIG1heSBvY2N1ci4gXG4gICAgICogQSB2YWx1ZSBvZiBgMC44YCBtZWFucyB0aGUgYm9keSBtYXkgYm91bmNlIGJhY2sgd2l0aCBhcHByb3hpbWF0ZWx5IDgwJSBvZiBpdHMga2luZXRpYyBlbmVyZ3kuXG4gICAgICogTm90ZSB0aGF0IGNvbGxpc2lvbiByZXNwb25zZSBpcyBiYXNlZCBvbiBfcGFpcnNfIG9mIGJvZGllcywgYW5kIHRoYXQgYHJlc3RpdHV0aW9uYCB2YWx1ZXMgYXJlIF9jb21iaW5lZF8gd2l0aCB0aGUgZm9sbG93aW5nIGZvcm11bGE6XG4gICAgICpcbiAgICAgKiAgICAgTWF0aC5tYXgoYm9keUEucmVzdGl0dXRpb24sIGJvZHlCLnJlc3RpdHV0aW9uKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGZyaWN0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmFsdWUgaXMgYWx3YXlzIHBvc2l0aXZlIGFuZCBpcyBpbiB0aGUgcmFuZ2UgYCgwLCAxKWAuXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgdGhhdCB0aGUgYm9keSBtYXkgc2xpZGUgaW5kZWZpbml0ZWx5LlxuICAgICAqIEEgdmFsdWUgb2YgYDFgIG1lYW5zIHRoZSBib2R5IG1heSBjb21lIHRvIGEgc3RvcCBhbG1vc3QgaW5zdGFudGx5IGFmdGVyIGEgZm9yY2UgaXMgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3RzIG9mIHRoZSB2YWx1ZSBtYXkgYmUgbm9uLWxpbmVhci4gXG4gICAgICogSGlnaCB2YWx1ZXMgbWF5IGJlIHVuc3RhYmxlIGRlcGVuZGluZyBvbiB0aGUgYm9keS5cbiAgICAgKiBUaGUgZW5naW5lIHVzZXMgYSBDb3Vsb21iIGZyaWN0aW9uIG1vZGVsIGluY2x1ZGluZyBzdGF0aWMgYW5kIGtpbmV0aWMgZnJpY3Rpb24uXG4gICAgICogTm90ZSB0aGF0IGNvbGxpc2lvbiByZXNwb25zZSBpcyBiYXNlZCBvbiBfcGFpcnNfIG9mIGJvZGllcywgYW5kIHRoYXQgYGZyaWN0aW9uYCB2YWx1ZXMgYXJlIF9jb21iaW5lZF8gd2l0aCB0aGUgZm9sbG93aW5nIGZvcm11bGE6XG4gICAgICpcbiAgICAgKiAgICAgTWF0aC5taW4oYm9keUEuZnJpY3Rpb24sIGJvZHlCLmZyaWN0aW9uKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgc3RhdGljIGZyaWN0aW9uIG9mIHRoZSBib2R5IChpbiB0aGUgQ291bG9tYiBmcmljdGlvbiBtb2RlbCkuIFxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBib2R5IHdpbGwgbmV2ZXIgJ3N0aWNrJyB3aGVuIGl0IGlzIG5lYXJseSBzdGF0aW9uYXJ5IGFuZCBvbmx5IGR5bmFtaWMgYGZyaWN0aW9uYCBpcyB1c2VkLlxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlIChlLmcuIGAxMGApLCB0aGUgbW9yZSBmb3JjZSBpdCB3aWxsIHRha2UgdG8gaW5pdGlhbGx5IGdldCB0aGUgYm9keSBtb3Zpbmcgd2hlbiBuZWFybHkgc3RhdGlvbmFyeS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIG11bHRpcGxpZWQgd2l0aCB0aGUgYGZyaWN0aW9uYCBwcm9wZXJ0eSB0byBtYWtlIGl0IGVhc2llciB0byBjaGFuZ2UgYGZyaWN0aW9uYCBhbmQgbWFpbnRhaW4gYW4gYXBwcm9wcmlhdGUgYW1vdW50IG9mIHN0YXRpYyBmcmljdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0YXRpY1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGFpciBmcmljdGlvbiBvZiB0aGUgYm9keSAoYWlyIHJlc2lzdGFuY2UpLiBcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGUgYm9keSB3aWxsIG5ldmVyIHNsb3cgYXMgaXQgbW92ZXMgdGhyb3VnaCBzcGFjZS5cbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGZhc3RlciBhIGJvZHkgc2xvd3Mgd2hlbiBtb3ZpbmcgdGhyb3VnaCBzcGFjZS5cbiAgICAgKiBUaGUgZWZmZWN0cyBvZiB0aGUgdmFsdWUgYXJlIG5vbi1saW5lYXIuIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQWlyXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBmaWx0ZXJpbmcgcHJvcGVydGllcyBvZiB0aGlzIGJvZHkuXG4gICAgICpcbiAgICAgKiBDb2xsaXNpb25zIGJldHdlZW4gdHdvIGJvZGllcyB3aWxsIG9iZXkgdGhlIGZvbGxvd2luZyBydWxlczpcbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgdGhlIHNhbWUgbm9uLXplcm8gdmFsdWUgb2YgYGNvbGxpc2lvbkZpbHRlci5ncm91cGAsXG4gICAgICogICB0aGV5IHdpbGwgYWx3YXlzIGNvbGxpZGUgaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlLCBhbmQgdGhleSB3aWxsIG5ldmVyIGNvbGxpZGVcbiAgICAgKiAgIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgZGlmZmVyZW50IHZhbHVlcyBvZiBgY29sbGlzaW9uRmlsdGVyLmdyb3VwYCBvciBpZiBvbmVcbiAgICAgKiAgIChvciBib3RoKSBvZiB0aGUgYm9kaWVzIGhhcyBhIHZhbHVlIG9mIDAsIHRoZW4gdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMgYXBwbHkgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIEVhY2ggYm9keSBiZWxvbmdzIHRvIGEgY29sbGlzaW9uIGNhdGVnb3J5LCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLmNhdGVnb3J5YC4gVGhpc1xuICAgICAqIHZhbHVlIGlzIHVzZWQgYXMgYSBiaXQgZmllbGQgYW5kIHRoZSBjYXRlZ29yeSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBtZWFuaW5nIHRoYXRcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBhIHBvd2VyIG9mIHR3byBpbiB0aGUgcmFuZ2UgWzEsIDJeMzFdLiBUaHVzLCB0aGVyZSBhcmUgMzJcbiAgICAgKiBkaWZmZXJlbnQgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogRWFjaCBib2R5IGFsc28gZGVmaW5lcyBhIGNvbGxpc2lvbiBiaXRtYXNrLCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLm1hc2tgIHdoaWNoIHNwZWNpZmllc1xuICAgICAqIHRoZSBjYXRlZ29yaWVzIGl0IGNvbGxpZGVzIHdpdGggKHRoZSB2YWx1ZSBpcyB0aGUgYml0d2lzZSBBTkQgdmFsdWUgb2YgYWxsIHRoZXNlIGNhdGVnb3JpZXMpLlxuICAgICAqXG4gICAgICogVXNpbmcgdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMsIHR3byBib2RpZXMgYEFgIGFuZCBgQmAgY29sbGlkZSBpZiBlYWNoIGluY2x1ZGVzIHRoZSBvdGhlcidzXG4gICAgICogY2F0ZWdvcnkgaW4gaXRzIG1hc2ssIGkuZS4gYChjYXRlZ29yeUEgJiBtYXNrQikgIT09IDBgIGFuZCBgKGNhdGVnb3J5QiAmIG1hc2tBKSAhPT0gMGBcbiAgICAgKiBhcmUgYm90aCB0cnVlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlclxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gSW50ZWdlciBgTnVtYmVyYCwgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBncm91cCB0aGlzIGJvZHkgYmVsb25ncyB0by5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXIuZ3JvdXBcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGJpdCBmaWVsZCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGNhdGVnb3J5IHRoaXMgYm9keSBiZWxvbmdzIHRvLlxuICAgICAqIFRoZSBjYXRlZ29yeSB2YWx1ZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBmb3IgZXhhbXBsZSBgMHgwMDAxYC5cbiAgICAgKiBUaGlzIG1lYW5zIHRoZXJlIGFyZSB1cCB0byAzMiB1bmlxdWUgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5jYXRlZ29yeVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYml0IG1hc2sgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBjYXRlZ29yaWVzIHRoaXMgYm9keSBtYXkgY29sbGlkZSB3aXRoLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5tYXNrXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgYSB0b2xlcmFuY2Ugb24gaG93IGZhciBhIGJvZHkgaXMgYWxsb3dlZCB0byAnc2luaycgb3Igcm90YXRlIGludG8gb3RoZXIgYm9kaWVzLlxuICAgICAqIEF2b2lkIGNoYW5naW5nIHRoaXMgdmFsdWUgdW5sZXNzIHlvdSB1bmRlcnN0YW5kIHRoZSBwdXJwb3NlIG9mIGBzbG9wYCBpbiBwaHlzaWNzIGVuZ2luZXMuXG4gICAgICogVGhlIGRlZmF1bHQgc2hvdWxkIGdlbmVyYWxseSBzdWZmaWNlLCBhbHRob3VnaCB2ZXJ5IGxhcmdlIGJvZGllcyBtYXkgcmVxdWlyZSBsYXJnZXIgdmFsdWVzIGZvciBzdGFibGUgc3RhY2tpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2xvcFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuMDVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBhbGxvd3MgcGVyLWJvZHkgdGltZSBzY2FsaW5nLCBlLmcuIGEgZm9yY2UtZmllbGQgd2hlcmUgYm9kaWVzIGluc2lkZSBhcmUgaW4gc2xvdy1tb3Rpb24sIHdoaWxlIG90aGVycyBhcmUgYXQgZnVsbCBzcGVlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lU2NhbGVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IGRlZmluZXMgdGhlIHJlbmRlcmluZyBwcm9wZXJ0aWVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb2R1bGUgYE1hdHRlci5SZW5kZXJgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlclxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBib2R5IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudmlzaWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIub3BhY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSBzcHJpdGUgcHJvcGVydGllcyB0byB1c2Ugd2hlbiByZW5kZXJpbmcsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgc3ByaXRlIHRleHR1cmUsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnRleHR1cmVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHgtYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueFNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHktYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSB4LWF4aXMgZm9yIHRoZSBzcHJpdGUgKG5vcm1hbGlzZWQgYnkgdGV4dHVyZSB3aWR0aCkuXG4gICAgICAqXG4gICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnhPZmZzZXRcbiAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICovXG5cbiAgICAgLyoqXG4gICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHktYXhpcyBmb3IgdGhlIHNwcml0ZSAobm9ybWFsaXNlZCBieSB0ZXh0dXJlIGhlaWdodCkuXG4gICAgICAqXG4gICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnlPZmZzZXRcbiAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbGluZSB3aWR0aCB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgb3V0bGluZSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIG5vIG91dGxpbmUgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIubGluZVdpZHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIGZpbGwgc3R5bGUgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBib2R5IChpZiBhIHNwcml0ZSBpcyBub3QgZGVmaW5lZCkuXG4gICAgICogSXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB1c2luZyBhIGNhbnZhcywgc28gaXQgYWNjZXB0cyBDU1Mgc3R5bGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5maWxsU3R5bGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2Ugc3R5bGUgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBib2R5IG91dGxpbmUgKGlmIGEgc3ByaXRlIGlzIG5vdCBkZWZpbmVkKS5cbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnN0cm9rZVN0eWxlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgYSByYW5kb20gY29sb3VyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB1bmlxdWUgYXhpcyB2ZWN0b3JzIChlZGdlIG5vcm1hbHMpIHVzZWQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG4gICAgICogVGhlc2UgYXJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgaW4gYEJvZHkuY3JlYXRlYC5cbiAgICAgKiBUaGV5IGFyZSBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgdGhlIHNpbXVsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHZlY3RvcltdXG4gICAgICovXG4gICAgIFxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBfbWVhc3VyZXNfIHRoZSBhcmVhIG9mIHRoZSBib2R5J3MgY29udmV4IGh1bGwsIGNhbGN1bGF0ZWQgYXQgY3JlYXRpb24gYnkgYEJvZHkuY3JlYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhcmVhXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIEFBQkIgcmVnaW9uIGZvciB0aGUgYm9keS5cbiAgICAgKiBJdCBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZnJvbSB0aGUgZ2l2ZW4gY29udmV4IGh1bGwgKGB2ZXJ0aWNlc2AgYXJyYXkpIGluIGBCb2R5LmNyZWF0ZWAgYW5kIGNvbnN0YW50bHkgdXBkYXRlZCBieSBgQm9keS51cGRhdGVgIGR1cmluZyBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xuICAgICAqIEB0eXBlIGJvdW5kc1xuICAgICAqL1xuXG59KSgpO1xuXG59LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9jb3JlL1NsZWVwaW5nXCI6MjIsXCIuLi9nZW9tZXRyeS9BeGVzXCI6MjUsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyOSxcIi4uL3JlbmRlci9SZW5kZXJcIjozMX1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29tcG9zaXRlIGJvZGllcy5cbiogQSBjb21wb3NpdGUgYm9keSBpcyBhIGNvbGxlY3Rpb24gb2YgYE1hdHRlci5Cb2R5YCwgYE1hdHRlci5Db25zdHJhaW50YCBhbmQgb3RoZXIgYE1hdHRlci5Db21wb3NpdGVgLCB0aGVyZWZvcmUgY29tcG9zaXRlcyBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUuXG4qIEl0IGlzIGltcG9ydGFudCB0byB1c2UgdGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB0byBtb2RpZnkgY29tcG9zaXRlcywgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoZWlyIHByb3BlcnRpZXMuXG4qIE5vdGUgdGhhdCB0aGUgYE1hdHRlci5Xb3JsZGAgb2JqZWN0IGlzIGFsc28gYSB0eXBlIG9mIGBNYXR0ZXIuQ29tcG9zaXRlYCBhbmQgYXMgc3VjaCBhbGwgY29tcG9zaXRlIG1ldGhvZHMgaGVyZSBjYW4gYWxzbyBvcGVyYXRlIG9uIGEgYE1hdHRlci5Xb3JsZGAuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb21wb3NpdGVcbiovXG5cbnZhciBDb21wb3NpdGUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGU7XG5cbnZhciBFdmVudHMgPSBfZGVyZXFfKCcuLi9jb3JlL0V2ZW50cycpO1xudmFyIENvbW1vbiA9IF9kZXJlcV8oJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgQm91bmRzID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4vQm9keScpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvc2l0ZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJpdGVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXG4gICAgICAgICAgICBpZDogQ29tbW9uLm5leHRJZCgpLFxuICAgICAgICAgICAgdHlwZTogJ2NvbXBvc2l0ZScsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBpc01vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGJvZGllczogW10sIFxuICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLCBcbiAgICAgICAgICAgIGNvbXBvc2l0ZXM6IFtdLFxuICAgICAgICAgICAgbGFiZWw6ICdDb21wb3NpdGUnLFxuICAgICAgICAgICAgcGx1Z2luOiB7fVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcG9zaXRlJ3MgYGlzTW9kaWZpZWRgIGZsYWcuIFxuICAgICAqIElmIGB1cGRhdGVQYXJlbnRzYCBpcyB0cnVlLCBhbGwgcGFyZW50cyB3aWxsIGJlIHNldCAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqIElmIGB1cGRhdGVDaGlsZHJlbmAgaXMgdHJ1ZSwgYWxsIGNoaWxkcmVuIHdpbGwgYmUgc2V0IChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICogQG1ldGhvZCBzZXRNb2RpZmllZFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVQYXJlbnRzPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZUNoaWxkcmVuPWZhbHNlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgY29tcG9zaXRlLmlzTW9kaWZpZWQgPSBpc01vZGlmaWVkO1xuXG4gICAgICAgIGlmICh1cGRhdGVQYXJlbnRzICYmIGNvbXBvc2l0ZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUucGFyZW50LCBpc01vZGlmaWVkLCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbXBvc2l0ZSA9IGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldO1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjaGlsZENvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgYWRkIGZ1bmN0aW9uLiBBZGRzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlQWRkYCBhbmQgYGFmdGVyQWRkYCBldmVudHMgb24gdGhlIGBjb21wb3NpdGVgLlxuICAgICAqIEBtZXRob2QgYWRkXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGQgPSBmdW5jdGlvbihjb21wb3NpdGUsIG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqZWN0cyA9IFtdLmNvbmNhdChvYmplY3QpO1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGNvbXBvc2l0ZSwgJ2JlZm9yZUFkZCcsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXTtcblxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAvLyBza2lwIGFkZGluZyBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChvYmoucGFyZW50ICE9PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ0NvbXBvc2l0ZS5hZGQ6IHNraXBwZWQgYWRkaW5nIGEgY29tcG91bmQgYm9keSBwYXJ0ICh5b3UgbXVzdCBhZGQgaXRzIHBhcmVudCBpbnN0ZWFkKScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUoY29tcG9zaXRlLCBvYmopO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2VDb25zdHJhaW50JzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iai5jb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYWZ0ZXJBZGQnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgcmVtb3ZlIGZ1bmN0aW9uLiBSZW1vdmVzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZVJlbW92ZWAgYW5kIGBhZnRlclJlbW92ZWAgZXZlbnRzIG9uIHRoZSBgY29tcG9zaXRlYC5cbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgb2JqZWN0LCBkZWVwKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gW10uY29uY2F0KG9iamVjdCk7XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYmVmb3JlUmVtb3ZlJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBvc2l0ZSc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZShjb21wb3NpdGUsIG9iaiwgZGVlcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZUNvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLmNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdhZnRlclJlbW92ZScsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbXBvc2l0ZSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRDb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVCXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBvYmplY3RzIGZyb20gY29tcG9zaXRlQiBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCKSB7XG4gICAgICAgIGNvbXBvc2l0ZUEuY29tcG9zaXRlcy5wdXNoKGNvbXBvc2l0ZUIpO1xuICAgICAgICBjb21wb3NpdGVCLnBhcmVudCA9IGNvbXBvc2l0ZUE7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGVBLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVBO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9zaXRlIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUFcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCLCBkZWVwKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZUEuY29tcG9zaXRlcywgY29tcG9zaXRlQik7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGVBdChjb21wb3NpdGVBLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlQSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlQS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlKGNvbXBvc2l0ZUEuY29tcG9zaXRlc1tpXSwgY29tcG9zaXRlQiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlQTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbXBvc2l0ZSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbXBvc2l0ZUF0XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGVBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29tcG9zaXRlLmNvbXBvc2l0ZXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYm9keSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRCb2R5XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBib2R5IGFkZGVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFkZEJvZHkgPSBmdW5jdGlvbihjb21wb3NpdGUsIGJvZHkpIHtcbiAgICAgICAgY29tcG9zaXRlLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBib2R5IGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBib2R5IHJlbW92ZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUucmVtb3ZlQm9keSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgYm9keSwgZGVlcCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBDb21tb24uaW5kZXhPZihjb21wb3NpdGUuYm9kaWVzLCBib2R5KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUJvZHlBdChjb21wb3NpdGUsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQm9keShjb21wb3NpdGUuY29tcG9zaXRlc1tpXSwgYm9keSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUJvZHlBdFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgYm9keSByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUJvZHlBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29tcG9zaXRlLmJvZGllcy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb25zdHJhaW50IHRvIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgYWRkZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgY29uc3RyYWludCkge1xuICAgICAgICBjb21wb3NpdGUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29uc3RyYWludCBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUsIGFuZCBvcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbnN0cmFpbnQsIGRlZXApIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gQ29tbW9uLmluZGV4T2YoY29tcG9zaXRlLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnRBdChjb21wb3NpdGUsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludChjb21wb3NpdGUuY29tcG9zaXRlc1tpXSwgY29uc3RyYWludCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRBdFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnRBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgYm9kaWVzLCBjb25zdHJhaW50cyBhbmQgY29tcG9zaXRlcyBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogT3B0aW9uYWxseSBjbGVhcmluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdGF0aWNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5jbGVhciA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwga2VlcFN0YXRpYywgZGVlcCkge1xuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLmNsZWFyKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldLCBrZWVwU3RhdGljLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGtlZXBTdGF0aWMpIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMgPSBjb21wb3NpdGUuYm9kaWVzLmZpbHRlcihmdW5jdGlvbihib2R5KSB7IHJldHVybiBib2R5LmlzU3RhdGljOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5jb25zdHJhaW50cy5sZW5ndGggPSAwO1xuICAgICAgICBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUsIGluY2x1ZGluZyBhbGwgYm9kaWVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxCb2RpZXNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBBbGwgdGhlIGJvZGllc1xuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hbGxCb2RpZXMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuYm9kaWVzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgYm9kaWVzID0gYm9kaWVzLmNvbmNhdChDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldKSk7XG5cbiAgICAgICAgcmV0dXJuIGJvZGllcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY29uc3RyYWludHMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb25zdHJhaW50cyBpbiBpdHMgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgYWxsQ29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Y29uc3RyYWludFtdfSBBbGwgdGhlIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29uc3RyYWludHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0pKTtcblxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNvbXBvc2l0ZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb21wb3NpdGVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxDb21wb3NpdGVzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZVtdfSBBbGwgdGhlIGNvbXBvc2l0ZXNcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSkge1xuICAgICAgICB2YXIgY29tcG9zaXRlcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29tcG9zaXRlcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbXBvc2l0ZXMgPSBjb21wb3NpdGVzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgY29tcG9zaXRlIHJlY3Vyc2l2ZWx5IGZvciBhbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHR5cGUgYW5kIGlkIHN1cHBsaWVkLCBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHJlcXVlc3RlZCBvYmplY3QsIGlmIGZvdW5kXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmdldCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaWQsIHR5cGUpIHtcbiAgICAgICAgdmFyIG9iamVjdHMsXG4gICAgICAgICAgICBvYmplY3Q7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkuY29uY2F0KGNvbXBvc2l0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqZWN0cylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIG9iamVjdCA9IG9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkgeyBcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuaWQudG9TdHJpbmcoKSA9PT0gaWQudG9TdHJpbmcoKTsgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmplY3QubGVuZ3RoID09PSAwID8gbnVsbCA6IG9iamVjdFswXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGdpdmVuIG9iamVjdChzKSBmcm9tIGNvbXBvc2l0ZUEgdG8gY29tcG9zaXRlQiAoZXF1YWwgdG8gYSByZW1vdmUgZm9sbG93ZWQgYnkgYW4gYWRkKS5cbiAgICAgKiBAbWV0aG9kIG1vdmVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZUF9IGNvbXBvc2l0ZUFcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBvYmplY3RzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGVCfSBjb21wb3NpdGVCXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZUFcbiAgICAgKi9cbiAgICBDb21wb3NpdGUubW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIG9iamVjdHMsIGNvbXBvc2l0ZUIpIHtcbiAgICAgICAgQ29tcG9zaXRlLnJlbW92ZShjb21wb3NpdGVBLCBvYmplY3RzKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZChjb21wb3NpdGVCLCBvYmplY3RzKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGlkcyBmb3IgYWxsIG9iamVjdHMgaW4gdGhlIGNvbXBvc2l0ZSwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCByZWJhc2VcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZWJhc2UgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKGNvbXBvc2l0ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqZWN0c1tpXS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlIGJ5IGEgZ2l2ZW4gdmVjdG9yIHJlbGF0aXZlIHRvIHRoZWlyIGN1cnJlbnQgcG9zaXRpb25zLCBcbiAgICAgKiB3aXRob3V0IGltcGFydGluZyBhbnkgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgdHJhbnNsYXRpb24sIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQm9keS50cmFuc2xhdGUoYm9kaWVzW2ldLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbXBvc2l0ZSBieSBhIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBnaXZlbiBwb2ludCwgd2l0aG91dCBpbXBhcnRpbmcgYW55IGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJvdGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcm90YXRpb24sIHBvaW50LCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKSxcbiAgICAgICAgICAgIGJvZGllcyA9IHJlY3Vyc2l2ZSA/IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSA6IGNvbXBvc2l0ZS5ib2RpZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGR4ID0gYm9keS5wb3NpdGlvbi54IC0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICBkeSA9IGJvZHkucG9zaXRpb24ueSAtIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgKGR4ICogY29zIC0gZHkgKiBzaW4pLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBCb2R5LnJvdGF0ZShib2R5LCByb3RhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlLCBpbmNsdWRpbmcgdXBkYXRpbmcgcGh5c2ljYWwgcHJvcGVydGllcyAobWFzcywgYXJlYSwgYXhlcywgaW5lcnRpYSksIGZyb20gYSB3b3JsZC1zcGFjZSBwb2ludC5cbiAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnNjYWxlID0gZnVuY3Rpb24oY29tcG9zaXRlLCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQsIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxuICAgICAgICAgICAgICAgIGR5ID0gYm9keS5wb3NpdGlvbi55IC0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyBkeCAqIHNjYWxlWCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgZHkgKiBzY2FsZVlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBCb2R5LnNjYWxlKGJvZHksIHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGUgYm91bmRzIG9mIGFsbCBvZiB0aGUgY29tcG9zaXRlJ3MgYm9kaWVzLlxuICAgICAqIEBtZXRob2QgYm91bmRzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZSBUaGUgY29tcG9zaXRlLlxuICAgICAqIEByZXR1cm5zIHtib3VuZHN9IFRoZSBjb21wb3NpdGUgYm91bmRzLlxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5ib3VuZHMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSxcbiAgICAgICAgICAgIHZlcnRpY2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChib2R5LmJvdW5kcy5taW4sIGJvZHkuYm91bmRzLm1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQm91bmRzLmNyZWF0ZSh2ZXJ0aWNlcyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUuYWRkYCBpcyBtYWRlLCBiZWZvcmUgb2JqZWN0cyBoYXZlIGJlZW4gYWRkZWQuXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZUFkZFxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRvIGJlIGFkZGVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5hZGRgIGlzIG1hZGUsIGFmdGVyIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICpcbiAgICAqIEBldmVudCBhZnRlckFkZFxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5yZW1vdmVgIGlzIG1hZGUsIGJlZm9yZSBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVSZW1vdmVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5vYmplY3QgVGhlIG9iamVjdChzKSB0byBiZSByZW1vdmVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5yZW1vdmVgIGlzIG1hZGUsIGFmdGVyIG9iamVjdHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyUmVtb3ZlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdW5pcXVlbHkgaWRlbnRpZnlpbmcgbnVtYmVyIGdlbmVyYXRlZCBpbiBgQ29tcG9zaXRlLmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJjb21wb3NpdGVcIlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJiaXRyYXJ5IGBTdHJpbmdgIG5hbWUgdG8gaGVscCB0aGUgdXNlciBpZGVudGlmeSBhbmQgbWFuYWdlIGNvbXBvc2l0ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkNvbXBvc2l0ZVwiXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgY29tcG9zaXRlIGhhcyBiZWVuIG1vZGlmaWVkIGR1cmluZyB0aGUgY3VycmVudCBzdGVwLlxuICAgICAqIE1vc3QgYE1hdHRlci5Db21wb3NpdGVgIG1ldGhvZHMgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGlzIGZsYWcgdG8gYHRydWVgIHRvIGluZm9ybSB0aGUgZW5naW5lIG9mIGNoYW5nZXMgdG8gYmUgaGFuZGxlZC5cbiAgICAgKiBJZiB5b3UgbmVlZCB0byBjaGFuZ2UgaXQgbWFudWFsbHksIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLnNldE1vZGlmaWVkYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNNb2RpZmllZFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBDb21wb3NpdGVgIHRoYXQgaXMgdGhlIHBhcmVudCBvZiB0aGlzIGNvbXBvc2l0ZS4gSXQgaXMgYXV0b21hdGljYWxseSBtYW5hZ2VkIGJ5IHRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRcbiAgICAgKiBAdHlwZSBjb21wb3NpdGVcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBgQm9keWAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBib2RpZXMgeW91IHNob3VsZCB1c2UgYENvbXBvc2l0ZS5hZGRgIGFuZCBgQ29tcG9zaXRlLnJlbW92ZWAgbWV0aG9kcyByYXRoZXIgdGhhbiBkaXJlY3RseSBtb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiBJZiB5b3Ugd2lzaCB0byByZWN1cnNpdmVseSBmaW5kIGFsbCBkZXNjZW5kYW50cywgeW91IHNob3VsZCB1c2UgdGhlIGBDb21wb3NpdGUuYWxsQm9kaWVzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICogQHR5cGUgYm9keVtdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGBDb25zdHJhaW50YCB0aGF0IGFyZSBfZGlyZWN0XyBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvc2l0ZS5cbiAgICAgKiBUbyBhZGQgb3IgcmVtb3ZlIGNvbnN0cmFpbnRzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSBjb25zdHJhaW50W11cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYENvbXBvc2l0ZWAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBjb21wb3NpdGVzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXNgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb21wb3NpdGVzXG4gICAgICogQHR5cGUgY29tcG9zaXRlW11cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsdWdpblxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbn0pKCk7XG5cbn0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4vQm9keVwiOjF9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5Xb3JsZGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgdGhlIHdvcmxkIGNvbXBvc2l0ZS5cbiogQSBgTWF0dGVyLldvcmxkYCBpcyBhIGBNYXR0ZXIuQ29tcG9zaXRlYCBib2R5LCB3aGljaCBpcyBhIGNvbGxlY3Rpb24gb2YgYE1hdHRlci5Cb2R5YCwgYE1hdHRlci5Db25zdHJhaW50YCBhbmQgb3RoZXIgYE1hdHRlci5Db21wb3NpdGVgLlxuKiBBIGBNYXR0ZXIuV29ybGRgIGhhcyBhIGZldyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW5jbHVkaW5nIGBncmF2aXR5YCBhbmQgYGJvdW5kc2AuXG4qIEl0IGlzIGltcG9ydGFudCB0byB1c2UgdGhlIGZ1bmN0aW9ucyBpbiB0aGUgYE1hdHRlci5Db21wb3NpdGVgIG1vZHVsZSB0byBtb2RpZnkgdGhlIHdvcmxkIGNvbXBvc2l0ZSwgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIGl0cyBwcm9wZXJ0aWVzLlxuKiBUaGVyZSBhcmUgYWxzbyBhIGZldyBtZXRob2RzIGhlcmUgdGhhdCBhbGlhcyB0aG9zZSBpbiBgTWF0dGVyLkNvbXBvc2l0ZWAgZm9yIGVhc2llciByZWFkYWJpbGl0eS5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFdvcmxkXG4qIEBleHRlbmRzIENvbXBvc2l0ZVxuKi9cblxudmFyIFdvcmxkID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gV29ybGQ7XG5cbnZhciBDb21wb3NpdGUgPSBfZGVyZXFfKCcuL0NvbXBvc2l0ZScpO1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50L0NvbnN0cmFpbnQnKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdvcmxkIGNvbXBvc2l0ZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7d29ybGR9IEEgbmV3IHdvcmxkXG4gICAgICovXG4gICAgV29ybGQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9zaXRlID0gQ29tcG9zaXRlLmNyZWF0ZSgpO1xuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGxhYmVsOiAnV29ybGQnLFxuICAgICAgICAgICAgZ3Jhdml0eToge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMSxcbiAgICAgICAgICAgICAgICBzY2FsZTogMC4wMDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3VuZHM6IHsgXG4gICAgICAgICAgICAgICAgbWluOiB7IHg6IC1JbmZpbml0eSwgeTogLUluZmluaXR5IH0sIFxuICAgICAgICAgICAgICAgIG1heDogeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHkgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKGNvbXBvc2l0ZSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBncmF2aXR5IHRvIGFwcGx5IG9uIHRoZSB3b3JsZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0eSB4IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnhcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0eSB5IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnlcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0eSBzY2FsZSBmYWN0b3IuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eS5zY2FsZVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDAuMDAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHdvcmxkIGJvdW5kcyBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib3VuZHNcbiAgICAgKiBAdHlwZSBib3VuZHNcbiAgICAgKiBAZGVmYXVsdCB7IG1pbjogeyB4OiAtSW5maW5pdHksIHk6IC1JbmZpbml0eSB9LCBtYXg6IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5IH0gfVxuICAgICAqL1xuXG4gICAgLy8gV29ybGQgaXMgYSBDb21wb3NpdGUgYm9keVxuICAgIC8vIHNlZSBzcmMvbW9kdWxlL091dHJvLmpzIGZvciB0aGVzZSBhbGlhc2VzOlxuICAgIFxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzIGZvciBDb21wb3NpdGUuYWRkXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge3dvcmxkfSB3b3JsZFxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCB3b3JsZCB3aXRoIHRoZSBvYmplY3RzIGFkZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhbGlhcyBmb3IgQ29tcG9zaXRlLnJlbW92ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCB3b3JsZCB3aXRoIHRoZSBvYmplY3RzIHJlbW92ZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzIGZvciBDb21wb3NpdGUuY2xlYXJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdGF0aWNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzIGZvciBDb21wb3NpdGUuYWRkQ29tcG9zaXRlXG4gICAgICogQG1ldGhvZCBhZGRDb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge3dvcmxkfSB3b3JsZFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIG9iamVjdHMgZnJvbSBjb21wb3NpdGUgYWRkZWRcbiAgICAgKi9cbiAgICBcbiAgICAgLyoqXG4gICAgICAqIEFuIGFsaWFzIGZvciBDb21wb3NpdGUuYWRkQm9keVxuICAgICAgKiBAbWV0aG9kIGFkZEJvZHlcbiAgICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcbiAgICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICAqIEByZXR1cm4ge3dvcmxkfSBUaGUgb3JpZ2luYWwgd29ybGQgd2l0aCB0aGUgYm9keSBhZGRlZFxuICAgICAgKi9cblxuICAgICAvKipcbiAgICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50XG4gICAgICAqIEBtZXRob2QgYWRkQ29uc3RyYWludFxuICAgICAgKiBAcGFyYW0ge3dvcmxkfSB3b3JsZFxuICAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAgICAgICogQHJldHVybiB7d29ybGR9IFRoZSBvcmlnaW5hbCB3b3JsZCB3aXRoIHRoZSBjb25zdHJhaW50IGFkZGVkXG4gICAgICAqL1xuXG59KSgpO1xuXG59LHtcIi4uL2NvbnN0cmFpbnQvQ29uc3RyYWludFwiOjEyLFwiLi4vY29yZS9Db21tb25cIjoxNCxcIi4vQ29tcG9zaXRlXCI6Mn1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLkNvbnRhY3RgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbGxpc2lvbiBjb250YWN0cy5cbipcbiogQGNsYXNzIENvbnRhY3RcbiovXG5cbnZhciBDb250YWN0ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdDtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb250YWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt2ZXJ0ZXh9IHZlcnRleFxuICAgICAqIEByZXR1cm4ge2NvbnRhY3R9IEEgbmV3IGNvbnRhY3RcbiAgICAgKi9cbiAgICBDb250YWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IENvbnRhY3QuaWQodmVydGV4KSxcbiAgICAgICAgICAgIHZlcnRleDogdmVydGV4LFxuICAgICAgICAgICAgbm9ybWFsSW1wdWxzZTogMCxcbiAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlOiAwXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBjb250YWN0IGlkLlxuICAgICAqIEBtZXRob2QgaWRcbiAgICAgKiBAcGFyYW0ge3ZlcnRleH0gdmVydGV4XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBVbmlxdWUgY29udGFjdElEXG4gICAgICovXG4gICAgQ29udGFjdC5pZCA9IGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgICByZXR1cm4gdmVydGV4LmJvZHkuaWQgKyAnXycgKyB2ZXJ0ZXguaW5kZXg7XG4gICAgfTtcblxufSkoKTtcblxufSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuRGV0ZWN0b3JgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyBnaXZlbiBhIHNldCBvZiBwYWlycy5cbipcbiogQGNsYXNzIERldGVjdG9yXG4qL1xuXG4vLyBUT0RPOiBzcGVjdWxhdGl2ZSBjb250YWN0c1xuXG52YXIgRGV0ZWN0b3IgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXRlY3RvcjtcblxudmFyIFNBVCA9IF9kZXJlcV8oJy4vU0FUJyk7XG52YXIgUGFpciA9IF9kZXJlcV8oJy4vUGFpcicpO1xudmFyIEJvdW5kcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgY29sbGlzaW9ucyBnaXZlbiBhIGxpc3Qgb2YgcGFpcnMuXG4gICAgICogQG1ldGhvZCBjb2xsaXNpb25zXG4gICAgICogQHBhcmFtIHtwYWlyW119IGJyb2FkcGhhc2VQYWlyc1xuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gY29sbGlzaW9uc1xuICAgICAqL1xuICAgIERldGVjdG9yLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihicm9hZHBoYXNlUGFpcnMsIGVuZ2luZSkge1xuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IFtdLFxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IGVuZ2luZS5wYWlycy50YWJsZTtcblxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm9hZHBoYXNlUGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGJyb2FkcGhhc2VQYWlyc1tpXVswXSwgXG4gICAgICAgICAgICAgICAgYm9keUIgPSBicm9hZHBoYXNlUGFpcnNbaV1bMV07XG5cbiAgICAgICAgICAgIGlmICgoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykgJiYgKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIURldGVjdG9yLmNhbkNvbGxpZGUoYm9keUEuY29sbGlzaW9uRmlsdGVyLCBib2R5Qi5jb2xsaXNpb25GaWx0ZXIpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG5cbiAgICAgICAgICAgIC8vIG1pZCBwaGFzZVxuICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhib2R5QS5ib3VuZHMsIGJvZHlCLmJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gYm9keUEucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgYm9keUEucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gYm9keUEucGFydHNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGJvZHlCLnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IGJvZHlCLnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydEIgPSBib2R5Qi5wYXJ0c1trXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJ0QSA9PT0gYm9keUEgJiYgcGFydEIgPT09IGJvZHlCKSB8fCBCb3VuZHMub3ZlcmxhcHMocGFydEEuYm91bmRzLCBwYXJ0Qi5ib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBhIHByZXZpb3VzIGNvbGxpc2lvbiB3ZSBjb3VsZCByZXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlySWQgPSBQYWlyLmlkKHBhcnRBLCBwYXJ0QiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXIgPSBwYWlyc1RhYmxlW3BhaXJJZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29sbGlzaW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIgJiYgcGFpci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29sbGlzaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXJyb3cgcGhhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gU0FULmNvbGxpZGVzKHBhcnRBLCBwYXJ0QiwgcHJldmlvdXNDb2xsaXNpb24pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLmNvbGxpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnMucHVzaChjb2xsaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xsaXNpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIHN1cHBsaWVkIGNvbGxpc2lvbiBmaWx0ZXJzIHdpbGwgYWxsb3cgYSBjb2xsaXNpb24gdG8gb2NjdXIuXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZCBjYW5Db2xsaWRlXG4gICAgICogQHBhcmFtIHt9IGZpbHRlckFcbiAgICAgKiBAcGFyYW0ge30gZmlsdGVyQlxuICAgICAqIEByZXR1cm4ge2Jvb2x9IGB0cnVlYCBpZiBjb2xsaXNpb24gY2FuIG9jY3VyXG4gICAgICovXG4gICAgRGV0ZWN0b3IuY2FuQ29sbGlkZSA9IGZ1bmN0aW9uKGZpbHRlckEsIGZpbHRlckIpIHtcbiAgICAgICAgaWYgKGZpbHRlckEuZ3JvdXAgPT09IGZpbHRlckIuZ3JvdXAgJiYgZmlsdGVyQS5ncm91cCAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJBLmdyb3VwID4gMDtcblxuICAgICAgICByZXR1cm4gKGZpbHRlckEubWFzayAmIGZpbHRlckIuY2F0ZWdvcnkpICE9PSAwICYmIChmaWx0ZXJCLm1hc2sgJiBmaWx0ZXJBLmNhdGVnb3J5KSAhPT0gMDtcbiAgICB9O1xuXG59KSgpO1xuXG59LHtcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI2LFwiLi9QYWlyXCI6NyxcIi4vU0FUXCI6MTF9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5HcmlkYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gYnJvYWRwaGFzZSBncmlkIHN0cnVjdHVyZXMuXG4qXG4qIEBjbGFzcyBHcmlkXG4qL1xuXG52YXIgR3JpZCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG5cbnZhciBQYWlyID0gX2RlcmVxXygnLi9QYWlyJyk7XG52YXIgRGV0ZWN0b3IgPSBfZGVyZXFfKCcuL0RldGVjdG9yJyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBncmlkLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtncmlkfSBBIG5ldyBncmlkXG4gICAgICovXG4gICAgR3JpZC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IEdyaWQsXG4gICAgICAgICAgICBkZXRlY3RvcjogRGV0ZWN0b3IuY29sbGlzaW9ucyxcbiAgICAgICAgICAgIGJ1Y2tldHM6IHt9LFxuICAgICAgICAgICAgcGFpcnM6IHt9LFxuICAgICAgICAgICAgcGFpcnNMaXN0OiBbXSxcbiAgICAgICAgICAgIGJ1Y2tldFdpZHRoOiA0OCxcbiAgICAgICAgICAgIGJ1Y2tldEhlaWdodDogNDhcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBhIHNpbmdsZSBncmlkIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBidWNrZXRXaWR0aFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDQ4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGdyaWQgYnVja2V0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJ1Y2tldEhlaWdodFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDQ4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBncmlkLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlXG4gICAgICovXG4gICAgR3JpZC51cGRhdGUgPSBmdW5jdGlvbihncmlkLCBib2RpZXMsIGVuZ2luZSwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgdmFyIGksIGNvbCwgcm93LFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBidWNrZXRzID0gZ3JpZC5idWNrZXRzLFxuICAgICAgICAgICAgYnVja2V0LFxuICAgICAgICAgICAgYnVja2V0SWQsXG4gICAgICAgICAgICBncmlkQ2hhbmdlZCA9IGZhbHNlO1xuXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChib2R5LmlzU2xlZXBpbmcgJiYgIWZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBkb24ndCB1cGRhdGUgb3V0IG9mIHdvcmxkIGJvZGllc1xuICAgICAgICAgICAgaWYgKGJvZHkuYm91bmRzLm1heC54IDwgd29ybGQuYm91bmRzLm1pbi54IHx8IGJvZHkuYm91bmRzLm1pbi54ID4gd29ybGQuYm91bmRzLm1heC54XG4gICAgICAgICAgICAgICAgfHwgYm9keS5ib3VuZHMubWF4LnkgPCB3b3JsZC5ib3VuZHMubWluLnkgfHwgYm9keS5ib3VuZHMubWluLnkgPiB3b3JsZC5ib3VuZHMubWF4LnkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBuZXdSZWdpb24gPSBHcmlkLl9nZXRSZWdpb24oZ3JpZCwgYm9keSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBib2R5IGhhcyBjaGFuZ2VkIGdyaWQgcmVnaW9uXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IG5ld1JlZ2lvbi5pZCAhPT0gYm9keS5yZWdpb24uaWQgfHwgZm9yY2VVcGRhdGUpIHtcblxuXG4gICAgICAgICAgICAgICAgaWYgKCFib2R5LnJlZ2lvbiB8fCBmb3JjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgYm9keS5yZWdpb24gPSBuZXdSZWdpb247XG5cbiAgICAgICAgICAgICAgICB2YXIgdW5pb24gPSBHcmlkLl9yZWdpb25VbmlvbihuZXdSZWdpb24sIGJvZHkucmVnaW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBncmlkIGJ1Y2tldHMgYWZmZWN0ZWQgYnkgcmVnaW9uIGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgdW5pb24gb2YgYm90aCByZWdpb25zXG4gICAgICAgICAgICAgICAgZm9yIChjb2wgPSB1bmlvbi5zdGFydENvbDsgY29sIDw9IHVuaW9uLmVuZENvbDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSB1bmlvbi5zdGFydFJvdzsgcm93IDw9IHVuaW9uLmVuZFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldElkID0gR3JpZC5fZ2V0QnVja2V0SWQoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gYnVja2V0c1tidWNrZXRJZF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0luc2lkZU5ld1JlZ2lvbiA9IChjb2wgPj0gbmV3UmVnaW9uLnN0YXJ0Q29sICYmIGNvbCA8PSBuZXdSZWdpb24uZW5kQ29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByb3cgPj0gbmV3UmVnaW9uLnN0YXJ0Um93ICYmIHJvdyA8PSBuZXdSZWdpb24uZW5kUm93KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5zaWRlT2xkUmVnaW9uID0gKGNvbCA+PSBib2R5LnJlZ2lvbi5zdGFydENvbCAmJiBjb2wgPD0gYm9keS5yZWdpb24uZW5kQ29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByb3cgPj0gYm9keS5yZWdpb24uc3RhcnRSb3cgJiYgcm93IDw9IGJvZHkucmVnaW9uLmVuZFJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIG9sZCByZWdpb24gYnVja2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0luc2lkZU5ld1JlZ2lvbiAmJiBpc0luc2lkZU9sZFJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luc2lkZU9sZFJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVja2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JpZC5fYnVja2V0UmVtb3ZlQm9keShncmlkLCBidWNrZXQsIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRvIG5ldyByZWdpb24gYnVja2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkucmVnaW9uID09PSBuZXdSZWdpb24gfHwgKGlzSW5zaWRlTmV3UmVnaW9uICYmICFpc0luc2lkZU9sZFJlZ2lvbikgfHwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1Y2tldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gR3JpZC5fY3JlYXRlQnVja2V0KGJ1Y2tldHMsIGJ1Y2tldElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLl9idWNrZXRBZGRCb2R5KGdyaWQsIGJ1Y2tldCwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIG5ldyByZWdpb25cbiAgICAgICAgICAgICAgICBib2R5LnJlZ2lvbiA9IG5ld1JlZ2lvbjtcblxuICAgICAgICAgICAgICAgIC8vIGZsYWcgY2hhbmdlcyBzbyB3ZSBjYW4gdXBkYXRlIHBhaXJzXG4gICAgICAgICAgICAgICAgZ3JpZENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhaXJzIGxpc3Qgb25seSBpZiBwYWlycyBjaGFuZ2VkIChpLmUuIGEgYm9keSBjaGFuZ2VkIHJlZ2lvbilcbiAgICAgICAgaWYgKGdyaWRDaGFuZ2VkKVxuICAgICAgICAgICAgZ3JpZC5wYWlyc0xpc3QgPSBHcmlkLl9jcmVhdGVBY3RpdmVQYWlyc0xpc3QoZ3JpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JpZC5cbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICovXG4gICAgR3JpZC5jbGVhciA9IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC5idWNrZXRzID0ge307XG4gICAgICAgIGdyaWQucGFpcnMgPSB7fTtcbiAgICAgICAgZ3JpZC5wYWlyc0xpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHVuaW9uIG9mIHR3byByZWdpb25zLlxuICAgICAqIEBtZXRob2QgX3JlZ2lvblVuaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gcmVnaW9uQVxuICAgICAqIEBwYXJhbSB7fSByZWdpb25CXG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICBHcmlkLl9yZWdpb25VbmlvbiA9IGZ1bmN0aW9uKHJlZ2lvbkEsIHJlZ2lvbkIpIHtcbiAgICAgICAgdmFyIHN0YXJ0Q29sID0gTWF0aC5taW4ocmVnaW9uQS5zdGFydENvbCwgcmVnaW9uQi5zdGFydENvbCksXG4gICAgICAgICAgICBlbmRDb2wgPSBNYXRoLm1heChyZWdpb25BLmVuZENvbCwgcmVnaW9uQi5lbmRDb2wpLFxuICAgICAgICAgICAgc3RhcnRSb3cgPSBNYXRoLm1pbihyZWdpb25BLnN0YXJ0Um93LCByZWdpb25CLnN0YXJ0Um93KSxcbiAgICAgICAgICAgIGVuZFJvdyA9IE1hdGgubWF4KHJlZ2lvbkEuZW5kUm93LCByZWdpb25CLmVuZFJvdyk7XG5cbiAgICAgICAgcmV0dXJuIEdyaWQuX2NyZWF0ZVJlZ2lvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmVnaW9uIGEgZ2l2ZW4gYm9keSBmYWxscyBpbiBmb3IgYSBnaXZlbiBncmlkLlxuICAgICAqIEBtZXRob2QgX2dldFJlZ2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGdyaWRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqIEByZXR1cm4ge30gcmVnaW9uXG4gICAgICovXG4gICAgR3JpZC5fZ2V0UmVnaW9uID0gZnVuY3Rpb24oZ3JpZCwgYm9keSkge1xuICAgICAgICB2YXIgYm91bmRzID0gYm9keS5ib3VuZHMsXG4gICAgICAgICAgICBzdGFydENvbCA9IE1hdGguZmxvb3IoYm91bmRzLm1pbi54IC8gZ3JpZC5idWNrZXRXaWR0aCksXG4gICAgICAgICAgICBlbmRDb2wgPSBNYXRoLmZsb29yKGJvdW5kcy5tYXgueCAvIGdyaWQuYnVja2V0V2lkdGgpLFxuICAgICAgICAgICAgc3RhcnRSb3cgPSBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSAvIGdyaWQuYnVja2V0SGVpZ2h0KSxcbiAgICAgICAgICAgIGVuZFJvdyA9IE1hdGguZmxvb3IoYm91bmRzLm1heC55IC8gZ3JpZC5idWNrZXRIZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBHcmlkLl9jcmVhdGVSZWdpb24oc3RhcnRDb2wsIGVuZENvbCwgc3RhcnRSb3csIGVuZFJvdyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWdpb24uXG4gICAgICogQG1ldGhvZCBfY3JlYXRlUmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gc3RhcnRDb2xcbiAgICAgKiBAcGFyYW0ge30gZW5kQ29sXG4gICAgICogQHBhcmFtIHt9IHN0YXJ0Um93XG4gICAgICogQHBhcmFtIHt9IGVuZFJvd1xuICAgICAqIEByZXR1cm4ge30gcmVnaW9uXG4gICAgICovXG4gICAgR3JpZC5fY3JlYXRlUmVnaW9uID0gZnVuY3Rpb24oc3RhcnRDb2wsIGVuZENvbCwgc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIGlkOiBzdGFydENvbCArICcsJyArIGVuZENvbCArICcsJyArIHN0YXJ0Um93ICsgJywnICsgZW5kUm93LFxuICAgICAgICAgICAgc3RhcnRDb2w6IHN0YXJ0Q29sLCBcbiAgICAgICAgICAgIGVuZENvbDogZW5kQ29sLCBcbiAgICAgICAgICAgIHN0YXJ0Um93OiBzdGFydFJvdywgXG4gICAgICAgICAgICBlbmRSb3c6IGVuZFJvdyBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYnVja2V0IGlkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKiBAbWV0aG9kIF9nZXRCdWNrZXRJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGNvbHVtblxuICAgICAqIEBwYXJhbSB7fSByb3dcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGJ1Y2tldCBpZFxuICAgICAqL1xuICAgIEdyaWQuX2dldEJ1Y2tldElkID0gZnVuY3Rpb24oY29sdW1uLCByb3cpIHtcbiAgICAgICAgcmV0dXJuICdDJyArIGNvbHVtbiArICdSJyArIHJvdztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVCdWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRzXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldElkXG4gICAgICogQHJldHVybiB7fSBidWNrZXRcbiAgICAgKi9cbiAgICBHcmlkLl9jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbihidWNrZXRzLCBidWNrZXRJZCkge1xuICAgICAgICB2YXIgYnVja2V0ID0gYnVja2V0c1tidWNrZXRJZF0gPSBbXTtcbiAgICAgICAgcmV0dXJuIGJ1Y2tldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGJvZHkgdG8gYSBidWNrZXQuXG4gICAgICogQG1ldGhvZCBfYnVja2V0QWRkQm9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGdyaWRcbiAgICAgKiBAcGFyYW0ge30gYnVja2V0XG4gICAgICogQHBhcmFtIHt9IGJvZHlcbiAgICAgKi9cbiAgICBHcmlkLl9idWNrZXRBZGRCb2R5ID0gZnVuY3Rpb24oZ3JpZCwgYnVja2V0LCBib2R5KSB7XG4gICAgICAgIC8vIGFkZCBuZXcgcGFpcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGJ1Y2tldFtpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaWQgPT09IGJvZHlCLmlkIHx8IChib2R5LmlzU3RhdGljICYmIGJvZHlCLmlzU3RhdGljKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGJ1Y2tldHMgdGhlIHBhaXIgZXhpc3RzIGluXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIEdyaWQudXBkYXRlIHRvIHdvcmtcbiAgICAgICAgICAgIHZhciBwYWlySWQgPSBQYWlyLmlkKGJvZHksIGJvZHlCKSxcbiAgICAgICAgICAgICAgICBwYWlyID0gZ3JpZC5wYWlyc1twYWlySWRdO1xuXG4gICAgICAgICAgICBpZiAocGFpcikge1xuICAgICAgICAgICAgICAgIHBhaXJbMl0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5wYWlyc1twYWlySWRdID0gW2JvZHksIGJvZHlCLCAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBib2RpZXMgKGFmdGVyIHBhaXJzLCBvdGhlcndpc2UgcGFpcnMgd2l0aCBzZWxmKVxuICAgICAgICBidWNrZXQucHVzaChib2R5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9idWNrZXRSZW1vdmVCb2R5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqL1xuICAgIEdyaWQuX2J1Y2tldFJlbW92ZUJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gYnVja2V0XG4gICAgICAgIGJ1Y2tldC5zcGxpY2UoQ29tbW9uLmluZGV4T2YoYnVja2V0LCBib2R5KSwgMSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhaXIgY291bnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgYnVja2V0cyB0aGUgcGFpciBleGlzdHMgaW5cbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCB0byB3b3JrXG4gICAgICAgICAgICB2YXIgYm9keUIgPSBidWNrZXRbaV0sXG4gICAgICAgICAgICAgICAgcGFpcklkID0gUGFpci5pZChib2R5LCBib2R5QiksXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcklkXTtcblxuICAgICAgICAgICAgaWYgKHBhaXIpXG4gICAgICAgICAgICAgICAgcGFpclsyXSAtPSAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGxpc3Qgb2YgdGhlIGFjdGl2ZSBwYWlycyBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVBY3RpdmVQYWlyc0xpc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBncmlkXG4gICAgICogQHJldHVybiBbXSBwYWlyc1xuICAgICAqL1xuICAgIEdyaWQuX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCA9IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIHBhaXJLZXlzLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIHBhaXJzID0gW107XG5cbiAgICAgICAgLy8gZ3JpZC5wYWlycyBpcyB1c2VkIGFzIGEgaGFzaG1hcFxuICAgICAgICBwYWlyS2V5cyA9IENvbW1vbi5rZXlzKGdyaWQucGFpcnMpO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBncmlkLnBhaXJzXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpcktleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBncmlkLnBhaXJzW3BhaXJLZXlzW2tdXTtcblxuICAgICAgICAgICAgLy8gaWYgcGFpciBleGlzdHMgaW4gYXQgbGVhc3Qgb25lIGJ1Y2tldFxuICAgICAgICAgICAgLy8gaXQgaXMgYSBwYWlyIHRoYXQgbmVlZHMgZnVydGhlciBjb2xsaXNpb24gdGVzdGluZyBzbyBwdXNoIGl0XG4gICAgICAgICAgICBpZiAocGFpclsyXSA+IDApIHtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZ3JpZC5wYWlyc1twYWlyS2V5c1trXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfTtcbiAgICBcbn0pKCk7XG5cbn0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4vRGV0ZWN0b3JcIjo1LFwiLi9QYWlyXCI6N31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLlBhaXJgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbGxpc2lvbiBwYWlycy5cbipcbiogQGNsYXNzIFBhaXJcbiovXG5cbnZhciBQYWlyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUGFpcjtcblxudmFyIENvbnRhY3QgPSBfZGVyZXFfKCcuL0NvbnRhY3QnKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWlyLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb259IGNvbGxpc2lvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKiBAcmV0dXJuIHtwYWlyfSBBIG5ldyBwYWlyXG4gICAgICovXG4gICAgUGFpci5jcmVhdGUgPSBmdW5jdGlvbihjb2xsaXNpb24sIHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgYm9keUEgPSBjb2xsaXNpb24uYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QixcbiAgICAgICAgICAgIHBhcmVudEEgPSBjb2xsaXNpb24ucGFyZW50QSxcbiAgICAgICAgICAgIHBhcmVudEIgPSBjb2xsaXNpb24ucGFyZW50QjtcblxuICAgICAgICB2YXIgcGFpciA9IHtcbiAgICAgICAgICAgIGlkOiBQYWlyLmlkKGJvZHlBLCBib2R5QiksXG4gICAgICAgICAgICBib2R5QTogYm9keUEsXG4gICAgICAgICAgICBib2R5QjogYm9keUIsXG4gICAgICAgICAgICBjb250YWN0czoge30sXG4gICAgICAgICAgICBhY3RpdmVDb250YWN0czogW10sXG4gICAgICAgICAgICBzZXBhcmF0aW9uOiAwLFxuICAgICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBpc1NlbnNvcjogYm9keUEuaXNTZW5zb3IgfHwgYm9keUIuaXNTZW5zb3IsXG4gICAgICAgICAgICB0aW1lQ3JlYXRlZDogdGltZXN0YW1wLFxuICAgICAgICAgICAgdGltZVVwZGF0ZWQ6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGludmVyc2VNYXNzOiBwYXJlbnRBLmludmVyc2VNYXNzICsgcGFyZW50Qi5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgIGZyaWN0aW9uOiBNYXRoLm1pbihwYXJlbnRBLmZyaWN0aW9uLCBwYXJlbnRCLmZyaWN0aW9uKSxcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiBNYXRoLm1heChwYXJlbnRBLmZyaWN0aW9uU3RhdGljLCBwYXJlbnRCLmZyaWN0aW9uU3RhdGljKSxcbiAgICAgICAgICAgIHJlc3RpdHV0aW9uOiBNYXRoLm1heChwYXJlbnRBLnJlc3RpdHV0aW9uLCBwYXJlbnRCLnJlc3RpdHV0aW9uKSxcbiAgICAgICAgICAgIHNsb3A6IE1hdGgubWF4KHBhcmVudEEuc2xvcCwgcGFyZW50Qi5zbG9wKVxuICAgICAgICB9O1xuXG4gICAgICAgIFBhaXIudXBkYXRlKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcblxuICAgICAgICByZXR1cm4gcGFpcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHBhaXIgZ2l2ZW4gYSBjb2xsaXNpb24uXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge3BhaXJ9IHBhaXJcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbn0gY29sbGlzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqL1xuICAgIFBhaXIudXBkYXRlID0gZnVuY3Rpb24ocGFpciwgY29sbGlzaW9uLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIGNvbnRhY3RzID0gcGFpci5jb250YWN0cyxcbiAgICAgICAgICAgIHN1cHBvcnRzID0gY29sbGlzaW9uLnN1cHBvcnRzLFxuICAgICAgICAgICAgYWN0aXZlQ29udGFjdHMgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzLFxuICAgICAgICAgICAgcGFyZW50QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxuICAgICAgICAgICAgcGFyZW50QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xuICAgICAgICBcbiAgICAgICAgcGFpci5jb2xsaXNpb24gPSBjb2xsaXNpb247XG4gICAgICAgIHBhaXIuaW52ZXJzZU1hc3MgPSBwYXJlbnRBLmludmVyc2VNYXNzICsgcGFyZW50Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgcGFpci5mcmljdGlvbiA9IE1hdGgubWluKHBhcmVudEEuZnJpY3Rpb24sIHBhcmVudEIuZnJpY3Rpb24pO1xuICAgICAgICBwYWlyLmZyaWN0aW9uU3RhdGljID0gTWF0aC5tYXgocGFyZW50QS5mcmljdGlvblN0YXRpYywgcGFyZW50Qi5mcmljdGlvblN0YXRpYyk7XG4gICAgICAgIHBhaXIucmVzdGl0dXRpb24gPSBNYXRoLm1heChwYXJlbnRBLnJlc3RpdHV0aW9uLCBwYXJlbnRCLnJlc3RpdHV0aW9uKTtcbiAgICAgICAgcGFpci5zbG9wID0gTWF0aC5tYXgocGFyZW50QS5zbG9wLCBwYXJlbnRCLnNsb3ApO1xuICAgICAgICBhY3RpdmVDb250YWN0cy5sZW5ndGggPSAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbGxpc2lvbi5jb2xsaWRlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0ID0gc3VwcG9ydHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RJZCA9IENvbnRhY3QuaWQoc3VwcG9ydCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QgPSBjb250YWN0c1tjb250YWN0SWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ29udGFjdHMucHVzaChjb250YWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVDb250YWN0cy5wdXNoKGNvbnRhY3RzW2NvbnRhY3RJZF0gPSBDb250YWN0LmNyZWF0ZShzdXBwb3J0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYWlyLnNlcGFyYXRpb24gPSBjb2xsaXNpb24uZGVwdGg7XG4gICAgICAgICAgICBQYWlyLnNldEFjdGl2ZShwYWlyLCB0cnVlLCB0aW1lc3RhbXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhaXIuaXNBY3RpdmUgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgUGFpci5zZXRBY3RpdmUocGFpciwgZmFsc2UsIHRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCBhIHBhaXIgYXMgYWN0aXZlIG9yIGluYWN0aXZlLlxuICAgICAqIEBtZXRob2Qgc2V0QWN0aXZlXG4gICAgICogQHBhcmFtIHtwYWlyfSBwYWlyXG4gICAgICogQHBhcmFtIHtib29sfSBpc0FjdGl2ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBQYWlyLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHBhaXIsIGlzQWN0aXZlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICBwYWlyLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhaXIudGltZVVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWlyLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZCBmb3IgdGhlIGdpdmVuIHBhaXIuXG4gICAgICogQG1ldGhvZCBpZFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlCXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBVbmlxdWUgcGFpcklkXG4gICAgICovXG4gICAgUGFpci5pZCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qikge1xuICAgICAgICBpZiAoYm9keUEuaWQgPCBib2R5Qi5pZCkge1xuICAgICAgICAgICAgcmV0dXJuICdBJyArIGJvZHlBLmlkICsgJ0InICsgYm9keUIuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0EnICsgYm9keUIuaWQgKyAnQicgKyBib2R5QS5pZDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi9Db250YWN0XCI6NH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLlBhaXJzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gcGFpciBzZXRzLlxuKlxuKiBAY2xhc3MgUGFpcnNcbiovXG5cbnZhciBQYWlycyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhaXJzO1xuXG52YXIgUGFpciA9IF9kZXJlcV8oJy4vUGFpcicpO1xudmFyIENvbW1vbiA9IF9kZXJlcV8oJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcbiAgICBcbiAgICBQYWlycy5fcGFpck1heElkbGVMaWZlID0gMTAwMDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGFpcnMgc3RydWN0dXJlLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge3BhaXJzfSBBIG5ldyBwYWlycyBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBQYWlycy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXG4gICAgICAgICAgICB0YWJsZToge30sXG4gICAgICAgICAgICBsaXN0OiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0OiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZTogW10sXG4gICAgICAgICAgICBjb2xsaXNpb25FbmQ6IFtdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHBhaXJzIGdpdmVuIGEgbGlzdCBvZiBjb2xsaXNpb25zLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhaXJzXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb25bXX0gY29sbGlzaW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBQYWlycy51cGRhdGUgPSBmdW5jdGlvbihwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBwYWlyc0xpc3QgPSBwYWlycy5saXN0LFxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IHBhaXJzLnRhYmxlLFxuICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQgPSBwYWlycy5jb2xsaXNpb25TdGFydCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkVuZCA9IHBhaXJzLmNvbGxpc2lvbkVuZCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZSA9IHBhaXJzLmNvbGxpc2lvbkFjdGl2ZSxcbiAgICAgICAgICAgIGFjdGl2ZVBhaXJJZHMgPSBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIHBhaXJJZCxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGNsZWFyIGNvbGxpc2lvbiBzdGF0ZSBhcnJheXMsIGJ1dCBtYWludGFpbiBvbGQgcmVmZXJlbmNlXG4gICAgICAgIGNvbGxpc2lvblN0YXJ0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xuICAgICAgICBjb2xsaXNpb25BY3RpdmUubGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5jb2xsaWRlZCkge1xuICAgICAgICAgICAgICAgIHBhaXJJZCA9IFBhaXIuaWQoY29sbGlzaW9uLmJvZHlBLCBjb2xsaXNpb24uYm9keUIpO1xuICAgICAgICAgICAgICAgIGFjdGl2ZVBhaXJJZHMucHVzaChwYWlySWQpO1xuXG4gICAgICAgICAgICAgICAgcGFpciA9IHBhaXJzVGFibGVbcGFpcklkXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocGFpcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGFscmVhZHkgZXhpc3RzIChidXQgbWF5IG9yIG1heSBub3QgYmUgYWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFpciBleGlzdHMgYW5kIGlzIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGV4aXN0cyBidXQgd2FzIGluYWN0aXZlLCBzbyBhIGNvbGxpc2lvbiBoYXMganVzdCBzdGFydGVkIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25TdGFydC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIFBhaXIudXBkYXRlKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGRpZCBub3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBwYWlyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSBQYWlyLmNyZWF0ZShjb2xsaXNpb24sIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzVGFibGVbcGFpcklkXSA9IHBhaXI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgbmV3IHBhaXJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQucHVzaChwYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnNMaXN0LnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVhY3RpdmF0ZSBwcmV2aW91c2x5IGFjdGl2ZSBwYWlycyB0aGF0IGFyZSBub3cgaW5hY3RpdmVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzTGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlICYmIENvbW1vbi5pbmRleE9mKGFjdGl2ZVBhaXJJZHMsIHBhaXIuaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIFBhaXIuc2V0QWN0aXZlKHBhaXIsIGZhbHNlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkVuZC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbmQgcmVtb3ZlcyBwYWlycyB0aGF0IGhhdmUgYmVlbiBpbmFjdGl2ZSBmb3IgYSBzZXQgYW1vdW50IG9mIHRpbWUuXG4gICAgICogQG1ldGhvZCByZW1vdmVPbGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFpcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICovXG4gICAgUGFpcnMucmVtb3ZlT2xkID0gZnVuY3Rpb24ocGFpcnMsIHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgcGFpcnNMaXN0ID0gcGFpcnMubGlzdCxcbiAgICAgICAgICAgIHBhaXJzVGFibGUgPSBwYWlycy50YWJsZSxcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZSA9IFtdLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIHBhaXJJbmRleCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBuZXZlciByZW1vdmUgc2xlZXBpbmcgcGFpcnNcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24uYm9keUEuaXNTbGVlcGluZyB8fCBjb2xsaXNpb24uYm9keUIuaXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIHBhaXIudGltZVVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHBhaXIgaXMgaW5hY3RpdmUgZm9yIHRvbyBsb25nLCBtYXJrIGl0IHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgLSBwYWlyLnRpbWVVcGRhdGVkID4gUGFpcnMuX3BhaXJNYXhJZGxlTGlmZSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIG1hcmtlZCBwYWlyc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXhlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlySW5kZXggPSBpbmRleGVzVG9SZW1vdmVbaV0gLSBpO1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzTGlzdFtwYWlySW5kZXhdO1xuICAgICAgICAgICAgZGVsZXRlIHBhaXJzVGFibGVbcGFpci5pZF07XG4gICAgICAgICAgICBwYWlyc0xpc3Quc3BsaWNlKHBhaXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBnaXZlbiBwYWlycyBzdHJ1Y3R1cmUuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7cGFpcnN9IHBhaXJzXG4gICAgICogQHJldHVybiB7cGFpcnN9IHBhaXJzXG4gICAgICovXG4gICAgUGFpcnMuY2xlYXIgPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICBwYWlycy50YWJsZSA9IHt9O1xuICAgICAgICBwYWlycy5saXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHBhaXJzLmNvbGxpc2lvblN0YXJ0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xuICAgICAgICBwYWlycy5jb2xsaXNpb25FbmQubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4vUGFpclwiOjd9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5RdWVyeWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgY29sbGlzaW9uIHF1ZXJpZXMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBRdWVyeVxuKi9cblxudmFyIFF1ZXJ5ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5cbnZhciBWZWN0b3IgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcbnZhciBTQVQgPSBfZGVyZXFfKCcuL1NBVCcpO1xudmFyIEJvdW5kcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xudmFyIEJvZGllcyA9IF9kZXJlcV8oJy4uL2ZhY3RvcnkvQm9kaWVzJyk7XG52YXIgVmVydGljZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb2xsaXNpb25zIGJldHdlZW4gYGJvZHlgIGFuZCBgYm9kaWVzYC5cbiAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEByZXR1cm4ge29iamVjdFtdfSBDb2xsaXNpb25zXG4gICAgICovXG4gICAgUXVlcnkuY29sbGlkZXMgPSBmdW5jdGlvbihib2R5LCBib2RpZXMpIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKGJvZHlBLmJvdW5kcywgYm9keS5ib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHlBLnBhcnRzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyBqIDwgYm9keUEucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5QS5wYXJ0c1tqXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKHBhcnQuYm91bmRzLCBib2R5LmJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBTQVQuY29sbGlkZXMocGFydCwgYm9keSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24uY29sbGlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zLnB1c2goY29sbGlzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xsaXNpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBhIHJheSBzZWdtZW50IGFnYWluc3QgYSBzZXQgb2YgYm9kaWVzIGFuZCByZXR1cm5zIGFsbCBjb2xsaXNpb25zLCByYXkgd2lkdGggaXMgb3B0aW9uYWwuIEludGVyc2VjdGlvbiBwb2ludHMgYXJlIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAbWV0aG9kIHJheVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gc3RhcnRQb2ludFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBlbmRQb2ludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF5V2lkdGhdXG4gICAgICogQHJldHVybiB7b2JqZWN0W119IENvbGxpc2lvbnNcbiAgICAgKi9cbiAgICBRdWVyeS5yYXkgPSBmdW5jdGlvbihib2RpZXMsIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCByYXlXaWR0aCkge1xuICAgICAgICByYXlXaWR0aCA9IHJheVdpZHRoIHx8IDFlLTEwMDtcblxuICAgICAgICB2YXIgcmF5QW5nbGUgPSBWZWN0b3IuYW5nbGUoc3RhcnRQb2ludCwgZW5kUG9pbnQpLFxuICAgICAgICAgICAgcmF5TGVuZ3RoID0gVmVjdG9yLm1hZ25pdHVkZShWZWN0b3Iuc3ViKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSksXG4gICAgICAgICAgICByYXlYID0gKGVuZFBvaW50LnggKyBzdGFydFBvaW50LngpICogMC41LFxuICAgICAgICAgICAgcmF5WSA9IChlbmRQb2ludC55ICsgc3RhcnRQb2ludC55KSAqIDAuNSxcbiAgICAgICAgICAgIHJheSA9IEJvZGllcy5yZWN0YW5nbGUocmF5WCwgcmF5WSwgcmF5TGVuZ3RoLCByYXlXaWR0aCwgeyBhbmdsZTogcmF5QW5nbGUgfSksXG4gICAgICAgICAgICBjb2xsaXNpb25zID0gUXVlcnkuY29sbGlkZXMocmF5LCBib2RpZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGlzaW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XG4gICAgICAgICAgICBjb2xsaXNpb24uYm9keSA9IGNvbGxpc2lvbi5ib2R5QiA9IGNvbGxpc2lvbi5ib2R5QTsgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xsaXNpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBib2RpZXMgd2hvc2UgYm91bmRzIGFyZSBpbnNpZGUgKG9yIG91dHNpZGUgaWYgc2V0KSB0aGUgZ2l2ZW4gc2V0IG9mIGJvdW5kcywgZnJvbSB0aGUgZ2l2ZW4gc2V0IG9mIGJvZGllcy5cbiAgICAgKiBAbWV0aG9kIHJlZ2lvblxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHtib29sfSBbb3V0c2lkZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtib2R5W119IFRoZSBib2RpZXMgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG4gICAgICovXG4gICAgUXVlcnkucmVnaW9uID0gZnVuY3Rpb24oYm9kaWVzLCBib3VuZHMsIG91dHNpZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBvdmVybGFwcyA9IEJvdW5kcy5vdmVybGFwcyhib2R5LmJvdW5kcywgYm91bmRzKTtcbiAgICAgICAgICAgIGlmICgob3ZlcmxhcHMgJiYgIW91dHNpZGUpIHx8ICghb3ZlcmxhcHMgJiYgb3V0c2lkZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBib2RpZXMgd2hvc2UgdmVydGljZXMgY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQsIGZyb20gdGhlIGdpdmVuIHNldCBvZiBib2RpZXMuXG4gICAgICogQG1ldGhvZCBwb2ludFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtib2R5W119IFRoZSBib2RpZXMgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG4gICAgICovXG4gICAgUXVlcnkucG9pbnQgPSBmdW5jdGlvbihib2RpZXMsIHBvaW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMoYm9keS5ib3VuZHMsIHBvaW50KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5LnBhcnRzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5jb250YWlucyhwYXJ0LmJvdW5kcywgcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBWZXJ0aWNlcy5jb250YWlucyhwYXJ0LnZlcnRpY2VzLCBwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi4vZmFjdG9yeS9Cb2RpZXNcIjoyMyxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI2LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6MjgsXCIuLi9nZW9tZXRyeS9WZXJ0aWNlc1wiOjI5LFwiLi9TQVRcIjoxMX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5SZXNvbHZlcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHJlc29sdmluZyBjb2xsaXNpb24gcGFpcnMuXG4qXG4qIEBjbGFzcyBSZXNvbHZlclxuKi9cblxudmFyIFJlc29sdmVyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb2x2ZXI7XG5cbnZhciBWZXJ0aWNlcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XG52YXIgVmVjdG9yID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcbnZhciBCb3VuZHMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2ggPSA0O1xuICAgIFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCA9IDY7XG4gICAgUmVzb2x2ZXIuX3Bvc2l0aW9uRGFtcGVuID0gMC45O1xuICAgIFJlc29sdmVyLl9wb3NpdGlvbldhcm1pbmcgPSAwLjg7XG4gICAgUmVzb2x2ZXIuX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllciA9IDU7XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciBwb3NpdGlvbiBzb2x2aW5nLlxuICAgICAqIEBtZXRob2QgcHJlU29sdmVQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqL1xuICAgIFJlc29sdmVyLnByZVNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBhY3RpdmVDb3VudDtcblxuICAgICAgICAvLyBmaW5kIHRvdGFsIGNvbnRhY3RzIG9uIGVhY2ggYm9keVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhY3RpdmVDb3VudCA9IHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoO1xuICAgICAgICAgICAgcGFpci5jb2xsaXNpb24ucGFyZW50QS50b3RhbENvbnRhY3RzICs9IGFjdGl2ZUNvdW50O1xuICAgICAgICAgICAgcGFpci5jb2xsaXNpb24ucGFyZW50Qi50b3RhbENvbnRhY3RzICs9IGFjdGl2ZUNvdW50O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBzb2x1dGlvbiBmb3IgcGFpciBwb3NpdGlvbnMuXG4gICAgICogQG1ldGhvZCBzb2x2ZVBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxuICAgICAqL1xuICAgIFJlc29sdmVyLnNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycywgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBib2R5QnRvQSxcbiAgICAgICAgICAgIGNvbnRhY3RTaGFyZSxcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSxcbiAgICAgICAgICAgIGNvbnRhY3RDb3VudCA9IHt9LFxuICAgICAgICAgICAgdGVtcEEgPSBWZWN0b3IuX3RlbXBbMF0sXG4gICAgICAgICAgICB0ZW1wQiA9IFZlY3Rvci5fdGVtcFsxXSxcbiAgICAgICAgICAgIHRlbXBDID0gVmVjdG9yLl90ZW1wWzJdLFxuICAgICAgICAgICAgdGVtcEQgPSBWZWN0b3IuX3RlbXBbM107XG5cbiAgICAgICAgLy8gZmluZCBpbXB1bHNlcyByZXF1aXJlZCB0byByZXNvbHZlIHBlbmV0cmF0aW9uXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XG5cbiAgICAgICAgICAgIC8vIGdldCBjdXJyZW50IHNlcGFyYXRpb24gYmV0d2VlbiBib2R5IGVkZ2VzIGludm9sdmVkIGluIGNvbGxpc2lvblxuICAgICAgICAgICAgYm9keUJ0b0EgPSBWZWN0b3Iuc3ViKFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb25JbXB1bHNlLCBib2R5Qi5wb3NpdGlvbiwgdGVtcEEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb25JbXB1bHNlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3Iuc3ViKGJvZHlCLnBvc2l0aW9uLCBjb2xsaXNpb24ucGVuZXRyYXRpb24sIHRlbXBCKSwgdGVtcEMpLCB0ZW1wRCk7XG5cbiAgICAgICAgICAgIHBhaXIuc2VwYXJhdGlvbiA9IFZlY3Rvci5kb3Qobm9ybWFsLCBib2R5QnRvQSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UgPSAocGFpci5zZXBhcmF0aW9uIC0gcGFpci5zbG9wKSAqIHRpbWVTY2FsZTtcblxuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlCLmlzU3RhdGljKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSAqPSAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIShib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiAvIGJvZHlBLnRvdGFsQ29udGFjdHM7XG4gICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25JbXB1bHNlLnggKz0gbm9ybWFsLnggKiBwb3NpdGlvbkltcHVsc2UgKiBjb250YWN0U2hhcmU7XG4gICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25JbXB1bHNlLnkgKz0gbm9ybWFsLnkgKiBwb3NpdGlvbkltcHVsc2UgKiBjb250YWN0U2hhcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gUmVzb2x2ZXIuX3Bvc2l0aW9uRGFtcGVuIC8gYm9keUIudG90YWxDb250YWN0cztcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueCAtPSBub3JtYWwueCAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueSAtPSBub3JtYWwueSAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwb3NpdGlvbiByZXNvbHV0aW9uLlxuICAgICAqIEBtZXRob2QgcG9zdFNvbHZlUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyByZXNldCBjb250YWN0IGNvdW50XG4gICAgICAgICAgICBib2R5LnRvdGFsQ29udGFjdHMgPSAwO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5wb3NpdGlvbkltcHVsc2UueCAhPT0gMCB8fCBib2R5LnBvc2l0aW9uSW1wdWxzZS55ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgYm9keS5wb3NpdGlvbkltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLng7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBib2R5LnBvc2l0aW9uSW1wdWxzZS55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGJvZHkgd2l0aG91dCBjaGFuZ2luZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gYm9keS5wb3NpdGlvbkltcHVsc2UueDtcbiAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoVmVjdG9yLmRvdChib2R5LnBvc2l0aW9uSW1wdWxzZSwgYm9keS52ZWxvY2l0eSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNhY2hlZCBpbXB1bHNlIGlmIHRoZSBib2R5IGhhcyB2ZWxvY2l0eSBhbG9uZyBpdFxuICAgICAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybSB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueCAqPSBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nO1xuICAgICAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS55ICo9IFJlc29sdmVyLl9wb3NpdGlvbldhcm1pbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgcGFpcnMgZm9yIHZlbG9jaXR5IHNvbHZpbmcuXG4gICAgICogQG1ldGhvZCBwcmVTb2x2ZVZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICovXG4gICAgUmVzb2x2ZXIucHJlU29sdmVWZWxvY2l0eSA9IGZ1bmN0aW9uKHBhaXJzKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb250YWN0cyxcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICB0YW5nZW50LFxuICAgICAgICAgICAgY29udGFjdCxcbiAgICAgICAgICAgIGNvbnRhY3RWZXJ0ZXgsXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlLFxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBpbXB1bHNlID0gVmVjdG9yLl90ZW1wWzBdLFxuICAgICAgICAgICAgdGVtcEEgPSBWZWN0b3IuX3RlbXBbMV07XG4gICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnRhY3RzID0gcGFpci5hY3RpdmVDb250YWN0cztcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24ucGFyZW50QTtcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEI7XG4gICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsO1xuICAgICAgICAgICAgdGFuZ2VudCA9IGNvbGxpc2lvbi50YW5nZW50O1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdCA9IGNvbnRhY3RzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnRhY3RWZXJ0ZXggPSBjb250YWN0LnZlcnRleDtcbiAgICAgICAgICAgICAgICBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxJbXB1bHNlICE9PSAwIHx8IHRhbmdlbnRJbXB1bHNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvdGFsIGltcHVsc2UgZnJvbSBjb250YWN0XG4gICAgICAgICAgICAgICAgICAgIGltcHVsc2UueCA9IChub3JtYWwueCAqIG5vcm1hbEltcHVsc2UpICsgKHRhbmdlbnQueCAqIHRhbmdlbnRJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gKG5vcm1hbC55ICogbm9ybWFsSW1wdWxzZSkgKyAodGFuZ2VudC55ICogdGFuZ2VudEltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFZlY3Rvci5zdWIoY29udGFjdFZlcnRleCwgYm9keUEucG9zaXRpb24sIHRlbXBBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54ICs9IGltcHVsc2UueCAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnkgKz0gaW1wdWxzZS55ICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gVmVjdG9yLmNyb3NzKG9mZnNldCwgaW1wdWxzZSkgKiBib2R5QS5pbnZlcnNlSW5lcnRpYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBWZWN0b3Iuc3ViKGNvbnRhY3RWZXJ0ZXgsIGJvZHlCLnBvc2l0aW9uLCB0ZW1wQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvblByZXYueCAtPSBpbXB1bHNlLnggKiBib2R5Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2UueSAqIGJvZHlCLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuYW5nbGVQcmV2IC09IFZlY3Rvci5jcm9zcyhvZmZzZXQsIGltcHVsc2UpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHNvbHV0aW9uIGZvciBwYWlyIHZlbG9jaXRpZXMuXG4gICAgICogQG1ldGhvZCBzb2x2ZVZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxuICAgICAqL1xuICAgIFJlc29sdmVyLnNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbihwYWlycywgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGVTcXVhcmVkID0gdGltZVNjYWxlICogdGltZVNjYWxlLFxuICAgICAgICAgICAgaW1wdWxzZSA9IFZlY3Rvci5fdGVtcFswXSxcbiAgICAgICAgICAgIHRlbXBBID0gVmVjdG9yLl90ZW1wWzFdLFxuICAgICAgICAgICAgdGVtcEIgPSBWZWN0b3IuX3RlbXBbMl0sXG4gICAgICAgICAgICB0ZW1wQyA9IFZlY3Rvci5fdGVtcFszXSxcbiAgICAgICAgICAgIHRlbXBEID0gVmVjdG9yLl90ZW1wWzRdLFxuICAgICAgICAgICAgdGVtcEUgPSBWZWN0b3IuX3RlbXBbNV07XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEEsXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QixcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsLFxuICAgICAgICAgICAgICAgIHRhbmdlbnQgPSBjb2xsaXNpb24udGFuZ2VudCxcbiAgICAgICAgICAgICAgICBjb250YWN0cyA9IHBhaXIuYWN0aXZlQ29udGFjdHMsXG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gMSAvIGNvbnRhY3RzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgdmVsb2NpdGllc1xuICAgICAgICAgICAgYm9keUEudmVsb2NpdHkueCA9IGJvZHlBLnBvc2l0aW9uLnggLSBib2R5QS5wb3NpdGlvblByZXYueDtcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2Lnk7XG4gICAgICAgICAgICBib2R5Qi52ZWxvY2l0eS54ID0gYm9keUIucG9zaXRpb24ueCAtIGJvZHlCLnBvc2l0aW9uUHJldi54O1xuICAgICAgICAgICAgYm9keUIudmVsb2NpdHkueSA9IGJvZHlCLnBvc2l0aW9uLnkgLSBib2R5Qi5wb3NpdGlvblByZXYueTtcbiAgICAgICAgICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlBLmFuZ2xlIC0gYm9keUEuYW5nbGVQcmV2O1xuICAgICAgICAgICAgYm9keUIuYW5ndWxhclZlbG9jaXR5ID0gYm9keUIuYW5nbGUgLSBib2R5Qi5hbmdsZVByZXY7XG5cbiAgICAgICAgICAgIC8vIHJlc29sdmUgZWFjaCBjb250YWN0XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBjb250YWN0c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFZlcnRleCA9IGNvbnRhY3QudmVydGV4LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRBID0gVmVjdG9yLnN1Yihjb250YWN0VmVydGV4LCBib2R5QS5wb3NpdGlvbiwgdGVtcEEpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCID0gVmVjdG9yLnN1Yihjb250YWN0VmVydGV4LCBib2R5Qi5wb3NpdGlvbiwgdGVtcEIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eVBvaW50QSA9IFZlY3Rvci5hZGQoYm9keUEudmVsb2NpdHksIFZlY3Rvci5tdWx0KFZlY3Rvci5wZXJwKG9mZnNldEEpLCBib2R5QS5hbmd1bGFyVmVsb2NpdHkpLCB0ZW1wQyksXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0gVmVjdG9yLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QiksIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSksIHRlbXBEKSwgXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3Iuc3ViKHZlbG9jaXR5UG9pbnRBLCB2ZWxvY2l0eVBvaW50QiwgdGVtcEUpLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxWZWxvY2l0eSA9IFZlY3Rvci5kb3Qobm9ybWFsLCByZWxhdGl2ZVZlbG9jaXR5KTtcblxuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50VmVsb2NpdHkgPSBWZWN0b3IuZG90KHRhbmdlbnQsIHJlbGF0aXZlVmVsb2NpdHkpLFxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50U3BlZWQgPSBNYXRoLmFicyh0YW5nZW50VmVsb2NpdHkpLFxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50VmVsb2NpdHlEaXJlY3Rpb24gPSBDb21tb24uc2lnbih0YW5nZW50VmVsb2NpdHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmF3IGltcHVsc2VzXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEltcHVsc2UgPSAoMSArIHBhaXIucmVzdGl0dXRpb24pICogbm9ybWFsVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEZvcmNlID0gQ29tbW9uLmNsYW1wKHBhaXIuc2VwYXJhdGlvbiArIG5vcm1hbFZlbG9jaXR5LCAwLCAxKSAqIFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBjb3Vsb21iIGZyaWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHRhbmdlbnRJbXB1bHNlID0gdGFuZ2VudFZlbG9jaXR5LFxuICAgICAgICAgICAgICAgICAgICBtYXhGcmljdGlvbiA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRTcGVlZCA+IHBhaXIuZnJpY3Rpb24gKiBwYWlyLmZyaWN0aW9uU3RhdGljICogbm9ybWFsRm9yY2UgKiB0aW1lU2NhbGVTcXVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEZyaWN0aW9uID0gdGFuZ2VudFNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IENvbW1vbi5jbGFtcChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXIuZnJpY3Rpb24gKiB0YW5nZW50VmVsb2NpdHlEaXJlY3Rpb24gKiB0aW1lU2NhbGVTcXVhcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLW1heEZyaWN0aW9uLCBtYXhGcmljdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vZGlmeSBpbXB1bHNlcyBhY2NvdW50aW5nIGZvciBtYXNzLCBpbmVydGlhIGFuZCBvZmZzZXRcbiAgICAgICAgICAgICAgICB2YXIgb0FjTiA9IFZlY3Rvci5jcm9zcyhvZmZzZXRBLCBub3JtYWwpLFxuICAgICAgICAgICAgICAgICAgICBvQmNOID0gVmVjdG9yLmNyb3NzKG9mZnNldEIsIG5vcm1hbCksXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlID0gY29udGFjdFNoYXJlIC8gKGJvZHlBLmludmVyc2VNYXNzICsgYm9keUIuaW52ZXJzZU1hc3MgKyBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIG9BY04gKiBvQWNOICArIGJvZHlCLmludmVyc2VJbmVydGlhICogb0JjTiAqIG9CY04pO1xuXG4gICAgICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSAqPSBzaGFyZTtcbiAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSAqPSBzaGFyZTtcblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBoaWdoIHZlbG9jaXR5IGFuZCByZXN0aW5nIGNvbGxpc2lvbnMgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxWZWxvY2l0eSA8IDAgJiYgbm9ybWFsVmVsb2NpdHkgKiBub3JtYWxWZWxvY2l0eSA+IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoICogdGltZVNjYWxlU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWdoIG5vcm1hbCB2ZWxvY2l0eSBzbyBjbGVhciBjYWNoZWQgY29udGFjdCBub3JtYWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbHZlIHJlc3RpbmcgY29sbGlzaW9uIGNvbnN0cmFpbnRzIHVzaW5nIEVyaW4gQ2F0dG8ncyBtZXRob2QgKEdEQzA4KVxuICAgICAgICAgICAgICAgICAgICAvLyBpbXB1bHNlIGNvbnN0cmFpbnQgdGVuZHMgdG8gMFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdE5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3Qubm9ybWFsSW1wdWxzZSA9IE1hdGgubWluKGNvbnRhY3Qubm9ybWFsSW1wdWxzZSArIG5vcm1hbEltcHVsc2UsIDApO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlIC0gY29udGFjdE5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGhpZ2ggdmVsb2NpdHkgYW5kIHJlc3RpbmcgY29sbGlzaW9ucyBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRWZWxvY2l0eSAqIHRhbmdlbnRWZWxvY2l0eSA+IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCAqIHRpbWVTY2FsZVNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCB0YW5nZW50IHZlbG9jaXR5IHNvIGNsZWFyIGNhY2hlZCBjb250YWN0IHRhbmdlbnQgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZSByZXN0aW5nIGNvbGxpc2lvbiBjb25zdHJhaW50cyB1c2luZyBFcmluIENhdHRvJ3MgbWV0aG9kIChHREMwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFuZ2VudCBpbXB1bHNlIHRlbmRzIHRvIC10YW5nZW50U3BlZWQgb3IgK3RhbmdlbnRTcGVlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdFRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC50YW5nZW50SW1wdWxzZSA9IENvbW1vbi5jbGFtcChjb250YWN0LnRhbmdlbnRJbXB1bHNlICsgdGFuZ2VudEltcHVsc2UsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudEltcHVsc2UgLSBjb250YWN0VGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdG90YWwgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSAobm9ybWFsLnggKiBub3JtYWxJbXB1bHNlKSArICh0YW5nZW50LnggKiB0YW5nZW50SW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gKG5vcm1hbC55ICogbm9ybWFsSW1wdWxzZSkgKyAodGFuZ2VudC55ICogdGFuZ2VudEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGltcHVsc2UgZnJvbSBjb250YWN0XG4gICAgICAgICAgICAgICAgaWYgKCEoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnggKz0gaW1wdWxzZS54ICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55ICs9IGltcHVsc2UueSAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gVmVjdG9yLmNyb3NzKG9mZnNldEEsIGltcHVsc2UpICogYm9keUEuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnggLT0gaW1wdWxzZS54ICogYm9keUIuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2UueSAqIGJvZHlCLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICBib2R5Qi5hbmdsZVByZXYgLT0gVmVjdG9yLmNyb3NzKG9mZnNldEIsIGltcHVsc2UpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxufSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyOCxcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6Mjl9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuU0FUYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgZGV0ZWN0aW5nIGNvbGxpc2lvbnMgdXNpbmcgdGhlIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtLlxuKlxuKiBAY2xhc3MgU0FUXG4qL1xuXG4vLyBUT0RPOiB0cnVlIGNpcmNsZXMgYW5kIGN1cnZlc1xuXG52YXIgU0FUID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gU0FUO1xuXG52YXIgVmVydGljZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIFZlY3RvciA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllcyB1c2luZyB0aGUgU2VwYXJhdGluZyBBeGlzIFRoZW9yZW0uXG4gICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlCXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb259IHByZXZpb3VzQ29sbGlzaW9uXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9ufSBjb2xsaXNpb25cbiAgICAgKi9cbiAgICBTQVQuY29sbGlkZXMgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHByZXZpb3VzQ29sbGlzaW9uKSB7XG4gICAgICAgIHZhciBvdmVybGFwQUIsXG4gICAgICAgICAgICBvdmVybGFwQkEsIFxuICAgICAgICAgICAgbWluT3ZlcmxhcCxcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGNhblJldXNlUHJldkNvbCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwcmV2aW91c0NvbGxpc2lvbikge1xuICAgICAgICAgICAgLy8gZXN0aW1hdGUgdG90YWwgbW90aW9uXG4gICAgICAgICAgICB2YXIgcGFyZW50QSA9IGJvZHlBLnBhcmVudCxcbiAgICAgICAgICAgICAgICBwYXJlbnRCID0gYm9keUIucGFyZW50LFxuICAgICAgICAgICAgICAgIG1vdGlvbiA9IHBhcmVudEEuc3BlZWQgKiBwYXJlbnRBLnNwZWVkICsgcGFyZW50QS5hbmd1bGFyU3BlZWQgKiBwYXJlbnRBLmFuZ3VsYXJTcGVlZFxuICAgICAgICAgICAgICAgICAgICAgICArIHBhcmVudEIuc3BlZWQgKiBwYXJlbnRCLnNwZWVkICsgcGFyZW50Qi5hbmd1bGFyU3BlZWQgKiBwYXJlbnRCLmFuZ3VsYXJTcGVlZDtcblxuICAgICAgICAgICAgLy8gd2UgbWF5IGJlIGFibGUgdG8gKHBhcnRpYWxseSkgcmV1c2UgY29sbGlzaW9uIHJlc3VsdCBcbiAgICAgICAgICAgIC8vIGJ1dCBvbmx5IHNhZmUgaWYgY29sbGlzaW9uIHdhcyByZXN0aW5nXG4gICAgICAgICAgICBjYW5SZXVzZVByZXZDb2wgPSBwcmV2aW91c0NvbGxpc2lvbiAmJiBwcmV2aW91c0NvbGxpc2lvbi5jb2xsaWRlZCAmJiBtb3Rpb24gPCAwLjI7XG5cbiAgICAgICAgICAgIC8vIHJldXNlIGNvbGxpc2lvbiBvYmplY3RcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHByZXZpb3VzQ29sbGlzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlzaW9uID0geyBjb2xsaWRlZDogZmFsc2UsIGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldmlvdXNDb2xsaXNpb24gJiYgY2FuUmV1c2VQcmV2Q29sKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4gcmV1c2UgdGhlIGNvbGxpc2lvbiByZXN1bHRcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byB0ZXN0IHRoZSBwcmV2aW91c2x5IGZvdW5kIGF4aXNcbiAgICAgICAgICAgIHZhciBheGlzQm9keUEgPSBjb2xsaXNpb24uYXhpc0JvZHksXG4gICAgICAgICAgICAgICAgYXhpc0JvZHlCID0gYXhpc0JvZHlBID09PSBib2R5QSA/IGJvZHlCIDogYm9keUEsXG4gICAgICAgICAgICAgICAgYXhlcyA9IFtheGlzQm9keUEuYXhlc1twcmV2aW91c0NvbGxpc2lvbi5heGlzTnVtYmVyXV07XG5cbiAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBTQVQuX292ZXJsYXBBeGVzKGF4aXNCb2R5QS52ZXJ0aWNlcywgYXhpc0JvZHlCLnZlcnRpY2VzLCBheGVzKTtcbiAgICAgICAgICAgIGNvbGxpc2lvbi5yZXVzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAobWluT3ZlcmxhcC5vdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgcmV1c2UgYSByZXN1bHQsIHBlcmZvcm0gYSBmdWxsIFNBVCB0ZXN0XG5cbiAgICAgICAgICAgIG92ZXJsYXBBQiA9IFNBVC5fb3ZlcmxhcEF4ZXMoYm9keUEudmVydGljZXMsIGJvZHlCLnZlcnRpY2VzLCBib2R5QS5heGVzKTtcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXBBQi5vdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdmVybGFwQkEgPSBTQVQuX292ZXJsYXBBeGVzKGJvZHlCLnZlcnRpY2VzLCBib2R5QS52ZXJ0aWNlcywgYm9keUIuYXhlcyk7XG5cbiAgICAgICAgICAgIGlmIChvdmVybGFwQkEub3ZlcmxhcCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG92ZXJsYXBBQi5vdmVybGFwIDwgb3ZlcmxhcEJBLm92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcEFCO1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5heGlzQm9keSA9IGJvZHlBO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcEJBO1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5heGlzQm9keSA9IGJvZHlCO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIHJldXNlIGxhdGVyXG4gICAgICAgICAgICBjb2xsaXNpb24uYXhpc051bWJlciA9IG1pbk92ZXJsYXAuYXhpc051bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxpc2lvbi5ib2R5QSA9IGJvZHlBLmlkIDwgYm9keUIuaWQgPyBib2R5QSA6IGJvZHlCO1xuICAgICAgICBjb2xsaXNpb24uYm9keUIgPSBib2R5QS5pZCA8IGJvZHlCLmlkID8gYm9keUIgOiBib2R5QTtcbiAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gdHJ1ZTtcbiAgICAgICAgY29sbGlzaW9uLmRlcHRoID0gbWluT3ZlcmxhcC5vdmVybGFwO1xuICAgICAgICBjb2xsaXNpb24ucGFyZW50QSA9IGNvbGxpc2lvbi5ib2R5QS5wYXJlbnQ7XG4gICAgICAgIGNvbGxpc2lvbi5wYXJlbnRCID0gY29sbGlzaW9uLmJvZHlCLnBhcmVudDtcbiAgICAgICAgXG4gICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBO1xuICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QjtcblxuICAgICAgICAvLyBlbnN1cmUgbm9ybWFsIGlzIGZhY2luZyBhd2F5IGZyb20gYm9keUFcbiAgICAgICAgaWYgKFZlY3Rvci5kb3QobWluT3ZlcmxhcC5heGlzLCBWZWN0b3Iuc3ViKGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbikpIDwgMCkge1xuICAgICAgICAgICAgY29sbGlzaW9uLm5vcm1hbCA9IHtcbiAgICAgICAgICAgICAgICB4OiBtaW5PdmVybGFwLmF4aXMueCxcbiAgICAgICAgICAgICAgICB5OiBtaW5PdmVybGFwLmF4aXMueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxpc2lvbi5ub3JtYWwgPSB7XG4gICAgICAgICAgICAgICAgeDogLW1pbk92ZXJsYXAuYXhpcy54LFxuICAgICAgICAgICAgICAgIHk6IC1taW5PdmVybGFwLmF4aXMueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxpc2lvbi50YW5nZW50ID0gVmVjdG9yLnBlcnAoY29sbGlzaW9uLm5vcm1hbCk7XG5cbiAgICAgICAgY29sbGlzaW9uLnBlbmV0cmF0aW9uID0gY29sbGlzaW9uLnBlbmV0cmF0aW9uIHx8IHt9O1xuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCA9IGNvbGxpc2lvbi5ub3JtYWwueCAqIGNvbGxpc2lvbi5kZXB0aDtcbiAgICAgICAgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnkgPSBjb2xsaXNpb24ubm9ybWFsLnkgKiBjb2xsaXNpb24uZGVwdGg7IFxuXG4gICAgICAgIC8vIGZpbmQgc3VwcG9ydCBwb2ludHMsIHRoZXJlIGlzIGFsd2F5cyBlaXRoZXIgZXhhY3RseSBvbmUgb3IgdHdvXG4gICAgICAgIHZhciB2ZXJ0aWNlc0IgPSBTQVQuX2ZpbmRTdXBwb3J0cyhib2R5QSwgYm9keUIsIGNvbGxpc2lvbi5ub3JtYWwpLFxuICAgICAgICAgICAgc3VwcG9ydHMgPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBzdXBwb3J0cyBmcm9tIGJvZHlCIHRoYXQgYXJlIGluc2lkZSBib2R5QVxuICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMoYm9keUEudmVydGljZXMsIHZlcnRpY2VzQlswXSkpXG4gICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQlswXSk7XG5cbiAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlBLnZlcnRpY2VzLCB2ZXJ0aWNlc0JbMV0pKVxuICAgICAgICAgICAgc3VwcG9ydHMucHVzaCh2ZXJ0aWNlc0JbMV0pO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHN1cHBvcnRzIGZyb20gYm9keUEgdGhhdCBhcmUgaW5zaWRlIGJvZHlCXG4gICAgICAgIGlmIChzdXBwb3J0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgdmVydGljZXNBID0gU0FULl9maW5kU3VwcG9ydHMoYm9keUIsIGJvZHlBLCBWZWN0b3IubmVnKGNvbGxpc2lvbi5ub3JtYWwpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5Qi52ZXJ0aWNlcywgdmVydGljZXNBWzBdKSlcbiAgICAgICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQVswXSk7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0cy5sZW5ndGggPCAyICYmIFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlCLnZlcnRpY2VzLCB2ZXJ0aWNlc0FbMV0pKVxuICAgICAgICAgICAgICAgIHN1cHBvcnRzLnB1c2godmVydGljZXNBWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBlZGdlIGNhc2Ugb2Ygb3ZlcmxhcHBpbmcgYnV0IG5vIHZlcnRleCBjb250YWlubWVudFxuICAgICAgICBpZiAoc3VwcG9ydHMubGVuZ3RoIDwgMSlcbiAgICAgICAgICAgIHN1cHBvcnRzID0gW3ZlcnRpY2VzQlswXV07XG4gICAgICAgIFxuICAgICAgICBjb2xsaXNpb24uc3VwcG9ydHMgPSBzdXBwb3J0cztcblxuICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvdmVybGFwIGJldHdlZW4gdHdvIHNldHMgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBfb3ZlcmxhcEF4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSB2ZXJ0aWNlc0FcbiAgICAgKiBAcGFyYW0ge30gdmVydGljZXNCXG4gICAgICogQHBhcmFtIHt9IGF4ZXNcbiAgICAgKiBAcmV0dXJuIHJlc3VsdFxuICAgICAqL1xuICAgIFNBVC5fb3ZlcmxhcEF4ZXMgPSBmdW5jdGlvbih2ZXJ0aWNlc0EsIHZlcnRpY2VzQiwgYXhlcykge1xuICAgICAgICB2YXIgcHJvamVjdGlvbkEgPSBWZWN0b3IuX3RlbXBbMF0sIFxuICAgICAgICAgICAgcHJvamVjdGlvbkIgPSBWZWN0b3IuX3RlbXBbMV0sXG4gICAgICAgICAgICByZXN1bHQgPSB7IG92ZXJsYXA6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgIG92ZXJsYXAsXG4gICAgICAgICAgICBheGlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXhpcyA9IGF4ZXNbaV07XG5cbiAgICAgICAgICAgIFNBVC5fcHJvamVjdFRvQXhpcyhwcm9qZWN0aW9uQSwgdmVydGljZXNBLCBheGlzKTtcbiAgICAgICAgICAgIFNBVC5fcHJvamVjdFRvQXhpcyhwcm9qZWN0aW9uQiwgdmVydGljZXNCLCBheGlzKTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IE1hdGgubWluKHByb2plY3Rpb25BLm1heCAtIHByb2plY3Rpb25CLm1pbiwgcHJvamVjdGlvbkIubWF4IC0gcHJvamVjdGlvbkEubWluKTtcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IHJlc3VsdC5vdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5heGlzID0gYXhpcztcbiAgICAgICAgICAgICAgICByZXN1bHQuYXhpc051bWJlciA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0cyB2ZXJ0aWNlcyBvbiBhbiBheGlzIGFuZCByZXR1cm5zIGFuIGludGVydmFsLlxuICAgICAqIEBtZXRob2QgX3Byb2plY3RUb0F4aXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBwcm9qZWN0aW9uXG4gICAgICogQHBhcmFtIHt9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHt9IGF4aXNcbiAgICAgKi9cbiAgICBTQVQuX3Byb2plY3RUb0F4aXMgPSBmdW5jdGlvbihwcm9qZWN0aW9uLCB2ZXJ0aWNlcywgYXhpcykge1xuICAgICAgICB2YXIgbWluID0gVmVjdG9yLmRvdCh2ZXJ0aWNlc1swXSwgYXhpcyksXG4gICAgICAgICAgICBtYXggPSBtaW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGRvdCA9IFZlY3Rvci5kb3QodmVydGljZXNbaV0sIGF4aXMpO1xuXG4gICAgICAgICAgICBpZiAoZG90ID4gbWF4KSB7IFxuICAgICAgICAgICAgICAgIG1heCA9IGRvdDsgXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvdCA8IG1pbikgeyBcbiAgICAgICAgICAgICAgICBtaW4gPSBkb3Q7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvamVjdGlvbi5taW4gPSBtaW47XG4gICAgICAgIHByb2plY3Rpb24ubWF4ID0gbWF4O1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogRmluZHMgc3VwcG9ydGluZyB2ZXJ0aWNlcyBnaXZlbiB0d28gYm9kaWVzIGFsb25nIGEgZ2l2ZW4gZGlyZWN0aW9uIHVzaW5nIGhpbGwtY2xpbWJpbmcuXG4gICAgICogQG1ldGhvZCBfZmluZFN1cHBvcnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gYm9keUFcbiAgICAgKiBAcGFyYW0ge30gYm9keUJcbiAgICAgKiBAcGFyYW0ge30gbm9ybWFsXG4gICAgICogQHJldHVybiBbdmVjdG9yXVxuICAgICAqL1xuICAgIFNBVC5fZmluZFN1cHBvcnRzID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBub3JtYWwpIHtcbiAgICAgICAgdmFyIG5lYXJlc3REaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICB2ZXJ0ZXhUb0JvZHkgPSBWZWN0b3IuX3RlbXBbMF0sXG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IGJvZHlCLnZlcnRpY2VzLFxuICAgICAgICAgICAgYm9keUFQb3NpdGlvbiA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgICB2ZXJ0ZXhBLFxuICAgICAgICAgICAgdmVydGV4QjtcblxuICAgICAgICAvLyBmaW5kIGNsb3Nlc3QgdmVydGV4IG9uIGJvZHlCXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgdmVydGV4VG9Cb2R5LnggPSB2ZXJ0ZXgueCAtIGJvZHlBUG9zaXRpb24ueDtcbiAgICAgICAgICAgIHZlcnRleFRvQm9keS55ID0gdmVydGV4LnkgLSBib2R5QVBvc2l0aW9uLnk7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IC1WZWN0b3IuZG90KG5vcm1hbCwgdmVydGV4VG9Cb2R5KTtcblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbmVhcmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbmVhcmVzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdmVydGV4QSA9IHZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgbmV4dCBjbG9zZXN0IHZlcnRleCB1c2luZyB0aGUgdHdvIGNvbm5lY3RlZCB0byBpdFxuICAgICAgICB2YXIgcHJldkluZGV4ID0gdmVydGV4QS5pbmRleCAtIDEgPj0gMCA/IHZlcnRleEEuaW5kZXggLSAxIDogdmVydGljZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbcHJldkluZGV4XTtcbiAgICAgICAgdmVydGV4VG9Cb2R5LnggPSB2ZXJ0ZXgueCAtIGJvZHlBUG9zaXRpb24ueDtcbiAgICAgICAgdmVydGV4VG9Cb2R5LnkgPSB2ZXJ0ZXgueSAtIGJvZHlBUG9zaXRpb24ueTtcbiAgICAgICAgbmVhcmVzdERpc3RhbmNlID0gLVZlY3Rvci5kb3Qobm9ybWFsLCB2ZXJ0ZXhUb0JvZHkpO1xuICAgICAgICB2ZXJ0ZXhCID0gdmVydGV4O1xuXG4gICAgICAgIHZhciBuZXh0SW5kZXggPSAodmVydGV4QS5pbmRleCArIDEpICUgdmVydGljZXMubGVuZ3RoO1xuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tuZXh0SW5kZXhdO1xuICAgICAgICB2ZXJ0ZXhUb0JvZHkueCA9IHZlcnRleC54IC0gYm9keUFQb3NpdGlvbi54O1xuICAgICAgICB2ZXJ0ZXhUb0JvZHkueSA9IHZlcnRleC55IC0gYm9keUFQb3NpdGlvbi55O1xuICAgICAgICBkaXN0YW5jZSA9IC1WZWN0b3IuZG90KG5vcm1hbCwgdmVydGV4VG9Cb2R5KTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbmVhcmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhCID0gdmVydGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt2ZXJ0ZXhBLCB2ZXJ0ZXhCXTtcbiAgICB9O1xuXG59KSgpO1xuXG59LHtcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyOX1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5Db25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb25zdHJhaW50cy5cbiogQ29uc3RyYWludHMgYXJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgdGhhdCBhIGZpeGVkIGRpc3RhbmNlIG11c3QgYmUgbWFpbnRhaW5lZCBiZXR3ZWVuIHR3byBib2RpZXMgKG9yIGEgYm9keSBhbmQgYSBmaXhlZCB3b3JsZC1zcGFjZSBwb3NpdGlvbikuXG4qIFRoZSBzdGlmZm5lc3Mgb2YgY29uc3RyYWludHMgY2FuIGJlIG1vZGlmaWVkIHRvIGNyZWF0ZSBzcHJpbmdzIG9yIGVsYXN0aWMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb25zdHJhaW50XG4qL1xuXG52YXIgQ29uc3RyYWludCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XG5cbnZhciBWZXJ0aWNlcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XG52YXIgVmVjdG9yID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XG52YXIgU2xlZXBpbmcgPSBfZGVyZXFfKCcuLi9jb3JlL1NsZWVwaW5nJyk7XG52YXIgQm91bmRzID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XG52YXIgQXhlcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L0F4ZXMnKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBDb25zdHJhaW50Ll93YXJtaW5nID0gMC40O1xuICAgIENvbnN0cmFpbnQuX3RvcnF1ZURhbXBlbiA9IDE7XG4gICAgQ29uc3RyYWludC5fbWluTGVuZ3RoID0gMC4wMDAwMDE7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnN0cmFpbnQuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBUbyBzaW11bGF0ZSBhIHJldm9sdXRlIGNvbnN0cmFpbnQgKG9yIHBpbiBqb2ludCkgc2V0IGBsZW5ndGg6IDBgIGFuZCBhIGhpZ2ggYHN0aWZmbmVzc2AgdmFsdWUgKGUuZy4gYDAuN2Agb3IgYWJvdmUpLlxuICAgICAqIElmIHRoZSBjb25zdHJhaW50IGlzIHVuc3RhYmxlLCB0cnkgbG93ZXJpbmcgdGhlIGBzdGlmZm5lc3NgIHZhbHVlIGFuZCAvIG9yIGluY3JlYXNpbmcgYGVuZ2luZS5jb25zdHJhaW50SXRlcmF0aW9uc2AuXG4gICAgICogRm9yIGNvbXBvdW5kIGJvZGllcywgY29uc3RyYWludHMgbXVzdCBiZSBhcHBsaWVkIHRvIHRoZSBwYXJlbnQgYm9keSAobm90IG9uZSBvZiBpdHMgcGFydHMpLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBvcHRpb25zO1xuXG4gICAgICAgIC8vIGlmIGJvZGllcyBkZWZpbmVkIGJ1dCBubyBwb2ludHMsIHVzZSBib2R5IGNlbnRyZVxuICAgICAgICBpZiAoY29uc3RyYWludC5ib2R5QSAmJiAhY29uc3RyYWludC5wb2ludEEpXG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBpZiAoY29uc3RyYWludC5ib2R5QiAmJiAhY29uc3RyYWludC5wb2ludEIpXG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzdGF0aWMgbGVuZ3RoIHVzaW5nIGluaXRpYWwgd29ybGQgc3BhY2UgcG9pbnRzXG4gICAgICAgIHZhciBpbml0aWFsUG9pbnRBID0gY29uc3RyYWludC5ib2R5QSA/IFZlY3Rvci5hZGQoY29uc3RyYWludC5ib2R5QS5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEEpIDogY29uc3RyYWludC5wb2ludEEsXG4gICAgICAgICAgICBpbml0aWFsUG9pbnRCID0gY29uc3RyYWludC5ib2R5QiA/IFZlY3Rvci5hZGQoY29uc3RyYWludC5ib2R5Qi5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEIpIDogY29uc3RyYWludC5wb2ludEIsXG4gICAgICAgICAgICBsZW5ndGggPSBWZWN0b3IubWFnbml0dWRlKFZlY3Rvci5zdWIoaW5pdGlhbFBvaW50QSwgaW5pdGlhbFBvaW50QikpO1xuICAgIFxuICAgICAgICBjb25zdHJhaW50Lmxlbmd0aCA9IHR5cGVvZiBjb25zdHJhaW50Lmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zdHJhaW50Lmxlbmd0aCA6IGxlbmd0aDtcblxuICAgICAgICAvLyBvcHRpb24gZGVmYXVsdHNcbiAgICAgICAgY29uc3RyYWludC5pZCA9IGNvbnN0cmFpbnQuaWQgfHwgQ29tbW9uLm5leHRJZCgpO1xuICAgICAgICBjb25zdHJhaW50LmxhYmVsID0gY29uc3RyYWludC5sYWJlbCB8fCAnQ29uc3RyYWludCc7XG4gICAgICAgIGNvbnN0cmFpbnQudHlwZSA9ICdjb25zdHJhaW50JztcbiAgICAgICAgY29uc3RyYWludC5zdGlmZm5lc3MgPSBjb25zdHJhaW50LnN0aWZmbmVzcyB8fCAoY29uc3RyYWludC5sZW5ndGggPiAwID8gMSA6IDAuNyk7XG4gICAgICAgIGNvbnN0cmFpbnQuZGFtcGluZyA9IGNvbnN0cmFpbnQuZGFtcGluZyB8fCAwO1xuICAgICAgICBjb25zdHJhaW50LmFuZ3VsYXJTdGlmZm5lc3MgPSBjb25zdHJhaW50LmFuZ3VsYXJTdGlmZm5lc3MgfHwgMDtcbiAgICAgICAgY29uc3RyYWludC5hbmdsZUEgPSBjb25zdHJhaW50LmJvZHlBID8gY29uc3RyYWludC5ib2R5QS5hbmdsZSA6IGNvbnN0cmFpbnQuYW5nbGVBO1xuICAgICAgICBjb25zdHJhaW50LmFuZ2xlQiA9IGNvbnN0cmFpbnQuYm9keUIgPyBjb25zdHJhaW50LmJvZHlCLmFuZ2xlIDogY29uc3RyYWludC5hbmdsZUI7XG4gICAgICAgIGNvbnN0cmFpbnQucGx1Z2luID0ge307XG5cbiAgICAgICAgLy8gcmVuZGVyXG4gICAgICAgIHZhciByZW5kZXIgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgIGFuY2hvcnM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29uc3RyYWludC5sZW5ndGggPT09IDAgJiYgY29uc3RyYWludC5zdGlmZm5lc3MgPiAwLjEpIHtcbiAgICAgICAgICAgIHJlbmRlci50eXBlID0gJ3Bpbic7XG4gICAgICAgICAgICByZW5kZXIuYW5jaG9ycyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQuc3RpZmZuZXNzIDwgMC45KSB7XG4gICAgICAgICAgICByZW5kZXIudHlwZSA9ICdzcHJpbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RyYWludC5yZW5kZXIgPSBDb21tb24uZXh0ZW5kKHJlbmRlciwgY29uc3RyYWludC5yZW5kZXIpO1xuXG4gICAgICAgIHJldHVybiBjb25zdHJhaW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBmb3Igc29sdmluZyBieSBjb25zdHJhaW50IHdhcm1pbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHByZVNvbHZlQWxsXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIENvbnN0cmFpbnQucHJlU29sdmVBbGwgPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBib2R5LmNvbnN0cmFpbnRJbXB1bHNlO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCAoaW1wdWxzZS54ID09PSAwICYmIGltcHVsc2UueSA9PT0gMCAmJiBpbXB1bHNlLmFuZ2xlID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uLnggKz0gaW1wdWxzZS54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvbi55ICs9IGltcHVsc2UueTtcbiAgICAgICAgICAgIGJvZHkuYW5nbGUgKz0gaW1wdWxzZS5hbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTb2x2ZXMgYWxsIGNvbnN0cmFpbnRzIGluIGEgbGlzdCBvZiBjb2xsaXNpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzb2x2ZUFsbFxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludFtdfSBjb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnNvbHZlQWxsID0gZnVuY3Rpb24oY29uc3RyYWludHMsIHRpbWVTY2FsZSkge1xuICAgICAgICAvLyBTb2x2ZSBmaXhlZCBjb25zdHJhaW50cyBmaXJzdC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXSxcbiAgICAgICAgICAgICAgICBmaXhlZEEgPSAhY29uc3RyYWludC5ib2R5QSB8fCAoY29uc3RyYWludC5ib2R5QSAmJiBjb25zdHJhaW50LmJvZHlBLmlzU3RhdGljKSxcbiAgICAgICAgICAgICAgICBmaXhlZEIgPSAhY29uc3RyYWludC5ib2R5QiB8fCAoY29uc3RyYWludC5ib2R5QiAmJiBjb25zdHJhaW50LmJvZHlCLmlzU3RhdGljKTtcblxuICAgICAgICAgICAgaWYgKGZpeGVkQSB8fCBmaXhlZEIpIHtcbiAgICAgICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlKGNvbnN0cmFpbnRzW2ldLCB0aW1lU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29sdmUgZnJlZSBjb25zdHJhaW50cyBsYXN0LlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgICAgIGZpeGVkQSA9ICFjb25zdHJhaW50LmJvZHlBIHx8IChjb25zdHJhaW50LmJvZHlBICYmIGNvbnN0cmFpbnQuYm9keUEuaXNTdGF0aWMpO1xuICAgICAgICAgICAgZml4ZWRCID0gIWNvbnN0cmFpbnQuYm9keUIgfHwgKGNvbnN0cmFpbnQuYm9keUIgJiYgY29uc3RyYWludC5ib2R5Qi5pc1N0YXRpYyk7XG5cbiAgICAgICAgICAgIGlmICghZml4ZWRBICYmICFmaXhlZEIpIHtcbiAgICAgICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlKGNvbnN0cmFpbnRzW2ldLCB0aW1lU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyBhIGRpc3RhbmNlIGNvbnN0cmFpbnQgd2l0aCBHYXVzcy1TaWVkZWwgbWV0aG9kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzb2x2ZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnNvbHZlID0gZnVuY3Rpb24oY29uc3RyYWludCwgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICBwb2ludEEgPSBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgIHBvaW50QiA9IGNvbnN0cmFpbnQucG9pbnRCO1xuXG4gICAgICAgIGlmICghYm9keUEgJiYgIWJvZHlCKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIHVwZGF0ZSByZWZlcmVuY2UgYW5nbGVcbiAgICAgICAgaWYgKGJvZHlBICYmICFib2R5QS5pc1N0YXRpYykge1xuICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZShwb2ludEEsIGJvZHlBLmFuZ2xlIC0gY29uc3RyYWludC5hbmdsZUEsIHBvaW50QSk7XG4gICAgICAgICAgICBjb25zdHJhaW50LmFuZ2xlQSA9IGJvZHlBLmFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB1cGRhdGUgcmVmZXJlbmNlIGFuZ2xlXG4gICAgICAgIGlmIChib2R5QiAmJiAhYm9keUIuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIFZlY3Rvci5yb3RhdGUocG9pbnRCLCBib2R5Qi5hbmdsZSAtIGNvbnN0cmFpbnQuYW5nbGVCLCBwb2ludEIpO1xuICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBib2R5Qi5hbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludEFXb3JsZCA9IHBvaW50QSxcbiAgICAgICAgICAgIHBvaW50QldvcmxkID0gcG9pbnRCO1xuXG4gICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBwb2ludEEpO1xuICAgICAgICBpZiAoYm9keUIpIHBvaW50QldvcmxkID0gVmVjdG9yLmFkZChib2R5Qi5wb3NpdGlvbiwgcG9pbnRCKTtcblxuICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKHBvaW50QVdvcmxkLCBwb2ludEJXb3JsZCksXG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gVmVjdG9yLm1hZ25pdHVkZShkZWx0YSk7XG5cbiAgICAgICAgLy8gcHJldmVudCBzaW5ndWxhcml0eVxuICAgICAgICBpZiAoY3VycmVudExlbmd0aCA8IENvbnN0cmFpbnQuX21pbkxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudExlbmd0aCA9IENvbnN0cmFpbnQuX21pbkxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNvbHZlIGRpc3RhbmNlIGNvbnN0cmFpbnQgd2l0aCBHYXVzcy1TaWVkZWwgbWV0aG9kXG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gKGN1cnJlbnRMZW5ndGggLSBjb25zdHJhaW50Lmxlbmd0aCkgLyBjdXJyZW50TGVuZ3RoLFxuICAgICAgICAgICAgc3RpZmZuZXNzID0gY29uc3RyYWludC5zdGlmZm5lc3MgPCAxID8gY29uc3RyYWludC5zdGlmZm5lc3MgKiB0aW1lU2NhbGUgOiBjb25zdHJhaW50LnN0aWZmbmVzcyxcbiAgICAgICAgICAgIGZvcmNlID0gVmVjdG9yLm11bHQoZGVsdGEsIGRpZmZlcmVuY2UgKiBzdGlmZm5lc3MpLFxuICAgICAgICAgICAgbWFzc1RvdGFsID0gKGJvZHlBID8gYm9keUEuaW52ZXJzZU1hc3MgOiAwKSArIChib2R5QiA/IGJvZHlCLmludmVyc2VNYXNzIDogMCksXG4gICAgICAgICAgICBpbmVydGlhVG90YWwgPSAoYm9keUEgPyBib2R5QS5pbnZlcnNlSW5lcnRpYSA6IDApICsgKGJvZHlCID8gYm9keUIuaW52ZXJzZUluZXJ0aWEgOiAwKSxcbiAgICAgICAgICAgIHJlc2lzdGFuY2VUb3RhbCA9IG1hc3NUb3RhbCArIGluZXJ0aWFUb3RhbCxcbiAgICAgICAgICAgIHRvcnF1ZSxcbiAgICAgICAgICAgIHNoYXJlLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgbm9ybWFsVmVsb2NpdHksXG4gICAgICAgICAgICByZWxhdGl2ZVZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50LmRhbXBpbmcpIHtcbiAgICAgICAgICAgIHZhciB6ZXJvID0gVmVjdG9yLmNyZWF0ZSgpO1xuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLmRpdihkZWx0YSwgY3VycmVudExlbmd0aCk7XG5cbiAgICAgICAgICAgIHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3Iuc3ViKFxuICAgICAgICAgICAgICAgIGJvZHlCICYmIFZlY3Rvci5zdWIoYm9keUIucG9zaXRpb24sIGJvZHlCLnBvc2l0aW9uUHJldikgfHwgemVybyxcbiAgICAgICAgICAgICAgICBib2R5QSAmJiBWZWN0b3Iuc3ViKGJvZHlBLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvblByZXYpIHx8IHplcm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG5vcm1hbFZlbG9jaXR5ID0gVmVjdG9yLmRvdChub3JtYWwsIHJlbGF0aXZlVmVsb2NpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlBICYmICFib2R5QS5pc1N0YXRpYykge1xuICAgICAgICAgICAgc2hhcmUgPSBib2R5QS5pbnZlcnNlTWFzcyAvIG1hc3NUb3RhbDtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBhcHBsaWVkIGltcHVsc2VzIGZvciBwb3N0IHNvbHZpbmdcbiAgICAgICAgICAgIGJvZHlBLmNvbnN0cmFpbnRJbXB1bHNlLnggLT0gZm9yY2UueCAqIHNoYXJlO1xuICAgICAgICAgICAgYm9keUEuY29uc3RyYWludEltcHVsc2UueSAtPSBmb3JjZS55ICogc2hhcmU7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGZvcmNlc1xuICAgICAgICAgICAgYm9keUEucG9zaXRpb24ueCAtPSBmb3JjZS54ICogc2hhcmU7XG4gICAgICAgICAgICBib2R5QS5wb3NpdGlvbi55IC09IGZvcmNlLnkgKiBzaGFyZTtcblxuICAgICAgICAgICAgLy8gYXBwbHkgZGFtcGluZ1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuZGFtcGluZykge1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54IC09IGNvbnN0cmFpbnQuZGFtcGluZyAqIG5vcm1hbC54ICogbm9ybWFsVmVsb2NpdHkgKiBzaGFyZTtcbiAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueSAtPSBjb25zdHJhaW50LmRhbXBpbmcgKiBub3JtYWwueSAqIG5vcm1hbFZlbG9jaXR5ICogc2hhcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRvcnF1ZVxuICAgICAgICAgICAgdG9ycXVlID0gKFZlY3Rvci5jcm9zcyhwb2ludEEsIGZvcmNlKSAvIHJlc2lzdGFuY2VUb3RhbCkgKiBDb25zdHJhaW50Ll90b3JxdWVEYW1wZW4gKiBib2R5QS5pbnZlcnNlSW5lcnRpYSAqICgxIC0gY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzKTtcbiAgICAgICAgICAgIGJvZHlBLmNvbnN0cmFpbnRJbXB1bHNlLmFuZ2xlIC09IHRvcnF1ZTtcbiAgICAgICAgICAgIGJvZHlBLmFuZ2xlIC09IHRvcnF1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5QiAmJiAhYm9keUIuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIHNoYXJlID0gYm9keUIuaW52ZXJzZU1hc3MgLyBtYXNzVG90YWw7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgYXBwbGllZCBpbXB1bHNlcyBmb3IgcG9zdCBzb2x2aW5nXG4gICAgICAgICAgICBib2R5Qi5jb25zdHJhaW50SW1wdWxzZS54ICs9IGZvcmNlLnggKiBzaGFyZTtcbiAgICAgICAgICAgIGJvZHlCLmNvbnN0cmFpbnRJbXB1bHNlLnkgKz0gZm9yY2UueSAqIHNoYXJlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBhcHBseSBmb3JjZXNcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnggKz0gZm9yY2UueCAqIHNoYXJlO1xuICAgICAgICAgICAgYm9keUIucG9zaXRpb24ueSArPSBmb3JjZS55ICogc2hhcmU7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGRhbXBpbmdcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmRhbXBpbmcpIHtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvblByZXYueCArPSBjb25zdHJhaW50LmRhbXBpbmcgKiBub3JtYWwueCAqIG5vcm1hbFZlbG9jaXR5ICogc2hhcmU7XG4gICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnkgKz0gY29uc3RyYWludC5kYW1waW5nICogbm9ybWFsLnkgKiBub3JtYWxWZWxvY2l0eSAqIHNoYXJlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcHBseSB0b3JxdWVcbiAgICAgICAgICAgIHRvcnF1ZSA9IChWZWN0b3IuY3Jvc3MocG9pbnRCLCBmb3JjZSkgLyByZXNpc3RhbmNlVG90YWwpICogQ29uc3RyYWludC5fdG9ycXVlRGFtcGVuICogYm9keUIuaW52ZXJzZUluZXJ0aWEgKiAoMSAtIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyk7XG4gICAgICAgICAgICBib2R5Qi5jb25zdHJhaW50SW1wdWxzZS5hbmdsZSArPSB0b3JxdWU7XG4gICAgICAgICAgICBib2R5Qi5hbmdsZSArPSB0b3JxdWU7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBib2R5IHVwZGF0ZXMgcmVxdWlyZWQgYWZ0ZXIgc29sdmluZyBjb25zdHJhaW50cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcG9zdFNvbHZlQWxsXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIENvbnN0cmFpbnQucG9zdFNvbHZlQWxsID0gZnVuY3Rpb24oYm9kaWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gYm9keS5jb25zdHJhaW50SW1wdWxzZTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMgfHwgKGltcHVsc2UueCA9PT0gMCAmJiBpbXB1bHNlLnkgPT09IDAgJiYgaW1wdWxzZS5hbmdsZSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGdlb21ldHJ5IGFuZCByZXNldFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBpbXB1bHNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gaW1wdWxzZS54O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgKz0gaW1wdWxzZS55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbXB1bHNlLmFuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLnJvdGF0ZShwYXJ0LnZlcnRpY2VzLCBpbXB1bHNlLmFuZ2xlLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBpbXB1bHNlLmFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3Iucm90YXRlQWJvdXQocGFydC5wb3NpdGlvbiwgaW1wdWxzZS5hbmdsZSwgYm9keS5wb3NpdGlvbiwgcGFydC5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGFtcGVuIHRoZSBjYWNoZWQgaW1wdWxzZSBmb3Igd2FybWluZyBuZXh0IHN0ZXBcbiAgICAgICAgICAgIGltcHVsc2UuYW5nbGUgKj0gQ29uc3RyYWludC5fd2FybWluZztcbiAgICAgICAgICAgIGltcHVsc2UueCAqPSBDb25zdHJhaW50Ll93YXJtaW5nO1xuICAgICAgICAgICAgaW1wdWxzZS55ICo9IENvbnN0cmFpbnQuX3dhcm1pbmc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIG51bWJlciBnZW5lcmF0ZWQgaW4gYENvbXBvc2l0ZS5jcmVhdGVgIGJ5IGBDb21tb24ubmV4dElkYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IFwiY29uc3RyYWludFwiXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgYm9kaWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhYmVsXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJDb25zdHJhaW50XCJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgZGVmaW5lcyB0aGUgcmVuZGVyaW5nIHByb3BlcnRpZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhlIG1vZHVsZSBgTWF0dGVyLlJlbmRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci52aXNpYmxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBsaW5lIHdpZHRoIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgY29uc3RyYWludCBvdXRsaW5lLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIG5vIG91dGxpbmUgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIubGluZVdpZHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGNvbnN0cmFpbnQgb3V0bGluZS5cbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnN0cm9rZVN0eWxlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgYSByYW5kb20gY29sb3VyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgY29uc3RyYWludCByZW5kZXJpbmcgdHlwZS4gXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmUgJ2xpbmUnLCAncGluJywgJ3NwcmluZycuXG4gICAgICogQW4gYXBwcm9wcmlhdGUgcmVuZGVyIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNob3NlbiB1bmxlc3Mgb25lIGlzIGdpdmVuIGluIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnR5cGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAnbGluZSdcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvb2xlYW5gIHRoYXQgZGVmaW5lcyBpZiB0aGUgY29uc3RyYWludCdzIGFuY2hvciBwb2ludHMgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5hbmNob3JzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBwb3NzaWJsZSBgQm9keWAgdGhhdCB0aGlzIGNvbnN0cmFpbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSBib2R5XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCBwb3NzaWJsZSBgQm9keWAgdGhhdCB0aGlzIGNvbnN0cmFpbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSBib2R5XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBjb25zdHJhaW50IGZyb20gY2VudGVyIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QWAgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGEgd29ybGQtc3BhY2UgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9pbnRBXG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgY29uc3RyYWludCBmcm9tIGNlbnRlciBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUJgIGlmIGRlZmluZWQsIG90aGVyd2lzZSBhIHdvcmxkLXNwYWNlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvaW50QlxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBzdGlmZm5lc3Mgb2YgdGhlIGNvbnN0cmFpbnQsIGkuZS4gdGhlIHJhdGUgYXQgd2hpY2ggaXQgcmV0dXJucyB0byBpdHMgcmVzdGluZyBgY29uc3RyYWludC5sZW5ndGhgLlxuICAgICAqIEEgdmFsdWUgb2YgYDFgIG1lYW5zIHRoZSBjb25zdHJhaW50IHNob3VsZCBiZSB2ZXJ5IHN0aWZmLlxuICAgICAqIEEgdmFsdWUgb2YgYDAuMmAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgYWN0cyBsaWtlIGEgc29mdCBzcHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgZGFtcGluZyBvZiB0aGUgY29uc3RyYWludCwgXG4gICAgICogaS5lLiB0aGUgYW1vdW50IG9mIHJlc2lzdGFuY2UgYXBwbGllZCB0byBlYWNoIGJvZHkgYmFzZWQgb24gdGhlaXIgdmVsb2NpdGllcyB0byBsaW1pdCB0aGUgYW1vdW50IG9mIG9zY2lsbGF0aW9uLlxuICAgICAqIERhbXBpbmcgd2lsbCBvbmx5IGJlIGFwcGFyZW50IHdoZW4gdGhlIGNvbnN0cmFpbnQgYWxzbyBoYXMgYSB2ZXJ5IGxvdyBgc3RpZmZuZXNzYC5cbiAgICAgKiBBIHZhbHVlIG9mIGAwLjFgIG1lYW5zIHRoZSBjb25zdHJhaW50IHdpbGwgYXBwbHkgaGVhdnkgZGFtcGluZywgcmVzdWx0aW5nIGluIGxpdHRsZSB0byBubyBvc2NpbGxhdGlvbi5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGUgY29uc3RyYWludCB3aWxsIGFwcGx5IG5vIGRhbXBpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXN0aW5nIGxlbmd0aCBvZiB0aGUgY29uc3RyYWludC4gXG4gICAgICogSXQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGluIGBDb25zdHJhaW50LmNyZWF0ZWAgZnJvbSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGFuZCBgY29uc3RyYWludC5ib2R5QmAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGVuZ3RoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVzZXJ2ZWQgZm9yIHN0b3JpbmcgcGx1Z2luLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxufSkoKTtcblxufSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9TbGVlcGluZ1wiOjIyLFwiLi4vZ2VvbWV0cnkvQXhlc1wiOjI1LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyOCxcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6Mjl9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuTW91c2VDb25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgbW91c2UgY29uc3RyYWludHMuXG4qIE1vdXNlIGNvbnN0cmFpbnRzIGFyZSB1c2VkIGZvciBhbGxvd2luZyB1c2VyIGludGVyYWN0aW9uLCBwcm92aWRpbmcgdGhlIGFiaWxpdHkgdG8gbW92ZSBib2RpZXMgdmlhIHRoZSBtb3VzZSBvciB0b3VjaC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIE1vdXNlQ29uc3RyYWludFxuKi9cblxudmFyIE1vdXNlQ29uc3RyYWludCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlQ29uc3RyYWludDtcblxudmFyIFZlcnRpY2VzID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcbnZhciBTbGVlcGluZyA9IF9kZXJlcV8oJy4uL2NvcmUvU2xlZXBpbmcnKTtcbnZhciBNb3VzZSA9IF9kZXJlcV8oJy4uL2NvcmUvTW91c2UnKTtcbnZhciBFdmVudHMgPSBfZGVyZXFfKCcuLi9jb3JlL0V2ZW50cycpO1xudmFyIERldGVjdG9yID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0RldGVjdG9yJyk7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xudmFyIENvbXBvc2l0ZSA9IF9kZXJlcV8oJy4uL2JvZHkvQ29tcG9zaXRlJyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcbnZhciBCb3VuZHMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtb3VzZSBjb25zdHJhaW50LlxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge01vdXNlQ29uc3RyYWludH0gQSBuZXcgTW91c2VDb25zdHJhaW50XG4gICAgICovXG4gICAgTW91c2VDb25zdHJhaW50LmNyZWF0ZSA9IGZ1bmN0aW9uKGVuZ2luZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW91c2UgPSAoZW5naW5lID8gZW5naW5lLm1vdXNlIDogbnVsbCkgfHwgKG9wdGlvbnMgPyBvcHRpb25zLm1vdXNlIDogbnVsbCk7XG5cbiAgICAgICAgaWYgKCFtb3VzZSkge1xuICAgICAgICAgICAgaWYgKGVuZ2luZSAmJiBlbmdpbmUucmVuZGVyICYmIGVuZ2luZS5yZW5kZXIuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUoZW5naW5lLnJlbmRlci5jYW52YXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKG9wdGlvbnMuZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ01vdXNlQ29uc3RyYWludC5jcmVhdGU6IG9wdGlvbnMubW91c2Ugd2FzIHVuZGVmaW5lZCwgb3B0aW9ucy5lbGVtZW50IHdhcyB1bmRlZmluZWQsIG1heSBub3QgZnVuY3Rpb24gYXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gQ29uc3RyYWludC5jcmVhdGUoeyBcbiAgICAgICAgICAgIGxhYmVsOiAnTW91c2UgQ29uc3RyYWludCcsXG4gICAgICAgICAgICBwb2ludEE6IG1vdXNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9pbnRCOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogMC4wMSwgXG4gICAgICAgICAgICBzdGlmZm5lc3M6IDAuMSxcbiAgICAgICAgICAgIGFuZ3VsYXJTdGlmZm5lc3M6IDEsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJyM5MEVFOTAnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogM1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnbW91c2VDb25zdHJhaW50JyxcbiAgICAgICAgICAgIG1vdXNlOiBtb3VzZSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXG4gICAgICAgICAgICAgICAgbWFzazogMHhGRkZGRkZGRixcbiAgICAgICAgICAgICAgICBncm91cDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3VzZUNvbnN0cmFpbnQgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBFdmVudHMub24oZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWxsQm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhlbmdpbmUud29ybGQpO1xuICAgICAgICAgICAgTW91c2VDb25zdHJhaW50LnVwZGF0ZShtb3VzZUNvbnN0cmFpbnQsIGFsbEJvZGllcyk7XG4gICAgICAgICAgICBNb3VzZUNvbnN0cmFpbnQuX3RyaWdnZXJFdmVudHMobW91c2VDb25zdHJhaW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vdXNlQ29uc3RyYWludDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gbW91c2UgY29uc3RyYWludC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUNvbnN0cmFpbnR9IG1vdXNlQ29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQudXBkYXRlID0gZnVuY3Rpb24obW91c2VDb25zdHJhaW50LCBib2RpZXMpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxuICAgICAgICAgICAgY29uc3RyYWludCA9IG1vdXNlQ29uc3RyYWludC5jb25zdHJhaW50LFxuICAgICAgICAgICAgYm9keSA9IG1vdXNlQ29uc3RyYWludC5ib2R5O1xuXG4gICAgICAgIGlmIChtb3VzZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIGlmICghY29uc3RyYWludC5ib2R5Qikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMoYm9keS5ib3VuZHMsIG1vdXNlLnBvc2l0aW9uKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBEZXRlY3Rvci5jYW5Db2xsaWRlKGJvZHkuY29sbGlzaW9uRmlsdGVyLCBtb3VzZUNvbnN0cmFpbnQuY29sbGlzaW9uRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0gbW91c2UucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYm9keUIgPSBtb3VzZUNvbnN0cmFpbnQuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0geyB4OiBtb3VzZS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBtb3VzZS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYW5nbGVCID0gYm9keS5hbmdsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdzdGFydGRyYWcnLCB7IG1vdXNlOiBtb3VzZSwgYm9keTogYm9keSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChjb25zdHJhaW50LmJvZHlCLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSBtb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQuYm9keUIgPSBtb3VzZUNvbnN0cmFpbnQuYm9keSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ2VuZGRyYWcnLCB7IG1vdXNlOiBtb3VzZSwgYm9keTogYm9keSB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBtb3VzZSBjb25zdHJhaW50IGV2ZW50cy5cbiAgICAgKiBAbWV0aG9kIF90cmlnZ2VyRXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZUNvbnN0cmFpbnRcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQuX3RyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihtb3VzZUNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxuICAgICAgICAgICAgbW91c2VFdmVudHMgPSBtb3VzZS5zb3VyY2VFdmVudHM7XG5cbiAgICAgICAgaWYgKG1vdXNlRXZlbnRzLm1vdXNlbW92ZSlcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ21vdXNlbW92ZScsIHsgbW91c2U6IG1vdXNlIH0pO1xuXG4gICAgICAgIGlmIChtb3VzZUV2ZW50cy5tb3VzZWRvd24pXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZWRvd24nLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICBpZiAobW91c2VFdmVudHMubW91c2V1cClcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ21vdXNldXAnLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICAvLyByZXNldCB0aGUgbW91c2Ugc3RhdGUgcmVhZHkgZm9yIHRoZSBuZXh0IHN0ZXBcbiAgICAgICAgTW91c2UuY2xlYXJTb3VyY2VFdmVudHMobW91c2UpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBoYXMgbW92ZWQgKG9yIGEgdG91Y2ggbW92ZXMpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNlbW92ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgZG93biAob3IgYSB0b3VjaCBoYXMgc3RhcnRlZCkgZHVyaW5nIHRoZSBsYXN0IHN0ZXBcbiAgICAqXG4gICAgKiBAZXZlbnQgbW91c2Vkb3duXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBpcyB1cCAob3IgYSB0b3VjaCBoYXMgZW5kZWQpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNldXBcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIGEgYm9keVxuICAgICpcbiAgICAqIEBldmVudCBzdGFydGRyYWdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtib2R5fSBldmVudC5ib2R5IFRoZSBib2R5IGJlaW5nIGRyYWdnZWRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGVuZHMgZHJhZ2dpbmcgYSBib2R5XG4gICAgKlxuICAgICogQGV2ZW50IGVuZGRyYWdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtib2R5fSBldmVudC5ib2R5IFRoZSBib2R5IHRoYXQgaGFzIHN0b3BwZWQgYmVpbmcgZHJhZ2dlZFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgZGVub3RpbmcgdGhlIHR5cGUgb2Ygb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcImNvbnN0cmFpbnRcIlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBNb3VzZWAgaW5zdGFuY2UgaW4gdXNlLiBJZiBub3Qgc3VwcGxpZWQgaW4gYE1vdXNlQ29uc3RyYWludC5jcmVhdGVgLCBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1vdXNlXG4gICAgICogQHR5cGUgbW91c2VcbiAgICAgKiBAZGVmYXVsdCBtb3VzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBCb2R5YCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBtb3ZlZCBieSB0aGUgdXNlciwgb3IgYG51bGxgIGlmIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9keVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYENvbnN0cmFpbnRgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gbW92ZSB0aGUgYm9keSBkdXJpbmcgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludFxuICAgICAqIEB0eXBlIGNvbnN0cmFpbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZmlsdGVyIHByb3BlcnRpZXMuXG4gICAgICogVGhlIGNvbGxpc2lvbiBmaWx0ZXIgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSB3aGljaCB0eXBlcyBvZiBib2R5IHRoaXMgbW91c2UgY29uc3RyYWludCBjYW4gaW50ZXJhY3Qgd2l0aC5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXJcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxufSkoKTtcblxufSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuLi9jb2xsaXNpb24vRGV0ZWN0b3JcIjo1LFwiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuLi9jb3JlL01vdXNlXCI6MTksXCIuLi9jb3JlL1NsZWVwaW5nXCI6MjIsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6MjksXCIuL0NvbnN0cmFpbnRcIjoxMn1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5Db21tb25gIG1vZHVsZSBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGFyZSBjb21tb24gdG8gYWxsIG1vZHVsZXMuXG4qXG4qIEBjbGFzcyBDb21tb25cbiovXG5cbnZhciBDb21tb24gPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tb247XG5cbihmdW5jdGlvbigpIHtcblxuICAgIENvbW1vbi5fbmV4dElkID0gMDtcbiAgICBDb21tb24uX3NlZWQgPSAwO1xuICAgIENvbW1vbi5fbm93U3RhcnRUaW1lID0gKyhuZXcgRGF0ZSgpKTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZHMgdGhlIG9iamVjdCBpbiB0aGUgZmlyc3QgYXJndW1lbnQgdXNpbmcgdGhlIG9iamVjdCBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICogQHBhcmFtIHt9IG9ialxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcFxuICAgICAqIEByZXR1cm4ge30gb2JqIGV4dGVuZGVkXG4gICAgICovXG4gICAgQ29tbW9uLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaiwgZGVlcCkge1xuICAgICAgICB2YXIgYXJnc1N0YXJ0LFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIGRlZXBDbG9uZTtcblxuICAgICAgICBpZiAodHlwZW9mIGRlZXAgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgYXJnc1N0YXJ0ID0gMjtcbiAgICAgICAgICAgIGRlZXBDbG9uZSA9IGRlZXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzU3RhcnQgPSAxO1xuICAgICAgICAgICAgZGVlcENsb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBhcmdzU3RhcnQ7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcENsb25lICYmIHNvdXJjZVtwcm9wXSAmJiBzb3VyY2VbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmpbcHJvcF0gfHwgb2JqW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBvYmpbcHJvcF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmV4dGVuZChvYmpbcHJvcF0sIGRlZXBDbG9uZSwgc291cmNlW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsb25lIG9mIHRoZSBvYmplY3QsIGlmIGRlZXAgaXMgdHJ1ZSByZWZlcmVuY2VzIHdpbGwgYWxzbyBiZSBjbG9uZWQuXG4gICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAqIEBwYXJhbSB7fSBvYmpcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGRlZXBcbiAgICAgKiBAcmV0dXJuIHt9IG9iaiBjbG9uZWRcbiAgICAgKi9cbiAgICBDb21tb24uY2xvbmUgPSBmdW5jdGlvbihvYmosIGRlZXApIHtcbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoe30sIGRlZXAsIG9iaik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGtleXNcbiAgICAgKiBAcGFyYW0ge30gb2JqXG4gICAgICogQHJldHVybiB7c3RyaW5nW119IGtleXNcbiAgICAgKi9cbiAgICBDb21tb24ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcblxuICAgICAgICAvLyBhdm9pZCBoYXNPd25Qcm9wZXJ0eSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge30gb2JqXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHRoZSBvYmplY3RzIHByb3BlcnR5IHZhbHVlc1xuICAgICAqL1xuICAgIENvbW1vbi52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gYXZvaWQgaGFzT3duUHJvcGVydHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChvYmpba2V5XSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIGBiYXNlYCByZWxhdGl2ZSB0byB0aGUgYHBhdGhgIHN0cmluZy5cbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7fSBvYmogVGhlIGJhc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgLCBlLmcuICdGb28uQmFyLmJheidcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luXSBQYXRoIHNsaWNlIGJlZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIFBhdGggc2xpY2UgZW5kXG4gICAgICogQHJldHVybiB7fSBUaGUgb2JqZWN0IGF0IHRoZSBnaXZlbiBwYXRoXG4gICAgICovXG4gICAgQ29tbW9uLmdldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgYmVnaW4sIGVuZCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpLnNsaWNlKGJlZ2luLCBlbmQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2JqID0gb2JqW3BhdGhbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIG9uIGBiYXNlYCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gYHBhdGhgIHN0cmluZy5cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7fSBvYmogVGhlIGJhc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgLCBlLmcuICdGb28uQmFyLmJheidcbiAgICAgKiBAcGFyYW0ge30gdmFsIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luXSBQYXRoIHNsaWNlIGJlZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIFBhdGggc2xpY2UgZW5kXG4gICAgICogQHJldHVybiB7fSBQYXNzIHRocm91Z2ggYHZhbGAgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgQ29tbW9uLnNldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgdmFsLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKS5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgQ29tbW9uLmdldChvYmosIHBhdGgsIDAsIC0xKVtwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXV0gPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZS5cbiAgICAgKiBUaGUgZnVuY3Rpb24gdXNlcyBhIHNlZWRlZCByYW5kb20gZ2VuZXJhdG9yLlxuICAgICAqIEBtZXRob2Qgc2h1ZmZsZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybiB7YXJyYXl9IGFycmF5IHNodWZmbGVkIHJhbmRvbWx5XG4gICAgICovXG4gICAgQ29tbW9uLnNodWZmbGUgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKENvbW1vbi5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgICAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSYW5kb21seSBjaG9vc2VzIGEgdmFsdWUgZnJvbSBhIGxpc3Qgd2l0aCBlcXVhbCBwcm9iYWJpbGl0eS5cbiAgICAgKiBUaGUgZnVuY3Rpb24gdXNlcyBhIHNlZWRlZCByYW5kb20gZ2VuZXJhdG9yLlxuICAgICAqIEBtZXRob2QgY2hvb3NlXG4gICAgICogQHBhcmFtIHthcnJheX0gY2hvaWNlc1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSByYW5kb20gY2hvaWNlIG9iamVjdCBmcm9tIHRoZSBhcnJheVxuICAgICAqL1xuICAgIENvbW1vbi5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzKSB7XG4gICAgICAgIHJldHVybiBjaG9pY2VzW01hdGguZmxvb3IoQ29tbW9uLnJhbmRvbSgpICogY2hvaWNlcy5sZW5ndGgpXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqIEBtZXRob2QgaXNFbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEhUTUxFbGVtZW50LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBDb21tb24uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSAmJiBvYmoubm9kZU5hbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBhcnJheS5cbiAgICAgKiBAbWV0aG9kIGlzQXJyYXlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBDb21tb24uaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgZnVuY3Rpb24uXG4gICAgICogQG1ldGhvZCBpc0Z1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBDb21tb24uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHBsYWluIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGlzUGxhaW5PYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBDb21tb24uaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nLlxuICAgICAqIEBtZXRob2QgaXNTdHJpbmdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBDb21tb24uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZSBjbGFtcGVkIGJldHdlZW4gYSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBtZXRob2QgY2xhbXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGNsYW1wZWQgYmV0d2VlbiBtaW4gYW5kIG1heCBpbmNsdXNpdmVcbiAgICAgKi9cbiAgICBDb21tb24uY2xhbXAgPSBmdW5jdGlvbih2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICogQG1ldGhvZCBzaWduXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSBpZiBuZWdhdGl2ZSwgKzEgaWYgMCBvciBwb3NpdGl2ZVxuICAgICAqL1xuICAgIENvbW1vbi5zaWduID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IC0xIDogMTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZXN0YW1wIHNpbmNlIHRoZSB0aW1lIG9yaWdpbiAoZS5nLiBmcm9tIHBhZ2UgbG9hZCkuXG4gICAgICogVGhlIHJlc3VsdCB3aWxsIGJlIGhpZ2gtcmVzb2x1dGlvbiBpbmNsdWRpbmcgZGVjaW1hbCBwbGFjZXMgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgbm93XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBDb21tb24ubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LnBlcmZvcm1hbmNlLndlYmtpdE5vdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uud2Via2l0Tm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCkpIC0gQ29tbW9uLl9ub3dTdGFydFRpbWU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gYSBtaW5pbXVtIGFuZCBhIG1heGltdW0gdmFsdWUgaW5jbHVzaXZlLlxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VzIGEgc2VlZGVkIHJhbmRvbSBnZW5lcmF0b3IuXG4gICAgICogQG1ldGhvZCByYW5kb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXggaW5jbHVzaXZlXG4gICAgICovXG4gICAgQ29tbW9uLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgIG1pbiA9ICh0eXBlb2YgbWluICE9PSBcInVuZGVmaW5lZFwiKSA/IG1pbiA6IDA7XG4gICAgICAgIG1heCA9ICh0eXBlb2YgbWF4ICE9PSBcInVuZGVmaW5lZFwiKSA/IG1heCA6IDE7XG4gICAgICAgIHJldHVybiBtaW4gKyBfc2VlZGVkUmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgICB9O1xuXG4gICAgdmFyIF9zZWVkZWRSYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2NvbmdydWVudGlhbF9nZW5lcmF0b3JcbiAgICAgICAgQ29tbW9uLl9zZWVkID0gKENvbW1vbi5fc2VlZCAqIDkzMDEgKyA0OTI5NykgJSAyMzMyODA7XG4gICAgICAgIHJldHVybiBDb21tb24uX3NlZWQgLyAyMzMyODA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgQ1NTIGhleCBjb2xvdXIgc3RyaW5nIGludG8gYW4gaW50ZWdlci5cbiAgICAgKiBAbWV0aG9kIGNvbG9yVG9OdW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBDU1MgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIENvbW1vbi5jb2xvclRvTnVtYmVyID0gZnVuY3Rpb24oY29sb3JTdHJpbmcpIHtcbiAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5yZXBsYWNlKCcjJywnJyk7XG5cbiAgICAgICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLmNoYXJBdCgwKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb2xvclN0cmluZy5jaGFyQXQoMSkgKyBjb2xvclN0cmluZy5jaGFyQXQoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3JTdHJpbmcuY2hhckF0KDIpICsgY29sb3JTdHJpbmcuY2hhckF0KDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zb2xlIGxvZ2dpbmcgbGV2ZWwgdG8gdXNlLCB3aGVyZSBlYWNoIGxldmVsIGluY2x1ZGVzIGFsbCBsZXZlbHMgYWJvdmUgYW5kIGV4Y2x1ZGVzIHRoZSBsZXZlbHMgYmVsb3cuXG4gICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgaXMgJ2RlYnVnJyB3aGljaCBzaG93cyBhbGwgY29uc29sZSBtZXNzYWdlcy4gIFxuICAgICAqXG4gICAgICogUG9zc2libGUgbGV2ZWwgdmFsdWVzIGFyZTpcbiAgICAgKiAtIDAgPSBOb25lXG4gICAgICogLSAxID0gRGVidWdcbiAgICAgKiAtIDIgPSBJbmZvXG4gICAgICogLSAzID0gV2FyblxuICAgICAqIC0gNCA9IEVycm9yXG4gICAgICogQHByb3BlcnR5IENvbW1vbi5sb2dMZXZlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIENvbW1vbi5sb2dMZXZlbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLmxvZ2AgbWVzc2FnZSBvbmx5IGlmIHRoZSBjdXJyZW50IGBDb21tb24ubG9nTGV2ZWxgIGFsbG93cyBpdC5cbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggJ21hdHRlci1qcycgdG8gbWFrZSBpdCBlYXNpbHkgaWRlbnRpZmlhYmxlLlxuICAgICAqIEBtZXRob2QgbG9nXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgWydtYXR0ZXItanM6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLmluZm9gIG1lc3NhZ2Ugb25seSBpZiB0aGUgY3VycmVudCBgQ29tbW9uLmxvZ0xldmVsYCBhbGxvd3MgaXQuXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBwcmVmaXhlZCB3aXRoICdtYXR0ZXItanMnIHRvIG1ha2UgaXQgZWFzaWx5IGlkZW50aWZpYWJsZS5cbiAgICAgKiBAbWV0aG9kIGluZm9cbiAgICAgKiBAcGFyYW0gLi4ub2JqcyB7fSBUaGUgb2JqZWN0cyB0byBsb2cuXG4gICAgICovXG4gICAgQ29tbW9uLmluZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIFsnbWF0dGVyLWpzOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBgY29uc29sZS53YXJuYCBtZXNzYWdlIG9ubHkgaWYgdGhlIGN1cnJlbnQgYENvbW1vbi5sb2dMZXZlbGAgYWxsb3dzIGl0LlxuICAgICAqIFRoZSBtZXNzYWdlIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCAnbWF0dGVyLWpzJyB0byBtYWtlIGl0IGVhc2lseSBpZGVudGlmaWFibGUuXG4gICAgICogQG1ldGhvZCB3YXJuXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi53YXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbJ21hdHRlci1qczonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIHNlcXVlbnRpYWwgSUQuXG4gICAgICogQG1ldGhvZCBuZXh0SWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBzZXF1ZW50aWFsIElEXG4gICAgICovXG4gICAgQ29tbW9uLm5leHRJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ29tbW9uLl9uZXh0SWQrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBjcm9zcyBicm93c2VyIGNvbXBhdGlibGUgaW5kZXhPZiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAbWV0aG9kIGluZGV4T2ZcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBoYXlzdGFja1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZWVkbGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiBuZWVkbGUgaW4gaGF5c3RhY2ssIG90aGVyd2lzZSAtMS5cbiAgICAgKi9cbiAgICBDb21tb24uaW5kZXhPZiA9IGZ1bmN0aW9uKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKGhheXN0YWNrLmluZGV4T2YpXG4gICAgICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChoYXlzdGFja1tpXSA9PT0gbmVlZGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGNyb3NzIGJyb3dzZXIgY29tcGF0aWJsZSBhcnJheSBtYXAgaW1wbGVtZW50YXRpb24uXG4gICAgICogQG1ldGhvZCBtYXBcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBsaXN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge2FycmF5fSBWYWx1ZXMgZnJvbSBsaXN0IHRyYW5zZm9ybWVkIGJ5IGZ1bmMuXG4gICAgICovXG4gICAgQ29tbW9uLm1hcCA9IGZ1bmN0aW9uKGxpc3QsIGZ1bmMpIHtcbiAgICAgICAgaWYgKGxpc3QubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5tYXAoZnVuYyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFwcGVkID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBtYXBwZWQucHVzaChmdW5jKGxpc3RbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZGlyZWN0ZWQgZ3JhcGggYW5kIHJldHVybnMgdGhlIHBhcnRpYWxseSBvcmRlcmVkIHNldCBvZiB2ZXJ0aWNlcyBpbiB0b3BvbG9naWNhbCBvcmRlci5cbiAgICAgKiBDaXJjdWxhciBkZXBlbmRlbmNpZXMgYXJlIGFsbG93ZWQuXG4gICAgICogQG1ldGhvZCB0b3BvbG9naWNhbFNvcnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gUGFydGlhbGx5IG9yZGVyZWQgc2V0IG9mIHZlcnRpY2VzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxuICAgICAqL1xuICAgIENvbW1vbi50b3BvbG9naWNhbFNvcnQgPSBmdW5jdGlvbihncmFwaCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWdlY2hldi9qYXZhc2NyaXB0LWFsZ29yaXRobXNcbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSBNaW5rbyBHZWNoZXYgKE1JVCBsaWNlbnNlKVxuICAgICAgICAvLyBNb2RpZmljYXRpb25zOiB0aWR5IGZvcm1hdHRpbmcgYW5kIG5hbWluZ1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB2aXNpdGVkID0gW10sXG4gICAgICAgICAgICB0ZW1wID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZSBpbiBncmFwaCkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW25vZGVdICYmICF0ZW1wW25vZGVdKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLl90b3BvbG9naWNhbFNvcnQobm9kZSwgdmlzaXRlZCwgdGVtcCwgZ3JhcGgsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb21tb24uX3RvcG9sb2dpY2FsU29ydCA9IGZ1bmN0aW9uKG5vZGUsIHZpc2l0ZWQsIHRlbXAsIGdyYXBoLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoW25vZGVdIHx8IFtdO1xuICAgICAgICB0ZW1wW25vZGVdID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICBpZiAodGVtcFtuZWlnaGJvcl0pIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbmVpZ2hib3JdKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLl90b3BvbG9naWNhbFNvcnQobmVpZ2hib3IsIHZpc2l0ZWQsIHRlbXAsIGdyYXBoLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGVtcFtub2RlXSA9IGZhbHNlO1xuICAgICAgICB2aXNpdGVkW25vZGVdID0gdHJ1ZTtcblxuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgX25fIGZ1bmN0aW9ucyBhcyBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGVtIGluIG9yZGVyLlxuICAgICAqIFRoZSBhcmd1bWVudHMgYXBwbGllZCB3aGVuIGNhbGxpbmcgdGhlIG5ldyBmdW5jdGlvbiB3aWxsIGFsc28gYmUgYXBwbGllZCB0byBldmVyeSBmdW5jdGlvbiBwYXNzZWQuXG4gICAgICogVGhlIHZhbHVlIG9mIGB0aGlzYCByZWZlcnMgdG8gdGhlIGxhc3QgdmFsdWUgcmV0dXJuZWQgaW4gdGhlIGNoYWluIHRoYXQgd2FzIG5vdCBgdW5kZWZpbmVkYC5cbiAgICAgKiBUaGVyZWZvcmUgaWYgYSBwYXNzZWQgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUsIHRoZSBwcmV2aW91c2x5IHJldHVybmVkIHZhbHVlIGlzIG1haW50YWluZWQuXG4gICAgICogQWZ0ZXIgYWxsIHBhc3NlZCBmdW5jdGlvbnMgaGF2ZSBiZWVuIGNhbGxlZCB0aGUgbmV3IGZ1bmN0aW9uIHJldHVybnMgdGhlIGxhc3QgcmV0dXJuZWQgdmFsdWUgKGlmIGFueSkuXG4gICAgICogSWYgYW55IG9mIHRoZSBwYXNzZWQgZnVuY3Rpb25zIGFyZSBhIGNoYWluLCB0aGVuIHRoZSBjaGFpbiB3aWxsIGJlIGZsYXR0ZW5lZC5cbiAgICAgKiBAbWV0aG9kIGNoYWluXG4gICAgICogQHBhcmFtIC4uLmZ1bmNzIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9ucyB0byBjaGFpbi5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcGFzc2VkIGZ1bmN0aW9ucyBpbiBvcmRlci5cbiAgICAgKi9cbiAgICBDb21tb24uY2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZ1bmNzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZnVuYy5fY2hhaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gYWxyZWFkeSBjaGFpbmVkIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgIGZ1bmNzLnB1c2guYXBwbHkoZnVuY3MsIGZ1bmMuX2NoYWluZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdW5jcy5wdXNoKGZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL2RldnRvb2xzLWRvY3MvaXNzdWVzLzUzI2lzc3VlY29tbWVudC01MTk0MTM1OFxuICAgICAgICAgICAgdmFyIGxhc3RSZXN1bHQsXG4gICAgICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmNzW2ldLmFwcGx5KGxhc3RSZXN1bHQsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjaGFpbi5fY2hhaW5lZCA9IGZ1bmNzO1xuXG4gICAgICAgIHJldHVybiBjaGFpbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGJlZm9yZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgYmFzZWAuXG4gICAgICogU2VlIGFsc28gZG9jcyBmb3IgYENvbW1vbi5jaGFpbmAuXG4gICAgICogQG1ldGhvZCBjaGFpblBhdGhCZWZvcmVcbiAgICAgKiBAcGFyYW0ge30gYmFzZSBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBiZWZvcmUgdGhlIG9yaWdpbmFsXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXG4gICAgICovXG4gICAgQ29tbW9uLmNoYWluUGF0aEJlZm9yZSA9IGZ1bmN0aW9uKGJhc2UsIHBhdGgsIGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIENvbW1vbi5zZXQoYmFzZSwgcGF0aCwgQ29tbW9uLmNoYWluKFxuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgICAgIENvbW1vbi5nZXQoYmFzZSwgcGF0aClcbiAgICAgICAgKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBhZnRlciB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgYmFzZWAuXG4gICAgICogU2VlIGFsc28gZG9jcyBmb3IgYENvbW1vbi5jaGFpbmAuXG4gICAgICogQG1ldGhvZCBjaGFpblBhdGhBZnRlclxuICAgICAqIEBwYXJhbSB7fSBiYXNlIFRoZSBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoYWluIGFmdGVyIHRoZSBvcmlnaW5hbFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgY2hhaW5lZCBmdW5jdGlvbiB0aGF0IHJlcGxhY2VkIHRoZSBvcmlnaW5hbFxuICAgICAqL1xuICAgIENvbW1vbi5jaGFpblBhdGhBZnRlciA9IGZ1bmN0aW9uKGJhc2UsIHBhdGgsIGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIENvbW1vbi5zZXQoYmFzZSwgcGF0aCwgQ29tbW9uLmNoYWluKFxuICAgICAgICAgICAgQ29tbW9uLmdldChiYXNlLCBwYXRoKSxcbiAgICAgICAgICAgIGZ1bmNcbiAgICAgICAgKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVxdWlyZSBleHRlcm5hbCBsaWJyYXJpZXMgb3V0c2lkZSBvZiB0aGUgYnVuZGxlLlxuICAgICAqIEl0IGZpcnN0IGxvb2tzIGZvciB0aGUgYGdsb2JhbE5hbWVgIG9uIHRoZSBlbnZpcm9ubWVudCdzIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICogSWYgdGhlIGdsb2JhbCBpcyBub3QgZm91bmQsIGl0IHdpbGwgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBzdGFuZGFyZCBgcmVxdWlyZWAgdXNpbmcgdGhlIGBtb2R1bGVOYW1lYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgX3JlcXVpcmVHbG9iYWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ2xvYmFsTmFtZSBUaGUgZ2xvYmFsIG1vZHVsZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgVGhlIGZhbGxiYWNrIENvbW1vbkpTIG1vZHVsZSBuYW1lXG4gICAgICogQHJldHVybiB7fSBUaGUgbG9hZGVkIG1vZHVsZVxuICAgICAqL1xuICAgIENvbW1vbi5fcmVxdWlyZUdsb2JhbCA9IGZ1bmN0aW9uKGdsb2JhbE5hbWUsIG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdmFyIG9iaiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1tnbG9iYWxOYW1lXSA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsW2dsb2JhbE5hbWVdIDogbnVsbCk7XG4gICAgICAgIHJldHVybiBvYmogfHwgX2RlcmVxXyhtb2R1bGVOYW1lKTtcbiAgICB9O1xufSkoKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuRW5naW5lYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBlbmdpbmVzLlxuKiBBbiBlbmdpbmUgaXMgYSBjb250cm9sbGVyIHRoYXQgbWFuYWdlcyB1cGRhdGluZyB0aGUgc2ltdWxhdGlvbiBvZiB0aGUgd29ybGQuXG4qIFNlZSBgTWF0dGVyLlJ1bm5lcmAgZm9yIGFuIG9wdGlvbmFsIGdhbWUgbG9vcCB1dGlsaXR5LlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgRW5naW5lXG4qL1xuXG52YXIgRW5naW5lID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gRW5naW5lO1xuXG52YXIgV29ybGQgPSBfZGVyZXFfKCcuLi9ib2R5L1dvcmxkJyk7XG52YXIgU2xlZXBpbmcgPSBfZGVyZXFfKCcuL1NsZWVwaW5nJyk7XG52YXIgUmVzb2x2ZXIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmVzb2x2ZXInKTtcbnZhciBSZW5kZXIgPSBfZGVyZXFfKCcuLi9yZW5kZXIvUmVuZGVyJyk7XG52YXIgUGFpcnMgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUGFpcnMnKTtcbnZhciBNZXRyaWNzID0gX2RlcmVxXygnLi9NZXRyaWNzJyk7XG52YXIgR3JpZCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9HcmlkJyk7XG52YXIgRXZlbnRzID0gX2RlcmVxXygnLi9FdmVudHMnKTtcbnZhciBDb21wb3NpdGUgPSBfZGVyZXFfKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50L0NvbnN0cmFpbnQnKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuL0NvbW1vbicpO1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9ib2R5L0JvZHknKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBlbmdpbmUuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqL1xuICAgIEVuZ2luZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgbWF5IGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgKGFuZCBvbmx5KSBhcmd1bWVudFxuICAgICAgICBvcHRpb25zID0gQ29tbW9uLmlzRWxlbWVudChlbGVtZW50KSA/IG9wdGlvbnMgOiBlbGVtZW50O1xuICAgICAgICBlbGVtZW50ID0gQ29tbW9uLmlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBudWxsO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoZWxlbWVudCB8fCBvcHRpb25zLnJlbmRlcikge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ0VuZ2luZS5jcmVhdGU6IGVuZ2luZS5yZW5kZXIgaXMgZGVwcmVjYXRlZCAoc2VlIGRvY3MpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbkl0ZXJhdGlvbnM6IDYsXG4gICAgICAgICAgICB2ZWxvY2l0eUl0ZXJhdGlvbnM6IDQsXG4gICAgICAgICAgICBjb25zdHJhaW50SXRlcmF0aW9uczogMixcbiAgICAgICAgICAgIGVuYWJsZVNsZWVwaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBwbHVnaW46IHt9LFxuICAgICAgICAgICAgdGltaW5nOiB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJyb2FkcGhhc2U6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBHcmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVuZ2luZSA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXG4gICAgICAgIGlmIChlbGVtZW50IHx8IGVuZ2luZS5yZW5kZXIpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJEZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlbmRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZW5naW5lLnJlbmRlciA9IENvbW1vbi5leHRlbmQocmVuZGVyRGVmYXVsdHMsIGVuZ2luZS5yZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAgICAgaWYgKGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBlbmdpbmUucmVuZGVyID0gZW5naW5lLnJlbmRlci5jb250cm9sbGVyLmNyZWF0ZShlbmdpbmUucmVuZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXG4gICAgICAgIGlmIChlbmdpbmUucmVuZGVyKSB7XG4gICAgICAgICAgICBlbmdpbmUucmVuZGVyLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZ2luZS53b3JsZCA9IG9wdGlvbnMud29ybGQgfHwgV29ybGQuY3JlYXRlKGVuZ2luZS53b3JsZCk7XG4gICAgICAgIGVuZ2luZS5wYWlycyA9IFBhaXJzLmNyZWF0ZSgpO1xuICAgICAgICBlbmdpbmUuYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlLmNvbnRyb2xsZXIuY3JlYXRlKGVuZ2luZS5icm9hZHBoYXNlKTtcbiAgICAgICAgZW5naW5lLm1ldHJpY3MgPSBlbmdpbmUubWV0cmljcyB8fCB7IGV4dGVuZGVkOiBmYWxzZSB9O1xuXG5cbiAgICAgICAgcmV0dXJuIGVuZ2luZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHNpbXVsYXRpb24gZm9yd2FyZCBpbiB0aW1lIGJ5IGBkZWx0YWAgbXMuXG4gICAgICogVGhlIGBjb3JyZWN0aW9uYCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdGltZSBjb3JyZWN0aW9uIGZhY3RvciB0byBhcHBseSB0byB0aGUgdXBkYXRlLlxuICAgICAqIFRoaXMgY2FuIGhlbHAgaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgdGhlIHNpbXVsYXRpb24gaW4gY2FzZXMgd2hlcmUgYGRlbHRhYCBpcyBjaGFuZ2luZyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICogVGhlIHZhbHVlIG9mIGBjb3JyZWN0aW9uYCBpcyBkZWZpbmVkIGFzIGBkZWx0YSAvIGxhc3REZWx0YWAsIGkuZS4gdGhlIHBlcmNlbnRhZ2UgY2hhbmdlIG9mIGBkZWx0YWAgb3ZlciB0aGUgbGFzdCBzdGVwLlxuICAgICAqIFRoZXJlZm9yZSB0aGUgdmFsdWUgaXMgYWx3YXlzIGAxYCAobm8gY29ycmVjdGlvbikgd2hlbiBgZGVsdGFgIGNvbnN0YW50IChvciB3aGVuIG5vIGNvcnJlY3Rpb24gaXMgZGVzaXJlZCwgd2hpY2ggaXMgdGhlIGRlZmF1bHQpLlxuICAgICAqIFNlZSB0aGUgcGFwZXIgb24gPGEgaHJlZj1cImh0dHA6Ly9sb25lc29jay5uZXQvYXJ0aWNsZS92ZXJsZXQuaHRtbFwiPlRpbWUgQ29ycmVjdGVkIFZlcmxldDwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlVXBkYXRlYCBhbmQgYGFmdGVyVXBkYXRlYCBldmVudHMuXG4gICAgICogVHJpZ2dlcnMgYGNvbGxpc2lvblN0YXJ0YCwgYGNvbGxpc2lvbkFjdGl2ZWAgYW5kIGBjb2xsaXNpb25FbmRgIGV2ZW50cy5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbHRhPTE2LjY2Nl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvcnJlY3Rpb249MV1cbiAgICAgKi9cbiAgICBFbmdpbmUudXBkYXRlID0gZnVuY3Rpb24oZW5naW5lLCBkZWx0YSwgY29ycmVjdGlvbikge1xuICAgICAgICBkZWx0YSA9IGRlbHRhIHx8IDEwMDAgLyA2MDtcbiAgICAgICAgY29ycmVjdGlvbiA9IGNvcnJlY3Rpb24gfHwgMTtcblxuICAgICAgICB2YXIgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICB0aW1pbmcgPSBlbmdpbmUudGltaW5nLFxuICAgICAgICAgICAgYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlLFxuICAgICAgICAgICAgYnJvYWRwaGFzZVBhaXJzID0gW10sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGluY3JlbWVudCB0aW1lc3RhbXBcbiAgICAgICAgdGltaW5nLnRpbWVzdGFtcCArPSBkZWx0YSAqIHRpbWluZy50aW1lU2NhbGU7XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGV2ZW50IG9iamVjdFxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWluZy50aW1lc3RhbXBcbiAgICAgICAgfTtcblxuICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdiZWZvcmVVcGRhdGUnLCBldmVudCk7XG5cbiAgICAgICAgLy8gZ2V0IGxpc3RzIG9mIGFsbCBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLCBubyBtYXR0ZXIgd2hhdCBjb21wb3NpdGVzIHRoZXkgYXJlIGluXG4gICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcbiAgICAgICAgICAgIGFsbENvbnN0cmFpbnRzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKHdvcmxkKTtcblxuXG4gICAgICAgIC8vIGlmIHNsZWVwaW5nIGVuYWJsZWQsIGNhbGwgdGhlIHNsZWVwaW5nIGNvbnRyb2xsZXJcbiAgICAgICAgaWYgKGVuZ2luZS5lbmFibGVTbGVlcGluZylcbiAgICAgICAgICAgIFNsZWVwaW5nLnVwZGF0ZShhbGxCb2RpZXMsIHRpbWluZy50aW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIGFwcGxpZXMgZ3Jhdml0eSB0byBhbGwgYm9kaWVzXG4gICAgICAgIEVuZ2luZS5fYm9kaWVzQXBwbHlHcmF2aXR5KGFsbEJvZGllcywgd29ybGQuZ3Jhdml0eSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGFsbCBib2R5IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBieSBpbnRlZ3JhdGlvblxuICAgICAgICBFbmdpbmUuX2JvZGllc1VwZGF0ZShhbGxCb2RpZXMsIGRlbHRhLCB0aW1pbmcudGltZVNjYWxlLCBjb3JyZWN0aW9uLCB3b3JsZC5ib3VuZHMpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBhbGwgY29uc3RyYWludHMgKGZpcnN0IHBhc3MpXG4gICAgICAgIENvbnN0cmFpbnQucHJlU29sdmVBbGwoYWxsQm9kaWVzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS5jb25zdHJhaW50SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlQWxsKGFsbENvbnN0cmFpbnRzLCB0aW1pbmcudGltZVNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbChhbGxCb2RpZXMpO1xuXG4gICAgICAgIC8vIGJyb2FkcGhhc2UgcGFzczogZmluZCBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzXG4gICAgICAgIGlmIChicm9hZHBoYXNlLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIGlmIHdvcmxkIGlzIGRpcnR5LCB3ZSBtdXN0IGZsdXNoIHRoZSB3aG9sZSBncmlkXG4gICAgICAgICAgICBpZiAod29ybGQuaXNNb2RpZmllZClcbiAgICAgICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIuY2xlYXIoYnJvYWRwaGFzZSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZ3JpZCBidWNrZXRzIGJhc2VkIG9uIGN1cnJlbnQgYm9kaWVzXG4gICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIudXBkYXRlKGJyb2FkcGhhc2UsIGFsbEJvZGllcywgZW5naW5lLCB3b3JsZC5pc01vZGlmaWVkKTtcbiAgICAgICAgICAgIGJyb2FkcGhhc2VQYWlycyA9IGJyb2FkcGhhc2UucGFpcnNMaXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gYnJvYWRwaGFzZSBzZXQsIHdlIGp1c3QgcGFzcyBhbGwgYm9kaWVzXG4gICAgICAgICAgICBicm9hZHBoYXNlUGFpcnMgPSBhbGxCb2RpZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBhbGwgY29tcG9zaXRlIG1vZGlmaWVkIGZsYWdzXG4gICAgICAgIGlmICh3b3JsZC5pc01vZGlmaWVkKSB7XG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQod29ybGQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuYXJyb3dwaGFzZSBwYXNzOiBmaW5kIGFjdHVhbCBjb2xsaXNpb25zLCB0aGVuIGNyZWF0ZSBvciB1cGRhdGUgY29sbGlzaW9uIHBhaXJzXG4gICAgICAgIHZhciBjb2xsaXNpb25zID0gYnJvYWRwaGFzZS5kZXRlY3Rvcihicm9hZHBoYXNlUGFpcnMsIGVuZ2luZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGNvbGxpc2lvbiBwYWlyc1xuICAgICAgICB2YXIgcGFpcnMgPSBlbmdpbmUucGFpcnMsXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1pbmcudGltZXN0YW1wO1xuICAgICAgICBQYWlycy51cGRhdGUocGFpcnMsIGNvbGxpc2lvbnMsIHRpbWVzdGFtcCk7XG4gICAgICAgIFBhaXJzLnJlbW92ZU9sZChwYWlycywgdGltZXN0YW1wKTtcblxuICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25zXG4gICAgICAgIGlmIChlbmdpbmUuZW5hYmxlU2xlZXBpbmcpXG4gICAgICAgICAgICBTbGVlcGluZy5hZnRlckNvbGxpc2lvbnMocGFpcnMubGlzdCwgdGltaW5nLnRpbWVTY2FsZSk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBjb2xsaXNpb24gZXZlbnRzXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uU3RhcnQnLCB7IHBhaXJzOiBwYWlycy5jb2xsaXNpb25TdGFydCB9KTtcblxuICAgICAgICAvLyBpdGVyYXRpdmVseSByZXNvbHZlIHBvc2l0aW9uIGJldHdlZW4gY29sbGlzaW9uc1xuICAgICAgICBSZXNvbHZlci5wcmVTb2x2ZVBvc2l0aW9uKHBhaXJzLmxpc3QpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5naW5lLnBvc2l0aW9uSXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBSZXNvbHZlci5zb2x2ZVBvc2l0aW9uKHBhaXJzLmxpc3QsIHRpbWluZy50aW1lU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIFJlc29sdmVyLnBvc3RTb2x2ZVBvc2l0aW9uKGFsbEJvZGllcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGFsbCBjb25zdHJhaW50cyAoc2Vjb25kIHBhc3MpXG4gICAgICAgIENvbnN0cmFpbnQucHJlU29sdmVBbGwoYWxsQm9kaWVzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS5jb25zdHJhaW50SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlQWxsKGFsbENvbnN0cmFpbnRzLCB0aW1pbmcudGltZVNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbChhbGxCb2RpZXMpO1xuXG4gICAgICAgIC8vIGl0ZXJhdGl2ZWx5IHJlc29sdmUgdmVsb2NpdHkgYmV0d2VlbiBjb2xsaXNpb25zXG4gICAgICAgIFJlc29sdmVyLnByZVNvbHZlVmVsb2NpdHkocGFpcnMubGlzdCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUudmVsb2NpdHlJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIFJlc29sdmVyLnNvbHZlVmVsb2NpdHkocGFpcnMubGlzdCwgdGltaW5nLnRpbWVTY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGNvbGxpc2lvbiBldmVudHNcbiAgICAgICAgaWYgKHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uQWN0aXZlJywgeyBwYWlyczogcGFpcnMuY29sbGlzaW9uQWN0aXZlIH0pO1xuXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25FbmQubGVuZ3RoID4gMClcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2NvbGxpc2lvbkVuZCcsIHsgcGFpcnM6IHBhaXJzLmNvbGxpc2lvbkVuZCB9KTtcblxuXG4gICAgICAgIC8vIGNsZWFyIGZvcmNlIGJ1ZmZlcnNcbiAgICAgICAgRW5naW5lLl9ib2RpZXNDbGVhckZvcmNlcyhhbGxCb2RpZXMpO1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVXBkYXRlJywgZXZlbnQpO1xuXG4gICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdHdvIGVuZ2luZXMgYnkga2VlcGluZyB0aGUgY29uZmlndXJhdGlvbiBvZiBgZW5naW5lQWAgYnV0IHJlcGxhY2luZyB0aGUgd29ybGQgd2l0aCB0aGUgb25lIGZyb20gYGVuZ2luZUJgLlxuICAgICAqIEBtZXRob2QgbWVyZ2VcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lQVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVCXG4gICAgICovXG4gICAgRW5naW5lLm1lcmdlID0gZnVuY3Rpb24oZW5naW5lQSwgZW5naW5lQikge1xuICAgICAgICBDb21tb24uZXh0ZW5kKGVuZ2luZUEsIGVuZ2luZUIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVuZ2luZUIud29ybGQpIHtcbiAgICAgICAgICAgIGVuZ2luZUEud29ybGQgPSBlbmdpbmVCLndvcmxkO1xuXG4gICAgICAgICAgICBFbmdpbmUuY2xlYXIoZW5naW5lQSk7XG5cbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZUEud29ybGQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYm9keS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGVuZ2luZSBpbmNsdWRpbmcgdGhlIHdvcmxkLCBwYWlycyBhbmQgYnJvYWRwaGFzZS5cbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqL1xuICAgIEVuZ2luZS5jbGVhciA9IGZ1bmN0aW9uKGVuZ2luZSkge1xuICAgICAgICB2YXIgd29ybGQgPSBlbmdpbmUud29ybGQ7XG4gICAgICAgIFxuICAgICAgICBQYWlycy5jbGVhcihlbmdpbmUucGFpcnMpO1xuXG4gICAgICAgIHZhciBicm9hZHBoYXNlID0gZW5naW5lLmJyb2FkcGhhc2U7XG4gICAgICAgIGlmIChicm9hZHBoYXNlLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKTtcbiAgICAgICAgICAgIGJyb2FkcGhhc2UuY29udHJvbGxlci5jbGVhcihicm9hZHBoYXNlKTtcbiAgICAgICAgICAgIGJyb2FkcGhhc2UuY29udHJvbGxlci51cGRhdGUoYnJvYWRwaGFzZSwgYm9kaWVzLCBlbmdpbmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFplcm9lcyB0aGUgYGJvZHkuZm9yY2VgIGFuZCBgYm9keS50b3JxdWVgIGZvcmNlIGJ1ZmZlcnMuXG4gICAgICogQG1ldGhvZCBfYm9kaWVzQ2xlYXJGb3JjZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICBFbmdpbmUuX2JvZGllc0NsZWFyRm9yY2VzID0gZnVuY3Rpb24oYm9kaWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgZm9yY2UgYnVmZmVyc1xuICAgICAgICAgICAgYm9keS5mb3JjZS54ID0gMDtcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueSA9IDA7XG4gICAgICAgICAgICBib2R5LnRvcnF1ZSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbHlzIGEgbWFzcyBkZXBlbmRhbnQgZm9yY2UgdG8gYWxsIGdpdmVuIGJvZGllcy5cbiAgICAgKiBAbWV0aG9kIF9ib2RpZXNBcHBseUdyYXZpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZ3Jhdml0eVxuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzQXBwbHlHcmF2aXR5ID0gZnVuY3Rpb24oYm9kaWVzLCBncmF2aXR5KSB7XG4gICAgICAgIHZhciBncmF2aXR5U2NhbGUgPSB0eXBlb2YgZ3Jhdml0eS5zY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBncmF2aXR5LnNjYWxlIDogMC4wMDE7XG5cbiAgICAgICAgaWYgKChncmF2aXR5LnggPT09IDAgJiYgZ3Jhdml0eS55ID09PSAwKSB8fCBncmF2aXR5U2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCBib2R5LmlzU2xlZXBpbmcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGdyYXZpdHlcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueSArPSBib2R5Lm1hc3MgKiBncmF2aXR5LnkgKiBncmF2aXR5U2NhbGU7XG4gICAgICAgICAgICBib2R5LmZvcmNlLnggKz0gYm9keS5tYXNzICogZ3Jhdml0eS54ICogZ3Jhdml0eVNjYWxlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5cyBgQm9keS51cGRhdGVgIHRvIGFsbCBnaXZlbiBgYm9kaWVzYC5cbiAgICAgKiBAbWV0aG9kIF9ib2RpZXNVcGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIFxuICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBlbGFwc2VkIGJldHdlZW4gdXBkYXRlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29ycmVjdGlvbiBcbiAgICAgKiBUaGUgVmVybGV0IGNvcnJlY3Rpb24gZmFjdG9yIChkZWx0YVRpbWUgLyBsYXN0RGVsdGFUaW1lKVxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSB3b3JsZEJvdW5kc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlID0gZnVuY3Rpb24oYm9kaWVzLCBkZWx0YVRpbWUsIHRpbWVTY2FsZSwgY29ycmVjdGlvbiwgd29ybGRCb3VuZHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCBib2R5LmlzU2xlZXBpbmcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIEJvZHkudXBkYXRlKGJvZHksIGRlbHRhVGltZSwgdGltZVNjYWxlLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbGlhcyBmb3IgYFJ1bm5lci5ydW5gLCBzZWUgYE1hdHRlci5SdW5uZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBtZXRob2QgcnVuXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhbiB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlVXBkYXRlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlIGFuZCBhbGwgY29sbGlzaW9uIGV2ZW50c1xuICAgICpcbiAgICAqIEBldmVudCBhZnRlclVwZGF0ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgc3RhcnRlZCB0byBjb2xsaWRlIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcbiAgICAqXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uU3RhcnRcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlLCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIHBhaXJzIHRoYXQgYXJlIGNvbGxpZGluZyBpbiB0aGUgY3VycmVudCB0aWNrIChpZiBhbnkpXG4gICAgKlxuICAgICogQGV2ZW50IGNvbGxpc2lvbkFjdGl2ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnBhaXJzIExpc3Qgb2YgYWZmZWN0ZWQgcGFpcnNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB1cGRhdGUsIHByb3ZpZGVzIGEgbGlzdCBvZiBhbGwgcGFpcnMgdGhhdCBoYXZlIGVuZGVkIGNvbGxpc2lvbiBpbiB0aGUgY3VycmVudCB0aWNrIChpZiBhbnkpXG4gICAgKlxuICAgICogQGV2ZW50IGNvbGxpc2lvbkVuZFxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnBhaXJzIExpc3Qgb2YgYWZmZWN0ZWQgcGFpcnNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbiBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uSXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDZcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB2ZWxvY2l0eSBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5SXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBjb25zdHJhaW50IGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBlYWNoIHVwZGF0ZS5cbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGhpZ2hlciBxdWFsaXR5IHRoZSBzaW11bGF0aW9uIHdpbGwgYmUgYXQgdGhlIGV4cGVuc2Ugb2YgcGVyZm9ybWFuY2UuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDJgIGlzIHVzdWFsbHkgdmVyeSBhZGVxdWF0ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50SXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBlbmdpbmUgc2hvdWxkIGFsbG93IHNsZWVwaW5nIHZpYSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlLlxuICAgICAqIFNsZWVwaW5nIGNhbiBpbXByb3ZlIHN0YWJpbGl0eSBhbmQgcGVyZm9ybWFuY2UsIGJ1dCBvZnRlbiBhdCB0aGUgZXhwZW5zZSBvZiBhY2N1cmFjeS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVTbGVlcGluZ1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgY29udGFpbmluZyBwcm9wZXJ0aWVzIHJlZ2FyZGluZyB0aGUgdGltaW5nIHN5c3RlbXMgb2YgdGhlIGVuZ2luZS4gXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBnbG9iYWwgc2NhbGluZyBmYWN0b3Igb2YgdGltZSBmb3IgYWxsIGJvZGllcy5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBmcmVlemVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgYDAuMWAgZ2l2ZXMgYSBzbG93LW1vdGlvbiBlZmZlY3QuXG4gICAgICogQSB2YWx1ZSBvZiBgMS4yYCBnaXZlcyBhIHNwZWVkLXVwIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCBzaW11bGF0aW9uLXRpbWUgaW4gbWlsbGlzZWNvbmRzIHN0YXJ0aW5nIGZyb20gYDBgLiBcbiAgICAgKiBJdCBpcyBpbmNyZW1lbnRlZCBvbiBldmVyeSBgRW5naW5lLnVwZGF0ZWAgYnkgdGhlIGdpdmVuIGBkZWx0YWAgYXJndW1lbnQuIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbWluZy50aW1lc3RhbXBcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiBhIGBSZW5kZXJgIGNvbnRyb2xsZXIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgYE1hdHRlci5SZW5kZXJgIGluc3RhbmNlIGNyZWF0ZWQgYnkgYEVuZ2luZS5jcmVhdGVgLlxuICAgICAqIE9uZSBtYXkgYWxzbyBkZXZlbG9wIGEgY3VzdG9tIHJlbmRlcmVyIG1vZHVsZSBiYXNlZCBvbiBgTWF0dGVyLlJlbmRlcmAgYW5kIHBhc3MgYW4gaW5zdGFuY2Ugb2YgaXQgdG8gYEVuZ2luZS5jcmVhdGVgIHZpYSBgb3B0aW9ucy5yZW5kZXJgLlxuICAgICAqXG4gICAgICogQSBtaW5pbWFsIGN1c3RvbSByZW5kZXJlciBvYmplY3QgbXVzdCBkZWZpbmUgYXQgbGVhc3QgdGhyZWUgZnVuY3Rpb25zOiBgY3JlYXRlYCwgYGNsZWFyYCBhbmQgYHdvcmxkYCAoc2VlIGBNYXR0ZXIuUmVuZGVyYCkuXG4gICAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBpbnN0ZWFkIHBhc3MgdGhlIF9tb2R1bGVfIHJlZmVyZW5jZSB2aWEgYG9wdGlvbnMucmVuZGVyLmNvbnRyb2xsZXJgIGFuZCBgRW5naW5lLmNyZWF0ZWAgd2lsbCBpbnN0YW50aWF0ZSBvbmUgZm9yIHlvdS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcbiAgICAgKiBAdHlwZSByZW5kZXJcbiAgICAgKiBAZGVwcmVjYXRlZCBzZWUgRGVtby5qcyBmb3IgYW4gZXhhbXBsZSBvZiBjcmVhdGluZyBhIHJlbmRlcmVyXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuUmVuZGVyIGluc3RhbmNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiBhIGJyb2FkcGhhc2UgY29udHJvbGxlci4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBgTWF0dGVyLkdyaWRgIGluc3RhbmNlIGNyZWF0ZWQgYnkgYEVuZ2luZS5jcmVhdGVgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSBncmlkXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuR3JpZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgV29ybGRgIGNvbXBvc2l0ZSBvYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gYWxsIHNpbXVsYXRlZCBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUgd29ybGRcbiAgICAgKiBAZGVmYXVsdCBhIE1hdHRlci5Xb3JsZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsdWdpblxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbn0pKCk7XG5cbn0se1wiLi4vYm9keS9Cb2R5XCI6MSxcIi4uL2JvZHkvQ29tcG9zaXRlXCI6MixcIi4uL2JvZHkvV29ybGRcIjozLFwiLi4vY29sbGlzaW9uL0dyaWRcIjo2LFwiLi4vY29sbGlzaW9uL1BhaXJzXCI6OCxcIi4uL2NvbGxpc2lvbi9SZXNvbHZlclwiOjEwLFwiLi4vY29uc3RyYWludC9Db25zdHJhaW50XCI6MTIsXCIuLi9yZW5kZXIvUmVuZGVyXCI6MzEsXCIuL0NvbW1vblwiOjE0LFwiLi9FdmVudHNcIjoxNixcIi4vTWV0cmljc1wiOjE4LFwiLi9TbGVlcGluZ1wiOjIyfV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLkV2ZW50c2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgdG8gZmlyZSBhbmQgbGlzdGVuIHRvIGV2ZW50cyBvbiBvdGhlciBvYmplY3RzLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgRXZlbnRzXG4qL1xuXG52YXIgRXZlbnRzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xuXG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi9Db21tb24nKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBvYmplY3QncyBgZXZlbnROYW1lYC5cbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBFdmVudHMub24gPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgIG5hbWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgb2JqZWN0LmV2ZW50cyA9IG9iamVjdC5ldmVudHMgfHwge307XG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzW25hbWVdID0gb2JqZWN0LmV2ZW50c1tuYW1lXSB8fCBbXTtcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGV2ZW50IGNhbGxiYWNrLiBJZiBubyBjYWxsYmFjaywgY2xlYXJzIGFsbCBjYWxsYmFja3MgaW4gYGV2ZW50TmFtZXNgLiBJZiBubyBgZXZlbnROYW1lc2AsIGNsZWFycyBhbGwgZXZlbnRzLlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBFdmVudHMub2ZmID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBFdmVudHMub2ZmKG9iamVjdCwgY2FsbGJhY2spXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBldmVudE5hbWVzO1xuICAgICAgICAgICAgZXZlbnROYW1lcyA9IENvbW1vbi5rZXlzKG9iamVjdC5ldmVudHMpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gb2JqZWN0LmV2ZW50c1tuYW1lc1tpXV0sXG4gICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2pdICE9PSBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzW25hbWVzW2ldXSA9IG5ld0NhbGxiYWNrcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyBhbGwgdGhlIGNhbGxiYWNrcyBzdWJzY3JpYmVkIHRvIHRoZSBnaXZlbiBvYmplY3QncyBgZXZlbnROYW1lYCwgaW4gdGhlIG9yZGVyIHRoZXkgc3Vic2NyaWJlZCwgaWYgYW55LlxuICAgICAqIEBtZXRob2QgdHJpZ2dlclxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7fSBldmVudFxuICAgICAqL1xuICAgIEV2ZW50cy50cmlnZ2VyID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBldmVudCkge1xuICAgICAgICB2YXIgbmFtZXMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2tzLFxuICAgICAgICAgICAgZXZlbnRDbG9uZTtcblxuICAgICAgICBpZiAob2JqZWN0LmV2ZW50cykge1xuICAgICAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICAgICAgICBldmVudCA9IHt9O1xuXG4gICAgICAgICAgICBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBvYmplY3QuZXZlbnRzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBldmVudENsb25lID0gQ29tbW9uLmNsb25lKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUuc291cmNlID0gb2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Nbal0uYXBwbHkob2JqZWN0LCBbZXZlbnRDbG9uZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxufSx7XCIuL0NvbW1vblwiOjE0fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyYCBtb2R1bGUgaXMgdGhlIHRvcCBsZXZlbCBuYW1lc3BhY2UuIEl0IGFsc28gaW5jbHVkZXMgYSBmdW5jdGlvbiBmb3IgaW5zdGFsbGluZyBwbHVnaW5zIG9uIHRvcCBvZiB0aGUgbGlicmFyeS5cbipcbiogQGNsYXNzIE1hdHRlclxuKi9cblxudmFyIE1hdHRlciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHRlcjtcblxudmFyIFBsdWdpbiA9IF9kZXJlcV8oJy4vUGx1Z2luJyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi9Db21tb24nKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpYnJhcnkgbmFtZS5cbiAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAqIEByZWFkT25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgTWF0dGVyLm5hbWUgPSAnbWF0dGVyLWpzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaWJyYXJ5IHZlcnNpb24uXG4gICAgICogQHByb3BlcnR5IHZlcnNpb25cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIE1hdHRlci52ZXJzaW9uID0gJzAuMTQuMic7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgcGx1Z2luIGRlcGVuZGVuY2llcyB0byBiZSBpbnN0YWxsZWQuIFRoZXNlIGFyZSBub3JtYWxseSBzZXQgYW5kIGluc3RhbGxlZCB0aHJvdWdoIGBNYXR0ZXIudXNlYC5cbiAgICAgKiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgc2V0IGBNYXR0ZXIudXNlc2AgbWFudWFsbHkgYW5kIGluc3RhbGwgdGhlbSBieSBjYWxsaW5nIGBQbHVnaW4udXNlKE1hdHRlcilgLlxuICAgICAqIEBwcm9wZXJ0eSB1c2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIE1hdHRlci51c2VzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGx1Z2lucyB0aGF0IGhhdmUgYmVlbiBpbnN0YWxsZWQgdGhyb3VnaCBgTWF0dGVyLlBsdWdpbi5pbnN0YWxsYC4gUmVhZCBvbmx5LlxuICAgICAqIEBwcm9wZXJ0eSB1c2VkXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIE1hdHRlci51c2VkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxscyB0aGUgZ2l2ZW4gcGx1Z2lucyBvbiB0aGUgYE1hdHRlcmAgbmFtZXNwYWNlLlxuICAgICAqIFRoaXMgaXMgYSBzaG9ydC1oYW5kIGZvciBgUGx1Z2luLnVzZWAsIHNlZSBpdCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gb25jZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBjb2RlLCB3aXRoIGFsbCBvZiB0aGUgcGx1Z2lucyB5b3Ugd2lzaCB0byBpbnN0YWxsIGFzIGFyZ3VtZW50cy5cbiAgICAgKiBBdm9pZCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdW5sZXNzIHlvdSBpbnRlbmQgdG8gbWFudWFsbHkgY29udHJvbCBpbnN0YWxsYXRpb24gb3JkZXIuXG4gICAgICogQG1ldGhvZCB1c2VcbiAgICAgKiBAcGFyYW0gLi4ucGx1Z2luIHtGdW5jdGlvbn0gVGhlIHBsdWdpbihzKSB0byBpbnN0YWxsIG9uIGBiYXNlYCAobXVsdGktYXJndW1lbnQpLlxuICAgICAqL1xuICAgIE1hdHRlci51c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUGx1Z2luLnVzZShNYXR0ZXIsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYmVmb3JlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBNYXR0ZXJgLlxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxuICAgICAqIEBtZXRob2QgYmVmb3JlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYE1hdHRlcmBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBiZWZvcmUgdGhlIG9yaWdpbmFsXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXG4gICAgICovXG4gICAgTWF0dGVyLmJlZm9yZSA9IGZ1bmN0aW9uKHBhdGgsIGZ1bmMpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXk1hdHRlci4vLCAnJyk7XG4gICAgICAgIHJldHVybiBDb21tb24uY2hhaW5QYXRoQmVmb3JlKE1hdHRlciwgcGF0aCwgZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBhZnRlciB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgTWF0dGVyYC5cbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cbiAgICAgKiBAbWV0aG9kIGFmdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYE1hdHRlcmBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBhZnRlciB0aGUgb3JpZ2luYWxcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcbiAgICAgKi9cbiAgICBNYXR0ZXIuYWZ0ZXIgPSBmdW5jdGlvbihwYXRoLCBmdW5jKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15NYXR0ZXIuLywgJycpO1xuICAgICAgICByZXR1cm4gQ29tbW9uLmNoYWluUGF0aEFmdGVyKE1hdHRlciwgcGF0aCwgZnVuYyk7XG4gICAgfTtcblxufSkoKTtcblxufSx7XCIuL0NvbW1vblwiOjE0LFwiLi9QbHVnaW5cIjoyMH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxufSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuL0NvbW1vblwiOjE0fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLk1vdXNlYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBtb3VzZSBpbnB1dHMuXG4qXG4qIEBjbGFzcyBNb3VzZVxuKi9cblxudmFyIE1vdXNlID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gTW91c2U7XG5cbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbW91c2UgaW5wdXQuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7bW91c2V9IEEgbmV3IG1vdXNlXG4gICAgICovXG4gICAgTW91c2UuY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgbW91c2UgPSB7fTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIENvbW1vbi5sb2coJ01vdXNlLmNyZWF0ZTogZWxlbWVudCB3YXMgdW5kZWZpbmVkLCBkZWZhdWx0aW5nIHRvIGRvY3VtZW50LmJvZHknLCAnd2FybicpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBtb3VzZS5lbGVtZW50ID0gZWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICBtb3VzZS5hYnNvbHV0ZSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBtb3VzZS5wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2Uub2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIG1vdXNlLnNjYWxlID0geyB4OiAxLCB5OiAxIH07XG4gICAgICAgIG1vdXNlLndoZWVsRGVsdGEgPSAwO1xuICAgICAgICBtb3VzZS5idXR0b24gPSAtMTtcbiAgICAgICAgbW91c2UucGl4ZWxSYXRpbyA9IG1vdXNlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBpeGVsLXJhdGlvJykgfHwgMTtcblxuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMgPSB7XG4gICAgICAgICAgICBtb3VzZW1vdmU6IG51bGwsXG4gICAgICAgICAgICBtb3VzZWRvd246IG51bGwsXG4gICAgICAgICAgICBtb3VzZXVwOiBudWxsLFxuICAgICAgICAgICAgbW91c2V3aGVlbDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW91c2UubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHsgXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmUgPSBldmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG1vdXNlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnggPSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgICAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbi55ID0gbW91c2UucG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZWRvd24gPSBldmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG1vdXNlLm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gTW91c2UuX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbihldmVudCwgbW91c2UuZWxlbWVudCwgbW91c2UucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vdXNlLmJ1dHRvbiA9IC0xO1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueSA9IG1vdXNlLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IGV2ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIG1vdXNlLm1vdXNld2hlZWwgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZXRhaWwpKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgTW91c2Uuc2V0RWxlbWVudChtb3VzZSwgbW91c2UuZWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIG1vdXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50IHRoZSBtb3VzZSBpcyBib3VuZCB0byAoYW5kIHJlbGF0aXZlIHRvKS5cbiAgICAgKiBAbWV0aG9kIHNldEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBNb3VzZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24obW91c2UsIGVsZW1lbnQpIHtcbiAgICAgICAgbW91c2UuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZS5tb3VzZW1vdmUpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlLm1vdXNlZG93bik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlLm1vdXNldXApO1xuICAgICAgICBcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2UubW91c2V3aGVlbCk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBtb3VzZS5tb3VzZXdoZWVsKTtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdXNlLm1vdXNlbW92ZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG1vdXNlLm1vdXNlZG93bik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBtb3VzZS5tb3VzZXVwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjYXB0dXJlZCBzb3VyY2UgZXZlbnRzLlxuICAgICAqIEBtZXRob2QgY2xlYXJTb3VyY2VFdmVudHNcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqL1xuICAgIE1vdXNlLmNsZWFyU291cmNlRXZlbnRzID0gZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZWRvd24gPSBudWxsO1xuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IG51bGw7XG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZXdoZWVsID0gbnVsbDtcbiAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vdXNlIHBvc2l0aW9uIG9mZnNldC5cbiAgICAgKiBAbWV0aG9kIHNldE9mZnNldFxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IG9mZnNldFxuICAgICAqL1xuICAgIE1vdXNlLnNldE9mZnNldCA9IGZ1bmN0aW9uKG1vdXNlLCBvZmZzZXQpIHtcbiAgICAgICAgbW91c2Uub2Zmc2V0LnggPSBvZmZzZXQueDtcbiAgICAgICAgbW91c2Uub2Zmc2V0LnkgPSBvZmZzZXQueTtcbiAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiBzY2FsZS5cbiAgICAgKiBAbWV0aG9kIHNldFNjYWxlXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gc2NhbGVcbiAgICAgKi9cbiAgICBNb3VzZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKG1vdXNlLCBzY2FsZSkge1xuICAgICAgICBtb3VzZS5zY2FsZS54ID0gc2NhbGUueDtcbiAgICAgICAgbW91c2Uuc2NhbGUueSA9IHNjYWxlLnk7XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGFuIGVsZW1lbnQgZ2l2ZW4gYSBzY3JlZW4gcGl4ZWwgcmF0aW8uXG4gICAgICogQG1ldGhvZCBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXG4gICAgICogQHJldHVybiB7fVxuICAgICAqL1xuICAgIE1vdXNlLl9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihldmVudCwgZWxlbWVudCwgcGl4ZWxSYXRpbykge1xuICAgICAgICB2YXIgZWxlbWVudEJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICByb290Tm9kZSA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLFxuICAgICAgICAgICAgc2Nyb2xsWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxUb3AsXG4gICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgICAgICB4LCB5O1xuICAgICAgICBcbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAgIHggPSB0b3VjaGVzWzBdLnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgPSB0b3VjaGVzWzBdLnBhZ2VZIC0gZWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IGV2ZW50LnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgPSBldmVudC5wYWdlWSAtIGVsZW1lbnRCb3VuZHMudG9wIC0gc2Nyb2xsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgeDogeCAvIChlbGVtZW50LmNsaWVudFdpZHRoIC8gKGVsZW1lbnQud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCkgKiBwaXhlbFJhdGlvKSxcbiAgICAgICAgICAgIHk6IHkgLyAoZWxlbWVudC5jbGllbnRIZWlnaHQgLyAoZWxlbWVudC5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQpICogcGl4ZWxSYXRpbylcbiAgICAgICAgfTtcbiAgICB9O1xuXG59KSgpO1xuXG59LHtcIi4uL2NvcmUvQ29tbW9uXCI6MTR9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuUGx1Z2luYCBtb2R1bGUgY29udGFpbnMgZnVuY3Rpb25zIGZvciByZWdpc3RlcmluZyBhbmQgaW5zdGFsbGluZyBwbHVnaW5zIG9uIG1vZHVsZXMuXG4qXG4qIEBjbGFzcyBQbHVnaW5cbiovXG5cbnZhciBQbHVnaW4gPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW47XG5cbnZhciBDb21tb24gPSBfZGVyZXFfKCcuL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBQbHVnaW4uX3JlZ2lzdHJ5ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gb2JqZWN0IHNvIGl0IGNhbiBiZSByZXNvbHZlZCBsYXRlciBieSBuYW1lLlxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIHt9IFRoZSBwbHVnaW4gdG8gcmVnaXN0ZXIuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcGx1Z2luLlxuICAgICAqL1xuICAgIFBsdWdpbi5yZWdpc3RlciA9IGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICBpZiAoIVBsdWdpbi5pc1BsdWdpbihwbHVnaW4pKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnJlZ2lzdGVyOicsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pLCAnZG9lcyBub3QgaW1wbGVtZW50IGFsbCByZXF1aXJlZCBmaWVsZHMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGx1Z2luLm5hbWUgaW4gUGx1Z2luLl9yZWdpc3RyeSkge1xuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWQgPSBQbHVnaW4uX3JlZ2lzdHJ5W3BsdWdpbi5uYW1lXSxcbiAgICAgICAgICAgICAgICBwbHVnaW5WZXJzaW9uID0gUGx1Z2luLnZlcnNpb25QYXJzZShwbHVnaW4udmVyc2lvbikubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRWZXJzaW9uID0gUGx1Z2luLnZlcnNpb25QYXJzZShyZWdpc3RlcmVkLnZlcnNpb24pLm51bWJlcjtcblxuICAgICAgICAgICAgaWYgKHBsdWdpblZlcnNpb24gPiByZWdpc3RlcmVkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHJlZ2lzdGVyZWQpLCAnd2FzIHVwZ3JhZGVkIHRvJywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xuICAgICAgICAgICAgICAgIFBsdWdpbi5fcmVnaXN0cnlbcGx1Z2luLm5hbWVdID0gcGx1Z2luO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW5WZXJzaW9uIDwgcmVnaXN0ZXJlZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnJlZ2lzdGVyOicsIFBsdWdpbi50b1N0cmluZyhyZWdpc3RlcmVkKSwgJ2NhbiBub3QgYmUgZG93bmdyYWRlZCB0bycsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luICE9PSByZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2lzIGFscmVhZHkgcmVnaXN0ZXJlZCB0byBkaWZmZXJlbnQgcGx1Z2luIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGx1Z2luO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIGRlcGVuZGVuY3kgdG8gYSBwbHVnaW4gb2JqZWN0IGZyb20gdGhlIHJlZ2lzdHJ5IGlmIGl0IGV4aXN0cy4gXG4gICAgICogVGhlIGBkZXBlbmRlbmN5YCBtYXkgY29udGFpbiBhIHZlcnNpb24sIGJ1dCBvbmx5IHRoZSBuYW1lIG1hdHRlcnMgd2hlbiByZXNvbHZpbmcuXG4gICAgICogQG1ldGhvZCByZXNvbHZlXG4gICAgICogQHBhcmFtIGRlcGVuZGVuY3kge3N0cmluZ30gVGhlIGRlcGVuZGVuY3kuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcGx1Z2luIGlmIHJlc29sdmVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgUGx1Z2luLnJlc29sdmUgPSBmdW5jdGlvbihkZXBlbmRlbmN5KSB7XG4gICAgICAgIHJldHVybiBQbHVnaW4uX3JlZ2lzdHJ5W1BsdWdpbi5kZXBlbmRlbmN5UGFyc2UoZGVwZW5kZW5jeSkubmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcmV0dHkgcHJpbnRlZCBwbHVnaW4gbmFtZSBhbmQgdmVyc2lvbi5cbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHBhcmFtIHBsdWdpbiB7fSBUaGUgcGx1Z2luLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUHJldHR5IHByaW50ZWQgcGx1Z2luIG5hbWUgYW5kIHZlcnNpb24uXG4gICAgICovXG4gICAgUGx1Z2luLnRvU3RyaW5nID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJyA/IHBsdWdpbiA6IChwbHVnaW4ubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnQCcgKyAocGx1Z2luLnZlcnNpb24gfHwgcGx1Z2luLnJhbmdlIHx8ICcwLjAuMCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IG1lZXRzIHRoZSBtaW5pbXVtIHN0YW5kYXJkIHRvIGJlIGNvbnNpZGVyZWQgYSBwbHVnaW4uXG4gICAgICogVGhpcyBtZWFucyBpdCBtdXN0IGRlZmluZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBgbmFtZWBcbiAgICAgKiAtIGB2ZXJzaW9uYFxuICAgICAqIC0gYGluc3RhbGxgXG4gICAgICogQG1ldGhvZCBpc1BsdWdpblxuICAgICAqIEBwYXJhbSBvYmoge30gVGhlIG9iaiB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgb2JqZWN0IGNhbiBiZSBjb25zaWRlcmVkIGEgcGx1Z2luIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFBsdWdpbi5pc1BsdWdpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5uYW1lICYmIG9iai52ZXJzaW9uICYmIG9iai5pbnN0YWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhIHBsdWdpbiB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgYmVlbiBpbnN0YWxsZWQgb24gYG1vZHVsZWAuXG4gICAgICogQG1ldGhvZCBpc1VzZWRcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIHBsdWdpbiBuYW1lLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBhIHBsdWdpbiB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgYmVlbiBpbnN0YWxsZWQgb24gYG1vZHVsZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFBsdWdpbi5pc1VzZWQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS51c2VkLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYHBsdWdpbi5mb3JgIGlzIGFwcGxpY2FibGUgdG8gYG1vZHVsZWAgYnkgY29tcGFyaW5nIGFnYWluc3QgYG1vZHVsZS5uYW1lYCBhbmQgYG1vZHVsZS52ZXJzaW9uYC5cbiAgICAgKiBJZiBgcGx1Z2luLmZvcmAgaXMgbm90IHNwZWNpZmllZCB0aGVuIGl0IGlzIGFzc3VtZWQgdG8gYmUgYXBwbGljYWJsZS5cbiAgICAgKiBUaGUgdmFsdWUgb2YgYHBsdWdpbi5mb3JgIGlzIGEgc3RyaW5nIG9mIHRoZSBmb3JtYXQgYCdtb2R1bGUtbmFtZSdgIG9yIGAnbW9kdWxlLW5hbWVAdmVyc2lvbidgLlxuICAgICAqIEBtZXRob2QgaXNGb3JcbiAgICAgKiBAcGFyYW0gcGx1Z2luIHt9IFRoZSBwbHVnaW4uXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBgcGx1Z2luLmZvcmAgaXMgYXBwbGljYWJsZSB0byBgbW9kdWxlYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGx1Z2luLmlzRm9yID0gZnVuY3Rpb24ocGx1Z2luLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBsdWdpbi5mb3IgJiYgUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShwbHVnaW4uZm9yKTtcbiAgICAgICAgcmV0dXJuICFwbHVnaW4uZm9yIHx8IChtb2R1bGUubmFtZSA9PT0gcGFyc2VkLm5hbWUgJiYgUGx1Z2luLnZlcnNpb25TYXRpc2ZpZXMobW9kdWxlLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxscyB0aGUgcGx1Z2lucyBieSBjYWxsaW5nIGBwbHVnaW4uaW5zdGFsbGAgb24gZWFjaCBwbHVnaW4gc3BlY2lmaWVkIGluIGBwbHVnaW5zYCBpZiBwYXNzZWQsIG90aGVyd2lzZSBgbW9kdWxlLnVzZXNgLlxuICAgICAqIEZvciBpbnN0YWxsaW5nIHBsdWdpbnMgb24gYE1hdHRlcmAgc2VlIHRoZSBjb252ZW5pZW5jZSBmdW5jdGlvbiBgTWF0dGVyLnVzZWAuXG4gICAgICogUGx1Z2lucyBtYXkgYmUgc3BlY2lmaWVkIGVpdGhlciBieSB0aGVpciBuYW1lIG9yIGEgcmVmZXJlbmNlIHRvIHRoZSBwbHVnaW4gb2JqZWN0LlxuICAgICAqIFBsdWdpbnMgdGhlbXNlbHZlcyBtYXkgc3BlY2lmeSBmdXJ0aGVyIGRlcGVuZGVuY2llcywgYnV0IGVhY2ggcGx1Z2luIGlzIGluc3RhbGxlZCBvbmx5IG9uY2UuXG4gICAgICogT3JkZXIgaXMgaW1wb3J0YW50LCBhIHRvcG9sb2dpY2FsIHNvcnQgaXMgcGVyZm9ybWVkIHRvIGZpbmQgdGhlIGJlc3QgcmVzdWx0aW5nIG9yZGVyIG9mIGluc3RhbGxhdGlvbi5cbiAgICAgKiBUaGlzIHNvcnRpbmcgYXR0ZW1wdHMgdG8gc2F0aXNmeSBldmVyeSBkZXBlbmRlbmN5J3MgcmVxdWVzdGVkIG9yZGVyaW5nLCBidXQgbWF5IG5vdCBiZSBleGFjdCBpbiBhbGwgY2FzZXMuXG4gICAgICogVGhpcyBmdW5jdGlvbiBsb2dzIHRoZSByZXN1bHRpbmcgc3RhdHVzIG9mIGVhY2ggZGVwZW5kZW5jeSBpbiB0aGUgY29uc29sZSwgYWxvbmcgd2l0aCBhbnkgd2FybmluZ3MuXG4gICAgICogLSBBIGdyZWVuIHRpY2sg4pyFIGluZGljYXRlcyBhIGRlcGVuZGVuY3kgd2FzIHJlc29sdmVkIGFuZCBpbnN0YWxsZWQuXG4gICAgICogLSBBbiBvcmFuZ2UgZGlhbW9uZCDwn5S2IGluZGljYXRlcyBhIGRlcGVuZGVuY3kgd2FzIHJlc29sdmVkIGJ1dCBhIHdhcm5pbmcgd2FzIHRocm93biBmb3IgaXQgb3Igb25lIGlmIGl0cyBkZXBlbmRlbmNpZXMuXG4gICAgICogLSBBIHJlZCBjcm9zcyDinYwgaW5kaWNhdGVzIGEgZGVwZW5kZW5jeSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuXG4gICAgICogQXZvaWQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIG1vZHVsZSB1bmxlc3MgeW91IGludGVuZCB0byBtYW51YWxseSBjb250cm9sIGluc3RhbGxhdGlvbiBvcmRlci5cbiAgICAgKiBAbWV0aG9kIHVzZVxuICAgICAqIEBwYXJhbSBtb2R1bGUge30gVGhlIG1vZHVsZSBpbnN0YWxsIHBsdWdpbnMgb24uXG4gICAgICogQHBhcmFtIFtwbHVnaW5zPW1vZHVsZS51c2VzXSB7fSBUaGUgcGx1Z2lucyB0byBpbnN0YWxsIG9uIG1vZHVsZSAob3B0aW9uYWwsIGRlZmF1bHRzIHRvIGBtb2R1bGUudXNlc2ApLlxuICAgICAqL1xuICAgIFBsdWdpbi51c2UgPSBmdW5jdGlvbihtb2R1bGUsIHBsdWdpbnMpIHtcbiAgICAgICAgbW9kdWxlLnVzZXMgPSAobW9kdWxlLnVzZXMgfHwgW10pLmNvbmNhdChwbHVnaW5zIHx8IFtdKTtcblxuICAgICAgICBpZiAobW9kdWxlLnVzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcobW9kdWxlKSwgJ2RvZXMgbm90IHNwZWNpZnkgYW55IGRlcGVuZGVuY2llcyB0byBpbnN0YWxsLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFBsdWdpbi5kZXBlbmRlbmNpZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHNvcnRlZERlcGVuZGVuY2llcyA9IENvbW1vbi50b3BvbG9naWNhbFNvcnQoZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAgIHN0YXR1cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoc29ydGVkRGVwZW5kZW5jaWVzW2ldID09PSBtb2R1bGUubmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gUGx1Z2luLnJlc29sdmUoc29ydGVkRGVwZW5kZW5jaWVzW2ldKTtcblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn4p2MICcgKyBzb3J0ZWREZXBlbmRlbmNpZXNbaV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoUGx1Z2luLmlzVXNlZChtb2R1bGUsIHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIVBsdWdpbi5pc0ZvcihwbHVnaW4sIG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2lzIGZvcicsIHBsdWdpbi5mb3IsICdidXQgaW5zdGFsbGVkIG9uJywgUGx1Z2luLnRvU3RyaW5nKG1vZHVsZSkgKyAnLicpO1xuICAgICAgICAgICAgICAgIHBsdWdpbi5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBsdWdpbi5pbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwobW9kdWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi51c2U6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdkb2VzIG5vdCBzcGVjaWZ5IGFuIGluc3RhbGwgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICAgICAgcGx1Z2luLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGx1Z2luLl93YXJuZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn8J+UtiAnICsgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW4uX3dhcm5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goJ+KchSAnICsgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2R1bGUudXNlZC5wdXNoKHBsdWdpbi5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0dXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgQ29tbW9uLmluZm8oc3RhdHVzLmpvaW4oJyAgJykpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZpbmRzIGFsbCBvZiBhIG1vZHVsZSdzIGRlcGVuZGVuY2llcyBhbmQgcmV0dXJucyBhIGZsYXQgZGVwZW5kZW5jeSBncmFwaC5cbiAgICAgKiBAbWV0aG9kIGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSBtb2R1bGUge30gVGhlIG1vZHVsZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgZGVwZW5kZW5jeSBncmFwaC5cbiAgICAgKi9cbiAgICBQbHVnaW4uZGVwZW5kZW5jaWVzID0gZnVuY3Rpb24obW9kdWxlLCB0cmFja2VkKSB7XG4gICAgICAgIHZhciBwYXJzZWRCYXNlID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShtb2R1bGUpLFxuICAgICAgICAgICAgbmFtZSA9IHBhcnNlZEJhc2UubmFtZTtcblxuICAgICAgICB0cmFja2VkID0gdHJhY2tlZCB8fCB7fTtcblxuICAgICAgICBpZiAobmFtZSBpbiB0cmFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtb2R1bGUgPSBQbHVnaW4ucmVzb2x2ZShtb2R1bGUpIHx8IG1vZHVsZTtcblxuICAgICAgICB0cmFja2VkW25hbWVdID0gQ29tbW9uLm1hcChtb2R1bGUudXNlcyB8fCBbXSwgZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgaWYgKFBsdWdpbi5pc1BsdWdpbihkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgICAgIFBsdWdpbi5yZWdpc3RlcihkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IFBsdWdpbi5kZXBlbmRlbmN5UGFyc2UoZGVwZW5kZW5jeSksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBQbHVnaW4ucmVzb2x2ZShkZXBlbmRlbmN5KTtcblxuICAgICAgICAgICAgaWYgKHJlc29sdmVkICYmICFQbHVnaW4udmVyc2lvblNhdGlzZmllcyhyZXNvbHZlZC52ZXJzaW9uLCBwYXJzZWQucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICdQbHVnaW4uZGVwZW5kZW5jaWVzOicsIFBsdWdpbi50b1N0cmluZyhyZXNvbHZlZCksICdkb2VzIG5vdCBzYXRpc2Z5JyxcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luLnRvU3RyaW5nKHBhcnNlZCksICd1c2VkIGJ5JywgUGx1Z2luLnRvU3RyaW5nKHBhcnNlZEJhc2UpICsgJy4nXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmVkLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1vZHVsZS5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICdQbHVnaW4uZGVwZW5kZW5jaWVzOicsIFBsdWdpbi50b1N0cmluZyhkZXBlbmRlbmN5KSwgJ3VzZWQgYnknLFxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSksICdjb3VsZCBub3QgYmUgcmVzb2x2ZWQuJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQubmFtZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja2VkW25hbWVdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBQbHVnaW4uZGVwZW5kZW5jaWVzKHRyYWNrZWRbbmFtZV1baV0sIHRyYWNrZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYWNrZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGRlcGVuZGVuY3kgc3RyaW5nIGludG8gaXRzIGNvbXBvbmVudHMuXG4gICAgICogVGhlIGBkZXBlbmRlbmN5YCBpcyBhIHN0cmluZyBvZiB0aGUgZm9ybWF0IGAnbW9kdWxlLW5hbWUnYCBvciBgJ21vZHVsZS1uYW1lQHZlcnNpb24nYC5cbiAgICAgKiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgYFBsdWdpbi52ZXJzaW9uUGFyc2VgIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmb3JtYXQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYWxzbyBoYW5kbGUgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIGFscmVhZHkgcmVzb2x2ZWQgKGUuZy4gYSBtb2R1bGUgb2JqZWN0KS5cbiAgICAgKiBAbWV0aG9kIGRlcGVuZGVuY3lQYXJzZVxuICAgICAqIEBwYXJhbSBkZXBlbmRlbmN5IHtzdHJpbmd9IFRoZSBkZXBlbmRlbmN5IG9mIHRoZSBmb3JtYXQgYCdtb2R1bGUtbmFtZSdgIG9yIGAnbW9kdWxlLW5hbWVAdmVyc2lvbidgLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGRlcGVuZGVuY3kgcGFyc2VkIGludG8gaXRzIGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgUGx1Z2luLmRlcGVuZGVuY3lQYXJzZSA9IGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc1N0cmluZyhkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSAvXltcXHctXSsoQChcXCp8W1xcXn5dP1xcZCtcXC5cXGQrXFwuXFxkKygtWzAtOUEtWmEtei1dKyk/KSk/JC87XG5cbiAgICAgICAgICAgIGlmICghcGF0dGVybi50ZXN0KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5kZXBlbmRlbmN5UGFyc2U6JywgZGVwZW5kZW5jeSwgJ2lzIG5vdCBhIHZhbGlkIGRlcGVuZGVuY3kgc3RyaW5nLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kuc3BsaXQoJ0AnKVswXSxcbiAgICAgICAgICAgICAgICByYW5nZTogZGVwZW5kZW5jeS5zcGxpdCgnQCcpWzFdIHx8ICcqJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBkZXBlbmRlbmN5Lm5hbWUsXG4gICAgICAgICAgICByYW5nZTogZGVwZW5kZW5jeS5yYW5nZSB8fCBkZXBlbmRlbmN5LnZlcnNpb25cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgdmVyc2lvbiBzdHJpbmcgaW50byBpdHMgY29tcG9uZW50cy4gIFxuICAgICAqIFZlcnNpb25zIGFyZSBzdHJpY3RseSBvZiB0aGUgZm9ybWF0IGB4LnkuemAgKGFzIGluIFtzZW12ZXJdKGh0dHA6Ly9zZW12ZXIub3JnLykpLlxuICAgICAqIFZlcnNpb25zIG1heSBvcHRpb25hbGx5IGhhdmUgYSBwcmVyZWxlYXNlIHRhZyBpbiB0aGUgZm9ybWF0IGB4Lnkuei1hbHBoYWAuXG4gICAgICogUmFuZ2VzIGFyZSBhIHN0cmljdCBzdWJzZXQgb2YgW25wbSByYW5nZXNdKGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vbWlzYy9zZW12ZXIjYWR2YW5jZWQtcmFuZ2Utc3ludGF4KS5cbiAgICAgKiBPbmx5IHRoZSBmb2xsb3dpbmcgcmFuZ2UgdHlwZXMgYXJlIHN1cHBvcnRlZDpcbiAgICAgKiAtIFRpbGRlIHJhbmdlcyBlLmcuIGB+MS4yLjNgXG4gICAgICogLSBDYXJldCByYW5nZXMgZS5nLiBgXjEuMi4zYFxuICAgICAqIC0gRXhhY3QgdmVyc2lvbiBlLmcuIGAxLjIuM2BcbiAgICAgKiAtIEFueSB2ZXJzaW9uIGAqYFxuICAgICAqIEBtZXRob2QgdmVyc2lvblBhcnNlXG4gICAgICogQHBhcmFtIHJhbmdlIHtzdHJpbmd9IFRoZSB2ZXJzaW9uIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSB2ZXJzaW9uIHJhbmdlIHBhcnNlZCBpbnRvIGl0cyBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIFBsdWdpbi52ZXJzaW9uUGFyc2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IC9eXFwqfFtcXF5+XT9cXGQrXFwuXFxkK1xcLlxcZCsoLVswLTlBLVphLXotXSspPyQvO1xuXG4gICAgICAgIGlmICghcGF0dGVybi50ZXN0KHJhbmdlKSkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi52ZXJzaW9uUGFyc2U6JywgcmFuZ2UsICdpcyBub3QgYSB2YWxpZCB2ZXJzaW9uIG9yIHJhbmdlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gcmFuZ2Uuc3BsaXQoJy0nKTtcbiAgICAgICAgcmFuZ2UgPSBpZGVudGlmaWVyc1swXTtcblxuICAgICAgICB2YXIgaXNSYW5nZSA9IGlzTmFOKE51bWJlcihyYW5nZVswXSkpLFxuICAgICAgICAgICAgdmVyc2lvbiA9IGlzUmFuZ2UgPyByYW5nZS5zdWJzdHIoMSkgOiByYW5nZSxcbiAgICAgICAgICAgIHBhcnRzID0gQ29tbW9uLm1hcCh2ZXJzaW9uLnNwbGl0KCcuJyksIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHBhcnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzUmFuZ2U6IGlzUmFuZ2UsXG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGlzUmFuZ2UgPyByYW5nZVswXSA6ICcnLFxuICAgICAgICAgICAgcGFydHM6IHBhcnRzLFxuICAgICAgICAgICAgcHJlcmVsZWFzZTogaWRlbnRpZmllcnNbMV0sXG4gICAgICAgICAgICBudW1iZXI6IHBhcnRzWzBdICogMWU4ICsgcGFydHNbMV0gKiAxZTQgKyBwYXJ0c1syXVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIHRoZSBnaXZlbiBgcmFuZ2VgLlxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGZvciBgUGx1Z2luLnZlcnNpb25QYXJzZWAgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZvcm1hdC5cbiAgICAgKiBJZiBhIHZlcnNpb24gb3IgcmFuZ2UgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBhbnkgdmVyc2lvbiAoYCpgKSBpcyBhc3N1bWVkIHRvIHNhdGlzZnkuXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uU2F0aXNmaWVzXG4gICAgICogQHBhcmFtIHZlcnNpb24ge3N0cmluZ30gVGhlIHZlcnNpb24gc3RyaW5nLlxuICAgICAqIEBwYXJhbSByYW5nZSB7c3RyaW5nfSBUaGUgcmFuZ2Ugc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIGByYW5nZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzID0gZnVuY3Rpb24odmVyc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSByYW5nZSB8fCAnKic7XG5cbiAgICAgICAgdmFyIHJhbmdlUGFyc2VkID0gUGx1Z2luLnZlcnNpb25QYXJzZShyYW5nZSksXG4gICAgICAgICAgICByYW5nZVBhcnRzID0gcmFuZ2VQYXJzZWQucGFydHMsXG4gICAgICAgICAgICB2ZXJzaW9uUGFyc2VkID0gUGx1Z2luLnZlcnNpb25QYXJzZSh2ZXJzaW9uKSxcbiAgICAgICAgICAgIHZlcnNpb25QYXJ0cyA9IHZlcnNpb25QYXJzZWQucGFydHM7XG5cbiAgICAgICAgaWYgKHJhbmdlUGFyc2VkLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZVBhcnNlZC5vcGVyYXRvciA9PT0gJyonIHx8IHZlcnNpb24gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2VQYXJzZWQub3BlcmF0b3IgPT09ICd+Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uUGFydHNbMF0gPT09IHJhbmdlUGFydHNbMF0gJiYgdmVyc2lvblBhcnRzWzFdID09PSByYW5nZVBhcnRzWzFdICYmIHZlcnNpb25QYXJ0c1syXSA+PSByYW5nZVBhcnRzWzJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2VQYXJzZWQub3BlcmF0b3IgPT09ICdeJykge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVBhcnRzWzBdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzBdID09PSByYW5nZVBhcnRzWzBdICYmIHZlcnNpb25QYXJzZWQubnVtYmVyID49IHJhbmdlUGFyc2VkLm51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0c1sxXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25QYXJ0c1sxXSA9PT0gcmFuZ2VQYXJ0c1sxXSAmJiB2ZXJzaW9uUGFydHNbMl0gPj0gcmFuZ2VQYXJ0c1syXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzJdID09PSByYW5nZVBhcnRzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlcnNpb24gPT09IHJhbmdlIHx8IHZlcnNpb24gPT09ICcqJztcbiAgICB9O1xuXG59KSgpO1xuXG59LHtcIi4vQ29tbW9uXCI6MTR9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuUnVubmVyYCBtb2R1bGUgaXMgYW4gb3B0aW9uYWwgdXRpbGl0eSB3aGljaCBwcm92aWRlcyBhIGdhbWUgbG9vcCwgXG4qIHRoYXQgaGFuZGxlcyBjb250aW51b3VzbHkgdXBkYXRpbmcgYSBgTWF0dGVyLkVuZ2luZWAgZm9yIHlvdSB3aXRoaW4gYSBicm93c2VyLlxuKiBJdCBpcyBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBwdXJwb3NlcywgYnV0IG1heSBhbHNvIGJlIHN1aXRhYmxlIGZvciBzaW1wbGUgZ2FtZXMuXG4qIElmIHlvdSBhcmUgdXNpbmcgeW91ciBvd24gZ2FtZSBsb29wIGluc3RlYWQsIHRoZW4geW91IGRvIG5vdCBuZWVkIHRoZSBgTWF0dGVyLlJ1bm5lcmAgbW9kdWxlLlxuKiBJbnN0ZWFkIGp1c3QgY2FsbCBgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhKWAgaW4geW91ciBvd24gbG9vcC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFJ1bm5lclxuKi9cblxudmFyIFJ1bm5lciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcblxudmFyIEV2ZW50cyA9IF9kZXJlcV8oJy4vRXZlbnRzJyk7XG52YXIgRW5naW5lID0gX2RlcmVxXygnLi9FbmdpbmUnKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICBcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgIH1cblxuICAgIGlmICghX3JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB2YXIgX2ZyYW1lVGltZW91dDtcblxuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2speyBcbiAgICAgICAgICAgIF9mcmFtZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhDb21tb24ubm93KCkpOyBcbiAgICAgICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX2ZyYW1lVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBSdW5uZXIuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBSdW5uZXIuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBmcHM6IDYwLFxuICAgICAgICAgICAgY29ycmVjdGlvbjogMSxcbiAgICAgICAgICAgIGRlbHRhU2FtcGxlU2l6ZTogNjAsXG4gICAgICAgICAgICBjb3VudGVyVGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgZnJhbWVDb3VudGVyOiAwLFxuICAgICAgICAgICAgZGVsdGFIaXN0b3J5OiBbXSxcbiAgICAgICAgICAgIHRpbWVQcmV2OiBudWxsLFxuICAgICAgICAgICAgdGltZVNjYWxlUHJldjogMSxcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJ1bm5lciA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJ1bm5lci5kZWx0YSA9IHJ1bm5lci5kZWx0YSB8fCAxMDAwIC8gcnVubmVyLmZwcztcbiAgICAgICAgcnVubmVyLmRlbHRhTWluID0gcnVubmVyLmRlbHRhTWluIHx8IDEwMDAgLyBydW5uZXIuZnBzO1xuICAgICAgICBydW5uZXIuZGVsdGFNYXggPSBydW5uZXIuZGVsdGFNYXggfHwgMTAwMCAvIChydW5uZXIuZnBzICogMC41KTtcbiAgICAgICAgcnVubmVyLmZwcyA9IDEwMDAgLyBydW5uZXIuZGVsdGE7XG5cbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IHRpY2tzIGEgYE1hdHRlci5FbmdpbmVgIGJ5IGNhbGxpbmcgYFJ1bm5lci50aWNrYCBvbiB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgZXZlbnQuXG4gICAgICogQG1ldGhvZCBydW5cbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICovXG4gICAgUnVubmVyLnJ1biA9IGZ1bmN0aW9uKHJ1bm5lciwgZW5naW5lKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBydW5uZXIgaWYgZW5naW5lIGlzIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgIGlmICh0eXBlb2YgcnVubmVyLnBvc2l0aW9uSXRlcmF0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVuZ2luZSA9IHJ1bm5lcjtcbiAgICAgICAgICAgIHJ1bm5lciA9IFJ1bm5lci5jcmVhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIChmdW5jdGlvbiByZW5kZXIodGltZSl7XG4gICAgICAgICAgICBydW5uZXIuZnJhbWVSZXF1ZXN0SWQgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICYmIHJ1bm5lci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgUnVubmVyLnRpY2socnVubmVyLCBlbmdpbmUsIHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZ2FtZSBsb29wIHV0aWxpdHkgdGhhdCB1cGRhdGVzIHRoZSBlbmdpbmUgYW5kIHJlbmRlcmVyIGJ5IG9uZSBzdGVwIChhICd0aWNrJykuXG4gICAgICogRmVhdHVyZXMgZGVsdGEgc21vb3RoaW5nLCB0aW1lIGNvcnJlY3Rpb24gYW5kIGZpeGVkIG9yIGR5bmFtaWMgdGltaW5nLlxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVUaWNrYCwgYHRpY2tgIGFuZCBgYWZ0ZXJUaWNrYCBldmVudHMgb24gdGhlIGVuZ2luZS5cbiAgICAgKiBDb25zaWRlciBqdXN0IGBFbmdpbmUudXBkYXRlKGVuZ2luZSwgZGVsdGEpYCBpZiB5b3UncmUgdXNpbmcgeW91ciBvd24gbG9vcC5cbiAgICAgKiBAbWV0aG9kIHRpY2tcbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gICAgICovXG4gICAgUnVubmVyLnRpY2sgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSwgdGltZSkge1xuICAgICAgICB2YXIgdGltaW5nID0gZW5naW5lLnRpbWluZyxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gPSAxLFxuICAgICAgICAgICAgZGVsdGE7XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGV2ZW50IG9iamVjdFxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWluZy50aW1lc3RhbXBcbiAgICAgICAgfTtcblxuICAgICAgICBFdmVudHMudHJpZ2dlcihydW5uZXIsICdiZWZvcmVUaWNrJywgZXZlbnQpO1xuICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdiZWZvcmVUaWNrJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxuXG4gICAgICAgIGlmIChydW5uZXIuaXNGaXhlZCkge1xuICAgICAgICAgICAgLy8gZml4ZWQgdGltZXN0ZXBcbiAgICAgICAgICAgIGRlbHRhID0gcnVubmVyLmRlbHRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHluYW1pYyB0aW1lc3RlcCBiYXNlZCBvbiB3YWxsIGNsb2NrIGJldHdlZW4gY2FsbHNcbiAgICAgICAgICAgIGRlbHRhID0gKHRpbWUgLSBydW5uZXIudGltZVByZXYpIHx8IHJ1bm5lci5kZWx0YTtcbiAgICAgICAgICAgIHJ1bm5lci50aW1lUHJldiA9IHRpbWU7XG5cbiAgICAgICAgICAgIC8vIG9wdGltaXN0aWNhbGx5IGZpbHRlciBkZWx0YSBvdmVyIGEgZmV3IGZyYW1lcywgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICAgICAgICAgIHJ1bm5lci5kZWx0YUhpc3RvcnkucHVzaChkZWx0YSk7XG4gICAgICAgICAgICBydW5uZXIuZGVsdGFIaXN0b3J5ID0gcnVubmVyLmRlbHRhSGlzdG9yeS5zbGljZSgtcnVubmVyLmRlbHRhU2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICBkZWx0YSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHJ1bm5lci5kZWx0YUhpc3RvcnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBsaW1pdCBkZWx0YVxuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA8IHJ1bm5lci5kZWx0YU1pbiA/IHJ1bm5lci5kZWx0YU1pbiA6IGRlbHRhO1xuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA+IHJ1bm5lci5kZWx0YU1heCA/IHJ1bm5lci5kZWx0YU1heCA6IGRlbHRhO1xuXG4gICAgICAgICAgICAvLyBjb3JyZWN0aW9uIGZvciBkZWx0YVxuICAgICAgICAgICAgY29ycmVjdGlvbiA9IGRlbHRhIC8gcnVubmVyLmRlbHRhO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgZW5naW5lIHRpbWluZyBvYmplY3RcbiAgICAgICAgICAgIHJ1bm5lci5kZWx0YSA9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGltZSBjb3JyZWN0aW9uIGZvciB0aW1lIHNjYWxpbmdcbiAgICAgICAgaWYgKHJ1bm5lci50aW1lU2NhbGVQcmV2ICE9PSAwKVxuICAgICAgICAgICAgY29ycmVjdGlvbiAqPSB0aW1pbmcudGltZVNjYWxlIC8gcnVubmVyLnRpbWVTY2FsZVByZXY7XG5cbiAgICAgICAgaWYgKHRpbWluZy50aW1lU2NhbGUgPT09IDApXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gMDtcblxuICAgICAgICBydW5uZXIudGltZVNjYWxlUHJldiA9IHRpbWluZy50aW1lU2NhbGU7XG4gICAgICAgIHJ1bm5lci5jb3JyZWN0aW9uID0gY29ycmVjdGlvbjtcblxuICAgICAgICAvLyBmcHMgY291bnRlclxuICAgICAgICBydW5uZXIuZnJhbWVDb3VudGVyICs9IDE7XG4gICAgICAgIGlmICh0aW1lIC0gcnVubmVyLmNvdW50ZXJUaW1lc3RhbXAgPj0gMTAwMCkge1xuICAgICAgICAgICAgcnVubmVyLmZwcyA9IHJ1bm5lci5mcmFtZUNvdW50ZXIgKiAoKHRpbWUgLSBydW5uZXIuY291bnRlclRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb3VudGVyVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZUNvdW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAndGljaycsIGV2ZW50KTtcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAndGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcblxuICAgICAgICAvLyBpZiB3b3JsZCBoYXMgYmVlbiBtb2RpZmllZCwgY2xlYXIgdGhlIHJlbmRlciBzY2VuZSBncmFwaFxuICAgICAgICBpZiAoZW5naW5lLndvcmxkLmlzTW9kaWZpZWQgXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXJcbiAgICAgICAgICAgICYmIGVuZ2luZS5yZW5kZXIuY29udHJvbGxlci5jbGVhcikge1xuICAgICAgICAgICAgZW5naW5lLnJlbmRlci5jb250cm9sbGVyLmNsZWFyKGVuZ2luZS5yZW5kZXIpOyAvLyBAZGVwcmVjYXRlZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVVwZGF0ZScsIGV2ZW50KTtcbiAgICAgICAgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJVcGRhdGUnLCBldmVudCk7XG5cbiAgICAgICAgLy8gcmVuZGVyXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXG4gICAgICAgIGlmIChlbmdpbmUucmVuZGVyICYmIGVuZ2luZS5yZW5kZXIuY29udHJvbGxlcikge1xuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxuXG4gICAgICAgICAgICBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIud29ybGQoZW5naW5lLnJlbmRlcik7XG5cbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYWZ0ZXJSZW5kZXInLCBldmVudCk7IC8vIEBkZXByZWNhdGVkXG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihydW5uZXIsICdhZnRlclRpY2snLCBldmVudCk7XG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5kcyBleGVjdXRpb24gb2YgYFJ1bm5lci5ydW5gIG9uIHRoZSBnaXZlbiBgcnVubmVyYCwgYnkgY2FuY2VsaW5nIHRoZSBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBldmVudCBsb29wLlxuICAgICAqIElmIHlvdSB3aXNoIHRvIG9ubHkgdGVtcG9yYXJpbHkgcGF1c2UgdGhlIGVuZ2luZSwgc2VlIGBlbmdpbmUuZW5hYmxlZGAgaW5zdGVhZC5cbiAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICovXG4gICAgUnVubmVyLnN0b3AgPSBmdW5jdGlvbihydW5uZXIpIHtcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lKHJ1bm5lci5mcmFtZVJlcXVlc3RJZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgUnVubmVyLnJ1bmAuXG4gICAgICogQG1ldGhvZCBzdGFydFxuICAgICAqIEBwYXJhbSB7cnVubmVyfSBydW5uZXJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICovXG4gICAgUnVubmVyLnN0YXJ0ID0gZnVuY3Rpb24ocnVubmVyLCBlbmdpbmUpIHtcbiAgICAgICAgUnVubmVyLnJ1bihydW5uZXIsIGVuZ2luZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGF0IHRoZSBzdGFydCBvZiBhIHRpY2ssIGJlZm9yZSBhbnkgdXBkYXRlcyB0byB0aGUgZW5naW5lIG9yIHRpbWluZ1xuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVUaWNrXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdGltaW5nIHVwZGF0ZWQsIGJ1dCBqdXN0IGJlZm9yZSB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgdGlja1xuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYXQgdGhlIGVuZCBvZiBhIHRpY2ssIGFmdGVyIGVuZ2luZSB1cGRhdGUgYW5kIGFmdGVyIHJlbmRlcmluZ1xuICAgICpcbiAgICAqIEBldmVudCBhZnRlclRpY2tcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGJlZm9yZSB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlVXBkYXRlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgYWZ0ZXJVcGRhdGVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGJlZm9yZSByZW5kZXJpbmdcbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqIEBkZXByZWNhdGVkXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqIEBkZXByZWNhdGVkXG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHJ1bm5lciBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvb2xlYW5gIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBydW5uZXIgc2hvdWxkIHVzZSBhIGZpeGVkIHRpbWVzdGVwIChvdGhlcndpc2UgaXQgaXMgdmFyaWFibGUpLlxuICAgICAqIElmIHRpbWluZyBpcyBmaXhlZCwgdGhlbiB0aGUgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZCB3aWxsIGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGZyYW1lIHJhdGUgKGJ1dCBiZWhhdmlvdXIgd2lsbCBiZSBkZXRlcm1pbmlzdGljKS5cbiAgICAgKiBJZiB0aGUgdGltaW5nIGlzIHZhcmlhYmxlLCB0aGVuIHRoZSBhcHBhcmVudCBzaW11bGF0aW9uIHNwZWVkIHdpbGwgYmUgY29uc3RhbnQgKGFwcHJveGltYXRlbHksIGJ1dCBhdCB0aGUgY29zdCBvZiBkZXRlcm1pbmluaXNtKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc0ZpeGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0aW1lIHN0ZXAgYmV0d2VlbiB1cGRhdGVzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBJZiBgZW5naW5lLnRpbWluZy5pc0ZpeGVkYCBpcyBzZXQgdG8gYHRydWVgLCB0aGVuIGBkZWx0YWAgaXMgZml4ZWQuXG4gICAgICogSWYgaXQgaXMgYGZhbHNlYCwgdGhlbiBgZGVsdGFgIGNhbiBkeW5hbWljYWxseSBjaGFuZ2UgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkZWx0YVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDEwMDAgLyA2MFxuICAgICAqL1xuXG59KSgpO1xuXG59LHtcIi4vQ29tbW9uXCI6MTQsXCIuL0VuZ2luZVwiOjE1LFwiLi9FdmVudHNcIjoxNn1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgdG8gbWFuYWdlIHRoZSBzbGVlcGluZyBzdGF0ZSBvZiBib2RpZXMuXG4qXG4qIEBjbGFzcyBTbGVlcGluZ1xuKi9cblxudmFyIFNsZWVwaW5nID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gU2xlZXBpbmc7XG5cbnZhciBFdmVudHMgPSBfZGVyZXFfKCcuL0V2ZW50cycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBTbGVlcGluZy5fbW90aW9uV2FrZVRocmVzaG9sZCA9IDAuMTg7XG4gICAgU2xlZXBpbmcuX21vdGlvblNsZWVwVGhyZXNob2xkID0gMC4wODtcbiAgICBTbGVlcGluZy5fbWluQmlhcyA9IDAuOTtcblxuICAgIC8qKlxuICAgICAqIFB1dHMgYm9kaWVzIHRvIHNsZWVwIG9yIHdha2VzIHRoZW0gdXAgZGVwZW5kaW5nIG9uIHRoZWlyIG1vdGlvbi5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXG4gICAgICovXG4gICAgU2xlZXBpbmcudXBkYXRlID0gZnVuY3Rpb24oYm9kaWVzLCB0aW1lU2NhbGUpIHtcbiAgICAgICAgdmFyIHRpbWVGYWN0b3IgPSB0aW1lU2NhbGUgKiB0aW1lU2NhbGUgKiB0aW1lU2NhbGU7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJvZGllcyBzbGVlcGluZyBzdGF0dXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIG1vdGlvbiA9IGJvZHkuc3BlZWQgKiBib2R5LnNwZWVkICsgYm9keS5hbmd1bGFyU3BlZWQgKiBib2R5LmFuZ3VsYXJTcGVlZDtcblxuICAgICAgICAgICAgLy8gd2FrZSB1cCBib2RpZXMgaWYgdGhleSBoYXZlIGEgZm9yY2UgYXBwbGllZFxuICAgICAgICAgICAgaWYgKGJvZHkuZm9yY2UueCAhPT0gMCB8fCBib2R5LmZvcmNlLnkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWluTW90aW9uID0gTWF0aC5taW4oYm9keS5tb3Rpb24sIG1vdGlvbiksXG4gICAgICAgICAgICAgICAgbWF4TW90aW9uID0gTWF0aC5tYXgoYm9keS5tb3Rpb24sIG1vdGlvbik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gYmlhc2VkIGF2ZXJhZ2UgbW90aW9uIGVzdGltYXRpb24gYmV0d2VlbiBmcmFtZXNcbiAgICAgICAgICAgIGJvZHkubW90aW9uID0gU2xlZXBpbmcuX21pbkJpYXMgKiBtaW5Nb3Rpb24gKyAoMSAtIFNsZWVwaW5nLl9taW5CaWFzKSAqIG1heE1vdGlvbjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGJvZHkuc2xlZXBUaHJlc2hvbGQgPiAwICYmIGJvZHkubW90aW9uIDwgU2xlZXBpbmcuX21vdGlvblNsZWVwVGhyZXNob2xkICogdGltZUZhY3Rvcikge1xuICAgICAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuc2xlZXBDb3VudGVyID49IGJvZHkuc2xlZXBUaHJlc2hvbGQpXG4gICAgICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYm9keS5zbGVlcENvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBjb2xsaWRpbmcgcGFpcnMsIHdha2VzIHRoZSBzbGVlcGluZyBib2RpZXMgaW52b2x2ZWQuXG4gICAgICogQG1ldGhvZCBhZnRlckNvbGxpc2lvbnNcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXG4gICAgICovXG4gICAgU2xlZXBpbmcuYWZ0ZXJDb2xsaXNpb25zID0gZnVuY3Rpb24ocGFpcnMsIHRpbWVTY2FsZSkge1xuICAgICAgICB2YXIgdGltZUZhY3RvciA9IHRpbWVTY2FsZSAqIHRpbWVTY2FsZSAqIHRpbWVTY2FsZTtcblxuICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGRvbid0IHdha2UgaW5hY3RpdmUgcGFpcnNcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBLnBhcmVudCwgXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUIucGFyZW50O1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGRvbid0IHdha2UgaWYgYXQgbGVhc3Qgb25lIGJvZHkgaXMgc3RhdGljXG4gICAgICAgICAgICBpZiAoKGJvZHlBLmlzU2xlZXBpbmcgJiYgYm9keUIuaXNTbGVlcGluZykgfHwgYm9keUEuaXNTdGF0aWMgfHwgYm9keUIuaXNTdGF0aWMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU2xlZXBpbmcgfHwgYm9keUIuaXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIHZhciBzbGVlcGluZ0JvZHkgPSAoYm9keUEuaXNTbGVlcGluZyAmJiAhYm9keUEuaXNTdGF0aWMpID8gYm9keUEgOiBib2R5QixcbiAgICAgICAgICAgICAgICAgICAgbW92aW5nQm9keSA9IHNsZWVwaW5nQm9keSA9PT0gYm9keUEgPyBib2R5QiA6IGJvZHlBO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzbGVlcGluZ0JvZHkuaXNTdGF0aWMgJiYgbW92aW5nQm9keS5tb3Rpb24gPiBTbGVlcGluZy5fbW90aW9uV2FrZVRocmVzaG9sZCAqIHRpbWVGYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KHNsZWVwaW5nQm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8qKlxuICAgICAqIFNldCBhIGJvZHkgYXMgc2xlZXBpbmcgb3IgYXdha2UuXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2xlZXBpbmdcbiAgICAgKi9cbiAgICBTbGVlcGluZy5zZXQgPSBmdW5jdGlvbihib2R5LCBpc1NsZWVwaW5nKSB7XG4gICAgICAgIHZhciB3YXNTbGVlcGluZyA9IGJvZHkuaXNTbGVlcGluZztcblxuICAgICAgICBpZiAoaXNTbGVlcGluZykge1xuICAgICAgICAgICAgYm9keS5pc1NsZWVwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyID0gYm9keS5zbGVlcFRocmVzaG9sZDtcblxuICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueCA9IDA7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS55ID0gMDtcblxuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGJvZHkucG9zaXRpb24ueDtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgIGJvZHkuYW5nbGVQcmV2ID0gYm9keS5hbmdsZTtcbiAgICAgICAgICAgIGJvZHkuc3BlZWQgPSAwO1xuICAgICAgICAgICAgYm9keS5hbmd1bGFyU3BlZWQgPSAwO1xuICAgICAgICAgICAgYm9keS5tb3Rpb24gPSAwO1xuXG4gICAgICAgICAgICBpZiAoIXdhc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoYm9keSwgJ3NsZWVwU3RhcnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkuaXNTbGVlcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgPSAwO1xuXG4gICAgICAgICAgICBpZiAod2FzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihib2R5LCAnc2xlZXBFbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi9FdmVudHNcIjoxNn1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuKiBUaGUgYE1hdHRlci5Cb2RpZXNgIG1vZHVsZSBjb250YWlucyBmYWN0b3J5IG1ldGhvZHMgZm9yIGNyZWF0aW5nIHJpZ2lkIGJvZHkgbW9kZWxzIFxuKiB3aXRoIGNvbW1vbmx5IHVzZWQgYm9keSBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyByZWN0YW5nbGVzLCBjaXJjbGVzIGFuZCBvdGhlciBwb2x5Z29ucykuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBCb2RpZXNcbiovXG5cbi8vIFRPRE86IHRydWUgY2lyY2xlIGJvZGllc1xuXG52YXIgQm9kaWVzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQm9kaWVzO1xuXG52YXIgVmVydGljZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIENvbW1vbiA9IF9kZXJlcV8oJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL2JvZHkvQm9keScpO1xudmFyIEJvdW5kcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xudmFyIFZlY3RvciA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIGRlY29tcDtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWN0YW5nbGUgaHVsbC4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyByZWN0YW5nbGUgYm9keVxuICAgICAqL1xuICAgIEJvZGllcy5yZWN0YW5nbGUgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciByZWN0YW5nbGUgPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdSZWN0YW5nbGUgQm9keScsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgoJ0wgMCAwIEwgJyArIHdpZHRoICsgJyAwIEwgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0ICsgJyBMIDAgJyArIGhlaWdodClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XG4gICAgICAgICAgICB2YXIgY2hhbWZlciA9IG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgICAgIHJlY3RhbmdsZS52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNoYW1mZXIocmVjdGFuZ2xlLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFtZmVyLnF1YWxpdHksIGNoYW1mZXIucXVhbGl0eU1pbiwgY2hhbWZlci5xdWFsaXR5TWF4KTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7fSwgcmVjdGFuZ2xlLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwgd2l0aCBhIHRyYXBlem9pZCBodWxsLiBcbiAgICAgKiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIHRyYXBlem9pZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3BlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHRyYXBlem9pZCBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLnRyYXBlem9pZCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIHNsb3BlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHNsb3BlICo9IDAuNTtcbiAgICAgICAgdmFyIHJvb2YgPSAoMSAtIChzbG9wZSAqIDIpKSAqIHdpZHRoO1xuICAgICAgICBcbiAgICAgICAgdmFyIHgxID0gd2lkdGggKiBzbG9wZSxcbiAgICAgICAgICAgIHgyID0geDEgKyByb29mLFxuICAgICAgICAgICAgeDMgPSB4MiArIHgxLFxuICAgICAgICAgICAgdmVydGljZXNQYXRoO1xuXG4gICAgICAgIGlmIChzbG9wZSA8IDAuNSkge1xuICAgICAgICAgICAgdmVydGljZXNQYXRoID0gJ0wgMCAwIEwgJyArIHgxICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MiArICcgJyArICgtaGVpZ2h0KSArICcgTCAnICsgeDMgKyAnIDAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVydGljZXNQYXRoID0gJ0wgMCAwIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhcGV6b2lkID0geyBcbiAgICAgICAgICAgIGxhYmVsOiAnVHJhcGV6b2lkIEJvZHknLFxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogeCwgeTogeSB9LFxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKHZlcnRpY2VzUGF0aClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XG4gICAgICAgICAgICB2YXIgY2hhbWZlciA9IG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgICAgIHRyYXBlem9pZC52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNoYW1mZXIodHJhcGV6b2lkLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFtZmVyLnF1YWxpdHksIGNoYW1mZXIucXVhbGl0eU1pbiwgY2hhbWZlci5xdWFsaXR5TWF4KTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7fSwgdHJhcGV6b2lkLCBvcHRpb25zKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQgYm9keSBtb2RlbCB3aXRoIGEgY2lyY2xlIGh1bGwuIFxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhTaWRlc11cbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyBjaXJjbGUgYm9keVxuICAgICAqL1xuICAgIEJvZGllcy5jaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIG9wdGlvbnMsIG1heFNpZGVzKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBjaXJjbGUgPSB7XG4gICAgICAgICAgICBsYWJlbDogJ0NpcmNsZSBCb2R5JyxcbiAgICAgICAgICAgIGNpcmNsZVJhZGl1czogcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBhcHByb3hpbWF0ZSBjaXJjbGVzIHdpdGggcG9seWdvbnMgdW50aWwgdHJ1ZSBjaXJjbGVzIGltcGxlbWVudGVkIGluIFNBVFxuICAgICAgICBtYXhTaWRlcyA9IG1heFNpZGVzIHx8IDI1O1xuICAgICAgICB2YXIgc2lkZXMgPSBNYXRoLmNlaWwoTWF0aC5tYXgoMTAsIE1hdGgubWluKG1heFNpZGVzLCByYWRpdXMpKSk7XG5cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uOiBhbHdheXMgdXNlIGV2ZW4gbnVtYmVyIG9mIHNpZGVzIChoYWxmIHRoZSBudW1iZXIgb2YgdW5pcXVlIGF4ZXMpXG4gICAgICAgIGlmIChzaWRlcyAlIDIgPT09IDEpXG4gICAgICAgICAgICBzaWRlcyArPSAxO1xuXG4gICAgICAgIHJldHVybiBCb2RpZXMucG9seWdvbih4LCB5LCBzaWRlcywgcmFkaXVzLCBDb21tb24uZXh0ZW5kKHt9LCBjaXJjbGUsIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWd1bGFyIHBvbHlnb24gaHVsbCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygc2lkZXMuIFxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgcG9seWdvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lkZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHJlZ3VsYXIgcG9seWdvbiBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLnBvbHlnb24gPSBmdW5jdGlvbih4LCB5LCBzaWRlcywgcmFkaXVzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChzaWRlcyA8IDMpXG4gICAgICAgICAgICByZXR1cm4gQm9kaWVzLmNpcmNsZSh4LCB5LCByYWRpdXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gc2lkZXMsXG4gICAgICAgICAgICBwYXRoID0gJycsXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGV0YSAqIDAuNTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IG9mZnNldCArIChpICogdGhldGEpLFxuICAgICAgICAgICAgICAgIHh4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgICAgICAgICAgIHl5ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuXG4gICAgICAgICAgICBwYXRoICs9ICdMICcgKyB4eC50b0ZpeGVkKDMpICsgJyAnICsgeXkudG9GaXhlZCgzKSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2x5Z29uID0geyBcbiAgICAgICAgICAgIGxhYmVsOiAnUG9seWdvbiBCb2R5JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBWZXJ0aWNlcy5mcm9tUGF0aChwYXRoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW1mZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICAgICAgcG9seWdvbi52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNoYW1mZXIocG9seWdvbi52ZXJ0aWNlcywgY2hhbWZlci5yYWRpdXMsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbWZlci5xdWFsaXR5LCBjaGFtZmVyLnF1YWxpdHlNaW4sIGNoYW1mZXIucXVhbGl0eU1heCk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoe30sIHBvbHlnb24sIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJvZHkgdXNpbmcgdGhlIHN1cHBsaWVkIHZlcnRpY2VzIChvciBhbiBhcnJheSBjb250YWluaW5nIG11bHRpcGxlIHNldHMgb2YgdmVydGljZXMpLlxuICAgICAqIElmIHRoZSB2ZXJ0aWNlcyBhcmUgY29udmV4LCB0aGV5IHdpbGwgcGFzcyB0aHJvdWdoIGFzIHN1cHBsaWVkLlxuICAgICAqIE90aGVyd2lzZSBpZiB0aGUgdmVydGljZXMgYXJlIGNvbmNhdmUsIHRoZXkgd2lsbCBiZSBkZWNvbXBvc2VkIGlmIFtwb2x5LWRlY29tcC5qc10oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBpcyBhdmFpbGFibGUuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcHJvY2VzcyBpcyBub3QgZ3VhcmFudGVlZCB0byBzdXBwb3J0IGNvbXBsZXggc2V0cyBvZiB2ZXJ0aWNlcyAoZS5nLiB0aG9zZSB3aXRoIGhvbGVzIG1heSBmYWlsKS5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBkZWNvbXBvc2l0aW9uIHdpbGwgZGlzY2FyZCBjb2xsaW5lYXIgZWRnZXMgKHRvIGltcHJvdmUgcGVyZm9ybWFuY2UpLlxuICAgICAqIEl0IGNhbiBhbHNvIG9wdGlvbmFsbHkgZGlzY2FyZCBhbnkgcGFydHMgdGhhdCBoYXZlIGFuIGFyZWEgbGVzcyB0aGFuIGBtaW5pbXVtQXJlYWAuXG4gICAgICogSWYgdGhlIHZlcnRpY2VzIGNhbiBub3QgYmUgZGVjb21wb3NlZCwgdGhlIHJlc3VsdCB3aWxsIGZhbGwgYmFjayB0byB1c2luZyB0aGUgY29udmV4IGh1bGwuXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgYE1hdHRlci5Cb2R5YCBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gW1t2ZWN0b3JdXSB2ZXJ0ZXhTZXRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2ZsYWdJbnRlcm5hbD1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JlbW92ZUNvbGxpbmVhcj0wLjAxXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluaW11bUFyZWE9MTBdXG4gICAgICogQHJldHVybiB7Ym9keX1cbiAgICAgKi9cbiAgICBCb2RpZXMuZnJvbVZlcnRpY2VzID0gZnVuY3Rpb24oeCwgeSwgdmVydGV4U2V0cywgb3B0aW9ucywgZmxhZ0ludGVybmFsLCByZW1vdmVDb2xsaW5lYXIsIG1pbmltdW1BcmVhKSB7XG4gICAgICAgIGlmICghZGVjb21wKSB7XG4gICAgICAgICAgICBkZWNvbXAgPSBDb21tb24uX3JlcXVpcmVHbG9iYWwoJ2RlY29tcCcsICdwb2x5LWRlY29tcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvZHksXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIGlzQ29udmV4LFxuICAgICAgICAgICAgdmVydGljZXMsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgejtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcGFydHMgPSBbXTtcblxuICAgICAgICBmbGFnSW50ZXJuYWwgPSB0eXBlb2YgZmxhZ0ludGVybmFsICE9PSAndW5kZWZpbmVkJyA/IGZsYWdJbnRlcm5hbCA6IGZhbHNlO1xuICAgICAgICByZW1vdmVDb2xsaW5lYXIgPSB0eXBlb2YgcmVtb3ZlQ29sbGluZWFyICE9PSAndW5kZWZpbmVkJyA/IHJlbW92ZUNvbGxpbmVhciA6IDAuMDE7XG4gICAgICAgIG1pbmltdW1BcmVhID0gdHlwZW9mIG1pbmltdW1BcmVhICE9PSAndW5kZWZpbmVkJyA/IG1pbmltdW1BcmVhIDogMTA7XG5cbiAgICAgICAgaWYgKCFkZWNvbXApIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdCb2RpZXMuZnJvbVZlcnRpY2VzOiBwb2x5LWRlY29tcC5qcyByZXF1aXJlZC4gQ291bGQgbm90IGRlY29tcG9zZSB2ZXJ0aWNlcy4gRmFsbGJhY2sgdG8gY29udmV4IGh1bGwuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdmVydGV4U2V0cyBpcyBhbiBhcnJheSBvZiBhcnJheXNcbiAgICAgICAgaWYgKCFDb21tb24uaXNBcnJheSh2ZXJ0ZXhTZXRzWzBdKSkge1xuICAgICAgICAgICAgdmVydGV4U2V0cyA9IFt2ZXJ0ZXhTZXRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodiA9IDA7IHYgPCB2ZXJ0ZXhTZXRzLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRleFNldHNbdl07XG4gICAgICAgICAgICBpc0NvbnZleCA9IFZlcnRpY2VzLmlzQ29udmV4KHZlcnRpY2VzKTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udmV4IHx8ICFkZWNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb252ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0KHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBjb252ZXggaHVsbCB3aGVuIGRlY29tcG9zaXRpb24gaXMgbm90IHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gVmVydGljZXMuaHVsbCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYSBkZWNvbXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGNvbmNhdmUgPSB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmVydGV4LngsIHZlcnRleC55XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2VzIGFyZSBjb25jYXZlIGFuZCBzaW1wbGUsIHdlIGNhbiBkZWNvbXBvc2UgaW50byBwYXJ0c1xuICAgICAgICAgICAgICAgIGRlY29tcC5tYWtlQ0NXKGNvbmNhdmUpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVDb2xsaW5lYXIgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBkZWNvbXAucmVtb3ZlQ29sbGluZWFyUG9pbnRzKGNvbmNhdmUsIHJlbW92ZUNvbGxpbmVhcik7XG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHF1aWNrIGRlY29tcG9zaXRpb24gYWxnb3JpdGhtIChCYXlheml0KVxuICAgICAgICAgICAgICAgIHZhciBkZWNvbXBvc2VkID0gZGVjb21wLnF1aWNrRGVjb21wKGNvbmNhdmUpO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggZGVjb21wb3NlZCBjaHVua1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWNvbXBvc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IGRlY29tcG9zZWRbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB2ZXJ0aWNlcyBpbnRvIHRoZSBjb3JyZWN0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtWZXJ0aWNlcyA9IGNodW5rLm1hcChmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB2ZXJ0aWNlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNlc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBzbWFsbCBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltdW1BcmVhID4gMCAmJiBWZXJ0aWNlcy5hcmVhKGNodW5rVmVydGljZXMpIDwgbWluaW11bUFyZWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb21wb3VuZCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFZlcnRpY2VzLmNlbnRyZShjaHVua1ZlcnRpY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzOiBjaHVua1ZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBib2R5IHBhcnRzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHNbaV0gPSBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHBhcnRzW2ldLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmbGFnIGludGVybmFsIGVkZ2VzIChjb2luY2lkZW50IHBhcnQgZWRnZXMpXG4gICAgICAgIGlmIChmbGFnSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciBjb2luY2lkZW50X21heF9kaXN0ID0gNTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gcGFydHNbaV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IHBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMocGFydEEuYm91bmRzLCBwYXJ0Qi5ib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF2ID0gcGFydEEudmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGJ2ID0gcGFydEIudmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdmVydGljZXMgb2YgYm90aCBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnRBLnZlcnRpY2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8IHBhcnRCLnZlcnRpY2VzLmxlbmd0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYSA9IFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkKFZlY3Rvci5zdWIocGF2WyhrICsgMSkgJSBwYXYubGVuZ3RoXSwgcGJ2W3pdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYiA9IFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkKFZlY3Rvci5zdWIocGF2W2tdLCBwYnZbKHogKyAxKSAlIHBidi5sZW5ndGhdKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYm90aCB2ZXJ0aWNlcyBhcmUgdmVyeSBjbG9zZSwgY29uc2lkZXIgdGhlIGVkZ2UgY29uY2lkZW50IChpbnRlcm5hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhIDwgY29pbmNpZGVudF9tYXhfZGlzdCAmJiBkYiA8IGNvaW5jaWRlbnRfbWF4X2Rpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdltrXS5pc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBidlt6XS5pc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcGFyZW50IGJvZHkgdG8gYmUgcmV0dXJuZWQsIHRoYXQgY29udGFpbnMgZ2VuZXJhdGVkIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBib2R5ID0gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IHBhcnRzOiBwYXJ0cy5zbGljZSgwKSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHsgeDogeCwgeTogeSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG59LHtcIi4uL2JvZHkvQm9keVwiOjEsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuLi9nZW9tZXRyeS9WZWN0b3JcIjoyOCxcIi4uL2dlb21ldHJ5L1ZlcnRpY2VzXCI6Mjl9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuQ29tcG9zaXRlc2AgbW9kdWxlIGNvbnRhaW5zIGZhY3RvcnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGJvZGllc1xuKiB3aXRoIGNvbW1vbmx5IHVzZWQgY29uZmlndXJhdGlvbnMgKHN1Y2ggYXMgc3RhY2tzIGFuZCBjaGFpbnMpLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgQ29tcG9zaXRlc1xuKi9cblxudmFyIENvbXBvc2l0ZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGVzO1xuXG52YXIgQ29tcG9zaXRlID0gX2RlcmVxXygnLi4vYm9keS9Db21wb3NpdGUnKTtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludC9Db25zdHJhaW50Jyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vYm9keS9Cb2R5Jyk7XG52YXIgQm9kaWVzID0gX2RlcmVxXygnLi9Cb2RpZXMnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIGJvZGllcyBjcmVhdGVkIGluIHRoZSBjYWxsYmFjayBpbiBhIGdyaWQgYXJyYW5nZW1lbnQuXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBib2R5J3MgYm91bmRzIHRvIHByZXZlbnQgb3ZlcmxhcHMuXG4gICAgICogQG1ldGhvZCBzdGFja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5zdGFjayA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdGFjayA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ1N0YWNrJyB9KSxcbiAgICAgICAgICAgIHggPSB4eCxcbiAgICAgICAgICAgIHkgPSB5eSxcbiAgICAgICAgICAgIGxhc3RCb2R5LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjb2x1bW5zOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gY2FsbGJhY2soeCwgeSwgY29sdW1uLCByb3csIGxhc3RCb2R5LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlIZWlnaHQgPSBib2R5LmJvdW5kcy5tYXgueSAtIGJvZHkuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVdpZHRoID0gYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueDsgXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlIZWlnaHQgPiBtYXhIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBib2R5SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQm9keS50cmFuc2xhdGUoYm9keSwgeyB4OiBib2R5V2lkdGggKiAwLjUsIHk6IGJvZHlIZWlnaHQgKiAwLjUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IGJvZHkuYm91bmRzLm1heC54ICsgY29sdW1uR2FwO1xuXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KHN0YWNrLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxhc3RCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gY29sdW1uR2FwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgeSArPSBtYXhIZWlnaHQgKyByb3dHYXA7XG4gICAgICAgICAgICB4ID0geHg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDaGFpbnMgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gY29tcG9zaXRlIHRvZ2V0aGVyIHVzaW5nIGNvbnN0cmFpbnRzLlxuICAgICAqIEBtZXRob2QgY2hhaW5cbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXRBXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRBXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXRCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRCXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjaGFpbmVkIHRvZ2V0aGVyIHdpdGggY29uc3RyYWludHNcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLmNoYWluID0gZnVuY3Rpb24oY29tcG9zaXRlLCB4T2Zmc2V0QSwgeU9mZnNldEEsIHhPZmZzZXRCLCB5T2Zmc2V0Qiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcztcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaSAtIDFdLFxuICAgICAgICAgICAgICAgIGJvZHlCID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGJvZHlBSGVpZ2h0ID0gYm9keUEuYm91bmRzLm1heC55IC0gYm9keUEuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvZHlBV2lkdGggPSBib2R5QS5ib3VuZHMubWF4LnggLSBib2R5QS5ib3VuZHMubWluLngsIFxuICAgICAgICAgICAgICAgIGJvZHlCSGVpZ2h0ID0gYm9keUIuYm91bmRzLm1heC55IC0gYm9keUIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvZHlCV2lkdGggPSBib2R5Qi5ib3VuZHMubWF4LnggLSBib2R5Qi5ib3VuZHMubWluLng7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGJvZHlBOiBib2R5QSxcbiAgICAgICAgICAgICAgICBwb2ludEE6IHsgeDogYm9keUFXaWR0aCAqIHhPZmZzZXRBLCB5OiBib2R5QUhlaWdodCAqIHlPZmZzZXRBIH0sXG4gICAgICAgICAgICAgICAgYm9keUI6IGJvZHlCLFxuICAgICAgICAgICAgICAgIHBvaW50QjogeyB4OiBib2R5QldpZHRoICogeE9mZnNldEIsIHk6IGJvZHlCSGVpZ2h0ICogeU9mZnNldEIgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKGNvbnN0cmFpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5sYWJlbCArPSAnIENoYWluJztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGJvZGllcyBpbiB0aGUgY29tcG9zaXRlIHdpdGggY29uc3RyYWludHMgaW4gYSBncmlkIHBhdHRlcm4sIHdpdGggb3B0aW9uYWwgY3Jvc3MgYnJhY2VzLlxuICAgICAqIEBtZXRob2QgbWVzaFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgbWVzaGVkIHRvZ2V0aGVyIHdpdGggY29uc3RyYWludHNcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLm1lc2ggPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbHVtbnMsIHJvd3MsIGNyb3NzQnJhY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IGNvbXBvc2l0ZS5ib2RpZXMsXG4gICAgICAgICAgICByb3csXG4gICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgYm9keUM7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDE7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgYm9keUEgPSBib2RpZXNbKGNvbCAtIDEpICsgKHJvdyAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICBib2R5QiA9IGJvZGllc1tjb2wgKyAocm93ICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBjb2x1bW5zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBib2R5QSA9IGJvZGllc1tjb2wgKyAoKHJvdyAtIDEpICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGJvZGllc1tjb2wgKyAocm93ICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKENvbW1vbi5leHRlbmQoeyBib2R5QTogYm9keUEsIGJvZHlCOiBib2R5QiB9LCBvcHRpb25zKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlDID0gYm9kaWVzWyhjb2wgLSAxKSArICgocm93IC0gMSkgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKENvbW1vbi5leHRlbmQoeyBib2R5QTogYm9keUMsIGJvZHlCOiBib2R5QiB9LCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyb3NzQnJhY2UgJiYgY29sIDwgY29sdW1ucyAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlDID0gYm9kaWVzWyhjb2wgKyAxKSArICgocm93IC0gMSkgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKENvbW1vbi5leHRlbmQoeyBib2R5QTogYm9keUMsIGJvZHlCOiBib2R5QiB9LCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9zaXRlLmxhYmVsICs9ICcgTWVzaCc7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIGJvZGllcyBjcmVhdGVkIGluIHRoZSBjYWxsYmFjayBpbiBhIHB5cmFtaWQgYXJyYW5nZW1lbnQuXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBib2R5J3MgYm91bmRzIHRvIHByZXZlbnQgb3ZlcmxhcHMuXG4gICAgICogQG1ldGhvZCBweXJhbWlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5HYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93R2FwXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLnB5cmFtaWQgPSBmdW5jdGlvbih4eCwgeXksIGNvbHVtbnMsIHJvd3MsIGNvbHVtbkdhcCwgcm93R2FwLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gQ29tcG9zaXRlcy5zdGFjayh4eCwgeXksIGNvbHVtbnMsIHJvd3MsIGNvbHVtbkdhcCwgcm93R2FwLCBmdW5jdGlvbih4LCB5LCBjb2x1bW4sIHJvdywgbGFzdEJvZHksIGkpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxSb3dzID0gTWF0aC5taW4ocm93cywgTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSksXG4gICAgICAgICAgICAgICAgbGFzdEJvZHlXaWR0aCA9IGxhc3RCb2R5ID8gbGFzdEJvZHkuYm91bmRzLm1heC54IC0gbGFzdEJvZHkuYm91bmRzLm1pbi54IDogMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJvdyA+IGFjdHVhbFJvd3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByZXZlcnNlIHJvdyBvcmRlclxuICAgICAgICAgICAgcm93ID0gYWN0dWFsUm93cyAtIHJvdztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcm93LFxuICAgICAgICAgICAgICAgIGVuZCA9IGNvbHVtbnMgLSAxIC0gcm93O1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgc3RhcnQgfHwgY29sdW1uID4gZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gcmV0cm9hY3RpdmVseSBmaXggdGhlIGZpcnN0IGJvZHkncyBwb3NpdGlvbiwgc2luY2Ugd2lkdGggd2FzIHVua25vd25cbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgQm9keS50cmFuc2xhdGUobGFzdEJvZHksIHsgeDogKGNvbHVtbiArIChjb2x1bW5zICUgMiA9PT0gMSA/IDEgOiAtMSkpICogbGFzdEJvZHlXaWR0aCwgeTogMCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHhPZmZzZXQgPSBsYXN0Qm9keSA/IGNvbHVtbiAqIGxhc3RCb2R5V2lkdGggOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soeHggKyB4T2Zmc2V0ICsgY29sdW1uICogY29sdW1uR2FwLCB5LCBjb2x1bW4sIHJvdywgbGFzdEJvZHksIGkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB3aXRoIGEgTmV3dG9uJ3MgQ3JhZGxlIHNldHVwIG9mIGJvZGllcyBhbmQgY29uc3RyYWludHMuXG4gICAgICogQG1ldGhvZCBuZXd0b25zQ3JhZGxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIG5ld3RvbnNDcmFkbGUgYm9keVxuICAgICAqL1xuICAgIENvbXBvc2l0ZXMubmV3dG9uc0NyYWRsZSA9IGZ1bmN0aW9uKHh4LCB5eSwgbnVtYmVyLCBzaXplLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld3RvbnNDcmFkbGUgPSBDb21wb3NpdGUuY3JlYXRlKHsgbGFiZWw6ICdOZXd0b25zIENyYWRsZScgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSAxLjksXG4gICAgICAgICAgICAgICAgY2lyY2xlID0gQm9kaWVzLmNpcmNsZSh4eCArIGkgKiAoc2l6ZSAqIHNlcGFyYXRpb24pLCB5eSArIGxlbmd0aCwgc2l6ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbmVydGlhOiBJbmZpbml0eSwgcmVzdGl0dXRpb246IDEsIGZyaWN0aW9uOiAwLCBmcmljdGlvbkFpcjogMC4wMDAxLCBzbG9wOiAxIH0pLFxuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBDb25zdHJhaW50LmNyZWF0ZSh7IHBvaW50QTogeyB4OiB4eCArIGkgKiAoc2l6ZSAqIHNlcGFyYXRpb24pLCB5OiB5eSB9LCBib2R5QjogY2lyY2xlIH0pO1xuXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShuZXd0b25zQ3JhZGxlLCBjaXJjbGUpO1xuICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQobmV3dG9uc0NyYWRsZSwgY29uc3RyYWludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3dG9uc0NyYWRsZTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgd2l0aCBzaW1wbGUgY2FyIHNldHVwIG9mIGJvZGllcyBhbmQgY29uc3RyYWludHMuXG4gICAgICogQG1ldGhvZCBjYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdoZWVsU2l6ZVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNhciBib2R5XG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5jYXIgPSBmdW5jdGlvbih4eCwgeXksIHdpZHRoLCBoZWlnaHQsIHdoZWVsU2l6ZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSBCb2R5Lm5leHRHcm91cCh0cnVlKSxcbiAgICAgICAgICAgIHdoZWVsQmFzZSA9IDIwLFxuICAgICAgICAgICAgd2hlZWxBT2Zmc2V0ID0gLXdpZHRoICogMC41ICsgd2hlZWxCYXNlLFxuICAgICAgICAgICAgd2hlZWxCT2Zmc2V0ID0gd2lkdGggKiAwLjUgLSB3aGVlbEJhc2UsXG4gICAgICAgICAgICB3aGVlbFlPZmZzZXQgPSAwO1xuICAgIFxuICAgICAgICB2YXIgY2FyID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnQ2FyJyB9KSxcbiAgICAgICAgICAgIGJvZHkgPSBCb2RpZXMucmVjdGFuZ2xlKHh4LCB5eSwgd2lkdGgsIGhlaWdodCwgeyBcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25GaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGFtZmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogaGVpZ2h0ICogMC41XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZW5zaXR5OiAwLjAwMDJcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICB2YXIgd2hlZWxBID0gQm9kaWVzLmNpcmNsZSh4eCArIHdoZWVsQU9mZnNldCwgeXkgKyB3aGVlbFlPZmZzZXQsIHdoZWVsU2l6ZSwgeyBcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgd2hlZWxCID0gQm9kaWVzLmNpcmNsZSh4eCArIHdoZWVsQk9mZnNldCwgeXkgKyB3aGVlbFlPZmZzZXQsIHdoZWVsU2l6ZSwgeyBcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXhlbEEgPSBDb25zdHJhaW50LmNyZWF0ZSh7XG4gICAgICAgICAgICBib2R5QjogYm9keSxcbiAgICAgICAgICAgIHBvaW50QjogeyB4OiB3aGVlbEFPZmZzZXQsIHk6IHdoZWVsWU9mZnNldCB9LFxuICAgICAgICAgICAgYm9keUE6IHdoZWVsQSxcbiAgICAgICAgICAgIHN0aWZmbmVzczogMSxcbiAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXhlbEIgPSBDb25zdHJhaW50LmNyZWF0ZSh7XG4gICAgICAgICAgICBib2R5QjogYm9keSxcbiAgICAgICAgICAgIHBvaW50QjogeyB4OiB3aGVlbEJPZmZzZXQsIHk6IHdoZWVsWU9mZnNldCB9LFxuICAgICAgICAgICAgYm9keUE6IHdoZWVsQixcbiAgICAgICAgICAgIHN0aWZmbmVzczogMSxcbiAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KGNhciwgYm9keSk7XG4gICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KGNhciwgd2hlZWxBKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCB3aGVlbEIpO1xuICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjYXIsIGF4ZWxBKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY2FyLCBheGVsQik7XG5cbiAgICAgICAgcmV0dXJuIGNhcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpbXBsZSBzb2Z0IGJvZHkgbGlrZSBvYmplY3QuXG4gICAgICogQG1ldGhvZCBzb2Z0Qm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3Jvc3NCcmFjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0aWNsZVJhZGl1c1xuICAgICAqIEBwYXJhbSB7fSBwYXJ0aWNsZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge30gY29uc3RyYWludE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBzb2Z0Qm9keVxuICAgICAqL1xuICAgIENvbXBvc2l0ZXMuc29mdEJvZHkgPSBmdW5jdGlvbih4eCwgeXksIGNvbHVtbnMsIHJvd3MsIGNvbHVtbkdhcCwgcm93R2FwLCBjcm9zc0JyYWNlLCBwYXJ0aWNsZVJhZGl1cywgcGFydGljbGVPcHRpb25zLCBjb25zdHJhaW50T3B0aW9ucykge1xuICAgICAgICBwYXJ0aWNsZU9wdGlvbnMgPSBDb21tb24uZXh0ZW5kKHsgaW5lcnRpYTogSW5maW5pdHkgfSwgcGFydGljbGVPcHRpb25zKTtcbiAgICAgICAgY29uc3RyYWludE9wdGlvbnMgPSBDb21tb24uZXh0ZW5kKHsgc3RpZmZuZXNzOiAwLjIsIHJlbmRlcjogeyB0eXBlOiAnbGluZScsIGFuY2hvcnM6IGZhbHNlIH0gfSwgY29uc3RyYWludE9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBzb2Z0Qm9keSA9IENvbXBvc2l0ZXMuc3RhY2soeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvZGllcy5jaXJjbGUoeCwgeSwgcGFydGljbGVSYWRpdXMsIHBhcnRpY2xlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIENvbXBvc2l0ZXMubWVzaChzb2Z0Qm9keSwgY29sdW1ucywgcm93cywgY3Jvc3NCcmFjZSwgY29uc3RyYWludE9wdGlvbnMpO1xuXG4gICAgICAgIHNvZnRCb2R5LmxhYmVsID0gJ1NvZnQgQm9keSc7XG5cbiAgICAgICAgcmV0dXJuIHNvZnRCb2R5O1xuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi4vYm9keS9Cb2R5XCI6MSxcIi4uL2JvZHkvQ29tcG9zaXRlXCI6MixcIi4uL2NvbnN0cmFpbnQvQ29uc3RyYWludFwiOjEyLFwiLi4vY29yZS9Db21tb25cIjoxNCxcIi4vQm9kaWVzXCI6MjN9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuQXhlc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgc2V0cyBvZiBheGVzLlxuKlxuKiBAY2xhc3MgQXhlc1xuKi9cblxudmFyIEF4ZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGVzO1xuXG52YXIgVmVjdG9yID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzZXQgb2YgYXhlcyBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7YXhlc30gQSBuZXcgYXhlcyBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIEF4ZXMuZnJvbVZlcnRpY2VzID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSB7fTtcblxuICAgICAgICAvLyBmaW5kIHRoZSB1bmlxdWUgYXhlcywgdXNpbmcgZWRnZSBub3JtYWwgZ3JhZGllbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aCwgXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZSh7IFxuICAgICAgICAgICAgICAgICAgICB4OiB2ZXJ0aWNlc1tqXS55IC0gdmVydGljZXNbaV0ueSwgXG4gICAgICAgICAgICAgICAgICAgIHk6IHZlcnRpY2VzW2ldLnggLSB2ZXJ0aWNlc1tqXS54XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSAobm9ybWFsLnkgPT09IDApID8gSW5maW5pdHkgOiAobm9ybWFsLnggLyBub3JtYWwueSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGxpbWl0IHByZWNpc2lvblxuICAgICAgICAgICAgZ3JhZGllbnQgPSBncmFkaWVudC50b0ZpeGVkKDMpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBheGVzW2dyYWRpZW50XSA9IG5vcm1hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb21tb24udmFsdWVzKGF4ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGEgc2V0IG9mIGF4ZXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtheGVzfSBheGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgQXhlcy5yb3RhdGUgPSBmdW5jdGlvbihheGVzLCBhbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGVzW2ldLFxuICAgICAgICAgICAgICAgIHh4O1xuICAgICAgICAgICAgeHggPSBheGlzLnggKiBjb3MgLSBheGlzLnkgKiBzaW47XG4gICAgICAgICAgICBheGlzLnkgPSBheGlzLnggKiBzaW4gKyBheGlzLnkgKiBjb3M7XG4gICAgICAgICAgICBheGlzLnggPSB4eDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLkJvdW5kc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIChBQUJCKS5cbipcbiogQGNsYXNzIEJvdW5kc1xuKi9cblxudmFyIEJvdW5kcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvdW5kcztcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IChBQUJCKSBmb3IgdGhlIGdpdmVuIHZlcnRpY2VzLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHtib3VuZHN9IEEgbmV3IGJvdW5kcyBvYmplY3RcbiAgICAgKi9cbiAgICBCb3VuZHMuY3JlYXRlID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHsgXG4gICAgICAgICAgICBtaW46IHsgeDogMCwgeTogMCB9LCBcbiAgICAgICAgICAgIG1heDogeyB4OiAwLCB5OiAwIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodmVydGljZXMpXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKGJvdW5kcywgdmVydGljZXMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBib3VuZHMgdXNpbmcgdGhlIGdpdmVuIHZlcnRpY2VzIGFuZCBleHRlbmRzIHRoZSBib3VuZHMgZ2l2ZW4gYSB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWxvY2l0eVxuICAgICAqL1xuICAgIEJvdW5kcy51cGRhdGUgPSBmdW5jdGlvbihib3VuZHMsIHZlcnRpY2VzLCB2ZWxvY2l0eSkge1xuICAgICAgICBib3VuZHMubWluLnggPSBJbmZpbml0eTtcbiAgICAgICAgYm91bmRzLm1heC54ID0gLUluZmluaXR5O1xuICAgICAgICBib3VuZHMubWluLnkgPSBJbmZpbml0eTtcbiAgICAgICAgYm91bmRzLm1heC55ID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueCA+IGJvdW5kcy5tYXgueCkgYm91bmRzLm1heC54ID0gdmVydGV4Lng7XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPCBib3VuZHMubWluLngpIGJvdW5kcy5taW4ueCA9IHZlcnRleC54O1xuICAgICAgICAgICAgaWYgKHZlcnRleC55ID4gYm91bmRzLm1heC55KSBib3VuZHMubWF4LnkgPSB2ZXJ0ZXgueTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueSA8IGJvdW5kcy5taW4ueSkgYm91bmRzLm1pbi55ID0gdmVydGV4Lnk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh2ZWxvY2l0eSkge1xuICAgICAgICAgICAgaWYgKHZlbG9jaXR5LnggPiAwKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLm1heC54ICs9IHZlbG9jaXR5Lng7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueCArPSB2ZWxvY2l0eS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodmVsb2NpdHkueSA+IDApIHtcbiAgICAgICAgICAgICAgICBib3VuZHMubWF4LnkgKz0gdmVsb2NpdHkueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLm1pbi55ICs9IHZlbG9jaXR5Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBib3VuZHMgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYm91bmRzIGNvbnRhaW4gdGhlIHBvaW50LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBCb3VuZHMuY29udGFpbnMgPSBmdW5jdGlvbihib3VuZHMsIHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludC54ID49IGJvdW5kcy5taW4ueCAmJiBwb2ludC54IDw9IGJvdW5kcy5tYXgueCBcbiAgICAgICAgICAgICAgICYmIHBvaW50LnkgPj0gYm91bmRzLm1pbi55ICYmIHBvaW50LnkgPD0gYm91bmRzLm1heC55O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBib3VuZHMgaW50ZXJzZWN0LlxuICAgICAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzQVxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNCXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYm91bmRzIG92ZXJsYXAsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIEJvdW5kcy5vdmVybGFwcyA9IGZ1bmN0aW9uKGJvdW5kc0EsIGJvdW5kc0IpIHtcbiAgICAgICAgcmV0dXJuIChib3VuZHNBLm1pbi54IDw9IGJvdW5kc0IubWF4LnggJiYgYm91bmRzQS5tYXgueCA+PSBib3VuZHNCLm1pbi54XG4gICAgICAgICAgICAgICAgJiYgYm91bmRzQS5tYXgueSA+PSBib3VuZHNCLm1pbi55ICYmIGJvdW5kc0EubWluLnkgPD0gYm91bmRzQi5tYXgueSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGJvdW5kcyBieSB0aGUgZ2l2ZW4gdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKi9cbiAgICBCb3VuZHMudHJhbnNsYXRlID0gZnVuY3Rpb24oYm91bmRzLCB2ZWN0b3IpIHtcbiAgICAgICAgYm91bmRzLm1pbi54ICs9IHZlY3Rvci54O1xuICAgICAgICBib3VuZHMubWF4LnggKz0gdmVjdG9yLng7XG4gICAgICAgIGJvdW5kcy5taW4ueSArPSB2ZWN0b3IueTtcbiAgICAgICAgYm91bmRzLm1heC55ICs9IHZlY3Rvci55O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIGJvdW5kcyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICogQG1ldGhvZCBzaGlmdFxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBCb3VuZHMuc2hpZnQgPSBmdW5jdGlvbihib3VuZHMsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBib3VuZHMubWF4LnggLSBib3VuZHMubWluLngsXG4gICAgICAgICAgICBkZWx0YVkgPSBib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnk7XG4gICAgICAgICAgICBcbiAgICAgICAgYm91bmRzLm1pbi54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgYm91bmRzLm1heC54ID0gcG9zaXRpb24ueCArIGRlbHRhWDtcbiAgICAgICAgYm91bmRzLm1pbi55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgYm91bmRzLm1heC55ID0gcG9zaXRpb24ueSArIGRlbHRhWTtcbiAgICB9O1xuICAgIFxufSkoKTtcblxufSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4qIFRoZSBgTWF0dGVyLlN2Z2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNvbnZlcnRpbmcgU1ZHIGltYWdlcyBpbnRvIGFuIGFycmF5IG9mIHZlY3RvciBwb2ludHMuXG4qXG4qIFRvIHVzZSB0aGlzIG1vZHVsZSB5b3UgYWxzbyBuZWVkIHRoZSBTVkdQYXRoU2VnIHBvbHlmaWxsOiBodHRwczovL2dpdGh1Yi5jb20vcHJvZ2Vycy9wYXRoc2VnXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBTdmdcbiovXG5cbnZhciBTdmcgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdmc7XG5cbnZhciBCb3VuZHMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBTVkcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHZlY3RvciBwb2ludHMuXG4gICAgICogSWYgdGhlIGlucHV0IHBhdGggZm9ybXMgYSBjb25jYXZlIHNoYXBlLCB5b3UgbXVzdCBkZWNvbXBvc2UgdGhlIHJlc3VsdCBpbnRvIGNvbnZleCBwYXJ0cyBiZWZvcmUgdXNlLlxuICAgICAqIFNlZSBgQm9kaWVzLmZyb21WZXJ0aWNlc2Agd2hpY2ggcHJvdmlkZXMgc3VwcG9ydCBmb3IgdGhpcy5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBzdXBwb3J0IGNvbXBsZXggcGF0aHMgKHN1Y2ggYXMgdGhvc2Ugd2l0aCBob2xlcykuXG4gICAgICogWW91IG11c3QgbG9hZCB0aGUgYHBhdGhzZWcuanNgIHBvbHlmaWxsIG9uIG5ld2VyIGJyb3dzZXJzLlxuICAgICAqIEBtZXRob2QgcGF0aFRvVmVydGljZXNcbiAgICAgKiBAcGFyYW0ge1NWR1BhdGhFbGVtZW50fSBwYXRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVMZW5ndGg9MTVdXG4gICAgICogQHJldHVybiB7VmVjdG9yW119IHBvaW50c1xuICAgICAqL1xuICAgIFN2Zy5wYXRoVG9WZXJ0aWNlcyA9IGZ1bmN0aW9uKHBhdGgsIHNhbXBsZUxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISgnU1ZHUGF0aFNlZycgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1N2Zy5wYXRoVG9WZXJ0aWNlczogU1ZHUGF0aFNlZyBub3QgZGVmaW5lZCwgYSBwb2x5ZmlsbCBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93b3V0L3N2Zy50b3BvbHkuanMvYmxvYi9tYXN0ZXIvc3ZnLnRvcG9seS5qc1xuICAgICAgICB2YXIgaSwgaWwsIHRvdGFsLCBwb2ludCwgc2VnbWVudCwgc2VnbWVudHMsIFxuICAgICAgICAgICAgc2VnbWVudHNRdWV1ZSwgbGFzdFNlZ21lbnQsIFxuICAgICAgICAgICAgbGFzdFBvaW50LCBzZWdtZW50SW5kZXgsIHBvaW50cyA9IFtdLFxuICAgICAgICAgICAgbHgsIGx5LCBsZW5ndGggPSAwLCB4ID0gMCwgeSA9IDA7XG5cbiAgICAgICAgc2FtcGxlTGVuZ3RoID0gc2FtcGxlTGVuZ3RoIHx8IDE1O1xuXG4gICAgICAgIHZhciBhZGRQb2ludCA9IGZ1bmN0aW9uKHB4LCBweSwgcGF0aFNlZ1R5cGUpIHtcbiAgICAgICAgICAgIC8vIGFsbCBvZGQtbnVtYmVyZWQgcGF0aCB0eXBlcyBhcmUgcmVsYXRpdmUgZXhjZXB0IFBBVEhTRUdfQ0xPU0VQQVRIICgxKVxuICAgICAgICAgICAgdmFyIGlzUmVsYXRpdmUgPSBwYXRoU2VnVHlwZSAlIDIgPT09IDEgJiYgcGF0aFNlZ1R5cGUgPiAxO1xuXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBsYXN0IHBvaW50IGRvZXNuJ3QgZXF1YWwgdGhlIGN1cnJlbnQgcG9pbnQgYWRkIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludCB8fCBweCAhPSBsYXN0UG9pbnQueCB8fCBweSAhPSBsYXN0UG9pbnQueSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UG9pbnQgJiYgaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBseCA9IGxhc3RQb2ludC54O1xuICAgICAgICAgICAgICAgICAgICBseSA9IGxhc3RQb2ludC55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGx4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogbHggKyBweCxcbiAgICAgICAgICAgICAgICAgICAgeTogbHkgKyBweVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgbGFzdCBwb2ludFxuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlIHx8ICFsYXN0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgeCA9IGx4ICsgcHg7XG4gICAgICAgICAgICAgICAgeSA9IGx5ICsgcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFkZFNlZ21lbnRQb2ludCA9IGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBzZWdUeXBlID0gc2VnbWVudC5wYXRoU2VnVHlwZUFzTGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIHNraXAgcGF0aCBlbmRzXG4gICAgICAgICAgICBpZiAoc2VnVHlwZSA9PT0gJ1onKSBcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG1hcCBzZWdtZW50IHRvIHggYW5kIHlcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnVHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgeCA9IHNlZ21lbnQueDtcbiAgICAgICAgICAgICAgICB5ID0gc2VnbWVudC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgeCA9IHNlZ21lbnQueDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgIHkgPSBzZWdtZW50Lnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZFBvaW50KHgsIHksIHNlZ21lbnQucGF0aFNlZ1R5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGVuc3VyZSBwYXRoIGlzIGFic29sdXRlXG4gICAgICAgIFN2Zy5fc3ZnUGF0aFRvQWJzb2x1dGUocGF0aCk7XG5cbiAgICAgICAgLy8gZ2V0IHRvdGFsIGxlbmd0aFxuICAgICAgICB0b3RhbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcblxuICAgICAgICAvLyBxdWV1ZSBzZWdtZW50c1xuICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zOyBpICs9IDEpXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHBhdGgucGF0aFNlZ0xpc3QuZ2V0SXRlbShpKSk7XG5cbiAgICAgICAgc2VnbWVudHNRdWV1ZSA9IHNlZ21lbnRzLmNvbmNhdCgpO1xuXG4gICAgICAgIC8vIHNhbXBsZSB0aHJvdWdoIHBhdGhcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA8IHRvdGFsKSB7XG4gICAgICAgICAgICAvLyBnZXQgc2VnbWVudCBhdCBwb3NpdGlvblxuICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gcGF0aC5nZXRQYXRoU2VnQXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBuZXcgc2VnbWVudFxuICAgICAgICAgICAgaWYgKHNlZ21lbnQgIT0gbGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VnbWVudHNRdWV1ZS5sZW5ndGggJiYgc2VnbWVudHNRdWV1ZVswXSAhPSBzZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWdtZW50UG9pbnQoc2VnbWVudHNRdWV1ZS5zaGlmdCgpKTtcblxuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHBvaW50cyBpbiBiZXR3ZWVuIHdoZW4gY3VydmluZ1xuICAgICAgICAgICAgLy8gVE9ETzogYWRhcHRpdmUgc2FtcGxpbmdcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnbWVudC5wYXRoU2VnVHlwZUFzTGV0dGVyLnRvVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICBwb2ludCA9IHBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LngsIHBvaW50LnksIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBieSBzYW1wbGUgdmFsdWVcbiAgICAgICAgICAgIGxlbmd0aCArPSBzYW1wbGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHNlZ21lbnRzIG5vdCBwYXNzZWQgYnkgc2FtcGxpbmdcbiAgICAgICAgZm9yIChpID0gMCwgaWwgPSBzZWdtZW50c1F1ZXVlLmxlbmd0aDsgaSA8IGlsOyArK2kpXG4gICAgICAgICAgICBhZGRTZWdtZW50UG9pbnQoc2VnbWVudHNRdWV1ZVtpXSk7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9O1xuXG4gICAgU3ZnLl9zdmdQYXRoVG9BYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgLy8gaHR0cDovL3Bocm9nei5uZXQvY29udmVydC1zdmctcGF0aC10by1hbGwtYWJzb2x1dGUtY29tbWFuZHNcbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSBHYXZpbiBLaXN0bmVyXG4gICAgICAgIC8vIGh0dHA6Ly9waHJvZ3oubmV0L2pzL19SZXVzZUxpY2Vuc2UudHh0XG4gICAgICAgIC8vIE1vZGlmaWNhdGlvbnM6IHRpZHkgZm9ybWF0dGluZyBhbmQgbmFtaW5nXG4gICAgICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBzZWdzID0gcGF0aC5wYXRoU2VnTGlzdCxcbiAgICAgICAgICAgIHggPSAwLCB5ID0gMCwgbGVuID0gc2Vncy5udW1iZXJPZkl0ZW1zO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzLmdldEl0ZW0oaSksXG4gICAgICAgICAgICAgICAgc2VnVHlwZSA9IHNlZy5wYXRoU2VnVHlwZUFzTGV0dGVyO1xuXG4gICAgICAgICAgICBpZiAoL1tNTEhWQ1NRVEFdLy50ZXN0KHNlZ1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCd4JyBpbiBzZWcpIHggPSBzZWcueDtcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSA9IHNlZy55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3gxJyBpbiBzZWcpIHgxID0geCArIHNlZy54MTtcbiAgICAgICAgICAgICAgICBpZiAoJ3gyJyBpbiBzZWcpIHgyID0geCArIHNlZy54MjtcbiAgICAgICAgICAgICAgICBpZiAoJ3kxJyBpbiBzZWcpIHkxID0geSArIHNlZy55MTtcbiAgICAgICAgICAgICAgICBpZiAoJ3kyJyBpbiBzZWcpIHkyID0geSArIHNlZy55MjtcbiAgICAgICAgICAgICAgICBpZiAoJ3gnIGluIHNlZykgeCArPSBzZWcueDtcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSArPSBzZWcueTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VnVHlwZSkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzKHgsIHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvQWJzKHgsIHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicyh4KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzKHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzKHgsIHksIHgxLCB5MSwgeDIsIHkyKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyh4LCB5LCB4MiwgeTIpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficyh4LCB5LCB4MSwgeTEpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicyh4LCB5KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0FyY0Ficyh4LCB5LCBzZWcucjEsIHNlZy5yMiwgc2VnLmFuZ2xlLCBzZWcubGFyZ2VBcmNGbGFnLCBzZWcuc3dlZXBGbGFnKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICB4ID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdUeXBlID09ICdNJyB8fCBzZWdUeXBlID09ICdtJykge1xuICAgICAgICAgICAgICAgIHgwID0geDtcbiAgICAgICAgICAgICAgICB5MCA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xufSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjZ9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuVmVjdG9yYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyB2ZWN0b3JzLlxuKiBWZWN0b3JzIGFyZSB0aGUgYmFzaXMgb2YgYWxsIHRoZSBnZW9tZXRyeSByZWxhdGVkIG9wZXJhdGlvbnMgaW4gdGhlIGVuZ2luZS5cbiogQSBgTWF0dGVyLlZlY3RvcmAgb2JqZWN0IGlzIG9mIHRoZSBmb3JtIGB7IHg6IDAsIHk6IDAgfWAuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBWZWN0b3JcbiovXG5cbi8vIFRPRE86IGNvbnNpZGVyIHBhcmFtcyBmb3IgcmV1c2luZyB2ZWN0b3Igb2JqZWN0c1xuXG52YXIgVmVjdG9yID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5jcmVhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggfHwgMCwgeTogeSB8fCAwIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHdpdGggYHhgIGFuZCBgeWAgY29waWVkIGZyb20gdGhlIGdpdmVuIGB2ZWN0b3JgLlxuICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyBjbG9uZWQgdmVjdG9yXG4gICAgICovXG4gICAgVmVjdG9yLmNsb25lID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54LCB5OiB2ZWN0b3IueSB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgYSB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBtYWduaXR1ZGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubWFnbml0dWRlID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHZlY3Rvci54ICogdmVjdG9yLngpICsgKHZlY3Rvci55ICogdmVjdG9yLnkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFnbml0dWRlIChsZW5ndGgpIG9mIGEgdmVjdG9yICh0aGVyZWZvcmUgc2F2aW5nIGEgYHNxcnRgIG9wZXJhdGlvbikuXG4gICAgICogQG1ldGhvZCBtYWduaXR1ZGVTcXVhcmVkXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICByZXR1cm4gKHZlY3Rvci54ICogdmVjdG9yLngpICsgKHZlY3Rvci55ICogdmVjdG9yLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgYWJvdXQgKDAsIDApIGJ5IHNwZWNpZmllZCBhbmdsZS5cbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW291dHB1dF1cbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSB2ZWN0b3Igcm90YXRlZCBhYm91dCAoMCwgMClcbiAgICAgKi9cbiAgICBWZWN0b3Iucm90YXRlID0gZnVuY3Rpb24odmVjdG9yLCBhbmdsZSwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICB2YXIgeCA9IHZlY3Rvci54ICogY29zIC0gdmVjdG9yLnkgKiBzaW47XG4gICAgICAgIG91dHB1dC55ID0gdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvcztcbiAgICAgICAgb3V0cHV0LnggPSB4O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgYWJvdXQgYSBzcGVjaWZpZWQgcG9pbnQgYnkgc3BlY2lmaWVkIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlQWJvdXRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igcm90YXRlZCBhYm91dCB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBWZWN0b3Iucm90YXRlQWJvdXQgPSBmdW5jdGlvbih2ZWN0b3IsIGFuZ2xlLCBwb2ludCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICB2YXIgeCA9IHBvaW50LnggKyAoKHZlY3Rvci54IC0gcG9pbnQueCkgKiBjb3MgLSAodmVjdG9yLnkgLSBwb2ludC55KSAqIHNpbik7XG4gICAgICAgIG91dHB1dC55ID0gcG9pbnQueSArICgodmVjdG9yLnggLSBwb2ludC54KSAqIHNpbiArICh2ZWN0b3IueSAtIHBvaW50LnkpICogY29zKTtcbiAgICAgICAgb3V0cHV0LnggPSB4O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpc2VzIGEgdmVjdG9yIChzdWNoIHRoYXQgaXRzIG1hZ25pdHVkZSBpcyBgMWApLlxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXNlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIG5vcm1hbGlzZWRcbiAgICAgKi9cbiAgICBWZWN0b3Iubm9ybWFsaXNlID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBWZWN0b3IubWFnbml0dWRlKHZlY3Rvcik7XG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54IC8gbWFnbml0dWRlLCB5OiB2ZWN0b3IueSAvIG1hZ25pdHVkZSB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGRvdFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgdHdvIHZlY3RvcnNcbiAgICAgKi9cbiAgICBWZWN0b3IuZG90ID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueCkgKyAodmVjdG9yQS55ICogdmVjdG9yQi55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGNyb3NzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIHR3byB2ZWN0b3JzXG4gICAgICovXG4gICAgVmVjdG9yLmNyb3NzID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueSkgLSAodmVjdG9yQS55ICogdmVjdG9yQi54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3MzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JDXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgdGhyZWUgdmVjdG9yc1xuICAgICAqL1xuICAgIFZlY3Rvci5jcm9zczMgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCB2ZWN0b3JDKSB7XG4gICAgICAgIHJldHVybiAodmVjdG9yQi54IC0gdmVjdG9yQS54KSAqICh2ZWN0b3JDLnkgLSB2ZWN0b3JBLnkpIC0gKHZlY3RvckIueSAtIHZlY3RvckEueSkgKiAodmVjdG9yQy54IC0gdmVjdG9yQS54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgdHdvIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBhZGRlZFxuICAgICAqL1xuICAgIFZlY3Rvci5hZGQgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICBvdXRwdXQueCA9IHZlY3RvckEueCArIHZlY3RvckIueDtcbiAgICAgICAgb3V0cHV0LnkgPSB2ZWN0b3JBLnkgKyB2ZWN0b3JCLnk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgdHdvIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBzdWJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBzdWJ0cmFjdGVkXG4gICAgICovXG4gICAgVmVjdG9yLnN1YiA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIsIG91dHB1dCkge1xuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICAgIG91dHB1dC54ID0gdmVjdG9yQS54IC0gdmVjdG9yQi54O1xuICAgICAgICBvdXRwdXQueSA9IHZlY3RvckEueSAtIHZlY3RvckIueTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBhbmQgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWx0XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBtdWx0aXBsaWVkIGJ5IHNjYWxhclxuICAgICAqL1xuICAgIFZlY3Rvci5tdWx0ID0gZnVuY3Rpb24odmVjdG9yLCBzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLnggKiBzY2FsYXIsIHk6IHZlY3Rvci55ICogc2NhbGFyIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLlxuICAgICAqIEBtZXRob2QgZGl2XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBkaXZpZGVkIGJ5IHNjYWxhclxuICAgICAqL1xuICAgIFZlY3Rvci5kaXYgPSBmdW5jdGlvbih2ZWN0b3IsIHNjYWxhcikge1xuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCAvIHNjYWxhciwgeTogdmVjdG9yLnkgLyBzY2FsYXIgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IuIFNldCBgbmVnYXRlYCB0byB0cnVlIGZvciB0aGUgcGVycGVuZGljdWxhciBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICAgICAqIEBtZXRob2QgcGVycFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtuZWdhdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgcGVycGVuZGljdWxhciB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IucGVycCA9IGZ1bmN0aW9uKHZlY3RvciwgbmVnYXRlKSB7XG4gICAgICAgIG5lZ2F0ZSA9IG5lZ2F0ZSA9PT0gdHJ1ZSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHsgeDogbmVnYXRlICogLXZlY3Rvci55LCB5OiBuZWdhdGUgKiB2ZWN0b3IueCB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGJvdGggY29tcG9uZW50cyBvZiBhIHZlY3RvciBzdWNoIHRoYXQgaXQgcG9pbnRzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogQG1ldGhvZCBuZWdcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgbmVnYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubmVnID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB7IHg6IC12ZWN0b3IueCwgeTogLXZlY3Rvci55IH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHZlY3RvciBgdmVjdG9yQiAtIHZlY3RvckFgIGFuZCB0aGUgeC1heGlzIGluIHJhZGlhbnMuXG4gICAgICogQG1ldGhvZCBhbmdsZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgVmVjdG9yLmFuZ2xlID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih2ZWN0b3JCLnkgLSB2ZWN0b3JBLnksIHZlY3RvckIueCAtIHZlY3RvckEueCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSB2ZWN0b3IgcG9vbCAobm90IHRocmVhZC1zYWZlKS5cbiAgICAgKiBAcHJvcGVydHkgX3RlbXBcbiAgICAgKiBAdHlwZSB7dmVjdG9yW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWZWN0b3IuX3RlbXAgPSBbXG4gICAgICAgIFZlY3Rvci5jcmVhdGUoKSwgVmVjdG9yLmNyZWF0ZSgpLCBcbiAgICAgICAgVmVjdG9yLmNyZWF0ZSgpLCBWZWN0b3IuY3JlYXRlKCksIFxuICAgICAgICBWZWN0b3IuY3JlYXRlKCksIFZlY3Rvci5jcmVhdGUoKVxuICAgIF07XG5cbn0pKCk7XG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuVmVydGljZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgdmVydGljZXMuXG4qIEEgc2V0IG9mIHZlcnRpY2VzIGlzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCB3aXRoIGFkZGl0aW9uYWwgaW5kZXhpbmcgcHJvcGVydGllcyBpbnNlcnRlZCBieSBgVmVydGljZXMuY3JlYXRlYC5cbiogQSBgTWF0dGVyLkJvZHlgIG1haW50YWlucyBhIHNldCBvZiB2ZXJ0aWNlcyB0byByZXByZXNlbnQgdGhlIHNoYXBlIG9mIHRoZSBvYmplY3QgKGl0cyBjb252ZXggaHVsbCkuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBWZXJ0aWNlc1xuKi9cblxudmFyIFZlcnRpY2VzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGljZXM7XG5cbnZhciBWZWN0b3IgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNldCBvZiBgTWF0dGVyLkJvZHlgIGNvbXBhdGlibGUgdmVydGljZXMuXG4gICAgICogVGhlIGBwb2ludHNgIGFyZ3VtZW50IGFjY2VwdHMgYW4gYXJyYXkgb2YgYE1hdHRlci5WZWN0b3JgIHBvaW50cyBvcmllbnRhdGVkIGFyb3VuZCB0aGUgb3JpZ2luIGAoMCwgMClgLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICBbeyB4OiAwLCB5OiAwIH0sIHsgeDogMjUsIHk6IDUwIH0sIHsgeDogNTAsIHk6IDAgfV1cbiAgICAgKlxuICAgICAqIFRoZSBgVmVydGljZXMuY3JlYXRlYCBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheSBvZiB2ZXJ0aWNlcywgd2hpY2ggYXJlIHNpbWlsYXIgdG8gTWF0dGVyLlZlY3RvciBvYmplY3RzLFxuICAgICAqIGJ1dCB3aXRoIHNvbWUgYWRkaXRpb25hbCByZWZlcmVuY2VzIHJlcXVpcmVkIGZvciBlZmZpY2llbnQgY29sbGlzaW9uIGRldGVjdGlvbiByb3V0aW5lcy5cbiAgICAgKlxuICAgICAqIFZlcnRpY2VzIG11c3QgYmUgc3BlY2lmaWVkIGluIGNsb2Nrd2lzZSBvcmRlci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgYGJvZHlgIGFyZ3VtZW50IGlzIG5vdCBvcHRpb25hbCwgYSBgTWF0dGVyLkJvZHlgIHJlZmVyZW5jZSBtdXN0IGJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge3ZlY3RvcltdfSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5jcmVhdGUgPSBmdW5jdGlvbihwb2ludHMsIGJvZHkpIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvaW50LnksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBpc0ludGVybmFsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIGNvbnRhaW5pbmcgb3JkZXJlZCB4IHkgcGFpcnMgc2VwYXJhdGVkIGJ5IHNwYWNlcyAoYW5kIG9wdGlvbmFsbHkgY29tbWFzKSwgXG4gICAgICogaW50byBhIGBNYXR0ZXIuVmVydGljZXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGBNYXR0ZXIuQm9keWAuXG4gICAgICogRm9yIHBhcnNpbmcgU1ZHIHBhdGhzLCBzZWUgYFN2Zy5wYXRoVG9WZXJ0aWNlc2AuXG4gICAgICogQG1ldGhvZCBmcm9tUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHJldHVybiB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICovXG4gICAgVmVydGljZXMuZnJvbVBhdGggPSBmdW5jdGlvbihwYXRoLCBib2R5KSB7XG4gICAgICAgIHZhciBwYXRoUGF0dGVybiA9IC9MP1xccyooW1xcLVxcZFxcLmVdKylbXFxzLF0qKFtcXC1cXGRcXC5lXSspKi9pZyxcbiAgICAgICAgICAgIHBvaW50cyA9IFtdO1xuXG4gICAgICAgIHBhdGgucmVwbGFjZShwYXRoUGF0dGVybiwgZnVuY3Rpb24obWF0Y2gsIHgsIHkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogcGFyc2VGbG9hdCh4KSwgeTogcGFyc2VGbG9hdCh5KSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFZlcnRpY2VzLmNyZWF0ZShwb2ludHMsIGJvZHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjZW50cmUgKGNlbnRyb2lkKSBvZiB0aGUgc2V0IG9mIHZlcnRpY2VzLlxuICAgICAqIEBtZXRob2QgY2VudHJlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBjZW50cmUgcG9pbnRcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5jZW50cmUgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgYXJlYSA9IFZlcnRpY2VzLmFyZWEodmVydGljZXMsIHRydWUpLFxuICAgICAgICAgICAgY2VudHJlID0geyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjcm9zcyxcbiAgICAgICAgICAgIHRlbXAsXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGogPSAoaSArIDEpICUgdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgY3Jvc3MgPSBWZWN0b3IuY3Jvc3ModmVydGljZXNbaV0sIHZlcnRpY2VzW2pdKTtcbiAgICAgICAgICAgIHRlbXAgPSBWZWN0b3IubXVsdChWZWN0b3IuYWRkKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tqXSksIGNyb3NzKTtcbiAgICAgICAgICAgIGNlbnRyZSA9IFZlY3Rvci5hZGQoY2VudHJlLCB0ZW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBWZWN0b3IuZGl2KGNlbnRyZSwgNiAqIGFyZWEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIChtZWFuKSBvZiB0aGUgc2V0IG9mIHZlcnRpY2VzLlxuICAgICAqIEBtZXRob2QgbWVhblxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgYXZlcmFnZSBwb2ludFxuICAgICAqL1xuICAgIFZlcnRpY2VzLm1lYW4gPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgYXZlcmFnZSA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGF2ZXJhZ2UueCArPSB2ZXJ0aWNlc1tpXS54O1xuICAgICAgICAgICAgYXZlcmFnZS55ICs9IHZlcnRpY2VzW2ldLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVmVjdG9yLmRpdihhdmVyYWdlLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBhcmVhXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHNpZ25lZFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFyZWFcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5hcmVhID0gZnVuY3Rpb24odmVydGljZXMsIHNpZ25lZCkge1xuICAgICAgICB2YXIgYXJlYSA9IDAsXG4gICAgICAgICAgICBqID0gdmVydGljZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhICs9ICh2ZXJ0aWNlc1tqXS54IC0gdmVydGljZXNbaV0ueCkgKiAodmVydGljZXNbal0ueSArIHZlcnRpY2VzW2ldLnkpO1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZWEgLyAyO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhcmVhKSAvIDI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vbWVudCBvZiBpbmVydGlhIChzZWNvbmQgbW9tZW50IG9mIGFyZWEpIG9mIHRoZSBzZXQgb2YgdmVydGljZXMgZ2l2ZW4gdGhlIHRvdGFsIG1hc3MuXG4gICAgICogQG1ldGhvZCBpbmVydGlhXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFzc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvbHlnb24ncyBtb21lbnQgb2YgaW5lcnRpYVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmluZXJ0aWEgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWFzcykge1xuICAgICAgICB2YXIgbnVtZXJhdG9yID0gMCxcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gMCxcbiAgICAgICAgICAgIHYgPSB2ZXJ0aWNlcyxcbiAgICAgICAgICAgIGNyb3NzLFxuICAgICAgICAgICAgajtcblxuICAgICAgICAvLyBmaW5kIHRoZSBwb2x5Z29uJ3MgbW9tZW50IG9mIGluZXJ0aWEsIHVzaW5nIHNlY29uZCBtb21lbnQgb2YgYXJlYVxuICAgICAgICAvLyBmcm9tIGVxdWF0aW9ucyBhdCBodHRwOi8vd3d3LnBoeXNpY3Nmb3J1bXMuY29tL3Nob3d0aHJlYWQucGhwP3Q9MjUyOTNcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB2Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBqID0gKG4gKyAxKSAlIHYubGVuZ3RoO1xuICAgICAgICAgICAgY3Jvc3MgPSBNYXRoLmFicyhWZWN0b3IuY3Jvc3ModltqXSwgdltuXSkpO1xuICAgICAgICAgICAgbnVtZXJhdG9yICs9IGNyb3NzICogKFZlY3Rvci5kb3QodltqXSwgdltqXSkgKyBWZWN0b3IuZG90KHZbal0sIHZbbl0pICsgVmVjdG9yLmRvdCh2W25dLCB2W25dKSk7XG4gICAgICAgICAgICBkZW5vbWluYXRvciArPSBjcm9zcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobWFzcyAvIDYpICogKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgc2V0IG9mIHZlcnRpY2VzIGluLXBsYWNlLlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxuICAgICAqL1xuICAgIFZlcnRpY2VzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCB2ZWN0b3IsIHNjYWxhcikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHNjYWxhcikge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV0ueCArPSB2ZWN0b3IueCAqIHNjYWxhcjtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS55ICs9IHZlY3Rvci55ICogc2NhbGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV0ueCArPSB2ZWN0b3IueDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS55ICs9IHZlY3Rvci55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBzZXQgb2YgdmVydGljZXMgaW4tcGxhY2UuXG4gICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqL1xuICAgIFZlcnRpY2VzLnJvdGF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBhbmdsZSwgcG9pbnQpIHtcbiAgICAgICAgaWYgKGFuZ2xlID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2UgPSB2ZXJ0aWNlc1tpXSxcbiAgICAgICAgICAgICAgICBkeCA9IHZlcnRpY2UueCAtIHBvaW50LngsXG4gICAgICAgICAgICAgICAgZHkgPSB2ZXJ0aWNlLnkgLSBwb2ludC55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmVydGljZS54ID0gcG9pbnQueCArIChkeCAqIGNvcyAtIGR5ICogc2luKTtcbiAgICAgICAgICAgIHZlcnRpY2UueSA9IHBvaW50LnkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBgcG9pbnRgIGlzIGluc2lkZSB0aGUgc2V0IG9mIGB2ZXJ0aWNlc2AuXG4gICAgICogQG1ldGhvZCBjb250YWluc1xuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVydGljZXMgY29udGFpbnMgcG9pbnQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNvbnRhaW5zID0gZnVuY3Rpb24odmVydGljZXMsIHBvaW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlID0gdmVydGljZXNbaV0sXG4gICAgICAgICAgICAgICAgbmV4dFZlcnRpY2UgPSB2ZXJ0aWNlc1soaSArIDEpICUgdmVydGljZXMubGVuZ3RoXTtcbiAgICAgICAgICAgIGlmICgocG9pbnQueCAtIHZlcnRpY2UueCkgKiAobmV4dFZlcnRpY2UueSAtIHZlcnRpY2UueSkgKyAocG9pbnQueSAtIHZlcnRpY2UueSkgKiAodmVydGljZS54IC0gbmV4dFZlcnRpY2UueCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgdmVydGljZXMgZnJvbSBhIHBvaW50IChkZWZhdWx0IGlzIGNlbnRyZSkgaW4tcGxhY2UuXG4gICAgICogQG1ldGhvZCBzY2FsZVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5zY2FsZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQpIHtcbiAgICAgICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XG5cbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCBWZXJ0aWNlcy5jZW50cmUodmVydGljZXMpO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXgsXG4gICAgICAgICAgICBkZWx0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGRlbHRhID0gVmVjdG9yLnN1Yih2ZXJ0ZXgsIHBvaW50KTtcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnggPSBwb2ludC54ICsgZGVsdGEueCAqIHNjYWxlWDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgPSBwb2ludC55ICsgZGVsdGEueSAqIHNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbWZlcnMgYSBzZXQgb2YgdmVydGljZXMgYnkgZ2l2aW5nIHRoZW0gcm91bmRlZCBjb3JuZXJzLCByZXR1cm5zIGEgbmV3IHNldCBvZiB2ZXJ0aWNlcy5cbiAgICAgKiBUaGUgcmFkaXVzIHBhcmFtZXRlciBpcyBhIHNpbmdsZSBudW1iZXIgb3IgYW4gYXJyYXkgdG8gc3BlY2lmeSB0aGUgcmFkaXVzIGZvciBlYWNoIHZlcnRleC5cbiAgICAgKiBAbWV0aG9kIGNoYW1mZXJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlNaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eU1heFxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNoYW1mZXIgPSBmdW5jdGlvbih2ZXJ0aWNlcywgcmFkaXVzLCBxdWFsaXR5LCBxdWFsaXR5TWluLCBxdWFsaXR5TWF4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmFkaXVzID0gW3JhZGl1c107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgWzhdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhbGl0eSBkZWZhdWx0cyB0byAtMSwgd2hpY2ggaXMgYXV0b1xuICAgICAgICBxdWFsaXR5ID0gKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykgPyBxdWFsaXR5IDogLTE7XG4gICAgICAgIHF1YWxpdHlNaW4gPSBxdWFsaXR5TWluIHx8IDI7XG4gICAgICAgIHF1YWxpdHlNYXggPSBxdWFsaXR5TWF4IHx8IDE0O1xuXG4gICAgICAgIHZhciBuZXdWZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmV2VmVydGV4ID0gdmVydGljZXNbaSAtIDEgPj0gMCA/IGkgLSAxIDogdmVydGljZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV0sXG4gICAgICAgICAgICAgICAgbmV4dFZlcnRleCA9IHZlcnRpY2VzWyhpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYWRpdXMgPSByYWRpdXNbaSA8IHJhZGl1cy5sZW5ndGggPyBpIDogcmFkaXVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFJhZGl1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld1ZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZXZOb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXG4gICAgICAgICAgICAgICAgeDogdmVydGV4LnkgLSBwcmV2VmVydGV4LnksIFxuICAgICAgICAgICAgICAgIHk6IHByZXZWZXJ0ZXgueCAtIHZlcnRleC54XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG5leHROb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXG4gICAgICAgICAgICAgICAgeDogbmV4dFZlcnRleC55IC0gdmVydGV4LnksIFxuICAgICAgICAgICAgICAgIHk6IHZlcnRleC54IC0gbmV4dFZlcnRleC54XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsUmFkaXVzID0gTWF0aC5zcXJ0KDIgKiBNYXRoLnBvdyhjdXJyZW50UmFkaXVzLCAyKSksXG4gICAgICAgICAgICAgICAgcmFkaXVzVmVjdG9yID0gVmVjdG9yLm11bHQoQ29tbW9uLmNsb25lKHByZXZOb3JtYWwpLCBjdXJyZW50UmFkaXVzKSxcbiAgICAgICAgICAgICAgICBtaWROb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKFZlY3Rvci5tdWx0KFZlY3Rvci5hZGQocHJldk5vcm1hbCwgbmV4dE5vcm1hbCksIDAuNSkpLFxuICAgICAgICAgICAgICAgIHNjYWxlZFZlcnRleCA9IFZlY3Rvci5zdWIodmVydGV4LCBWZWN0b3IubXVsdChtaWROb3JtYWwsIGRpYWdvbmFsUmFkaXVzKSk7XG5cbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBxdWFsaXR5O1xuXG4gICAgICAgICAgICBpZiAocXVhbGl0eSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlY2lkZSBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBNYXRoLnBvdyhjdXJyZW50UmFkaXVzLCAwLjMyKSAqIDEuNzU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWNpc2lvbiA9IENvbW1vbi5jbGFtcChwcmVjaXNpb24sIHF1YWxpdHlNaW4sIHF1YWxpdHlNYXgpO1xuXG4gICAgICAgICAgICAvLyB1c2UgYW4gZXZlbiB2YWx1ZSBmb3IgcHJlY2lzaW9uLCBtb3JlIGxpa2VseSB0byByZWR1Y2UgYXhlcyBieSB1c2luZyBzeW1tZXRyeVxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAlIDIgPT09IDEpXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uICs9IDE7XG5cbiAgICAgICAgICAgIHZhciBhbHBoYSA9IE1hdGguYWNvcyhWZWN0b3IuZG90KHByZXZOb3JtYWwsIG5leHROb3JtYWwpKSxcbiAgICAgICAgICAgICAgICB0aGV0YSA9IGFscGhhIC8gcHJlY2lzaW9uO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByZWNpc2lvbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3VmVydGljZXMucHVzaChWZWN0b3IuYWRkKFZlY3Rvci5yb3RhdGUocmFkaXVzVmVjdG9yLCB0aGV0YSAqIGopLCBzY2FsZWRWZXJ0ZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdWZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGlucHV0IHZlcnRpY2VzIGludG8gY2xvY2t3aXNlIG9yZGVyIGluIHBsYWNlLlxuICAgICAqIEBtZXRob2QgY2xvY2t3aXNlU29ydFxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICovXG4gICAgVmVydGljZXMuY2xvY2t3aXNlU29ydCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBjZW50cmUgPSBWZXJ0aWNlcy5tZWFuKHZlcnRpY2VzKTtcblxuICAgICAgICB2ZXJ0aWNlcy5zb3J0KGZ1bmN0aW9uKHZlcnRleEEsIHZlcnRleEIpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuYW5nbGUoY2VudHJlLCB2ZXJ0ZXhBKSAtIFZlY3Rvci5hbmdsZShjZW50cmUsIHZlcnRleEIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmVydGljZXMgZm9ybSBhIGNvbnZleCBzaGFwZSAodmVydGljZXMgbXVzdCBiZSBpbiBjbG9ja3dpc2Ugb3JkZXIpLlxuICAgICAqIEBtZXRob2QgaXNDb252ZXhcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge2Jvb2x9IGB0cnVlYCBpZiB0aGUgYHZlcnRpY2VzYCBhcmUgY29udmV4LCBgZmFsc2VgIGlmIG5vdCAob3IgYG51bGxgIGlmIG5vdCBjb21wdXRhYmxlKS5cbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5pc0NvbnZleCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9nZW9tZXRyeS9wb2x5Z29ubWVzaC9cbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSBQYXVsIEJvdXJrZSAodXNlIHBlcm1pdHRlZClcblxuICAgICAgICB2YXIgZmxhZyA9IDAsXG4gICAgICAgICAgICBuID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgejtcblxuICAgICAgICBpZiAobiA8IDMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBqID0gKGkgKyAxKSAlIG47XG4gICAgICAgICAgICBrID0gKGkgKyAyKSAlIG47XG4gICAgICAgICAgICB6ID0gKHZlcnRpY2VzW2pdLnggLSB2ZXJ0aWNlc1tpXS54KSAqICh2ZXJ0aWNlc1trXS55IC0gdmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICB6IC09ICh2ZXJ0aWNlc1tqXS55IC0gdmVydGljZXNbaV0ueSkgKiAodmVydGljZXNba10ueCAtIHZlcnRpY2VzW2pdLngpO1xuXG4gICAgICAgICAgICBpZiAoeiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFnIHw9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHogPiAwKSB7XG4gICAgICAgICAgICAgICAgZmxhZyB8PSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmxhZyA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFnICE9PSAwKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udmV4IGh1bGwgb2YgdGhlIGlucHV0IHZlcnRpY2VzIGFzIGEgbmV3IGFycmF5IG9mIHBvaW50cy5cbiAgICAgKiBAbWV0aG9kIGh1bGxcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4gW3ZlcnRleF0gdmVydGljZXNcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5odWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgLy8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMTAtX2h1bGwtMS5odG1sXG5cbiAgICAgICAgdmFyIHVwcGVyID0gW10sXG4gICAgICAgICAgICBsb3dlciA9IFtdLCBcbiAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gc29ydCB2ZXJ0aWNlcyBvbiB4LWF4aXMgKHktYXhpcyBmb3IgdGllcylcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5zbGljZSgwKTtcbiAgICAgICAgdmVydGljZXMuc29ydChmdW5jdGlvbih2ZXJ0ZXhBLCB2ZXJ0ZXhCKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB2ZXJ0ZXhBLnggLSB2ZXJ0ZXhCLng7XG4gICAgICAgICAgICByZXR1cm4gZHggIT09IDAgPyBkeCA6IHZlcnRleEEueSAtIHZlcnRleEIueTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYnVpbGQgbG93ZXIgaHVsbFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgICAgICB3aGlsZSAobG93ZXIubGVuZ3RoID49IDIgXG4gICAgICAgICAgICAgICAgICAgJiYgVmVjdG9yLmNyb3NzMyhsb3dlcltsb3dlci5sZW5ndGggLSAyXSwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIHZlcnRleCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGxvd2VyLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb3dlci5wdXNoKHZlcnRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCB1cHBlciBodWxsXG4gICAgICAgIGZvciAoaSA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgd2hpbGUgKHVwcGVyLmxlbmd0aCA+PSAyIFxuICAgICAgICAgICAgICAgICAgICYmIFZlY3Rvci5jcm9zczModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCB2ZXJ0ZXgpIDw9IDApIHtcbiAgICAgICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBwZXIucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uY2F0ZW5hdGlvbiBvZiB0aGUgbG93ZXIgYW5kIHVwcGVyIGh1bGxzIGdpdmVzIHRoZSBjb252ZXggaHVsbFxuICAgICAgICAvLyBvbWl0IGxhc3QgcG9pbnRzIGJlY2F1c2UgdGhleSBhcmUgcmVwZWF0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgb3RoZXIgbGlzdFxuICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgbG93ZXIucG9wKCk7XG5cbiAgICAgICAgcmV0dXJuIHVwcGVyLmNvbmNhdChsb3dlcik7XG4gICAgfTtcblxufSkoKTtcblxufSx7XCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6Mjh9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTWF0dGVyID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi9jb3JlL01hdHRlcicpO1xuXG5NYXR0ZXIuQm9keSA9IF9kZXJlcV8oJy4uL2JvZHkvQm9keScpO1xuTWF0dGVyLkNvbXBvc2l0ZSA9IF9kZXJlcV8oJy4uL2JvZHkvQ29tcG9zaXRlJyk7XG5NYXR0ZXIuV29ybGQgPSBfZGVyZXFfKCcuLi9ib2R5L1dvcmxkJyk7XG5cbk1hdHRlci5Db250YWN0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0NvbnRhY3QnKTtcbk1hdHRlci5EZXRlY3RvciA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9EZXRlY3RvcicpO1xuTWF0dGVyLkdyaWQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vR3JpZCcpO1xuTWF0dGVyLlBhaXJzID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1BhaXJzJyk7XG5NYXR0ZXIuUGFpciA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9QYWlyJyk7XG5NYXR0ZXIuUXVlcnkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUXVlcnknKTtcbk1hdHRlci5SZXNvbHZlciA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SZXNvbHZlcicpO1xuTWF0dGVyLlNBVCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9TQVQnKTtcblxuTWF0dGVyLkNvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50L0NvbnN0cmFpbnQnKTtcbk1hdHRlci5Nb3VzZUNvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50L01vdXNlQ29uc3RyYWludCcpO1xuXG5NYXR0ZXIuQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcbk1hdHRlci5FbmdpbmUgPSBfZGVyZXFfKCcuLi9jb3JlL0VuZ2luZScpO1xuTWF0dGVyLkV2ZW50cyA9IF9kZXJlcV8oJy4uL2NvcmUvRXZlbnRzJyk7XG5NYXR0ZXIuTW91c2UgPSBfZGVyZXFfKCcuLi9jb3JlL01vdXNlJyk7XG5NYXR0ZXIuUnVubmVyID0gX2RlcmVxXygnLi4vY29yZS9SdW5uZXInKTtcbk1hdHRlci5TbGVlcGluZyA9IF9kZXJlcV8oJy4uL2NvcmUvU2xlZXBpbmcnKTtcbk1hdHRlci5QbHVnaW4gPSBfZGVyZXFfKCcuLi9jb3JlL1BsdWdpbicpO1xuXG5cbk1hdHRlci5Cb2RpZXMgPSBfZGVyZXFfKCcuLi9mYWN0b3J5L0JvZGllcycpO1xuTWF0dGVyLkNvbXBvc2l0ZXMgPSBfZGVyZXFfKCcuLi9mYWN0b3J5L0NvbXBvc2l0ZXMnKTtcblxuTWF0dGVyLkF4ZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9BeGVzJyk7XG5NYXR0ZXIuQm91bmRzID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XG5NYXR0ZXIuU3ZnID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvU3ZnJyk7XG5NYXR0ZXIuVmVjdG9yID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XG5NYXR0ZXIuVmVydGljZXMgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xuXG5NYXR0ZXIuUmVuZGVyID0gX2RlcmVxXygnLi4vcmVuZGVyL1JlbmRlcicpO1xuTWF0dGVyLlJlbmRlclBpeGkgPSBfZGVyZXFfKCcuLi9yZW5kZXIvUmVuZGVyUGl4aScpO1xuXG4vLyBhbGlhc2VzXG5cbk1hdHRlci5Xb3JsZC5hZGQgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZDtcbk1hdHRlci5Xb3JsZC5yZW1vdmUgPSBNYXR0ZXIuQ29tcG9zaXRlLnJlbW92ZTtcbk1hdHRlci5Xb3JsZC5hZGRDb21wb3NpdGUgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZENvbXBvc2l0ZTtcbk1hdHRlci5Xb3JsZC5hZGRCb2R5ID0gTWF0dGVyLkNvbXBvc2l0ZS5hZGRCb2R5O1xuTWF0dGVyLldvcmxkLmFkZENvbnN0cmFpbnQgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQ7XG5NYXR0ZXIuV29ybGQuY2xlYXIgPSBNYXR0ZXIuQ29tcG9zaXRlLmNsZWFyO1xuTWF0dGVyLkVuZ2luZS5ydW4gPSBNYXR0ZXIuUnVubmVyLnJ1bjtcblxufSx7XCIuLi9ib2R5L0JvZHlcIjoxLFwiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vYm9keS9Xb3JsZFwiOjMsXCIuLi9jb2xsaXNpb24vQ29udGFjdFwiOjQsXCIuLi9jb2xsaXNpb24vRGV0ZWN0b3JcIjo1LFwiLi4vY29sbGlzaW9uL0dyaWRcIjo2LFwiLi4vY29sbGlzaW9uL1BhaXJcIjo3LFwiLi4vY29sbGlzaW9uL1BhaXJzXCI6OCxcIi4uL2NvbGxpc2lvbi9RdWVyeVwiOjksXCIuLi9jb2xsaXNpb24vUmVzb2x2ZXJcIjoxMCxcIi4uL2NvbGxpc2lvbi9TQVRcIjoxMSxcIi4uL2NvbnN0cmFpbnQvQ29uc3RyYWludFwiOjEyLFwiLi4vY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnRcIjoxMyxcIi4uL2NvcmUvQ29tbW9uXCI6MTQsXCIuLi9jb3JlL0VuZ2luZVwiOjE1LFwiLi4vY29yZS9FdmVudHNcIjoxNixcIi4uL2NvcmUvTWF0dGVyXCI6MTcsXCIuLi9jb3JlL01ldHJpY3NcIjoxOCxcIi4uL2NvcmUvTW91c2VcIjoxOSxcIi4uL2NvcmUvUGx1Z2luXCI6MjAsXCIuLi9jb3JlL1J1bm5lclwiOjIxLFwiLi4vY29yZS9TbGVlcGluZ1wiOjIyLFwiLi4vZmFjdG9yeS9Cb2RpZXNcIjoyMyxcIi4uL2ZhY3RvcnkvQ29tcG9zaXRlc1wiOjI0LFwiLi4vZ2VvbWV0cnkvQXhlc1wiOjI1LFwiLi4vZ2VvbWV0cnkvQm91bmRzXCI6MjYsXCIuLi9nZW9tZXRyeS9TdmdcIjoyNyxcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4LFwiLi4vZ2VvbWV0cnkvVmVydGljZXNcIjoyOSxcIi4uL3JlbmRlci9SZW5kZXJcIjozMSxcIi4uL3JlbmRlci9SZW5kZXJQaXhpXCI6MzJ9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuUmVuZGVyYCBtb2R1bGUgaXMgYSBzaW1wbGUgSFRNTDUgY2FudmFzIGJhc2VkIHJlbmRlcmVyIGZvciB2aXN1YWxpc2luZyBpbnN0YW5jZXMgb2YgYE1hdHRlci5FbmdpbmVgLlxuKiBJdCBpcyBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBwdXJwb3NlcywgYnV0IG1heSBhbHNvIGJlIHN1aXRhYmxlIGZvciBzaW1wbGUgZ2FtZXMuXG4qIEl0IGluY2x1ZGVzIGEgbnVtYmVyIG9mIGRyYXdpbmcgb3B0aW9ucyBpbmNsdWRpbmcgd2lyZWZyYW1lLCB2ZWN0b3Igd2l0aCBzdXBwb3J0IGZvciBzcHJpdGVzIGFuZCB2aWV3cG9ydHMuXG4qXG4qIEBjbGFzcyBSZW5kZXJcbiovXG5cbnZhciBSZW5kZXIgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXI7XG5cbnZhciBDb21tb24gPSBfZGVyZXFfKCcuLi9jb3JlL0NvbW1vbicpO1xudmFyIENvbXBvc2l0ZSA9IF9kZXJlcV8oJy4uL2JvZHkvQ29tcG9zaXRlJyk7XG52YXIgQm91bmRzID0gX2RlcmVxXygnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XG52YXIgRXZlbnRzID0gX2RlcmVxXygnLi4vY29yZS9FdmVudHMnKTtcbnZhciBHcmlkID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0dyaWQnKTtcbnZhciBWZWN0b3IgPSBfZGVyZXFfKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcbnZhciBNb3VzZSA9IF9kZXJlcV8oJy4uL2NvcmUvTW91c2UnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKXsgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKENvbW1vbi5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XG5cbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXJlci4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge3JlbmRlcn0gQSBuZXcgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBSZW5kZXIuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjb250cm9sbGVyOiBSZW5kZXIsXG4gICAgICAgICAgICBlbmdpbmU6IG51bGwsXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgY2FudmFzOiBudWxsLFxuICAgICAgICAgICAgbW91c2U6IG51bGwsXG4gICAgICAgICAgICBmcmFtZVJlcXVlc3RJZDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IDEsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJyMxODE4MWQnLFxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZUJhY2tncm91bmQ6ICcjMGYwZjEzJyxcbiAgICAgICAgICAgICAgICBoYXNCb3VuZHM6ICEhb3B0aW9ucy5ib3VuZHMsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3dTbGVlcGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93RGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCcm9hZHBoYXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93Qm91bmRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VmVsb2NpdHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dDb2xsaXNpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93U2VwYXJhdGlvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dBeGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93UG9zaXRpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QW5nbGVJbmRpY2F0b3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dJZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dTaGFkb3dzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VmVydGV4TnVtYmVyczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0NvbnZleEh1bGxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd01vdXNlUG9zaXRpb246IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbmRlciA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZW5kZXIuY2FudmFzKSB7XG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLndpZHRoID0gcmVuZGVyLm9wdGlvbnMud2lkdGggfHwgcmVuZGVyLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHJlbmRlci5jYW52YXMuaGVpZ2h0ID0gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0IHx8IHJlbmRlci5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyLm1vdXNlID0gb3B0aW9ucy5tb3VzZTtcbiAgICAgICAgcmVuZGVyLmVuZ2luZSA9IG9wdGlvbnMuZW5naW5lO1xuICAgICAgICByZW5kZXIuY2FudmFzID0gcmVuZGVyLmNhbnZhcyB8fCBfY3JlYXRlQ2FudmFzKHJlbmRlci5vcHRpb25zLndpZHRoLCByZW5kZXIub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICByZW5kZXIuY29udGV4dCA9IHJlbmRlci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XG5cbiAgICAgICAgcmVuZGVyLmJvdW5kcyA9IHJlbmRlci5ib3VuZHMgfHwge1xuICAgICAgICAgICAgbWluOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICAgICAgeDogcmVuZGVyLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiByZW5kZXIuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBSZW5kZXIuc2V0UGl4ZWxSYXRpbyhyZW5kZXIsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbW1vbi5pc0VsZW1lbnQocmVuZGVyLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZW5kZXIuZWxlbWVudC5hcHBlbmRDaGlsZChyZW5kZXIuY2FudmFzKTtcbiAgICAgICAgfSBlbHNlIGlmICghcmVuZGVyLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBDb21tb24ubG9nKCdSZW5kZXIuY3JlYXRlOiBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgcmVuZGVyLmNhbnZhcyB3YXMgY3JlYXRlZCBidXQgbm90IGFwcGVuZGVkJywgJ3dhcm4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRpbnVvdXNseSB1cGRhdGVzIHRoZSByZW5kZXIgY2FudmFzIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKi9cbiAgICBSZW5kZXIucnVuID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIChmdW5jdGlvbiBsb29wKHRpbWUpe1xuICAgICAgICAgICAgcmVuZGVyLmZyYW1lUmVxdWVzdElkID0gX3JlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgICAgIFJlbmRlci53b3JsZChyZW5kZXIpO1xuICAgICAgICB9KSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUmVuZGVyLnJ1bmAgb24gdGhlIGdpdmVuIGByZW5kZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5zdG9wID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZShyZW5kZXIuZnJhbWVSZXF1ZXN0SWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIgYW5kIHVwZGF0ZXMgdGhlIGNhbnZhcy5cbiAgICAgKiBUbyBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgY29ycmVjdCByYXRpbywgcGFzcyB0aGUgc3RyaW5nIGAnYXV0bydgIGZvciBgcGl4ZWxSYXRpb2AuXG4gICAgICogQG1ldGhvZCBzZXRQaXhlbFJhdGlvXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXG4gICAgICovXG4gICAgUmVuZGVyLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbihyZW5kZXIsIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbnZhcyA9IHJlbmRlci5jYW52YXM7XG5cbiAgICAgICAgaWYgKHBpeGVsUmF0aW8gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IF9nZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLXBpeGVsLXJhdGlvJywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgcmVuZGVyLmNvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9ucyBhbmQgc2l6ZXMgdGhlIHZpZXdwb3J0IGFyb3VuZCB0aGUgZ2l2ZW4gb2JqZWN0IGJvdW5kcy5cbiAgICAgKiBPYmplY3RzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIC0gYG9iamVjdC5ib3VuZHNgXG4gICAgICogLSBgb2JqZWN0LnBvc2l0aW9uYFxuICAgICAqIC0gYG9iamVjdC5taW5gIGFuZCBgb2JqZWN0Lm1heGBcbiAgICAgKiAtIGBvYmplY3QueGAgYW5kIGBvYmplY3QueWBcbiAgICAgKiBAbWV0aG9kIGxvb2tBdFxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBvYmplY3RzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtwYWRkaW5nXVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2NlbnRlcj10cnVlXVxuICAgICAqL1xuICAgIFJlbmRlci5sb29rQXQgPSBmdW5jdGlvbihyZW5kZXIsIG9iamVjdHMsIHBhZGRpbmcsIGNlbnRlcikge1xuICAgICAgICBjZW50ZXIgPSB0eXBlb2YgY2VudGVyICE9PSAndW5kZWZpbmVkJyA/IGNlbnRlciA6IHRydWU7XG4gICAgICAgIG9iamVjdHMgPSBDb21tb24uaXNBcnJheShvYmplY3RzKSA/IG9iamVjdHMgOiBbb2JqZWN0c107XG4gICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nIHx8IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmluZCBib3VuZHMgb2YgYWxsIG9iamVjdHNcbiAgICAgICAgdmFyIGJvdW5kcyA9IHtcbiAgICAgICAgICAgIG1pbjogeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHkgfSxcbiAgICAgICAgICAgIG1heDogeyB4OiAtSW5maW5pdHksIHk6IC1JbmZpbml0eSB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tpXSxcbiAgICAgICAgICAgICAgICBtaW4gPSBvYmplY3QuYm91bmRzID8gb2JqZWN0LmJvdW5kcy5taW4gOiAob2JqZWN0Lm1pbiB8fCBvYmplY3QucG9zaXRpb24gfHwgb2JqZWN0KSxcbiAgICAgICAgICAgICAgICBtYXggPSBvYmplY3QuYm91bmRzID8gb2JqZWN0LmJvdW5kcy5tYXggOiAob2JqZWN0Lm1heCB8fCBvYmplY3QucG9zaXRpb24gfHwgb2JqZWN0KTtcblxuICAgICAgICAgICAgaWYgKG1pbiAmJiBtYXgpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluLnggPCBib3VuZHMubWluLngpXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueCA9IG1pbi54O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heC54ID4gYm91bmRzLm1heC54KVxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWF4LnggPSBtYXgueDtcblxuICAgICAgICAgICAgICAgIGlmIChtaW4ueSA8IGJvdW5kcy5taW4ueSlcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1pbi55ID0gbWluLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4LnkgPiBib3VuZHMubWF4LnkpXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueSA9IG1heC55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCByYXRpb3NcbiAgICAgICAgdmFyIHdpZHRoID0gKGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCkgKyAyICogcGFkZGluZy54LFxuICAgICAgICAgICAgaGVpZ2h0ID0gKGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSkgKyAyICogcGFkZGluZy55LFxuICAgICAgICAgICAgdmlld0hlaWdodCA9IHJlbmRlci5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgdmlld1dpZHRoID0gcmVuZGVyLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIG91dGVyUmF0aW8gPSB2aWV3V2lkdGggLyB2aWV3SGVpZ2h0LFxuICAgICAgICAgICAgaW5uZXJSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0LFxuICAgICAgICAgICAgc2NhbGVYID0gMSxcbiAgICAgICAgICAgIHNjYWxlWSA9IDE7XG5cbiAgICAgICAgLy8gZmluZCBzY2FsZSBmYWN0b3JcbiAgICAgICAgaWYgKGlubmVyUmF0aW8gPiBvdXRlclJhdGlvKSB7XG4gICAgICAgICAgICBzY2FsZVkgPSBpbm5lclJhdGlvIC8gb3V0ZXJSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IG91dGVyUmF0aW8gLyBpbm5lclJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5hYmxlIGJvdW5kc1xuICAgICAgICByZW5kZXIub3B0aW9ucy5oYXNCb3VuZHMgPSB0cnVlO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIGFuZCBzaXplXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnggPSBib3VuZHMubWluLng7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggPSBib3VuZHMubWluLnggKyB3aWR0aCAqIHNjYWxlWDtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueSA9IGJvdW5kcy5taW4ueTtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSA9IGJvdW5kcy5taW4ueSArIGhlaWdodCAqIHNjYWxlWTtcblxuICAgICAgICAvLyBjZW50ZXJcbiAgICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueCArPSB3aWR0aCAqIDAuNSAtICh3aWR0aCAqIHNjYWxlWCkgKiAwLjU7XG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1heC54ICs9IHdpZHRoICogMC41IC0gKHdpZHRoICogc2NhbGVYKSAqIDAuNTtcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWluLnkgKz0gaGVpZ2h0ICogMC41IC0gKGhlaWdodCAqIHNjYWxlWSkgKiAwLjU7XG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1heC55ICs9IGhlaWdodCAqIDAuNSAtIChoZWlnaHQgKiBzY2FsZVkpICogMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi54IC09IHBhZGRpbmcueDtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueCAtPSBwYWRkaW5nLng7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnkgLT0gcGFkZGluZy55O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1heC55IC09IHBhZGRpbmcueTtcblxuICAgICAgICAvLyB1cGRhdGUgbW91c2VcbiAgICAgICAgaWYgKHJlbmRlci5tb3VzZSkge1xuICAgICAgICAgICAgTW91c2Uuc2V0U2NhbGUocmVuZGVyLm1vdXNlLCB7XG4gICAgICAgICAgICAgICAgeDogKHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54KSAvIHJlbmRlci5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogKHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55KSAvIHJlbmRlci5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTW91c2Uuc2V0T2Zmc2V0KHJlbmRlci5tb3VzZSwgcmVuZGVyLmJvdW5kcy5taW4pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdmlld3BvcnQgdHJhbnNmb3JtcyBiYXNlZCBvbiBgcmVuZGVyLmJvdW5kc2AgdG8gYSByZW5kZXIgY29udGV4dC5cbiAgICAgKiBAbWV0aG9kIHN0YXJ0Vmlld1RyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKi9cbiAgICBSZW5kZXIuc3RhcnRWaWV3VHJhbnNmb3JtID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIHZhciBib3VuZHNXaWR0aCA9IHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54LFxuICAgICAgICAgICAgYm91bmRzSGVpZ2h0ID0gcmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnksXG4gICAgICAgICAgICBib3VuZHNTY2FsZVggPSBib3VuZHNXaWR0aCAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgYm91bmRzU2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICAgIHJlbmRlci5jb250ZXh0LnNjYWxlKDEgLyBib3VuZHNTY2FsZVgsIDEgLyBib3VuZHNTY2FsZVkpO1xuICAgICAgICByZW5kZXIuY29udGV4dC50cmFuc2xhdGUoLXJlbmRlci5ib3VuZHMubWluLngsIC1yZW5kZXIuYm91bmRzLm1pbi55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCB0cmFuc2Zvcm1zIG9uIHRoZSByZW5kZXIgY29udGV4dC5cbiAgICAgKiBAbWV0aG9kIGVuZFZpZXdUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLmVuZFZpZXdUcmFuc2Zvcm0gPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgcmVuZGVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8sIDAsIDAsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBgZW5naW5lYCdzIGBNYXR0ZXIuV29ybGRgIG9iamVjdC5cbiAgICAgKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYWxsIHJlbmRlcmluZyBhbmQgc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBzY2VuZSBjaGFuZ2VzLlxuICAgICAqIEBtZXRob2Qgd29ybGRcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLndvcmxkID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBjYW52YXMgPSByZW5kZXIuY2FudmFzLFxuICAgICAgICAgICAgY29udGV4dCA9IHJlbmRlci5jb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgYWxsQm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kID0gb3B0aW9ucy53aXJlZnJhbWVzID8gb3B0aW9ucy53aXJlZnJhbWVCYWNrZ3JvdW5kIDogb3B0aW9ucy5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgYm9kaWVzID0gW10sXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IFtdLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IGVuZ2luZS50aW1pbmcudGltZXN0YW1wXG4gICAgICAgIH07XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocmVuZGVyLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpO1xuXG4gICAgICAgIC8vIGFwcGx5IGJhY2tncm91bmQgaWYgaXQgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCAhPT0gYmFja2dyb3VuZClcbiAgICAgICAgICAgIF9hcHBseUJhY2tncm91bmQocmVuZGVyLCBiYWNrZ3JvdW5kKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2FudmFzIHdpdGggYSB0cmFuc3BhcmVudCBmaWxsLCB0byBhbGxvdyB0aGUgY2FudmFzIGJhY2tncm91bmQgdG8gc2hvd1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2UtaW4nO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG5cbiAgICAgICAgLy8gaGFuZGxlIGJvdW5kc1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYm9kaWVzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhbGxCb2RpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhib2R5LmJvdW5kcywgcmVuZGVyLmJvdW5kcykpXG4gICAgICAgICAgICAgICAgICAgIGJvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGNvbnN0cmFpbnRzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGFsbENvbnN0cmFpbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRBV29ybGQgPSBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBjb25zdHJhaW50LnBvaW50QjtcblxuICAgICAgICAgICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCKSBwb2ludEJXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKTtcblxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRBV29ybGQgfHwgIXBvaW50QldvcmxkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRBV29ybGQpIHx8IEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEJXb3JsZCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgdmlld1xuICAgICAgICAgICAgUmVuZGVyLnN0YXJ0Vmlld1RyYW5zZm9ybShyZW5kZXIpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbW91c2VcbiAgICAgICAgICAgIGlmIChyZW5kZXIubW91c2UpIHtcbiAgICAgICAgICAgICAgICBNb3VzZS5zZXRTY2FsZShyZW5kZXIubW91c2UsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogKHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54KSAvIHJlbmRlci5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHk6IChyZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSkgLyByZW5kZXIuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgTW91c2Uuc2V0T2Zmc2V0KHJlbmRlci5tb3VzZSwgcmVuZGVyLmJvdW5kcy5taW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3RyYWludHMgPSBhbGxDb25zdHJhaW50cztcbiAgICAgICAgICAgIGJvZGllcyA9IGFsbEJvZGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy53aXJlZnJhbWVzIHx8IChlbmdpbmUuZW5hYmxlU2xlZXBpbmcgJiYgb3B0aW9ucy5zaG93U2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAvLyBmdWxseSBmZWF0dXJlZCByZW5kZXJpbmcgb2YgYm9kaWVzXG4gICAgICAgICAgICBSZW5kZXIuYm9kaWVzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dDb252ZXhIdWxscylcbiAgICAgICAgICAgICAgICBSZW5kZXIuYm9keUNvbnZleEh1bGxzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gb3B0aW1pc2VkIG1ldGhvZCBmb3Igd2lyZWZyYW1lcyBvbmx5XG4gICAgICAgICAgICBSZW5kZXIuYm9keVdpcmVmcmFtZXMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0JvdW5kcylcbiAgICAgICAgICAgIFJlbmRlci5ib2R5Qm91bmRzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93QXhlcyB8fCBvcHRpb25zLnNob3dBbmdsZUluZGljYXRvcilcbiAgICAgICAgICAgIFJlbmRlci5ib2R5QXhlcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Bvc2l0aW9ucylcbiAgICAgICAgICAgIFJlbmRlci5ib2R5UG9zaXRpb25zKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93VmVsb2NpdHkpXG4gICAgICAgICAgICBSZW5kZXIuYm9keVZlbG9jaXR5KHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93SWRzKVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlJZHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dTZXBhcmF0aW9ucylcbiAgICAgICAgICAgIFJlbmRlci5zZXBhcmF0aW9ucyhyZW5kZXIsIGVuZ2luZS5wYWlycy5saXN0LCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Q29sbGlzaW9ucylcbiAgICAgICAgICAgIFJlbmRlci5jb2xsaXNpb25zKHJlbmRlciwgZW5naW5lLnBhaXJzLmxpc3QsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dWZXJ0ZXhOdW1iZXJzKVxuICAgICAgICAgICAgUmVuZGVyLnZlcnRleE51bWJlcnMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dNb3VzZVBvc2l0aW9uKVxuICAgICAgICAgICAgUmVuZGVyLm1vdXNlUG9zaXRpb24ocmVuZGVyLCByZW5kZXIubW91c2UsIGNvbnRleHQpO1xuXG4gICAgICAgIFJlbmRlci5jb25zdHJhaW50cyhjb25zdHJhaW50cywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0Jyb2FkcGhhc2UgJiYgZW5naW5lLmJyb2FkcGhhc2UuY29udHJvbGxlciA9PT0gR3JpZClcbiAgICAgICAgICAgIFJlbmRlci5ncmlkKHJlbmRlciwgZW5naW5lLmJyb2FkcGhhc2UsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dEZWJ1ZylcbiAgICAgICAgICAgIFJlbmRlci5kZWJ1ZyhyZW5kZXIsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcykge1xuICAgICAgICAgICAgLy8gcmV2ZXJ0IHZpZXcgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgUmVuZGVyLmVuZFZpZXdUcmFuc2Zvcm0ocmVuZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJlbmRlciwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBkZWJ1Z1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuZGVidWcgPSBmdW5jdGlvbihyZW5kZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgbWV0cmljcyA9IGVuZ2luZS5tZXRyaWNzLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBzcGFjZSA9IFwiICAgIFwiO1xuXG4gICAgICAgIGlmIChlbmdpbmUudGltaW5nLnRpbWVzdGFtcCAtIChyZW5kZXIuZGVidWdUaW1lc3RhbXAgfHwgMCkgPj0gNTAwKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmIChtZXRyaWNzLnRpbWluZykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJmcHM6IFwiICsgTWF0aC5yb3VuZChtZXRyaWNzLnRpbWluZy5mcHMpICsgc3BhY2U7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmVuZGVyLmRlYnVnU3RyaW5nID0gdGV4dDtcbiAgICAgICAgICAgIHJlbmRlci5kZWJ1Z1RpbWVzdGFtcCA9IGVuZ2luZS50aW1pbmcudGltZXN0YW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlci5kZWJ1Z1N0cmluZykge1xuICAgICAgICAgICAgYy5mb250ID0gXCIxMnB4IEFyaWFsXCI7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNSknO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSByZW5kZXIuZGVidWdTdHJpbmcuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsVGV4dChzcGxpdFtpXSwgNTAsIDUwICsgaSAqIDE4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBjb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludFtdfSBjb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5jb25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQucmVuZGVyLnZpc2libGUgfHwgIWNvbnN0cmFpbnQucG9pbnRBIHx8ICFjb25zdHJhaW50LnBvaW50QilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kO1xuXG4gICAgICAgICAgICBpZiAoYm9keUEpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBjb25zdHJhaW50LnBvaW50QTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmVuZGVyLnR5cGUgPT09ICdwaW4nKSB7XG4gICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjLmFyYyhzdGFydC54LCBzdGFydC55LCAzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBjb25zdHJhaW50LnBvaW50QjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmVuZGVyLnR5cGUgPT09ICdzcHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IFZlY3Rvci5zdWIoZW5kLCBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBWZWN0b3IucGVycChWZWN0b3Iubm9ybWFsaXNlKGRlbHRhKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2lscyA9IE1hdGguY2VpbChDb21tb24uY2xhbXAoY29uc3RyYWludC5sZW5ndGggLyA1LCAxMiwgMjApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGNvaWxzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGogJSAyID09PSAwID8gMSA6IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydC54ICsgZGVsdGEueCAqIChqIC8gY29pbHMpICsgbm9ybWFsLnggKiBvZmZzZXQgKiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnkgKyBkZWx0YS55ICogKGogLyBjb2lscykgKyBub3JtYWwueSAqIG9mZnNldCAqIDRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhlbmQueCwgZW5kLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yZW5kZXIubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSBjb25zdHJhaW50LnJlbmRlci5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IGNvbnN0cmFpbnQucmVuZGVyLnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LnJlbmRlci5hbmNob3JzKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBjb25zdHJhaW50LnJlbmRlci5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMuYXJjKHN0YXJ0LngsIHN0YXJ0LnksIDMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjLmFyYyhlbmQueCwgZW5kLnksIDMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlTaGFkb3dzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVNoYWRvd3MgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5jaXJjbGVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMuYXJjKGJvZHkucG9zaXRpb24ueCwgYm9keS5wb3NpdGlvbi55LCBib2R5LmNpcmNsZVJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8oYm9keS52ZXJ0aWNlc1swXS54LCBib2R5LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYm9keS52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzW2pdLngsIGJvZHkudmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBib2R5LnBvc2l0aW9uLnggLSByZW5kZXIub3B0aW9ucy53aWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVkgPSBib2R5LnBvc2l0aW9uLnkgLSByZW5kZXIub3B0aW9ucy5oZWlnaHQgKiAwLjIsXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZVgpICsgTWF0aC5hYnMoZGlzdGFuY2VZKTtcblxuICAgICAgICAgICAgYy5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMTUpJztcbiAgICAgICAgICAgIGMuc2hhZG93T2Zmc2V0WCA9IDAuMDUgKiBkaXN0YW5jZVg7XG4gICAgICAgICAgICBjLnNoYWRvd09mZnNldFkgPSAwLjA1ICogZGlzdGFuY2VZO1xuICAgICAgICAgICAgYy5zaGFkb3dCbHVyID0gMSArIDEyICogTWF0aC5taW4oMSwgZGlzdGFuY2UgLyAxMDAwKTtcblxuICAgICAgICAgICAgYy5maWxsKCk7XG5cbiAgICAgICAgICAgIGMuc2hhZG93Q29sb3IgPSBudWxsO1xuICAgICAgICAgICAgYy5zaGFkb3dPZmZzZXRYID0gbnVsbDtcbiAgICAgICAgICAgIGMuc2hhZG93T2Zmc2V0WSA9IG51bGw7XG4gICAgICAgICAgICBjLnNoYWRvd0JsdXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZGllc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZGllcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IG9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXMgfHwgIW9wdGlvbnMud2lyZWZyYW1lcyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcbiAgICAgICAgICAgIGZvciAoayA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dTbGVlcGluZyAmJiBib2R5LmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IDAuNSAqIHBhcnQucmVuZGVyLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnJlbmRlci5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSBwYXJ0LnJlbmRlci5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnJlbmRlci5zcHJpdGUgJiYgcGFydC5yZW5kZXIuc3ByaXRlLnRleHR1cmUgJiYgIW9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IHNwcml0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gcGFydC5yZW5kZXIuc3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IF9nZXRUZXh0dXJlKHJlbmRlciwgc3ByaXRlLnRleHR1cmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGMudHJhbnNsYXRlKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICAgICAgYy5yb3RhdGUocGFydC5hbmdsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYy5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS53aWR0aCAqIC1zcHJpdGUueE9mZnNldCAqIHNwcml0ZS54U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCAqIC1zcHJpdGUueU9mZnNldCAqIHNwcml0ZS55U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoICogc3ByaXRlLnhTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ICogc3ByaXRlLnlTY2FsZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldmVydCB0cmFuc2xhdGlvbiwgaG9wZWZ1bGx5IGZhc3RlciB0aGFuIHNhdmUgLyByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGMucm90YXRlKC1wYXJ0LmFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgYy50cmFuc2xhdGUoLXBhcnQucG9zaXRpb24ueCwgLXBhcnQucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydCBwb2x5Z29uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNpcmNsZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYXJjKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55LCBwYXJ0LmNpcmNsZVJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbMF0ueCwgcGFydC52ZXJ0aWNlc1swXS55KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnZlcnRpY2VzW2ogLSAxXS5pc0ludGVybmFsIHx8IHNob3dJbnRlcm5hbEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzW2pdLngsIHBhcnQudmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQudmVydGljZXNbal0uaXNJbnRlcm5hbCAmJiAhc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLngsIHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbMF0ueCwgcGFydC52ZXJ0aWNlc1swXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBwYXJ0LnJlbmRlci5maWxsU3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnJlbmRlci5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IHBhcnQucmVuZGVyLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gcGFydC5yZW5kZXIuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJyNiYmInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXNlZCBtZXRob2QgZm9yIGRyYXdpbmcgYm9keSB3aXJlZnJhbWVzIGluIG9uZSBwYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlXaXJlZnJhbWVzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVdpcmVmcmFtZXMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IHJlbmRlci5vcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgYWxsIGJvZGllc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgZm9yIChrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGJvZHkucGFydHNba107XG5cbiAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgcGFydC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQudmVydGljZXNbaiAtIDFdLmlzSW50ZXJuYWwgfHwgc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnZlcnRpY2VzW2pdLmlzSW50ZXJuYWwgJiYgIXNob3dJbnRlcm5hbEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueCwgcGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJyNiYmInO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWlzZWQgbWV0aG9kIGZvciBkcmF3aW5nIGJvZHkgY29udmV4IGh1bGwgd2lyZWZyYW1lcyBpbiBvbmUgcGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5Q29udmV4SHVsbHNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5Q29udmV4SHVsbHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBjb252ZXggaHVsbHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlIHx8IGJvZHkucGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5LnZlcnRpY2VzWzBdLngsIGJvZHkudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBib2R5LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYy5saW5lVG8oYm9keS52ZXJ0aWNlc1tqXS54LCBib2R5LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzWzBdLngsIGJvZHkudmVydGljZXNbMF0ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBib2R5IHZlcnRleCBudW1iZXJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCB2ZXJ0ZXhOdW1iZXJzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIudmVydGV4TnVtYmVycyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBib2RpZXNbaV0ucGFydHM7XG4gICAgICAgICAgICBmb3IgKGsgPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBwYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNba107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsVGV4dChpICsgJ18nICsgaiwgcGFydC5wb3NpdGlvbi54ICsgKHBhcnQudmVydGljZXNbal0ueCAtIHBhcnQucG9zaXRpb24ueCkgKiAwLjgsIHBhcnQucG9zaXRpb24ueSArIChwYXJ0LnZlcnRpY2VzW2pdLnkgLSBwYXJ0LnBvc2l0aW9uLnkpICogMC44KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgbW91c2VQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5tb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24ocmVuZGVyLCBtb3VzZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XG4gICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC44KSc7XG4gICAgICAgIGMuZmlsbFRleHQobW91c2UucG9zaXRpb24ueCArICcgICcgKyBtb3VzZS5wb3NpdGlvbi55LCBtb3VzZS5wb3NpdGlvbi54ICsgNSwgbW91c2UucG9zaXRpb24ueSAtIDUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5Qm91bmRzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keUJvdW5kcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnM7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChib2R5LnJlbmRlci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjLnJlY3QocGFydC5ib3VuZHMubWluLngsIHBhcnQuYm91bmRzLm1pbi55LCBwYXJ0LmJvdW5kcy5tYXgueCAtIHBhcnQuYm91bmRzLm1pbi54LCBwYXJ0LmJvdW5kcy5tYXgueSAtIHBhcnQuYm91bmRzLm1pbi55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wOCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IGFuZ2xlIGluZGljYXRvcnMgYW5kIGF4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keUF4ZXNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5QXhlcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgcGFydHMgPSBib2R5LnBhcnRzO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dBeGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFsbCBheGVzXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydC5heGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHBhcnQuYXhlc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQucG9zaXRpb24ueCArIGF4aXMueCAqIDIwLCBwYXJ0LnBvc2l0aW9uLnkgKyBheGlzLnkgKiAyMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnQuYXhlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGEgc2luZ2xlIGF4aXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbygocGFydC52ZXJ0aWNlc1swXS54ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS54KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGFydC52ZXJ0aWNlc1swXS55ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS55KSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdpbmRpYW5yZWQnO1xuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCknO1xuICAgICAgICAgICAgYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnb3ZlcmxheSc7XG4gICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBjLnN0cm9rZSgpO1xuICAgICAgICBjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlQb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5UG9zaXRpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGJvZHkucGFydHNba107XG4gICAgICAgICAgICAgICAgYy5hcmMocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnksIDMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ2luZGlhbnJlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNSknO1xuICAgICAgICB9XG4gICAgICAgIGMuZmlsbCgpO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIHByZXZpb3VzIHBvc2l0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkucmVuZGVyLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjLmFyYyhib2R5LnBvc2l0aW9uUHJldi54LCBib2R5LnBvc2l0aW9uUHJldi55LCAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjgpJztcbiAgICAgICAgYy5maWxsKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgdmVsb2NpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keVZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVZlbG9jaXR5ID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0O1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHkucG9zaXRpb24ueCwgYm9keS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHkucG9zaXRpb24ueCArIChib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54KSAqIDIsIGJvZHkucG9zaXRpb24ueSArIChib2R5LnBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uUHJldi55KSAqIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAzO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ2Nvcm5mbG93ZXJibHVlJztcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9keSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keUlkc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZHlJZHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJvZGllc1tpXS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xuICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgIGMuZm9udCA9IFwiMTJweCBBcmlhbFwiO1xuICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC41KSc7XG4gICAgICAgICAgICAgICAgYy5maWxsVGV4dChwYXJ0LmlkLCBwYXJ0LnBvc2l0aW9uLnggKyAxMCwgcGFydC5wb3NpdGlvbi55IC0gMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGNvbGxpc2lvbnNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihyZW5kZXIsIHBhaXJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb2xsaXNpb24sXG4gICAgICAgICAgICBjb3JyZWN0ZWQsXG4gICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgY29sbGlzaW9uIHBvc2l0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzW2pdLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSBjb250YWN0LnZlcnRleDtcbiAgICAgICAgICAgICAgICBjLnJlY3QodmVydGV4LnggLSAxLjUsIHZlcnRleC55IC0gMS41LCAzLjUsIDMuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAnb3JhbmdlJztcbiAgICAgICAgfVxuICAgICAgICBjLmZpbGwoKTtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBjb2xsaXNpb24gbm9ybWFsc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcblxuICAgICAgICAgICAgaWYgKHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxQb3NYID0gcGFpci5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWSA9IHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4Lnk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWCA9IChwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC54ICsgcGFpci5hY3RpdmVDb250YWN0c1sxXS52ZXJ0ZXgueCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxQb3NZID0gKHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4LnkgKyBwYWlyLmFjdGl2ZUNvbnRhY3RzWzFdLnZlcnRleC55KSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5ib2R5QiA9PT0gY29sbGlzaW9uLnN1cHBvcnRzWzBdLmJvZHkgfHwgY29sbGlzaW9uLmJvZHlBLmlzU3RhdGljID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKG5vcm1hbFBvc1ggLSBjb2xsaXNpb24ubm9ybWFsLnggKiA4LCBub3JtYWxQb3NZIC0gY29sbGlzaW9uLm5vcm1hbC55ICogOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8obm9ybWFsUG9zWCArIGNvbGxpc2lvbi5ub3JtYWwueCAqIDgsIG5vcm1hbFBvc1kgKyBjb2xsaXNpb24ubm9ybWFsLnkgKiA4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhub3JtYWxQb3NYLCBub3JtYWxQb3NZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC43KSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ29yYW5nZSc7XG4gICAgICAgIH1cblxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHNlcGFyYXRpb25zXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5zZXBhcmF0aW9ucyA9IGZ1bmN0aW9uKHJlbmRlciwgcGFpcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGNvcnJlY3RlZCxcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBzZXBhcmF0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcbiAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUI7XG5cbiAgICAgICAgICAgIHZhciBrID0gMTtcblxuICAgICAgICAgICAgaWYgKCFib2R5Qi5pc1N0YXRpYyAmJiAhYm9keUEuaXNTdGF0aWMpIGsgPSAwLjU7XG4gICAgICAgICAgICBpZiAoYm9keUIuaXNTdGF0aWMpIGsgPSAwO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5Qi5wb3NpdGlvbi54LCBib2R5Qi5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHlCLnBvc2l0aW9uLnggLSBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCAqIGssIGJvZHlCLnBvc2l0aW9uLnkgLSBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSAqIGspO1xuXG4gICAgICAgICAgICBrID0gMTtcblxuICAgICAgICAgICAgaWYgKCFib2R5Qi5pc1N0YXRpYyAmJiAhYm9keUEuaXNTdGF0aWMpIGsgPSAwLjU7XG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTdGF0aWMpIGsgPSAwO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5QS5wb3NpdGlvbi54LCBib2R5QS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHlBLnBvc2l0aW9uLnggKyBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCAqIGssIGJvZHlBLnBvc2l0aW9uLnkgKyBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSAqIGspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjUpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnb3JhbmdlJztcbiAgICAgICAgfVxuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBncmlkXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Z3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ncmlkID0gZnVuY3Rpb24ocmVuZGVyLCBncmlkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucztcblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE4MCwwLDAuMSknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxODAsMCwwLjUpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIGJ1Y2tldEtleXMgPSBDb21tb24ua2V5cyhncmlkLmJ1Y2tldHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldElkID0gYnVja2V0S2V5c1tpXTtcblxuICAgICAgICAgICAgaWYgKGdyaWQuYnVja2V0c1tidWNrZXRJZF0ubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGJ1Y2tldElkLnNwbGl0KC9DfFIvKTtcbiAgICAgICAgICAgIGMucmVjdCgwLjUgKyBwYXJzZUludChyZWdpb25bMV0sIDEwKSAqIGdyaWQuYnVja2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIDAuNSArIHBhcnNlSW50KHJlZ2lvblsyXSwgMTApICogZ3JpZC5idWNrZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQuYnVja2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQuYnVja2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgaW5zcGVjdG9yXG4gICAgICogQHBhcmFtIHtpbnNwZWN0b3J9IGluc3BlY3RvclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5pbnNwZWN0b3IgPSBmdW5jdGlvbihpbnNwZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGVuZ2luZSA9IGluc3BlY3Rvci5lbmdpbmUsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGluc3BlY3Rvci5zZWxlY3RlZCxcbiAgICAgICAgICAgIHJlbmRlciA9IGluc3BlY3Rvci5yZW5kZXIsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBib3VuZHM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzV2lkdGggPSByZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgICAgICBib3VuZHNIZWlnaHQgPSByZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgICAgICBib3VuZHNTY2FsZVggPSBib3VuZHNXaWR0aCAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgIGJvdW5kc1NjYWxlWSA9IGJvdW5kc0hlaWdodCAvIHJlbmRlci5vcHRpb25zLmhlaWdodDtcblxuICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxIC8gYm91bmRzU2NhbGVYLCAxIC8gYm91bmRzU2NhbGVZKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1yZW5kZXIuYm91bmRzLm1pbi54LCAtcmVuZGVyLmJvdW5kcy5taW4ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGVkW2ldLmRhdGE7XG5cbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC45KSc7XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLDJdKTtcblxuICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSAnYm9keSc6XG5cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgYm9keSBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHM7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoTWF0aC5mbG9vcihib3VuZHMubWluLnggLSAzKSwgTWF0aC5mbG9vcihib3VuZHMubWluLnkgLSAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLSBib3VuZHMubWluLnggKyA2KSwgTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkgKyA2KSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGNvbnN0cmFpbnQgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGl0ZW0ucG9pbnRBO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmJvZHlBKVxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGl0ZW0ucG9pbnRCO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMocG9pbnQueCwgcG9pbnQueSwgMTAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVuZGVyIHNlbGVjdGlvbiByZWdpb25cbiAgICAgICAgaWYgKGluc3BlY3Rvci5zZWxlY3RTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjYpJztcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuMSknO1xuICAgICAgICAgICAgYm91bmRzID0gaW5zcGVjdG9yLnNlbGVjdEJvdW5kcztcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoTWF0aC5mbG9vcihib3VuZHMubWluLngpLCBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLSBib3VuZHMubWluLngpLCBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSkpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKVxuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQ2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gd2lkdGhcbiAgICAgKiBAcGFyYW0ge30gaGVpZ2h0XG4gICAgICogQHJldHVybiBjYW52YXNcbiAgICAgKi9cbiAgICB2YXIgX2NyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY2FudmFzLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICBjYW52YXMub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuXG4gICAgICogQG1ldGhvZCBfZ2V0UGl4ZWxSYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2FudmFzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBwaXhlbCByYXRpb1xuICAgICAqL1xuICAgIHZhciBfZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICBiYWNraW5nU3RvcmVQaXhlbFJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUGl4ZWxSYXRpbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmVxdWVzdGVkIHRleHR1cmUgKGFuIEltYWdlKSB2aWEgaXRzIHBhdGhcbiAgICAgKiBAbWV0aG9kIF9nZXRUZXh0dXJlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlUGF0aFxuICAgICAqIEByZXR1cm4ge0ltYWdlfSB0ZXh0dXJlXG4gICAgICovXG4gICAgdmFyIF9nZXRUZXh0dXJlID0gZnVuY3Rpb24ocmVuZGVyLCBpbWFnZVBhdGgpIHtcbiAgICAgICAgdmFyIGltYWdlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF07XG5cbiAgICAgICAgaWYgKGltYWdlKVxuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuXG4gICAgICAgIGltYWdlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF0gPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VQYXRoO1xuXG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgYmFja2dyb3VuZCB0byB0aGUgY2FudmFzIHVzaW5nIENTUy5cbiAgICAgKiBAbWV0aG9kIGFwcGx5QmFja2dyb3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kXG4gICAgICovXG4gICAgdmFyIF9hcHBseUJhY2tncm91bmQgPSBmdW5jdGlvbihyZW5kZXIsIGJhY2tncm91bmQpIHtcbiAgICAgICAgdmFyIGNzc0JhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXG4gICAgICAgIGlmICgvKGpwZ3xnaWZ8cG5nKSQvLnRlc3QoYmFja2dyb3VuZCkpXG4gICAgICAgICAgICBjc3NCYWNrZ3JvdW5kID0gJ3VybCgnICsgYmFja2dyb3VuZCArICcpJztcblxuICAgICAgICByZW5kZXIuY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBjc3NCYWNrZ3JvdW5kO1xuICAgICAgICByZW5kZXIuY2FudmFzLnN0eWxlLmJhY2tncm91bmRTaXplID0gXCJjb250YWluXCI7XG4gICAgICAgIHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGJlZm9yZSByZW5kZXJpbmdcbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciByZW5kZXJpbmdcbiAgICAqXG4gICAgKiBAZXZlbnQgYWZ0ZXJSZW5kZXJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYmFjay1yZWZlcmVuY2UgdG8gdGhlIGBNYXR0ZXIuUmVuZGVyYCBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29udHJvbGxlclxuICAgICAqIEB0eXBlIHJlbmRlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBNYXR0ZXIuRW5naW5lYCBpbnN0YW5jZSB0byBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVuZ2luZVxuICAgICAqIEB0eXBlIGVuZ2luZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgd2hlcmUgdGhlIGNhbnZhcyBpcyB0byBiZSBpbnNlcnRlZCAoaWYgYHJlbmRlci5jYW52YXNgIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZWxlbWVudFxuICAgICAqIEB0eXBlIEhUTUxFbGVtZW50XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRvIHJlbmRlciB0by4gSWYgbm90IHNwZWNpZmllZCwgb25lIHdpbGwgYmUgY3JlYXRlZCBpZiBgcmVuZGVyLmVsZW1lbnRgIGhhcyBiZWVuIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjYW52YXNcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIGByZW5kZXIuY2FudmFzYCB0byBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMud2lkdGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA4MDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgYHJlbmRlci5jYW52YXNgIHRvIGJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5oZWlnaHRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyBpZiBgcmVuZGVyLmJvdW5kc2Agc2hvdWxkIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5oYXNCb3VuZHNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvdW5kc2Agb2JqZWN0IHRoYXQgc3BlY2lmaWVzIHRoZSBkcmF3aW5nIHZpZXcgcmVnaW9uLlxuICAgICAqIFJlbmRlcmluZyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgYW5kIHNjYWxlZCB0byBmaXQgd2l0aGluIHRoZSBjYW52YXMgc2l6ZSAoYHJlbmRlci5vcHRpb25zLndpZHRoYCBhbmQgYHJlbmRlci5vcHRpb25zLmhlaWdodGApLlxuICAgICAqIFRoaXMgYWxsb3dzIGZvciBjcmVhdGluZyB2aWV3cyB0aGF0IGNhbiBwYW4gb3Igem9vbSBhcm91bmQgdGhlIHNjZW5lLlxuICAgICAqIFlvdSBtdXN0IGFsc28gc2V0IGByZW5kZXIub3B0aW9ucy5oYXNCb3VuZHNgIHRvIGB0cnVlYCB0byBlbmFibGUgYm91bmRlZCByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXG4gICAgICogQHR5cGUgYm91bmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgMmQgcmVuZGVyaW5nIGNvbnRleHQgZnJvbSB0aGUgYHJlbmRlci5jYW52YXNgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwcml0ZSB0ZXh0dXJlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVzXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxufSkoKTtcblxufSx7XCIuLi9ib2R5L0NvbXBvc2l0ZVwiOjIsXCIuLi9jb2xsaXNpb24vR3JpZFwiOjYsXCIuLi9jb3JlL0NvbW1vblwiOjE0LFwiLi4vY29yZS9FdmVudHNcIjoxNixcIi4uL2NvcmUvTW91c2VcIjoxOSxcIi4uL2dlb21ldHJ5L0JvdW5kc1wiOjI2LFwiLi4vZ2VvbWV0cnkvVmVjdG9yXCI6Mjh9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiogVGhlIGBNYXR0ZXIuUmVuZGVyUGl4aWAgbW9kdWxlIGlzIGFuIGV4YW1wbGUgcmVuZGVyZXIgdXNpbmcgcGl4aS5qcy5cbiogU2VlIGFsc28gYE1hdHRlci5SZW5kZXJgIGZvciBhIGNhbnZhcyBiYXNlZCByZW5kZXJlci5cbipcbiogQGNsYXNzIFJlbmRlclBpeGlcbiogQGRlcHJlY2F0ZWQgdGhlIE1hdHRlci5SZW5kZXJQaXhpIG1vZHVsZSB3aWxsIHNvb24gYmUgcmVtb3ZlZCBmcm9tIHRoZSBNYXR0ZXIuanMgY29yZS5cbiogSXQgd2lsbCBsaWtlbHkgYmUgbW92ZWQgdG8gaXRzIG93biByZXBvc2l0b3J5IChidXQgbWFpbnRlbmFuY2Ugd2lsbCBiZSBsaW1pdGVkKS5cbiovXG5cbnZhciBSZW5kZXJQaXhpID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyUGl4aTtcblxudmFyIEJvdW5kcyA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xudmFyIENvbXBvc2l0ZSA9IF9kZXJlcV8oJy4uL2JvZHkvQ29tcG9zaXRlJyk7XG52YXIgQ29tbW9uID0gX2RlcmVxXygnLi4vY29yZS9Db21tb24nKTtcbnZhciBFdmVudHMgPSBfZGVyZXFfKCcuLi9jb3JlL0V2ZW50cycpO1xudmFyIFZlY3RvciA9IF9kZXJlcV8oJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKXsgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKENvbW1vbi5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XG4gICBcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBpeGkuanMgV2ViR0wgcmVuZGVyZXJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtSZW5kZXJQaXhpfSBBIG5ldyByZW5kZXJlclxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIENvbW1vbi53YXJuKCdSZW5kZXJQaXhpLmNyZWF0ZTogTWF0dGVyLlJlbmRlclBpeGkgaXMgZGVwcmVjYXRlZCAoc2VlIGRvY3MpJyk7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgY29udHJvbGxlcjogUmVuZGVyUGl4aSxcbiAgICAgICAgICAgIGVuZ2luZTogbnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBmcmFtZVJlcXVlc3RJZDogbnVsbCxcbiAgICAgICAgICAgIGNhbnZhczogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgcGl4aU9wdGlvbnM6IG51bGwsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwMCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZhZmFmYScsXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lQmFja2dyb3VuZDogJyMyMjInLFxuICAgICAgICAgICAgICAgIGhhc0JvdW5kczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3dTbGVlcGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93RGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCcm9hZHBoYXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93Qm91bmRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VmVsb2NpdHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dDb2xsaXNpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QXhlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1Bvc2l0aW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0FuZ2xlSW5kaWNhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93SWRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93U2hhZG93czogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVuZGVyID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyksXG4gICAgICAgICAgICB0cmFuc3BhcmVudCA9ICFyZW5kZXIub3B0aW9ucy53aXJlZnJhbWVzICYmIHJlbmRlci5vcHRpb25zLmJhY2tncm91bmQgPT09ICd0cmFuc3BhcmVudCc7XG5cbiAgICAgICAgLy8gaW5pdCBwaXhpXG4gICAgICAgIHJlbmRlci5waXhpT3B0aW9ucyA9IHJlbmRlci5waXhpT3B0aW9ucyB8fCB7XG4gICAgICAgICAgICB2aWV3OiByZW5kZXIuY2FudmFzLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LFxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRcbiAgICAgICAgfTtcblxuICAgICAgICByZW5kZXIubW91c2UgPSBvcHRpb25zLm1vdXNlO1xuICAgICAgICByZW5kZXIuZW5naW5lID0gb3B0aW9ucy5lbmdpbmU7XG4gICAgICAgIHJlbmRlci5yZW5kZXJlciA9IHJlbmRlci5yZW5kZXJlciB8fCBuZXcgUElYSS5XZWJHTFJlbmRlcmVyKHJlbmRlci5vcHRpb25zLndpZHRoLCByZW5kZXIub3B0aW9ucy5oZWlnaHQsIHJlbmRlci5waXhpT3B0aW9ucyk7XG4gICAgICAgIHJlbmRlci5jb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyIHx8IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICAgICAgICByZW5kZXIuc3ByaXRlQ29udGFpbmVyID0gcmVuZGVyLnNwcml0ZUNvbnRhaW5lciB8fCBuZXcgUElYSS5Db250YWluZXIoKTtcbiAgICAgICAgcmVuZGVyLmNhbnZhcyA9IHJlbmRlci5jYW52YXMgfHwgcmVuZGVyLnJlbmRlcmVyLnZpZXc7XG4gICAgICAgIHJlbmRlci5ib3VuZHMgPSByZW5kZXIuYm91bmRzIHx8IHsgXG4gICAgICAgICAgICBtaW46IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgbWF4OiB7IFxuICAgICAgICAgICAgICAgIHg6IHJlbmRlci5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgIHk6IHJlbmRlci5vcHRpb25zLmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBFdmVudHMub24ocmVuZGVyLmVuZ2luZSwgJ2JlZm9yZVVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgUmVuZGVyUGl4aS5jbGVhcihyZW5kZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWNoZXNcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XG4gICAgICAgIHJlbmRlci5zcHJpdGVzID0ge307XG4gICAgICAgIHJlbmRlci5wcmltaXRpdmVzID0ge307XG5cbiAgICAgICAgLy8gdXNlIGEgc3ByaXRlIGJhdGNoIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICByZW5kZXIuY29udGFpbmVyLmFkZENoaWxkKHJlbmRlci5zcHJpdGVDb250YWluZXIpO1xuXG4gICAgICAgIC8vIGluc2VydCBjYW52YXNcbiAgICAgICAgaWYgKENvbW1vbi5pc0VsZW1lbnQocmVuZGVyLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZW5kZXIuZWxlbWVudC5hcHBlbmRDaGlsZChyZW5kZXIuY2FudmFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdObyBcInJlbmRlci5lbGVtZW50XCIgcGFzc2VkLCBcInJlbmRlci5jYW52YXNcIiB3YXMgbm90IGluc2VydGVkIGludG8gZG9jdW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IG1lbnVzIG9uIGNhbnZhc1xuICAgICAgICByZW5kZXIuY2FudmFzLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICByZW5kZXIuY2FudmFzLm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4gICAgICAgIHJldHVybiByZW5kZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRpbnVvdXNseSB1cGRhdGVzIHRoZSByZW5kZXIgY2FudmFzIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFJlbmRlclBpeGkucnVuID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIChmdW5jdGlvbiBsb29wKHRpbWUpe1xuICAgICAgICAgICAgcmVuZGVyLmZyYW1lUmVxdWVzdElkID0gX3JlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgICAgIFJlbmRlclBpeGkud29ybGQocmVuZGVyKTtcbiAgICAgICAgfSkoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5kcyBleGVjdXRpb24gb2YgYFJlbmRlci5ydW5gIG9uIHRoZSBnaXZlbiBgcmVuZGVyYCwgYnkgY2FuY2VsaW5nIHRoZSBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBldmVudCBsb29wLlxuICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFJlbmRlclBpeGkuc3RvcCA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVuZGVyLmZyYW1lUmVxdWVzdElkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzY2VuZSBncmFwaFxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5jbGVhciA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcmVuZGVyLmNvbnRhaW5lcixcbiAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lciA9IHJlbmRlci5zcHJpdGVDb250YWluZXI7XG5cbiAgICAgICAgLy8gY2xlYXIgc3RhZ2UgY29udGFpbmVyXG4gICAgICAgIHdoaWxlIChjb250YWluZXIuY2hpbGRyZW5bMF0pIHsgXG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmNoaWxkcmVuWzBdKTsgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBzcHJpdGUgYmF0Y2hcbiAgICAgICAgd2hpbGUgKHNwcml0ZUNvbnRhaW5lci5jaGlsZHJlblswXSkgeyBcbiAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lci5yZW1vdmVDaGlsZChzcHJpdGVDb250YWluZXIuY2hpbGRyZW5bMF0pOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZ1Nwcml0ZSA9IHJlbmRlci5zcHJpdGVzWydiZy0wJ107XG5cbiAgICAgICAgLy8gY2xlYXIgY2FjaGVzXG4gICAgICAgIHJlbmRlci50ZXh0dXJlcyA9IHt9O1xuICAgICAgICByZW5kZXIuc3ByaXRlcyA9IHt9O1xuICAgICAgICByZW5kZXIucHJpbWl0aXZlcyA9IHt9O1xuXG4gICAgICAgIC8vIHNldCBiYWNrZ3JvdW5kIHNwcml0ZVxuICAgICAgICByZW5kZXIuc3ByaXRlc1snYmctMCddID0gYmdTcHJpdGU7XG4gICAgICAgIGlmIChiZ1Nwcml0ZSlcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZEF0KGJnU3ByaXRlLCAwKTtcblxuICAgICAgICAvLyBhZGQgc3ByaXRlIGJhdGNoIGJhY2sgaW50byBjb250YWluZXJcbiAgICAgICAgcmVuZGVyLmNvbnRhaW5lci5hZGRDaGlsZChyZW5kZXIuc3ByaXRlQ29udGFpbmVyKTtcblxuICAgICAgICAvLyByZXNldCBiYWNrZ3JvdW5kIHN0YXRlXG4gICAgICAgIHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCA9IG51bGw7XG5cbiAgICAgICAgLy8gcmVzZXQgYm91bmRzIHRyYW5zZm9ybXNcbiAgICAgICAgY29udGFpbmVyLnNjYWxlLnNldCgxLCAxKTtcbiAgICAgICAgY29udGFpbmVyLnBvc2l0aW9uLnNldCgwLCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYmFja2dyb3VuZCBvZiB0aGUgY2FudmFzIFxuICAgICAqIEBtZXRob2Qgc2V0QmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFJlbmRlclBpeGkuc2V0QmFja2dyb3VuZCA9IGZ1bmN0aW9uKHJlbmRlciwgYmFja2dyb3VuZCkge1xuICAgICAgICBpZiAocmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICB2YXIgaXNDb2xvciA9IGJhY2tncm91bmQuaW5kZXhPZiAmJiBiYWNrZ3JvdW5kLmluZGV4T2YoJyMnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgYmdTcHJpdGUgPSByZW5kZXIuc3ByaXRlc1snYmctMCddO1xuXG4gICAgICAgICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHNvbGlkIGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBDb21tb24uY29sb3JUb051bWJlcihiYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgICAgICByZW5kZXIucmVuZGVyZXIuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgYmFja2dyb3VuZCBzcHJpdGUgaWYgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICBpZiAoYmdTcHJpdGUpXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlci5jb250YWluZXIucmVtb3ZlQ2hpbGQoYmdTcHJpdGUpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBiYWNrZ3JvdW5kIHNwcml0ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoIWJnU3ByaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gX2dldFRleHR1cmUocmVuZGVyLCBiYWNrZ3JvdW5kKTtcblxuICAgICAgICAgICAgICAgICAgICBiZ1Nwcml0ZSA9IHJlbmRlci5zcHJpdGVzWydiZy0wJ10gPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGJnU3ByaXRlLnBvc2l0aW9uLnggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiZ1Nwcml0ZS5wb3NpdGlvbi55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyLmNvbnRhaW5lci5hZGRDaGlsZEF0KGJnU3ByaXRlLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAbWV0aG9kIHdvcmxkXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS53b3JsZCA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICB2YXIgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgcmVuZGVyZXIgPSByZW5kZXIucmVuZGVyZXIsXG4gICAgICAgICAgICBjb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCksXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IFtdLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBSZW5kZXJQaXhpLnNldEJhY2tncm91bmQocmVuZGVyLCBvcHRpb25zLndpcmVmcmFtZUJhY2tncm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVuZGVyUGl4aS5zZXRCYWNrZ3JvdW5kKHJlbmRlciwgb3B0aW9ucy5iYWNrZ3JvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBib3VuZHNcbiAgICAgICAgdmFyIGJvdW5kc1dpZHRoID0gcmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngsXG4gICAgICAgICAgICBib3VuZHNIZWlnaHQgPSByZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWCA9IGJvdW5kc1dpZHRoIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICBib3VuZHNTY2FsZVkgPSBib3VuZHNIZWlnaHQgLyByZW5kZXIub3B0aW9ucy5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XG4gICAgICAgICAgICAvLyBIaWRlIGJvZGllcyB0aGF0IGFyZSBub3QgaW4gdmlld1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGJvZHkucmVuZGVyLnNwcml0ZS52aXNpYmxlID0gQm91bmRzLm92ZXJsYXBzKGJvZHkuYm91bmRzLCByZW5kZXIuYm91bmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBjb25zdHJhaW50cyB0aGF0IGFyZSBub3QgaW4gdmlld1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbENvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBhbGxDb25zdHJhaW50c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBjb25zdHJhaW50LmJvZHlBLFxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QVdvcmxkID0gY29uc3RyYWludC5wb2ludEEsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QldvcmxkID0gY29uc3RyYWludC5wb2ludEI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYm9keUEpIHBvaW50QVdvcmxkID0gVmVjdG9yLmFkZChib2R5QS5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEEpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5QikgcG9pbnRCV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50Qik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKHJlbmRlci5ib3VuZHMsIHBvaW50QVdvcmxkKSB8fCBCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRCV29ybGQpKVxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIHZpZXdcbiAgICAgICAgICAgIGNvbnRhaW5lci5zY2FsZS5zZXQoMSAvIGJvdW5kc1NjYWxlWCwgMSAvIGJvdW5kc1NjYWxlWSk7XG4gICAgICAgICAgICBjb250YWluZXIucG9zaXRpb24uc2V0KC1yZW5kZXIuYm91bmRzLm1pbi54ICogKDEgLyBib3VuZHNTY2FsZVgpLCAtcmVuZGVyLmJvdW5kcy5taW4ueSAqICgxIC8gYm91bmRzU2NhbGVZKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGFsbENvbnN0cmFpbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFJlbmRlclBpeGkuYm9keShyZW5kZXIsIGJvZGllc1tpXSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgUmVuZGVyUGl4aS5jb25zdHJhaW50KHJlbmRlciwgY29uc3RyYWludHNbaV0pO1xuXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihjb250YWluZXIpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQG1ldGhvZCBjb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5jb25zdHJhaW50ID0gZnVuY3Rpb24ocmVuZGVyLCBjb25zdHJhaW50KSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgYm9keUEgPSBjb25zdHJhaW50LmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxuICAgICAgICAgICAgcG9pbnRBID0gY29uc3RyYWludC5wb2ludEEsXG4gICAgICAgICAgICBwb2ludEIgPSBjb25zdHJhaW50LnBvaW50QixcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIsXG4gICAgICAgICAgICBjb25zdHJhaW50UmVuZGVyID0gY29uc3RyYWludC5yZW5kZXIsXG4gICAgICAgICAgICBwcmltaXRpdmVJZCA9ICdjLScgKyBjb25zdHJhaW50LmlkLFxuICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdO1xuXG4gICAgICAgIC8vIGluaXRpYWxpc2UgY29uc3RyYWludCBwcmltaXRpdmUgaWYgbm90IGV4aXN0aW5nXG4gICAgICAgIGlmICghcHJpbWl0aXZlKVxuICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblxuICAgICAgICAvLyBkb24ndCByZW5kZXIgaWYgY29uc3RyYWludCBkb2VzIG5vdCBoYXZlIHR3byBlbmQgcG9pbnRzXG4gICAgICAgIGlmICghY29uc3RyYWludFJlbmRlci52aXNpYmxlIHx8ICFjb25zdHJhaW50LnBvaW50QSB8fCAhY29uc3RyYWludC5wb2ludEIpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIHNjZW5lIGdyYXBoIGlmIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgICAgIGlmIChDb21tb24uaW5kZXhPZihjb250YWluZXIuY2hpbGRyZW4sIHByaW1pdGl2ZSkgPT09IC0xKVxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHByaW1pdGl2ZSk7XG5cbiAgICAgICAgLy8gcmVuZGVyIHRoZSBjb25zdHJhaW50IG9uIGV2ZXJ5IHVwZGF0ZSwgc2luY2UgdGhleSBjYW4gY2hhbmdlIGR5bmFtaWNhbGx5XG4gICAgICAgIHByaW1pdGl2ZS5jbGVhcigpO1xuICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKDAsIDApO1xuICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKGNvbnN0cmFpbnRSZW5kZXIubGluZVdpZHRoLCBDb21tb24uY29sb3JUb051bWJlcihjb25zdHJhaW50UmVuZGVyLnN0cm9rZVN0eWxlKSwgMSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoYm9keUEpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5tb3ZlVG8oYm9keUEucG9zaXRpb24ueCArIHBvaW50QS54LCBib2R5QS5wb3NpdGlvbi55ICsgcG9pbnRBLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhwb2ludEEueCwgcG9pbnRBLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlCKSB7XG4gICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKGJvZHlCLnBvc2l0aW9uLnggKyBwb2ludEIueCwgYm9keUIucG9zaXRpb24ueSArIHBvaW50Qi55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8ocG9pbnRCLngsIHBvaW50Qi55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW1pdGl2ZS5lbmRGaWxsKCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBtZXRob2QgYm9keVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFJlbmRlclBpeGkuYm9keSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9keSkge1xuICAgICAgICB2YXIgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIGJvZHlSZW5kZXIgPSBib2R5LnJlbmRlcjtcblxuICAgICAgICBpZiAoIWJvZHlSZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAoYm9keVJlbmRlci5zcHJpdGUgJiYgYm9keVJlbmRlci5zcHJpdGUudGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIHNwcml0ZUlkID0gJ2ItJyArIGJvZHkuaWQsXG4gICAgICAgICAgICAgICAgc3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbc3ByaXRlSWRdLFxuICAgICAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lciA9IHJlbmRlci5zcHJpdGVDb250YWluZXI7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYm9keSBzcHJpdGUgaWYgbm90IGV4aXN0aW5nXG4gICAgICAgICAgICBpZiAoIXNwcml0ZSlcbiAgICAgICAgICAgICAgICBzcHJpdGUgPSByZW5kZXIuc3ByaXRlc1tzcHJpdGVJZF0gPSBfY3JlYXRlQm9keVNwcml0ZShyZW5kZXIsIGJvZHkpO1xuXG4gICAgICAgICAgICAvLyBhZGQgdG8gc2NlbmUgZ3JhcGggaWYgbm90IGFscmVhZHkgdGhlcmVcbiAgICAgICAgICAgIGlmIChDb21tb24uaW5kZXhPZihzcHJpdGVDb250YWluZXIuY2hpbGRyZW4sIHNwcml0ZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm9keSBzcHJpdGVcbiAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi54ID0gYm9keS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnkgPSBib2R5LnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBzcHJpdGUucm90YXRpb24gPSBib2R5LmFuZ2xlO1xuICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnggPSBib2R5UmVuZGVyLnNwcml0ZS54U2NhbGUgfHwgMTtcbiAgICAgICAgICAgIHNwcml0ZS5zY2FsZS55ID0gYm9keVJlbmRlci5zcHJpdGUueVNjYWxlIHx8IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlSWQgPSAnYi0nICsgYm9keS5pZCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUgPSByZW5kZXIucHJpbWl0aXZlc1twcmltaXRpdmVJZF0sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gcmVuZGVyLmNvbnRhaW5lcjtcblxuICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBib2R5IHByaW1pdGl2ZSBpZiBub3QgZXhpc3RpbmdcbiAgICAgICAgICAgIGlmICghcHJpbWl0aXZlKSB7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdID0gX2NyZWF0ZUJvZHlQcmltaXRpdmUocmVuZGVyLCBib2R5KTtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuaW5pdGlhbEFuZ2xlID0gYm9keS5hbmdsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHRvIHNjZW5lIGdyYXBoIGlmIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmluZGV4T2YoY29udGFpbmVyLmNoaWxkcmVuLCBwcmltaXRpdmUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQocHJpbWl0aXZlKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgcHJpbWl0aXZlXG4gICAgICAgICAgICBwcmltaXRpdmUucG9zaXRpb24ueCA9IGJvZHkucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5wb3NpdGlvbi55ID0gYm9keS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgcHJpbWl0aXZlLnJvdGF0aW9uID0gYm9keS5hbmdsZSAtIHByaW1pdGl2ZS5pbml0aWFsQW5nbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJvZHkgc3ByaXRlXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQm9keVNwcml0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW5kZXJQaXhpfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gc3ByaXRlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICB2YXIgX2NyZWF0ZUJvZHlTcHJpdGUgPSBmdW5jdGlvbihyZW5kZXIsIGJvZHkpIHtcbiAgICAgICAgdmFyIGJvZHlSZW5kZXIgPSBib2R5LnJlbmRlcixcbiAgICAgICAgICAgIHRleHR1cmVQYXRoID0gYm9keVJlbmRlci5zcHJpdGUudGV4dHVyZSxcbiAgICAgICAgICAgIHRleHR1cmUgPSBfZ2V0VGV4dHVyZShyZW5kZXIsIHRleHR1cmVQYXRoKSxcbiAgICAgICAgICAgIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcblxuICAgICAgICBzcHJpdGUuYW5jaG9yLnggPSBib2R5LnJlbmRlci5zcHJpdGUueE9mZnNldDtcbiAgICAgICAgc3ByaXRlLmFuY2hvci55ID0gYm9keS5yZW5kZXIuc3ByaXRlLnlPZmZzZXQ7XG5cbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJvZHkgcHJpbWl0aXZlXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQm9keVByaW1pdGl2ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW5kZXJQaXhpfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljc1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgdmFyIF9jcmVhdGVCb2R5UHJpbWl0aXZlID0gZnVuY3Rpb24ocmVuZGVyLCBib2R5KSB7XG4gICAgICAgIHZhciBib2R5UmVuZGVyID0gYm9keS5yZW5kZXIsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwcmltaXRpdmUgPSBuZXcgUElYSS5HcmFwaGljcygpLFxuICAgICAgICAgICAgZmlsbFN0eWxlID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoYm9keVJlbmRlci5maWxsU3R5bGUpLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGUgPSBDb21tb24uY29sb3JUb051bWJlcihib2R5UmVuZGVyLnN0cm9rZVN0eWxlKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlSW5kaWNhdG9yID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoYm9keVJlbmRlci5zdHJva2VTdHlsZSksXG4gICAgICAgICAgICBzdHJva2VTdHlsZVdpcmVmcmFtZSA9IENvbW1vbi5jb2xvclRvTnVtYmVyKCcjYmJiJyksXG4gICAgICAgICAgICBzdHJva2VTdHlsZVdpcmVmcmFtZUluZGljYXRvciA9IENvbW1vbi5jb2xvclRvTnVtYmVyKCcjQ0Q1QzVDJyksXG4gICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgIHByaW1pdGl2ZS5jbGVhcigpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBjb21wb3VuZCBwYXJ0c1xuICAgICAgICBmb3IgKHZhciBrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKGZpbGxTdHlsZSwgMSk7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVTdHlsZShib2R5UmVuZGVyLmxpbmVXaWR0aCwgc3Ryb2tlU3R5bGUsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKDAsIDApO1xuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lU3R5bGUoMSwgc3Ryb2tlU3R5bGVXaXJlZnJhbWUsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmltaXRpdmUubW92ZVRvKHBhcnQudmVydGljZXNbMF0ueCAtIGJvZHkucG9zaXRpb24ueCwgcGFydC52ZXJ0aWNlc1swXS55IC0gYm9keS5wb3NpdGlvbi55KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVUbyhwYXJ0LnZlcnRpY2VzW2pdLnggLSBib2R5LnBvc2l0aW9uLngsIHBhcnQudmVydGljZXNbal0ueSAtIGJvZHkucG9zaXRpb24ueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54IC0gYm9keS5wb3NpdGlvbi54LCBwYXJ0LnZlcnRpY2VzWzBdLnkgLSBib2R5LnBvc2l0aW9uLnkpO1xuXG4gICAgICAgICAgICBwcmltaXRpdmUuZW5kRmlsbCgpO1xuXG4gICAgICAgICAgICAvLyBhbmdsZSBpbmRpY2F0b3JcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dBbmdsZUluZGljYXRvciB8fCBvcHRpb25zLnNob3dBeGVzKSB7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmJlZ2luRmlsbCgwLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVTdHlsZSgxLCBzdHJva2VTdHlsZVdpcmVmcmFtZUluZGljYXRvciwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVTdHlsZSgxLCBzdHJva2VTdHlsZUluZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhwYXJ0LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVUbygoKHBhcnQudmVydGljZXNbMF0ueCArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueCkgLyAyIC0gYm9keS5wb3NpdGlvbi54KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHBhcnQudmVydGljZXNbMF0ueSArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkgLyAyIC0gYm9keS5wb3NpdGlvbi55KSk7XG5cbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuZW5kRmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmVxdWVzdGVkIHRleHR1cmUgKGEgUElYSS5UZXh0dXJlKSB2aWEgaXRzIHBhdGhcbiAgICAgKiBAbWV0aG9kIF9nZXRUZXh0dXJlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVBhdGhcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IHRleHR1cmVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHZhciBfZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHJlbmRlciwgaW1hZ2VQYXRoKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF07XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlKVxuICAgICAgICAgICAgdGV4dHVyZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShpbWFnZVBhdGgpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH07XG5cbn0pKCk7XG5cbn0se1wiLi4vYm9keS9Db21wb3NpdGVcIjoyLFwiLi4vY29yZS9Db21tb25cIjoxNCxcIi4uL2NvcmUvRXZlbnRzXCI6MTYsXCIuLi9nZW9tZXRyeS9Cb3VuZHNcIjoyNixcIi4uL2dlb21ldHJ5L1ZlY3RvclwiOjI4fV19LHt9LFszMF0pKDMwKVxufSk7XG4iXSwibmFtZXMiOlsiZiIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsIk1hdHRlciIsInIiLCJlIiwibiIsInQiLCJvIiwiaSIsImMiLCJyZXF1aXJlIiwidSIsImEiLCJFcnJvciIsImNvZGUiLCJwIiwiY2FsbCIsImxlbmd0aCIsIl9kZXJlcV8iLCJCb2R5IiwiVmVydGljZXMiLCJWZWN0b3IiLCJTbGVlcGluZyIsIlJlbmRlciIsIkNvbW1vbiIsIkJvdW5kcyIsIkF4ZXMiLCJfaW5lcnRpYVNjYWxlIiwiX25leHRDb2xsaWRpbmdHcm91cElkIiwiX25leHROb25Db2xsaWRpbmdHcm91cElkIiwiX25leHRDYXRlZ29yeSIsImNyZWF0ZSIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsImlkIiwibmV4dElkIiwidHlwZSIsImxhYmVsIiwicGFydHMiLCJwbHVnaW4iLCJhbmdsZSIsInZlcnRpY2VzIiwiZnJvbVBhdGgiLCJwb3NpdGlvbiIsIngiLCJ5IiwiZm9yY2UiLCJ0b3JxdWUiLCJwb3NpdGlvbkltcHVsc2UiLCJjb25zdHJhaW50SW1wdWxzZSIsInRvdGFsQ29udGFjdHMiLCJzcGVlZCIsImFuZ3VsYXJTcGVlZCIsInZlbG9jaXR5IiwiYW5ndWxhclZlbG9jaXR5IiwiaXNTZW5zb3IiLCJpc1N0YXRpYyIsImlzU2xlZXBpbmciLCJtb3Rpb24iLCJzbGVlcFRocmVzaG9sZCIsImRlbnNpdHkiLCJyZXN0aXR1dGlvbiIsImZyaWN0aW9uIiwiZnJpY3Rpb25TdGF0aWMiLCJmcmljdGlvbkFpciIsImNvbGxpc2lvbkZpbHRlciIsImNhdGVnb3J5IiwibWFzayIsImdyb3VwIiwic2xvcCIsInRpbWVTY2FsZSIsInJlbmRlciIsInZpc2libGUiLCJvcGFjaXR5Iiwic3ByaXRlIiwieFNjYWxlIiwieVNjYWxlIiwieE9mZnNldCIsInlPZmZzZXQiLCJsaW5lV2lkdGgiLCJib2R5IiwiZXh0ZW5kIiwiX2luaXRQcm9wZXJ0aWVzIiwibmV4dEdyb3VwIiwiaXNOb25Db2xsaWRpbmciLCJuZXh0Q2F0ZWdvcnkiLCJzZXQiLCJib3VuZHMiLCJwb3NpdGlvblByZXYiLCJjbG9uZSIsImFuZ2xlUHJldiIsInBhcmVudCIsInJvdGF0ZSIsImF4ZXMiLCJ1cGRhdGUiLCJhcmVhIiwibWFzcyIsImluZXJ0aWEiLCJkZWZhdWx0RmlsbFN0eWxlIiwiY2hvb3NlIiwiZGVmYXVsdFN0cm9rZVN0eWxlIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJtaW4iLCJtYXgiLCJzZXR0aW5ncyIsInZhbHVlIiwicHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsInNldFN0YXRpYyIsInNldE1hc3MiLCJzZXREZW5zaXR5Iiwic2V0SW5lcnRpYSIsInNldFZlcnRpY2VzIiwic2V0UG9zaXRpb24iLCJzZXRBbmdsZSIsInNldFZlbG9jaXR5Iiwic2V0QW5ndWxhclZlbG9jaXR5Iiwic2V0UGFydHMiLCJwYXJ0IiwiX29yaWdpbmFsIiwiaW52ZXJzZU1hc3MiLCJpbnZlcnNlSW5lcnRpYSIsIkluZmluaXR5IiwibW9tZW50IiwiZnJvbVZlcnRpY2VzIiwiY2VudHJlIiwidHJhbnNsYXRlIiwiYXV0b0h1bGwiLCJzbGljZSIsInB1c2giLCJjb25jYXQiLCJjbG9ja3dpc2VTb3J0IiwiaHVsbCIsImh1bGxDZW50cmUiLCJ0b3RhbCIsIl90b3RhbFByb3BlcnRpZXMiLCJkZWx0YSIsInN1YiIsInJvdGF0ZUFib3V0IiwibWFnbml0dWRlIiwiTWF0aCIsImFicyIsInRyYW5zbGF0aW9uIiwiYWRkIiwicm90YXRpb24iLCJwb2ludCIsImNvcyIsInNpbiIsImR4IiwiZHkiLCJzY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsInRvdGFsQXJlYSIsInRvdGFsSW5lcnRpYSIsImNpcmNsZVJhZGl1cyIsImRlbHRhVGltZSIsImNvcnJlY3Rpb24iLCJkZWx0YVRpbWVTcXVhcmVkIiwicG93IiwidmVsb2NpdHlQcmV2WCIsInZlbG9jaXR5UHJldlkiLCJhcHBseUZvcmNlIiwib2Zmc2V0IiwicHJvcGVydGllcyIsIm11bHQiLCJkaXYiLCJDb21wb3NpdGUiLCJFdmVudHMiLCJpc01vZGlmaWVkIiwiYm9kaWVzIiwiY29uc3RyYWludHMiLCJjb21wb3NpdGVzIiwic2V0TW9kaWZpZWQiLCJjb21wb3NpdGUiLCJ1cGRhdGVQYXJlbnRzIiwidXBkYXRlQ2hpbGRyZW4iLCJjaGlsZENvbXBvc2l0ZSIsIm9iamVjdCIsIm9iamVjdHMiLCJ0cmlnZ2VyIiwib2JqIiwid2FybiIsImFkZEJvZHkiLCJhZGRDb25zdHJhaW50IiwiYWRkQ29tcG9zaXRlIiwiY29uc3RyYWludCIsInJlbW92ZSIsImRlZXAiLCJyZW1vdmVCb2R5IiwicmVtb3ZlQ29uc3RyYWludCIsInJlbW92ZUNvbXBvc2l0ZSIsImNvbXBvc2l0ZUEiLCJjb21wb3NpdGVCIiwiaW5kZXhPZiIsInJlbW92ZUNvbXBvc2l0ZUF0Iiwic3BsaWNlIiwicmVtb3ZlQm9keUF0IiwicmVtb3ZlQ29uc3RyYWludEF0IiwiY2xlYXIiLCJrZWVwU3RhdGljIiwiZmlsdGVyIiwiYWxsQm9kaWVzIiwiYWxsQ29uc3RyYWludHMiLCJhbGxDb21wb3NpdGVzIiwiZ2V0IiwidG9TdHJpbmciLCJtb3ZlIiwicmViYXNlIiwicmVjdXJzaXZlIiwiV29ybGQiLCJDb25zdHJhaW50IiwiZ3Jhdml0eSIsIkNvbnRhY3QiLCJ2ZXJ0ZXgiLCJub3JtYWxJbXB1bHNlIiwidGFuZ2VudEltcHVsc2UiLCJpbmRleCIsIkRldGVjdG9yIiwiU0FUIiwiUGFpciIsImNvbGxpc2lvbnMiLCJicm9hZHBoYXNlUGFpcnMiLCJlbmdpbmUiLCJwYWlyc1RhYmxlIiwicGFpcnMiLCJ0YWJsZSIsImJvZHlBIiwiYm9keUIiLCJjYW5Db2xsaWRlIiwib3ZlcmxhcHMiLCJqIiwicGFydEEiLCJrIiwicGFydEIiLCJwYWlySWQiLCJwYWlyIiwicHJldmlvdXNDb2xsaXNpb24iLCJpc0FjdGl2ZSIsImNvbGxpc2lvbiIsImNvbGxpZGVzIiwiY29sbGlkZWQiLCJmaWx0ZXJBIiwiZmlsdGVyQiIsIkdyaWQiLCJjb250cm9sbGVyIiwiZGV0ZWN0b3IiLCJidWNrZXRzIiwicGFpcnNMaXN0IiwiYnVja2V0V2lkdGgiLCJidWNrZXRIZWlnaHQiLCJncmlkIiwiZm9yY2VVcGRhdGUiLCJjb2wiLCJyb3ciLCJ3b3JsZCIsImJ1Y2tldCIsImJ1Y2tldElkIiwiZ3JpZENoYW5nZWQiLCJuZXdSZWdpb24iLCJfZ2V0UmVnaW9uIiwicmVnaW9uIiwidW5pb24iLCJfcmVnaW9uVW5pb24iLCJzdGFydENvbCIsImVuZENvbCIsInN0YXJ0Um93IiwiZW5kUm93IiwiX2dldEJ1Y2tldElkIiwiaXNJbnNpZGVOZXdSZWdpb24iLCJpc0luc2lkZU9sZFJlZ2lvbiIsIl9idWNrZXRSZW1vdmVCb2R5IiwiX2NyZWF0ZUJ1Y2tldCIsIl9idWNrZXRBZGRCb2R5IiwiX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCIsInJlZ2lvbkEiLCJyZWdpb25CIiwiX2NyZWF0ZVJlZ2lvbiIsImZsb29yIiwiY29sdW1uIiwicGFpcktleXMiLCJrZXlzIiwidGltZXN0YW1wIiwicGFyZW50QSIsInBhcmVudEIiLCJjb250YWN0cyIsImFjdGl2ZUNvbnRhY3RzIiwic2VwYXJhdGlvbiIsInRpbWVDcmVhdGVkIiwidGltZVVwZGF0ZWQiLCJzdXBwb3J0cyIsInN1cHBvcnQiLCJjb250YWN0SWQiLCJjb250YWN0IiwiZGVwdGgiLCJzZXRBY3RpdmUiLCJQYWlycyIsIl9wYWlyTWF4SWRsZUxpZmUiLCJsaXN0IiwiY29sbGlzaW9uU3RhcnQiLCJjb2xsaXNpb25BY3RpdmUiLCJjb2xsaXNpb25FbmQiLCJhY3RpdmVQYWlySWRzIiwicmVtb3ZlT2xkIiwiaW5kZXhlc1RvUmVtb3ZlIiwicGFpckluZGV4IiwiUXVlcnkiLCJCb2RpZXMiLCJyYXkiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJyYXlXaWR0aCIsInJheUFuZ2xlIiwicmF5TGVuZ3RoIiwicmF5WCIsInJheVkiLCJyZWN0YW5nbGUiLCJvdXRzaWRlIiwicmVzdWx0IiwiY29udGFpbnMiLCJSZXNvbHZlciIsIl9yZXN0aW5nVGhyZXNoIiwiX3Jlc3RpbmdUaHJlc2hUYW5nZW50IiwiX3Bvc2l0aW9uRGFtcGVuIiwiX3Bvc2l0aW9uV2FybWluZyIsIl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIiLCJwcmVTb2x2ZVBvc2l0aW9uIiwiYWN0aXZlQ291bnQiLCJzb2x2ZVBvc2l0aW9uIiwibm9ybWFsIiwiYm9keUJ0b0EiLCJjb250YWN0U2hhcmUiLCJjb250YWN0Q291bnQiLCJ0ZW1wQSIsIl90ZW1wIiwidGVtcEIiLCJ0ZW1wQyIsInRlbXBEIiwicGVuZXRyYXRpb24iLCJkb3QiLCJwb3N0U29sdmVQb3NpdGlvbiIsInByZVNvbHZlVmVsb2NpdHkiLCJ0YW5nZW50IiwiY29udGFjdFZlcnRleCIsImltcHVsc2UiLCJjcm9zcyIsInNvbHZlVmVsb2NpdHkiLCJ0aW1lU2NhbGVTcXVhcmVkIiwidGVtcEUiLCJvZmZzZXRBIiwib2Zmc2V0QiIsInZlbG9jaXR5UG9pbnRBIiwicGVycCIsInZlbG9jaXR5UG9pbnRCIiwicmVsYXRpdmVWZWxvY2l0eSIsIm5vcm1hbFZlbG9jaXR5IiwidGFuZ2VudFZlbG9jaXR5IiwidGFuZ2VudFNwZWVkIiwidGFuZ2VudFZlbG9jaXR5RGlyZWN0aW9uIiwic2lnbiIsIm5vcm1hbEZvcmNlIiwiY2xhbXAiLCJtYXhGcmljdGlvbiIsIm9BY04iLCJvQmNOIiwic2hhcmUiLCJjb250YWN0Tm9ybWFsSW1wdWxzZSIsImNvbnRhY3RUYW5nZW50SW1wdWxzZSIsIm92ZXJsYXBBQiIsIm92ZXJsYXBCQSIsIm1pbk92ZXJsYXAiLCJjYW5SZXVzZVByZXZDb2wiLCJheGlzQm9keUEiLCJheGlzQm9keSIsImF4aXNCb2R5QiIsImF4aXNOdW1iZXIiLCJfb3ZlcmxhcEF4ZXMiLCJyZXVzZWQiLCJvdmVybGFwIiwiYXhpcyIsInZlcnRpY2VzQiIsIl9maW5kU3VwcG9ydHMiLCJ2ZXJ0aWNlc0EiLCJuZWciLCJwcm9qZWN0aW9uQSIsInByb2plY3Rpb25CIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiX3Byb2plY3RUb0F4aXMiLCJwcm9qZWN0aW9uIiwibmVhcmVzdERpc3RhbmNlIiwidmVydGV4VG9Cb2R5IiwiYm9keUFQb3NpdGlvbiIsImRpc3RhbmNlIiwidmVydGV4QSIsInZlcnRleEIiLCJwcmV2SW5kZXgiLCJuZXh0SW5kZXgiLCJfd2FybWluZyIsIl90b3JxdWVEYW1wZW4iLCJfbWluTGVuZ3RoIiwicG9pbnRBIiwicG9pbnRCIiwiaW5pdGlhbFBvaW50QSIsImluaXRpYWxQb2ludEIiLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwiYW5ndWxhclN0aWZmbmVzcyIsImFuZ2xlQSIsImFuZ2xlQiIsImFuY2hvcnMiLCJwcmVTb2x2ZUFsbCIsInNvbHZlQWxsIiwiZml4ZWRBIiwiZml4ZWRCIiwic29sdmUiLCJwb2ludEFXb3JsZCIsInBvaW50QldvcmxkIiwiY3VycmVudExlbmd0aCIsImRpZmZlcmVuY2UiLCJtYXNzVG90YWwiLCJpbmVydGlhVG90YWwiLCJyZXNpc3RhbmNlVG90YWwiLCJ6ZXJvIiwicG9zdFNvbHZlQWxsIiwiTW91c2VDb25zdHJhaW50IiwiTW91c2UiLCJtb3VzZSIsImNhbnZhcyIsImVsZW1lbnQiLCJtb3VzZUNvbnN0cmFpbnQiLCJvbiIsIl90cmlnZ2VyRXZlbnRzIiwiYnV0dG9uIiwibW91c2VFdmVudHMiLCJzb3VyY2VFdmVudHMiLCJtb3VzZW1vdmUiLCJtb3VzZWRvd24iLCJtb3VzZXVwIiwiY2xlYXJTb3VyY2VFdmVudHMiLCJfbmV4dElkIiwiX3NlZWQiLCJfbm93U3RhcnRUaW1lIiwiRGF0ZSIsImFyZ3NTdGFydCIsImFyZ3MiLCJkZWVwQ2xvbmUiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJwcm9wIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJrZXkiLCJ2YWx1ZXMiLCJwYXRoIiwiYmVnaW4iLCJlbmQiLCJzcGxpdCIsInZhbCIsInNodWZmbGUiLCJhcnJheSIsInJhbmRvbSIsInRlbXAiLCJjaG9pY2VzIiwiaXNFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwiaXNBcnJheSIsInByb3RvdHlwZSIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNTdHJpbmciLCJub3ciLCJwZXJmb3JtYW5jZSIsIndlYmtpdE5vdyIsIl9zZWVkZWRSYW5kb20iLCJjb2xvclRvTnVtYmVyIiwiY29sb3JTdHJpbmciLCJyZXBsYWNlIiwiY2hhckF0IiwicGFyc2VJbnQiLCJsb2dMZXZlbCIsImxvZyIsImNvbnNvbGUiLCJhcHBseSIsIkFycmF5IiwiaW5mbyIsImhheXN0YWNrIiwibmVlZGxlIiwibWFwIiwiZnVuYyIsIm1hcHBlZCIsInRvcG9sb2dpY2FsU29ydCIsImdyYXBoIiwidmlzaXRlZCIsIm5vZGUiLCJfdG9wb2xvZ2ljYWxTb3J0IiwibmVpZ2hib3JzIiwibmVpZ2hib3IiLCJjaGFpbiIsImZ1bmNzIiwiX2NoYWluZWQiLCJsYXN0UmVzdWx0IiwibCIsImNoYWluUGF0aEJlZm9yZSIsImJhc2UiLCJjaGFpblBhdGhBZnRlciIsIl9yZXF1aXJlR2xvYmFsIiwiZ2xvYmFsTmFtZSIsIm1vZHVsZU5hbWUiLCJFbmdpbmUiLCJNZXRyaWNzIiwicG9zaXRpb25JdGVyYXRpb25zIiwidmVsb2NpdHlJdGVyYXRpb25zIiwiY29uc3RyYWludEl0ZXJhdGlvbnMiLCJlbmFibGVTbGVlcGluZyIsImV2ZW50cyIsInRpbWluZyIsImJyb2FkcGhhc2UiLCJyZW5kZXJEZWZhdWx0cyIsIm1ldHJpY3MiLCJleHRlbmRlZCIsImV2ZW50IiwiX2JvZGllc0FwcGx5R3Jhdml0eSIsIl9ib2RpZXNVcGRhdGUiLCJhZnRlckNvbGxpc2lvbnMiLCJfYm9kaWVzQ2xlYXJGb3JjZXMiLCJtZXJnZSIsImVuZ2luZUEiLCJlbmdpbmVCIiwiZ3Jhdml0eVNjYWxlIiwid29ybGRCb3VuZHMiLCJldmVudE5hbWVzIiwiY2FsbGJhY2siLCJuYW1lcyIsIm5hbWUiLCJvZmYiLCJqb2luIiwiY2FsbGJhY2tzIiwibmV3Q2FsbGJhY2tzIiwiZXZlbnRDbG9uZSIsIlBsdWdpbiIsInZlcnNpb24iLCJ1c2VzIiwidXNlZCIsInVzZSIsImJlZm9yZSIsImFmdGVyIiwiZG9jdW1lbnQiLCJhYnNvbHV0ZSIsIm1vdXNlZG93blBvc2l0aW9uIiwibW91c2V1cFBvc2l0aW9uIiwid2hlZWxEZWx0YSIsInBpeGVsUmF0aW8iLCJnZXRBdHRyaWJ1dGUiLCJtb3VzZXdoZWVsIiwiX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbiIsInRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsInByZXZlbnREZWZhdWx0IiwiZGV0YWlsIiwic2V0RWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRPZmZzZXQiLCJzZXRTY2FsZSIsImVsZW1lbnRCb3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyb290Tm9kZSIsImRvY3VtZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJzY3JvbGxYIiwicGFnZVhPZmZzZXQiLCJ1bmRlZmluZWQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVgiLCJsZWZ0IiwicGFnZVkiLCJ0b3AiLCJjbGllbnRXaWR0aCIsIndpZHRoIiwiY2xpZW50SGVpZ2h0IiwiaGVpZ2h0IiwiX3JlZ2lzdHJ5IiwicmVnaXN0ZXIiLCJpc1BsdWdpbiIsInJlZ2lzdGVyZWQiLCJwbHVnaW5WZXJzaW9uIiwidmVyc2lvblBhcnNlIiwibnVtYmVyIiwicmVnaXN0ZXJlZFZlcnNpb24iLCJyZXNvbHZlIiwiZGVwZW5kZW5jeSIsImRlcGVuZGVuY3lQYXJzZSIsInJhbmdlIiwiaW5zdGFsbCIsImlzVXNlZCIsImlzRm9yIiwicGFyc2VkIiwiZm9yIiwidmVyc2lvblNhdGlzZmllcyIsInBsdWdpbnMiLCJkZXBlbmRlbmNpZXMiLCJzb3J0ZWREZXBlbmRlbmNpZXMiLCJzdGF0dXMiLCJfd2FybmVkIiwidHJhY2tlZCIsInBhcnNlZEJhc2UiLCJyZXNvbHZlZCIsInBhdHRlcm4iLCJ0ZXN0IiwiaWRlbnRpZmllcnMiLCJpc1JhbmdlIiwiaXNOYU4iLCJzdWJzdHIiLCJvcGVyYXRvciIsInByZXJlbGVhc2UiLCJyYW5nZVBhcnNlZCIsInJhbmdlUGFydHMiLCJ2ZXJzaW9uUGFyc2VkIiwidmVyc2lvblBhcnRzIiwiUnVubmVyIiwiX3JlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9jYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtb3pDYW5jZWxBbmltYXRpb25GcmFtZSIsIndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIiwibXNDYW5jZWxBbmltYXRpb25GcmFtZSIsIl9mcmFtZVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZnBzIiwiZGVsdGFTYW1wbGVTaXplIiwiY291bnRlclRpbWVzdGFtcCIsImZyYW1lQ291bnRlciIsImRlbHRhSGlzdG9yeSIsInRpbWVQcmV2IiwidGltZVNjYWxlUHJldiIsImZyYW1lUmVxdWVzdElkIiwiaXNGaXhlZCIsImVuYWJsZWQiLCJydW5uZXIiLCJkZWx0YU1pbiIsImRlbHRhTWF4IiwicnVuIiwidGltZSIsInRpY2siLCJzdG9wIiwic3RhcnQiLCJfbW90aW9uV2FrZVRocmVzaG9sZCIsIl9tb3Rpb25TbGVlcFRocmVzaG9sZCIsIl9taW5CaWFzIiwidGltZUZhY3RvciIsIm1pbk1vdGlvbiIsIm1heE1vdGlvbiIsInNsZWVwQ291bnRlciIsInNsZWVwaW5nQm9keSIsIm1vdmluZ0JvZHkiLCJ3YXNTbGVlcGluZyIsImRlY29tcCIsImNoYW1mZXIiLCJyYWRpdXMiLCJxdWFsaXR5IiwicXVhbGl0eU1pbiIsInF1YWxpdHlNYXgiLCJ0cmFwZXpvaWQiLCJzbG9wZSIsInJvb2YiLCJ4MSIsIngyIiwieDMiLCJ2ZXJ0aWNlc1BhdGgiLCJjaXJjbGUiLCJtYXhTaWRlcyIsInNpZGVzIiwiY2VpbCIsInBvbHlnb24iLCJ0aGV0YSIsIlBJIiwieHgiLCJ5eSIsInRvRml4ZWQiLCJ2ZXJ0ZXhTZXRzIiwiZmxhZ0ludGVybmFsIiwicmVtb3ZlQ29sbGluZWFyIiwibWluaW11bUFyZWEiLCJpc0NvbnZleCIsInYiLCJ6IiwiY29uY2F2ZSIsIm1ha2VDQ1ciLCJyZW1vdmVDb2xsaW5lYXJQb2ludHMiLCJkZWNvbXBvc2VkIiwicXVpY2tEZWNvbXAiLCJjaHVuayIsImNodW5rVmVydGljZXMiLCJjb2luY2lkZW50X21heF9kaXN0IiwicGF2IiwicGJ2IiwiZGEiLCJtYWduaXR1ZGVTcXVhcmVkIiwiZGIiLCJpc0ludGVybmFsIiwiQ29tcG9zaXRlcyIsInN0YWNrIiwiY29sdW1ucyIsInJvd3MiLCJjb2x1bW5HYXAiLCJyb3dHYXAiLCJsYXN0Qm9keSIsIm1heEhlaWdodCIsImJvZHlIZWlnaHQiLCJib2R5V2lkdGgiLCJ4T2Zmc2V0QSIsInlPZmZzZXRBIiwieE9mZnNldEIiLCJ5T2Zmc2V0QiIsImJvZHlBSGVpZ2h0IiwiYm9keUFXaWR0aCIsImJvZHlCSGVpZ2h0IiwiYm9keUJXaWR0aCIsIm1lc2giLCJjcm9zc0JyYWNlIiwiYm9keUMiLCJweXJhbWlkIiwiYWN0dWFsUm93cyIsImxhc3RCb2R5V2lkdGgiLCJuZXd0b25zQ3JhZGxlIiwic2l6ZSIsImNhciIsIndoZWVsU2l6ZSIsIndoZWVsQmFzZSIsIndoZWVsQU9mZnNldCIsIndoZWVsQk9mZnNldCIsIndoZWVsWU9mZnNldCIsIndoZWVsQSIsIndoZWVsQiIsImF4ZWxBIiwiYXhlbEIiLCJzb2Z0Qm9keSIsInBhcnRpY2xlUmFkaXVzIiwicGFydGljbGVPcHRpb25zIiwiY29uc3RyYWludE9wdGlvbnMiLCJub3JtYWxpc2UiLCJncmFkaWVudCIsImJvdW5kc0EiLCJib3VuZHNCIiwidmVjdG9yIiwic2hpZnQiLCJkZWx0YVgiLCJkZWx0YVkiLCJTdmciLCJwYXRoVG9WZXJ0aWNlcyIsInNhbXBsZUxlbmd0aCIsImlsIiwic2VnbWVudCIsInNlZ21lbnRzIiwic2VnbWVudHNRdWV1ZSIsImxhc3RTZWdtZW50IiwibGFzdFBvaW50Iiwic2VnbWVudEluZGV4IiwicG9pbnRzIiwibHgiLCJseSIsImFkZFBvaW50IiwicHgiLCJweSIsInBhdGhTZWdUeXBlIiwiaXNSZWxhdGl2ZSIsImFkZFNlZ21lbnRQb2ludCIsInNlZ1R5cGUiLCJwYXRoU2VnVHlwZUFzTGV0dGVyIiwidG9VcHBlckNhc2UiLCJfc3ZnUGF0aFRvQWJzb2x1dGUiLCJnZXRUb3RhbExlbmd0aCIsInBhdGhTZWdMaXN0IiwibnVtYmVyT2ZJdGVtcyIsImdldEl0ZW0iLCJnZXRQYXRoU2VnQXRMZW5ndGgiLCJnZXRQb2ludEF0TGVuZ3RoIiwieDAiLCJ5MCIsInkxIiwieTIiLCJzZWdzIiwibGVuIiwic2VnIiwicmVwbGFjZUl0ZW0iLCJjcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0FicyIsImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0FicyIsImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMiLCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0FicyIsImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0FyY0FicyIsInIxIiwicjIiLCJsYXJnZUFyY0ZsYWciLCJzd2VlcEZsYWciLCJzcXJ0Iiwib3V0cHV0IiwidmVjdG9yQSIsInZlY3RvckIiLCJjcm9zczMiLCJ2ZWN0b3JDIiwic2NhbGFyIiwibmVnYXRlIiwiYXRhbjIiLCJwYXRoUGF0dGVybiIsIm1hdGNoIiwicGFyc2VGbG9hdCIsIm1lYW4iLCJhdmVyYWdlIiwic2lnbmVkIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJ2ZXJ0aWNlIiwibmV4dFZlcnRpY2UiLCJuZXdWZXJ0aWNlcyIsInByZXZWZXJ0ZXgiLCJuZXh0VmVydGV4IiwiY3VycmVudFJhZGl1cyIsInByZXZOb3JtYWwiLCJuZXh0Tm9ybWFsIiwiZGlhZ29uYWxSYWRpdXMiLCJyYWRpdXNWZWN0b3IiLCJtaWROb3JtYWwiLCJzY2FsZWRWZXJ0ZXgiLCJwcmVjaXNpb24iLCJhbHBoYSIsImFjb3MiLCJzb3J0IiwiZmxhZyIsInVwcGVyIiwibG93ZXIiLCJwb3AiLCJSZW5kZXJQaXhpIiwiYmFja2dyb3VuZCIsIndpcmVmcmFtZUJhY2tncm91bmQiLCJoYXNCb3VuZHMiLCJ3aXJlZnJhbWVzIiwic2hvd1NsZWVwaW5nIiwic2hvd0RlYnVnIiwic2hvd0Jyb2FkcGhhc2UiLCJzaG93Qm91bmRzIiwic2hvd1ZlbG9jaXR5Iiwic2hvd0NvbGxpc2lvbnMiLCJzaG93U2VwYXJhdGlvbnMiLCJzaG93QXhlcyIsInNob3dQb3NpdGlvbnMiLCJzaG93QW5nbGVJbmRpY2F0b3IiLCJzaG93SWRzIiwic2hvd1NoYWRvd3MiLCJzaG93VmVydGV4TnVtYmVycyIsInNob3dDb252ZXhIdWxscyIsInNob3dJbnRlcm5hbEVkZ2VzIiwic2hvd01vdXNlUG9zaXRpb24iLCJfY3JlYXRlQ2FudmFzIiwiY29udGV4dCIsImdldENvbnRleHQiLCJ0ZXh0dXJlcyIsInNldFBpeGVsUmF0aW8iLCJhcHBlbmRDaGlsZCIsImxvb3AiLCJfZ2V0UGl4ZWxSYXRpbyIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwibG9va0F0IiwicGFkZGluZyIsImNlbnRlciIsInZpZXdIZWlnaHQiLCJ2aWV3V2lkdGgiLCJvdXRlclJhdGlvIiwiaW5uZXJSYXRpbyIsInN0YXJ0Vmlld1RyYW5zZm9ybSIsImJvdW5kc1dpZHRoIiwiYm91bmRzSGVpZ2h0IiwiYm91bmRzU2NhbGVYIiwiYm91bmRzU2NhbGVZIiwiZW5kVmlld1RyYW5zZm9ybSIsInNldFRyYW5zZm9ybSIsImN1cnJlbnRCYWNrZ3JvdW5kIiwiX2FwcGx5QmFja2dyb3VuZCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImZpbGxSZWN0IiwiYm9keUNvbnZleEh1bGxzIiwiYm9keVdpcmVmcmFtZXMiLCJib2R5Qm91bmRzIiwiYm9keUF4ZXMiLCJib2R5UG9zaXRpb25zIiwiYm9keVZlbG9jaXR5IiwiYm9keUlkcyIsInNlcGFyYXRpb25zIiwidmVydGV4TnVtYmVycyIsIm1vdXNlUG9zaXRpb24iLCJkZWJ1ZyIsInNwYWNlIiwiZGVidWdUaW1lc3RhbXAiLCJ0ZXh0Iiwicm91bmQiLCJkZWJ1Z1N0cmluZyIsImZvbnQiLCJmaWxsVGV4dCIsImJlZ2luUGF0aCIsImFyYyIsImNsb3NlUGF0aCIsIm1vdmVUbyIsImNvaWxzIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbCIsImJvZHlTaGFkb3dzIiwiZGlzdGFuY2VYIiwiZGlzdGFuY2VZIiwic2hhZG93Q29sb3IiLCJzaGFkb3dPZmZzZXRYIiwic2hhZG93T2Zmc2V0WSIsInNoYWRvd0JsdXIiLCJnbG9iYWxBbHBoYSIsInRleHR1cmUiLCJfZ2V0VGV4dHVyZSIsImRyYXdJbWFnZSIsInJlY3QiLCJjb3JyZWN0ZWQiLCJub3JtYWxQb3NYIiwibm9ybWFsUG9zWSIsImJ1Y2tldEtleXMiLCJpbnNwZWN0b3IiLCJzZWxlY3RlZCIsIml0ZW0iLCJkYXRhIiwic2V0TGluZURhc2giLCJzZWxlY3RTdGFydCIsInNlbGVjdEJvdW5kcyIsImNyZWF0ZUVsZW1lbnQiLCJvbmNvbnRleHRtZW51Iiwib25zZWxlY3RzdGFydCIsImRldmljZVBpeGVsUmF0aW8iLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImltYWdlUGF0aCIsImltYWdlIiwiSW1hZ2UiLCJzcmMiLCJjc3NCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZFNpemUiLCJyZW5kZXJlciIsImNvbnRhaW5lciIsInNwcml0ZUNvbnRhaW5lciIsInBpeGlPcHRpb25zIiwidHJhbnNwYXJlbnQiLCJ2aWV3IiwiYW50aWFsaWFzIiwiYmFja2dyb3VuZENvbG9yIiwiUElYSSIsIldlYkdMUmVuZGVyZXIiLCJDb250YWluZXIiLCJzcHJpdGVzIiwicHJpbWl0aXZlcyIsImFkZENoaWxkIiwiY2hpbGRyZW4iLCJyZW1vdmVDaGlsZCIsImJnU3ByaXRlIiwiYWRkQ2hpbGRBdCIsInNldEJhY2tncm91bmQiLCJpc0NvbG9yIiwiY29sb3IiLCJTcHJpdGUiLCJjb25zdHJhaW50UmVuZGVyIiwicHJpbWl0aXZlSWQiLCJwcmltaXRpdmUiLCJHcmFwaGljcyIsImJlZ2luRmlsbCIsImxpbmVTdHlsZSIsImVuZEZpbGwiLCJib2R5UmVuZGVyIiwic3ByaXRlSWQiLCJfY3JlYXRlQm9keVNwcml0ZSIsIl9jcmVhdGVCb2R5UHJpbWl0aXZlIiwiaW5pdGlhbEFuZ2xlIiwidGV4dHVyZVBhdGgiLCJhbmNob3IiLCJzdHJva2VTdHlsZUluZGljYXRvciIsInN0cm9rZVN0eWxlV2lyZWZyYW1lIiwic3Ryb2tlU3R5bGVXaXJlZnJhbWVJbmRpY2F0b3IiLCJUZXh0dXJlIiwiZnJvbUltYWdlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FFQSxDQUFBLFNBQVNBLENBQUM7SUFBRSxJQUFHLE9BQU9DLFlBQVUsWUFBVSxPQUFPQyxXQUFTLGFBQVk7UUFBQ0EsT0FBT0QsT0FBTyxHQUFDRDtJQUFHLE9BQU0sSUFBRyxPQUFPRyxXQUFTLGNBQVlBLE9BQU9DLEdBQUcsRUFBQztRQUFDRCxPQUFPLEVBQUUsRUFBQ0g7SUFBRSxPQUFLO1FBQUMsSUFBSUs7UUFBRSxJQUFHLE9BQU9DLFdBQVMsYUFBWTtZQUFD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