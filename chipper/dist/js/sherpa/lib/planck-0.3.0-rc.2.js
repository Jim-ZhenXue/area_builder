/*
 * Planck.js v0.3.0-rc.2
 * 
 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
 * Copyright (c) 2006-2013 Erin Catto  http://www.gphysics.com
 * 
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * 
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */ !function(e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.planck = e();
    }
}(function() {
    var define1, module1, exports1;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for(var o = 0; o < r.length; o++)s(r[o]);
        return s;
    })({
        1: [
            function(require1, module1, exports1) {
                exports1.internal = {};
                exports1.Math = require1("./common/Math");
                exports1.Vec2 = require1("./common/Vec2");
                exports1.Vec3 = require1("./common/Vec3");
                exports1.Mat22 = require1("./common/Mat22");
                exports1.Mat33 = require1("./common/Mat33");
                exports1.Transform = require1("./common/Transform");
                exports1.Rot = require1("./common/Rot");
                exports1.AABB = require1("./collision/AABB");
                exports1.Shape = require1("./Shape");
                exports1.Fixture = require1("./Fixture");
                exports1.Body = require1("./Body");
                exports1.Contact = require1("./Contact");
                exports1.Joint = require1("./Joint");
                exports1.World = require1("./World");
                exports1.Circle = require1("./shape/CircleShape");
                exports1.Edge = require1("./shape/EdgeShape");
                exports1.Polygon = require1("./shape/PolygonShape");
                exports1.Chain = require1("./shape/ChainShape");
                exports1.Box = require1("./shape/BoxShape");
                require1("./shape/CollideCircle");
                require1("./shape/CollideEdgeCircle");
                exports1.internal.CollidePolygons = require1("./shape/CollidePolygon");
                require1("./shape/CollideCirclePolygone");
                require1("./shape/CollideEdgePolygon");
                exports1.DistanceJoint = require1("./joint/DistanceJoint");
                exports1.FrictionJoint = require1("./joint/FrictionJoint");
                exports1.GearJoint = require1("./joint/GearJoint");
                exports1.MotorJoint = require1("./joint/MotorJoint");
                exports1.MouseJoint = require1("./joint/MouseJoint");
                exports1.PrismaticJoint = require1("./joint/PrismaticJoint");
                exports1.PulleyJoint = require1("./joint/PulleyJoint");
                exports1.RevoluteJoint = require1("./joint/RevoluteJoint");
                exports1.RopeJoint = require1("./joint/RopeJoint");
                exports1.WeldJoint = require1("./joint/WeldJoint");
                exports1.WheelJoint = require1("./joint/WheelJoint");
                exports1.internal.Sweep = require1("./common/Sweep");
                exports1.internal.stats = require1("./common/stats");
                exports1.internal.Manifold = require1("./Manifold");
                exports1.internal.Distance = require1("./collision/Distance");
                exports1.internal.TimeOfImpact = require1("./collision/TimeOfImpact");
                exports1.internal.DynamicTree = require1("./collision/DynamicTree");
                exports1.internal.Settings = require1("./Settings");
            },
            {
                "./Body": 2,
                "./Contact": 3,
                "./Fixture": 4,
                "./Joint": 5,
                "./Manifold": 6,
                "./Settings": 7,
                "./Shape": 8,
                "./World": 10,
                "./collision/AABB": 11,
                "./collision/Distance": 13,
                "./collision/DynamicTree": 14,
                "./collision/TimeOfImpact": 15,
                "./common/Mat22": 16,
                "./common/Mat33": 17,
                "./common/Math": 18,
                "./common/Rot": 20,
                "./common/Sweep": 21,
                "./common/Transform": 22,
                "./common/Vec2": 23,
                "./common/Vec3": 24,
                "./common/stats": 26,
                "./joint/DistanceJoint": 27,
                "./joint/FrictionJoint": 28,
                "./joint/GearJoint": 29,
                "./joint/MotorJoint": 30,
                "./joint/MouseJoint": 31,
                "./joint/PrismaticJoint": 32,
                "./joint/PulleyJoint": 33,
                "./joint/RevoluteJoint": 34,
                "./joint/RopeJoint": 35,
                "./joint/WeldJoint": 36,
                "./joint/WheelJoint": 37,
                "./shape/BoxShape": 38,
                "./shape/ChainShape": 39,
                "./shape/CircleShape": 40,
                "./shape/CollideCircle": 41,
                "./shape/CollideCirclePolygone": 42,
                "./shape/CollideEdgeCircle": 43,
                "./shape/CollideEdgePolygon": 44,
                "./shape/CollidePolygon": 45,
                "./shape/EdgeShape": 46,
                "./shape/PolygonShape": 47
            }
        ],
        2: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Body;
                var common1 = require1("./util/common");
                var options = require1("./util/options");
                var Vec2 = require1("./common/Vec2");
                var Rot = require1("./common/Rot");
                var Math1 = require1("./common/Math");
                var Sweep = require1("./common/Sweep");
                var Transform = require1("./common/Transform");
                var Velocity = require1("./common/Velocity");
                var Position = require1("./common/Position");
                var Fixture = require1("./Fixture");
                var Shape = require1("./Shape");
                var World = require1("./World");
                var staticBody = Body.STATIC = "static";
                var kinematicBody = Body.KINEMATIC = "kinematic";
                var dynamicBody = Body.DYNAMIC = "dynamic";
                /**
 * @typedef {Object} BodyDef
 *
 * @prop type Body types are static, kinematic, or dynamic. Note: if a dynamic
 *       body would have zero mass, the mass is set to one.
 *
 * @prop position The world position of the body. Avoid creating bodies at the
 *       origin since this can lead to many overlapping shapes.
 *
 * @prop angle The world angle of the body in radians.
 *
 * @prop linearVelocity The linear velocity of the body's origin in world
 *       co-ordinates.
 *
 * @prop linearDamping Linear damping is use to reduce the linear velocity. The
 *       damping parameter can be larger than 1.0 but the damping effect becomes
 *       sensitive to the time step when the damping parameter is large.
 *
 * @prop angularDamping Angular damping is use to reduce the angular velocity.
 *       The damping parameter can be larger than 1.0 but the damping effect
 *       becomes sensitive to the time step when the damping parameter is large.
 *
 * @prop fixedRotation Should this body be prevented from rotating? Useful for
 *       characters.
 *
 * @prop bullet Is this a fast moving body that should be prevented from
 *       tunneling through other moving bodies? Note that all bodies are
 *       prevented from tunneling through kinematic and static bodies. This
 *       setting is only considered on dynamic bodies. Warning: You should use
 *       this flag sparingly since it increases processing time.
 *
 * @prop active Does this body start out active?
 *
 * @prop awake Is this body initially awake or sleeping?
 *
 * @prop allowSleep Set this flag to false if this body should never fall
 *       asleep. Note that this increases CPU usage.
 */ var BodyDef = {
                    type: staticBody,
                    position: Vec2.zero(),
                    angle: 0,
                    linearVelocity: Vec2.zero(),
                    angularVelocity: 0,
                    linearDamping: 0,
                    angularDamping: 0,
                    fixedRotation: false,
                    bullet: false,
                    gravityScale: 1,
                    allowSleep: true,
                    awake: true,
                    active: true,
                    userData: null
                };
                /**
 * @class
 * 
 * A rigid body composed of one or more fixtures.
 * 
 * @param {BodyDef} def
 */ function Body(world, def) {
                    def = options(def, BodyDef);
                    _ASSERT && common1.assert(Vec2.isValid(def.position));
                    _ASSERT && common1.assert(Vec2.isValid(def.linearVelocity));
                    _ASSERT && common1.assert(Math1.isFinite(def.angle));
                    _ASSERT && common1.assert(Math1.isFinite(def.angularVelocity));
                    _ASSERT && common1.assert(Math1.isFinite(def.angularDamping) && def.angularDamping >= 0);
                    _ASSERT && common1.assert(Math1.isFinite(def.linearDamping) && def.linearDamping >= 0);
                    this.m_world = world;
                    this.m_awakeFlag = def.awake;
                    this.m_autoSleepFlag = def.allowSleep;
                    this.m_bulletFlag = def.bullet;
                    this.m_fixedRotationFlag = def.fixedRotation;
                    this.m_activeFlag = def.active;
                    this.m_islandFlag = false;
                    this.m_toiFlag = false;
                    this.m_userData = def.userData;
                    this.m_type = def.type;
                    if (this.m_type == dynamicBody) {
                        this.m_mass = 1;
                        this.m_invMass = 1;
                    } else {
                        this.m_mass = 0;
                        this.m_invMass = 0;
                    }
                    // Rotational inertia about the center of mass.
                    this.m_I = 0;
                    this.m_invI = 0;
                    // the body origin transform
                    this.m_xf = Transform.identity();
                    this.m_xf.p = Vec2.clone(def.position);
                    this.m_xf.q.setAngle(def.angle);
                    // the swept motion for CCD
                    this.m_sweep = new Sweep();
                    this.m_sweep.setTransform(this.m_xf);
                    // position and velocity correction
                    this.c_velocity = new Velocity();
                    this.c_position = new Position();
                    this.m_force = Vec2.zero();
                    this.m_torque = 0;
                    this.m_linearVelocity = Vec2.clone(def.linearVelocity);
                    this.m_angularVelocity = def.angularVelocity;
                    this.m_linearDamping = def.linearDamping;
                    this.m_angularDamping = def.angularDamping;
                    this.m_gravityScale = def.gravityScale;
                    this.m_sleepTime = 0;
                    this.m_jointList = null;
                    this.m_contactList = null;
                    this.m_fixtureList = null;
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_destroyed = false;
                }
                Body.prototype.isWorldLocked = function() {
                    return this.m_world && this.m_world.isLocked() ? true : false;
                };
                Body.prototype.getWorld = function() {
                    return this.m_world;
                };
                Body.prototype.getNext = function() {
                    return this.m_next;
                };
                Body.prototype.setUserData = function(data) {
                    this.m_userData = data;
                };
                Body.prototype.getUserData = function() {
                    return this.m_userData;
                };
                Body.prototype.getFixtureList = function() {
                    return this.m_fixtureList;
                };
                Body.prototype.getJointList = function() {
                    return this.m_jointList;
                };
                /**
 * Warning: this list changes during the time step and you may miss some
 * collisions if you don't use ContactListener.
 */ Body.prototype.getContactList = function() {
                    return this.m_contactList;
                };
                Body.prototype.isStatic = function() {
                    return this.m_type == staticBody;
                };
                Body.prototype.isDynamic = function() {
                    return this.m_type == dynamicBody;
                };
                Body.prototype.isKinematic = function() {
                    return this.m_type == kinematicBody;
                };
                /**
 * This will alter the mass and velocity.
 */ Body.prototype.setStatic = function() {
                    this.setType(staticBody);
                    return this;
                };
                Body.prototype.setDynamic = function() {
                    this.setType(dynamicBody);
                    return this;
                };
                Body.prototype.setKinematic = function() {
                    this.setType(kinematicBody);
                    return this;
                };
                /**
 * @private
 */ Body.prototype.getType = function() {
                    return this.m_type;
                };
                /**
 * 
 * @private
 */ Body.prototype.setType = function(type) {
                    _ASSERT && common1.assert(type === staticBody || type === kinematicBody || type === dynamicBody);
                    _ASSERT && common1.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    if (this.m_type == type) {
                        return;
                    }
                    this.m_type = type;
                    this.resetMassData();
                    if (this.m_type == staticBody) {
                        this.m_linearVelocity.setZero();
                        this.m_angularVelocity = 0;
                        this.m_sweep.forward();
                        this.synchronizeFixtures();
                    }
                    this.setAwake(true);
                    this.m_force.setZero();
                    this.m_torque = 0;
                    // Delete the attached contacts.
                    var ce = this.m_contactList;
                    while(ce){
                        var ce0 = ce;
                        ce = ce.next;
                        this.m_world.destroyContact(ce0.contact);
                    }
                    this.m_contactList = null;
                    // Touch the proxies so that new contacts will be created (when appropriate)
                    var broadPhase = this.m_world.m_broadPhase;
                    for(var f = this.m_fixtureList; f; f = f.m_next){
                        var proxyCount = f.m_proxyCount;
                        for(var i = 0; i < proxyCount; ++i){
                            broadPhase.touchProxy(f.m_proxies[i].proxyId);
                        }
                    }
                };
                Body.prototype.isBullet = function() {
                    return this.m_bulletFlag;
                };
                /**
 * Should this body be treated like a bullet for continuous collision detection?
 */ Body.prototype.setBullet = function(flag) {
                    this.m_bulletFlag = !!flag;
                };
                Body.prototype.isSleepingAllowed = function() {
                    return this.m_autoSleepFlag;
                };
                Body.prototype.setSleepingAllowed = function(flag) {
                    this.m_autoSleepFlag = !!flag;
                    if (this.m_autoSleepFlag == false) {
                        this.setAwake(true);
                    }
                };
                Body.prototype.isAwake = function() {
                    return this.m_awakeFlag;
                };
                /**
 * Set the sleep state of the body. A sleeping body has very low CPU cost.
 * 
 * @param flag Set to true to wake the body, false to put it to sleep.
 */ Body.prototype.setAwake = function(flag) {
                    if (flag) {
                        if (this.m_awakeFlag == false) {
                            this.m_awakeFlag = true;
                            this.m_sleepTime = 0;
                        }
                    } else {
                        this.m_awakeFlag = false;
                        this.m_sleepTime = 0;
                        this.m_linearVelocity.setZero();
                        this.m_angularVelocity = 0;
                        this.m_force.setZero();
                        this.m_torque = 0;
                    }
                };
                Body.prototype.isActive = function() {
                    return this.m_activeFlag;
                };
                /**
 * Set the active state of the body. An inactive body is not simulated and
 * cannot be collided with or woken up. If you pass a flag of true, all fixtures
 * will be added to the broad-phase. If you pass a flag of false, all fixtures
 * will be removed from the broad-phase and all contacts will be destroyed.
 * Fixtures and joints are otherwise unaffected.
 * 
 * You may continue to create/destroy fixtures and joints on inactive bodies.
 * Fixtures on an inactive body are implicitly inactive and will not participate
 * in collisions, ray-casts, or queries. Joints connected to an inactive body
 * are implicitly inactive. An inactive body is still owned by a World object
 * and remains
 */ Body.prototype.setActive = function(flag) {
                    _ASSERT && common1.assert(this.isWorldLocked() == false);
                    if (flag == this.m_activeFlag) {
                        return;
                    }
                    this.m_activeFlag = !!flag;
                    if (this.m_activeFlag) {
                        // Create all proxies.
                        var broadPhase = this.m_world.m_broadPhase;
                        for(var f = this.m_fixtureList; f; f = f.m_next){
                            f.createProxies(broadPhase, this.m_xf);
                        }
                    } else {
                        // Destroy all proxies.
                        var broadPhase = this.m_world.m_broadPhase;
                        for(var f = this.m_fixtureList; f; f = f.m_next){
                            f.destroyProxies(broadPhase);
                        }
                        // Destroy the attached contacts.
                        var ce = this.m_contactList;
                        while(ce){
                            var ce0 = ce;
                            ce = ce.next;
                            this.m_world.destroyContact(ce0.contact);
                        }
                        this.m_contactList = null;
                    }
                };
                Body.prototype.isFixedRotation = function() {
                    return this.m_fixedRotationFlag;
                };
                /**
 * Set this body to have fixed rotation. This causes the mass to be reset.
 */ Body.prototype.setFixedRotation = function(flag) {
                    if (this.m_fixedRotationFlag == flag) {
                        return;
                    }
                    this.m_fixedRotationFlag = !!flag;
                    this.m_angularVelocity = 0;
                    this.resetMassData();
                };
                /**
 * Get the world transform for the body's origin.
 */ Body.prototype.getTransform = function() {
                    return this.m_xf;
                };
                /**
 * Set the position of the body's origin and rotation. Manipulating a body's
 * transform may cause non-physical behavior. Note: contacts are updated on the
 * next call to World.step.
 * 
 * @param position The world position of the body's local origin.
 * @param angle The world rotation in radians.
 */ Body.prototype.setTransform = function(position, angle) {
                    _ASSERT && common1.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    this.m_xf.set(position, angle);
                    this.m_sweep.setTransform(this.m_xf);
                    var broadPhase = this.m_world.m_broadPhase;
                    for(var f = this.m_fixtureList; f; f = f.m_next){
                        f.synchronize(broadPhase, this.m_xf, this.m_xf);
                    }
                };
                Body.prototype.synchronizeTransform = function() {
                    this.m_sweep.getTransform(this.m_xf, 1);
                };
                /**
 * Update fixtures in broad-phase.
 */ Body.prototype.synchronizeFixtures = function() {
                    var xf = Transform.identity();
                    this.m_sweep.getTransform(xf, 0);
                    var broadPhase = this.m_world.m_broadPhase;
                    for(var f = this.m_fixtureList; f; f = f.m_next){
                        f.synchronize(broadPhase, xf, this.m_xf);
                    }
                };
                /**
 * Used in TOI.
 */ Body.prototype.advance = function(alpha) {
                    // Advance to the new safe time. This doesn't sync the broad-phase.
                    this.m_sweep.advance(alpha);
                    this.m_sweep.c.set(this.m_sweep.c0);
                    this.m_sweep.a = this.m_sweep.a0;
                    this.m_sweep.getTransform(this.m_xf, 1);
                };
                /**
 * Get the world position for the body's origin.
 */ Body.prototype.getPosition = function() {
                    return this.m_xf.p;
                };
                Body.prototype.setPosition = function(p) {
                    this.setTransform(p, this.m_sweep.a);
                };
                /**
 * Get the current world rotation angle in radians.
 */ Body.prototype.getAngle = function() {
                    return this.m_sweep.a;
                };
                Body.prototype.setAngle = function(angle) {
                    this.setTransform(this.m_xf.p, angle);
                };
                /**
 * Get the world position of the center of mass.
 */ Body.prototype.getWorldCenter = function() {
                    return this.m_sweep.c;
                };
                /**
 * Get the local position of the center of mass.
 */ Body.prototype.getLocalCenter = function() {
                    return this.m_sweep.localCenter;
                };
                /**
 * Get the linear velocity of the center of mass.
 * 
 * @return the linear velocity of the center of mass.
 */ Body.prototype.getLinearVelocity = function() {
                    return this.m_linearVelocity;
                };
                /**
 * Get the world linear velocity of a world point attached to this body.
 * 
 * @param worldPoint A point in world coordinates.
 */ Body.prototype.getLinearVelocityFromWorldPoint = function(worldPoint) {
                    var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);
                    return Vec2.add(this.m_linearVelocity, Vec2.cross(this.m_angularVelocity, localCenter));
                };
                /**
 * Get the world velocity of a local point.
 * 
 * @param localPoint A point in local coordinates.
 */ Body.prototype.getLinearVelocityFromLocalPoint = function(localPoint) {
                    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));
                };
                /**
 * Set the linear velocity of the center of mass.
 * 
 * @param v The new linear velocity of the center of mass.
 */ Body.prototype.setLinearVelocity = function(v) {
                    if (this.m_type == staticBody) {
                        return;
                    }
                    if (Vec2.dot(v, v) > 0) {
                        this.setAwake(true);
                    }
                    this.m_linearVelocity.set(v);
                };
                /**
 * Get the angular velocity.
 * 
 * @returns the angular velocity in radians/second.
 */ Body.prototype.getAngularVelocity = function() {
                    return this.m_angularVelocity;
                };
                /**
 * Set the angular velocity.
 * 
 * @param omega The new angular velocity in radians/second.
 */ Body.prototype.setAngularVelocity = function(w) {
                    if (this.m_type == staticBody) {
                        return;
                    }
                    if (w * w > 0) {
                        this.setAwake(true);
                    }
                    this.m_angularVelocity = w;
                };
                Body.prototype.getLinearDamping = function() {
                    return this.m_linearDamping;
                };
                Body.prototype.setLinearDamping = function(linearDamping) {
                    this.m_linearDamping = linearDamping;
                };
                Body.prototype.getAngularDamping = function() {
                    return this.m_angularDamping;
                };
                Body.prototype.setAngularDamping = function(angularDamping) {
                    this.m_angularDamping = angularDamping;
                };
                Body.prototype.getGravityScale = function() {
                    return this.m_gravityScale;
                };
                /**
 * Scale the gravity applied to this body.
 */ Body.prototype.setGravityScale = function(scale) {
                    this.m_gravityScale = scale;
                };
                /**
 * Get the total mass of the body.
 * 
 * @returns The mass, usually in kilograms (kg).
 */ Body.prototype.getMass = function() {
                    return this.m_mass;
                };
                /**
 * Get the rotational inertia of the body about the local origin.
 * 
 * @return the rotational inertia, usually in kg-m^2.
 */ Body.prototype.getInertia = function() {
                    return this.m_I + this.m_mass * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
                };
                /**
 * @typedef {Object} MassData This holds the mass data computed for a shape.
 * 
 * @prop mass The mass of the shape, usually in kilograms.
 * @prop center The position of the shape's centroid relative to the shape's
 *       origin.
 * @prop I The rotational inertia of the shape about the local origin.
 */ function MassData() {
                    this.mass = 0;
                    this.center = Vec2.zero();
                    this.I = 0;
                }
                /**
 * Copy the mass data of the body to data.
 */ Body.prototype.getMassData = function(data) {
                    data.mass = this.m_mass;
                    data.I = this.getInertia();
                    data.center.set(this.m_sweep.localCenter);
                };
                /**
 * This resets the mass properties to the sum of the mass properties of the
 * fixtures. This normally does not need to be called unless you called
 * SetMassData to override the mass and you later want to reset the mass.
 */ Body.prototype.resetMassData = function() {
                    // Compute mass data from shapes. Each shape has its own density.
                    this.m_mass = 0;
                    this.m_invMass = 0;
                    this.m_I = 0;
                    this.m_invI = 0;
                    this.m_sweep.localCenter.setZero();
                    // Static and kinematic bodies have zero mass.
                    if (this.isStatic() || this.isKinematic()) {
                        this.m_sweep.c0.set(this.m_xf.p);
                        this.m_sweep.c.set(this.m_xf.p);
                        this.m_sweep.a0 = this.m_sweep.a;
                        return;
                    }
                    _ASSERT && common1.assert(this.isDynamic());
                    // Accumulate mass over all fixtures.
                    var localCenter = Vec2.zero();
                    for(var f = this.m_fixtureList; f; f = f.m_next){
                        if (f.m_density == 0) {
                            continue;
                        }
                        var massData = new MassData();
                        f.getMassData(massData);
                        this.m_mass += massData.mass;
                        localCenter.addMul(massData.mass, massData.center);
                        this.m_I += massData.I;
                    }
                    // Compute center of mass.
                    if (this.m_mass > 0) {
                        this.m_invMass = 1 / this.m_mass;
                        localCenter.mul(this.m_invMass);
                    } else {
                        // Force all dynamic bodies to have a positive mass.
                        this.m_mass = 1;
                        this.m_invMass = 1;
                    }
                    if (this.m_I > 0 && this.m_fixedRotationFlag == false) {
                        // Center the inertia about the center of mass.
                        this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);
                        _ASSERT && common1.assert(this.m_I > 0);
                        this.m_invI = 1 / this.m_I;
                    } else {
                        this.m_I = 0;
                        this.m_invI = 0;
                    }
                    // Move center of mass.
                    var oldCenter = Vec2.clone(this.m_sweep.c);
                    this.m_sweep.setLocalCenter(localCenter, this.m_xf);
                    // Update center of mass velocity.
                    this.m_linearVelocity.add(Vec2.cross(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));
                };
                /**
 * Set the mass properties to override the mass properties of the fixtures. Note
 * that this changes the center of mass position. Note that creating or
 * destroying fixtures can also alter the mass. This function has no effect if
 * the body isn't dynamic.
 * 
 * @param massData The mass properties.
 */ Body.prototype.setMassData = function(massData) {
                    _ASSERT && common1.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    this.m_invMass = 0;
                    this.m_I = 0;
                    this.m_invI = 0;
                    this.m_mass = massData.mass;
                    if (this.m_mass <= 0) {
                        this.m_mass = 1;
                    }
                    this.m_invMass = 1 / this.m_mass;
                    if (massData.I > 0 && this.m_fixedRotationFlag == false) {
                        this.m_I = massData.I - this.m_mass * Vec2.dot(massData.center, massData.center);
                        _ASSERT && common1.assert(this.m_I > 0);
                        this.m_invI = 1 / this.m_I;
                    }
                    // Move center of mass.
                    var oldCenter = Vec2.clone(this.m_sweep.c);
                    this.m_sweep.setLocalCenter(massData.center, this.m_xf);
                    // Update center of mass velocity.
                    this.m_linearVelocity.add(Vec2.cross(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));
                };
                /**
 * Apply a force at a world point. If the force is not applied at the center of
 * mass, it will generate a torque and affect the angular velocity. This wakes
 * up the body.
 * 
 * @param force The world force vector, usually in Newtons (N).
 * @param point The world position of the point of application.
 * @param wake Also wake up the body
 */ Body.prototype.applyForce = function(force, point, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate a force if the body is sleeping.
                    if (this.m_awakeFlag) {
                        this.m_force.add(force);
                        this.m_torque += Vec2.cross(Vec2.sub(point, this.m_sweep.c), force);
                    }
                };
                /**
 * Apply a force to the center of mass. This wakes up the body.
 * 
 * @param force The world force vector, usually in Newtons (N).
 * @param wake Also wake up the body
 */ Body.prototype.applyForceToCenter = function(force, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate a force if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_force.add(force);
                    }
                };
                /**
 * Apply a torque. This affects the angular velocity without affecting the
 * linear velocity of the center of mass. This wakes up the body.
 * 
 * @param torque About the z-axis (out of the screen), usually in N-m.
 * @param wake Also wake up the body
 */ Body.prototype.applyTorque = function(torque, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate a force if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_torque += torque;
                    }
                };
                /**
 * Apply an impulse at a point. This immediately modifies the velocity. It also
 * modifies the angular velocity if the point of application is not at the
 * center of mass. This wakes up the body.
 * 
 * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.
 * @param point The world position of the point of application.
 * @param wake Also wake up the body
 */ Body.prototype.applyLinearImpulse = function(impulse, point, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate velocity if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_linearVelocity.addMul(this.m_invMass, impulse);
                        this.m_angularVelocity += this.m_invI * Vec2.cross(Vec2.sub(point, this.m_sweep.c), impulse);
                    }
                };
                /**
 * Apply an angular impulse.
 * 
 * @param impulse The angular impulse in units of kg*m*m/s
 * @param wake Also wake up the body
 */ Body.prototype.applyAngularImpulse = function(impulse, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate velocity if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_angularVelocity += this.m_invI * impulse;
                    }
                };
                /**
 * This is used to prevent connected bodies (by joints) from colliding,
 * depending on the joint's collideConnected flag.
 */ Body.prototype.shouldCollide = function(that) {
                    // At least one body should be dynamic.
                    if (this.m_type != dynamicBody && that.m_type != dynamicBody) {
                        return false;
                    }
                    // Does a joint prevent collision?
                    for(var jn = this.m_jointList; jn; jn = jn.next){
                        if (jn.other == that) {
                            if (jn.joint.m_collideConnected == false) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                /**
 * Creates a fixture and attach it to this body.
 * 
 * If the density is non-zero, this function automatically updates the mass of
 * the body.
 * 
 * Contacts are not created until the next time step.
 * 
 * Warning: This function is locked during callbacks.

 * @param {Shape|FixtureDef} shape Shape or fixture definition.
 * @param {FixtureDef|number} fixdef Fixture definition or just density.
 */ Body.prototype.createFixture = function(shape, fixdef) {
                    _ASSERT && common1.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return null;
                    }
                    var fixture = new Fixture(this, shape, fixdef);
                    if (this.m_activeFlag) {
                        var broadPhase = this.m_world.m_broadPhase;
                        fixture.createProxies(broadPhase, this.m_xf);
                    }
                    fixture.m_next = this.m_fixtureList;
                    this.m_fixtureList = fixture;
                    // Adjust mass properties if needed.
                    if (fixture.m_density > 0) {
                        this.resetMassData();
                    }
                    // Let the world know we have a new fixture. This will cause new contacts
                    // to be created at the beginning of the next time step.
                    this.m_world.m_newFixture = true;
                    return fixture;
                };
                /**
 * Destroy a fixture. This removes the fixture from the broad-phase and destroys
 * all contacts associated with this fixture. This will automatically adjust the
 * mass of the body if the body is dynamic and the fixture has positive density.
 * All fixtures attached to a body are implicitly destroyed when the body is
 * destroyed.
 * 
 * Warning: This function is locked during callbacks.
 * 
 * @param fixture The fixture to be removed.
 */ Body.prototype.destroyFixture = function(fixture) {
                    _ASSERT && common1.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    _ASSERT && common1.assert(fixture.m_body == this);
                    // Remove the fixture from this body's singly linked list.
                    var found = false;
                    if (this.m_fixtureList === fixture) {
                        this.m_fixtureList = fixture.m_next;
                        found = true;
                    } else {
                        var node = this.m_fixtureList;
                        while(node != null){
                            if (node.m_next === fixture) {
                                node.m_next = fixture.m_next;
                                found = true;
                                break;
                            }
                            node = node.m_next;
                        }
                    }
                    // You tried to remove a shape that is not attached to this body.
                    _ASSERT && common1.assert(found);
                    // Destroy any contacts associated with the fixture.
                    var edge = this.m_contactList;
                    while(edge){
                        var c = edge.contact;
                        edge = edge.next;
                        var fixtureA = c.getFixtureA();
                        var fixtureB = c.getFixtureB();
                        if (fixture == fixtureA || fixture == fixtureB) {
                            // This destroys the contact and removes it from
                            // this body's contact list.
                            this.m_world.destroyContact(c);
                        }
                    }
                    if (this.m_activeFlag) {
                        var broadPhase = this.m_world.m_broadPhase;
                        fixture.destroyProxies(broadPhase);
                    }
                    fixture.m_body = null;
                    fixture.m_next = null;
                    this.m_world.publish("remove-fixture", fixture);
                    // Reset the mass data.
                    this.resetMassData();
                };
                /**
 * Get the corresponding world point of a local point.
 */ Body.prototype.getWorldPoint = function(localPoint) {
                    return Transform.mulVec2(this.m_xf, localPoint);
                };
                /**
 * Get the corresponding world vector of a local vector.
 */ Body.prototype.getWorldVector = function(localVector) {
                    return Rot.mulVec2(this.m_xf.q, localVector);
                };
                /**
 * Gets the corresponding local point of a world point.
 */ Body.prototype.getLocalPoint = function(worldPoint) {
                    return Transform.mulTVec2(this.m_xf, worldPoint);
                };
                /**
 * 
 * Gets the corresponding local vector of a world vector.
 */ Body.prototype.getLocalVector = function(worldVector) {
                    return Rot.mulTVec2(this.m_xf.q, worldVector);
                };
            },
            {
                "./Fixture": 4,
                "./Shape": 8,
                "./World": 10,
                "./common/Math": 18,
                "./common/Position": 19,
                "./common/Rot": 20,
                "./common/Sweep": 21,
                "./common/Transform": 22,
                "./common/Vec2": 23,
                "./common/Velocity": 25,
                "./util/common": 50,
                "./util/options": 52
            }
        ],
        3: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var DEBUG_SOLVER = false;
                var common1 = require1("./util/common");
                var Pool = require1("./util/Pool");
                var Math1 = require1("./common/Math");
                var Vec2 = require1("./common/Vec2");
                var Transform = require1("./common/Transform");
                var Mat22 = require1("./common/Mat22");
                var Rot = require1("./common/Rot");
                var Settings = require1("./Settings");
                var Manifold = require1("./Manifold");
                var Distance = require1("./collision/Distance");
                module1.exports = Contact;
                /**
 * A contact edge is used to connect bodies and contacts together in a contact
 * graph where each body is a node and each contact is an edge. A contact edge
 * belongs to a doubly linked list maintained in each attached body. Each
 * contact has two contact nodes, one for each attached body.
 * 
 * @prop {Contact} contact The contact
 * @prop {ContactEdge} prev The previous contact edge in the body's contact list
 * @prop {ContactEdge} next The next contact edge in the body's contact list
 * @prop {Body} other Provides quick access to the other body attached.
 */ function ContactEdge(contact) {
                    this.contact = contact;
                    this.prev = null;
                    this.next = null;
                    this.other = null;
                }
                /**
 * @function Contact~evaluate
 * 
 * @param manifold
 * @param xfA
 * @param fixtureA
 * @param indexA
 * @param xfB
 * @param fixtureB
 * @param indexB
 */ /**
 * The class manages contact between two shapes. A contact exists for each
 * overlapping AABB in the broad-phase (except if filtered). Therefore a contact
 * object may exist that has no contact points.
 */ function Contact() {
                    // Nodes for connecting bodies.
                    this.m_nodeA = new ContactEdge(this);
                    this.m_nodeB = new ContactEdge(this);
                    this.m_manifold = new Manifold();
                    this.v_points_cache = [
                        new VelocityConstraintPoint(),
                        new VelocityConstraintPoint()
                    ];
                    this.v_points = [];
                    // VelocityConstraintPoint[maxManifoldPoints]
                    this.v_normal = Vec2.zero();
                    this.v_normalMass = new Mat22();
                    this.v_K = new Mat22();
                    this.p_localPoints_cache = [
                        Vec2.zero(),
                        Vec2.zero()
                    ];
                    this.p_localPoints = [];
                    // Vec2[maxManifoldPoints];
                    this.p_localNormal = Vec2.zero();
                    this.p_localPoint = Vec2.zero();
                    this.p_localCenterA = Vec2.zero();
                    this.p_localCenterB = Vec2.zero();
                }
                /**
 * Initialize a Contact.
 *
 * @param {Fixture} fA
 * @param {int} indexA
 * @param {Fixture} fB
 * @param {int} indexB
 * @param {Contact~evaluate} evaluateFcn
 */ Contact.prototype.init = function(fA, indexA, fB, indexB, evaluateFcn) {
                    this.m_fixtureA = fA;
                    this.m_fixtureB = fB;
                    this.m_indexA = indexA;
                    this.m_indexB = indexB;
                    this.m_evaluateFcn = evaluateFcn;
                    this.m_manifold.init();
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_toi = 1;
                    this.m_toiCount = 0;
                    // This contact has a valid TOI in m_toi
                    this.m_toiFlag = false;
                    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
                    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
                    this.m_tangentSpeed = 0;
                    // This contact can be disabled (by user)
                    this.m_enabledFlag = true;
                    // Used when crawling contact graph when forming islands.
                    this.m_islandFlag = false;
                    // Set when the shapes are touching.
                    this.m_touchingFlag = false;
                    // This contact needs filtering because a fixture filter was changed.
                    this.m_filterFlag = false;
                    // This bullet contact had a TOI event
                    this.m_bulletHitFlag = false;
                    this.v_points.length = 0;
                    this.v_normal.setZero();
                    this.v_normalMass.setZero();
                    this.v_K.setZero();
                    this.v_pointCount = null;
                    this.v_tangentSpeed = null;
                    this.v_friction = null;
                    this.v_restitution = null;
                    this.v_invMassA = null;
                    this.v_invMassB = null;
                    this.v_invIA = null;
                    this.v_invIB = null;
                    this.p_localPoints.length = 0;
                    this.p_localNormal.setZero();
                    this.p_localPoint.setZero();
                    this.p_localCenterA.setZero();
                    this.p_localCenterB.setZero();
                    this.p_type = null;
                    // Manifold.Type
                    this.p_radiusA = null;
                    this.p_radiusB = null;
                    this.p_pointCount = null;
                    this.p_invMassA = null;
                    this.p_invMassB = null;
                    this.p_invIA = null;
                    this.p_invIB = null;
                };
                Contact.prototype.initConstraint = function(step) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var shapeA = fixtureA.getShape();
                    var shapeB = fixtureB.getShape();
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var manifold = this.m_manifold;
                    var pointCount = manifold.pointCount;
                    _ASSERT && common1.assert(pointCount > 0);
                    this.v_invMassA = bodyA.m_invMass;
                    this.v_invMassB = bodyB.m_invMass;
                    this.v_invIA = bodyA.m_invI;
                    this.v_invIB = bodyB.m_invI;
                    this.v_friction = this.m_friction;
                    this.v_restitution = this.m_restitution;
                    this.v_tangentSpeed = this.m_tangentSpeed;
                    this.v_pointCount = pointCount;
                    this.v_K.setZero();
                    this.v_normalMass.setZero();
                    this.p_invMassA = bodyA.m_invMass;
                    this.p_invMassB = bodyB.m_invMass;
                    this.p_invIA = bodyA.m_invI;
                    this.p_invIB = bodyB.m_invI;
                    this.p_localCenterA.setVec2(bodyA.m_sweep.localCenter);
                    this.p_localCenterB.setVec2(bodyB.m_sweep.localCenter);
                    this.p_radiusA = shapeA.m_radius;
                    this.p_radiusB = shapeB.m_radius;
                    this.p_type = manifold.type;
                    this.p_localNormal.setVec2(manifold.localNormal);
                    this.p_localPoint.setVec2(manifold.localPoint);
                    this.p_pointCount = pointCount;
                    for(var j = 0; j < pointCount; ++j){
                        var cp = manifold.points[j];
                        // ManifoldPoint
                        var vcp = this.v_points[j] = this.v_points_cache[j].init();
                        if (step.warmStarting) {
                            vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
                            vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;
                        } else {
                            vcp.normalImpulse = 0;
                            vcp.tangentImpulse = 0;
                        }
                        vcp.rA.setZero();
                        vcp.rB.setZero();
                        vcp.normalMass = 0;
                        vcp.tangentMass = 0;
                        vcp.velocityBias = 0;
                        this.p_localPoints[j] = this.p_localPoints_cache[j].setVec2(cp.localPoint);
                    }
                };
                /**
 * Get the contact manifold. Do not modify the manifold unless you understand
 * the internals of the library.
 */ Contact.prototype.getManifold = function() {
                    return this.m_manifold;
                };
                /**
 * Get the world manifold.
 * 
 * @param {WorldManifold} [worldManifold]
 */ Contact.prototype.getWorldManifold = function(worldManifold) {
                    var bodyA = this.m_fixtureA.getBody();
                    var bodyB = this.m_fixtureB.getBody();
                    var shapeA = this.m_fixtureA.getShape();
                    var shapeB = this.m_fixtureB.getShape();
                    var manifold = this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
                    return manifold;
                };
                /**
 * Enable/disable this contact. This can be used inside the pre-solve contact
 * listener. The contact is only disabled for the current time step (or sub-step
 * in continuous collisions).
 */ Contact.prototype.setEnabled = function(flag) {
                    this.m_enabledFlag = !!flag;
                };
                /**
 * Has this contact been disabled?
 */ Contact.prototype.isEnabled = function() {
                    return this.m_enabledFlag;
                };
                /**
 * Is this contact touching?
 */ Contact.prototype.isTouching = function() {
                    return this.m_touchingFlag;
                };
                /**
 * Get the next contact in the world's contact list.
 */ Contact.prototype.getNext = function() {
                    return this.m_next;
                };
                /**
 * Get fixture A in this contact.
 */ Contact.prototype.getFixtureA = function() {
                    return this.m_fixtureA;
                };
                /**
 * Get fixture B in this contact.
 */ Contact.prototype.getFixtureB = function() {
                    return this.m_fixtureB;
                };
                /**
 * Get the child primitive index for fixture A.
 */ Contact.prototype.getChildIndexA = function() {
                    return this.m_indexA;
                };
                /**
 * Get the child primitive index for fixture B.
 */ Contact.prototype.getChildIndexB = function() {
                    return this.m_indexB;
                };
                /**
 * Flag this contact for filtering. Filtering will occur the next time step.
 */ Contact.prototype.flagForFiltering = function() {
                    this.m_filterFlag = true;
                };
                /**
 * Override the default friction mixture. You can call this in
 * ContactListener.preSolve. This value persists until set or reset.
 */ Contact.prototype.setFriction = function(friction) {
                    this.m_friction = friction;
                };
                /**
 * Get the friction.
 */ Contact.prototype.getFriction = function() {
                    return this.m_friction;
                };
                /**
 * Reset the friction mixture to the default value.
 */ Contact.prototype.resetFriction = function() {
                    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
                };
                /**
 * Override the default restitution mixture. You can call this in
 * ContactListener.preSolve. The value persists until you set or reset.
 */ Contact.prototype.setRestitution = function(restitution) {
                    this.m_restitution = restitution;
                };
                /**
 * Get the restitution.
 */ Contact.prototype.getRestitution = function() {
                    return this.m_restitution;
                };
                /**
 * Reset the restitution to the default value.
 */ Contact.prototype.resetRestitution = function() {
                    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
                };
                /**
 * Set the desired tangent speed for a conveyor belt behavior. In meters per
 * second.
 */ Contact.prototype.setTangentSpeed = function(speed) {
                    this.m_tangentSpeed = speed;
                };
                /**
 * Get the desired tangent speed. In meters per second.
 */ Contact.prototype.getTangentSpeed = function() {
                    return this.m_tangentSpeed;
                };
                /**
 * Called by Update method, and implemented by subclasses.
 */ Contact.prototype.evaluate = function(manifold, xfA, xfB) {
                    this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB, this.m_fixtureB, this.m_indexB);
                };
                var cup_manifold = new Manifold();
                /**
 * Updates the contact manifold and touching status.
 * 
 * Note: do not assume the fixture AABBs are overlapping or are valid.
 * 
 * @param {function} listener.beginContact
 * @param {function} listener.endContact
 * @param {function} listener.preSolve
 */ Contact.prototype.update = function(listener) {
                    // Re-enable this contact.
                    this.m_enabledFlag = true;
                    var touching = false;
                    var wasTouching = this.m_touchingFlag;
                    var sensorA = this.m_fixtureA.isSensor();
                    var sensorB = this.m_fixtureB.isSensor();
                    var sensor = sensorA || sensorB;
                    var bodyA = this.m_fixtureA.getBody();
                    var bodyB = this.m_fixtureB.getBody();
                    var xfA = bodyA.getTransform();
                    var xfB = bodyB.getTransform();
                    // Is this contact a sensor?
                    if (sensor) {
                        var shapeA = this.m_fixtureA.getShape();
                        var shapeB = this.m_fixtureB.getShape();
                        touching = Distance.testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
                        // Sensors don't generate manifolds.
                        this.m_manifold.pointCount = 0;
                    } else {
                        var oldManifold = this.m_manifold;
                        this.m_manifold = cup_manifold.init();
                        cup_manifold = oldManifold;
                        this.evaluate(this.m_manifold, xfA, xfB);
                        touching = this.m_manifold.pointCount > 0;
                        for(var i = 0; i < this.m_manifold.pointCount; ++i){
                            var nmp = this.m_manifold.points[i];
                            nmp.normalImpulse = 0;
                            nmp.tangentImpulse = 0;
                            // Match old contact ids to new contact ids and copy the
                            // stored impulses to warm start the solver.
                            for(var j = 0; j < oldManifold.pointCount; ++j){
                                var omp = oldManifold.points[j];
                                if (omp.id.key == nmp.id.key) {
                                    // ContactID.key
                                    nmp.normalImpulse = omp.normalImpulse;
                                    nmp.tangentImpulse = omp.tangentImpulse;
                                    break;
                                }
                            }
                        }
                        if (touching !== wasTouching) {
                            bodyA.setAwake(true);
                            bodyB.setAwake(true);
                        }
                    }
                    this.m_touchingFlag = touching;
                    if (!wasTouching && touching && listener) {
                        listener.beginContact(this);
                    }
                    if (wasTouching && !touching && listener) {
                        listener.endContact(this);
                    }
                    if (!sensor && touching && listener) {
                        listener.preSolve(this, oldManifold);
                    }
                };
                Contact.prototype.solvePositionConstraint = function(step) {
                    return this._solvePositionConstraint(step, false);
                };
                Contact.prototype.solvePositionConstraintTOI = function(step, toiA, toiB) {
                    return this._solvePositionConstraint(step, true, toiA, toiB);
                };
                var spc_localCenterA = Vec2.zero();
                var spc_localCenterB = Vec2.zero();
                var spc_cA = Vec2.zero();
                var spc_cB = Vec2.zero();
                var spc_xfA = Transform.identity();
                var spc_xfB = Transform.identity();
                var spc_t1 = Vec2.zero();
                var spc_t2 = Vec2.zero();
                var spc_normal = Vec2.zero();
                var spc_point = Vec2.zero();
                var spc_pointA = Vec2.zero();
                var spc_pointB = Vec2.zero();
                var spc_planePoint = Vec2.zero();
                var spc_clipPoint = Vec2.zero();
                var spc_rA = Vec2.zero();
                var spc_rB = Vec2.zero();
                var spc_P = Vec2.zero();
                Contact.prototype._solvePositionConstraint = function(step, toi, toiA, toiB) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var velocityA = bodyA.c_velocity;
                    var velocityB = bodyB.c_velocity;
                    var positionA = bodyA.c_position;
                    var positionB = bodyB.c_position;
                    var localCenterA = spc_localCenterA.setVec2(this.p_localCenterA);
                    var localCenterB = spc_localCenterB.setVec2(this.p_localCenterB);
                    var mA = 0;
                    var iA = 0;
                    if (!toi || bodyA === toiA || bodyA === toiB) {
                        mA = this.p_invMassA;
                        iA = this.p_invIA;
                    }
                    var mB = 0;
                    var iB = 0;
                    if (!toi || bodyB === toiA || bodyB === toiB) {
                        mB = this.p_invMassB;
                        iB = this.p_invIB;
                    }
                    var cA = spc_cA.setVec2(positionA.c);
                    var aA = positionA.a;
                    var cB = spc_cB.setVec2(positionB.c);
                    var aB = positionB.a;
                    var minSeparation = 0;
                    // Solve normal constraints
                    for(var j = 0; j < this.p_pointCount; ++j){
                        var xfA = spc_xfA.setIdentity();
                        var xfB = spc_xfB.setIdentity();
                        xfA.q.set(aA);
                        xfB.q.set(aB);
                        xfA.p.setVec2(Vec2.sub_(cA, Rot.mulVec2_(xfA.q, localCenterA, spc_t1), spc_t2));
                        xfB.p.setVec2(Vec2.sub_(cB, Rot.mulVec2_(xfB.q, localCenterB, spc_t1), spc_t2));
                        // PositionSolverManifold
                        var normal, point, separation;
                        switch(this.p_type){
                            case Manifold.e_circles:
                                var pointA = Transform.mulVec2_(xfA, this.p_localPoint, spc_pointA);
                                var pointB = Transform.mulVec2_(xfB, this.p_localPoints[0], spc_pointB);
                                normal = Vec2.sub_(pointB, pointA, spc_normal);
                                normal.normalize();
                                point = Vec2.combine_(.5, pointA, .5, pointB, spc_point);
                                separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;
                                break;
                            case Manifold.e_faceA:
                                normal = Rot.mulVec2_(xfA.q, this.p_localNormal, spc_normal);
                                var planePoint = Transform.mulVec2_(xfA, this.p_localPoint, spc_planePoint);
                                var clipPoint = Transform.mulVec2_(xfB, this.p_localPoints[j], spc_clipPoint);
                                separation = Vec2.dot(Vec2.sub_(clipPoint, planePoint, spc_t1), normal) - this.p_radiusA - this.p_radiusB;
                                point = spc_point.setVec2(clipPoint);
                                break;
                            case Manifold.e_faceB:
                                normal = Rot.mulVec2_(xfB.q, this.p_localNormal, spc_normal);
                                var planePoint = Transform.mulVec2_(xfB, this.p_localPoint, spc_planePoint);
                                var clipPoint = Transform.mulVec2_(xfA, this.p_localPoints[j], spc_clipPoint);
                                separation = Vec2.dot(Vec2.sub_(clipPoint, planePoint, spc_t1), normal) - this.p_radiusA - this.p_radiusB;
                                point = spc_point.setVec2(clipPoint);
                                // Ensure normal points from A to B
                                normal.mul(-1);
                                break;
                        }
                        var rA = Vec2.sub_(point, cA, spc_rA);
                        var rB = Vec2.sub_(point, cB, spc_rB);
                        // Track max constraint error.
                        minSeparation = Math1.min(minSeparation, separation);
                        var baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;
                        var linearSlop = Settings.linearSlop;
                        var maxLinearCorrection = Settings.maxLinearCorrection;
                        // Prevent large corrections and allow slop.
                        var C = Math1.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0);
                        // Compute the effective mass.
                        var rnA = Vec2.crossVec2Vec2(rA, normal);
                        var rnB = Vec2.crossVec2Vec2(rB, normal);
                        var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                        // Compute normal impulse
                        var impulse = K > 0 ? -C / K : 0;
                        var P = Vec2.mulNumVec2_(impulse, normal, spc_P);
                        cA.subMul(mA, P);
                        aA -= iA * Vec2.crossVec2Vec2(rA, P);
                        cB.addMul(mB, P);
                        aB += iB * Vec2.crossVec2Vec2(rB, P);
                    }
                    positionA.c.setVec2(cA);
                    positionA.a = aA;
                    positionB.c.setVec2(cB);
                    positionB.a = aB;
                    return minSeparation;
                };
                function VelocityConstraintPoint() {
                    this.rA = Vec2.zero();
                    this.rB = Vec2.zero();
                    this.normalImpulse = 0;
                    this.tangentImpulse = 0;
                    this.normalMass = 0;
                    this.tangentMass = 0;
                    this.velocityBias = 0;
                }
                VelocityConstraintPoint.prototype.init = function() {
                    this.rA.setZero();
                    this.rB.setZero();
                    this.normalImpulse = 0;
                    this.tangentImpulse = 0;
                    this.normalMass = 0;
                    this.tangentMass = 0;
                    this.velocityBias = 0;
                    return this;
                };
                var ivc_localCenterA = Vec2.zero();
                var ivc_localCenterB = Vec2.zero();
                var ivc_normal = Vec2.zero();
                var ivc_cA = Vec2.zero();
                var ivc_cB = Vec2.zero();
                var ivc_vA = Vec2.zero();
                var ivc_vB = Vec2.zero();
                var ivc_t1 = Vec2.zero();
                var ivc_t2 = Vec2.zero();
                var ivc_xfA = Transform.identity();
                var ivc_xfB = Transform.identity();
                Contact.prototype.initVelocityConstraint = function(step) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var velocityA = bodyA.c_velocity;
                    var velocityB = bodyB.c_velocity;
                    var positionA = bodyA.c_position;
                    var positionB = bodyB.c_position;
                    var radiusA = this.p_radiusA;
                    var radiusB = this.p_radiusB;
                    var manifold = this.m_manifold;
                    var mA = this.v_invMassA;
                    var mB = this.v_invMassB;
                    var iA = this.v_invIA;
                    var iB = this.v_invIB;
                    var localCenterA = ivc_localCenterA.setVec2(this.p_localCenterA);
                    var localCenterB = ivc_localCenterB.setVec2(this.p_localCenterB);
                    var cA = ivc_cA.setVec2(positionA.c);
                    var aA = positionA.a;
                    var vA = ivc_vA.setVec2(velocityA.v);
                    var wA = velocityA.w;
                    var cB = ivc_cB.set(positionB.c);
                    var aB = positionB.a;
                    var vB = ivc_vB.set(velocityB.v);
                    var wB = velocityB.w;
                    _ASSERT && common1.assert(manifold.pointCount > 0);
                    var xfA = ivc_xfA.setIdentity();
                    var xfB = ivc_xfB.setIdentity();
                    xfA.q.set(aA);
                    xfB.q.set(aB);
                    xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));
                    xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));
                    var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);
                    this.v_normal.set(worldManifold.normal);
                    for(var j = 0; j < this.v_pointCount; ++j){
                        var vcp = this.v_points[j];
                        // VelocityConstraintPoint
                        vcp.rA.setCombine(1, worldManifold.points[j], -1, cA);
                        vcp.rB.setCombine(1, worldManifold.points[j], -1, cB);
                        var rnA = Vec2.crossVec2Vec2(vcp.rA, this.v_normal);
                        var rnB = Vec2.crossVec2Vec2(vcp.rB, this.v_normal);
                        var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                        vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
                        var tangent = Vec2.crossVec2Num_(this.v_normal, 1, ivc_normal);
                        var rtA = Vec2.crossVec2Vec2(vcp.rA, tangent);
                        var rtB = Vec2.crossVec2Vec2(vcp.rB, tangent);
                        var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                        vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
                        // Setup a velocity bias for restitution.
                        vcp.velocityBias = 0;
                        var vRel = Vec2.dot(this.v_normal, vB) + Vec2.dot(this.v_normal, Vec2.crossNumVec2_(wB, vcp.rB, ivc_t1)) - Vec2.dot(this.v_normal, vA) - Vec2.dot(this.v_normal, Vec2.crossNumVec2_(wA, vcp.rA, ivc_t2));
                        if (vRel < -Settings.velocityThreshold) {
                            vcp.velocityBias = -this.v_restitution * vRel;
                        }
                    }
                    // If we have two points, then prepare the block solver.
                    if (this.v_pointCount === 2 && step.blockSolve) {
                        var vcp1 = this.v_points[0];
                        // VelocityConstraintPoint
                        var vcp2 = this.v_points[1];
                        // VelocityConstraintPoint
                        var rn1A = Vec2.crossVec2Vec2(vcp1.rA, this.v_normal);
                        var rn1B = Vec2.crossVec2Vec2(vcp1.rB, this.v_normal);
                        var rn2A = Vec2.crossVec2Vec2(vcp2.rA, this.v_normal);
                        var rn2B = Vec2.crossVec2Vec2(vcp2.rB, this.v_normal);
                        var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                        var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                        var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                        // Ensure a reasonable condition number.
                        var k_maxConditionNumber = 1e3;
                        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                            // K is safe to invert.
                            this.v_K.ex.set(k11, k12);
                            this.v_K.ey.set(k12, k22);
                            this.v_normalMass.set(this.v_K.getInverse());
                        } else {
                            // The constraints are redundant, just use one.
                            // TODO_ERIN use deepest?
                            this.v_pointCount = 1;
                        }
                    }
                    positionA.c.set(cA);
                    positionA.a = aA;
                    velocityA.v.set(vA);
                    velocityA.w = wA;
                    positionB.c.set(cB);
                    positionB.a = aB;
                    velocityB.v.set(vB);
                    velocityB.w = wB;
                };
                var wsc_vA = Vec2.zero();
                var wsc_vB = Vec2.zero();
                var wsc_normal = Vec2.zero();
                var wsc_P = Vec2.zero();
                Contact.prototype.warmStartConstraint = function(step) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var velocityA = bodyA.c_velocity;
                    var velocityB = bodyB.c_velocity;
                    var positionA = bodyA.c_position;
                    var positionB = bodyB.c_position;
                    var mA = this.v_invMassA;
                    var iA = this.v_invIA;
                    var mB = this.v_invMassB;
                    var iB = this.v_invIB;
                    var vA = wsc_vA.set(velocityA.v);
                    var wA = velocityA.w;
                    var vB = wsc_vB.set(velocityB.v);
                    var wB = velocityB.w;
                    var normal = this.v_normal;
                    var tangent = Vec2.crossVec2Num_(normal, 1, wsc_normal);
                    for(var j = 0; j < this.v_pointCount; ++j){
                        var vcp = this.v_points[j];
                        // VelocityConstraintPoint
                        var P = wsc_P.setCombine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);
                        wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);
                        vA.subMul(mA, P);
                        wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);
                        vB.addMul(mB, P);
                    }
                    velocityA.v.set(vA);
                    velocityA.w = wA;
                    velocityB.v.set(vB);
                    velocityB.w = wB;
                };
                Contact.prototype.storeConstraintImpulses = function(step) {
                    var manifold = this.m_manifold;
                    for(var j = 0; j < this.v_pointCount; ++j){
                        manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;
                        manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;
                    }
                };
                var svc_vA = Vec2.zero();
                var svc_vB = Vec2.zero();
                var svc_dv = Vec2.zero();
                var svc_P = Vec2.zero();
                var svc_tangent = Vec2.zero();
                var svc_a = Vec2.zero();
                var svc_b = Vec2.zero();
                var svc_d = Vec2.zero();
                var svc_x = Vec2.zero();
                var svc_dv1 = Vec2.zero();
                var svc_dv2 = Vec2.zero();
                var svc_P1 = Vec2.zero();
                var svc_P2 = Vec2.zero();
                var svc_t1 = Vec2.zero();
                var svc_t2 = Vec2.zero();
                Contact.prototype.solveVelocityConstraint = function(step) {
                    var bodyA = this.m_fixtureA.m_body;
                    var bodyB = this.m_fixtureB.m_body;
                    var velocityA = bodyA.c_velocity;
                    var positionA = bodyA.c_position;
                    var velocityB = bodyB.c_velocity;
                    var positionB = bodyB.c_position;
                    var mA = this.v_invMassA;
                    var iA = this.v_invIA;
                    var mB = this.v_invMassB;
                    var iB = this.v_invIB;
                    // var vA = svc_vA.setVec2(velocityA.v);
                    var vAX = velocityA.v.x;
                    var vAY = velocityA.v.y;
                    var wA = velocityA.w;
                    // var vB = svc_vB.setVec2(velocityB.v);
                    var vBX = velocityB.v.x;
                    var vBY = velocityB.v.y;
                    var wB = velocityB.w;
                    var normal = this.v_normal;
                    var tangent = Vec2.crossVec2Num_(normal, 1, svc_tangent);
                    var friction = this.v_friction;
                    _ASSERT && common1.assert(this.v_pointCount === 1 || this.v_pointCount === 2);
                    // Solve tangent constraints first because non-penetration is more important
                    // than friction.
                    for(var j = 0; j < this.v_pointCount; ++j){
                        var vcp = this.v_points[j];
                        // VelocityConstraintPoint
                        // Relative velocity at contact
                        // var dv = Vec2.zero();
                        var dvX = 0;
                        var dvY = 0;
                        // dv.addCombine(1, vB, 1, Vec2.cross(wB, vcp.rB));
                        dvX += vBX + -wB * vcp.rB.y;
                        dvY += vBY + wB * vcp.rB.x;
                        // dv.subCombine(1, vA, 1, Vec2.cross(wA, vcp.rA));
                        dvX -= vAX + -wA * vcp.rA.y;
                        dvY -= vAY + wA * vcp.rA.x;
                        // Compute tangent force
                        // var vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;
                        var vt = dvX * tangent.x + dvY * tangent.y - this.v_tangentSpeed;
                        var lambda = vcp.tangentMass * -vt;
                        // Clamp the accumulated force
                        var maxFriction = friction * vcp.normalImpulse;
                        var newImpulse = Math1.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
                        lambda = newImpulse - vcp.tangentImpulse;
                        vcp.tangentImpulse = newImpulse;
                        // Apply contact impulse
                        // var P = Vec2.mul(lambda, tangent);
                        var PX = lambda * tangent.x;
                        var PY = lambda * tangent.y;
                        // vA.subMul(mA, P);
                        vAX -= mA * PX;
                        vAX -= mA * PY;
                        // wA -= iA * Vec2.cross(vcp.rA, P);
                        wA -= iA * (vcp.rA.x * PY - vcp.rA.y * PX);
                        // vB.addMul(mB, P);
                        vBX += mB * PX;
                        vBY += mB * PY;
                        // wB += iB * Vec2.cross(vcp.rB, P);
                        wB += iB * (vcp.rB.x * PY - vcp.rB.y * PX);
                    }
                    // Solve normal constraints
                    if (this.v_pointCount === 1 || step.blockSolve === false) {
                        for(var i = 0; i < this.v_pointCount; ++i){
                            var vcp = this.v_points[i];
                            // VelocityConstraintPoint
                            // Relative velocity at contact
                            // var dv = Vec2.zero();
                            var dvX = 0;
                            var dvY = 0;
                            // dv.addCombine(1, vB, 1, Vec2.cross(wB, vcp.rB));
                            dvX += vBX + -wB * vcp.rB.y;
                            dvY += vBY + wB * vcp.rB.x;
                            // dv.subCombine(1, vA, 1, Vec2.cross(wA, vcp.rA));
                            dvX -= vAX + -wA * vcp.rA.y;
                            dvY -= vAY + wA * vcp.rA.x;
                            // Compute normal impulse
                            // var vn = Vec2.dot(dv, normal);
                            var vn = dvX * normal.x + dvY * normal.y;
                            var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
                            // Clamp the accumulated impulse
                            var newImpulse = Math1.max(vcp.normalImpulse + lambda, 0);
                            lambda = newImpulse - vcp.normalImpulse;
                            vcp.normalImpulse = newImpulse;
                            // Apply contact impulse
                            // var P = Vec2.mul(lambda, normal);
                            var PX = lambda * normal.x;
                            var PY = lambda * normal.y;
                            // vA.subMul(mA, P);
                            vAX -= mA * PX;
                            vAY -= mA * PY;
                            // wA -= iA * Vec2.cross(vcp.rA, P);
                            wA -= iA * (vcp.rA.x * PY - vcp.rA.y * PX);
                            // vB.addMul(mB, P);
                            vBX += mB * PX;
                            vBY += mB * PY;
                            // wB += iB * Vec2.cross(vcp.rB, P);
                            wB += iB * (vcp.rB.x * PY - vcp.rB.y * PX);
                        }
                    } else {
                        // Block solver developed in collaboration with Dirk Gregorius (back in
                        // 01/07 on Box2D_Lite).
                        // Build the mini LCP for this contact patch
                        //
                        // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =
                        // 1..2
                        //
                        // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
                        // b = vn0 - velocityBias
                        //
                        // The system is solved using the "Total enumeration method" (s. Murty).
                        // The complementary constraint vn_i * x_i
                        // implies that we must have in any solution either vn_i = 0 or x_i = 0.
                        // So for the 2D contact problem the cases
                        // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and
                        // vn1 = 0 need to be tested. The first valid
                        // solution that satisfies the problem is chosen.
                        // 
                        // In order to account of the accumulated impulse 'a' (because of the
                        // iterative nature of the solver which only requires
                        // that the accumulated impulse is clamped and not the incremental
                        // impulse) we change the impulse variable (x_i).
                        //
                        // Substitute:
                        // 
                        // x = a + d
                        // 
                        // a := old total impulse
                        // x := new total impulse
                        // d := incremental impulse
                        //
                        // For the current iteration we extend the formula for the incremental
                        // impulse
                        // to compute the new total impulse:
                        //
                        // vn = A * d + b
                        // = A * (x - a) + b
                        // = A * x + b - A * a
                        // = A * x + b'
                        // b' = b - A * a;
                        var vcp1 = this.v_points[0];
                        // VelocityConstraintPoint
                        var vcp2 = this.v_points[1];
                        // VelocityConstraintPoint
                        // var a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);
                        var aX = vcp1.normalImpulse;
                        var aY = vcp2.normalImpulse;
                        _ASSERT && common1.assert(aX >= 0 && aY >= 0);
                        // Relative velocity at contact
                        // var dv1 = svc_dv1.setZero().add(vB).add(Vec2.crossNumVec2_(wB, vcp1.rB, svc_t1)).sub(vA).sub(Vec2.crossNumVec2_(wA, vcp1.rA, svc_t2));
                        var dv1X = vBX + -wB * vcp1.rB.y - (vAX + -wA * vcp1.rA.y);
                        var dv1Y = vBY + wB * vcp1.rB.x - (vAY + wA * vcp1.rA.x);
                        // var dv2 = svc_dv2.setZero().add(vB).add(Vec2.crossNumVec2_(wB, vcp2.rB, svc_t1)).sub(vA).sub(Vec2.crossNumVec2_(wA, vcp2.rA, svc_t2));
                        var dv2X = vBX + -wB * vcp2.rB.y - (vAX + -wA * vcp2.rA.y);
                        var dv2Y = vBY + wB * vcp2.rB.x - (vAY + wA * vcp2.rA.x);
                        // Compute normal velocity
                        var vn1 = dv1X * normal.x + dv1Y * normal.y;
                        var vn2 = dv2X * normal.x + dv2Y * normal.y;
                        // var b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);
                        var bX = vn1 - vcp1.velocityBias;
                        var bY = vn2 - vcp2.velocityBias;
                        // Compute b'
                        // b.sub(Mat22.mulVec2(this.v_K, a));
                        bX -= this.v_K.ex.x * aX + this.v_K.ey.x * aY;
                        bY -= this.v_K.ex.y * aX + this.v_K.ey.y * aY;
                        var k_errorTol = .001;
                        // NOT_USED(k_errorTol);
                        for(;;){
                            //
                            // Case 1: vn = 0
                            //
                            // 0 = A * x + b'
                            //
                            // Solve for x:
                            //
                            // x = - inv(A) * b'
                            //
                            // var x = Mat22.mulVec2(this.v_normalMass, b).neg();
                            var xX = -(this.v_normalMass.ex.x * bX + this.v_normalMass.ey.x * bY);
                            var xY = -(this.v_normalMass.ex.y * bX + this.v_normalMass.ey.y * bY);
                            if (xX >= 0 && xY >= 0) {
                                // Get the incremental impulse
                                var dX = xX - aX;
                                var dY = xY - aY;
                                // Apply incremental impulse
                                // var P1 = Vec2.mul(d.x, normal);
                                var P1X = dX * normal.x;
                                var P1Y = dX * normal.y;
                                // var P2 = Vec2.mul(d.y, normal);
                                var P2X = dY * normal.x;
                                var P2Y = dY * normal.y;
                                // vA.subCombine(mA, P1, mA, P2);
                                vAX -= mA * P1X + mA * P2X;
                                vAY -= mA * P1Y + mA * P2Y;
                                // wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                wA -= iA * (vcp1.rA.x * P1Y - vcp1.rA.y * P1X + vcp2.rA.x * P2Y - vcp2.rA.y * P2X);
                                // vB.addCombine(mB, P1, mB, P2);
                                vBX += mB * P1X + mB * P2X;
                                vBY += mB * P1Y + mB * P2Y;
                                // wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                wB += iB * (vcp1.rB.x * P1Y - vcp1.rB.y * P1X + vcp2.rB.x * P2Y - vcp2.rB.y * P2X);
                                // Accumulate
                                vcp1.normalImpulse = xX;
                                vcp2.normalImpulse = xY;
                                if (DEBUG_SOLVER) {
                                    // // Postconditions
                                    // dv1 = vB + Vec2.cross(wB, vcp1.rB) - vA - Vec2.cross(wA, vcp1.rA);
                                    // dv2 = vB + Vec2.cross(wB, vcp2.rB) - vA - Vec2.cross(wA, vcp2.rA);
                                    //
                                    // // Compute normal velocity
                                    // vn1 = Vec2.dot(dv1, normal);
                                    // vn2 = Vec2.dot(dv2, normal);
                                    //
                                    _ASSERT && common1.assert(Math1.abs(vn1 - vcp1.velocityBias) < k_errorTol);
                                    _ASSERT && common1.assert(Math1.abs(vn2 - vcp2.velocityBias) < k_errorTol);
                                }
                                break;
                            }
                            //
                            // Case 2: vn1 = 0 and x2 = 0
                            //
                            // 0 = a11 * x1 + a12 * 0 + b1'
                            // vn2 = a21 * x1 + a22 * 0 + b2'
                            //
                            xX = -vcp1.normalMass * bX;
                            xY = 0;
                            vn1 = 0;
                            vn2 = this.v_K.ex.y * xX + bY;
                            if (xX >= 0 && vn2 >= 0) {
                                // Get the incremental impulse
                                var dX = xX - aX;
                                var dY = xY - aY;
                                // Apply incremental impulse
                                // var P1 = Vec2.mul(d.x, normal);
                                var P1X = dX * normal.x;
                                var P1Y = dX * normal.y;
                                // var P2 = Vec2.mul(d.y, normal);
                                var P2X = dY * normal.x;
                                var P2Y = dY * normal.y;
                                // vA.subCombine(mA, P1, mA, P2);
                                vAX -= mA * P1X + mA * P2X;
                                vAY -= mA * P1Y + mA * P2Y;
                                // wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                wA -= iA * (vcp1.rA.x * P1Y - vcp1.rA.y * P1X + vcp2.rA.x * P2Y - vcp2.rA.y * P2X);
                                // vB.addCombine(mB, P1, mB, P2);
                                vBX += mB * P1X + mB * P2X;
                                vBY += mB * P1Y + mB * P2Y;
                                // wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                wB += iB * (vcp1.rB.x * P1Y - vcp1.rB.y * P1X + vcp2.rB.x * P2Y - vcp2.rB.y * P2X);
                                // Accumulate
                                vcp1.normalImpulse = xX;
                                vcp2.normalImpulse = xY;
                                if (DEBUG_SOLVER) {
                                    // // Postconditions
                                    // var dv1B = Vec2.add(vB, Vec2.cross(wB, vcp1.rB));
                                    // var dv1A = Vec2.add(vA, Vec2.cross(wA, vcp1.rA));
                                    // // var dv1 = Vec2.sub(dv1B, dv1A);
                                    // var dv1X = dv1B.x - dv1A.x;
                                    // var dv1Y = dv1B.y - dv1A.y;
                                    //
                                    // // Compute normal velocity
                                    // // vn1 = Vec2.dot(dv1, normal);
                                    // vn1 = dv1X * normal.x + dv1Y * normal.y;
                                    //
                                    _ASSERT && common1.assert(Math1.abs(vn1 - vcp1.velocityBias) < k_errorTol);
                                }
                                break;
                            }
                            //
                            // Case 3: vn2 = 0 and x1 = 0
                            //
                            // vn1 = a11 * 0 + a12 * x2 + b1'
                            // 0 = a21 * 0 + a22 * x2 + b2'
                            //
                            xX = 0;
                            xY = -vcp2.normalMass * bY;
                            vn1 = this.v_K.ey.x * xY + bX;
                            vn2 = 0;
                            if (xY >= 0 && vn1 >= 0) {
                                // Resubstitute for the incremental impulse
                                // var d = Vec2.sub(x, a);
                                var dX = xX - aX;
                                var dY = xY - aY;
                                // Apply incremental impulse
                                // var P1 = Vec2.mul(d.x, normal);
                                var P1X = dX * normal.x;
                                var P1Y = dX * normal.y;
                                // var P2 = Vec2.mul(d.y, normal);
                                var P2X = dY * normal.x;
                                var P2Y = dY * normal.y;
                                // vA.subCombine(mA, P1, mA, P2);
                                vAX -= mA * P1X + mA * P2X;
                                vAY -= mA * P1Y + mA * P2Y;
                                // wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                wA -= iA * (vcp1.rA.x * P1Y - vcp1.rA.y * P1X + vcp2.rA.x * P2Y - vcp2.rA.y * P2X);
                                // vB.addCombine(mB, P1, mB, P2);
                                vBX += mB * P1X + mB * P2X;
                                vBY += mB * P1Y + mB * P2Y;
                                // wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                wB += iB * (vcp1.rB.x * P1Y - vcp1.rB.y * P1X + vcp2.rB.x * P2Y - vcp2.rB.y * P2X);
                                // Accumulate
                                vcp1.normalImpulse = xX;
                                vcp2.normalImpulse = xY;
                                if (DEBUG_SOLVER) {
                                    // // Postconditions
                                    // var dv2B = Vec2.add(vB, Vec2.cross(wB, vcp2.rB));
                                    // var dv2A = Vec2.add(vA, Vec2.cross(wA, vcp2.rA));
                                    // var dv1 = Vec2.sub(dv2B, dv2A);
                                    //
                                    // // Compute normal velocity
                                    // vn2 = Vec2.dot(dv2, normal);
                                    //
                                    _ASSERT && common1.assert(Math1.abs(vn2 - vcp2.velocityBias) < k_errorTol);
                                }
                                break;
                            }
                            //
                            // Case 4: x1 = 0 and x2 = 0
                            // 
                            // vn1 = b1
                            // vn2 = b2;
                            //
                            xX = 0;
                            xY = 0;
                            vn1 = bX;
                            vn2 = bY;
                            if (vn1 >= 0 && vn2 >= 0) {
                                // Resubstitute for the incremental impulse
                                // var d = Vec2.sub(x, a);
                                var dX = xX - aX;
                                var dY = xY - aY;
                                // Apply incremental impulse
                                // var P1 = Vec2.mul(d.x, normal);
                                var P1X = dX * normal.x;
                                var P1Y = dX * normal.y;
                                // var P2 = Vec2.mul(d.y, normal);
                                var P2X = dY * normal.x;
                                var P2Y = dY * normal.y;
                                // vA.subCombine(mA, P1, mA, P2);
                                vAX -= mA * P1X + mA * P2X;
                                vAY -= mA * P1Y + mA * P2Y;
                                // wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                wA -= iA * (vcp1.rA.x * P1Y - vcp1.rA.y * P1X + vcp2.rA.x * P2Y - vcp2.rA.y * P2X);
                                // vB.addCombine(mB, P1, mB, P2);
                                vBX += mB * P1X + mB * P2X;
                                vBY += mB * P1Y + mB * P2Y;
                                // wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                wB += iB * (vcp1.rB.x * P1Y - vcp1.rB.y * P1X + vcp2.rB.x * P2Y - vcp2.rB.y * P2X);
                                // Accumulate
                                vcp1.normalImpulse = xX;
                                vcp2.normalImpulse = xY;
                                break;
                            }
                            break;
                        }
                    }
                    // velocityA.v.set(vA);
                    velocityA.v.x = vAX;
                    velocityA.v.y = vAY;
                    velocityA.w = wA;
                    // velocityB.v.set(vB);
                    velocityB.v.x = vBX;
                    velocityB.v.y = vBY;
                    velocityB.w = wB;
                };
                /**
 * Friction mixing law. The idea is to allow either fixture to drive the
 * restitution to zero. For example, anything slides on ice.
 */ function mixFriction(friction1, friction2) {
                    return Math1.sqrt(friction1 * friction2);
                }
                /**
 * Restitution mixing law. The idea is allow for anything to bounce off an
 * inelastic surface. For example, a superball bounces on anything.
 */ function mixRestitution(restitution1, restitution2) {
                    return restitution1 > restitution2 ? restitution1 : restitution2;
                }
                var s_registers = [];
                var contactPool = new Pool({
                    create: function() {
                        return new Contact();
                    }
                });
                /**
 * @param fn function(fixtureA, indexA, fixtureB, indexB) Contact
 */ Contact.addType = function(type1, type2, callback) {
                    s_registers[type1] = s_registers[type1] || {};
                    s_registers[type1][type2] = callback;
                };
                Contact.create = function(fixtureA, indexA, fixtureB, indexB) {
                    var typeA = fixtureA.getType();
                    // Shape.Type
                    var typeB = fixtureB.getType();
                    // Shape.Type
                    // TODO: pool contacts
                    var contact, evaluateFcn;
                    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {
                        contact = contactPool.allocate();
                        contact.init(fixtureA, indexA, fixtureB, indexB, evaluateFcn);
                    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {
                        contact = contactPool.allocate();
                        contact.init(fixtureB, indexB, fixtureA, indexA, evaluateFcn);
                    } else {
                        return null;
                    }
                    // Contact creation may swap fixtures.
                    fixtureA = contact.getFixtureA();
                    fixtureB = contact.getFixtureB();
                    indexA = contact.getChildIndexA();
                    indexB = contact.getChildIndexB();
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    // Connect to body A
                    contact.m_nodeA.contact = contact;
                    contact.m_nodeA.other = bodyB;
                    contact.m_nodeA.prev = null;
                    contact.m_nodeA.next = bodyA.m_contactList;
                    if (bodyA.m_contactList != null) {
                        bodyA.m_contactList.prev = contact.m_nodeA;
                    }
                    bodyA.m_contactList = contact.m_nodeA;
                    // Connect to body B
                    contact.m_nodeB.contact = contact;
                    contact.m_nodeB.other = bodyA;
                    contact.m_nodeB.prev = null;
                    contact.m_nodeB.next = bodyB.m_contactList;
                    if (bodyB.m_contactList != null) {
                        bodyB.m_contactList.prev = contact.m_nodeB;
                    }
                    bodyB.m_contactList = contact.m_nodeB;
                    // Wake up the bodies
                    if (!fixtureA.isSensor() && !fixtureB.isSensor()) {
                        bodyA.setAwake(true);
                        bodyB.setAwake(true);
                    }
                    return contact;
                };
                Contact.destroy = function(contact, listener) {
                    var fixtureA = contact.m_fixtureA;
                    var fixtureB = contact.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    if (contact.isTouching()) {
                        listener.endContact(contact);
                    }
                    // Remove from body 1
                    if (contact.m_nodeA.prev) {
                        contact.m_nodeA.prev.next = contact.m_nodeA.next;
                    }
                    if (contact.m_nodeA.next) {
                        contact.m_nodeA.next.prev = contact.m_nodeA.prev;
                    }
                    if (contact.m_nodeA === bodyA.m_contactList) {
                        bodyA.m_contactList = contact.m_nodeA.next;
                    }
                    // Remove from body 2
                    if (contact.m_nodeB.prev) {
                        contact.m_nodeB.prev.next = contact.m_nodeB.next;
                    }
                    if (contact.m_nodeB.next) {
                        contact.m_nodeB.next.prev = contact.m_nodeB.prev;
                    }
                    if (contact.m_nodeB === bodyB.m_contactList) {
                        bodyB.m_contactList = contact.m_nodeB.next;
                    }
                    if (contact.m_manifold.pointCount > 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {
                        bodyA.setAwake(true);
                        bodyB.setAwake(true);
                    }
                    var typeA = fixtureA.getType();
                    // Shape.Type
                    var typeB = fixtureB.getType();
                    // Shape.Type
                    var destroyFcn = s_registers[typeA][typeB].destroyFcn;
                    if (typeof destroyFcn === "function") {
                        destroyFcn(contact);
                    }
                    contactPool.release(contact);
                };
            },
            {
                "./Manifold": 6,
                "./Settings": 7,
                "./collision/Distance": 13,
                "./common/Mat22": 16,
                "./common/Math": 18,
                "./common/Rot": 20,
                "./common/Transform": 22,
                "./common/Vec2": 23,
                "./util/Pool": 48,
                "./util/common": 50
            }
        ],
        4: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Fixture;
                var common1 = require1("./util/common");
                var options = require1("./util/options");
                var Math1 = require1("./common/Math");
                var Vec2 = require1("./common/Vec2");
                var AABB = require1("./collision/AABB");
                /**
 * @typedef {Object} FixtureDef
 *
 * A fixture definition is used to create a fixture. This class defines an
 * abstract fixture definition. You can reuse fixture definitions safely.
 * 
 * @prop friction The friction coefficient, usually in the range [0,1]
 * @prop restitution The restitution (elasticity) usually in the range [0,1]
 * @prop density The density, usually in kg/m^2
 * @prop isSensor A sensor shape collects contact information but never
 *       generates a collision response
 * @prop userData
 * @prop filterGroupIndex Zero, positive or negative collision group. Fixtures with same positive groupIndex always collide and fixtures with same
 * negative groupIndex never collide.
 * @prop filterCategoryBits Collision category bit or bits that this fixture belongs
 *       to. If groupIndex is zero or not matching, then at least one bit in this fixture
 * categoryBits should match other fixture maskBits and vice versa.
 * @prop filterMaskBits Collision category bit or bits that this fixture accept for
 *       collision.
 */ var FixtureDef = {
                    userData: null,
                    friction: .2,
                    restitution: 0,
                    density: 0,
                    isSensor: false,
                    filterGroupIndex: 0,
                    filterCategoryBits: 1,
                    filterMaskBits: 65535
                };
                /**
 * This proxy is used internally to connect shape children to the broad-phase.
 */ function FixtureProxy(fixture, childIndex) {
                    this.aabb = new AABB();
                    this.fixture = fixture;
                    this.childIndex = childIndex;
                    this.proxyId;
                }
                /**
 * A fixture is used to attach a shape to a body for collision detection. A
 * fixture inherits its transform from its parent. Fixtures hold additional
 * non-geometric data such as friction, collision filters, etc. Fixtures are
 * created via Body.createFixture.
 * 
 * @param {Shape|FixtureDef} shape Shape of fixture definition.
 * @param {FixtureDef|number} def Fixture definition or number.
 */ function Fixture(body, shape, def) {
                    if (shape.shape) {
                        def = shape;
                        shape = shape.shape;
                    } else if (typeof def === "number") {
                        def = {
                            density: def
                        };
                    }
                    def = options(def, FixtureDef);
                    this.m_body = body;
                    this.m_friction = def.friction;
                    this.m_restitution = def.restitution;
                    this.m_density = def.density;
                    this.m_isSensor = def.isSensor;
                    this.m_filterGroupIndex = def.filterGroupIndex;
                    this.m_filterCategoryBits = def.filterCategoryBits;
                    this.m_filterMaskBits = def.filterMaskBits;
                    // TODO validate shape
                    this.m_shape = shape;
                    //.clone();
                    this.m_next = null;
                    this.m_proxies = [];
                    this.m_proxyCount = 0;
                    var childCount = this.m_shape.getChildCount();
                    for(var i = 0; i < childCount; ++i){
                        this.m_proxies[i] = new FixtureProxy(this, i);
                    }
                    this.m_userData = def.userData;
                }
                /**
 * Get the type of the child shape. You can use this to down cast to the
 * concrete shape.
 */ Fixture.prototype.getType = function() {
                    return this.m_shape.getType();
                };
                /**
 * Get the child shape. You can modify the child shape, however you should not
 * change the number of vertices because this will crash some collision caching
 * mechanisms. Manipulating the shape may lead to non-physical behavior.
 */ Fixture.prototype.getShape = function() {
                    return this.m_shape;
                };
                /**
 * A sensor shape collects contact information but never generates a collision
 * response.
 */ Fixture.prototype.isSensor = function() {
                    return this.m_isSensor;
                };
                /**
 * Set if this fixture is a sensor.
 */ Fixture.prototype.setSensor = function(sensor) {
                    if (sensor != this.m_isSensor) {
                        this.m_body.setAwake(true);
                        this.m_isSensor = sensor;
                    }
                };
                /**
 * Get the contact filtering data.
 */ // Fixture.prototype.getFilterData = function() {
                //   return this.m_filter;
                // }
                /**
 * Get the user data that was assigned in the fixture definition. Use this to
 * store your application specific data.
 */ Fixture.prototype.getUserData = function() {
                    return this.m_userData;
                };
                /**
 * Set the user data. Use this to store your application specific data.
 */ Fixture.prototype.setUserData = function(data) {
                    this.m_userData = data;
                };
                /**
 * Get the parent body of this fixture. This is null if the fixture is not
 * attached.
 */ Fixture.prototype.getBody = function() {
                    return this.m_body;
                };
                /**
 * Get the next fixture in the parent body's fixture list.
 */ Fixture.prototype.getNext = function() {
                    return this.m_next;
                };
                /**
 * Get the density of this fixture.
 */ Fixture.prototype.getDensity = function() {
                    return this.m_density;
                };
                /**
 * Set the density of this fixture. This will _not_ automatically adjust the
 * mass of the body. You must call Body.resetMassData to update the body's mass.
 */ Fixture.prototype.setDensity = function(density) {
                    _ASSERT && common1.assert(Math1.isFinite(density) && density >= 0);
                    this.m_density = density;
                };
                /**
 * Get the coefficient of friction, usually in the range [0,1].
 */ Fixture.prototype.getFriction = function() {
                    return this.m_friction;
                };
                /**
 * Set the coefficient of friction. This will not change the friction of
 * existing contacts.
 */ Fixture.prototype.setFriction = function(friction) {
                    this.m_friction = friction;
                };
                /**
 * Get the coefficient of restitution.
 */ Fixture.prototype.getRestitution = function() {
                    return this.m_restitution;
                };
                /**
 * Set the coefficient of restitution. This will not change the restitution of
 * existing contacts.
 */ Fixture.prototype.setRestitution = function(restitution) {
                    this.m_restitution = restitution;
                };
                /**
 * Test a point in world coordinates for containment in this fixture.
 */ Fixture.prototype.testPoint = function(p) {
                    return this.m_shape.testPoint(this.m_body.getTransform(), p);
                };
                /**
 * Cast a ray against this shape.
 */ Fixture.prototype.rayCast = function(output, input, childIndex) {
                    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);
                };
                /**
 * Get the mass data for this fixture. The mass data is based on the density and
 * the shape. The rotational inertia is about the shape's origin. This operation
 * may be expensive.
 */ Fixture.prototype.getMassData = function(massData) {
                    this.m_shape.computeMass(massData, this.m_density);
                };
                /**
 * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a
 * more accurate AABB, compute it using the shape and the body transform.
 */ Fixture.prototype.getAABB = function(childIndex) {
                    _ASSERT && common1.assert(0 <= childIndex && childIndex < this.m_proxyCount);
                    return this.m_proxies[childIndex].aabb;
                };
                /**
 * These support body activation/deactivation.
 */ Fixture.prototype.createProxies = function(broadPhase, xf) {
                    _ASSERT && common1.assert(this.m_proxyCount == 0);
                    // Create proxies in the broad-phase.
                    this.m_proxyCount = this.m_shape.getChildCount();
                    for(var i = 0; i < this.m_proxyCount; ++i){
                        var proxy = this.m_proxies[i];
                        this.m_shape.computeAABB(proxy.aabb, xf, i);
                        proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
                    }
                };
                Fixture.prototype.destroyProxies = function(broadPhase) {
                    // Destroy proxies in the broad-phase.
                    for(var i = 0; i < this.m_proxyCount; ++i){
                        var proxy = this.m_proxies[i];
                        broadPhase.destroyProxy(proxy.proxyId);
                        proxy.proxyId = null;
                    }
                    this.m_proxyCount = 0;
                };
                /**
 * Updates this fixture proxy in broad-phase (with combined AABB of current and
 * next transformation).
 */ Fixture.prototype.synchronize = function(broadPhase, xf1, xf2) {
                    for(var i = 0; i < this.m_proxyCount; ++i){
                        var proxy = this.m_proxies[i];
                        // Compute an AABB that covers the swept shape (may miss some rotation
                        // effect).
                        var aabb1 = new AABB();
                        var aabb2 = new AABB();
                        this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);
                        this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);
                        proxy.aabb.combine(aabb1, aabb2);
                        var displacement = Vec2.sub(xf2.p, xf1.p);
                        broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
                    }
                };
                /**
 * Set the contact filtering data. This will not update contacts until the next
 * time step when either parent body is active and awake. This automatically
 * calls refilter.
 */ Fixture.prototype.setFilterData = function(filter) {
                    this.m_filterGroupIndex = filter.groupIndex;
                    this.m_filterCategoryBits = filter.categoryBits;
                    this.m_filterMaskBits = filter.maskBits;
                    this.refilter();
                };
                Fixture.prototype.getFilterGroupIndex = function() {
                    return this.m_filterGroupIndex;
                };
                Fixture.prototype.getFilterCategoryBits = function() {
                    return this.m_filterCategoryBits;
                };
                Fixture.prototype.getFilterMaskBits = function() {
                    return this.m_filterMaskBits;
                };
                /**
 * Call this if you want to establish collision that was previously disabled by
 * ContactFilter.
 */ Fixture.prototype.refilter = function() {
                    if (this.m_body == null) {
                        return;
                    }
                    // Flag associated contacts for filtering.
                    var edge = this.m_body.getContactList();
                    while(edge){
                        var contact = edge.contact;
                        var fixtureA = contact.getFixtureA();
                        var fixtureB = contact.getFixtureB();
                        if (fixtureA == this || fixtureB == this) {
                            contact.flagForFiltering();
                        }
                        edge = edge.next;
                    }
                    var world = this.m_body.getWorld();
                    if (world == null) {
                        return;
                    }
                    // Touch each proxy so that new pairs may be created
                    var broadPhase = world.m_broadPhase;
                    for(var i = 0; i < this.m_proxyCount; ++i){
                        broadPhase.touchProxy(this.m_proxies[i].proxyId);
                    }
                };
                /**
 * Implement this method to provide collision filtering, if you want finer
 * control over contact creation.
 * 
 * Return true if contact calculations should be performed between these two
 * fixtures.
 * 
 * Warning: for performance reasons this is only called when the AABBs begin to
 * overlap.
 * 
 * @param {Fixture} fixtureA
 * @param {Fixture} fixtureB
 */ Fixture.prototype.shouldCollide = function(that) {
                    if (that.m_filterGroupIndex == this.m_filterGroupIndex && that.m_filterGroupIndex != 0) {
                        return that.m_filterGroupIndex > 0;
                    }
                    var collide = (that.m_filterMaskBits & this.m_filterCategoryBits) != 0 && (that.m_filterCategoryBits & this.m_filterMaskBits) != 0;
                    return collide;
                };
            },
            {
                "./collision/AABB": 11,
                "./common/Math": 18,
                "./common/Vec2": 23,
                "./util/common": 50,
                "./util/options": 52
            }
        ],
        5: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Joint;
                var common1 = require1("./util/common");
                /**
 * A joint edge is used to connect bodies and joints together in a joint graph
 * where each body is a node and each joint is an edge. A joint edge belongs to
 * a doubly linked list maintained in each attached body. Each joint has two
 * joint nodes, one for each attached body.
 * 
 * @prop {Body} other provides quick access to the other body attached.
 * @prop {Joint} joint the joint
 * @prop {JointEdge} prev the previous joint edge in the body's joint list
 * @prop {JointEdge} next the next joint edge in the body's joint list
 */ function JointEdge() {
                    this.other = null;
                    this.joint = null;
                    this.prev = null;
                    this.next = null;
                }
                /**
 * @typedef {Object} JointDef
 *
 * Joint definitions are used to construct joints.
 * 
 * @prop userData Use this to attach application specific data to your joints.
 *       void userData;
 * @prop {boolean} collideConnected Set this flag to true if the attached bodies
 *       should collide.
 *
 * @prop {Body} bodyA The first attached body.
 * @prop {Body} bodyB The second attached body.
 */ var DEFAULTS = {
                    userData: null,
                    collideConnected: false
                };
                /**
 * The base joint class. Joints are used to constraint two bodies together in
 * various fashions. Some joints also feature limits and motors.
 * 
 * @param {JointDef} def
 */ function Joint(def, bodyA, bodyB) {
                    bodyA = def.bodyA || bodyA;
                    bodyB = def.bodyB || bodyB;
                    _ASSERT && common1.assert(bodyA);
                    _ASSERT && common1.assert(bodyB);
                    _ASSERT && common1.assert(bodyA != bodyB);
                    this.m_type = "unknown-joint";
                    this.m_bodyA = bodyA;
                    this.m_bodyB = bodyB;
                    this.m_index = 0;
                    this.m_collideConnected = !!def.collideConnected;
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_edgeA = new JointEdge();
                    this.m_edgeB = new JointEdge();
                    this.m_islandFlag = false;
                    this.m_userData = def.userData;
                }
                /**
 * Short-cut function to determine if either body is inactive.
 * 
 * @returns {boolean}
 */ Joint.prototype.isActive = function() {
                    return this.m_bodyA.isActive() && this.m_bodyB.isActive();
                };
                /**
 * Get the type of the concrete joint.
 * 
 * @returns JointType
 */ Joint.prototype.getType = function() {
                    return this.m_type;
                };
                /**
 * Get the first body attached to this joint.
 * 
 * @returns Body
 */ Joint.prototype.getBodyA = function() {
                    return this.m_bodyA;
                };
                /**
 * Get the second body attached to this joint.
 * 
 * @returns Body
 */ Joint.prototype.getBodyB = function() {
                    return this.m_bodyB;
                };
                /**
 * Get the next joint the world joint list.
 * 
 * @returns Joint
 */ Joint.prototype.getNext = function() {
                    return this.m_next;
                };
                Joint.prototype.getUserData = function() {
                    return this.m_userData;
                };
                Joint.prototype.setUserData = function(data) {
                    this.m_userData = data;
                };
                /**
 * Get collide connected. Note: modifying the collide connect flag won't work
 * correctly because the flag is only checked when fixture AABBs begin to
 * overlap.
 * 
 * @returns {boolean}
 */ Joint.prototype.getCollideConnected = function() {
                    return this.m_collideConnected;
                };
                /**
 * Get the anchor point on bodyA in world coordinates.
 * 
 * @return {Vec2}
 */ Joint.prototype.getAnchorA = function() {};
                /**
 * Get the anchor point on bodyB in world coordinates.
 * 
 * @return {Vec2}
 */ Joint.prototype.getAnchorB = function() {};
                /**
 * Get the reaction force on bodyB at the joint anchor in Newtons.
 * 
 * @param {float} inv_dt
 * @return {Vec2}
 */ Joint.prototype.getReactionForce = function(inv_dt) {};
                /**
 * Get the reaction torque on bodyB in N*m.
 * 
 * @param {float} inv_dt
 * @return {float}
 */ Joint.prototype.getReactionTorque = function(inv_dt) {};
                /**
 * Shift the origin for any points stored in world coordinates.
 * 
 * @param {Vec2} newOrigin
 */ Joint.prototype.shiftOrigin = function(newOrigin) {};
                /**
 */ Joint.prototype.initVelocityConstraints = function(step) {};
                /**
 */ Joint.prototype.solveVelocityConstraints = function(step) {};
                /**
 * This returns true if the position errors are within tolerance.
 */ Joint.prototype.solvePositionConstraints = function(step) {};
            },
            {
                "./util/common": 50
            }
        ],
        6: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("./util/common");
                var Vec2 = require1("./common/Vec2");
                var Transform = require1("./common/Transform");
                var Math1 = require1("./common/Math");
                var Rot = require1("./common/Rot");
                module1.exports = Manifold;
                module1.exports.clipSegmentToLine = clipSegmentToLine;
                module1.exports.clipVertex = ClipVertex;
                module1.exports.getPointStates = getPointStates;
                module1.exports.PointState = PointState;
                // Manifold Type
                Manifold.e_circles = 0;
                Manifold.e_faceA = 1;
                Manifold.e_faceB = 2;
                // ContactFeature Type
                Manifold.e_vertex = 0;
                Manifold.e_face = 1;
                /**
 * A manifold for two touching convex shapes. Manifolds are created in `evaluate`
 * method of Contact subclasses.
 * 
 * Supported manifold types are e_faceA or e_faceB for clip point versus plane
 * with radius and e_circles point versus point with radius.
 * 
 * We store contacts in this way so that position correction can account for
 * movement, which is critical for continuous physics. All contact scenarios
 * must be expressed in one of these types. This structure is stored across time
 * steps, so we keep it small.
 * 
 * @prop type e_circle, e_faceA, e_faceB
 * @prop localPoint Usage depends on manifold type:<br>
 *       e_circles: the local center of circleA <br>
 *       e_faceA: the center of faceA <br>
 *       e_faceB: the center of faceB
 * @prop localNormal Usage depends on manifold type:<br>
 *       e_circles: not used <br>
 *       e_faceA: the normal on polygonA <br>
 *       e_faceB: the normal on polygonB
 * @prop points The points of contact {ManifoldPoint[]}
 * @prop pointCount The number of manifold points
 */ function Manifold() {
                    this.type = -1;
                    this.localNormal = Vec2.zero();
                    this.localPoint = Vec2.zero();
                    this.points = [
                        new ManifoldPoint(),
                        new ManifoldPoint()
                    ];
                    this.pointCount = 0;
                }
                Manifold.prototype.init = function() {
                    this.type = -1;
                    this.localNormal.setZero();
                    this.localPoint.setZero();
                    this.points[0].init();
                    this.points[1].init();
                    this.pointCount = 0;
                    return this;
                };
                /**
 * A manifold point is a contact point belonging to a contact manifold. It holds
 * details related to the geometry and dynamics of the contact points.
 * 
 * This structure is stored across time steps, so we keep it small.
 * 
 * Note: impulses are used for internal caching and may not provide reliable
 * contact forces, especially for high speed collisions.
 * 
 * @prop {Vec2} localPoint Usage depends on manifold type:<br>
 *       e_circles: the local center of circleB<br>
 *       e_faceA: the local center of cirlceB or the clip point of polygonB<br>
 *       e_faceB: the clip point of polygonA.
 * @prop normalImpulse The non-penetration impulse
 * @prop tangentImpulse The friction impulse
 * @prop {ContactID} id Uniquely identifies a contact point between two shapes
 *       to facilatate warm starting
 */ function ManifoldPoint() {
                    this.localPoint = Vec2.zero();
                    this.normalImpulse = 0;
                    this.tangentImpulse = 0;
                    this.id = new ContactID();
                }
                ManifoldPoint.prototype.init = function() {
                    this.localPoint.setZero();
                    this.normalImpulse = 0;
                    this.tangentImpulse = 0;
                    this.id.init();
                };
                /**
 * Contact ids to facilitate warm starting.
 * 
 * @prop {ContactFeature} cf
 * @prop key Used to quickly compare contact ids.
 * 
 */ function ContactID() {
                    this.cf = new ContactFeature();
                }
                ContactID.prototype.init = function() {
                    this.cf.init();
                };
                Object.defineProperty(ContactID.prototype, "key", {
                    get: function() {
                        return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;
                    },
                    enumerable: true,
                    configurable: true
                });
                ContactID.prototype.set = function(o) {
                    // this.key = o.key;
                    this.cf.set(o.cf);
                };
                /**
 * The features that intersect to form the contact point.
 * 
 * @prop indexA Feature index on shapeA
 * @prop indexB Feature index on shapeB
 * @prop typeA The feature type on shapeA
 * @prop typeB The feature type on shapeB
 */ function ContactFeature() {
                    this.indexA;
                    this.indexB;
                    this.typeA;
                    this.typeB;
                }
                ContactFeature.prototype.init = function() {
                    this.indexA = 0;
                    this.indexB = 0;
                    this.typeA = 0;
                    this.typeB = 0;
                };
                ContactFeature.prototype.set = function(o) {
                    this.indexA = o.indexA;
                    this.indexB = o.indexB;
                    this.typeA = o.typeA;
                    this.typeB = o.typeB;
                };
                /**
 * This is used to compute the current state of a contact manifold.
 * 
 * @prop normal World vector pointing from A to B
 * @prop points World contact point (point of intersection)
 * @prop separations A negative value indicates overlap, in meters
 */ function WorldManifold() {
                    this.normal;
                    this.points = [];
                    // [maxManifoldPoints]
                    this.separations = [];
                }
                /**
 * Evaluate the manifold with supplied transforms. This assumes modest motion
 * from the original state. This does not change the point count, impulses, etc.
 * The radii must come from the shapes that generated the manifold.
 * 
 * @param {WorldManifold} [wm]
 */ Manifold.prototype.getWorldManifold = function(wm, xfA, radiusA, xfB, radiusB) {
                    if (this.pointCount == 0) {
                        return;
                    }
                    wm = wm || new WorldManifold();
                    var normal = wm.normal;
                    var points = wm.points;
                    var separations = wm.separations;
                    // TODO: improve
                    switch(this.type){
                        case Manifold.e_circles:
                            normal = Vec2.neo(1, 0);
                            var pointA = Transform.mulVec2(xfA, this.localPoint);
                            var pointB = Transform.mulVec2(xfB, this.points[0].localPoint);
                            var dist = Vec2.sub(pointB, pointA);
                            if (Vec2.lengthSquared(dist) > Math1.EPSILON * Math1.EPSILON) {
                                normal.set(dist);
                                normal.normalize();
                            }
                            points[0] = Vec2.mid(pointA, pointB);
                            separations[0] = -radiusB - radiusA;
                            points.length = 1;
                            separations.length = 1;
                            break;
                        case Manifold.e_faceA:
                            normal = Rot.mulVec2(xfA.q, this.localNormal);
                            var planePoint = Transform.mulVec2(xfA, this.localPoint);
                            for(var i = 0; i < this.pointCount; ++i){
                                var clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);
                                var cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);
                                var cB = Vec2.clone(clipPoint).subMul(radiusB, normal);
                                points[i] = Vec2.mid(cA, cB);
                                separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);
                            }
                            points.length = this.pointCount;
                            separations.length = this.pointCount;
                            break;
                        case Manifold.e_faceB:
                            normal = Rot.mulVec2(xfB.q, this.localNormal);
                            var planePoint = Transform.mulVec2(xfB, this.localPoint);
                            for(var i = 0; i < this.pointCount; ++i){
                                var clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);
                                var cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);
                                var cA = Vec2.combine(1, clipPoint, -radiusA, normal);
                                points[i] = Vec2.mid(cA, cB);
                                separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);
                            }
                            points.length = this.pointCount;
                            separations.length = this.pointCount;
                            // Ensure normal points from A to B.
                            normal.mul(-1);
                            break;
                    }
                    wm.normal = normal;
                    wm.points = points;
                    wm.separations = separations;
                    return wm;
                };
                /**
 * This is used for determining the state of contact points.
 * 
 * @prop {0} nullState Point does not exist
 * @prop {1} addState Point was added in the update
 * @prop {2} persistState Point persisted across the update
 * @prop {3} removeState Point was removed in the update
 */ var PointState = {
                    // TODO: use constants
                    nullState: 0,
                    addState: 1,
                    persistState: 2,
                    removeState: 3
                };
                /**
 * Compute the point states given two manifolds. The states pertain to the
 * transition from manifold1 to manifold2. So state1 is either persist or remove
 * while state2 is either add or persist.
 * 
 * @param {PointState[Settings.maxManifoldPoints]} state1
 * @param {PointState[Settings.maxManifoldPoints]} state2
 */ function getPointStates(state1, state2, manifold1, manifold2) {
                    // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
                    // state1[i] = PointState.nullState;
                    // state2[i] = PointState.nullState;
                    // }
                    // Detect persists and removes.
                    for(var i = 0; i < manifold1.pointCount; ++i){
                        var id = manifold1.points[i].id;
                        // ContactID
                        state1[i] = PointState.removeState;
                        for(var j = 0; j < manifold2.pointCount; ++j){
                            if (manifold2.points[j].id.key == id.key) {
                                state1[i] = PointState.persistState;
                                break;
                            }
                        }
                    }
                    // Detect persists and adds.
                    for(var i = 0; i < manifold2.pointCount; ++i){
                        var id = manifold2.points[i].id;
                        // ContactID
                        state2[i] = PointState.addState;
                        for(var j = 0; j < manifold1.pointCount; ++j){
                            if (manifold1.points[j].id.key == id.key) {
                                state2[i] = PointState.persistState;
                                break;
                            }
                        }
                    }
                }
                /**
 * Used for computing contact manifolds.
 * 
 * @prop {Vec2} v
 * @prop {ContactID} id
 */ function ClipVertex() {
                    this.v = Vec2.zero();
                    this.id = new ContactID();
                }
                ClipVertex.prototype.set = function(o) {
                    this.v.set(o.v);
                    this.id.set(o.id);
                };
                ClipVertex.prototype.init = function() {
                    this.v.setZero();
                    this.id.init();
                };
                /**
 * Clipping for contact manifolds. Sutherland-Hodgman clipping.
 * 
 * @param {ClipVertex[2]} vOut
 * @param {ClipVertex[2]} vIn
 */ function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
                    // Start with no output points
                    var numOut = 0;
                    // Calculate the distance of end points to the line
                    var distance0 = Vec2.dot(normal, vIn[0].v) - offset;
                    var distance1 = Vec2.dot(normal, vIn[1].v) - offset;
                    // If the points are behind the plane
                    if (distance0 <= 0) vOut[numOut++].set(vIn[0]);
                    if (distance1 <= 0) vOut[numOut++].set(vIn[1]);
                    // If the points are on different sides of the plane
                    if (distance0 * distance1 < 0) {
                        // Find intersection point of edge and plane
                        var interp = distance0 / (distance0 - distance1);
                        vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);
                        // VertexA is hitting edgeB.
                        vOut[numOut].id.cf.indexA = vertexIndexA;
                        vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
                        vOut[numOut].id.cf.typeA = Manifold.e_vertex;
                        vOut[numOut].id.cf.typeB = Manifold.e_face;
                        ++numOut;
                    }
                    return numOut;
                }
            },
            {
                "./common/Math": 18,
                "./common/Rot": 20,
                "./common/Transform": 22,
                "./common/Vec2": 23,
                "./util/common": 50
            }
        ],
        7: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                // TODO merge with World options?
                var Settings = exports1;
                /**
 * Tuning constants based on meters-kilograms-seconds (MKS) units.
 */ // Collision
                /**
 * The maximum number of contact points between two convex shapes. Do not change
 * this value.
 */ Settings.maxManifoldPoints = 2;
                /**
 * The maximum number of vertices on a convex polygon. You cannot increase this
 * too much because BlockAllocator has a maximum object size.
 */ Settings.maxPolygonVertices = 12;
                /**
 * This is used to fatten AABBs in the dynamic tree. This allows proxies to move
 * by a small amount without triggering a tree adjustment. This is in meters.
 */ Settings.aabbExtension = .1;
                /**
 * This is used to fatten AABBs in the dynamic tree. This is used to predict the
 * future position based on the current displacement. This is a dimensionless
 * multiplier.
 */ Settings.aabbMultiplier = 2;
                /**
 * A small length used as a collision and constraint tolerance. Usually it is
 * chosen to be numerically significant, but visually insignificant.
 */ Settings.linearSlop = .005;
                Settings.linearSlopSquared = Settings.linearSlop * Settings.linearSlop;
                /**
 * A small angle used as a collision and constraint tolerance. Usually it is
 * chosen to be numerically significant, but visually insignificant.
 */ Settings.angularSlop = 2 / 180 * Math.PI;
                /**
 * The radius of the polygon/edge shape skin. This should not be modified.
 * Making this smaller means polygons will have an insufficient buffer for
 * continuous collision. Making it larger may create artifacts for vertex
 * collision.
 */ Settings.polygonRadius = 2 * Settings.linearSlop;
                /**
 * Maximum number of sub-steps per contact in continuous physics simulation.
 */ Settings.maxSubSteps = 8;
                // Dynamics
                /**
 * Maximum number of contacts to be handled to solve a TOI impact.
 */ Settings.maxTOIContacts = 32;
                /**
 * Maximum iterations to solve a TOI.
 */ Settings.maxTOIIterations = 20;
                /**
 * Maximum iterations to find Distance.
 */ Settings.maxDistnceIterations = 20;
                /**
 * A velocity threshold for elastic collisions. Any collision with a relative
 * linear velocity below this threshold will be treated as inelastic.
 */ Settings.velocityThreshold = 1;
                /**
 * The maximum linear position correction used when solving constraints. This
 * helps to prevent overshoot.
 */ Settings.maxLinearCorrection = .2;
                /**
 * The maximum angular position correction used when solving constraints. This
 * helps to prevent overshoot.
 */ Settings.maxAngularCorrection = 8 / 180 * Math.PI;
                /**
 * The maximum linear velocity of a body. This limit is very large and is used
 * to prevent numerical problems. You shouldn't need to adjust this.
 */ Settings.maxTranslation = 2;
                Settings.maxTranslationSquared = Settings.maxTranslation * Settings.maxTranslation;
                /**
 * The maximum angular velocity of a body. This limit is very large and is used
 * to prevent numerical problems. You shouldn't need to adjust this.
 */ Settings.maxRotation = .5 * Math.PI;
                Settings.maxRotationSquared = Settings.maxRotation * Settings.maxRotation;
                /**
 * This scale factor controls how fast overlap is resolved. Ideally this would
 * be 1 so that overlap is removed in one time step. However using values close
 * to 1 often lead to overshoot.
 */ Settings.baumgarte = .2;
                Settings.toiBaugarte = .75;
                // Sleep
                /**
 * The time that a body must be still before it will go to sleep.
 */ Settings.timeToSleep = .5;
                /**
 * A body cannot sleep if its linear velocity is above this tolerance.
 */ Settings.linearSleepTolerance = .01;
                Settings.linearSleepToleranceSqr = Math.pow(Settings.linearSleepTolerance, 2);
                /**
 * A body cannot sleep if its angular velocity is above this tolerance.
 */ Settings.angularSleepTolerance = 2 / 180 * Math.PI;
                Settings.angularSleepToleranceSqr = Math.pow(Settings.angularSleepTolerance, 2);
            },
            {}
        ],
        8: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Shape;
                var Math1 = require1("./common/Math");
                /**
 * A shape is used for collision detection. You can create a shape however you
 * like. Shapes used for simulation in World are created automatically when a
 * Fixture is created. Shapes may encapsulate one or more child shapes.
 */ function Shape() {
                    this.m_type;
                    this.m_radius;
                }
                Shape.isValid = function(shape) {
                    return !!shape;
                };
                Shape.prototype.getRadius = function() {
                    return this.m_radius;
                };
                /**
 * Get the type of this shape. You can use this to down cast to the concrete
 * shape.
 * 
 * @return the shape type.
 */ Shape.prototype.getType = function() {
                    return this.m_type;
                };
                /**
 * @deprecated Shapes should be treated as immutable.
 *
 * clone the concrete shape.
 */ Shape.prototype._clone = function() {};
                /**
 * // Get the number of child primitives.
 */ Shape.prototype.getChildCount = function() {};
                /**
 * Test a point for containment in this shape. This only works for convex
 * shapes.
 * 
 * @param {Transform} xf The shape world transform.
 * @param p A point in world coordinates.
 */ Shape.prototype.testPoint = function(xf, p) {};
                /**
 * Cast a ray against a child shape.
 * 
 * @param {RayCastOutput} output The ray-cast results.
 * @param {RayCastInput} input The ray-cast input parameters.
 * @param {Transform} transform The transform to be applied to the shape.
 * @param childIndex The child shape index
 */ Shape.prototype.rayCast = function(output, input, transform, childIndex) {};
                /**
 * Given a transform, compute the associated axis aligned bounding box for a
 * child shape.
 * 
 * @param {AABB} aabb Returns the axis aligned box.
 * @param {Transform} xf The world transform of the shape.
 * @param childIndex The child shape
 */ Shape.prototype.computeAABB = function(aabb, xf, childIndex) {};
                /**
 * Compute the mass properties of this shape using its dimensions and density.
 * The inertia tensor is computed about the local origin.
 * 
 * @param {MassData} massData Returns the mass data for this shape.
 * @param density The density in kilograms per meter squared.
 */ Shape.prototype.computeMass = function(massData, density) {};
                /**
 * @param {DistanceProxy} proxy
 */ Shape.prototype.computeDistanceProxy = function(proxy) {};
            },
            {
                "./common/Math": 18
            }
        ],
        9: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Solver;
                module1.exports.TimeStep = TimeStep;
                var Settings = require1("./Settings");
                var common1 = require1("./util/common");
                var Vec2 = require1("./common/Vec2");
                var Math1 = require1("./common/Math");
                var Body = require1("./Body");
                var Contact = require1("./Contact");
                var Joint = require1("./Joint");
                var TimeOfImpact = require1("./collision/TimeOfImpact");
                var TOIInput = TimeOfImpact.Input;
                var TOIOutput = TimeOfImpact.Output;
                var Distance = require1("./collision/Distance");
                var DistanceInput = Distance.Input;
                var DistanceOutput = Distance.Output;
                var DistanceProxy = Distance.Proxy;
                var SimplexCache = Distance.Cache;
                function TimeStep(dt) {
                    this.dt = 0;
                    // time step
                    this.inv_dt = 0;
                    // inverse time step (0 if dt == 0)
                    this.velocityIterations = 0;
                    this.positionIterations = 0;
                    this.warmStarting = false;
                    this.blockSolve = true;
                    // timestep ratio for variable timestep
                    this.inv_dt0 = 0;
                    this.dtRatio = 1;
                }
                TimeStep.prototype.reset = function(dt) {
                    if (this.dt > 0) {
                        this.inv_dt0 = this.inv_dt;
                    }
                    this.dt = dt;
                    this.inv_dt = dt == 0 ? 0 : 1 / dt;
                    this.dtRatio = dt * this.inv_dt0;
                };
                /**
 * Finds and solves islands. An island is a connected subset of the world.
 * 
 * @param {World} world
 */ function Solver(world) {
                    this.m_world = world;
                    this.m_stack = [];
                    this.m_bodies = [];
                    this.m_contacts = [];
                    this.m_joints = [];
                }
                Solver.prototype.clear = function() {
                    this.m_stack.length = 0;
                    this.m_bodies.length = 0;
                    this.m_contacts.length = 0;
                    this.m_joints.length = 0;
                };
                Solver.prototype.addBody = function(body) {
                    _ASSERT && common1.assert(body instanceof Body, "Not a Body!", body);
                    this.m_bodies.push(body);
                };
                Solver.prototype.addContact = function(contact) {
                    _ASSERT && common1.assert(contact instanceof Contact, "Not a Contact!", contact);
                    this.m_contacts.push(contact);
                };
                Solver.prototype.addJoint = function(joint) {
                    _ASSERT && common1.assert(joint instanceof Joint, "Not a Joint!", joint);
                    this.m_joints.push(joint);
                };
                /**
 * @param {TimeStep} step
 */ Solver.prototype.solveWorld = function(step) {
                    var world = this.m_world;
                    // Clear all the island flags.
                    for(var b = world.m_bodyList; b; b = b.m_next){
                        b.m_islandFlag = false;
                    }
                    for(var c = world.m_contactList; c; c = c.m_next){
                        c.m_islandFlag = false;
                    }
                    for(var j = world.m_jointList; j; j = j.m_next){
                        j.m_islandFlag = false;
                    }
                    // Build and simulate all awake islands.
                    var stack = this.m_stack;
                    var loop = -1;
                    for(var seed = world.m_bodyList; seed; seed = seed.m_next){
                        loop++;
                        if (seed.m_islandFlag) {
                            continue;
                        }
                        if (seed.isAwake() == false || seed.isActive() == false) {
                            continue;
                        }
                        // The seed can be dynamic or kinematic.
                        if (seed.isStatic()) {
                            continue;
                        }
                        // Reset island and stack.
                        this.clear();
                        stack.push(seed);
                        seed.m_islandFlag = true;
                        // Perform a depth first search (DFS) on the constraint graph.
                        while(stack.length > 0){
                            // Grab the next body off the stack and add it to the island.
                            var b = stack.pop();
                            _ASSERT && common1.assert(b.isActive() == true);
                            this.addBody(b);
                            // Make sure the body is awake.
                            b.setAwake(true);
                            // To keep islands as small as possible, we don't
                            // propagate islands across static bodies.
                            if (b.isStatic()) {
                                continue;
                            }
                            // Search all contacts connected to this body.
                            for(var ce = b.m_contactList; ce; ce = ce.next){
                                var contact = ce.contact;
                                // Has this contact already been added to an island?
                                if (contact.m_islandFlag) {
                                    continue;
                                }
                                // Is this contact solid and touching?
                                if (contact.isEnabled() == false || contact.isTouching() == false) {
                                    continue;
                                }
                                // Skip sensors.
                                var sensorA = contact.m_fixtureA.m_isSensor;
                                var sensorB = contact.m_fixtureB.m_isSensor;
                                if (sensorA || sensorB) {
                                    continue;
                                }
                                this.addContact(contact);
                                contact.m_islandFlag = true;
                                var other = ce.other;
                                // Was the other body already added to this island?
                                if (other.m_islandFlag) {
                                    continue;
                                }
                                // _ASSERT && common.assert(stack.length < world.m_bodyCount);
                                stack.push(other);
                                other.m_islandFlag = true;
                            }
                            // Search all joints connect to this body.
                            for(var je = b.m_jointList; je; je = je.next){
                                if (je.joint.m_islandFlag == true) {
                                    continue;
                                }
                                var other = je.other;
                                // Don't simulate joints connected to inactive bodies.
                                if (other.isActive() == false) {
                                    continue;
                                }
                                this.addJoint(je.joint);
                                je.joint.m_islandFlag = true;
                                if (other.m_islandFlag) {
                                    continue;
                                }
                                // _ASSERT && common.assert(stack.length < world.m_bodyCount);
                                stack.push(other);
                                other.m_islandFlag = true;
                            }
                        }
                        this.solveIsland(step);
                        // Post solve cleanup.
                        for(var i = 0; i < this.m_bodies.length; ++i){
                            // Allow static bodies to participate in other islands.
                            // TODO: are they added at all?
                            var b = this.m_bodies[i];
                            if (b.isStatic()) {
                                b.m_islandFlag = false;
                            }
                        }
                    }
                };
                /**
 * @param {TimeStep} step
 */ Solver.prototype.solveIsland = function(step) {
                    // B2: Island Solve
                    var world = this.m_world;
                    var gravity = world.m_gravity;
                    var allowSleep = world.m_allowSleep;
                    var h = step.dt;
                    // Integrate velocities and apply damping. Initialize the body state.
                    for(var i = 0; i < this.m_bodies.length; ++i){
                        var body = this.m_bodies[i];
                        var c = Vec2.clone(body.m_sweep.c);
                        var a = body.m_sweep.a;
                        var v = Vec2.clone(body.m_linearVelocity);
                        var w = body.m_angularVelocity;
                        // Store positions for continuous collision.
                        body.m_sweep.c0.set(body.m_sweep.c);
                        body.m_sweep.a0 = body.m_sweep.a;
                        if (body.isDynamic()) {
                            // Integrate velocities.
                            v.addMul(h * body.m_gravityScale, gravity);
                            v.addMul(h * body.m_invMass, body.m_force);
                            w += h * body.m_invI * body.m_torque;
                            /**
       * <pre>
       * Apply damping.
       * ODE: dv/dt + c * v = 0
       * Solution: v(t) = v0 * exp(-c * t)
       * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
       * v2 = exp(-c * dt) * v1
       * Pade approximation:
       * v2 = v1 * 1 / (1 + c * dt)
       * </pre>
       */ v.mul(1 / (1 + h * body.m_linearDamping));
                            w *= 1 / (1 + h * body.m_angularDamping);
                        }
                        body.c_position.c = c;
                        body.c_position.a = a;
                        body.c_velocity.v = v;
                        body.c_velocity.w = w;
                    }
                    for(var i = 0; i < this.m_contacts.length; ++i){
                        var contact = this.m_contacts[i];
                        contact.initConstraint(step);
                    }
                    _DEBUG && this.printBodies("M: ");
                    for(var i = 0; i < this.m_contacts.length; ++i){
                        var contact = this.m_contacts[i];
                        contact.initVelocityConstraint(step);
                    }
                    _DEBUG && this.printBodies("R: ");
                    if (step.warmStarting) {
                        // Warm start.
                        for(var i = 0; i < this.m_contacts.length; ++i){
                            var contact = this.m_contacts[i];
                            contact.warmStartConstraint(step);
                        }
                    }
                    _DEBUG && this.printBodies("Q: ");
                    for(var i = 0; i < this.m_joints.length; ++i){
                        var joint = this.m_joints[i];
                        joint.initVelocityConstraints(step);
                    }
                    _DEBUG && this.printBodies("E: ");
                    // Solve velocity constraints
                    for(var i = 0; i < step.velocityIterations; ++i){
                        for(var j = 0; j < this.m_joints.length; ++j){
                            var joint = this.m_joints[j];
                            joint.solveVelocityConstraints(step);
                        }
                        for(var j = 0; j < this.m_contacts.length; ++j){
                            var contact = this.m_contacts[j];
                            contact.solveVelocityConstraint(step);
                        }
                    }
                    _DEBUG && this.printBodies("D: ");
                    // Store impulses for warm starting
                    for(var i = 0; i < this.m_contacts.length; ++i){
                        var contact = this.m_contacts[i];
                        contact.storeConstraintImpulses(step);
                    }
                    _DEBUG && this.printBodies("C: ");
                    // Integrate positions
                    for(var i = 0; i < this.m_bodies.length; ++i){
                        var body = this.m_bodies[i];
                        var c = Vec2.clone(body.c_position.c);
                        var a = body.c_position.a;
                        var v = Vec2.clone(body.c_velocity.v);
                        var w = body.c_velocity.w;
                        // Check for large velocities
                        var translation = Vec2.mul(h, v);
                        if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {
                            var ratio = Settings.maxTranslation / translation.length();
                            v.mul(ratio);
                        }
                        var rotation = h * w;
                        if (rotation * rotation > Settings.maxRotationSquared) {
                            var ratio = Settings.maxRotation / Math1.abs(rotation);
                            w *= ratio;
                        }
                        // Integrate
                        c.addMul(h, v);
                        a += h * w;
                        body.c_position.c.set(c);
                        body.c_position.a = a;
                        body.c_velocity.v.set(v);
                        body.c_velocity.w = w;
                    }
                    _DEBUG && this.printBodies("B: ");
                    // Solve position constraints
                    var positionSolved = false;
                    for(var i = 0; i < step.positionIterations; ++i){
                        var minSeparation = 0;
                        for(var j = 0; j < this.m_contacts.length; ++j){
                            var contact = this.m_contacts[j];
                            var separation = contact.solvePositionConstraint(step);
                            minSeparation = Math1.min(minSeparation, separation);
                        }
                        // We can't expect minSpeparation >= -Settings.linearSlop because we don't
                        // push the separation above -Settings.linearSlop.
                        var contactsOkay = minSeparation >= -3 * Settings.linearSlop;
                        var jointsOkay = true;
                        for(var j = 0; j < this.m_joints.length; ++j){
                            var joint = this.m_joints[j];
                            var jointOkay = joint.solvePositionConstraints(step);
                            jointsOkay = jointsOkay && jointOkay;
                        }
                        if (contactsOkay && jointsOkay) {
                            // Exit early if the position errors are small.
                            positionSolved = true;
                            break;
                        }
                    }
                    _DEBUG && this.printBodies("L: ");
                    // Copy state buffers back to the bodies
                    for(var i = 0; i < this.m_bodies.length; ++i){
                        var body = this.m_bodies[i];
                        body.m_sweep.c.set(body.c_position.c);
                        body.m_sweep.a = body.c_position.a;
                        body.m_linearVelocity.set(body.c_velocity.v);
                        body.m_angularVelocity = body.c_velocity.w;
                        body.synchronizeTransform();
                    }
                    this.postSolveIsland();
                    if (allowSleep) {
                        var minSleepTime = Infinity;
                        var linTolSqr = Settings.linearSleepToleranceSqr;
                        var angTolSqr = Settings.angularSleepToleranceSqr;
                        for(var i = 0; i < this.m_bodies.length; ++i){
                            var body = this.m_bodies[i];
                            if (body.isStatic()) {
                                continue;
                            }
                            if (body.m_autoSleepFlag == false || body.m_angularVelocity * body.m_angularVelocity > angTolSqr || Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr) {
                                body.m_sleepTime = 0;
                                minSleepTime = 0;
                            } else {
                                body.m_sleepTime += h;
                                minSleepTime = Math1.min(minSleepTime, body.m_sleepTime);
                            }
                        }
                        if (minSleepTime >= Settings.timeToSleep && positionSolved) {
                            for(var i = 0; i < this.m_bodies.length; ++i){
                                var body = this.m_bodies[i];
                                body.setAwake(false);
                            }
                        }
                    }
                };
                Solver.prototype.printBodies = function(tag) {
                    for(var i = 0; i < this.m_bodies.length; ++i){
                        var b = this.m_bodies[i];
                        common1.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);
                    }
                };
                var s_subStep = new TimeStep();
                // reuse
                /**
 * Find TOI contacts and solve them.
 *
 * @param {TimeStep} step
 */ Solver.prototype.solveWorldTOI = function(step) {
                    var world = this.m_world;
                    if (world.m_stepComplete) {
                        for(var b = world.m_bodyList; b; b = b.m_next){
                            b.m_islandFlag = false;
                            b.m_sweep.alpha0 = 0;
                        }
                        for(var c = world.m_contactList; c; c = c.m_next){
                            // Invalidate TOI
                            c.m_toiFlag = false;
                            c.m_islandFlag = false;
                            c.m_toiCount = 0;
                            c.m_toi = 1;
                        }
                    }
                    // Find TOI events and solve them.
                    for(;;){
                        // Find the first TOI.
                        var minContact = null;
                        // Contact
                        var minAlpha = 1;
                        for(var c = world.m_contactList; c; c = c.m_next){
                            // Is this contact disabled?
                            if (c.isEnabled() == false) {
                                continue;
                            }
                            // Prevent excessive sub-stepping.
                            if (c.m_toiCount > Settings.maxSubSteps) {
                                continue;
                            }
                            var alpha = 1;
                            if (c.m_toiFlag) {
                                // This contact has a valid cached TOI.
                                alpha = c.m_toi;
                            } else {
                                var fA = c.getFixtureA();
                                var fB = c.getFixtureB();
                                // Is there a sensor?
                                if (fA.isSensor() || fB.isSensor()) {
                                    continue;
                                }
                                var bA = fA.getBody();
                                var bB = fB.getBody();
                                _ASSERT && common1.assert(bA.isDynamic() || bB.isDynamic());
                                var activeA = bA.isAwake() && !bA.isStatic();
                                var activeB = bB.isAwake() && !bB.isStatic();
                                // Is at least one body active (awake and dynamic or kinematic)?
                                if (activeA == false && activeB == false) {
                                    continue;
                                }
                                var collideA = bA.isBullet() || !bA.isDynamic();
                                var collideB = bB.isBullet() || !bB.isDynamic();
                                // Are these two non-bullet dynamic bodies?
                                if (collideA == false && collideB == false) {
                                    continue;
                                }
                                // Compute the TOI for this contact.
                                // Put the sweeps onto the same time interval.
                                var alpha0 = bA.m_sweep.alpha0;
                                if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                                    alpha0 = bB.m_sweep.alpha0;
                                    bA.m_sweep.advance(alpha0);
                                } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                                    alpha0 = bA.m_sweep.alpha0;
                                    bB.m_sweep.advance(alpha0);
                                }
                                _ASSERT && common1.assert(alpha0 < 1);
                                var indexA = c.getChildIndexA();
                                var indexB = c.getChildIndexB();
                                var sweepA = bA.m_sweep;
                                var sweepB = bB.m_sweep;
                                // Compute the time of impact in interval [0, minTOI]
                                var input = new TOIInput();
                                // TODO: reuse
                                input.proxyA.set(fA.getShape(), indexA);
                                input.proxyB.set(fB.getShape(), indexB);
                                input.sweepA.set(bA.m_sweep);
                                input.sweepB.set(bB.m_sweep);
                                input.tMax = 1;
                                var output = new TOIOutput();
                                // TODO: reuse
                                TimeOfImpact(output, input);
                                // Beta is the fraction of the remaining portion of the [time?].
                                var beta = output.t;
                                if (output.state == TOIOutput.e_touching) {
                                    alpha = Math1.min(alpha0 + (1 - alpha0) * beta, 1);
                                } else {
                                    alpha = 1;
                                }
                                c.m_toi = alpha;
                                c.m_toiFlag = true;
                            }
                            if (alpha < minAlpha) {
                                // This is the minimum TOI found so far.
                                minContact = c;
                                minAlpha = alpha;
                            }
                        }
                        if (minContact == null || 1 - 10 * Math1.EPSILON < minAlpha) {
                            // No more TOI events. Done!
                            world.m_stepComplete = true;
                            break;
                        }
                        // Advance the bodies to the TOI.
                        var fA = minContact.getFixtureA();
                        var fB = minContact.getFixtureB();
                        var bA = fA.getBody();
                        var bB = fB.getBody();
                        var backup1 = bA.m_sweep.clone();
                        var backup2 = bB.m_sweep.clone();
                        bA.advance(minAlpha);
                        bB.advance(minAlpha);
                        // The TOI contact likely has some new contact points.
                        minContact.update(world);
                        minContact.m_toiFlag = false;
                        ++minContact.m_toiCount;
                        // Is the contact solid?
                        if (minContact.isEnabled() == false || minContact.isTouching() == false) {
                            // Restore the sweeps.
                            minContact.setEnabled(false);
                            bA.m_sweep.set(backup1);
                            bB.m_sweep.set(backup2);
                            bA.synchronizeTransform();
                            bB.synchronizeTransform();
                            continue;
                        }
                        bA.setAwake(true);
                        bB.setAwake(true);
                        // Build the island
                        this.clear();
                        this.addBody(bA);
                        this.addBody(bB);
                        this.addContact(minContact);
                        bA.m_islandFlag = true;
                        bB.m_islandFlag = true;
                        minContact.m_islandFlag = true;
                        // Get contacts on bodyA and bodyB.
                        var bodies = [
                            bA,
                            bB
                        ];
                        for(var i = 0; i < bodies.length; ++i){
                            var body = bodies[i];
                            if (body.isDynamic()) {
                                for(var ce = body.m_contactList; ce; ce = ce.next){
                                    // if (this.m_bodyCount == this.m_bodyCapacity) { break; }
                                    // if (this.m_contactCount == this.m_contactCapacity) { break; }
                                    var contact = ce.contact;
                                    // Has this contact already been added to the island?
                                    if (contact.m_islandFlag) {
                                        continue;
                                    }
                                    // Only add if either is static, kinematic or bullet.
                                    var other = ce.other;
                                    if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {
                                        continue;
                                    }
                                    // Skip sensors.
                                    var sensorA = contact.m_fixtureA.m_isSensor;
                                    var sensorB = contact.m_fixtureB.m_isSensor;
                                    if (sensorA || sensorB) {
                                        continue;
                                    }
                                    // Tentatively advance the body to the TOI.
                                    var backup = other.m_sweep.clone();
                                    if (other.m_islandFlag == false) {
                                        other.advance(minAlpha);
                                    }
                                    // Update the contact points
                                    contact.update(world);
                                    // Was the contact disabled by the user?
                                    // Are there contact points?
                                    if (contact.isEnabled() == false || contact.isTouching() == false) {
                                        other.m_sweep.set(backup);
                                        other.synchronizeTransform();
                                        continue;
                                    }
                                    // Add the contact to the island
                                    contact.m_islandFlag = true;
                                    this.addContact(contact);
                                    // Has the other body already been added to the island?
                                    if (other.m_islandFlag) {
                                        continue;
                                    }
                                    // Add the other body to the island.
                                    other.m_islandFlag = true;
                                    if (!other.isStatic()) {
                                        other.setAwake(true);
                                    }
                                    this.addBody(other);
                                }
                            }
                        }
                        s_subStep.reset((1 - minAlpha) * step.dt);
                        s_subStep.dtRatio = 1;
                        s_subStep.positionIterations = 20;
                        s_subStep.velocityIterations = step.velocityIterations;
                        s_subStep.warmStarting = false;
                        this.solveIslandTOI(s_subStep, bA, bB);
                        // Reset island flags and synchronize broad-phase proxies.
                        for(var i = 0; i < this.m_bodies.length; ++i){
                            var body = this.m_bodies[i];
                            body.m_islandFlag = false;
                            if (!body.isDynamic()) {
                                continue;
                            }
                            body.synchronizeFixtures();
                            // Invalidate all contact TOIs on this displaced body.
                            for(var ce = body.m_contactList; ce; ce = ce.next){
                                ce.contact.m_toiFlag = false;
                                ce.contact.m_islandFlag = false;
                            }
                        }
                        // Commit fixture proxy movements to the broad-phase so that new contacts
                        // are created.
                        // Also, some contacts can be destroyed.
                        world.findNewContacts();
                        if (world.m_subStepping) {
                            world.m_stepComplete = false;
                            break;
                        }
                    }
                    if (_DEBUG) for(var b = world.m_bodyList; b; b = b.m_next){
                        var c = b.m_sweep.c;
                        var a = b.m_sweep.a;
                        var v = b.m_linearVelocity;
                        var w = b.m_angularVelocity;
                    }
                };
                /**
 * @param {TimeStep} subStep
 * @param toiA
 * @param toiB
 */ Solver.prototype.solveIslandTOI = function(subStep, toiA, toiB) {
                    var world = this.m_world;
                    // Initialize the body state.
                    for(var i = 0; i < this.m_bodies.length; ++i){
                        var body = this.m_bodies[i];
                        body.c_position.c.set(body.m_sweep.c);
                        body.c_position.a = body.m_sweep.a;
                        body.c_velocity.v.set(body.m_linearVelocity);
                        body.c_velocity.w = body.m_angularVelocity;
                    }
                    for(var i = 0; i < this.m_contacts.length; ++i){
                        var contact = this.m_contacts[i];
                        contact.initConstraint(subStep);
                    }
                    // Solve position constraints.
                    for(var i = 0; i < subStep.positionIterations; ++i){
                        var minSeparation = 0;
                        for(var j = 0; j < this.m_contacts.length; ++j){
                            var contact = this.m_contacts[j];
                            var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);
                            minSeparation = Math1.min(minSeparation, separation);
                        }
                        // We can't expect minSpeparation >= -Settings.linearSlop because we don't
                        // push the separation above -Settings.linearSlop.
                        var contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;
                        if (contactsOkay) {
                            break;
                        }
                    }
                    if (false) {
                        // Is the new position really safe?
                        for(var i = 0; i < this.m_contacts.length; ++i){
                            var c = this.m_contacts[i];
                            var fA = c.getFixtureA();
                            var fB = c.getFixtureB();
                            var bA = fA.getBody();
                            var bB = fB.getBody();
                            var indexA = c.getChildIndexA();
                            var indexB = c.getChildIndexB();
                            var input = new DistanceInput();
                            input.proxyA.set(fA.getShape(), indexA);
                            input.proxyB.set(fB.getShape(), indexB);
                            input.transformA = bA.getTransform();
                            input.transformB = bB.getTransform();
                            input.useRadii = false;
                            var output = new DistanceOutput();
                            var cache = new SimplexCache();
                            Distance(output, cache, input);
                            if (output.distance == 0 || cache.count == 3) {
                                cache.count += 0;
                            }
                        }
                    }
                    // Leap of faith to new safe state.
                    toiA.m_sweep.c0.set(toiA.c_position.c);
                    toiA.m_sweep.a0 = toiA.c_position.a;
                    toiB.m_sweep.c0.set(toiB.c_position.c);
                    toiB.m_sweep.a0 = toiB.c_position.a;
                    // No warm starting is needed for TOI events because warm
                    // starting impulses were applied in the discrete solver.
                    for(var i = 0; i < this.m_contacts.length; ++i){
                        var contact = this.m_contacts[i];
                        contact.initVelocityConstraint(subStep);
                    }
                    // Solve velocity constraints.
                    for(var i = 0; i < subStep.velocityIterations; ++i){
                        for(var j = 0; j < this.m_contacts.length; ++j){
                            var contact = this.m_contacts[j];
                            contact.solveVelocityConstraint(subStep);
                        }
                    }
                    // Don't store the TOI contact forces for warm starting
                    // because they can be quite large.
                    var h = subStep.dt;
                    // Integrate positions
                    for(var i = 0; i < this.m_bodies.length; ++i){
                        var body = this.m_bodies[i];
                        var c = Vec2.clone(body.c_position.c);
                        var a = body.c_position.a;
                        var v = Vec2.clone(body.c_velocity.v);
                        var w = body.c_velocity.w;
                        // Check for large velocities
                        var translation = Vec2.mul(h, v);
                        if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {
                            var ratio = Settings.maxTranslation / translation.length();
                            v.mul(ratio);
                        }
                        var rotation = h * w;
                        if (rotation * rotation > Settings.maxRotationSquared) {
                            var ratio = Settings.maxRotation / Math1.abs(rotation);
                            w *= ratio;
                        }
                        // Integrate
                        c.addMul(h, v);
                        a += h * w;
                        body.c_position.c = c;
                        body.c_position.a = a;
                        body.c_velocity.v = v;
                        body.c_velocity.w = w;
                        // Sync bodies
                        body.m_sweep.c = c;
                        body.m_sweep.a = a;
                        body.m_linearVelocity = v;
                        body.m_angularVelocity = w;
                        body.synchronizeTransform();
                    }
                    this.postSolveIsland();
                };
                /**
 * Contact impulses for reporting. Impulses are used instead of forces because
 * sub-step forces may approach infinity for rigid body collisions. These match
 * up one-to-one with the contact points in Manifold.
 */ function ContactImpulse() {
                    this.normalImpulses = [];
                    this.tangentImpulses = [];
                }
                Solver.prototype.postSolveIsland = function() {
                    // TODO: report contact.v_points instead of new object?
                    var impulse = new ContactImpulse();
                    for(var c = 0; c < this.m_contacts.length; ++c){
                        var contact = this.m_contacts[c];
                        for(var p = 0; p < contact.v_points.length; ++p){
                            impulse.normalImpulses.push(contact.v_points[p].normalImpulse);
                            impulse.tangentImpulses.push(contact.v_points[p].tangentImpulse);
                        }
                        this.m_world.postSolve(contact, impulse);
                    }
                };
            },
            {
                "./Body": 2,
                "./Contact": 3,
                "./Joint": 5,
                "./Settings": 7,
                "./collision/Distance": 13,
                "./collision/TimeOfImpact": 15,
                "./common/Math": 18,
                "./common/Vec2": 23,
                "./util/common": 50
            }
        ],
        10: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = World;
                var options = require1("./util/options");
                var common1 = require1("./util/common");
                var Vec2 = require1("./common/Vec2");
                var BroadPhase = require1("./collision/BroadPhase");
                var Solver = require1("./Solver");
                var Body = require1("./Body");
                var Contact = require1("./Contact");
                /**
 * @typedef {Object} WorldDef
 *
 * @prop {Vec2} [gravity = { x : 0, y : 0}]
 * @prop {boolean} [allowSleep = true]
 * @prop {boolean} [warmStarting = false]
 * @prop {boolean} [continuousPhysics = false]
 * @prop {boolean} [subStepping = false]
 * @prop {boolean} [blockSolve = true]
 * @prop {int} [velocityIterations = 8] For the velocity constraint solver.
 * @prop {int} [positionIterations = 3] For the position constraint solver.
 */ var WorldDef = {
                    gravity: Vec2.zero(),
                    allowSleep: true,
                    warmStarting: true,
                    continuousPhysics: true,
                    subStepping: false,
                    blockSolve: true,
                    velocityIterations: 8,
                    positionIterations: 3
                };
                /**
 * @param {WordDef|Vec2} def World definition or gravity vector.
 */ function World(def) {
                    if (!(this instanceof World)) {
                        return new World(def);
                    }
                    if (def && Vec2.isValid(def)) {
                        def = {
                            gravity: def
                        };
                    }
                    def = options(def, WorldDef);
                    this.m_solver = new Solver(this);
                    this.m_broadPhase = new BroadPhase();
                    this.m_contactList = null;
                    this.m_contactCount = 0;
                    this.m_bodyList = null;
                    this.m_bodyCount = 0;
                    this.m_jointList = null;
                    this.m_jointCount = 0;
                    this.m_stepComplete = true;
                    this.m_allowSleep = def.allowSleep;
                    this.m_gravity = Vec2.clone(def.gravity);
                    this.m_clearForces = true;
                    this.m_newFixture = false;
                    this.m_locked = false;
                    // These are for debugging the solver.
                    this.m_warmStarting = def.warmStarting;
                    this.m_continuousPhysics = def.continuousPhysics;
                    this.m_subStepping = def.subStepping;
                    this.m_blockSolve = def.blockSolve;
                    this.m_velocityIterations = def.velocityIterations;
                    this.m_positionIterations = def.positionIterations;
                    this.m_t = 0;
                    this.m_stepCount = 0;
                    // Broad-phase callback.
                    this.addPair = this.createContact.bind(this);
                }
                /**
 * Get the world body list. With the returned body, use Body.getNext to get the
 * next body in the world list. A null body indicates the end of the list.
 *
 * @return the head of the world body list.
 */ World.prototype.getBodyList = function() {
                    return this.m_bodyList;
                };
                /**
 * Get the world joint list. With the returned joint, use Joint.getNext to get
 * the next joint in the world list. A null joint indicates the end of the list.
 *
 * @return the head of the world joint list.
 */ World.prototype.getJointList = function() {
                    return this.m_jointList;
                };
                /**
 * Get the world contact list. With the returned contact, use Contact.getNext to
 * get the next contact in the world list. A null contact indicates the end of
 * the list.
 *
 * @return the head of the world contact list. Warning: contacts are created and
 *         destroyed in the middle of a time step. Use ContactListener to avoid
 *         missing contacts.
 */ World.prototype.getContactList = function() {
                    return this.m_contactList;
                };
                World.prototype.getBodyCount = function() {
                    return this.m_bodyCount;
                };
                World.prototype.getJointCount = function() {
                    return this.m_jointCount;
                };
                /**
 * Get the number of contacts (each may have 0 or more contact points).
 */ World.prototype.getContactCount = function() {
                    return this.m_contactCount;
                };
                /**
 * Change the global gravity vector.
 */ World.prototype.setGravity = function(gravity) {
                    this.m_gravity = gravity;
                };
                /**
 * Get the global gravity vector.
 */ World.prototype.getGravity = function() {
                    return this.m_gravity;
                };
                /**
 * Is the world locked (in the middle of a time step).
 */ World.prototype.isLocked = function() {
                    return this.m_locked;
                };
                /**
 * Enable/disable sleep.
 */ World.prototype.setAllowSleeping = function(flag) {
                    if (flag == this.m_allowSleep) {
                        return;
                    }
                    this.m_allowSleep = flag;
                    if (this.m_allowSleep == false) {
                        for(var b = this.m_bodyList; b; b = b.m_next){
                            b.setAwake(true);
                        }
                    }
                };
                World.prototype.getAllowSleeping = function() {
                    return this.m_allowSleep;
                };
                /**
 * Enable/disable warm starting. For testing.
 */ World.prototype.setWarmStarting = function(flag) {
                    this.m_warmStarting = flag;
                };
                World.prototype.getWarmStarting = function() {
                    return this.m_warmStarting;
                };
                /**
 * Enable/disable continuous physics. For testing.
 */ World.prototype.setContinuousPhysics = function(flag) {
                    this.m_continuousPhysics = flag;
                };
                World.prototype.getContinuousPhysics = function() {
                    return this.m_continuousPhysics;
                };
                /**
 * Enable/disable single stepped continuous physics. For testing.
 */ World.prototype.setSubStepping = function(flag) {
                    this.m_subStepping = flag;
                };
                World.prototype.getSubStepping = function() {
                    return this.m_subStepping;
                };
                /**
 * Set flag to control automatic clearing of forces after each time step.
 */ World.prototype.setAutoClearForces = function(flag) {
                    this.m_clearForces = flag;
                };
                /**
 * Get the flag that controls automatic clearing of forces after each time step.
 */ World.prototype.getAutoClearForces = function() {
                    return this.m_clearForces;
                };
                /**
 * Manually clear the force buffer on all bodies. By default, forces are cleared
 * automatically after each call to step. The default behavior is modified by
 * calling setAutoClearForces. The purpose of this function is to support
 * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step
 * under a variable frame-rate. When you perform sub-stepping you will disable
 * auto clearing of forces and instead call clearForces after all sub-steps are
 * complete in one pass of your game loop.
 *
 * @see setAutoClearForces
 */ World.prototype.clearForces = function() {
                    for(var body = this.m_bodyList; body; body = body.getNext()){
                        body.m_force.setZero();
                        body.m_torque = 0;
                    }
                };
                /**
 * @function World~rayCastCallback
 *
 * @param fixture
 */ /**
 * Query the world for all fixtures that potentially overlap the provided AABB.
 *
 * @param {World~queryCallback} queryCallback Called for each fixture
 *          found in the query AABB. It may return `false` to terminate the
 *          query.
 *
 * @param aabb The query box.
 */ World.prototype.queryAABB = function(aabb, queryCallback) {
                    _ASSERT && common1.assert(typeof queryCallback === "function");
                    var broadPhase = this.m_broadPhase;
                    this.m_broadPhase.query(aabb, function(proxyId) {
                        //TODO GC
                        var proxy = broadPhase.getUserData(proxyId);
                        // FixtureProxy
                        return queryCallback(proxy.fixture);
                    });
                };
                /**
 * @function World~rayCastCallback
 *
 * Callback class for ray casts. See World.rayCast
 *
 * Called for each fixture found in the query. You control how the ray cast
 * proceeds by returning a float: return -1: ignore this fixture and continue
 * return 0: terminate the ray cast return fraction: clip the ray to this point
 * return 1: don't clip the ray and continue
 *
 * @param fixture The fixture hit by the ray
 * @param point The point of initial intersection
 * @param normal The normal vector at the point of intersection
 * @param fraction
 *
 * @return {float} -1 to filter, 0 to terminate, fraction to clip the ray for
 *         closest hit, 1 to continue
 */ /**
 *
 * Ray-cast the world for all fixtures in the path of the ray. Your callback
 * controls whether you get the closest point, any point, or n-points. The
 * ray-cast ignores shapes that contain the starting point.
 *
 * @param {World~RayCastCallback} reportFixtureCallback A user implemented
 *          callback function.
 * @param point1 The ray starting point
 * @param point2 The ray ending point
 */ World.prototype.rayCast = function(point1, point2, reportFixtureCallback) {
                    _ASSERT && common1.assert(typeof reportFixtureCallback === "function");
                    var broadPhase = this.m_broadPhase;
                    this.m_broadPhase.rayCast({
                        maxFraction: 1,
                        p1: point1,
                        p2: point2
                    }, function(input, proxyId) {
                        // TODO GC
                        var proxy = broadPhase.getUserData(proxyId);
                        // FixtureProxy
                        var fixture = proxy.fixture;
                        var index = proxy.childIndex;
                        var output = {};
                        // TODO GC
                        var hit = fixture.rayCast(output, input, index);
                        if (hit) {
                            var fraction = output.fraction;
                            var point = Vec2.add(Vec2.mul(1 - fraction, input.p1), Vec2.mul(fraction, input.p2));
                            return reportFixtureCallback(fixture, point, output.normal, fraction);
                        }
                        return input.maxFraction;
                    });
                };
                /**
 * Get the number of broad-phase proxies.
 */ World.prototype.getProxyCount = function() {
                    return this.m_broadPhase.getProxyCount();
                };
                /**
 * Get the height of broad-phase dynamic tree.
 */ World.prototype.getTreeHeight = function() {
                    return this.m_broadPhase.getTreeHeight();
                };
                /**
 * Get the balance of broad-phase dynamic tree.
 *
 * @returns {int}
 */ World.prototype.getTreeBalance = function() {
                    return this.m_broadPhase.getTreeBalance();
                };
                /**
 * Get the quality metric of broad-phase dynamic tree. The smaller the better.
 * The minimum is 1.
 *
 * @returns {float}
 */ World.prototype.getTreeQuality = function() {
                    return this.m_broadPhase.getTreeQuality();
                };
                /**
 * Shift the world origin. Useful for large worlds. The body shift formula is:
 * position -= newOrigin
 *
 * @param {Vec2} newOrigin The new origin with respect to the old origin
 */ World.prototype.shiftOrigin = function(newOrigin) {
                    _ASSERT && common1.assert(this.m_locked == false);
                    if (this.m_locked) {
                        return;
                    }
                    for(var b = this.m_bodyList; b; b = b.m_next){
                        b.m_xf.p.sub(newOrigin);
                        b.m_sweep.c0.sub(newOrigin);
                        b.m_sweep.c.sub(newOrigin);
                    }
                    for(var j = this.m_jointList; j; j = j.m_next){
                        j.shiftOrigin(newOrigin);
                    }
                    this.m_broadPhase.shiftOrigin(newOrigin);
                };
                /**
 * Create a rigid body given a definition. No reference to the definition is
 * retained.
 *
 * Warning: This function is locked during callbacks.
 *
 * @param {BodyDef|Vec2} def Body definition or position.
 * @param {float} angle Body angle if def is position.
 */ World.prototype.createBody = function(def, angle) {
                    _ASSERT && common1.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return null;
                    }
                    if (def && Vec2.isValid(def)) {
                        def = {
                            position: def,
                            angle: angle
                        };
                    }
                    var body = new Body(this, def);
                    // Add to world doubly linked list.
                    body.m_prev = null;
                    body.m_next = this.m_bodyList;
                    if (this.m_bodyList) {
                        this.m_bodyList.m_prev = body;
                    }
                    this.m_bodyList = body;
                    ++this.m_bodyCount;
                    return body;
                };
                World.prototype.createDynamicBody = function(def, angle) {
                    if (!def) {
                        def = {};
                    } else if (Vec2.isValid(def)) {
                        def = {
                            position: def,
                            angle: angle
                        };
                    }
                    def.type = "dynamic";
                    return this.createBody(def);
                };
                World.prototype.createKinematicBody = function(def, angle) {
                    if (!def) {
                        def = {};
                    } else if (Vec2.isValid(def)) {
                        def = {
                            position: def,
                            angle: angle
                        };
                    }
                    def.type = "kinematic";
                    return this.createBody(def);
                };
                /**
 * Destroy a rigid body given a definition. No reference to the definition is
 * retained.
 *
 * Warning: This automatically deletes all associated shapes and joints.
 *
 * Warning: This function is locked during callbacks.
 *
 * @param {Body} b
 */ World.prototype.destroyBody = function(b) {
                    _ASSERT && common1.assert(this.m_bodyCount > 0);
                    _ASSERT && common1.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return;
                    }
                    if (b.m_destroyed) {
                        return false;
                    }
                    // Delete the attached joints.
                    var je = b.m_jointList;
                    while(je){
                        var je0 = je;
                        je = je.next;
                        this.publish("remove-joint", je0.joint);
                        this.destroyJoint(je0.joint);
                        b.m_jointList = je;
                    }
                    b.m_jointList = null;
                    // Delete the attached contacts.
                    var ce = b.m_contactList;
                    while(ce){
                        var ce0 = ce;
                        ce = ce.next;
                        this.destroyContact(ce0.contact);
                        b.m_contactList = ce;
                    }
                    b.m_contactList = null;
                    // Delete the attached fixtures. This destroys broad-phase proxies.
                    var f = b.m_fixtureList;
                    while(f){
                        var f0 = f;
                        f = f.m_next;
                        this.publish("remove-fixture", f0);
                        f0.destroyProxies(this.m_broadPhase);
                        b.m_fixtureList = f;
                    }
                    b.m_fixtureList = null;
                    // Remove world body list.
                    if (b.m_prev) {
                        b.m_prev.m_next = b.m_next;
                    }
                    if (b.m_next) {
                        b.m_next.m_prev = b.m_prev;
                    }
                    if (b == this.m_bodyList) {
                        this.m_bodyList = b.m_next;
                    }
                    b.m_destroyed = true;
                    --this.m_bodyCount;
                    this.publish("remove-body", b);
                    return true;
                };
                /**
 * Create a joint to constrain bodies together. No reference to the definition
 * is retained. This may cause the connected bodies to cease colliding.
 *
 * Warning: This function is locked during callbacks.
 *
 * @param {Joint} join
 * @param {Body} bodyB
 * @param {Body} bodyA
 */ World.prototype.createJoint = function(joint) {
                    _ASSERT && common1.assert(!!joint.m_bodyA);
                    _ASSERT && common1.assert(!!joint.m_bodyB);
                    _ASSERT && common1.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return null;
                    }
                    // Connect to the world list.
                    joint.m_prev = null;
                    joint.m_next = this.m_jointList;
                    if (this.m_jointList) {
                        this.m_jointList.m_prev = joint;
                    }
                    this.m_jointList = joint;
                    ++this.m_jointCount;
                    // Connect to the bodies' doubly linked lists.
                    joint.m_edgeA.joint = joint;
                    joint.m_edgeA.other = joint.m_bodyB;
                    joint.m_edgeA.prev = null;
                    joint.m_edgeA.next = joint.m_bodyA.m_jointList;
                    if (joint.m_bodyA.m_jointList) joint.m_bodyA.m_jointList.prev = joint.m_edgeA;
                    joint.m_bodyA.m_jointList = joint.m_edgeA;
                    joint.m_edgeB.joint = joint;
                    joint.m_edgeB.other = joint.m_bodyA;
                    joint.m_edgeB.prev = null;
                    joint.m_edgeB.next = joint.m_bodyB.m_jointList;
                    if (joint.m_bodyB.m_jointList) joint.m_bodyB.m_jointList.prev = joint.m_edgeB;
                    joint.m_bodyB.m_jointList = joint.m_edgeB;
                    // If the joint prevents collisions, then flag any contacts for filtering.
                    if (joint.m_collideConnected == false) {
                        for(var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next){
                            if (edge.other == joint.m_bodyA) {
                                // Flag the contact for filtering at the next time step (where either
                                // body is awake).
                                edge.contact.flagForFiltering();
                            }
                        }
                    }
                    // Note: creating a joint doesn't wake the bodies.
                    return joint;
                };
                /**
 * Destroy a joint. This may cause the connected bodies to begin colliding.
 * Warning: This function is locked during callbacks.
 *
 * @param {Joint} join
 */ World.prototype.destroyJoint = function(joint) {
                    _ASSERT && common1.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return;
                    }
                    // Remove from the doubly linked list.
                    if (joint.m_prev) {
                        joint.m_prev.m_next = joint.m_next;
                    }
                    if (joint.m_next) {
                        joint.m_next.m_prev = joint.m_prev;
                    }
                    if (joint == this.m_jointList) {
                        this.m_jointList = joint.m_next;
                    }
                    // Disconnect from bodies.
                    var bodyA = joint.m_bodyA;
                    var bodyB = joint.m_bodyB;
                    // Wake up connected bodies.
                    bodyA.setAwake(true);
                    bodyB.setAwake(true);
                    // Remove from body 1.
                    if (joint.m_edgeA.prev) {
                        joint.m_edgeA.prev.next = joint.m_edgeA.next;
                    }
                    if (joint.m_edgeA.next) {
                        joint.m_edgeA.next.prev = joint.m_edgeA.prev;
                    }
                    if (joint.m_edgeA == bodyA.m_jointList) {
                        bodyA.m_jointList = joint.m_edgeA.next;
                    }
                    joint.m_edgeA.prev = null;
                    joint.m_edgeA.next = null;
                    // Remove from body 2
                    if (joint.m_edgeB.prev) {
                        joint.m_edgeB.prev.next = joint.m_edgeB.next;
                    }
                    if (joint.m_edgeB.next) {
                        joint.m_edgeB.next.prev = joint.m_edgeB.prev;
                    }
                    if (joint.m_edgeB == bodyB.m_jointList) {
                        bodyB.m_jointList = joint.m_edgeB.next;
                    }
                    joint.m_edgeB.prev = null;
                    joint.m_edgeB.next = null;
                    _ASSERT && common1.assert(this.m_jointCount > 0);
                    --this.m_jointCount;
                    // If the joint prevents collisions, then flag any contacts for filtering.
                    if (joint.m_collideConnected == false) {
                        var edge = bodyB.getContactList();
                        while(edge){
                            if (edge.other == bodyA) {
                                // Flag the contact for filtering at the next time step (where either
                                // body is awake).
                                edge.contact.flagForFiltering();
                            }
                            edge = edge.next;
                        }
                    }
                    this.publish("remove-joint", joint);
                };
                var s_step = new Solver.TimeStep();
                // reuse
                /**
 * Take a time step. This performs collision detection, integration, and
 * constraint solution.
 *
 * Broad-phase, narrow-phase, solve and solve time of impacts.
 *
 * @param {float} timeStep Time step, this should not vary.
 * @param {int} velocityIterations
 * @param {int} positionIterations
 */ World.prototype.step = function(timeStep, velocityIterations, positionIterations) {
                    if ((velocityIterations | 0) !== velocityIterations) {
                        // TODO: remove this in future
                        velocityIterations = 0;
                    }
                    velocityIterations = velocityIterations || this.m_velocityIterations;
                    positionIterations = positionIterations || this.m_positionIterations;
                    // TODO: move this to testbed
                    this.m_stepCount++;
                    // If new fixtures were added, we need to find the new contacts.
                    if (this.m_newFixture) {
                        this.findNewContacts();
                        this.m_newFixture = false;
                    }
                    this.m_locked = true;
                    s_step.reset(timeStep);
                    s_step.velocityIterations = velocityIterations;
                    s_step.positionIterations = positionIterations;
                    s_step.warmStarting = this.m_warmStarting;
                    s_step.blockSolve = this.m_blockSolve;
                    // Update contacts. This is where some contacts are destroyed.
                    this.updateContacts();
                    // Integrate velocities, solve velocity constraints, and integrate positions.
                    if (this.m_stepComplete && timeStep > 0) {
                        this.m_solver.solveWorld(s_step);
                        // Synchronize fixtures, check for out of range bodies.
                        for(var b = this.m_bodyList; b; b = b.getNext()){
                            // If a body was not in an island then it did not move.
                            if (b.m_islandFlag == false) {
                                continue;
                            }
                            if (b.isStatic()) {
                                continue;
                            }
                            // Update fixtures (for broad-phase).
                            b.synchronizeFixtures();
                        }
                        // Look for new contacts.
                        this.findNewContacts();
                    }
                    // Handle TOI events.
                    if (this.m_continuousPhysics && timeStep > 0) {
                        this.m_solver.solveWorldTOI(s_step);
                    }
                    if (this.m_clearForces) {
                        this.clearForces();
                    }
                    this.m_locked = false;
                };
                /**
 * Call this method to find new contacts.
 */ World.prototype.findNewContacts = function() {
                    this.m_broadPhase.updatePairs(this.addPair);
                };
                /**
 * @private
 *
 * @param {FixtureProxy} proxyA
 * @param {FixtureProxy} proxyB
 */ World.prototype.createContact = function(proxyA, proxyB) {
                    var fixtureA = proxyA.fixture;
                    var fixtureB = proxyB.fixture;
                    var indexA = proxyA.childIndex;
                    var indexB = proxyB.childIndex;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    // Are the fixtures on the same body?
                    if (bodyA === bodyB) {
                        return;
                    }
                    // TODO_ERIN use a hash table to remove a potential bottleneck when both
                    // bodies have a lot of contacts.
                    // Does a contact already exist?
                    var edge = bodyB.getContactList();
                    // ContactEdge
                    while(edge){
                        if (edge.other === bodyA) {
                            var fA = edge.contact.getFixtureA();
                            var fB = edge.contact.getFixtureB();
                            var iA = edge.contact.getChildIndexA();
                            var iB = edge.contact.getChildIndexB();
                            if (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB) {
                                // A contact already exists.
                                return;
                            }
                            if (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA) {
                                // A contact already exists.
                                return;
                            }
                        }
                        edge = edge.next;
                    }
                    if (bodyB.shouldCollide(bodyA) === false) {
                        return;
                    }
                    if (fixtureB.shouldCollide(fixtureA) === false) {
                        return;
                    }
                    // Call the factory.
                    var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);
                    if (contact == null) {
                        return;
                    }
                    // Insert into the world.
                    contact.m_prev = null;
                    if (this.m_contactList != null) {
                        contact.m_next = this.m_contactList;
                        this.m_contactList.m_prev = contact;
                    }
                    this.m_contactList = contact;
                    ++this.m_contactCount;
                };
                /**
 * Removes old non-overlapping contacts, applies filters and updates contacts.
 */ World.prototype.updateContacts = function() {
                    // Update awake contacts.
                    var c, next_c = this.m_contactList;
                    while(c = next_c){
                        next_c = c.getNext();
                        var fixtureA = c.getFixtureA();
                        var fixtureB = c.getFixtureB();
                        var indexA = c.getChildIndexA();
                        var indexB = c.getChildIndexB();
                        var bodyA = fixtureA.getBody();
                        var bodyB = fixtureB.getBody();
                        // Is this contact flagged for filtering?
                        if (c.m_filterFlag) {
                            if (bodyB.shouldCollide(bodyA) == false) {
                                this.destroyContact(c);
                                continue;
                            }
                            if (fixtureB.shouldCollide(fixtureA) == false) {
                                this.destroyContact(c);
                                continue;
                            }
                            // Clear the filtering flag.
                            c.m_filterFlag = false;
                        }
                        var activeA = bodyA.isAwake() && !bodyA.isStatic();
                        var activeB = bodyB.isAwake() && !bodyB.isStatic();
                        // At least one body must be awake and it must be dynamic or kinematic.
                        if (activeA == false && activeB == false) {
                            continue;
                        }
                        var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
                        var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
                        var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);
                        // Here we destroy contacts that cease to overlap in the broad-phase.
                        if (overlap == false) {
                            this.destroyContact(c);
                            continue;
                        }
                        // The contact persists.
                        c.update(this);
                    }
                };
                /**
 * @param {Contact} contact
 */ World.prototype.destroyContact = function(contact) {
                    Contact.destroy(contact, this);
                    // Remove from the world.
                    if (contact.m_prev) {
                        contact.m_prev.m_next = contact.m_next;
                    }
                    if (contact.m_next) {
                        contact.m_next.m_prev = contact.m_prev;
                    }
                    if (contact == this.m_contactList) {
                        this.m_contactList = contact.m_next;
                    }
                    --this.m_contactCount;
                };
                World.prototype._listeners = null;
                /**
 * Register an event listener.
 *
 * @param {string} name
 * @param {function} listener
 */ World.prototype.on = function(name, listener) {
                    if (typeof name !== "string" || typeof listener !== "function") {
                        return this;
                    }
                    if (!this._listeners) {
                        this._listeners = {};
                    }
                    if (!this._listeners[name]) {
                        this._listeners[name] = [];
                    }
                    this._listeners[name].push(listener);
                    return this;
                };
                /**
 * Remove an event listener.
 *
 * @param {string} name
 * @param {function} listener
 */ World.prototype.off = function(name, listener) {
                    if (typeof name !== "string" || typeof listener !== "function") {
                        return this;
                    }
                    var listeners = this._listeners && this._listeners[name];
                    if (!listeners || !listeners.length) {
                        return this;
                    }
                    var index = listeners.indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    return this;
                };
                World.prototype.publish = function(name, arg1, arg2, arg3) {
                    var listeners = this._listeners && this._listeners[name];
                    if (!listeners || !listeners.length) {
                        return 0;
                    }
                    for(var l = 0; l < listeners.length; l++){
                        listeners[l].call(this, arg1, arg2, arg3);
                    }
                    return listeners.length;
                };
                /**
 * @event World#remove-body
 * @event World#remove-joint
 * @event World#remove-fixture
 *
 * Joints and fixtures are destroyed when their associated body is destroyed.
 * Register a destruction listener so that you may nullify references to these
 * joints and shapes.
 *
 * `function(object)` is called when any joint or fixture is about to
 * be destroyed due to the destruction of one of its attached or parent bodies.
 */ /**
 * @private
 * @param {Contact} contact
 */ World.prototype.beginContact = function(contact) {
                    this.publish("begin-contact", contact);
                };
                /**
 * @event World#begin-contact
 *
 * Called when two fixtures begin to touch.
 *
 * Implement contact callbacks to get contact information. You can use these
 * results for things like sounds and game logic. You can also get contact
 * results by traversing the contact lists after the time step. However, you
 * might miss some contacts because continuous physics leads to sub-stepping.
 * Additionally you may receive multiple callbacks for the same contact in a
 * single time step. You should strive to make your callbacks efficient because
 * there may be many callbacks per time step.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */ /**
 * @private
 * @param {Contact} contact
 */ World.prototype.endContact = function(contact) {
                    this.publish("end-contact", contact);
                };
                /**
 * @event World#end-contact
 *
 * Called when two fixtures cease to touch.
 *
 * Implement contact callbacks to get contact information. You can use these
 * results for things like sounds and game logic. You can also get contact
 * results by traversing the contact lists after the time step. However, you
 * might miss some contacts because continuous physics leads to sub-stepping.
 * Additionally you may receive multiple callbacks for the same contact in a
 * single time step. You should strive to make your callbacks efficient because
 * there may be many callbacks per time step.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */ /**
 * @private
 * @param {Contact} contact
 * @param {Manifold} oldManifold
 */ World.prototype.preSolve = function(contact, oldManifold) {
                    this.publish("pre-solve", contact, oldManifold);
                };
                /**
 * @event World#pre-solve
 *
 * This is called after a contact is updated. This allows you to inspect a
 * contact before it goes to the solver. If you are careful, you can modify the
 * contact manifold (e.g. disable contact). A copy of the old manifold is
 * provided so that you can detect changes. Note: this is called only for awake
 * bodies. Note: this is called even when the number of contact points is zero.
 * Note: this is not called for sensors. Note: if you set the number of contact
 * points to zero, you will not get an endContact callback. However, you may get
 * a beginContact callback the next step.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */ /**
 * @private
 * @param {Contact} contact
 * @param {ContactImpulse} impulse
 */ World.prototype.postSolve = function(contact, impulse) {
                    this.publish("post-solve", contact, impulse);
                };
            },
            {
                "./Body": 2,
                "./Contact": 3,
                "./Solver": 9,
                "./collision/BroadPhase": 12,
                "./common/Vec2": 23,
                "./util/common": 50,
                "./util/options": 52
            }
        ],
        11: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                module1.exports = AABB;
                function AABB(lower, upper) {
                    if (!(this instanceof AABB)) {
                        return new AABB(lower, upper);
                    }
                    this.lowerBound = Vec2.zero();
                    this.upperBound = Vec2.zero();
                    if (typeof lower === "object") {
                        this.lowerBound.set(lower);
                    }
                    if (typeof upper === "object") {
                        this.upperBound.set(upper);
                    }
                }
                /**
 * Verify that the bounds are sorted.
 */ AABB.prototype.isValid = function() {
                    return AABB.isValid(this);
                };
                AABB.isValid = function(aabb) {
                    var d = Vec2.sub(aabb.upperBound, aabb.lowerBound);
                    var valid = d.x >= 0 && d.y >= 0 && Vec2.isValid(aabb.lowerBound) && Vec2.isValid(aabb.upperBound);
                    return valid;
                };
                AABB.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!AABB.isValid(o)) {
                        _DEBUG && common.debug(o);
                        throw new Error("Invalid AABB!");
                    }
                };
                /**
 * Get the center of the AABB.
 */ AABB.prototype.getCenter = function() {
                    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * .5, (this.lowerBound.y + this.upperBound.y) * .5);
                };
                /**
 * Get the extents of the AABB (half-widths).
 */ AABB.prototype.getExtents = function() {
                    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * .5, (this.upperBound.y - this.lowerBound.y) * .5);
                };
                /**
 * Get the perimeter length.
 */ AABB.prototype.getPerimeter = function() {
                    return 2 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);
                };
                /**
 * Combine one or two AABB into this one.
 */ AABB.prototype.combine = function(a, b) {
                    var lowerA = a.lowerBound;
                    var upperA = a.upperBound;
                    var lowerB = b.lowerBound;
                    var upperB = b.upperBound;
                    var lowerX = Math1.min(lowerA.x, lowerB.x);
                    var lowerY = Math1.min(lowerA.y, lowerB.y);
                    var upperX = Math1.max(upperB.x, upperA.x);
                    var upperY = Math1.max(upperB.y, upperA.y);
                    this.lowerBound.set(lowerX, lowerY);
                    this.upperBound.set(upperX, upperY);
                };
                AABB.prototype.combinePoints = function(a, b) {
                    this.lowerBound.set(Math1.min(a.x, b.x), Math1.min(a.y, b.y));
                    this.upperBound.set(Math1.max(a.x, b.x), Math1.max(a.y, b.y));
                };
                AABB.prototype.set = function(aabb) {
                    this.lowerBound.set(aabb.lowerBound.x, aabb.lowerBound.y);
                    this.upperBound.set(aabb.upperBound.x, aabb.upperBound.y);
                };
                AABB.prototype.contains = function(aabb) {
                    var result = true;
                    result = result && this.lowerBound.x <= aabb.lowerBound.x;
                    result = result && this.lowerBound.y <= aabb.lowerBound.y;
                    result = result && aabb.upperBound.x <= this.upperBound.x;
                    result = result && aabb.upperBound.y <= this.upperBound.y;
                    return result;
                };
                AABB.prototype.extend = function(value) {
                    AABB.extend(this, value);
                };
                AABB.extend = function(aabb, value) {
                    aabb.lowerBound.x -= value;
                    aabb.lowerBound.y -= value;
                    aabb.upperBound.x += value;
                    aabb.upperBound.y += value;
                };
                AABB.testOverlap = function(a, b) {
                    var d1x = b.lowerBound.x - a.upperBound.x;
                    var d2x = a.lowerBound.x - b.upperBound.x;
                    var d1y = b.lowerBound.y - a.upperBound.y;
                    var d2y = a.lowerBound.y - b.upperBound.y;
                    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {
                        return false;
                    }
                    return true;
                };
                AABB.areEqual = function(a, b) {
                    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);
                };
                AABB.diff = function(a, b) {
                    var wD = Math1.max(0, Math1.min(a.upperBound.x, b.upperBound.x) - Math1.max(b.lowerBound.x, a.lowerBound.x));
                    var hD = Math1.max(0, Math1.min(a.upperBound.y, b.upperBound.y) - Math1.max(b.lowerBound.y, a.lowerBound.y));
                    var wA = a.upperBound.x - a.lowerBound.x;
                    var hA = a.upperBound.y - a.lowerBound.y;
                    var wB = b.upperBound.x - b.lowerBound.x;
                    var hB = b.upperBound.y - b.lowerBound.y;
                    return wA * hA + wB * hB - wD * hD;
                };
                /**
 * @typedef RayCastInput
 *
 * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
 *
 * @prop {Vec2} p1
 * @prop {Vec2} p2
 * @prop {number} maxFraction
 */ /**
 * @typedef RayCastInput
 *
 * Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and
 * p2 come from RayCastInput.
 *
 * @prop {Vec2} normal
 * @prop {number} fraction
 */ /**
 * @param {RayCastOutput} output
 * @param {RayCastInput} input
 * @returns {boolean}
 */ AABB.prototype.rayCast = function(output, input) {
                    // From Real-time Collision Detection, p179.
                    var tmin = -Infinity;
                    var tmax = Infinity;
                    var p = input.p1;
                    var d = Vec2.sub(input.p2, input.p1);
                    var absD = Vec2.abs(d);
                    var normal = Vec2.zero();
                    for(var f = "x"; f !== null; f = f === "x" ? "y" : null){
                        if (absD.x < Math1.EPSILON) {
                            // Parallel.
                            if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {
                                return false;
                            }
                        } else {
                            var inv_d = 1 / d[f];
                            var t1 = (this.lowerBound[f] - p[f]) * inv_d;
                            var t2 = (this.upperBound[f] - p[f]) * inv_d;
                            // Sign of the normal vector.
                            var s = -1;
                            if (t1 > t2) {
                                var temp = t1;
                                t1 = t2, t2 = temp;
                                s = 1;
                            }
                            // Push the min up
                            if (t1 > tmin) {
                                normal.setZero();
                                normal[f] = s;
                                tmin = t1;
                            }
                            // Pull the max down
                            tmax = Math1.min(tmax, t2);
                            if (tmin > tmax) {
                                return false;
                            }
                        }
                    }
                    // Does the ray start inside the box?
                    // Does the ray intersect beyond the max fraction?
                    if (tmin < 0 || input.maxFraction < tmin) {
                        return false;
                    }
                    // Intersection.
                    output.fraction = tmin;
                    output.normal = normal;
                    return true;
                };
                AABB.prototype.toString = function() {
                    return JSON.stringify(this);
                };
            },
            {
                "../Settings": 7,
                "../common/Math": 18,
                "../common/Vec2": 23
            }
        ],
        12: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var Settings = require1("../Settings");
                var common1 = require1("../util/common");
                var Math1 = require1("../common/Math");
                var AABB = require1("./AABB");
                var DynamicTree = require1("./DynamicTree");
                module1.exports = BroadPhase;
                /**
 * The broad-phase wraps and extends a dynamic-tree to keep track of moved
 * objects and query them on update.
 */ function BroadPhase() {
                    this.m_tree = new DynamicTree();
                    this.m_proxyCount = 0;
                    this.m_moveBuffer = [];
                    this.queryCallback = this.queryCallback.bind(this);
                }
                /**
 * Get user data from a proxy. Returns null if the id is invalid.
 */ BroadPhase.prototype.getUserData = function(proxyId) {
                    return this.m_tree.getUserData(proxyId);
                };
                /**
 * Test overlap of fat AABBs.
 */ BroadPhase.prototype.testOverlap = function(proxyIdA, proxyIdB) {
                    var aabbA = this.m_tree.getFatAABB(proxyIdA);
                    var aabbB = this.m_tree.getFatAABB(proxyIdB);
                    return AABB.testOverlap(aabbA, aabbB);
                };
                /**
 * Get the fat AABB for a proxy.
 */ BroadPhase.prototype.getFatAABB = function(proxyId) {
                    return this.m_tree.getFatAABB(proxyId);
                };
                /**
 * Get the number of proxies.
 */ BroadPhase.prototype.getProxyCount = function() {
                    return this.m_proxyCount;
                };
                /**
 * Get the height of the embedded tree.
 */ BroadPhase.prototype.getTreeHeight = function() {
                    return this.m_tree.getHeight();
                };
                /**
 * Get the balance (integer) of the embedded tree.
 */ BroadPhase.prototype.getTreeBalance = function() {
                    return this.m_tree.getMaxBalance();
                };
                /**
 * Get the quality metric of the embedded tree.
 */ BroadPhase.prototype.getTreeQuality = function() {
                    return this.m_tree.getAreaRatio();
                };
                /**
 * Query an AABB for overlapping proxies. The callback class is called for each
 * proxy that overlaps the supplied AABB.
 */ BroadPhase.prototype.query = function(aabb, queryCallback) {
                    this.m_tree.query(aabb, queryCallback);
                };
                /**
 * Ray-cast against the proxies in the tree. This relies on the callback to
 * perform a exact ray-cast in the case were the proxy contains a shape. The
 * callback also performs the any collision filtering. This has performance
 * roughly equal to k * log(n), where k is the number of collisions and n is the
 * number of proxies in the tree.
 * 
 * @param input The ray-cast input data. The ray extends from p1 to p1 +
 *          maxFraction * (p2 - p1).
 * @param rayCastCallback A function that is called for each proxy that is hit by
 *          the ray.
 */ BroadPhase.prototype.rayCast = function(input, rayCastCallback) {
                    this.m_tree.rayCast(input, rayCastCallback);
                };
                /**
 * Shift the world origin. Useful for large worlds. The shift formula is:
 * position -= newOrigin
 * 
 * @param newOrigin The new origin with respect to the old origin
 */ BroadPhase.prototype.shiftOrigin = function(newOrigin) {
                    this.m_tree.shiftOrigin(newOrigin);
                };
                /**
 * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs
 * is called.
 */ BroadPhase.prototype.createProxy = function(aabb, userData) {
                    _ASSERT && common1.assert(AABB.isValid(aabb));
                    var proxyId = this.m_tree.createProxy(aabb, userData);
                    this.m_proxyCount++;
                    this.bufferMove(proxyId);
                    return proxyId;
                };
                /**
 * Destroy a proxy. It is up to the client to remove any pairs.
 */ BroadPhase.prototype.destroyProxy = function(proxyId) {
                    this.unbufferMove(proxyId);
                    this.m_proxyCount--;
                    this.m_tree.destroyProxy(proxyId);
                };
                /**
 * Call moveProxy as many times as you like, then when you are done call
 * UpdatePairs to finalized the proxy pairs (for your time step).
 */ BroadPhase.prototype.moveProxy = function(proxyId, aabb, displacement) {
                    _ASSERT && common1.assert(AABB.isValid(aabb));
                    var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);
                    if (changed) {
                        this.bufferMove(proxyId);
                    }
                };
                /**
 * Call to trigger a re-processing of it's pairs on the next call to
 * UpdatePairs.
 */ BroadPhase.prototype.touchProxy = function(proxyId) {
                    this.bufferMove(proxyId);
                };
                BroadPhase.prototype.bufferMove = function(proxyId) {
                    this.m_moveBuffer.push(proxyId);
                };
                BroadPhase.prototype.unbufferMove = function(proxyId) {
                    for(var i = 0; i < this.m_moveBuffer.length; ++i){
                        if (this.m_moveBuffer[i] == proxyId) {
                            this.m_moveBuffer[i] = null;
                        }
                    }
                };
                /**
 * @function BroadPhase~addPair
 * @param {Object} userDataA
 * @param {Object} userDataB
 */ /**
 * Update the pairs. This results in pair callbacks. This can only add pairs.
 * 
 * @param {BroadPhase~AddPair} addPairCallback
 */ BroadPhase.prototype.updatePairs = function(addPairCallback) {
                    _ASSERT && common1.assert(typeof addPairCallback === "function");
                    this.m_callback = addPairCallback;
                    // Perform tree queries for all moving proxies.
                    while(this.m_moveBuffer.length > 0){
                        this.m_queryProxyId = this.m_moveBuffer.pop();
                        if (this.m_queryProxyId === null) {
                            continue;
                        }
                        // We have to query the tree with the fat AABB so that
                        // we don't fail to create a pair that may touch later.
                        var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);
                        // Query tree, create pairs and add them pair buffer.
                        this.m_tree.query(fatAABB, this.queryCallback);
                    }
                };
                BroadPhase.prototype.queryCallback = function(proxyId) {
                    // A proxy cannot form a pair with itself.
                    if (proxyId == this.m_queryProxyId) {
                        return true;
                    }
                    var proxyIdA = Math1.min(proxyId, this.m_queryProxyId);
                    var proxyIdB = Math1.max(proxyId, this.m_queryProxyId);
                    // TODO: Skip any duplicate pairs.
                    var userDataA = this.m_tree.getUserData(proxyIdA);
                    var userDataB = this.m_tree.getUserData(proxyIdB);
                    // Send the pairs back to the client.
                    this.m_callback(userDataA, userDataB);
                    return true;
                };
            },
            {
                "../Settings": 7,
                "../common/Math": 18,
                "../util/common": 50,
                "./AABB": 11,
                "./DynamicTree": 14
            }
        ],
        13: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Distance;
                module1.exports.Input = DistanceInput;
                module1.exports.Output = DistanceOutput;
                module1.exports.Proxy = DistanceProxy;
                module1.exports.Cache = SimplexCache;
                var Settings = require1("../Settings");
                var common1 = require1("../util/common");
                var stats = require1("../common/stats");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                /**
 * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
 */ stats.gjkCalls = 0;
                stats.gjkIters = 0;
                stats.gjkMaxIters = 0;
                /**
 * Input for Distance. You have to option to use the shape radii in the
 * computation. Even
 */ function DistanceInput() {
                    this.proxyA = new DistanceProxy();
                    this.proxyB = new DistanceProxy();
                    this.transformA = null;
                    this.transformB = null;
                    this.useRadii = false;
                }
                /**
 * Output for Distance.
 *
 * @prop {Vec2} pointA closest point on shapeA
 * @prop {Vec2} pointB closest point on shapeB
 * @prop distance
 * @prop iterations number of GJK iterations used
 */ function DistanceOutput() {
                    this.pointA = Vec2.zero();
                    this.pointB = Vec2.zero();
                    this.distance;
                    this.iterations;
                }
                /**
 * Used to warm start Distance. Set count to zero on first call.
 *
 * @prop {number} metric length or area
 * @prop {array} indexA vertices on shape A
 * @prop {array} indexB vertices on shape B
 * @prop {number} count
 */ function SimplexCache() {
                    this.metric = 0;
                    this.indexA = [];
                    this.indexB = [];
                    this.count = 0;
                }
                /**
 * Compute the closest points between two shapes. Supports any combination of:
 * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On
 * the first call set SimplexCache.count to zero.
 *
 * @param {DistanceOutput} output
 * @param {SimplexCache} cache
 * @param {DistanceInput} input
 */ function Distance(output, cache, input) {
                    ++stats.gjkCalls;
                    var proxyA = input.proxyA;
                    var proxyB = input.proxyB;
                    var xfA = input.transformA;
                    var xfB = input.transformB;
                    // Initialize the simplex.
                    var simplex = new Simplex();
                    simplex.readCache(cache, proxyA, xfA, proxyB, xfB);
                    // Get simplex vertices as an array.
                    var vertices = simplex.m_v;
                    // SimplexVertex
                    var k_maxIters = Settings.maxDistnceIterations;
                    // These store the vertices of the last simplex so that we
                    // can check for duplicates and prevent cycling.
                    var saveA = [];
                    var saveB = [];
                    // int[3]
                    var saveCount = 0;
                    var distanceSqr1 = Infinity;
                    var distanceSqr2 = Infinity;
                    // Main iteration loop.
                    var iter = 0;
                    while(iter < k_maxIters){
                        // Copy simplex so we can identify duplicates.
                        saveCount = simplex.m_count;
                        for(var i = 0; i < saveCount; ++i){
                            saveA[i] = vertices[i].indexA;
                            saveB[i] = vertices[i].indexB;
                        }
                        simplex.solve();
                        // If we have 3 points, then the origin is in the corresponding triangle.
                        if (simplex.m_count == 3) {
                            break;
                        }
                        // Compute closest point.
                        var p = simplex.getClosestPoint();
                        distanceSqr2 = p.lengthSquared();
                        // Ensure progress
                        if (distanceSqr2 >= distanceSqr1) {}
                        distanceSqr1 = distanceSqr2;
                        // Get search direction.
                        var d = simplex.getSearchDirection();
                        // Ensure the search direction is numerically fit.
                        if (d.lengthSquared() < Math1.EPSILON * Math1.EPSILON) {
                            break;
                        }
                        // Compute a tentative new simplex vertex using support points.
                        var vertex = vertices[simplex.m_count];
                        // SimplexVertex
                        vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));
                        vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));
                        vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));
                        vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));
                        vertex.w = Vec2.sub(vertex.wB, vertex.wA);
                        // Iteration count is equated to the number of support point calls.
                        ++iter;
                        ++stats.gjkIters;
                        // Check for duplicate support points. This is the main termination
                        // criteria.
                        var duplicate = false;
                        for(var i = 0; i < saveCount; ++i){
                            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                                duplicate = true;
                                break;
                            }
                        }
                        // If we found a duplicate support point we must exit to avoid cycling.
                        if (duplicate) {
                            break;
                        }
                        // New vertex is ok and needed.
                        ++simplex.m_count;
                    }
                    stats.gjkMaxIters = Math1.max(stats.gjkMaxIters, iter);
                    // Prepare output.
                    simplex.getWitnessPoints(output.pointA, output.pointB);
                    output.distance = Vec2.distance(output.pointA, output.pointB);
                    output.iterations = iter;
                    // Cache the simplex.
                    simplex.writeCache(cache);
                    // Apply radii if requested.
                    if (input.useRadii) {
                        var rA = proxyA.m_radius;
                        var rB = proxyB.m_radius;
                        if (output.distance > rA + rB && output.distance > Math1.EPSILON) {
                            // Shapes are still no overlapped.
                            // Move the witness points to the outer surface.
                            output.distance -= rA + rB;
                            var normal = Vec2.sub(output.pointB, output.pointA);
                            normal.normalize();
                            output.pointA.addMul(rA, normal);
                            output.pointB.subMul(rB, normal);
                        } else {
                            // Shapes are overlapped when radii are considered.
                            // Move the witness points to the middle.
                            var p = Vec2.mid(output.pointA, output.pointB);
                            output.pointA.set(p);
                            output.pointB.set(p);
                            output.distance = 0;
                        }
                    }
                }
                /**
 * A distance proxy is used by the GJK algorithm. It encapsulates any shape.
 */ function DistanceProxy() {
                    this.m_buffer = [];
                    // Vec2[2]
                    this.m_vertices = [];
                    // Vec2[]
                    this.m_count = 0;
                    this.m_radius = 0;
                }
                /**
 * Get the vertex count.
 */ DistanceProxy.prototype.getVertexCount = function() {
                    return this.m_count;
                };
                /**
 * Get a vertex by index. Used by Distance.
 */ DistanceProxy.prototype.getVertex = function(index) {
                    _ASSERT && common1.assert(0 <= index && index < this.m_count);
                    return this.m_vertices[index];
                };
                /**
 * Get the supporting vertex index in the given direction.
 */ DistanceProxy.prototype.getSupport = function(d) {
                    var bestIndex = 0;
                    var bestValue = Vec2.dot(this.m_vertices[0], d);
                    for(var i = 0; i < this.m_count; ++i){
                        var value = Vec2.dot(this.m_vertices[i], d);
                        if (value > bestValue) {
                            bestIndex = i;
                            bestValue = value;
                        }
                    }
                    return bestIndex;
                };
                /**
 * Get the supporting vertex in the given direction.
 */ DistanceProxy.prototype.getSupportVertex = function(d) {
                    return this.m_vertices[this.getSupport(d)];
                };
                /**
 * Initialize the proxy using the given shape. The shape must remain in scope
 * while the proxy is in use.
 */ DistanceProxy.prototype.set = function(shape, index) {
                    // TODO remove, use shape instead
                    _ASSERT && common1.assert(typeof shape.computeDistanceProxy === "function");
                    shape.computeDistanceProxy(this, index);
                };
                function SimplexVertex() {
                    this.indexA;
                    // wA index
                    this.indexB;
                    // wB index
                    this.wA = Vec2.zero();
                    // support point in proxyA
                    this.wB = Vec2.zero();
                    // support point in proxyB
                    this.w = Vec2.zero();
                    // wB - wA
                    this.a;
                }
                SimplexVertex.prototype.set = function(v) {
                    this.indexA = v.indexA;
                    this.indexB = v.indexB;
                    this.wA = Vec2.clone(v.wA);
                    this.wB = Vec2.clone(v.wB);
                    this.w = Vec2.clone(v.w);
                    this.a = v.a;
                };
                function Simplex() {
                    this.m_v1 = new SimplexVertex();
                    this.m_v2 = new SimplexVertex();
                    this.m_v3 = new SimplexVertex();
                    this.m_v = [
                        this.m_v1,
                        this.m_v2,
                        this.m_v3
                    ];
                    this.m_count;
                }
                Simplex.prototype.print = function() {
                    if (this.m_count == 3) {
                        return [
                            "+" + this.m_count,
                            this.m_v1.a,
                            this.m_v1.wA.x,
                            this.m_v1.wA.y,
                            this.m_v1.wB.x,
                            this.m_v1.wB.y,
                            this.m_v2.a,
                            this.m_v2.wA.x,
                            this.m_v2.wA.y,
                            this.m_v2.wB.x,
                            this.m_v2.wB.y,
                            this.m_v3.a,
                            this.m_v3.wA.x,
                            this.m_v3.wA.y,
                            this.m_v3.wB.x,
                            this.m_v3.wB.y
                        ].toString();
                    } else if (this.m_count == 2) {
                        return [
                            "+" + this.m_count,
                            this.m_v1.a,
                            this.m_v1.wA.x,
                            this.m_v1.wA.y,
                            this.m_v1.wB.x,
                            this.m_v1.wB.y,
                            this.m_v2.a,
                            this.m_v2.wA.x,
                            this.m_v2.wA.y,
                            this.m_v2.wB.x,
                            this.m_v2.wB.y
                        ].toString();
                    } else if (this.m_count == 1) {
                        return [
                            "+" + this.m_count,
                            this.m_v1.a,
                            this.m_v1.wA.x,
                            this.m_v1.wA.y,
                            this.m_v1.wB.x,
                            this.m_v1.wB.y
                        ].toString();
                    } else {
                        return "+" + this.m_count;
                    }
                };
                // (SimplexCache, DistanceProxy, ...)
                Simplex.prototype.readCache = function(cache, proxyA, transformA, proxyB, transformB) {
                    _ASSERT && common1.assert(cache.count <= 3);
                    // Copy data from cache.
                    this.m_count = cache.count;
                    for(var i = 0; i < this.m_count; ++i){
                        var v = this.m_v[i];
                        v.indexA = cache.indexA[i];
                        v.indexB = cache.indexB[i];
                        var wALocal = proxyA.getVertex(v.indexA);
                        var wBLocal = proxyB.getVertex(v.indexB);
                        v.wA = Transform.mulVec2(transformA, wALocal);
                        v.wB = Transform.mulVec2(transformB, wBLocal);
                        v.w = Vec2.sub(v.wB, v.wA);
                        v.a = 0;
                    }
                    // Compute the new simplex metric, if it is substantially different than
                    // old metric then flush the simplex.
                    if (this.m_count > 1) {
                        var metric1 = cache.metric;
                        var metric2 = this.getMetric();
                        if (metric2 < .5 * metric1 || 2 * metric1 < metric2 || metric2 < Math1.EPSILON) {
                            // Reset the simplex.
                            this.m_count = 0;
                        }
                    }
                    // If the cache is empty or invalid...
                    if (this.m_count == 0) {
                        var v = this.m_v[0];
                        // SimplexVertex
                        v.indexA = 0;
                        v.indexB = 0;
                        var wALocal = proxyA.getVertex(0);
                        var wBLocal = proxyB.getVertex(0);
                        v.wA = Transform.mulVec2(transformA, wALocal);
                        v.wB = Transform.mulVec2(transformB, wBLocal);
                        v.w = Vec2.sub(v.wB, v.wA);
                        v.a = 1;
                        this.m_count = 1;
                    }
                };
                // (SimplexCache)
                Simplex.prototype.writeCache = function(cache) {
                    cache.metric = this.getMetric();
                    cache.count = this.m_count;
                    for(var i = 0; i < this.m_count; ++i){
                        cache.indexA[i] = this.m_v[i].indexA;
                        cache.indexB[i] = this.m_v[i].indexB;
                    }
                };
                Simplex.prototype.getSearchDirection = function() {
                    switch(this.m_count){
                        case 1:
                            return Vec2.neg(this.m_v1.w);
                        case 2:
                            {
                                var e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);
                                var sgn = Vec2.cross(e12, Vec2.neg(this.m_v1.w));
                                if (sgn > 0) {
                                    // Origin is left of e12.
                                    return Vec2.cross(1, e12);
                                } else {
                                    // Origin is right of e12.
                                    return Vec2.cross(e12, 1);
                                }
                            }
                        default:
                            _ASSERT && common1.assert(false);
                            return Vec2.zero();
                    }
                };
                Simplex.prototype.getClosestPoint = function() {
                    switch(this.m_count){
                        case 0:
                            _ASSERT && common1.assert(false);
                            return Vec2.zero();
                        case 1:
                            return Vec2.clone(this.m_v1.w);
                        case 2:
                            return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);
                        case 3:
                            return Vec2.zero();
                        default:
                            _ASSERT && common1.assert(false);
                            return Vec2.zero();
                    }
                };
                Simplex.prototype.getWitnessPoints = function(pA, pB) {
                    switch(this.m_count){
                        case 0:
                            _ASSERT && common1.assert(false);
                            break;
                        case 1:
                            pA.set(this.m_v1.wA);
                            pB.set(this.m_v1.wB);
                            break;
                        case 2:
                            pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
                            pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);
                            break;
                        case 3:
                            pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
                            pA.addMul(this.m_v3.a, this.m_v3.wA);
                            pB.set(pA);
                            break;
                        default:
                            _ASSERT && common1.assert(false);
                            break;
                    }
                };
                Simplex.prototype.getMetric = function() {
                    switch(this.m_count){
                        case 0:
                            _ASSERT && common1.assert(false);
                            return 0;
                        case 1:
                            return 0;
                        case 2:
                            return Vec2.distance(this.m_v1.w, this.m_v2.w);
                        case 3:
                            return Vec2.cross(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w, this.m_v1.w));
                        default:
                            _ASSERT && common1.assert(false);
                            return 0;
                    }
                };
                Simplex.prototype.solve = function() {
                    switch(this.m_count){
                        case 1:
                            break;
                        case 2:
                            this.solve2();
                            break;
                        case 3:
                            this.solve3();
                            break;
                        default:
                            _ASSERT && common1.assert(false);
                    }
                };
                // Solve a line segment using barycentric coordinates.
                //
                // p = a1 * w1 + a2 * w2
                // a1 + a2 = 1
                //
                // The vector from the origin to the closest point on the line is
                // perpendicular to the line.
                // e12 = w2 - w1
                // dot(p, e) = 0
                // a1 * dot(w1, e) + a2 * dot(w2, e) = 0
                //
                // 2-by-2 linear system
                // [1 1 ][a1] = [1]
                // [w1.e12 w2.e12][a2] = [0]
                //
                // Define
                // d12_1 = dot(w2, e12)
                // d12_2 = -dot(w1, e12)
                // d12 = d12_1 + d12_2
                //
                // Solution
                // a1 = d12_1 / d12
                // a2 = d12_2 / d12
                Simplex.prototype.solve2 = function() {
                    var w1 = this.m_v1.w;
                    var w2 = this.m_v2.w;
                    var e12 = Vec2.sub(w2, w1);
                    // w1 region
                    var d12_2 = -Vec2.dot(w1, e12);
                    if (d12_2 <= 0) {
                        // a2 <= 0, so we clamp it to 0
                        this.m_v1.a = 1;
                        this.m_count = 1;
                        return;
                    }
                    // w2 region
                    var d12_1 = Vec2.dot(w2, e12);
                    if (d12_1 <= 0) {
                        // a1 <= 0, so we clamp it to 0
                        this.m_v2.a = 1;
                        this.m_count = 1;
                        this.m_v1.set(this.m_v2);
                        return;
                    }
                    // Must be in e12 region.
                    var inv_d12 = 1 / (d12_1 + d12_2);
                    this.m_v1.a = d12_1 * inv_d12;
                    this.m_v2.a = d12_2 * inv_d12;
                    this.m_count = 2;
                };
                // Possible regions:
                // - points[2]
                // - edge points[0]-points[2]
                // - edge points[1]-points[2]
                // - inside the triangle
                Simplex.prototype.solve3 = function() {
                    var w1 = this.m_v1.w;
                    var w2 = this.m_v2.w;
                    var w3 = this.m_v3.w;
                    // Edge12
                    // [1 1 ][a1] = [1]
                    // [w1.e12 w2.e12][a2] = [0]
                    // a3 = 0
                    var e12 = Vec2.sub(w2, w1);
                    var w1e12 = Vec2.dot(w1, e12);
                    var w2e12 = Vec2.dot(w2, e12);
                    var d12_1 = w2e12;
                    var d12_2 = -w1e12;
                    // Edge13
                    // [1 1 ][a1] = [1]
                    // [w1.e13 w3.e13][a3] = [0]
                    // a2 = 0
                    var e13 = Vec2.sub(w3, w1);
                    var w1e13 = Vec2.dot(w1, e13);
                    var w3e13 = Vec2.dot(w3, e13);
                    var d13_1 = w3e13;
                    var d13_2 = -w1e13;
                    // Edge23
                    // [1 1 ][a2] = [1]
                    // [w2.e23 w3.e23][a3] = [0]
                    // a1 = 0
                    var e23 = Vec2.sub(w3, w2);
                    // Vec2
                    var w2e23 = Vec2.dot(w2, e23);
                    var w3e23 = Vec2.dot(w3, e23);
                    var d23_1 = w3e23;
                    var d23_2 = -w2e23;
                    // Triangle123
                    var n123 = Vec2.cross(e12, e13);
                    var d123_1 = n123 * Vec2.cross(w2, w3);
                    var d123_2 = n123 * Vec2.cross(w3, w1);
                    var d123_3 = n123 * Vec2.cross(w1, w2);
                    // w1 region
                    if (d12_2 <= 0 && d13_2 <= 0) {
                        this.m_v1.a = 1;
                        this.m_count = 1;
                        return;
                    }
                    // e12
                    if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
                        var inv_d12 = 1 / (d12_1 + d12_2);
                        this.m_v1.a = d12_1 * inv_d12;
                        this.m_v2.a = d12_2 * inv_d12;
                        this.m_count = 2;
                        return;
                    }
                    // e13
                    if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
                        var inv_d13 = 1 / (d13_1 + d13_2);
                        this.m_v1.a = d13_1 * inv_d13;
                        this.m_v3.a = d13_2 * inv_d13;
                        this.m_count = 2;
                        this.m_v2.set(this.m_v3);
                        return;
                    }
                    // w2 region
                    if (d12_1 <= 0 && d23_2 <= 0) {
                        this.m_v2.a = 1;
                        this.m_count = 1;
                        this.m_v1.set(this.m_v2);
                        return;
                    }
                    // w3 region
                    if (d13_1 <= 0 && d23_1 <= 0) {
                        this.m_v3.a = 1;
                        this.m_count = 1;
                        this.m_v1.set(this.m_v3);
                        return;
                    }
                    // e23
                    if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
                        var inv_d23 = 1 / (d23_1 + d23_2);
                        this.m_v2.a = d23_1 * inv_d23;
                        this.m_v3.a = d23_2 * inv_d23;
                        this.m_count = 2;
                        this.m_v1.set(this.m_v3);
                        return;
                    }
                    // Must be in triangle123
                    var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
                    this.m_v1.a = d123_1 * inv_d123;
                    this.m_v2.a = d123_2 * inv_d123;
                    this.m_v3.a = d123_3 * inv_d123;
                    this.m_count = 3;
                };
                /**
 * Determine if two generic shapes overlap.
 */ Distance.testOverlap = function(shapeA, indexA, shapeB, indexB, xfA, xfB) {
                    var input = new DistanceInput();
                    input.proxyA.set(shapeA, indexA);
                    input.proxyB.set(shapeB, indexB);
                    input.transformA = xfA;
                    input.transformB = xfB;
                    input.useRadii = true;
                    var cache = new SimplexCache();
                    var output = new DistanceOutput();
                    Distance(output, cache, input);
                    return output.distance < 10 * Math1.EPSILON;
                };
            },
            {
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../common/stats": 26,
                "../util/common": 50
            }
        ],
        14: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var Settings = require1("../Settings");
                var common1 = require1("../util/common");
                var Pool = require1("../util/Pool");
                var Vec2 = require1("../common/Vec2");
                var Math1 = require1("../common/Math");
                var AABB = require1("./AABB");
                module1.exports = DynamicTree;
                var aabbPool = new Pool({
                    create: function() {
                        return new AABB();
                    },
                    release: function(aabb) {
                        aabb.lowerBound.setZero();
                        aabb.upperBound.setZero();
                    }
                });
                var nodePool = new Pool({
                    create: function() {
                        return new TreeNode();
                    }
                });
                /**
 * A node in the dynamic tree. The client does not interact with this directly.
 * 
 * @prop {AABB} aabb Enlarged AABB
 * @prop {integer} height 0: leaf, -1: free node
 */ function TreeNode(id) {
                    this.id = id;
                    this.aabb = new AABB();
                    this.userData = null;
                    this.parent = null;
                    this.child1 = null;
                    this.child2 = null;
                    this.height = -1;
                    this.toString = function() {
                        return this.id + ": " + this.userData;
                    };
                }
                TreeNode.prototype.isLeaf = function() {
                    return this.child1 == null;
                };
                /**
 * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A
 * dynamic tree arranges data in a binary tree to accelerate queries such as
 * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we
 * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger
 * than the client object. This allows the client object to move by small
 * amounts without triggering a tree update.
 * 
 * Nodes are pooled and relocatable, so we use node indices rather than
 * pointers.
 */ function DynamicTree() {
                    this.m_root = null;
                    this.m_nodes = {};
                    this.m_lastProxyId = 0;
                }
                /**
 * Get proxy user data.
 * 
 * @return the proxy user data or 0 if the id is invalid.
 */ DynamicTree.prototype.getUserData = function(id) {
                    var node = this.m_nodes[id];
                    _ASSERT && common1.assert(!!node);
                    return node.userData;
                };
                /**
 * Get the fat AABB for a node id.
 * 
 * @return the proxy user data or 0 if the id is invalid.
 */ DynamicTree.prototype.getFatAABB = function(id) {
                    var node = this.m_nodes[id];
                    _ASSERT && common1.assert(!!node);
                    return node.aabb;
                };
                DynamicTree.prototype.allocateNode = function() {
                    var node = nodePool.allocate();
                    node.id = ++this.m_lastProxyId;
                    node.userData = null;
                    node.parent = null;
                    node.child1 = null;
                    node.child2 = null;
                    node.height = -1;
                    this.m_nodes[node.id] = node;
                    return node;
                };
                DynamicTree.prototype.freeNode = function(node) {
                    nodePool.release(node);
                    node.height = -1;
                    delete this.m_nodes[node.id];
                };
                /**
 * Create a proxy in the tree as a leaf node. We return the index of the node
 * instead of a pointer so that we can grow the node pool.
 * 
 * Create a proxy. Provide a tight fitting AABB and a userData pointer.
 */ DynamicTree.prototype.createProxy = function(aabb, userData) {
                    _ASSERT && common1.assert(AABB.isValid(aabb));
                    var node = this.allocateNode();
                    node.aabb.set(aabb);
                    // Fatten the aabb.
                    node.aabb.extend(Settings.aabbExtension);
                    node.userData = userData;
                    node.height = 0;
                    this.insertLeaf(node);
                    return node.id;
                };
                /**
 * Destroy a proxy. This asserts if the id is invalid.
 */ DynamicTree.prototype.destroyProxy = function(id) {
                    var node = this.m_nodes[id];
                    _ASSERT && common1.assert(!!node);
                    _ASSERT && common1.assert(node.isLeaf());
                    this.removeLeaf(node);
                    this.freeNode(node);
                };
                /**
 * Move a proxy with a swepted AABB. If the proxy has moved outside of its
 * fattened AABB, then the proxy is removed from the tree and re-inserted.
 * Otherwise the function returns immediately.
 * 
 * @param id
 * @param aabb
 * @param {Vec2} d Displacement
 * 
 * @return true if the proxy was re-inserted.
 */ DynamicTree.prototype.moveProxy = function(id, aabb, d) {
                    _ASSERT && common1.assert(AABB.isValid(aabb));
                    _ASSERT && common1.assert(!d || Vec2.isValid(d));
                    var node = this.m_nodes[id];
                    _ASSERT && common1.assert(!!node);
                    _ASSERT && common1.assert(node.isLeaf());
                    if (node.aabb.contains(aabb)) {
                        return false;
                    }
                    this.removeLeaf(node);
                    node.aabb.set(aabb);
                    // Extend AABB.
                    aabb = node.aabb;
                    AABB.extend(aabb, Settings.aabbExtension);
                    // Predict AABB displacement.
                    // var d = Vec2.mul(Settings.aabbMultiplier, displacement);
                    if (d.x < 0) {
                        aabb.lowerBound.x += d.x * Settings.aabbMultiplier;
                    } else {
                        aabb.upperBound.x += d.x * Settings.aabbMultiplier;
                    }
                    if (d.y < 0) {
                        aabb.lowerBound.y += d.y * Settings.aabbMultiplier;
                    } else {
                        aabb.upperBound.y += d.y * Settings.aabbMultiplier;
                    }
                    this.insertLeaf(node);
                    return true;
                };
                DynamicTree.prototype.insertLeaf = function(leaf) {
                    _ASSERT && common1.assert(AABB.isValid(leaf.aabb));
                    if (this.m_root == null) {
                        this.m_root = leaf;
                        this.m_root.parent = null;
                        return;
                    }
                    // Find the best sibling for this node
                    var leafAABB = leaf.aabb;
                    var index = this.m_root;
                    while(index.isLeaf() == false){
                        var child1 = index.child1;
                        var child2 = index.child2;
                        var area = index.aabb.getPerimeter();
                        var combinedAABB = aabbPool.allocate();
                        combinedAABB.combine(index.aabb, leafAABB);
                        var combinedArea = combinedAABB.getPerimeter();
                        aabbPool.release(combinedAABB);
                        // Cost of creating a new parent for this node and the new leaf
                        var cost = 2 * combinedArea;
                        // Minimum cost of pushing the leaf further down the tree
                        var inheritanceCost = 2 * (combinedArea - area);
                        // Cost of descending into child1
                        var cost1;
                        if (child1.isLeaf()) {
                            var aabb = aabbPool.allocate();
                            aabb.combine(leafAABB, child1.aabb);
                            cost1 = aabb.getPerimeter() + inheritanceCost;
                            aabbPool.release(aabb);
                        } else {
                            var aabb = aabbPool.allocate();
                            aabb.combine(leafAABB, child1.aabb);
                            var oldArea = child1.aabb.getPerimeter();
                            var newArea = aabb.getPerimeter();
                            cost1 = newArea - oldArea + inheritanceCost;
                            aabbPool.release(aabb);
                        }
                        // Cost of descending into child2
                        var cost2;
                        if (child2.isLeaf()) {
                            var aabb = aabbPool.allocate();
                            aabb.combine(leafAABB, child2.aabb);
                            cost2 = aabb.getPerimeter() + inheritanceCost;
                            aabbPool.release(aabb);
                        } else {
                            var aabb = aabbPool.allocate();
                            aabb.combine(leafAABB, child2.aabb);
                            var oldArea = child2.aabb.getPerimeter();
                            var newArea = aabb.getPerimeter();
                            cost2 = newArea - oldArea + inheritanceCost;
                            aabbPool.release(aabb);
                        }
                        // Descend according to the minimum cost.
                        if (cost < cost1 && cost < cost2) {
                            break;
                        }
                        // Descend
                        if (cost1 < cost2) {
                            index = child1;
                        } else {
                            index = child2;
                        }
                    }
                    var sibling = index;
                    // Create a new parent.
                    var oldParent = sibling.parent;
                    var newParent = this.allocateNode();
                    newParent.parent = oldParent;
                    newParent.userData = null;
                    newParent.aabb.combine(leafAABB, sibling.aabb);
                    newParent.height = sibling.height + 1;
                    if (oldParent != null) {
                        // The sibling was not the root.
                        if (oldParent.child1 == sibling) {
                            oldParent.child1 = newParent;
                        } else {
                            oldParent.child2 = newParent;
                        }
                        newParent.child1 = sibling;
                        newParent.child2 = leaf;
                        sibling.parent = newParent;
                        leaf.parent = newParent;
                    } else {
                        // The sibling was the root.
                        newParent.child1 = sibling;
                        newParent.child2 = leaf;
                        sibling.parent = newParent;
                        leaf.parent = newParent;
                        this.m_root = newParent;
                    }
                    // Walk back up the tree fixing heights and AABBs
                    index = leaf.parent;
                    while(index != null){
                        index = this.balance(index);
                        var child1 = index.child1;
                        var child2 = index.child2;
                        _ASSERT && common1.assert(child1 != null);
                        _ASSERT && common1.assert(child2 != null);
                        index.height = 1 + Math1.max(child1.height, child2.height);
                        index.aabb.combine(child1.aabb, child2.aabb);
                        index = index.parent;
                    }
                };
                DynamicTree.prototype.removeLeaf = function(leaf) {
                    if (leaf == this.m_root) {
                        this.m_root = null;
                        return;
                    }
                    var parent = leaf.parent;
                    var grandParent = parent.parent;
                    var sibling;
                    if (parent.child1 == leaf) {
                        sibling = parent.child2;
                    } else {
                        sibling = parent.child1;
                    }
                    if (grandParent != null) {
                        // Destroy parent and connect sibling to grandParent.
                        if (grandParent.child1 == parent) {
                            grandParent.child1 = sibling;
                        } else {
                            grandParent.child2 = sibling;
                        }
                        sibling.parent = grandParent;
                        this.freeNode(parent);
                        // Adjust ancestor bounds.
                        var index = grandParent;
                        while(index != null){
                            index = this.balance(index);
                            var child1 = index.child1;
                            var child2 = index.child2;
                            index.aabb.combine(child1.aabb, child2.aabb);
                            index.height = 1 + Math1.max(child1.height, child2.height);
                            index = index.parent;
                        }
                    } else {
                        this.m_root = sibling;
                        sibling.parent = null;
                        this.freeNode(parent);
                    }
                };
                /**
 * Perform a left or right rotation if node A is imbalanced. Returns the new
 * root index.
 */ DynamicTree.prototype.balance = function(iA) {
                    _ASSERT && common1.assert(iA != null);
                    var A = iA;
                    if (A.isLeaf() || A.height < 2) {
                        return iA;
                    }
                    var B = A.child1;
                    var C = A.child2;
                    var balance = C.height - B.height;
                    // Rotate C up
                    if (balance > 1) {
                        var F = C.child1;
                        var G = C.child2;
                        // Swap A and C
                        C.child1 = A;
                        C.parent = A.parent;
                        A.parent = C;
                        // A's old parent should point to C
                        if (C.parent != null) {
                            if (C.parent.child1 == iA) {
                                C.parent.child1 = C;
                            } else {
                                C.parent.child2 = C;
                            }
                        } else {
                            this.m_root = C;
                        }
                        // Rotate
                        if (F.height > G.height) {
                            C.child2 = F;
                            A.child2 = G;
                            G.parent = A;
                            A.aabb.combine(B.aabb, G.aabb);
                            C.aabb.combine(A.aabb, F.aabb);
                            A.height = 1 + Math1.max(B.height, G.height);
                            C.height = 1 + Math1.max(A.height, F.height);
                        } else {
                            C.child2 = G;
                            A.child2 = F;
                            F.parent = A;
                            A.aabb.combine(B.aabb, F.aabb);
                            C.aabb.combine(A.aabb, G.aabb);
                            A.height = 1 + Math1.max(B.height, F.height);
                            C.height = 1 + Math1.max(A.height, G.height);
                        }
                        return C;
                    }
                    // Rotate B up
                    if (balance < -1) {
                        var D = B.child1;
                        var E = B.child2;
                        // Swap A and B
                        B.child1 = A;
                        B.parent = A.parent;
                        A.parent = B;
                        // A's old parent should point to B
                        if (B.parent != null) {
                            if (B.parent.child1 == A) {
                                B.parent.child1 = B;
                            } else {
                                B.parent.child2 = B;
                            }
                        } else {
                            this.m_root = B;
                        }
                        // Rotate
                        if (D.height > E.height) {
                            B.child2 = D;
                            A.child1 = E;
                            E.parent = A;
                            A.aabb.combine(C.aabb, E.aabb);
                            B.aabb.combine(A.aabb, D.aabb);
                            A.height = 1 + Math1.max(C.height, E.height);
                            B.height = 1 + Math1.max(A.height, D.height);
                        } else {
                            B.child2 = E;
                            A.child1 = D;
                            D.parent = A;
                            A.aabb.combine(C.aabb, D.aabb);
                            B.aabb.combine(A.aabb, E.aabb);
                            A.height = 1 + Math1.max(C.height, D.height);
                            B.height = 1 + Math1.max(A.height, E.height);
                        }
                        return B;
                    }
                    return A;
                };
                /**
 * Compute the height of the binary tree in O(N) time. Should not be called
 * often.
 */ DynamicTree.prototype.getHeight = function() {
                    if (this.m_root == null) {
                        return 0;
                    }
                    return this.m_root.height;
                };
                /**
 * Get the ratio of the sum of the node areas to the root area.
 */ DynamicTree.prototype.getAreaRatio = function() {
                    if (this.m_root == null) {
                        return 0;
                    }
                    var root = this.m_root;
                    var rootArea = root.aabb.getPerimeter();
                    var totalArea = 0;
                    var node, it = iteratorPool.allocate().preorder();
                    while(node = it.next()){
                        if (node.height < 0) {
                            continue;
                        }
                        totalArea += node.aabb.getPerimeter();
                    }
                    iteratorPool.release(it);
                    return totalArea / rootArea;
                };
                /**
 * Compute the height of a sub-tree.
 */ DynamicTree.prototype.computeHeight = function(id) {
                    var node;
                    if (typeof id !== "undefined") {
                        node = this.m_nodes[id];
                    } else {
                        node = this.m_root;
                    }
                    // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);
                    if (node.isLeaf()) {
                        return 0;
                    }
                    var height1 = ComputeHeight(node.child1);
                    var height2 = ComputeHeight(node.child2);
                    return 1 + Math1.max(height1, height2);
                };
                DynamicTree.prototype.validateStructure = function(node) {
                    if (node == null) {
                        return;
                    }
                    if (node == this.m_root) {
                        _ASSERT && common1.assert(node.parent == null);
                    }
                    var child1 = node.child1;
                    var child2 = node.child2;
                    if (node.isLeaf()) {
                        _ASSERT && common1.assert(child1 == null);
                        _ASSERT && common1.assert(child2 == null);
                        _ASSERT && common1.assert(node.height == 0);
                        return;
                    }
                    // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
                    // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);
                    _ASSERT && common1.assert(child1.parent == node);
                    _ASSERT && common1.assert(child2.parent == node);
                    this.validateStructure(child1);
                    this.validateStructure(child2);
                };
                DynamicTree.prototype.validateMetrics = function(node) {
                    if (node == null) {
                        return;
                    }
                    var child1 = node.child1;
                    var child2 = node.child2;
                    if (node.isLeaf()) {
                        _ASSERT && common1.assert(child1 == null);
                        _ASSERT && common1.assert(child2 == null);
                        _ASSERT && common1.assert(node.height == 0);
                        return;
                    }
                    // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
                    // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);
                    var height1 = this.m_nodes[child1].height;
                    var height2 = this.m_nodes[child2].height;
                    var height = 1 + Math1.max(height1, height2);
                    _ASSERT && common1.assert(node.height == height);
                    _ASSERT && common1.assert(AABB.areEqual(new AABB().combine(child1.aabb, child2.aabb), node.aabb));
                    this.validateMetrics(child1);
                    this.validateMetrics(child2);
                };
                // Validate this tree. For testing.
                DynamicTree.prototype.validate = function() {
                    ValidateStructure(this.m_root);
                    ValidateMetrics(this.m_root);
                    _ASSERT && common1.assert(this.getHeight() == this.computeHeight());
                };
                /**
 * Get the maximum balance of an node in the tree. The balance is the difference
 * in height of the two children of a node.
 */ DynamicTree.prototype.getMaxBalance = function() {
                    var maxBalance = 0;
                    var node, it = iteratorPool.allocate().preorder();
                    while(node = it.next()){
                        if (node.height <= 1) {
                            continue;
                        }
                        _ASSERT && common1.assert(node.isLeaf() == false);
                        var balance = Math1.abs(node.child2.height - node.child1.height);
                        maxBalance = Math1.max(maxBalance, balance);
                    }
                    iteratorPool.release(it);
                    return maxBalance;
                };
                /**
 * Build an optimal tree. Very expensive. For testing.
 */ DynamicTree.prototype.rebuildBottomUp = function() {
                    var nodes = [];
                    var count = 0;
                    // Build array of leaves. Free the rest.
                    var node, it = iteratorPool.allocate().preorder();
                    while(node = it.next()){
                        if (node.height < 0) {
                            continue;
                        }
                        if (node.isLeaf()) {
                            node.parent = null;
                            nodes[count] = node;
                            ++count;
                        } else {
                            this.freeNode(node);
                        }
                    }
                    iteratorPool.release(it);
                    while(count > 1){
                        var minCost = Infinity;
                        var iMin = -1, jMin = -1;
                        for(var i = 0; i < count; ++i){
                            var aabbi = nodes[i].aabb;
                            for(var j = i + 1; j < count; ++j){
                                var aabbj = nodes[j].aabb;
                                var b = aabbPool.allocate();
                                b.combine(aabbi, aabbj);
                                var cost = b.getPerimeter();
                                if (cost < minCost) {
                                    iMin = i;
                                    jMin = j;
                                    minCost = cost;
                                }
                                aabbPool.release(b);
                            }
                        }
                        var child1 = nodes[iMin];
                        var child2 = nodes[jMin];
                        var parent = this.allocateNode();
                        parent.child1 = child1;
                        parent.child2 = child2;
                        parent.height = 1 + Math1.max(child1.height, child2.height);
                        parent.aabb.combine(child1.aabb, child2.aabb);
                        parent.parent = null;
                        child1.parent = parent;
                        child2.parent = parent;
                        nodes[jMin] = nodes[count - 1];
                        nodes[iMin] = parent;
                        --count;
                    }
                    this.m_root = nodes[0];
                    this.validate();
                };
                /**
 * Shift the world origin. Useful for large worlds. The shift formula is:
 * position -= newOrigin
 * 
 * @param newOrigin The new origin with respect to the old origin
 */ DynamicTree.prototype.shiftOrigin = function(newOrigin) {
                    // Build array of leaves. Free the rest.
                    var node, it = iteratorPool.allocate().preorder();
                    while(node = it.next()){
                        var aabb = node.aabb;
                        aabb.lowerBound.x -= newOrigin.x;
                        aabb.lowerBound.y -= newOrigin.y;
                        aabb.upperBound.x -= newOrigin.x;
                        aabb.upperBound.y -= newOrigin.y;
                    }
                    iteratorPool.release(it);
                };
                /**
 * @function {DynamicTree~queryCallback}
 * 
 * @param id Node id.
 */ /**
 * Query an AABB for overlapping proxies. The callback class is called for each
 * proxy that overlaps the supplied AABB.
 * 
 * @param {DynamicTree~queryCallback} queryCallback
 */ DynamicTree.prototype.query = function(aabb, queryCallback) {
                    _ASSERT && common1.assert(typeof queryCallback === "function");
                    var stack = stackPool.allocate();
                    stack.push(this.m_root);
                    while(stack.length > 0){
                        var node = stack.pop();
                        if (node == null) {
                            continue;
                        }
                        if (AABB.testOverlap(node.aabb, aabb)) {
                            if (node.isLeaf()) {
                                var proceed = queryCallback(node.id);
                                if (proceed == false) {
                                    return;
                                }
                            } else {
                                stack.push(node.child1);
                                stack.push(node.child2);
                            }
                        }
                    }
                    stackPool.release(stack);
                };
                /**
 * Ray-cast against the proxies in the tree. This relies on the callback to
 * perform a exact ray-cast in the case were the proxy contains a shape. The
 * callback also performs the any collision filtering. This has performance
 * roughly equal to k * log(n), where k is the number of collisions and n is the
 * number of proxies in the tree.
 * 
 * @param input The ray-cast input data. The ray extends from p1 to p1 +
 *          maxFraction * (p2 - p1).
 * @param rayCastCallback A function that is called for each proxy that is hit by
 *          the ray.
 */ DynamicTree.prototype.rayCast = function(input, rayCastCallback) {
                    // TODO GC
                    _ASSERT && common1.assert(typeof rayCastCallback === "function");
                    var p1 = input.p1;
                    var p2 = input.p2;
                    var r = Vec2.sub(p2, p1);
                    _ASSERT && common1.assert(r.lengthSquared() > 0);
                    r.normalize();
                    // v is perpendicular to the segment.
                    var v = Vec2.cross(1, r);
                    var abs_v = Vec2.abs(v);
                    // Separating axis for segment (Gino, p80).
                    // |dot(v, p1 - c)| > dot(|v|, h)
                    var maxFraction = input.maxFraction;
                    // Build a bounding box for the segment.
                    var segmentAABB = new AABB();
                    var t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);
                    segmentAABB.combinePoints(p1, t);
                    var stack = stackPool.allocate();
                    var subInput = inputPool.allocate();
                    stack.push(this.m_root);
                    while(stack.length > 0){
                        var node = stack.pop();
                        if (node == null) {
                            continue;
                        }
                        if (AABB.testOverlap(node.aabb, segmentAABB) == false) {
                            continue;
                        }
                        // Separating axis for segment (Gino, p80).
                        // |dot(v, p1 - c)| > dot(|v|, h)
                        var c = node.aabb.getCenter();
                        var h = node.aabb.getExtents();
                        var separation = Math1.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);
                        if (separation > 0) {
                            continue;
                        }
                        if (node.isLeaf()) {
                            subInput.p1 = Vec2.clone(input.p1);
                            subInput.p2 = Vec2.clone(input.p2);
                            subInput.maxFraction = maxFraction;
                            var value = rayCastCallback(subInput, node.id);
                            if (value == 0) {
                                // The client has terminated the ray cast.
                                return;
                            }
                            if (value > 0) {
                                // update segment bounding box.
                                maxFraction = value;
                                t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);
                                segmentAABB.combinePoints(p1, t);
                            }
                        } else {
                            stack.push(node.child1);
                            stack.push(node.child2);
                        }
                    }
                    stackPool.release(stack);
                    inputPool.release(subInput);
                };
                var inputPool = new Pool({
                    create: function() {
                        return {};
                    },
                    release: function(stack) {}
                });
                var stackPool = new Pool({
                    create: function() {
                        return [];
                    },
                    release: function(stack) {
                        stack.length = 0;
                    }
                });
                var iteratorPool = new Pool({
                    create: function() {
                        return new Iterator();
                    },
                    release: function(iterator) {
                        iterator.close();
                    }
                });
                function Iterator() {
                    var parents = [];
                    var states = [];
                    return {
                        preorder: function(root) {
                            parents.length = 0;
                            parents.push(root);
                            states.length = 0;
                            states.push(0);
                            return this;
                        },
                        next: function() {
                            while(parents.length > 0){
                                var i = parents.length - 1;
                                var node = parents[i];
                                if (states[i] === 0) {
                                    states[i] = 1;
                                    return node;
                                }
                                if (states[i] === 1) {
                                    states[i] = 2;
                                    if (node.child1) {
                                        parents.push(node.child1);
                                        states.push(1);
                                        return node.child1;
                                    }
                                }
                                if (states[i] === 2) {
                                    states[i] = 3;
                                    if (node.child2) {
                                        parents.push(node.child2);
                                        states.push(1);
                                        return node.child2;
                                    }
                                }
                                parents.pop();
                                states.pop();
                            }
                        },
                        close: function() {
                            parents.length = 0;
                        }
                    };
                }
            },
            {
                "../Settings": 7,
                "../common/Math": 18,
                "../common/Vec2": 23,
                "../util/Pool": 48,
                "../util/common": 50,
                "./AABB": 11
            }
        ],
        15: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = TimeOfImpact;
                module1.exports.Input = TOIInput;
                module1.exports.Output = TOIOutput;
                var Settings = require1("../Settings");
                var common1 = require1("../util/common");
                var Timer = require1("../util/Timer");
                var stats = require1("../common/stats");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Distance = require1("./Distance");
                var DistanceInput = Distance.Input;
                var DistanceOutput = Distance.Output;
                var DistanceProxy = Distance.Proxy;
                var SimplexCache = Distance.Cache;
                /**
 * Input parameters for TimeOfImpact.
 * 
 * @prop {DistanceProxy} proxyA
 * @prop {DistanceProxy} proxyB
 * @prop {Sweep} sweepA
 * @prop {Sweep} sweepB
 * @prop tMax defines sweep interval [0, tMax]
 */ function TOIInput() {
                    this.proxyA = new DistanceProxy();
                    this.proxyB = new DistanceProxy();
                    this.sweepA = new Sweep();
                    this.sweepB = new Sweep();
                    this.tMax;
                }
                // TOIOutput State
                TOIOutput.e_unknown = 0;
                TOIOutput.e_failed = 1;
                TOIOutput.e_overlapped = 2;
                TOIOutput.e_touching = 3;
                TOIOutput.e_separated = 4;
                /**
 * Output parameters for TimeOfImpact.
 * 
 * @prop state
 * @prop t
 */ function TOIOutput() {
                    this.state;
                    this.t;
                }
                stats.toiTime = 0;
                stats.toiMaxTime = 0;
                stats.toiCalls = 0;
                stats.toiIters = 0;
                stats.toiMaxIters = 0;
                stats.toiRootIters = 0;
                stats.toiMaxRootIters = 0;
                /**
 * Compute the upper bound on time before two shapes penetrate. Time is
 * represented as a fraction between [0,tMax]. This uses a swept separating axis
 * and may miss some intermediate, non-tunneling collision. If you change the
 * time interval, you should call this function again.
 * 
 * Note: use Distance to compute the contact point and normal at the time of
 * impact.
 * 
 * CCD via the local separating axis method. This seeks progression by computing
 * the largest time at which separation is maintained.
 */ function TimeOfImpact(output, input) {
                    var timer = Timer.now();
                    ++stats.toiCalls;
                    output.state = TOIOutput.e_unknown;
                    output.t = input.tMax;
                    var proxyA = input.proxyA;
                    // DistanceProxy
                    var proxyB = input.proxyB;
                    // DistanceProxy
                    var sweepA = input.sweepA;
                    // Sweep
                    var sweepB = input.sweepB;
                    // Sweep
                    // Large rotations can make the root finder fail, so we normalize the
                    // sweep angles.
                    sweepA.normalize();
                    sweepB.normalize();
                    var tMax = input.tMax;
                    var totalRadius = proxyA.m_radius + proxyB.m_radius;
                    var target = Math1.max(Settings.linearSlop, totalRadius - 3 * Settings.linearSlop);
                    var tolerance = .25 * Settings.linearSlop;
                    _ASSERT && common1.assert(target > tolerance);
                    var t1 = 0;
                    var k_maxIterations = Settings.maxTOIIterations;
                    var iter = 0;
                    // Prepare input for distance query.
                    var cache = new SimplexCache();
                    var distanceInput = new DistanceInput();
                    distanceInput.proxyA = input.proxyA;
                    distanceInput.proxyB = input.proxyB;
                    distanceInput.useRadii = false;
                    // The outer loop progressively attempts to compute new separating axes.
                    // This loop terminates when an axis is repeated (no progress is made).
                    for(;;){
                        var xfA = Transform.identity();
                        var xfB = Transform.identity();
                        sweepA.getTransform(xfA, t1);
                        sweepB.getTransform(xfB, t1);
                        // Get the distance between shapes. We can also use the results
                        // to get a separating axis.
                        distanceInput.transformA = xfA;
                        distanceInput.transformB = xfB;
                        var distanceOutput = new DistanceOutput();
                        Distance(distanceOutput, cache, distanceInput);
                        // If the shapes are overlapped, we give up on continuous collision.
                        if (distanceOutput.distance <= 0) {
                            // Failure!
                            output.state = TOIOutput.e_overlapped;
                            output.t = 0;
                            break;
                        }
                        if (distanceOutput.distance < target + tolerance) {
                            // Victory!
                            output.state = TOIOutput.e_touching;
                            output.t = t1;
                            break;
                        }
                        // Initialize the separating axis.
                        var fcn = new SeparationFunction();
                        fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
                        if (false) {
                            // Dump the curve seen by the root finder
                            var N = 100;
                            var dx = 1 / N;
                            var xs = [];
                            // [ N + 1 ];
                            var fs = [];
                            // [ N + 1 ];
                            var x = 0;
                            for(var i = 0; i <= N; ++i){
                                sweepA.getTransform(xfA, x);
                                sweepB.getTransform(xfB, x);
                                var f = fcn.evaluate(xfA, xfB) - target;
                                printf("%g %g\n", x, f);
                                xs[i] = x;
                                fs[i] = f;
                                x += dx;
                            }
                        }
                        // Compute the TOI on the separating axis. We do this by successively
                        // resolving the deepest point. This loop is bounded by the number of
                        // vertices.
                        var done = false;
                        var t2 = tMax;
                        var pushBackIter = 0;
                        for(;;){
                            // Find the deepest point at t2. Store the witness point indices.
                            var s2 = fcn.findMinSeparation(t2);
                            var indexA = fcn.indexA;
                            var indexB = fcn.indexB;
                            // Is the final configuration separated?
                            if (s2 > target + tolerance) {
                                // Victory!
                                output.state = TOIOutput.e_separated;
                                output.t = tMax;
                                done = true;
                                break;
                            }
                            // Has the separation reached tolerance?
                            if (s2 > target - tolerance) {
                                // Advance the sweeps
                                t1 = t2;
                                break;
                            }
                            // Compute the initial separation of the witness points.
                            var s1 = fcn.evaluate(t1);
                            var indexA = fcn.indexA;
                            var indexB = fcn.indexB;
                            // Check for initial overlap. This might happen if the root finder
                            // runs out of iterations.
                            if (s1 < target - tolerance) {
                                output.state = TOIOutput.e_failed;
                                output.t = t1;
                                done = true;
                                break;
                            }
                            // Check for touching
                            if (s1 <= target + tolerance) {
                                // Victory! t1 should hold the TOI (could be 0.0).
                                output.state = TOIOutput.e_touching;
                                output.t = t1;
                                done = true;
                                break;
                            }
                            // Compute 1D root of: f(x) - target = 0
                            var rootIterCount = 0;
                            var a1 = t1, a2 = t2;
                            for(;;){
                                // Use a mix of the secant rule and bisection.
                                var t;
                                if (rootIterCount & 1) {
                                    // Secant rule to improve convergence.
                                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
                                } else {
                                    // Bisection to guarantee progress.
                                    t = .5 * (a1 + a2);
                                }
                                ++rootIterCount;
                                ++stats.toiRootIters;
                                var s = fcn.evaluate(t);
                                var indexA = fcn.indexA;
                                var indexB = fcn.indexB;
                                if (Math1.abs(s - target) < tolerance) {
                                    // t2 holds a tentative value for t1
                                    t2 = t;
                                    break;
                                }
                                // Ensure we continue to bracket the root.
                                if (s > target) {
                                    a1 = t;
                                    s1 = s;
                                } else {
                                    a2 = t;
                                    s2 = s;
                                }
                                if (rootIterCount == 50) {
                                    break;
                                }
                            }
                            stats.toiMaxRootIters = Math1.max(stats.toiMaxRootIters, rootIterCount);
                            ++pushBackIter;
                            if (pushBackIter == Settings.maxPolygonVertices) {
                                break;
                            }
                        }
                        ++iter;
                        ++stats.toiIters;
                        if (done) {
                            break;
                        }
                        if (iter == k_maxIterations) {
                            // Root finder got stuck. Semi-victory.
                            output.state = TOIOutput.e_failed;
                            output.t = t1;
                            break;
                        }
                    }
                    stats.toiMaxIters = Math1.max(stats.toiMaxIters, iter);
                    var time = Timer.diff(timer);
                    stats.toiMaxTime = Math1.max(stats.toiMaxTime, time);
                    stats.toiTime += time;
                }
                // SeparationFunction Type
                var e_points = 1;
                var e_faceA = 2;
                var e_faceB = 3;
                function SeparationFunction() {
                    this.m_proxyA = new DistanceProxy();
                    this.m_proxyB = new DistanceProxy();
                    this.m_sweepA;
                    // Sweep
                    this.m_sweepB;
                    // Sweep
                    this.m_type;
                    this.m_localPoint = Vec2.zero();
                    this.m_axis = Vec2.zero();
                }
                // TODO_ERIN might not need to return the separation
                /**
 * @param {SimplexCache} cache
 * @param {DistanceProxy} proxyA
 * @param {Sweep} sweepA
 * @param {DistanceProxy} proxyB
 * @param {Sweep} sweepB
 * @param {float} t1
 */ SeparationFunction.prototype.initialize = function(cache, proxyA, sweepA, proxyB, sweepB, t1) {
                    this.m_proxyA = proxyA;
                    this.m_proxyB = proxyB;
                    var count = cache.count;
                    _ASSERT && common1.assert(0 < count && count < 3);
                    this.m_sweepA = sweepA;
                    this.m_sweepB = sweepB;
                    var xfA = Transform.identity();
                    var xfB = Transform.identity();
                    this.m_sweepA.getTransform(xfA, t1);
                    this.m_sweepB.getTransform(xfB, t1);
                    if (count == 1) {
                        this.m_type = e_points;
                        var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);
                        var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
                        var pointA = Transform.mulVec2(xfA, localPointA);
                        var pointB = Transform.mulVec2(xfB, localPointB);
                        this.m_axis.setCombine(1, pointB, -1, pointA);
                        var s = this.m_axis.normalize();
                        return s;
                    } else if (cache.indexA[0] == cache.indexA[1]) {
                        // Two points on B and one on A.
                        this.m_type = e_faceB;
                        var localPointB1 = proxyB.getVertex(cache.indexB[0]);
                        var localPointB2 = proxyB.getVertex(cache.indexB[1]);
                        this.m_axis = Vec2.cross(Vec2.sub(localPointB2, localPointB1), 1);
                        this.m_axis.normalize();
                        var normal = Rot.mulVec2(xfB.q, this.m_axis);
                        this.m_localPoint = Vec2.mid(localPointB1, localPointB2);
                        var pointB = Transform.mulVec2(xfB, this.m_localPoint);
                        var localPointA = proxyA.getVertex(cache.indexA[0]);
                        var pointA = Transform.mulVec2(xfA, localPointA);
                        var s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);
                        if (s < 0) {
                            this.m_axis = Vec2.neg(this.m_axis);
                            s = -s;
                        }
                        return s;
                    } else {
                        // Two points on A and one or two points on B.
                        this.m_type = e_faceA;
                        var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);
                        var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);
                        this.m_axis = Vec2.cross(Vec2.sub(localPointA2, localPointA1), 1);
                        this.m_axis.normalize();
                        var normal = Rot.mulVec2(xfA.q, this.m_axis);
                        this.m_localPoint = Vec2.mid(localPointA1, localPointA2);
                        var pointA = Transform.mulVec2(xfA, this.m_localPoint);
                        var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
                        var pointB = Transform.mulVec2(xfB, localPointB);
                        var s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);
                        if (s < 0) {
                            this.m_axis = Vec2.neg(this.m_axis);
                            s = -s;
                        }
                        return s;
                    }
                };
                SeparationFunction.prototype.compute = function(find, t) {
                    // It was findMinSeparation and evaluate
                    var xfA = Transform.identity();
                    var xfB = Transform.identity();
                    this.m_sweepA.getTransform(xfA, t);
                    this.m_sweepB.getTransform(xfB, t);
                    switch(this.m_type){
                        case e_points:
                            {
                                if (find) {
                                    var axisA = Rot.mulTVec2(xfA.q, this.m_axis);
                                    var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));
                                    this.indexA = this.m_proxyA.getSupport(axisA);
                                    this.indexB = this.m_proxyB.getSupport(axisB);
                                }
                                var localPointA = this.m_proxyA.getVertex(this.indexA);
                                var localPointB = this.m_proxyB.getVertex(this.indexB);
                                var pointA = Transform.mulVec2(xfA, localPointA);
                                var pointB = Transform.mulVec2(xfB, localPointB);
                                var sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);
                                return sep;
                            }
                        case e_faceA:
                            {
                                var normal = Rot.mulVec2(xfA.q, this.m_axis);
                                var pointA = Transform.mulVec2(xfA, this.m_localPoint);
                                if (find) {
                                    var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));
                                    this.indexA = -1;
                                    this.indexB = this.m_proxyB.getSupport(axisB);
                                }
                                var localPointB = this.m_proxyB.getVertex(this.indexB);
                                var pointB = Transform.mulVec2(xfB, localPointB);
                                var sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);
                                return sep;
                            }
                        case e_faceB:
                            {
                                var normal = Rot.mulVec2(xfB.q, this.m_axis);
                                var pointB = Transform.mulVec2(xfB, this.m_localPoint);
                                if (find) {
                                    var axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));
                                    this.indexB = -1;
                                    this.indexA = this.m_proxyA.getSupport(axisA);
                                }
                                var localPointA = this.m_proxyA.getVertex(this.indexA);
                                var pointA = Transform.mulVec2(xfA, localPointA);
                                var sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);
                                return sep;
                            }
                        default:
                            _ASSERT && common1.assert(false);
                            if (find) {
                                this.indexA = -1;
                                this.indexB = -1;
                            }
                            return 0;
                    }
                };
                SeparationFunction.prototype.findMinSeparation = function(t) {
                    return this.compute(true, t);
                };
                SeparationFunction.prototype.evaluate = function(t) {
                    return this.compute(false, t);
                };
            },
            {
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../common/stats": 26,
                "../util/Timer": 49,
                "../util/common": 50,
                "./Distance": 13
            }
        ],
        16: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Mat22;
                var common1 = require1("../util/common");
                var Math1 = require1("./Math");
                var Vec2 = require1("./Vec2");
                /**
 * A 2-by-2 matrix. Stored in column-major order.
 */ function Mat22(a, b, c, d) {
                    if (typeof a === "object" && a !== null) {
                        this.ex = Vec2.clone(a);
                        this.ey = Vec2.clone(b);
                    } else if (typeof a === "number") {
                        this.ex = Vec2.neo(a, c);
                        this.ey = Vec2.neo(b, d);
                    } else {
                        this.ex = Vec2.zero();
                        this.ey = Vec2.zero();
                    }
                }
                Mat22.prototype.toString = function() {
                    return JSON.stringify(this);
                };
                Mat22.isValid = function(o) {
                    return o && Vec2.isValid(o.ex) && Vec2.isValid(o.ey);
                };
                Mat22.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!Mat22.isValid(o)) {
                        _DEBUG && common1.debug(o);
                        throw new Error("Invalid Mat22!");
                    }
                };
                Mat22.prototype.set = function(a, b, c, d) {
                    if (typeof a === "number" && typeof b === "number" && typeof c === "number" && typeof d === "number") {
                        this.ex.set(a, c);
                        this.ey.set(b, d);
                    } else if (typeof a === "object" && typeof b === "object") {
                        this.ex.set(a);
                        this.ey.set(b);
                    } else if (typeof a === "object") {
                        _ASSERT && Mat22.assert(a);
                        this.ex.set(a.ex);
                        this.ey.set(a.ey);
                    } else {
                        _ASSERT && common1.assert(false);
                    }
                };
                Mat22.prototype.setIdentity = function() {
                    this.ex.x = 1;
                    this.ey.x = 0;
                    this.ex.y = 0;
                    this.ey.y = 1;
                };
                Mat22.prototype.setZero = function() {
                    this.ex.x = 0;
                    this.ey.x = 0;
                    this.ex.y = 0;
                    this.ey.y = 0;
                };
                Mat22.prototype.getInverse = function() {
                    var a = this.ex.x;
                    var b = this.ey.x;
                    var c = this.ex.y;
                    var d = this.ey.y;
                    var det = a * d - b * c;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var imx = new Mat22();
                    imx.ex.x = det * d;
                    imx.ey.x = -det * b;
                    imx.ex.y = -det * c;
                    imx.ey.y = det * a;
                    return imx;
                };
                /**
 * Solve A * x = b, where b is a column vector. This is more efficient than
 * computing the inverse in one-shot cases.
 */ Mat22.prototype.solve = function(v) {
                    _ASSERT && Vec2.assert(v);
                    var a = this.ex.x;
                    var b = this.ey.x;
                    var c = this.ex.y;
                    var d = this.ey.y;
                    var det = a * d - b * c;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var w = Vec2.zero();
                    w.x = det * (d * v.x - b * v.y);
                    w.y = det * (a * v.y - c * v.x);
                    return w;
                };
                /**
 * Multiply a matrix times a vector. If a rotation matrix is provided, then this
 * transforms the vector from one frame to another.
 */ Mat22.mul = function(mx, v) {
                    if (v && "x" in v && "y" in v) {
                        _ASSERT && Vec2.assert(v);
                        var x = mx.ex.x * v.x + mx.ey.x * v.y;
                        var y = mx.ex.y * v.x + mx.ey.y * v.y;
                        return Vec2.neo(x, y);
                    } else if (v && "ex" in v && "ey" in v) {
                        // Mat22
                        _ASSERT && Mat22.assert(v);
                        return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
                    }
                    _ASSERT && common1.assert(false);
                };
                Mat22.mulVec2 = function(mx, v) {
                    _ASSERT && Vec2.assert(v);
                    var x = mx.ex.x * v.x + mx.ey.x * v.y;
                    var y = mx.ex.y * v.x + mx.ey.y * v.y;
                    return Vec2.neo(x, y);
                };
                Mat22.mulVec2_ = function(mx, v, _) {
                    _ASSERT && Vec2.assert(v);
                    var x = mx.ex.x * v.x + mx.ey.x * v.y;
                    var y = mx.ex.y * v.x + mx.ey.y * v.y;
                    return _.set(x, y);
                };
                Mat22.mulMat22 = function(mx, v) {
                    _ASSERT && Mat22.assert(v);
                    return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
                    _ASSERT && common1.assert(false);
                };
                /**
 * Multiply a matrix transpose times a vector. If a rotation matrix is provided,
 * then this transforms the vector from one frame to another (inverse
 * transform).
 */ Mat22.mulT = function(mx, v) {
                    if (v && "x" in v && "y" in v) {
                        // Vec2
                        _ASSERT && Vec2.assert(v);
                        return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));
                    } else if (v && "ex" in v && "ey" in v) {
                        // Mat22
                        _ASSERT && Mat22.assert(v);
                        var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
                        var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
                        return new Mat22(c1, c2);
                    }
                    _ASSERT && common1.assert(false);
                };
                Mat22.mulTVec2 = function(mx, v) {
                    _ASSERT && Mat22.assert(mx);
                    _ASSERT && Vec2.assert(v);
                    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));
                };
                Mat22.mulTMat22 = function(mx, v) {
                    _ASSERT && Mat22.assert(mx);
                    _ASSERT && Mat22.assert(v);
                    var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
                    var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
                    return new Mat22(c1, c2);
                };
                Mat22.abs = function(mx) {
                    _ASSERT && Mat22.assert(mx);
                    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));
                };
                Mat22.add = function(mx1, mx2) {
                    _ASSERT && Mat22.assert(mx1);
                    _ASSERT && Mat22.assert(mx2);
                    return new Mat22(Vec2.add(mx1.ex + mx2.ex), Vec2.add(mx1.ey + mx2.ey));
                };
            },
            {
                "../util/common": 50,
                "./Math": 18,
                "./Vec2": 23
            }
        ],
        17: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Mat33;
                var common1 = require1("../util/common");
                var Math1 = require1("./Math");
                var Vec2 = require1("./Vec2");
                var Vec3 = require1("./Vec3");
                /**
 * A 3-by-3 matrix. Stored in column-major order.
 */ function Mat33(a, b, c) {
                    if (typeof a === "object" && a !== null) {
                        this.ex = Vec3.clone(a);
                        this.ey = Vec3.clone(b);
                        this.ez = Vec3.clone(c);
                    } else {
                        this.ex = Vec3();
                        this.ey = Vec3();
                        this.ez = Vec3();
                    }
                }
                Mat33.prototype.toString = function() {
                    return JSON.stringify(this);
                };
                Mat33.isValid = function(o) {
                    return o && Vec3.isValid(o.ex) && Vec3.isValid(o.ey) && Vec3.isValid(o.ez);
                };
                Mat33.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!Mat33.isValid(o)) {
                        _DEBUG && common1.debug(o);
                        throw new Error("Invalid Mat33!");
                    }
                };
                /**
 * Set this matrix to all zeros.
 */ Mat33.prototype.setZero = function() {
                    this.ex.setZero();
                    this.ey.setZero();
                    this.ez.setZero();
                    return this;
                };
                /**
 * Solve A * x = b, where b is a column vector. This is more efficient than
 * computing the inverse in one-shot cases.
 * 
 * @param {Vec3} v
 * @returns {Vec3}
 */ Mat33.prototype.solve33 = function(v) {
                    var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var r = new Vec3();
                    r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));
                    r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));
                    r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));
                    return r;
                };
                /**
 * Solve A * x = b, where b is a column vector. This is more efficient than
 * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix
 * equation.
 * 
 * @param {Vec2} v
 * 
 * @returns {Vec2}
 */ Mat33.prototype.solve22 = function(v) {
                    var a11 = this.ex.x;
                    var a12 = this.ey.x;
                    var a21 = this.ex.y;
                    var a22 = this.ey.y;
                    var det = a11 * a22 - a12 * a21;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var r = Vec2.zero();
                    r.x = det * (a22 * v.x - a12 * v.y);
                    r.y = det * (a11 * v.y - a21 * v.x);
                    return r;
                };
                /**
 * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if
 * singular.
 * 
 * @param {Mat33} M
 */ Mat33.prototype.getInverse22 = function(M) {
                    var a = this.ex.x;
                    var b = this.ey.x;
                    var c = this.ex.y;
                    var d = this.ey.y;
                    var det = a * d - b * c;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    M.ex.x = det * d;
                    M.ey.x = -det * b;
                    M.ex.z = 0;
                    M.ex.y = -det * c;
                    M.ey.y = det * a;
                    M.ey.z = 0;
                    M.ez.x = 0;
                    M.ez.y = 0;
                    M.ez.z = 0;
                };
                /**
 * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix
 * if singular.
 * 
 * @param {Mat33} M
 */ Mat33.prototype.getSymInverse33 = function(M) {
                    var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var a11 = this.ex.x;
                    var a12 = this.ey.x;
                    var a13 = this.ez.x;
                    var a22 = this.ey.y;
                    var a23 = this.ez.y;
                    var a33 = this.ez.z;
                    M.ex.x = det * (a22 * a33 - a23 * a23);
                    M.ex.y = det * (a13 * a23 - a12 * a33);
                    M.ex.z = det * (a12 * a23 - a13 * a22);
                    M.ey.x = M.ex.y;
                    M.ey.y = det * (a11 * a33 - a13 * a13);
                    M.ey.z = det * (a13 * a12 - a11 * a23);
                    M.ez.x = M.ex.z;
                    M.ez.y = M.ey.z;
                    M.ez.z = det * (a11 * a22 - a12 * a12);
                };
                /**
 * Multiply a matrix times a vector.
 * 
 * @param {Mat33} a
 * @param {Vec3|Vec2} b
 * 
 * @returns {Vec3|Vec2}
 */ Mat33.mul = function(a, b) {
                    _ASSERT && Mat33.assert(a);
                    if (b && "z" in b && "y" in b && "x" in b) {
                        _ASSERT && Vec3.assert(b);
                        var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
                        var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
                        var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
                        return new Vec3(x, y, z);
                    } else if (b && "y" in b && "x" in b) {
                        _ASSERT && Vec2.assert(b);
                        var x = a.ex.x * b.x + a.ey.x * b.y;
                        var y = a.ex.y * b.x + a.ey.y * b.y;
                        return Vec2.neo(x, y);
                    }
                    _ASSERT && common1.assert(false);
                };
                Mat33.mulVec3 = function(a, b) {
                    _ASSERT && Mat33.assert(a);
                    _ASSERT && Vec3.assert(b);
                    var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
                    var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
                    var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
                    return new Vec3(x, y, z);
                };
                Mat33.mulVec2 = function(a, b) {
                    _ASSERT && Mat33.assert(a);
                    _ASSERT && Vec2.assert(b);
                    var x = a.ex.x * b.x + a.ey.x * b.y;
                    var y = a.ex.y * b.x + a.ey.y * b.y;
                    return Vec2.neo(x, y);
                };
                Mat33.add = function(a, b) {
                    _ASSERT && Mat33.assert(a);
                    _ASSERT && Mat33.assert(b);
                    return new Mat33(Vec3.add(a.ex + b.ex), Vec3.add(a.ey + b.ey), Vec3.add(a.ez + b.ez));
                };
            },
            {
                "../util/common": 50,
                "./Math": 18,
                "./Vec2": 23,
                "./Vec3": 24
            }
        ],
        18: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("../util/common");
                var create = require1("../util/create");
                var native = Math;
                var math = module1.exports = create(native);
                math.EPSILON = 1e-9;
                // TODO
                /**
 * This function is used to ensure that a floating point number is not a NaN or
 * infinity.
 */ math.isFinite = function(x) {
                    return typeof x === "number" && isFinite(x) && !isNaN(x);
                };
                math.assert = function(x) {
                    if (!_ASSERT) return;
                    if (!math.isFinite(x)) {
                        _DEBUG && common1.debug(x);
                        throw new Error("Invalid Number!");
                    }
                };
                /**
 * TODO: This is a approximate yet fast inverse square-root.
 */ math.invSqrt = function(x) {
                    // TODO
                    return 1 / native.sqrt(x);
                };
                /**
 * Next Largest Power of 2 Given a binary integer value x, the next largest
 * power of 2 can be computed by a SWAR algorithm that recursively "folds" the
 * upper bits into the lower bits. This process yields a bit vector with the
 * same most significant 1 as x, but all 1's below it. Adding 1 to that value
 * yields the next largest power of 2. For a 32-bit value:
 */ math.nextPowerOfTwo = function(x) {
                    // TODO
                    x |= x >> 1;
                    x |= x >> 2;
                    x |= x >> 4;
                    x |= x >> 8;
                    x |= x >> 16;
                    return x + 1;
                };
                math.isPowerOfTwo = function(x) {
                    return x > 0 && (x & x - 1) == 0;
                };
                math.mod = function(num, min, max) {
                    if (typeof min === "undefined") {
                        max = 1, min = 0;
                    } else if (typeof max === "undefined") {
                        max = min, min = 0;
                    }
                    if (max > min) {
                        num = (num - min) % (max - min);
                        return num + (num < 0 ? max : min);
                    } else {
                        num = (num - max) % (min - max);
                        return num + (num <= 0 ? min : max);
                    }
                };
                math.clamp = function(num, min, max) {
                    if (num < min) {
                        return min;
                    } else if (num > max) {
                        return max;
                    } else {
                        return num;
                    }
                };
                math.random = function(min, max) {
                    if (typeof min === "undefined") {
                        max = 1;
                        min = 0;
                    } else if (typeof max === "undefined") {
                        max = min;
                        min = 0;
                    }
                    return min == max ? min : native.random() * (max - min) + min;
                };
            },
            {
                "../util/common": 50,
                "../util/create": 51
            }
        ],
        19: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Position;
                var Vec2 = require1("./Vec2");
                var Rot = require1("./Rot");
                /**
 * @prop {Vec2} c location
 * @prop {float} a angle
 */ function Position() {
                    this.c = Vec2.zero();
                    this.a = 0;
                }
                Position.prototype.getTransform = function(xf, p) {
                    xf.q.set(this.a);
                    xf.p.set(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));
                    return xf;
                };
            },
            {
                "./Rot": 20,
                "./Vec2": 23
            }
        ],
        20: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Rot;
                var common1 = require1("../util/common");
                var Vec2 = require1("./Vec2");
                var Math1 = require1("./Math");
                // TODO merge with Transform
                /**
 * Initialize from an angle in radians.
 */ function Rot(angle) {
                    if (!(this instanceof Rot)) {
                        return new Rot(angle);
                    }
                    if (typeof angle === "number") {
                        this.setAngle(angle);
                    } else if (typeof angle === "object") {
                        this.set(angle);
                    } else {
                        this.setIdentity();
                    }
                }
                Rot.neo = function(angle) {
                    var obj = Object.create(Rot.prototype);
                    obj.setAngle(angle);
                    return obj;
                };
                Rot.clone = function(rot) {
                    _ASSERT && Rot.assert(rot);
                    var obj = Object.create(Rot.prototype);
                    obj.s = rot.s;
                    obj.c = rot.c;
                    return obj;
                };
                Rot.identity = function() {
                    var obj = Object.create(Rot.prototype);
                    obj.s = 0;
                    obj.c = 1;
                    return obj;
                };
                Rot.isValid = function(o) {
                    return o && Math1.isFinite(o.s) && Math1.isFinite(o.c);
                };
                Rot.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!Rot.isValid(o)) {
                        _DEBUG && common1.debug(o);
                        throw new Error("Invalid Rot!");
                    }
                };
                /**
 * Set to the identity rotation.
 */ Rot.prototype.setIdentity = function() {
                    this.s = 0;
                    this.c = 1;
                    return this;
                };
                Rot.prototype.set = function(angle) {
                    if (typeof angle === "object") {
                        _ASSERT && Rot.assert(angle);
                        this.s = angle.s;
                        this.c = angle.c;
                    } else {
                        _ASSERT && Math1.assert(angle);
                        // TODO_ERIN optimize
                        this.s = Math1.sin(angle);
                        this.c = Math1.cos(angle);
                    }
                };
                /**
 * Set using an angle in radians.
 */ Rot.prototype.setAngle = function(angle) {
                    _ASSERT && Math1.assert(angle);
                    // TODO_ERIN optimize
                    this.s = Math1.sin(angle);
                    this.c = Math1.cos(angle);
                };
                /**
 * Get the angle in radians.
 */ Rot.prototype.getAngle = function() {
                    return Math1.atan2(this.s, this.c);
                };
                /**
 * Get the x-axis.
 */ Rot.prototype.getXAxis = function() {
                    return Vec2.neo(this.c, this.s);
                };
                /**
 * Get the u-axis.
 */ Rot.prototype.getYAxis = function() {
                    return Vec2.neo(-this.s, this.c);
                };
                /**
 * Multiply two rotations: q * r
 * 
 * @returns Rot
 * 
 * Rotate a vector
 * 
 * @returns Vec2
 */ Rot.mul = function(rot, m) {
                    _ASSERT && Rot.assert(rot);
                    if ("c" in m && "s" in m) {
                        _ASSERT && Rot.assert(m);
                        // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
                        // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
                        // s = qs * rc + qc * rs
                        // c = qc * rc - qs * rs
                        var qr = Rot.identity();
                        qr.s = rot.s * m.c + rot.c * m.s;
                        qr.c = rot.c * m.c - rot.s * m.s;
                        return qr;
                    } else if ("x" in m && "y" in m) {
                        _ASSERT && Vec2.assert(m);
                        return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
                    }
                };
                Rot.mulRot = function(rot, m) {
                    _ASSERT && Rot.assert(rot);
                    _ASSERT && Rot.assert(m);
                    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
                    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
                    // s = qs * rc + qc * rs
                    // c = qc * rc - qs * rs
                    var qr = Rot.identity();
                    qr.s = rot.s * m.c + rot.c * m.s;
                    qr.c = rot.c * m.c - rot.s * m.s;
                    return qr;
                };
                Rot.mulVec2 = function(rot, m) {
                    _ASSERT && Rot.assert(rot);
                    _ASSERT && Vec2.assert(m);
                    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
                };
                Rot.mulVec2_ = function(rot, m, _) {
                    _ASSERT && Rot.assert(rot);
                    _ASSERT && Vec2.assert(m);
                    return _.set(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
                };
                Rot.mulSub = function(rot, v, w) {
                    var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);
                    var y = rot.s * (v.x - w.y) + rot.c * (v.y - w.y);
                    return Vec2.neo(x, y);
                };
                /**
 * Transpose multiply two rotations: qT * r
 * 
 * @returns Rot
 * 
 * Inverse rotate a vector
 * 
 * @returns Vec2
 */ Rot.mulT = function(rot, m) {
                    if ("c" in m && "s" in m) {
                        _ASSERT && Rot.assert(m);
                        // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
                        // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
                        // s = qc * rs - qs * rc
                        // c = qc * rc + qs * rs
                        var qr = Rot.identity();
                        qr.s = rot.c * m.s - rot.s * m.c;
                        qr.c = rot.c * m.c + rot.s * m.s;
                        return qr;
                    } else if ("x" in m && "y" in m) {
                        _ASSERT && Vec2.assert(m);
                        return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
                    }
                };
                Rot.mulTRot = function(rot, m) {
                    _ASSERT && Rot.assert(m);
                    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
                    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
                    // s = qc * rs - qs * rc
                    // c = qc * rc + qs * rs
                    var qr = Rot.identity();
                    qr.s = rot.c * m.s - rot.s * m.c;
                    qr.c = rot.c * m.c + rot.s * m.s;
                    return qr;
                };
                Rot.mulTRot_ = function(rot, m, _) {
                    _ASSERT && Rot.assert(m);
                    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
                    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
                    // s = qc * rs - qs * rc
                    // c = qc * rc + qs * rs
                    var qr = _.setIdentity();
                    qr.s = rot.c * m.s - rot.s * m.c;
                    qr.c = rot.c * m.c + rot.s * m.s;
                    return qr;
                };
                Rot.mulTVec2 = function(rot, m) {
                    _ASSERT && Vec2.assert(m);
                    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
                };
                Rot.mulTVec2_ = function(rot, m, _) {
                    _ASSERT && Vec2.assert(m);
                    return _.set(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
                };
            },
            {
                "../util/common": 50,
                "./Math": 18,
                "./Vec2": 23
            }
        ],
        21: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Sweep;
                var common1 = require1("../util/common");
                var Math1 = require1("./Math");
                var Vec2 = require1("./Vec2");
                var Rot = require1("./Rot");
                var Transform = require1("./Transform");
                /**
 * This describes the motion of a body/shape for TOI computation. Shapes are
 * defined with respect to the body origin, which may not coincide with the
 * center of mass. However, to support dynamics we must interpolate the center
 * of mass position.
 * 
 * @prop {Vec2} localCenter Local center of mass position
 * @prop {Vec2} c World center position
 * @prop {float} a World angle
 * @prop {float} alpha0 Fraction of the current time step in the range [0,1], c0
 *       and a0 are c and a at alpha0.
 */ function Sweep(c, a) {
                    _ASSERT && common1.assert(typeof c === "undefined");
                    _ASSERT && common1.assert(typeof a === "undefined");
                    this.localCenter = Vec2.zero();
                    this.c = Vec2.zero();
                    this.a = 0;
                    this.alpha0 = 0;
                    this.c0 = Vec2.zero();
                    this.a0 = 0;
                }
                Sweep.prototype.setTransform = function(xf) {
                    var c = Transform.mulVec2(xf, this.localCenter);
                    this.c.set(c);
                    this.c0.set(c);
                    this.a = xf.q.getAngle();
                    this.a0 = xf.q.getAngle();
                };
                Sweep.prototype.setLocalCenter = function(localCenter, xf) {
                    this.localCenter.set(localCenter);
                    var c = Transform.mulVec2(xf, this.localCenter);
                    this.c.set(c);
                    this.c0.set(c);
                };
                /**
 * Get the interpolated transform at a specific time.
 * 
 * @param xf
 * @param beta A factor in [0,1], where 0 indicates alpha0
 */ Sweep.prototype.getTransform = function(xf, beta) {
                    beta = typeof beta === "undefined" ? 0 : beta;
                    xf.q.setAngle((1 - beta) * this.a0 + beta * this.a);
                    xf.p.setCombine(1 - beta, this.c0, beta, this.c);
                    // shift to origin
                    xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));
                };
                /**
 * Advance the sweep forward, yielding a new initial state.
 * 
 * @param {float} alpha The new initial time
 */ Sweep.prototype.advance = function(alpha) {
                    _ASSERT && common1.assert(this.alpha0 < 1);
                    var beta = (alpha - this.alpha0) / (1 - this.alpha0);
                    this.c0.setCombine(beta, this.c, 1 - beta, this.c0);
                    this.a0 = beta * this.a + (1 - beta) * this.a0;
                    this.alpha0 = alpha;
                };
                Sweep.prototype.forward = function() {
                    this.a0 = this.a;
                    this.c0.set(this.c);
                };
                /**
 * normalize the angles in radians to be between -pi and pi.
 */ Sweep.prototype.normalize = function() {
                    var a0 = Math1.mod(this.a0, -Math1.PI, +Math1.PI);
                    this.a -= this.a0 - a0;
                    this.a0 = a0;
                };
                Sweep.prototype.clone = function() {
                    var clone = new Sweep();
                    clone.localCenter.set(this.localCenter);
                    clone.alpha0 = this.alpha0;
                    clone.a0 = this.a0;
                    clone.a = this.a;
                    clone.c0.set(this.c0);
                    clone.c.set(this.c);
                    return clone;
                };
                Sweep.prototype.set = function(that) {
                    this.localCenter.set(that.localCenter);
                    this.alpha0 = that.alpha0;
                    this.a0 = that.a0;
                    this.a = that.a;
                    this.c0.set(that.c0);
                    this.c.set(that.c);
                };
            },
            {
                "../util/common": 50,
                "./Math": 18,
                "./Rot": 20,
                "./Transform": 22,
                "./Vec2": 23
            }
        ],
        22: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Transform;
                var common1 = require1("../util/common");
                var Vec2 = require1("./Vec2");
                var Rot = require1("./Rot");
                // TODO merge with Rot
                /**
 * A transform contains translation and rotation. It is used to represent the
 * position and orientation of rigid frames. Initialize using a position vector
 * and a rotation.
 *
 * @prop {Vec2} position
 * @prop {Rot} rotation
 */ function Transform(position, rotation) {
                    if (!(this instanceof Transform)) {
                        return new Transform(position, rotation);
                    }
                    this.p = Vec2.zero();
                    this.q = Rot.identity();
                    if (typeof position !== "undefined") {
                        this.p.set(position);
                    }
                    if (typeof rotation !== "undefined") {
                        this.q.set(rotation);
                    }
                }
                Transform.clone = function(xf) {
                    var obj = Object.create(Transform.prototype);
                    obj.p = Vec2.clone(xf.p);
                    obj.q = Rot.clone(xf.q);
                    return obj;
                };
                Transform.neo = function(position, rotation) {
                    var obj = Object.create(Transform.prototype);
                    obj.p = Vec2.clone(position);
                    obj.q = Rot.clone(rotation);
                    return obj;
                };
                Transform.identity = function() {
                    var obj = Object.create(Transform.prototype);
                    obj.p = Vec2.zero();
                    obj.q = Rot.identity();
                    return obj;
                };
                /**
 * Set this to the identity transform.
 */ Transform.prototype.setIdentity = function() {
                    this.p.setZero();
                    this.q.setIdentity();
                    return this;
                };
                /**
 * Set this based on the position and angle.
 */ Transform.prototype.set = function(a, b) {
                    if (typeof b === "undefined") {
                        this.p.set(a.p);
                        this.q.set(a.q);
                    } else {
                        this.p.set(a);
                        this.q.set(b);
                    }
                };
                Transform.isValid = function(o) {
                    return o && Vec2.isValid(o.p) && Rot.isValid(o.q);
                };
                Transform.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!Transform.isValid(o)) {
                        _DEBUG && common1.debug(o);
                        throw new Error("Invalid Transform!");
                    }
                };
                /**
 * @param {Transform} a
 * @param {Vec2} b
 * @returns {Vec2}
 *
 * @param {Transform} a
 * @param {Transform} b
 * @returns {Transform}
 */ Transform.mul = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    if (Array.isArray(b)) {
                        var arr = [];
                        for(var i = 0; i < b.length; i++){
                            arr[i] = Transform.mul(a, b[i]);
                        }
                        return arr;
                    } else if ("x" in b && "y" in b) {
                        _ASSERT && Vec2.assert(b);
                        var x = a.q.c * b.x - a.q.s * b.y + a.p.x;
                        var y = a.q.s * b.x + a.q.c * b.y + a.p.y;
                        return Vec2.neo(x, y);
                    } else if ("p" in b && "q" in b) {
                        _ASSERT && Transform.assert(b);
                        // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
                        // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
                        var xf = Transform.identity();
                        xf.q = Rot.mulRot(a.q, b.q);
                        xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);
                        return xf;
                    }
                };
                /**
 * @deprecated Use mulFn instead.
 */ Transform.mulAll = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    var arr = [];
                    for(var i = 0; i < b.length; i++){
                        arr[i] = Transform.mul(a, b[i]);
                    }
                    return arr;
                };
                /**
 * @experimental
 */ Transform.mulFn = function(a) {
                    _ASSERT && Transform.assert(a);
                    return function(b) {
                        return Transform.mul(a, b);
                    };
                };
                Transform.mulVec2 = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Vec2.assert(b);
                    var x = a.q.c * b.x - a.q.s * b.y + a.p.x;
                    var y = a.q.s * b.x + a.q.c * b.y + a.p.y;
                    return Vec2.neo(x, y);
                };
                Transform.mulVec2_ = function(a, b, _) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Vec2.assert(b);
                    var x = a.q.c * b.x - a.q.s * b.y + a.p.x;
                    var y = a.q.s * b.x + a.q.c * b.y + a.p.y;
                    return _.set(x, y);
                };
                Transform.mulXf = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Transform.assert(b);
                    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
                    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
                    var xf = Transform.identity();
                    xf.q = Rot.mulRot(a.q, b.q);
                    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);
                    return xf;
                };
                /**
 * @param {Transform} a
 * @param {Vec2} b
 * @returns {Vec2}
 *
 * @param {Transform} a
 * @param {Transform} b
 * @returns {Transform}
 */ Transform.mulT = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    if ("x" in b && "y" in b) {
                        _ASSERT && Vec2.assert(b);
                        var px = b.x - a.p.x;
                        var py = b.y - a.p.y;
                        var x = a.q.c * px + a.q.s * py;
                        var y = -a.q.s * px + a.q.c * py;
                        return Vec2.neo(x, y);
                    } else if ("p" in b && "q" in b) {
                        _ASSERT && Transform.assert(b);
                        // v2 = A.q' * (B.q * v1 + B.p - A.p)
                        // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
                        var xf = Transform.identity();
                        xf.q.set(Rot.mulTRot(a.q, b.q));
                        xf.p.set(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));
                        return xf;
                    }
                };
                Transform.mulTVec2 = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Vec2.assert(b);
                    var px = b.x - a.p.x;
                    var py = b.y - a.p.y;
                    var x = a.q.c * px + a.q.s * py;
                    var y = -a.q.s * px + a.q.c * py;
                    return Vec2.neo(x, y);
                };
                Transform.mulTVec2_ = function(a, b, _) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Vec2.assert(b);
                    var px = b.x - a.p.x;
                    var py = b.y - a.p.y;
                    var x = a.q.c * px + a.q.s * py;
                    var y = -a.q.s * px + a.q.c * py;
                    return _.set(x, y);
                };
                Transform.mulTXf = function(a, b) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Transform.assert(b);
                    // v2 = A.q' * (B.q * v1 + B.p - A.p)
                    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
                    var xf = Transform.identity();
                    xf.q.set(Rot.mulTRot(a.q, b.q));
                    xf.p.set(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));
                    return xf;
                };
                var _vt1 = Vec2.zero();
                Transform.mulTXf_ = function(a, b, _) {
                    _ASSERT && Transform.assert(a);
                    _ASSERT && Transform.assert(b);
                    // v2 = A.q' * (B.q * v1 + B.p - A.p)
                    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
                    Rot.mulTRot_(a.q, b.q, _.q);
                    Rot.mulTVec2_(a.q, Vec2.sub(b.p, a.p, _vt1), _.p);
                    return _;
                };
            },
            {
                "../util/common": 50,
                "./Rot": 20,
                "./Vec2": 23
            }
        ],
        23: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Vec2;
                var common1 = require1("../util/common");
                var Math1 = require1("./Math");
                function Vec2(x, y) {
                    if (!(this instanceof Vec2)) {
                        return new Vec2(x, y);
                    }
                    if (typeof x === "undefined") {
                        this.x = 0;
                        this.y = 0;
                    } else if (typeof x === "object") {
                        this.x = x.x;
                        this.y = x.y;
                    } else {
                        this.x = x;
                        this.y = y;
                    }
                    _ASSERT && Vec2.assert(this);
                }
                Vec2.zero = function() {
                    var obj = Object.create(Vec2.prototype);
                    obj.x = 0;
                    obj.y = 0;
                    return obj;
                };
                Vec2.neo = function(x, y) {
                    var obj = Object.create(Vec2.prototype);
                    obj.x = x;
                    obj.y = y;
                    return obj;
                };
                Vec2.clone = function(v) {
                    _ASSERT && Vec2.assert(v);
                    return Vec2.neo(v.x, v.y);
                };
                Vec2.prototype.toString = function() {
                    return JSON.stringify(this);
                };
                /**
 * Does this vector contain finite coordinates?
 */ Vec2.isValid = function(v) {
                    return v && Math1.isFinite(v.x) && Math1.isFinite(v.y);
                };
                Vec2.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!Vec2.isValid(o)) {
                        _DEBUG && common1.debug(o);
                        throw new Error("Invalid Vec2!");
                    }
                };
                Vec2.prototype.clone = function() {
                    return Vec2.clone(this);
                };
                /**
 * Set this vector to all zeros.
 * 
 * @returns this
 */ Vec2.prototype.setZero = function() {
                    this.x = 0;
                    this.y = 0;
                    return this;
                };
                /**
 * Set this vector to some specified coordinates.
 * 
 * @returns this
 */ Vec2.prototype.set = function(x, y) {
                    if (typeof x === "object") {
                        _ASSERT && Vec2.assert(x);
                        this.x = x.x;
                        this.y = x.y;
                    } else {
                        _ASSERT && Math1.assert(x);
                        _ASSERT && Math1.assert(y);
                        this.x = x;
                        this.y = y;
                    }
                    return this;
                };
                Vec2.prototype.setXY = function(x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                };
                Vec2.prototype.setVec2 = function(x) {
                    this.x = x.x;
                    this.y = x.y;
                    return this;
                };
                /**
 * @deprecated Use setCombine or setMul
 */ Vec2.prototype.wSet = function(a, v, b, w) {
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        return this.setCombine(a, v, b, w);
                    } else {
                        return this.setMul(a, v);
                    }
                };
                /**
 * Set linear combination of v and w: `a * v + b * w`
 */ Vec2.prototype.setCombine = function(a, v, b, w) {
                    _ASSERT && Math1.assert(a);
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Math1.assert(b);
                    _ASSERT && Vec2.assert(w);
                    var x = a * v.x + b * w.x;
                    var y = a * v.y + b * w.y;
                    // `this` may be `w`
                    this.x = x;
                    this.y = y;
                    return this;
                };
                Vec2.prototype.setMul = function(a, v) {
                    _ASSERT && Math1.assert(a);
                    _ASSERT && Vec2.assert(v);
                    var x = a * v.x;
                    var y = a * v.y;
                    this.x = x;
                    this.y = y;
                    return this;
                };
                /**
 * Add a vector to this vector.
 * 
 * @returns this
 */ Vec2.prototype.add = function(w) {
                    _ASSERT && Vec2.assert(w);
                    this.x += w.x;
                    this.y += w.y;
                    return this;
                };
                /**
 * @deprecated Use addCombine or addMul
 */ Vec2.prototype.wAdd = function(a, v, b, w) {
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        return this.addCombine(a, v, b, w);
                    } else {
                        return this.addMul(a, v);
                    }
                };
                /**
 * Add linear combination of v and w: `a * v + b * w`
 */ Vec2.prototype.addCombine = function(a, v, b, w) {
                    _ASSERT && Math1.assert(a);
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Math1.assert(b);
                    _ASSERT && Vec2.assert(w);
                    var x = a * v.x + b * w.x;
                    var y = a * v.y + b * w.y;
                    // `this` may be `w`
                    this.x += x;
                    this.y += y;
                    return this;
                };
                Vec2.prototype.addMul = function(a, v) {
                    _ASSERT && Math1.assert(a);
                    _ASSERT && Vec2.assert(v);
                    var x = a * v.x;
                    var y = a * v.y;
                    this.x += x;
                    this.y += y;
                    return this;
                };
                /**
 * @deprecated Use subCombine or subMul
 */ Vec2.prototype.wSub = function(a, v, b, w) {
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        return this.subCombine(a, v, b, w);
                    } else {
                        return this.subMul(a, v);
                    }
                };
                /**
 * Subtract linear combination of v and w: `a * v + b * w`
 */ Vec2.prototype.subCombine = function(a, v, b, w) {
                    _ASSERT && Math1.assert(a);
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Math1.assert(b);
                    _ASSERT && Vec2.assert(w);
                    var x = a * v.x + b * w.x;
                    var y = a * v.y + b * w.y;
                    // `this` may be `w`
                    this.x -= x;
                    this.y -= y;
                    return this;
                };
                Vec2.prototype.subMul = function(a, v) {
                    _ASSERT && Math1.assert(a);
                    _ASSERT && Vec2.assert(v);
                    var x = a * v.x;
                    var y = a * v.y;
                    this.x -= x;
                    this.y -= y;
                    return this;
                };
                /**
 * Subtract a vector from this vector
 * 
 * @returns this
 */ Vec2.prototype.sub = function(w) {
                    _ASSERT && Vec2.assert(w);
                    this.x -= w.x;
                    this.y -= w.y;
                    return this;
                };
                /**
 * Multiply this vector by a scalar.
 * 
 * @returns this
 */ Vec2.prototype.mul = function(m) {
                    _ASSERT && Math1.assert(m);
                    this.x *= m;
                    this.y *= m;
                    return this;
                };
                /**
 * Get the length of this vector (the norm).
 * 
 * For performance, use this instead of lengthSquared (if possible).
 */ Vec2.prototype.length = function() {
                    return Vec2.lengthOf(this);
                };
                /**
 * Get the length squared.
 */ Vec2.prototype.lengthSquared = function() {
                    return Vec2.lengthSquared(this);
                };
                /**
 * Convert this vector into a unit vector.
 * 
 * @returns old length
 */ Vec2.prototype.normalize = function() {
                    var length = this.length();
                    if (length < Math1.EPSILON) {
                        return 0;
                    }
                    var invLength = 1 / length;
                    this.x *= invLength;
                    this.y *= invLength;
                    return length;
                };
                /**
 * Get the length of this vector (the norm).
 *
 * For performance, use this instead of lengthSquared (if possible).
 */ Vec2.lengthOf = function(v) {
                    _ASSERT && Vec2.assert(v);
                    return Math1.sqrt(v.x * v.x + v.y * v.y);
                };
                /**
 * Get the length squared.
 */ Vec2.lengthSquared = function(v) {
                    _ASSERT && Vec2.assert(v);
                    return v.x * v.x + v.y * v.y;
                };
                Vec2.distance = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    var dx = v.x - w.x, dy = v.y - w.y;
                    return Math1.sqrt(dx * dx + dy * dy);
                };
                Vec2.distanceSquared = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    var dx = v.x - w.x, dy = v.y - w.y;
                    return dx * dx + dy * dy;
                };
                Vec2.areEqual = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return v == w || typeof w === "object" && w !== null && v.x === w.x && v.y === w.y;
                };
                /**
 * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
 */ Vec2.skew = function(v) {
                    _ASSERT && Vec2.assert(v);
                    return Vec2.neo(-v.y, v.x);
                };
                /**
 * Perform the dot product on two vectors.
 */ Vec2.dot = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return v.x * w.x + v.y * w.y;
                };
                /**
 * Perform the cross product on two vectors. In 2D this produces a scalar.
 * 
 * Perform the cross product on a vector and a scalar. In 2D this produces a
 * vector.
 */ Vec2.cross = function(v, w) {
                    if (typeof w === "number") {
                        _ASSERT && Vec2.assert(v);
                        _ASSERT && Math1.assert(w);
                        return Vec2.neo(w * v.y, -w * v.x);
                    } else if (typeof v === "number") {
                        _ASSERT && Math1.assert(v);
                        _ASSERT && Vec2.assert(w);
                        return Vec2.neo(-v * w.y, v * w.x);
                    } else {
                        _ASSERT && Vec2.assert(v);
                        _ASSERT && Vec2.assert(w);
                        return v.x * w.y - v.y * w.x;
                    }
                };
                Vec2.crossVec2Vec2 = function(v, w) {
                    return v.x * w.y - v.y * w.x;
                };
                Vec2.crossNumVec2_ = function(v, w, _) {
                    return _.setXY(-v * w.y, v * w.x);
                };
                Vec2.crossVec2Num_ = function(v, w, _) {
                    return _.setXY(w * v.y, -w * v.x);
                };
                /**
 * Returns `a + (v x w)`
 */ Vec2.addCross = function(a, v, w) {
                    if (typeof w === "number") {
                        _ASSERT && Vec2.assert(v);
                        _ASSERT && Math1.assert(w);
                        return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);
                    } else if (typeof v === "number") {
                        _ASSERT && Math1.assert(v);
                        _ASSERT && Vec2.assert(w);
                        return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);
                    }
                    _ASSERT && common1.assert(false);
                };
                Vec2.add = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return Vec2.neo(v.x + w.x, v.y + w.y);
                };
                /**
 * @deprecated Use combine
 */ Vec2.wAdd = function(a, v, b, w) {
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        return Vec2.combine(a, v, b, w);
                    } else {
                        return Vec2.mul(a, v);
                    }
                };
                Vec2.combine = function(a, v, b, w) {
                    return Vec2.zero().setCombine(a, v, b, w);
                };
                Vec2.combine_ = function(a, v, b, w, _) {
                    return _.setCombine(a, v, b, w);
                };
                Vec2.sub = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return Vec2.neo(v.x - w.x, v.y - w.y);
                };
                Vec2.sub_ = function(v, w, _) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return _.setXY(v.x - w.x, v.y - w.y);
                };
                Vec2.mul = function(a, b) {
                    if (typeof a === "object") {
                        _ASSERT && Vec2.assert(a);
                        _ASSERT && Math1.assert(b);
                        return Vec2.neo(a.x * b, a.y * b);
                    } else if (typeof b === "object") {
                        _ASSERT && Math1.assert(a);
                        _ASSERT && Vec2.assert(b);
                        return Vec2.neo(a * b.x, a * b.y);
                    }
                };
                Vec2.mulVec2Num_ = function(a, b, _) {
                    return _.setXY(a.x * b, a.y * b);
                };
                Vec2.mulNumVec2_ = function(a, b, _) {
                    return _.setXY(a * b.x, a * b.y);
                };
                Vec2.prototype.neg = function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this;
                };
                Vec2.neg = function(v) {
                    _ASSERT && Vec2.assert(v);
                    return Vec2.neo(-v.x, -v.y);
                };
                Vec2.neg_ = function(v, _) {
                    _ASSERT && Vec2.assert(v);
                    return _.setXY(-v.x, -v.y);
                };
                Vec2.abs = function(v) {
                    _ASSERT && Vec2.assert(v);
                    return Vec2.neo(Math1.abs(v.x), Math1.abs(v.y));
                };
                Vec2.mid = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return Vec2.neo((v.x + w.x) * .5, (v.y + w.y) * .5);
                };
                Vec2.upper = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return Vec2.neo(Math1.max(v.x, w.x), Math1.max(v.y, w.y));
                };
                Vec2.lower = function(v, w) {
                    _ASSERT && Vec2.assert(v);
                    _ASSERT && Vec2.assert(w);
                    return Vec2.neo(Math1.min(v.x, w.x), Math1.min(v.y, w.y));
                };
                Vec2.prototype.clamp = function(max) {
                    var lengthSqr = this.x * this.x + this.y * this.y;
                    if (lengthSqr > max * max) {
                        var invLength = Math1.invSqrt(lengthSqr);
                        this.x *= invLength * max;
                        this.y *= invLength * max;
                    }
                    return this;
                };
                Vec2.clamp = function(v, max) {
                    v = Vec2.neo(v.x, v.y);
                    v.clamp(max);
                    return v;
                };
                /**
 * @experimental
 */ Vec2.scaleFn = function(x, y) {
                    return function(v) {
                        return Vec2.neo(v.x * x, v.y * y);
                    };
                };
                /**
 * @experimental
 */ Vec2.translateFn = function(x, y) {
                    return function(v) {
                        return Vec2.neo(v.x + x, v.y + y);
                    };
                };
            },
            {
                "../util/common": 50,
                "./Math": 18
            }
        ],
        24: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Vec3;
                var common1 = require1("../util/common");
                var Math1 = require1("./Math");
                function Vec3(x, y, z) {
                    if (!(this instanceof Vec3)) {
                        return new Vec3(x, y, z);
                    }
                    if (typeof x === "undefined") {
                        this.x = 0, this.y = 0, this.z = 0;
                    } else if (typeof x === "object") {
                        this.x = x.x, this.y = x.y, this.z = x.z;
                    } else {
                        this.x = x, this.y = y, this.z = z;
                    }
                    _ASSERT && Vec3.assert(this);
                }
                Vec3.neo = function(x, y, z) {
                    var obj = Object.create(Vec3.prototype);
                    obj.x = x;
                    obj.y = y;
                    obj.z = z;
                    return obj;
                };
                Vec3.clone = function(v) {
                    _ASSERT && Vec3.assert(v);
                    return Vec3.neo(v.x, v.y, v.z);
                };
                Vec3.prototype.toString = function() {
                    return JSON.stringify(this);
                };
                /**
 * Does this vector contain finite coordinates?
 */ Vec3.isValid = function(v) {
                    return v && Math1.isFinite(v.x) && Math1.isFinite(v.y) && Math1.isFinite(v.z);
                };
                Vec3.assert = function(o) {
                    if (!_ASSERT) return;
                    if (!Vec3.isValid(o)) {
                        _DEBUG && common1.debug(o);
                        throw new Error("Invalid Vec3!");
                    }
                };
                Vec3.prototype.setZero = function() {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    return this;
                };
                Vec3.prototype.set = function(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                };
                Vec3.prototype.add = function(w) {
                    this.x += w.x;
                    this.y += w.y;
                    this.z += w.z;
                    return this;
                };
                Vec3.prototype.sub = function(w) {
                    this.x -= w.x;
                    this.y -= w.y;
                    this.z -= w.z;
                    return this;
                };
                Vec3.prototype.mul = function(m) {
                    this.x *= m;
                    this.y *= m;
                    this.z *= m;
                    return this;
                };
                Vec3.areEqual = function(v, w) {
                    _ASSERT && Vec3.assert(v);
                    _ASSERT && Vec3.assert(w);
                    return v == w || typeof v === "object" && v !== null && typeof w === "object" && w !== null && v.x === w.x && v.y === w.y && v.z === w.z;
                };
                /**
 * Perform the dot product on two vectors.
 */ Vec3.dot = function(v, w) {
                    return v.x * w.x + v.y * w.y + v.z * w.z;
                };
                /**
 * Perform the cross product on two vectors. In 2D this produces a scalar.
 */ Vec3.cross = function(v, w) {
                    return new Vec3(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);
                };
                Vec3.add = function(v, w) {
                    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);
                };
                Vec3.sub = function(v, w) {
                    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);
                };
                Vec3.mul = function(v, m) {
                    return new Vec3(m * v.x, m * v.y, m * v.z);
                };
                Vec3.prototype.neg = function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                };
                Vec3.neg = function(v) {
                    return new Vec3(-v.x, -v.y, -v.z);
                };
            },
            {
                "../util/common": 50,
                "./Math": 18
            }
        ],
        25: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Velocity;
                var Vec2 = require1("./Vec2");
                /**
 * @prop {Vec2} v linear
 * @prop {float} w angular
 */ function Velocity() {
                    this.v = Vec2.zero();
                    this.w = 0;
                }
            },
            {
                "./Vec2": 23
            }
        ],
        26: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                exports1.toString = function(newline) {
                    newline = typeof newline === "string" ? newline : "\n";
                    var string = "";
                    for(var name in this){
                        if (typeof this[name] !== "function" && typeof this[name] !== "object") {
                            string += name + ": " + this[name] + newline;
                        }
                    }
                    return string;
                };
            },
            {}
        ],
        27: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = DistanceJoint;
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                DistanceJoint.TYPE = "distance-joint";
                DistanceJoint._super = Joint;
                DistanceJoint.prototype = create(DistanceJoint._super.prototype);
                /**
 * @typedef {Object} DistanceJointDef
 *
 * Distance joint definition. This requires defining an anchor point on both
 * bodies and the non-zero length of the distance joint. The definition uses
 * local anchor points so that the initial configuration can violate the
 * constraint slightly. This helps when saving and loading a game. Warning: Do
 * not use a zero or short length.
 * 
 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. A value
 *       of 0 disables softness.
 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
 *       damping.
 *
 * @prop {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {number} def.length Distance length.
 */ var DEFAULTS = {
                    frequencyHz: 0,
                    dampingRatio: 0
                };
                /**
 * A distance joint constrains two points on two bodies to remain at a fixed
 * distance from each other. You can view this as a massless, rigid rod.
 *
 * @param {DistanceJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec2} anchorA Anchor A in global coordination.
 * @param {Vec2} anchorB Anchor B in global coordination.
 */ function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {
                    if (!(this instanceof DistanceJoint)) {
                        return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);
                    }
                    // order of constructor arguments is changed in v0.2
                    if (bodyB && anchorA && "m_type" in anchorA && "x" in bodyB && "y" in bodyB) {
                        var temp = bodyB;
                        bodyB = anchorA;
                        anchorA = temp;
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = DistanceJoint.TYPE;
                    // Solver shared
                    this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero();
                    this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero();
                    this.m_length = Math1.isFinite(def.length) ? def.length : Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_impulse = 0;
                    this.m_gamma = 0;
                    this.m_bias = 0;
                    // Solver temp
                    this.m_u;
                    // Vec2
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    this.m_invMassB;
                    this.m_invIA;
                    this.m_invIB;
                    this.m_mass;
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ DistanceJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ DistanceJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * Set/get the natural length. Manipulating the length can lead to non-physical
 * behavior when the frequency is zero.
 */ DistanceJoint.prototype.setLength = function(length) {
                    this.m_length = length;
                };
                DistanceJoint.prototype.getLength = function() {
                    return this.m_length;
                };
                DistanceJoint.prototype.setFrequency = function(hz) {
                    this.m_frequencyHz = hz;
                };
                DistanceJoint.prototype.getFrequency = function() {
                    return this.m_frequencyHz;
                };
                DistanceJoint.prototype.setDampingRatio = function(ratio) {
                    this.m_dampingRatio = ratio;
                };
                DistanceJoint.prototype.getDampingRatio = function() {
                    return this.m_dampingRatio;
                };
                DistanceJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                DistanceJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                DistanceJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(this.m_impulse, this.m_u).mul(inv_dt);
                };
                DistanceJoint.prototype.getReactionTorque = function(inv_dt) {
                    return 0;
                };
                DistanceJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));
                    // Handle singularity.
                    var length = this.m_u.length();
                    if (length > Settings.linearSlop) {
                        this.m_u.mul(1 / length);
                    } else {
                        this.m_u.set(0, 0);
                    }
                    var crAu = Vec2.cross(this.m_rA, this.m_u);
                    var crBu = Vec2.cross(this.m_rB, this.m_u);
                    var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
                    // Compute the effective mass matrix.
                    this.m_mass = invMass != 0 ? 1 / invMass : 0;
                    if (this.m_frequencyHz > 0) {
                        var C = length - this.m_length;
                        // Frequency
                        var omega = 2 * Math1.PI * this.m_frequencyHz;
                        // Damping coefficient
                        var d = 2 * this.m_mass * this.m_dampingRatio * omega;
                        // Spring stiffness
                        var k = this.m_mass * omega * omega;
                        // magic formulas
                        var h = step.dt;
                        this.m_gamma = h * (d + h * k);
                        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
                        this.m_bias = C * h * k * this.m_gamma;
                        invMass += this.m_gamma;
                        this.m_mass = invMass != 0 ? 1 / invMass : 0;
                    } else {
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    }
                    if (step.warmStarting) {
                        // Scale the impulse to support a variable time step.
                        this.m_impulse *= step.dtRatio;
                        var P = Vec2.mul(this.m_impulse, this.m_u);
                        vA.subMul(this.m_invMassA, P);
                        wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                        vB.addMul(this.m_invMassB, P);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };
                DistanceJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    // Cdot = dot(u, v + cross(w, r))
                    var vpA = Vec2.add(vA, Vec2.cross(wA, this.m_rA));
                    var vpB = Vec2.add(vB, Vec2.cross(wB, this.m_rB));
                    var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);
                    var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
                    this.m_impulse += impulse;
                    var P = Vec2.mul(impulse, this.m_u);
                    vA.subMul(this.m_invMassA, P);
                    wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                    vB.addMul(this.m_invMassB, P);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };
                DistanceJoint.prototype.solvePositionConstraints = function(step) {
                    if (this.m_frequencyHz > 0) {
                        // There is no position correction for soft distance constraints.
                        return true;
                    }
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
                    var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
                    var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));
                    var length = u.normalize();
                    var C = length - this.m_length;
                    C = Math1.clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);
                    var impulse = -this.m_mass * C;
                    var P = Vec2.mul(impulse, u);
                    cA.subMul(this.m_invMassA, P);
                    aA -= this.m_invIA * Vec2.cross(rA, P);
                    cB.addMul(this.m_invMassB, P);
                    aB += this.m_invIB * Vec2.cross(rB, P);
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return Math1.abs(C) < Settings.linearSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        28: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = FrictionJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                FrictionJoint.TYPE = "friction-joint";
                FrictionJoint._super = Joint;
                FrictionJoint.prototype = create(FrictionJoint._super.prototype);
                /**
 * @typedef {Object} FrictionJointDef
 *
 * Friction joint definition.
 * 
 * @prop {float} maxForce The maximum friction force in N.
 * @prop {float} maxTorque The maximum friction torque in N-m.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 */ var DEFAULTS = {
                    maxForce: 0,
                    maxTorque: 0
                };
                /**
 * Friction joint. This is used for top-down friction. It provides 2D
 * translational friction and angular friction.
 *
 * @param {FrictionJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec2} anchor Anchor in global coordination.
 */ function FrictionJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof FrictionJoint)) {
                        return new FrictionJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = FrictionJoint.TYPE;
                    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero();
                    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero();
                    // Solver shared
                    this.m_linearImpulse = Vec2.zero();
                    this.m_angularImpulse = 0;
                    this.m_maxForce = def.maxForce;
                    this.m_maxTorque = def.maxTorque;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_linearMass;
                    // Mat22
                    this.m_angularMass;
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ FrictionJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ FrictionJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * Set the maximum friction force in N.
 */ FrictionJoint.prototype.setMaxForce = function(force) {
                    _ASSERT && common1.assert(Math1.isFinite(force) && force >= 0);
                    this.m_maxForce = force;
                };
                /**
 * Get the maximum friction force in N.
 */ FrictionJoint.prototype.getMaxForce = function() {
                    return this.m_maxForce;
                };
                /**
 * Set the maximum friction torque in N*m.
 */ FrictionJoint.prototype.setMaxTorque = function(torque) {
                    _ASSERT && common1.assert(Math1.isFinite(torque) && torque >= 0);
                    this.m_maxTorque = torque;
                };
                /**
 * Get the maximum friction torque in N*m.
 */ FrictionJoint.prototype.getMaxTorque = function() {
                    return this.m_maxTorque;
                };
                FrictionJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                FrictionJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                FrictionJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(inv_dt, this.m_linearImpulse);
                };
                FrictionJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * this.m_angularImpulse;
                };
                FrictionJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA), qB = Rot.neo(aB);
                    // Compute the effective mass matrix.
                    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA, iB = this.m_invIB;
                    // float
                    var K = new Mat22();
                    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
                    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
                    this.m_linearMass = K.getInverse();
                    this.m_angularMass = iA + iB;
                    if (this.m_angularMass > 0) {
                        this.m_angularMass = 1 / this.m_angularMass;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_linearImpulse.mul(step.dtRatio);
                        this.m_angularImpulse *= step.dtRatio;
                        var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
                        vA.subMul(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_angularImpulse);
                        vB.addMul(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_angularImpulse);
                    } else {
                        this.m_linearImpulse.setZero();
                        this.m_angularImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                FrictionJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA, iB = this.m_invIB;
                    // float
                    var h = step.dt;
                    // float
                    // Solve angular friction
                    {
                        var Cdot = wB - wA;
                        // float
                        var impulse = -this.m_angularMass * Cdot;
                        // float
                        var oldImpulse = this.m_angularImpulse;
                        // float
                        var maxImpulse = h * this.m_maxTorque;
                        // float
                        this.m_angularImpulse = Math1.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_angularImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve linear friction
                    {
                        var Cdot = Vec2.sub(Vec2.add(vB, Vec2.cross(wB, this.m_rB)), Vec2.add(vA, Vec2.cross(wA, this.m_rA)));
                        // Vec2
                        var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
                        // Vec2
                        var oldImpulse = this.m_linearImpulse;
                        // Vec2
                        this.m_linearImpulse.add(impulse);
                        var maxImpulse = h * this.m_maxForce;
                        // float
                        if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {
                            this.m_linearImpulse.normalize();
                            this.m_linearImpulse.mul(maxImpulse);
                        }
                        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
                        vA.subMul(mA, impulse);
                        wA -= iA * Vec2.cross(this.m_rA, impulse);
                        vB.addMul(mB, impulse);
                        wB += iB * Vec2.cross(this.m_rB, impulse);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                FrictionJoint.prototype.solvePositionConstraints = function(step) {
                    return true;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        29: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = GearJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                var RevoluteJoint = require1("./RevoluteJoint");
                var PrismaticJoint = require1("./PrismaticJoint");
                GearJoint.TYPE = "gear-joint";
                GearJoint._super = Joint;
                GearJoint.prototype = create(GearJoint._super.prototype);
                /**
 * @typedef {Object} GearJointDef
 *
 * Gear joint definition.
 *
 * @prop {float} ratio The gear ratio. See GearJoint for explanation.
 *
 * @prop {RevoluteJoint|PrismaticJoint} joint1 The first revolute/prismatic
 *          joint attached to the gear joint.
 * @prop {PrismaticJoint|RevoluteJoint} joint2 The second prismatic/revolute
 *          joint attached to the gear joint.
 */ var DEFAULTS = {
                    ratio: 1
                };
                /**
 * A gear joint is used to connect two joints together. Either joint can be a
 * revolute or prismatic joint. You specify a gear ratio to bind the motions
 * together: coordinate1 + ratio * coordinate2 = constant
 * 
 * The ratio can be negative or positive. If one joint is a revolute joint and
 * the other joint is a prismatic joint, then the ratio will have units of
 * length or units of 1/length. Warning: You have to manually destroy the gear
 * joint if joint1 or joint2 is destroyed.
 * 
 * This definition requires two existing revolute or prismatic joints (any
 * combination will work).
 *
 * @param {GearJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {
                    if (!(this instanceof GearJoint)) {
                        return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = GearJoint.TYPE;
                    _ASSERT && common1.assert(joint1.m_type === RevoluteJoint.TYPE || joint1.m_type === PrismaticJoint.TYPE);
                    _ASSERT && common1.assert(joint2.m_type === RevoluteJoint.TYPE || joint2.m_type === PrismaticJoint.TYPE);
                    this.m_joint1 = joint1 ? joint1 : def.joint1;
                    this.m_joint2 = joint2 ? joint2 : def.joint2;
                    this.m_ratio = Math1.isFinite(ratio) ? ratio : def.ratio;
                    this.m_type1 = this.m_joint1.getType();
                    this.m_type2 = this.m_joint2.getType();
                    // joint1 connects body A to body C
                    // joint2 connects body B to body D
                    var coordinateA, coordinateB;
                    // float
                    // TODO_ERIN there might be some problem with the joint edges in Joint.
                    this.m_bodyC = this.m_joint1.getBodyA();
                    this.m_bodyA = this.m_joint1.getBodyB();
                    // Get geometry of joint1
                    var xfA = this.m_bodyA.m_xf;
                    var aA = this.m_bodyA.m_sweep.a;
                    var xfC = this.m_bodyC.m_xf;
                    var aC = this.m_bodyC.m_sweep.a;
                    if (this.m_type1 === RevoluteJoint.TYPE) {
                        var revolute = this.m_joint1;
                        // RevoluteJoint
                        this.m_localAnchorC = revolute.m_localAnchorA;
                        this.m_localAnchorA = revolute.m_localAnchorB;
                        this.m_referenceAngleA = revolute.m_referenceAngle;
                        this.m_localAxisC = Vec2.zero();
                        coordinateA = aA - aC - this.m_referenceAngleA;
                    } else {
                        var prismatic = this.m_joint1;
                        // PrismaticJoint
                        this.m_localAnchorC = prismatic.m_localAnchorA;
                        this.m_localAnchorA = prismatic.m_localAnchorB;
                        this.m_referenceAngleA = prismatic.m_referenceAngle;
                        this.m_localAxisC = prismatic.m_localXAxisA;
                        var pC = this.m_localAnchorC;
                        var pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mul(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));
                        coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);
                    }
                    this.m_bodyD = this.m_joint2.getBodyA();
                    this.m_bodyB = this.m_joint2.getBodyB();
                    // Get geometry of joint2
                    var xfB = this.m_bodyB.m_xf;
                    var aB = this.m_bodyB.m_sweep.a;
                    var xfD = this.m_bodyD.m_xf;
                    var aD = this.m_bodyD.m_sweep.a;
                    if (this.m_type2 === RevoluteJoint.TYPE) {
                        var revolute = this.m_joint2;
                        // RevoluteJoint
                        this.m_localAnchorD = revolute.m_localAnchorA;
                        this.m_localAnchorB = revolute.m_localAnchorB;
                        this.m_referenceAngleB = revolute.m_referenceAngle;
                        this.m_localAxisD = Vec2.zero();
                        coordinateB = aB - aD - this.m_referenceAngleB;
                    } else {
                        var prismatic = this.m_joint2;
                        // PrismaticJoint
                        this.m_localAnchorD = prismatic.m_localAnchorA;
                        this.m_localAnchorB = prismatic.m_localAnchorB;
                        this.m_referenceAngleB = prismatic.m_referenceAngle;
                        this.m_localAxisD = prismatic.m_localXAxisA;
                        var pD = this.m_localAnchorD;
                        var pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mul(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));
                        coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
                    }
                    this.m_constant = coordinateA + this.m_ratio * coordinateB;
                    this.m_impulse = 0;
                    // Solver temp
                    this.m_lcA, this.m_lcB, this.m_lcC, this.m_lcD;
                    // Vec2
                    this.m_mA, this.m_mB, this.m_mC, this.m_mD;
                    // float
                    this.m_iA, this.m_iB, this.m_iC, this.m_iD;
                    // float
                    this.m_JvAC, this.m_JvBD;
                    // Vec2
                    this.m_JwA, this.m_JwB, this.m_JwC, this.m_JwD;
                    // float
                    this.m_mass;
                }
                /**
 * Get the first joint.
 */ GearJoint.prototype.getJoint1 = function() {
                    return this.m_joint1;
                };
                /**
 * Get the second joint.
 */ GearJoint.prototype.getJoint2 = function() {
                    return this.m_joint2;
                };
                /**
 * Set/Get the gear ratio.
 */ GearJoint.prototype.setRatio = function(ratio) {
                    _ASSERT && common1.assert(Math1.isFinite(ratio));
                    this.m_ratio = ratio;
                };
                GearJoint.prototype.getRatio = function() {
                    return this.m_ratio;
                };
                GearJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                GearJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                GearJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(this.m_impulse, this.m_JvAC).mul(inv_dt);
                };
                GearJoint.prototype.getReactionTorque = function(inv_dt) {
                    var L = this.m_impulse * this.m_JwA;
                    // float
                    return inv_dt * L;
                };
                GearJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_lcA = this.m_bodyA.m_sweep.localCenter;
                    this.m_lcB = this.m_bodyB.m_sweep.localCenter;
                    this.m_lcC = this.m_bodyC.m_sweep.localCenter;
                    this.m_lcD = this.m_bodyD.m_sweep.localCenter;
                    this.m_mA = this.m_bodyA.m_invMass;
                    this.m_mB = this.m_bodyB.m_invMass;
                    this.m_mC = this.m_bodyC.m_invMass;
                    this.m_mD = this.m_bodyD.m_invMass;
                    this.m_iA = this.m_bodyA.m_invI;
                    this.m_iB = this.m_bodyB.m_invI;
                    this.m_iC = this.m_bodyC.m_invI;
                    this.m_iD = this.m_bodyD.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var aC = this.m_bodyC.c_position.a;
                    var vC = this.m_bodyC.c_velocity.v;
                    var wC = this.m_bodyC.c_velocity.w;
                    var aD = this.m_bodyD.c_position.a;
                    var vD = this.m_bodyD.c_velocity.v;
                    var wD = this.m_bodyD.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var qC = Rot.neo(aC);
                    var qD = Rot.neo(aD);
                    this.m_mass = 0;
                    if (this.m_type1 == RevoluteJoint.TYPE) {
                        this.m_JvAC = Vec2.zero();
                        this.m_JwA = 1;
                        this.m_JwC = 1;
                        this.m_mass += this.m_iA + this.m_iC;
                    } else {
                        var u = Rot.mulVec2(qC, this.m_localAxisC);
                        // Vec2
                        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
                        // Vec2
                        var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
                        // Vec2
                        this.m_JvAC = u;
                        this.m_JwC = Vec2.cross(rC, u);
                        this.m_JwA = Vec2.cross(rA, u);
                        this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
                    }
                    if (this.m_type2 == RevoluteJoint.TYPE) {
                        this.m_JvBD = Vec2.zero();
                        this.m_JwB = this.m_ratio;
                        this.m_JwD = this.m_ratio;
                        this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                    } else {
                        var u = Rot.mulVec2(qD, this.m_localAxisD);
                        // Vec2
                        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
                        // Vec2
                        var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
                        // Vec2
                        this.m_JvBD = Vec2.mul(this.m_ratio, u);
                        this.m_JwD = this.m_ratio * Vec2.cross(rD, u);
                        this.m_JwB = this.m_ratio * Vec2.cross(rB, u);
                        this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
                    }
                    // Compute effective mass.
                    this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
                    if (step.warmStarting) {
                        vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);
                        wA += this.m_iA * this.m_impulse * this.m_JwA;
                        vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);
                        wB += this.m_iB * this.m_impulse * this.m_JwB;
                        vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);
                        wC -= this.m_iC * this.m_impulse * this.m_JwC;
                        vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);
                        wD -= this.m_iD * this.m_impulse * this.m_JwD;
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                    this.m_bodyC.c_velocity.v.set(vC);
                    this.m_bodyC.c_velocity.w = wC;
                    this.m_bodyD.c_velocity.v.set(vD);
                    this.m_bodyD.c_velocity.w = wD;
                };
                GearJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var vC = this.m_bodyC.c_velocity.v;
                    var wC = this.m_bodyC.c_velocity.w;
                    var vD = this.m_bodyD.c_velocity.v;
                    var wD = this.m_bodyD.c_velocity.w;
                    var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD);
                    // float
                    Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);
                    var impulse = -this.m_mass * Cdot;
                    // float
                    this.m_impulse += impulse;
                    vA.addMul(this.m_mA * impulse, this.m_JvAC);
                    wA += this.m_iA * impulse * this.m_JwA;
                    vB.addMul(this.m_mB * impulse, this.m_JvBD);
                    wB += this.m_iB * impulse * this.m_JwB;
                    vC.subMul(this.m_mC * impulse, this.m_JvAC);
                    wC -= this.m_iC * impulse * this.m_JwC;
                    vD.subMul(this.m_mD * impulse, this.m_JvBD);
                    wD -= this.m_iD * impulse * this.m_JwD;
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                    this.m_bodyC.c_velocity.v.set(vC);
                    this.m_bodyC.c_velocity.w = wC;
                    this.m_bodyD.c_velocity.v.set(vD);
                    this.m_bodyD.c_velocity.w = wD;
                };
                GearJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var cC = this.m_bodyC.c_position.c;
                    var aC = this.m_bodyC.c_position.a;
                    var cD = this.m_bodyD.c_position.c;
                    var aD = this.m_bodyD.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var qC = Rot.neo(aC);
                    var qD = Rot.neo(aD);
                    var linearError = 0;
                    // float
                    var coordinateA, coordinateB;
                    // float
                    var JvAC, JvBD;
                    // Vec2
                    var JwA, JwB, JwC, JwD;
                    // float
                    var mass = 0;
                    // float
                    if (this.m_type1 == RevoluteJoint.TYPE) {
                        JvAC = Vec2.zero();
                        JwA = 1;
                        JwC = 1;
                        mass += this.m_iA + this.m_iC;
                        coordinateA = aA - aC - this.m_referenceAngleA;
                    } else {
                        var u = Rot.mulVec2(qC, this.m_localAxisC);
                        // Vec2
                        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
                        // Vec2
                        var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
                        // Vec2
                        JvAC = u;
                        JwC = Vec2.cross(rC, u);
                        JwA = Vec2.cross(rA, u);
                        mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
                        var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC);
                        // Vec2
                        var pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC)));
                        // Vec2
                        coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);
                    }
                    if (this.m_type2 == RevoluteJoint.TYPE) {
                        JvBD = Vec2.zero();
                        JwB = this.m_ratio;
                        JwD = this.m_ratio;
                        mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                        coordinateB = aB - aD - this.m_referenceAngleB;
                    } else {
                        var u = Rot.mulVec2(qD, this.m_localAxisD);
                        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
                        var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
                        JvBD = Vec2.mul(this.m_ratio, u);
                        JwD = this.m_ratio * Vec2.cross(rD, u);
                        JwB = this.m_ratio * Vec2.cross(rB, u);
                        mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
                        var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);
                        // Vec2
                        var pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD)));
                        // Vec2
                        coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
                    }
                    var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;
                    // float
                    var impulse = 0;
                    // float
                    if (mass > 0) {
                        impulse = -C / mass;
                    }
                    cA.addMul(this.m_mA * impulse, JvAC);
                    aA += this.m_iA * impulse * JwA;
                    cB.addMul(this.m_mB * impulse, JvBD);
                    aB += this.m_iB * impulse * JwB;
                    cC.subMul(this.m_mC * impulse, JvAC);
                    aC -= this.m_iC * impulse * JwC;
                    cD.subMul(this.m_mD * impulse, JvBD);
                    aD -= this.m_iD * impulse * JwD;
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    this.m_bodyC.c_position.c.set(cC);
                    this.m_bodyC.c_position.a = aC;
                    this.m_bodyD.c_position.c.set(cD);
                    this.m_bodyD.c_position.a = aD;
                    // TODO_ERIN not implemented
                    return linearError < Settings.linearSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52,
                "./PrismaticJoint": 32,
                "./RevoluteJoint": 34
            }
        ],
        30: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = MotorJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                MotorJoint.TYPE = "motor-joint";
                MotorJoint._super = Joint;
                MotorJoint.prototype = create(MotorJoint._super.prototype);
                /**
 * @typedef {Object} MotorJointDef
 *
 * Motor joint definition.
 * 
 * @prop {float} angularOffset The bodyB angle minus bodyA angle in radians.
 * @prop {float} maxForce The maximum motor force in N.
 * @prop {float} maxTorque The maximum motor torque in N-m.
 * @prop {float} correctionFactor Position correction factor in the range [0,1].
 * @prop {Vec2} linearOffset Position of bodyB minus the position of bodyA, in
 *       bodyA's frame, in meters.
 */ var DEFAULTS = {
                    maxForce: 1,
                    maxTorque: 1,
                    correctionFactor: .3
                };
                /**
 * A motor joint is used to control the relative motion between two bodies. A
 * typical usage is to control the movement of a dynamic body with respect to
 * the ground.
 *
 * @param {MotorJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function MotorJoint(def, bodyA, bodyB) {
                    if (!(this instanceof MotorJoint)) {
                        return new MotorJoint(def, bodyA, bodyB);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = MotorJoint.TYPE;
                    this.m_linearOffset = def.linearOffset ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());
                    var angleA = bodyA.getAngle();
                    var angleB = bodyB.getAngle();
                    this.m_angularOffset = angleB - angleA;
                    this.m_linearImpulse = Vec2.zero();
                    this.m_angularImpulse = 0;
                    this.m_maxForce = def.maxForce;
                    this.m_maxTorque = def.maxTorque;
                    this.m_correctionFactor = def.correctionFactor;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_linearError;
                    // Vec2
                    this.m_angularError;
                    // float
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_linearMass;
                    // Mat22
                    this.m_angularMass;
                }
                /**
 * Set the maximum friction force in N.
 */ MotorJoint.prototype.setMaxForce = function(force) {
                    _ASSERT && common1.assert(Math1.isFinite(force) && force >= 0);
                    this.m_maxForce = force;
                };
                /**
 * Get the maximum friction force in N.
 */ MotorJoint.prototype.getMaxForce = function() {
                    return this.m_maxForce;
                };
                /**
 * Set the maximum friction torque in N*m.
 */ MotorJoint.prototype.setMaxTorque = function(torque) {
                    _ASSERT && common1.assert(Math1.isFinite(torque) && torque >= 0);
                    this.m_maxTorque = torque;
                };
                /**
 * Get the maximum friction torque in N*m.
 */ MotorJoint.prototype.getMaxTorque = function() {
                    return this.m_maxTorque;
                };
                /**
 * Set the position correction factor in the range [0,1].
 */ MotorJoint.prototype.setCorrectionFactor = function(factor) {
                    _ASSERT && common1.assert(Math1.isFinite(factor) && 0 <= factor && factor <= 1);
                    this.m_correctionFactor = factor;
                };
                /**
 * Get the position correction factor in the range [0,1].
 */ MotorJoint.prototype.getCorrectionFactor = function() {
                    return this.m_correctionFactor;
                };
                /**
 * Set/get the target linear offset, in frame A, in meters.
 */ MotorJoint.prototype.setLinearOffset = function(linearOffset) {
                    if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_linearOffset = linearOffset;
                    }
                };
                MotorJoint.prototype.getLinearOffset = function() {
                    return this.m_linearOffset;
                };
                /**
 * Set/get the target angular offset, in radians.
 */ MotorJoint.prototype.setAngularOffset = function(angularOffset) {
                    if (angularOffset != this.m_angularOffset) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_angularOffset = angularOffset;
                    }
                };
                MotorJoint.prototype.getAngularOffset = function() {
                    return this.m_angularOffset;
                };
                MotorJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getPosition();
                };
                MotorJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getPosition();
                };
                MotorJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(inv_dt, this.m_linearImpulse);
                };
                MotorJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * this.m_angularImpulse;
                };
                MotorJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA), qB = Rot.neo(aB);
                    // Compute the effective mass matrix.
                    this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));
                    this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    var K = new Mat22();
                    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
                    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
                    this.m_linearMass = K.getInverse();
                    this.m_angularMass = iA + iB;
                    if (this.m_angularMass > 0) {
                        this.m_angularMass = 1 / this.m_angularMass;
                    }
                    this.m_linearError = Vec2.zero();
                    this.m_linearError.addCombine(1, cB, 1, this.m_rB);
                    this.m_linearError.subCombine(1, cA, 1, this.m_rA);
                    this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));
                    this.m_angularError = aB - aA - this.m_angularOffset;
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_linearImpulse.mul(step.dtRatio);
                        this.m_angularImpulse *= step.dtRatio;
                        var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
                        vA.subMul(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_angularImpulse);
                        vB.addMul(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_angularImpulse);
                    } else {
                        this.m_linearImpulse.setZero();
                        this.m_angularImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                MotorJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var h = step.dt;
                    var inv_h = step.inv_dt;
                    // Solve angular friction
                    {
                        var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
                        var impulse = -this.m_angularMass * Cdot;
                        var oldImpulse = this.m_angularImpulse;
                        var maxImpulse = h * this.m_maxTorque;
                        this.m_angularImpulse = Math1.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_angularImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve linear friction
                    {
                        var Cdot = Vec2.zero();
                        Cdot.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);
                        var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
                        var oldImpulse = Vec2.clone(this.m_linearImpulse);
                        this.m_linearImpulse.add(impulse);
                        var maxImpulse = h * this.m_maxForce;
                        this.m_linearImpulse.clamp(maxImpulse);
                        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
                        vA.subMul(mA, impulse);
                        wA -= iA * Vec2.cross(this.m_rA, impulse);
                        vB.addMul(mB, impulse);
                        wB += iB * Vec2.cross(this.m_rB, impulse);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                MotorJoint.prototype.solvePositionConstraints = function(step) {
                    return true;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        31: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = MouseJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                MouseJoint.TYPE = "mouse-joint";
                MouseJoint._super = Joint;
                MouseJoint.prototype = create(MouseJoint._super.prototype);
                /**
 * @typedef {Object} MouseJointDef
 *
 * Mouse joint definition. This requires a world target point, tuning
 * parameters, and the time step.
 * 
 * @prop [maxForce = 0.0] The maximum constraint force that can be exerted to
 *       move the candidate body. Usually you will express as some multiple of
 *       the weight (multiplier * mass * gravity).
 * @prop [frequencyHz = 5.0] The response speed.
 * @prop [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical
 *       damping.
 *
 * @prop {Vec2} target The initial world target point. This is assumed to
 *       coincide with the body anchor initially.
 */ var DEFAULTS = {
                    maxForce: 0,
                    frequencyHz: 5,
                    dampingRatio: .7
                };
                /**
 * A mouse joint is used to make a point on a body track a specified world
 * point. This a soft constraint with a maximum force. This allows the
 * constraint to stretch and without applying huge forces.
 * 
 * NOTE: this joint is not documented in the manual because it was developed to
 * be used in the testbed. If you want to learn how to use the mouse joint, look
 * at the testbed.
 *
 * @param {MouseJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function MouseJoint(def, bodyA, bodyB, target) {
                    if (!(this instanceof MouseJoint)) {
                        return new MouseJoint(def, bodyA, bodyB, target);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = MouseJoint.TYPE;
                    _ASSERT && common1.assert(Math1.isFinite(def.maxForce) && def.maxForce >= 0);
                    _ASSERT && common1.assert(Math1.isFinite(def.frequencyHz) && def.frequencyHz >= 0);
                    _ASSERT && common1.assert(Math1.isFinite(def.dampingRatio) && def.dampingRatio >= 0);
                    this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();
                    this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);
                    this.m_maxForce = def.maxForce;
                    this.m_impulse = Vec2.zero();
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_beta = 0;
                    this.m_gamma = 0;
                    // Solver temp
                    this.m_rB = Vec2.zero();
                    this.m_localCenterB = Vec2.zero();
                    this.m_invMassB = 0;
                    this.m_invIB = 0;
                    this.mass = new Mat22();
                    this.m_C = Vec2.zero();
                }
                /**
 * Use this to update the target point.
 */ MouseJoint.prototype.setTarget = function(target) {
                    if (this.m_bodyB.isAwake() == false) {
                        this.m_bodyB.setAwake(true);
                    }
                    this.m_targetA = Vec2.clone(target);
                };
                MouseJoint.prototype.getTarget = function() {
                    return this.m_targetA;
                };
                /**
 * Set/get the maximum force in Newtons.
 */ MouseJoint.prototype.setMaxForce = function(force) {
                    this.m_maxForce = force;
                };
                MouseJoint.getMaxForce = function() {
                    return this.m_maxForce;
                };
                /**
 * Set/get the frequency in Hertz.
 */ MouseJoint.prototype.setFrequency = function(hz) {
                    this.m_frequencyHz = hz;
                };
                MouseJoint.prototype.getFrequency = function() {
                    return this.m_frequencyHz;
                };
                /**
 * Set/get the damping ratio (dimensionless).
 */ MouseJoint.prototype.setDampingRatio = function(ratio) {
                    this.m_dampingRatio = ratio;
                };
                MouseJoint.prototype.getDampingRatio = function() {
                    return this.m_dampingRatio;
                };
                MouseJoint.prototype.getAnchorA = function() {
                    return Vec2.clone(this.m_targetA);
                };
                MouseJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                MouseJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(inv_dt, this.m_impulse);
                };
                MouseJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * 0;
                };
                MouseJoint.prototype.shiftOrigin = function(newOrigin) {
                    this.m_targetA.sub(newOrigin);
                };
                MouseJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var position = this.m_bodyB.c_position;
                    var velocity = this.m_bodyB.c_velocity;
                    var cB = position.c;
                    var aB = position.a;
                    var vB = velocity.v;
                    var wB = velocity.w;
                    var qB = Rot.neo(aB);
                    var mass = this.m_bodyB.getMass();
                    // Frequency
                    var omega = 2 * Math1.PI * this.m_frequencyHz;
                    // Damping coefficient
                    var d = 2 * mass * this.m_dampingRatio * omega;
                    // Spring stiffness
                    var k = mass * (omega * omega);
                    // magic formulas
                    // gamma has units of inverse mass.
                    // beta has units of inverse time.
                    var h = step.dt;
                    _ASSERT && common1.assert(d + h * k > Math1.EPSILON);
                    this.m_gamma = h * (d + h * k);
                    if (this.m_gamma != 0) {
                        this.m_gamma = 1 / this.m_gamma;
                    }
                    this.m_beta = h * k * this.m_gamma;
                    // Compute the effective mass matrix.
                    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *
                    // invI2 * skew(r2)]
                    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y
                    // -r1.x*r1.y]
                    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]
                    var K = new Mat22();
                    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
                    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
                    this.m_mass = K.getInverse();
                    this.m_C.set(cB);
                    this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);
                    this.m_C.mul(this.m_beta);
                    // Cheat with some damping
                    wB *= .98;
                    if (step.warmStarting) {
                        this.m_impulse.mul(step.dtRatio);
                        vB.addMul(this.m_invMassB, this.m_impulse);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, this.m_impulse);
                    } else {
                        this.m_impulse.setZero();
                    }
                    velocity.v.set(vB);
                    velocity.w = wB;
                };
                MouseJoint.prototype.solveVelocityConstraints = function(step) {
                    var velocity = this.m_bodyB.c_velocity;
                    var vB = Vec2.clone(velocity.v);
                    var wB = velocity.w;
                    // Cdot = v + cross(w, r)
                    var Cdot = Vec2.cross(wB, this.m_rB);
                    Cdot.add(vB);
                    Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);
                    Cdot.neg();
                    var impulse = Mat22.mulVec2(this.m_mass, Cdot);
                    var oldImpulse = Vec2.clone(this.m_impulse);
                    this.m_impulse.add(impulse);
                    var maxImpulse = step.dt * this.m_maxForce;
                    this.m_impulse.clamp(maxImpulse);
                    impulse = Vec2.sub(this.m_impulse, oldImpulse);
                    vB.addMul(this.m_invMassB, impulse);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, impulse);
                    velocity.v.set(vB);
                    velocity.w = wB;
                };
                MouseJoint.prototype.solvePositionConstraints = function(step) {
                    return true;
                };
            },
            {
                "../Joint": 5,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        32: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = PrismaticJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                var inactiveLimit = 0;
                var atLowerLimit = 1;
                var atUpperLimit = 2;
                var equalLimits = 3;
                PrismaticJoint.TYPE = "prismatic-joint";
                PrismaticJoint._super = Joint;
                PrismaticJoint.prototype = create(PrismaticJoint._super.prototype);
                /**
 * @typedef {Object} PrismaticJointDef
 *
 * Prismatic joint definition. This requires defining a line of motion using an
 * axis and an anchor point. The definition uses local anchor points and a local
 * axis so that the initial configuration can violate the constraint slightly.
 * The joint translation is zero when the local anchor points coincide in world
 * space. Using local anchors and a local axis helps when saving and loading a
 * game.
 * 
 * @prop {boolean} enableLimit Enable/disable the joint limit.
 * @prop {float} lowerTranslation The lower translation limit, usually in
 *       meters.
 * @prop {float} upperTranslation The upper translation limit, usually in
 *       meters.
 * @prop {boolean} enableMotor Enable/disable the joint motor.
 * @prop {float} maxMotorForce The maximum motor torque, usually in N-m.
 * @prop {float} motorSpeed The desired motor speed in radians per second.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {Vec2} localAxisA The local translation unit axis in bodyA.
 * @prop {float} referenceAngle The constrained angle between the bodies:
 *       bodyB_angle - bodyA_angle.
 */ var DEFAULTS = {
                    enableLimit: false,
                    lowerTranslation: 0,
                    upperTranslation: 0,
                    enableMotor: false,
                    maxMotorForce: 0,
                    motorSpeed: 0
                };
                /**
 * A prismatic joint. This joint provides one degree of freedom: translation
 * along an axis fixed in bodyA. Relative rotation is prevented. You can use a
 * joint limit to restrict the range of motion and a joint motor to drive the
 * motion or to model joint friction.
 *
 * @param {PrismaticJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {
                    if (!(this instanceof PrismaticJoint)) {
                        return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = PrismaticJoint.TYPE;
                    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero();
                    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero();
                    this.m_localXAxisA = axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1, 0);
                    this.m_localXAxisA.normalize();
                    this.m_localYAxisA = Vec2.cross(1, this.m_localXAxisA);
                    this.m_referenceAngle = Math1.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
                    this.m_impulse = Vec3();
                    this.m_motorMass = 0;
                    this.m_motorImpulse = 0;
                    this.m_lowerTranslation = def.lowerTranslation;
                    this.m_upperTranslation = def.upperTranslation;
                    this.m_maxMotorForce = def.maxMotorForce;
                    this.m_motorSpeed = def.motorSpeed;
                    this.m_enableLimit = def.enableLimit;
                    this.m_enableMotor = def.enableMotor;
                    this.m_limitState = inactiveLimit;
                    this.m_axis = Vec2.zero();
                    this.m_perp = Vec2.zero();
                    // Solver temp
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_axis, this.m_perp;
                    // Vec2
                    this.m_s1, this.m_s2;
                    // float
                    this.m_a1, this.m_a2;
                    // float
                    this.m_K = new Mat33();
                    this.m_motorMass;
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ PrismaticJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ PrismaticJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * The local joint axis relative to bodyA.
 */ PrismaticJoint.prototype.getLocalAxisA = function() {
                    return this.m_localXAxisA;
                };
                /**
 * Get the reference angle.
 */ PrismaticJoint.prototype.getReferenceAngle = function() {
                    return this.m_referenceAngle;
                };
                /**
 * Get the current joint translation, usually in meters.
 */ PrismaticJoint.prototype.getJointTranslation = function() {
                    var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                    var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                    var d = Vec2.sub(pB, pA);
                    var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);
                    var translation = Vec2.dot(d, axis);
                    return translation;
                };
                /**
 * Get the current joint translation speed, usually in meters per second.
 */ PrismaticJoint.prototype.getJointSpeed = function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    var rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter));
                    // Vec2
                    var rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter));
                    // Vec2
                    var p1 = Vec2.add(bA.m_sweep.c, rA);
                    // Vec2
                    var p2 = Vec2.add(bB.m_sweep.c, rB);
                    // Vec2
                    var d = Vec2.sub(p2, p1);
                    // Vec2
                    var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA);
                    // Vec2
                    var vA = bA.m_linearVelocity;
                    // Vec2
                    var vB = bB.m_linearVelocity;
                    // Vec2
                    var wA = bA.m_angularVelocity;
                    // float
                    var wB = bB.m_angularVelocity;
                    // float
                    var speed = Vec2.dot(d, Vec2.cross(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCross(vB, wB, rB), Vec2.addCross(vA, wA, rA)));
                    // float
                    return speed;
                };
                /**
 * Is the joint limit enabled?
 */ PrismaticJoint.prototype.isLimitEnabled = function() {
                    return this.m_enableLimit;
                };
                /**
 * Enable/disable the joint limit.
 */ PrismaticJoint.prototype.enableLimit = function(flag) {
                    if (flag != this.m_enableLimit) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_enableLimit = flag;
                        this.m_impulse.z = 0;
                    }
                };
                /**
 * Get the lower joint limit, usually in meters.
 */ PrismaticJoint.prototype.getLowerLimit = function() {
                    return this.m_lowerTranslation;
                };
                /**
 * Get the upper joint limit, usually in meters.
 */ PrismaticJoint.prototype.getUpperLimit = function() {
                    return this.m_upperTranslation;
                };
                /**
 * Set the joint limits, usually in meters.
 */ PrismaticJoint.prototype.setLimits = function(lower, upper) {
                    _ASSERT && common1.assert(lower <= upper);
                    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_lowerTranslation = lower;
                        this.m_upperTranslation = upper;
                        this.m_impulse.z = 0;
                    }
                };
                /**
 * Is the joint motor enabled?
 */ PrismaticJoint.prototype.isMotorEnabled = function() {
                    return this.m_enableMotor;
                };
                /**
 * Enable/disable the joint motor.
 */ PrismaticJoint.prototype.enableMotor = function(flag) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_enableMotor = flag;
                };
                /**
 * Set the motor speed, usually in meters per second.
 */ PrismaticJoint.prototype.setMotorSpeed = function(speed) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_motorSpeed = speed;
                };
                /**
 * Set the maximum motor force, usually in N.
 */ PrismaticJoint.prototype.setMaxMotorForce = function(force) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_maxMotorForce = force;
                };
                /**
 * Get the motor speed, usually in meters per second.
 */ PrismaticJoint.prototype.getMotorSpeed = function() {
                    return this.m_motorSpeed;
                };
                /**
 * Get the current motor force given the inverse time step, usually in N.
 */ PrismaticJoint.prototype.getMotorForce = function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };
                PrismaticJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                PrismaticJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                PrismaticJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);
                };
                PrismaticJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * this.m_impulse.y;
                };
                PrismaticJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    // Compute the effective masses.
                    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    var d = Vec2.zero();
                    d.addCombine(1, cB, 1, rB);
                    d.subCombine(1, cA, 1, rA);
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    // Compute motor Jacobian and effective mass.
                    {
                        this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);
                        this.m_a1 = Vec2.cross(Vec2.add(d, rA), this.m_axis);
                        this.m_a2 = Vec2.cross(rB, this.m_axis);
                        this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                        if (this.m_motorMass > 0) {
                            this.m_motorMass = 1 / this.m_motorMass;
                        }
                    }
                    // Prismatic constraint.
                    {
                        this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);
                        this.m_s1 = Vec2.cross(Vec2.add(d, rA), this.m_perp);
                        this.m_s2 = Vec2.cross(rB, this.m_perp);
                        var s1test = Vec2.cross(rA, this.m_perp);
                        var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
                        var k12 = iA * this.m_s1 + iB * this.m_s2;
                        var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
                        var k22 = iA + iB;
                        if (k22 == 0) {
                            // For bodies with fixed rotation.
                            k22 = 1;
                        }
                        var k23 = iA * this.m_a1 + iB * this.m_a2;
                        var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                        this.m_K.ex.set(k11, k12, k13);
                        this.m_K.ey.set(k12, k22, k23);
                        this.m_K.ez.set(k13, k23, k33);
                    }
                    // Compute motor and limit terms.
                    if (this.m_enableLimit) {
                        var jointTranslation = Vec2.dot(this.m_axis, d);
                        // float
                        if (Math1.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * Settings.linearSlop) {
                            this.m_limitState = equalLimits;
                        } else if (jointTranslation <= this.m_lowerTranslation) {
                            if (this.m_limitState != atLowerLimit) {
                                this.m_limitState = atLowerLimit;
                                this.m_impulse.z = 0;
                            }
                        } else if (jointTranslation >= this.m_upperTranslation) {
                            if (this.m_limitState != atUpperLimit) {
                                this.m_limitState = atUpperLimit;
                                this.m_impulse.z = 0;
                            }
                        } else {
                            this.m_limitState = inactiveLimit;
                            this.m_impulse.z = 0;
                        }
                    } else {
                        this.m_limitState = inactiveLimit;
                        this.m_impulse.z = 0;
                    }
                    if (this.m_enableMotor == false) {
                        this.m_motorImpulse = 0;
                    }
                    if (step.warmStarting) {
                        // Account for variable time step.
                        this.m_impulse.mul(step.dtRatio);
                        this.m_motorImpulse *= step.dtRatio;
                        var P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis);
                        var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
                        var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
                        vA.subMul(mA, P);
                        wA -= iA * LA;
                        vB.addMul(mB, P);
                        wB += iB * LB;
                    } else {
                        this.m_impulse.setZero();
                        this.m_motorImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };
                PrismaticJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // Solve linear motor constraint.
                    if (this.m_enableMotor && this.m_limitState != equalLimits) {
                        var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;
                        var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
                        var oldImpulse = this.m_motorImpulse;
                        var maxImpulse = step.dt * this.m_maxMotorForce;
                        this.m_motorImpulse = Math1.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        var P = Vec2.mul(impulse, this.m_axis);
                        var LA = impulse * this.m_a1;
                        var LB = impulse * this.m_a2;
                        vA.subMul(mA, P);
                        wA -= iA * LA;
                        vB.addMul(mB, P);
                        wB += iB * LB;
                    }
                    var Cdot1 = Vec2.zero();
                    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;
                    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;
                    Cdot1.y = wB - wA;
                    if (this.m_enableLimit && this.m_limitState != inactiveLimit) {
                        // Solve prismatic and limit constraint in block form.
                        var Cdot2 = 0;
                        Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;
                        Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;
                        var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var f1 = Vec3(this.m_impulse);
                        var df = this.m_K.solve33(Vec3.neg(Cdot));
                        // Vec3
                        this.m_impulse.add(df);
                        if (this.m_limitState == atLowerLimit) {
                            this.m_impulse.z = Math1.max(this.m_impulse.z, 0);
                        } else if (this.m_limitState == atUpperLimit) {
                            this.m_impulse.z = Math1.min(this.m_impulse.z, 0);
                        }
                        // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
                        // f1(1:2)
                        var b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));
                        // Vec2
                        var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y));
                        // Vec2
                        this.m_impulse.x = f2r.x;
                        this.m_impulse.y = f2r.y;
                        df = Vec3.sub(this.m_impulse, f1);
                        var P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis);
                        // Vec2
                        var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
                        // float
                        var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;
                        // float
                        vA.subMul(mA, P);
                        wA -= iA * LA;
                        vB.addMul(mB, P);
                        wB += iB * LB;
                    } else {
                        // Limit is inactive, just solve the prismatic constraint in block form.
                        var df = this.m_K.solve22(Vec2.neg(Cdot1));
                        // Vec2
                        this.m_impulse.x += df.x;
                        this.m_impulse.y += df.y;
                        var P = Vec2.mul(df.x, this.m_perp);
                        // Vec2
                        var LA = df.x * this.m_s1 + df.y;
                        // float
                        var LB = df.x * this.m_s2 + df.y;
                        // float
                        vA.subMul(mA, P);
                        wA -= iA * LA;
                        vB.addMul(mB, P);
                        wB += iB * LB;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                PrismaticJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // Compute fresh Jacobians
                    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    // Vec2
                    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Vec2
                    var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));
                    // Vec2
                    var axis = Rot.mulVec2(qA, this.m_localXAxisA);
                    // Vec2
                    var a1 = Vec2.cross(Vec2.add(d, rA), axis);
                    // float
                    var a2 = Vec2.cross(rB, axis);
                    // float
                    var perp = Rot.mulVec2(qA, this.m_localYAxisA);
                    // Vec2
                    var s1 = Vec2.cross(Vec2.add(d, rA), perp);
                    // float
                    var s2 = Vec2.cross(rB, perp);
                    // float
                    var impulse = Vec3();
                    var C1 = Vec2.zero();
                    // Vec2
                    C1.x = Vec2.dot(perp, d);
                    C1.y = aB - aA - this.m_referenceAngle;
                    var linearError = Math1.abs(C1.x);
                    // float
                    var angularError = Math1.abs(C1.y);
                    // float
                    var linearSlop = Settings.linearSlop;
                    var maxLinearCorrection = Settings.maxLinearCorrection;
                    var active = false;
                    // bool
                    var C2 = 0;
                    // float
                    if (this.m_enableLimit) {
                        var translation = Vec2.dot(axis, d);
                        // float
                        if (Math1.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * linearSlop) {
                            // Prevent large angular corrections
                            C2 = Math1.clamp(translation, -maxLinearCorrection, maxLinearCorrection);
                            linearError = Math1.max(linearError, Math1.abs(translation));
                            active = true;
                        } else if (translation <= this.m_lowerTranslation) {
                            // Prevent large linear corrections and allow some slop.
                            C2 = Math1.clamp(translation - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0);
                            linearError = Math1.max(linearError, this.m_lowerTranslation - translation);
                            active = true;
                        } else if (translation >= this.m_upperTranslation) {
                            // Prevent large linear corrections and allow some slop.
                            C2 = Math1.clamp(translation - this.m_upperTranslation - linearSlop, 0, maxLinearCorrection);
                            linearError = Math1.max(linearError, translation - this.m_upperTranslation);
                            active = true;
                        }
                    }
                    if (active) {
                        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                        // float
                        var k12 = iA * s1 + iB * s2;
                        // float
                        var k13 = iA * s1 * a1 + iB * s2 * a2;
                        // float
                        var k22 = iA + iB;
                        // float
                        if (k22 == 0) {
                            // For fixed rotation
                            k22 = 1;
                        }
                        var k23 = iA * a1 + iB * a2;
                        // float
                        var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
                        // float
                        var K = new Mat33();
                        K.ex.set(k11, k12, k13);
                        K.ey.set(k12, k22, k23);
                        K.ez.set(k13, k23, k33);
                        var C = Vec3();
                        C.x = C1.x;
                        C.y = C1.y;
                        C.z = C2;
                        impulse = K.solve33(Vec3.neg(C));
                    } else {
                        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                        // float
                        var k12 = iA * s1 + iB * s2;
                        // float
                        var k22 = iA + iB;
                        // float
                        if (k22 == 0) {
                            k22 = 1;
                        }
                        var K = new Mat22();
                        K.ex.set(k11, k12);
                        K.ey.set(k12, k22);
                        var impulse1 = K.solve(Vec2.neg(C1));
                        // Vec2
                        impulse.x = impulse1.x;
                        impulse.y = impulse1.y;
                        impulse.z = 0;
                    }
                    var P = Vec2.combine(impulse.x, perp, impulse.z, axis);
                    // Vec2
                    var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
                    // float
                    var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
                    // float
                    cA.subMul(mA, P);
                    aA -= iA * LA;
                    cB.addMul(mB, P);
                    aB += iB * LB;
                    this.m_bodyA.c_position.c = cA;
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c = cB;
                    this.m_bodyB.c_position.a = aB;
                    return linearError <= Settings.linearSlop && angularError <= Settings.angularSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        33: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = PulleyJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                PulleyJoint.TYPE = "pulley-joint";
                PulleyJoint.MIN_PULLEY_LENGTH = 2;
                // minPulleyLength
                PulleyJoint._super = Joint;
                PulleyJoint.prototype = create(PulleyJoint._super.prototype);
                /**
 * @typedef {Object} PulleyJointDef
 *
 * Pulley joint definition. This requires two ground anchors, two dynamic body
 * anchor points, and a pulley ratio.
 *
 * @prop {Vec2} groundAnchorA The first ground anchor in world coordinates.
 *          This point never moves.
 * @prop {Vec2} groundAnchorB The second ground anchor in world coordinates.
 *          This point never moves.
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {float} ratio The pulley ratio, used to simulate a block-and-tackle.
 * @prop {float} lengthA The reference length for the segment attached to bodyA.
 * @prop {float} lengthB The reference length for the segment attached to bodyB.
 */ var PulleyJointDef = {
                    collideConnected: true
                };
                /**
 * The pulley joint is connected to two bodies and two fixed ground points. The
 * pulley supports a ratio such that: length1 + ratio * length2 <= constant
 * 
 * Yes, the force transmitted is scaled by the ratio.
 * 
 * Warning: the pulley joint can get a bit squirrelly by itself. They often work
 * better when combined with prismatic joints. You should also cover the the
 * anchor points with static shapes to prevent one side from going to zero
 * length.
 *
 * @param {PulleyJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {
                    if (!(this instanceof PulleyJoint)) {
                        return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);
                    }
                    def = options(def, PulleyJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = PulleyJoint.TYPE;
                    this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1, 1);
                    this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1, 1);
                    this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1, 0);
                    this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1, 0);
                    this.m_lengthA = Math1.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);
                    this.m_lengthB = Math1.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);
                    this.m_ratio = Math1.isFinite(ratio) ? ratio : def.ratio;
                    _ASSERT && common1.assert(ratio > Math1.EPSILON);
                    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;
                    this.m_impulse = 0;
                    // Solver temp
                    this.m_uA;
                    // Vec2
                    this.m_uB;
                    // Vec2
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_mass;
                }
                /**
 * Get the first ground anchor.
 */ PulleyJoint.prototype.getGroundAnchorA = function() {
                    return this.m_groundAnchorA;
                };
                /**
 * Get the second ground anchor.
 */ PulleyJoint.prototype.getGroundAnchorB = function() {
                    return this.m_groundAnchorB;
                };
                /**
 * Get the current length of the segment attached to bodyA.
 */ PulleyJoint.prototype.getLengthA = function() {
                    return this.m_lengthA;
                };
                /**
 * Get the current length of the segment attached to bodyB.
 */ PulleyJoint.prototype.getLengthB = function() {
                    return this.m_lengthB;
                };
                /**
 * Get the pulley ratio.
 */ PulleyJoint.prototype.getRatio = function() {
                    return this.m_ratio;
                };
                /**
 * Get the current length of the segment attached to bodyA.
 */ PulleyJoint.prototype.getCurrentLengthA = function() {
                    var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                    var s = this.m_groundAnchorA;
                    return Vec2.distance(p, s);
                };
                /**
 * Get the current length of the segment attached to bodyB.
 */ PulleyJoint.prototype.getCurrentLengthB = function() {
                    var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                    var s = this.m_groundAnchorB;
                    return Vec2.distance(p, s);
                };
                PulleyJoint.prototype.shiftOrigin = function(newOrigin) {
                    this.m_groundAnchorA.sub(newOrigin);
                    this.m_groundAnchorB.sub(newOrigin);
                };
                PulleyJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                PulleyJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                PulleyJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(this.m_impulse, this.m_uB).mul(inv_dt);
                };
                PulleyJoint.prototype.getReactionTorque = function(inv_dt) {
                    return 0;
                };
                PulleyJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Get the pulley axes.
                    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
                    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);
                    var lengthA = this.m_uA.length();
                    var lengthB = this.m_uB.length();
                    if (lengthA > 10 * Settings.linearSlop) {
                        this.m_uA.mul(1 / lengthA);
                    } else {
                        this.m_uA.setZero();
                    }
                    if (lengthB > 10 * Settings.linearSlop) {
                        this.m_uB.mul(1 / lengthB);
                    } else {
                        this.m_uB.setZero();
                    }
                    // Compute effective mass.
                    var ruA = Vec2.cross(this.m_rA, this.m_uA);
                    // float
                    var ruB = Vec2.cross(this.m_rB, this.m_uB);
                    // float
                    var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
                    // float
                    var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
                    // float
                    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
                    if (this.m_mass > 0) {
                        this.m_mass = 1 / this.m_mass;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support variable time steps.
                        this.m_impulse *= step.dtRatio;
                        // Warm starting.
                        var PA = Vec2.mul(-this.m_impulse, this.m_uA);
                        var PB = Vec2.mul(-this.m_ratio * this.m_impulse, this.m_uB);
                        vA.addMul(this.m_invMassA, PA);
                        wA += this.m_invIA * Vec2.cross(this.m_rA, PA);
                        vB.addMul(this.m_invMassB, PB);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, PB);
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                PulleyJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var vpA = Vec2.add(vA, Vec2.cross(wA, this.m_rA));
                    var vpB = Vec2.add(vB, Vec2.cross(wB, this.m_rB));
                    var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);
                    // float
                    var impulse = -this.m_mass * Cdot;
                    // float
                    this.m_impulse += impulse;
                    var PA = Vec2.mul(-impulse, this.m_uA);
                    // Vec2
                    var PB = Vec2.mul(-this.m_ratio * impulse, this.m_uB);
                    // Vec2
                    vA.addMul(this.m_invMassA, PA);
                    wA += this.m_invIA * Vec2.cross(this.m_rA, PA);
                    vB.addMul(this.m_invMassB, PB);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, PB);
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                PulleyJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA), qB = Rot.neo(aB);
                    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Get the pulley axes.
                    var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
                    var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);
                    var lengthA = uA.length();
                    var lengthB = uB.length();
                    if (lengthA > 10 * Settings.linearSlop) {
                        uA.mul(1 / lengthA);
                    } else {
                        uA.setZero();
                    }
                    if (lengthB > 10 * Settings.linearSlop) {
                        uB.mul(1 / lengthB);
                    } else {
                        uB.setZero();
                    }
                    // Compute effective mass.
                    var ruA = Vec2.cross(rA, uA);
                    var ruB = Vec2.cross(rB, uB);
                    var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
                    // float
                    var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
                    // float
                    var mass = mA + this.m_ratio * this.m_ratio * mB;
                    // float
                    if (mass > 0) {
                        mass = 1 / mass;
                    }
                    var C = this.m_constant - lengthA - this.m_ratio * lengthB;
                    // float
                    var linearError = Math1.abs(C);
                    // float
                    var impulse = -mass * C;
                    // float
                    var PA = Vec2.mul(-impulse, uA);
                    // Vec2
                    var PB = Vec2.mul(-this.m_ratio * impulse, uB);
                    // Vec2
                    cA.addMul(this.m_invMassA, PA);
                    aA += this.m_invIA * Vec2.cross(rA, PA);
                    cB.addMul(this.m_invMassB, PB);
                    aB += this.m_invIB * Vec2.cross(rB, PB);
                    this.m_bodyA.c_position.c = cA;
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c = cB;
                    this.m_bodyB.c_position.a = aB;
                    return linearError < Settings.linearSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        34: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = RevoluteJoint;
                var common1 = require1("../util/common");
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                var inactiveLimit = 0;
                var atLowerLimit = 1;
                var atUpperLimit = 2;
                var equalLimits = 3;
                RevoluteJoint.TYPE = "revolute-joint";
                RevoluteJoint._super = Joint;
                RevoluteJoint.prototype = create(RevoluteJoint._super.prototype);
                /**
 * @typedef {Object} RevoluteJointDef
 *
 * Revolute joint definition. This requires defining an anchor point where the
 * bodies are joined. The definition uses local anchor points so that the
 * initial configuration can violate the constraint slightly. You also need to
 * specify the initial relative angle for joint limits. This helps when saving
 * and loading a game.
 * 
 * The local anchor points are measured from the body's origin rather than the
 * center of mass because: 1. you might not know where the center of mass will
 * be. 2. if you add/remove shapes from a body and recompute the mass, the
 * joints will be broken.
 * 
 * @prop {bool} enableLimit A flag to enable joint limits.
 * @prop {bool} enableMotor A flag to enable the joint motor.
 * @prop {float} lowerAngle The lower angle for the joint limit (radians).
 * @prop {float} upperAngle The upper angle for the joint limit (radians).
 * @prop {float} motorSpeed The desired motor speed. Usually in radians per
 *       second.
 * @prop {float} maxMotorTorque The maximum motor torque used to achieve the
 *       desired motor speed. Usually in N-m.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
 *       reference state (radians).
 */ var DEFAULTS = {
                    lowerAngle: 0,
                    upperAngle: 0,
                    maxMotorTorque: 0,
                    motorSpeed: 0,
                    enableLimit: false,
                    enableMotor: false
                };
                /**
 * A revolute joint constrains two bodies to share a common point while they are
 * free to rotate about the point. The relative rotation about the shared point
 * is the joint angle. You can limit the relative rotation with a joint limit
 * that specifies a lower and upper angle. You can use a motor to drive the
 * relative rotation about the shared point. A maximum motor torque is provided
 * so that infinite forces are not generated.
 *
 * @param {RevoluteJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function RevoluteJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof RevoluteJoint)) {
                        return new RevoluteJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = RevoluteJoint.TYPE;
                    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero();
                    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero();
                    this.m_referenceAngle = Math1.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
                    this.m_impulse = Vec3();
                    this.m_motorImpulse = 0;
                    this.m_lowerAngle = def.lowerAngle;
                    this.m_upperAngle = def.upperAngle;
                    this.m_maxMotorTorque = def.maxMotorTorque;
                    this.m_motorSpeed = def.motorSpeed;
                    this.m_enableLimit = def.enableLimit;
                    this.m_enableMotor = def.enableMotor;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    // effective mass for point-to-point constraint.
                    this.m_mass = new Mat33();
                    // effective mass for motor/limit angular constraint.
                    this.m_motorMass;
                    // float
                    this.m_limitState = inactiveLimit;
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ RevoluteJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ RevoluteJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * Get the reference angle.
 */ RevoluteJoint.prototype.getReferenceAngle = function() {
                    return this.m_referenceAngle;
                };
                /**
 * Get the current joint angle in radians.
 */ RevoluteJoint.prototype.getJointAngle = function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
                };
                /**
 * Get the current joint angle speed in radians per second.
 */ RevoluteJoint.prototype.getJointSpeed = function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    return bB.m_angularVelocity - bA.m_angularVelocity;
                };
                /**
 * Is the joint motor enabled?
 */ RevoluteJoint.prototype.isMotorEnabled = function() {
                    return this.m_enableMotor;
                };
                /**
 * Enable/disable the joint motor.
 */ RevoluteJoint.prototype.enableMotor = function(flag) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_enableMotor = flag;
                };
                /**
 * Get the current motor torque given the inverse time step. Unit is N*m.
 */ RevoluteJoint.prototype.getMotorTorque = function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };
                /**
 * Set the motor speed in radians per second.
 */ RevoluteJoint.prototype.setMotorSpeed = function(speed) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_motorSpeed = speed;
                };
                /**
 * Get the motor speed in radians per second.
 */ RevoluteJoint.prototype.getMotorSpeed = function() {
                    return this.m_motorSpeed;
                };
                /**
 * Set the maximum motor torque, usually in N-m.
 */ RevoluteJoint.prototype.setMaxMotorTorque = function(torque) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_maxMotorTorque = torque;
                };
                /**
 * Is the joint limit enabled?
 */ RevoluteJoint.prototype.isLimitEnabled = function() {
                    return this.m_enableLimit;
                };
                /**
 * Enable/disable the joint limit.
 */ RevoluteJoint.prototype.enableLimit = function(flag) {
                    if (flag != this.m_enableLimit) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_enableLimit = flag;
                        this.m_impulse.z = 0;
                    }
                };
                /**
 * Get the lower joint limit in radians.
 */ RevoluteJoint.prototype.getLowerLimit = function() {
                    return this.m_lowerAngle;
                };
                /**
 * Get the upper joint limit in radians.
 */ RevoluteJoint.prototype.getUpperLimit = function() {
                    return this.m_upperAngle;
                };
                /**
 * Set the joint limits in radians.
 */ RevoluteJoint.prototype.setLimits = function(lower, upper) {
                    _ASSERT && common1.assert(lower <= upper);
                    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_impulse.z = 0;
                        this.m_lowerAngle = lower;
                        this.m_upperAngle = upper;
                    }
                };
                RevoluteJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                RevoluteJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                /**
 * Get the reaction force given the inverse time step. Unit is N.
 */ RevoluteJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
                };
                /**
 * Get the reaction torque due to the joint limit given the inverse time step.
 * Unit is N*m.
 */ RevoluteJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * this.m_impulse.z;
                };
                RevoluteJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var fixedRotation = iA + iB === 0;
                    // bool
                    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
                    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
                    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
                    this.m_mass.ex.y = this.m_mass.ey.x;
                    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
                    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
                    this.m_mass.ex.z = this.m_mass.ez.x;
                    this.m_mass.ey.z = this.m_mass.ez.y;
                    this.m_mass.ez.z = iA + iB;
                    this.m_motorMass = iA + iB;
                    if (this.m_motorMass > 0) {
                        this.m_motorMass = 1 / this.m_motorMass;
                    }
                    if (this.m_enableMotor == false || fixedRotation) {
                        this.m_motorImpulse = 0;
                    }
                    if (this.m_enableLimit && fixedRotation == false) {
                        var jointAngle = aB - aA - this.m_referenceAngle;
                        // float
                        if (Math1.abs(this.m_upperAngle - this.m_lowerAngle) < 2 * Settings.angularSlop) {
                            this.m_limitState = equalLimits;
                        } else if (jointAngle <= this.m_lowerAngle) {
                            if (this.m_limitState != atLowerLimit) {
                                this.m_impulse.z = 0;
                            }
                            this.m_limitState = atLowerLimit;
                        } else if (jointAngle >= this.m_upperAngle) {
                            if (this.m_limitState != atUpperLimit) {
                                this.m_impulse.z = 0;
                            }
                            this.m_limitState = atUpperLimit;
                        } else {
                            this.m_limitState = inactiveLimit;
                            this.m_impulse.z = 0;
                        }
                    } else {
                        this.m_limitState = inactiveLimit;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_impulse.mul(step.dtRatio);
                        this.m_motorImpulse *= step.dtRatio;
                        var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                        vA.subMul(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);
                        vB.addMul(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
                    } else {
                        this.m_impulse.setZero();
                        this.m_motorImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                RevoluteJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var fixedRotation = iA + iB === 0;
                    // bool
                    // Solve motor constraint.
                    if (this.m_enableMotor && this.m_limitState != equalLimits && fixedRotation == false) {
                        var Cdot = wB - wA - this.m_motorSpeed;
                        // float
                        var impulse = -this.m_motorMass * Cdot;
                        // float
                        var oldImpulse = this.m_motorImpulse;
                        // float
                        var maxImpulse = step.dt * this.m_maxMotorTorque;
                        // float
                        this.m_motorImpulse = Math1.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve limit constraint.
                    if (this.m_enableLimit && this.m_limitState != inactiveLimit && fixedRotation == false) {
                        var Cdot1 = Vec2.zero();
                        Cdot1.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot1.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        var Cdot2 = wB - wA;
                        // float
                        var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var impulse = Vec3.neg(this.m_mass.solve33(Cdot));
                        // Vec3
                        if (this.m_limitState == equalLimits) {
                            this.m_impulse.add(impulse);
                        } else if (this.m_limitState == atLowerLimit) {
                            var newImpulse = this.m_impulse.z + impulse.z;
                            // float
                            if (newImpulse < 0) {
                                var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
                                // Vec2
                                var reduced = this.m_mass.solve22(rhs);
                                // Vec2
                                impulse.x = reduced.x;
                                impulse.y = reduced.y;
                                impulse.z = -this.m_impulse.z;
                                this.m_impulse.x += reduced.x;
                                this.m_impulse.y += reduced.y;
                                this.m_impulse.z = 0;
                            } else {
                                this.m_impulse.add(impulse);
                            }
                        } else if (this.m_limitState == atUpperLimit) {
                            var newImpulse = this.m_impulse.z + impulse.z;
                            // float
                            if (newImpulse > 0) {
                                var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
                                // Vec2
                                var reduced = this.m_mass.solve22(rhs);
                                // Vec2
                                impulse.x = reduced.x;
                                impulse.y = reduced.y;
                                impulse.z = -this.m_impulse.z;
                                this.m_impulse.x += reduced.x;
                                this.m_impulse.y += reduced.y;
                                this.m_impulse.z = 0;
                            } else {
                                this.m_impulse.add(impulse);
                            }
                        }
                        var P = Vec2.neo(impulse.x, impulse.y);
                        vA.subMul(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + impulse.z);
                        vB.addMul(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + impulse.z);
                    } else {
                        // Solve point-to-point constraint
                        var Cdot = Vec2.zero();
                        Cdot.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        var impulse = this.m_mass.solve22(Vec2.neg(Cdot));
                        // Vec2
                        this.m_impulse.x += impulse.x;
                        this.m_impulse.y += impulse.y;
                        vA.subMul(mA, impulse);
                        wA -= iA * Vec2.cross(this.m_rA, impulse);
                        vB.addMul(mB, impulse);
                        wB += iB * Vec2.cross(this.m_rB, impulse);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                RevoluteJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var angularError = 0;
                    // float
                    var positionError = 0;
                    // float
                    var fixedRotation = this.m_invIA + this.m_invIB == 0;
                    // bool
                    // Solve angular limit constraint.
                    if (this.m_enableLimit && this.m_limitState != inactiveLimit && fixedRotation == false) {
                        var angle = aB - aA - this.m_referenceAngle;
                        // float
                        var limitImpulse = 0;
                        // float
                        if (this.m_limitState == equalLimits) {
                            // Prevent large angular corrections
                            var C = Math1.clamp(angle - this.m_lowerAngle, -Settings.maxAngularCorrection, Settings.maxAngularCorrection);
                            // float
                            limitImpulse = -this.m_motorMass * C;
                            angularError = Math1.abs(C);
                        } else if (this.m_limitState == atLowerLimit) {
                            var C = angle - this.m_lowerAngle;
                            // float
                            angularError = -C;
                            // Prevent large angular corrections and allow some slop.
                            C = Math1.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection, 0);
                            limitImpulse = -this.m_motorMass * C;
                        } else if (this.m_limitState == atUpperLimit) {
                            var C = angle - this.m_upperAngle;
                            // float
                            angularError = C;
                            // Prevent large angular corrections and allow some slop.
                            C = Math1.clamp(C - Settings.angularSlop, 0, Settings.maxAngularCorrection);
                            limitImpulse = -this.m_motorMass * C;
                        }
                        aA -= this.m_invIA * limitImpulse;
                        aB += this.m_invIB * limitImpulse;
                    }
                    // Solve point-to-point constraint.
                    {
                        qA.set(aA);
                        qB.set(aB);
                        var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                        // Vec2
                        var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                        // Vec2
                        var C = Vec2.zero();
                        C.addCombine(1, cB, 1, rB);
                        C.subCombine(1, cA, 1, rA);
                        positionError = C.length();
                        var mA = this.m_invMassA;
                        var mB = this.m_invMassB;
                        // float
                        var iA = this.m_invIA;
                        var iB = this.m_invIB;
                        // float
                        var K = new Mat22();
                        K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
                        K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
                        K.ey.x = K.ex.y;
                        K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
                        var impulse = Vec2.neg(K.solve(C));
                        // Vec2
                        cA.subMul(mA, impulse);
                        aA -= iA * Vec2.cross(rA, impulse);
                        cB.addMul(mB, impulse);
                        aB += iB * Vec2.cross(rB, impulse);
                    }
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        35: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = RopeJoint;
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                var inactiveLimit = 0;
                var atLowerLimit = 1;
                var atUpperLimit = 2;
                var equalLimits = 3;
                RopeJoint.TYPE = "rope-joint";
                RopeJoint._super = Joint;
                RopeJoint.prototype = create(RopeJoint._super.prototype);
                /**
 * @typedef {Object} RopeJointDef
 *
 * Rope joint definition. This requires two body anchor points and a maximum
 * lengths. Note: by default the connected objects will not collide. see
 * collideConnected in JointDef.
 *
 * @prop {float} maxLength The maximum length of the rope. Warning: this must be
 *       larger than linearSlop or the joint will have no effect.
 *
 * @prop {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
 */ var DEFAULTS = {
                    maxLength: 0
                };
                /**
 * A rope joint enforces a maximum distance between two points on two bodies. It
 * has no other effect.
 * 
 * Warning: if you attempt to change the maximum length during the simulation
 * you will get some non-physical behavior.
 * 
 * A model that would allow you to dynamically modify the length would have some
 * sponginess, so I chose not to implement it that way. See DistanceJoint if you
 * want to dynamically control length.
 *
 * @param {RopeJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function RopeJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof RopeJoint)) {
                        return new RopeJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = RopeJoint.TYPE;
                    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1, 0);
                    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1, 0);
                    this.m_maxLength = def.maxLength;
                    this.m_mass = 0;
                    this.m_impulse = 0;
                    this.m_length = 0;
                    this.m_state = inactiveLimit;
                    // Solver temp
                    this.m_u;
                    // Vec2
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_mass;
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ RopeJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ RopeJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * Set/Get the maximum length of the rope.
 */ RopeJoint.prototype.setMaxLength = function(length) {
                    this.m_maxLength = length;
                };
                RopeJoint.prototype.getMaxLength = function() {
                    return this.m_maxLength;
                };
                RopeJoint.prototype.getLimitState = function() {
                    // TODO LimitState
                    return this.m_state;
                };
                RopeJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                RopeJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                RopeJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.mul(this.m_impulse, this.m_u).mul(inv_dt);
                };
                RopeJoint.prototype.getReactionTorque = function(inv_dt) {
                    return 0;
                };
                RopeJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
                    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
                    this.m_u = Vec2.zero();
                    this.m_u.addCombine(1, cB, 1, this.m_rB);
                    this.m_u.subCombine(1, cA, 1, this.m_rA);
                    // Vec2
                    this.m_length = this.m_u.length();
                    var C = this.m_length - this.m_maxLength;
                    // float
                    if (C > 0) {
                        this.m_state = atUpperLimit;
                    } else {
                        this.m_state = inactiveLimit;
                    }
                    if (this.m_length > Settings.linearSlop) {
                        this.m_u.mul(1 / this.m_length);
                    } else {
                        this.m_u.setZero();
                        this.m_mass = 0;
                        this.m_impulse = 0;
                        return;
                    }
                    // Compute effective mass.
                    var crA = Vec2.cross(this.m_rA, this.m_u);
                    // float
                    var crB = Vec2.cross(this.m_rB, this.m_u);
                    // float
                    var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
                    // float
                    this.m_mass = invMass != 0 ? 1 / invMass : 0;
                    if (step.warmStarting) {
                        // Scale the impulse to support a variable time step.
                        this.m_impulse *= step.dtRatio;
                        var P = Vec2.mul(this.m_impulse, this.m_u);
                        vA.subMul(this.m_invMassA, P);
                        wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                        vB.addMul(this.m_invMassB, P);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };
                RopeJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    // Cdot = dot(u, v + cross(w, r))
                    var vpA = Vec2.addCross(vA, wA, this.m_rA);
                    // Vec2
                    var vpB = Vec2.addCross(vB, wB, this.m_rB);
                    // Vec2
                    var C = this.m_length - this.m_maxLength;
                    // float
                    var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));
                    // float
                    // Predictive constraint.
                    if (C < 0) {
                        Cdot += step.inv_dt * C;
                    }
                    var impulse = -this.m_mass * Cdot;
                    // float
                    var oldImpulse = this.m_impulse;
                    // float
                    this.m_impulse = Math1.min(0, this.m_impulse + impulse);
                    impulse = this.m_impulse - oldImpulse;
                    var P = Vec2.mul(impulse, this.m_u);
                    // Vec2
                    vA.subMul(this.m_invMassA, P);
                    wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                    vB.addMul(this.m_invMassB, P);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                RopeJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    // Vec2
                    var aA = this.m_bodyA.c_position.a;
                    // float
                    var cB = this.m_bodyB.c_position.c;
                    // Vec2
                    var aB = this.m_bodyB.c_position.a;
                    // float
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
                    var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
                    var u = Vec2.zero();
                    u.addCombine(1, cB, 1, rB);
                    u.subCombine(1, cA, 1, rA);
                    // Vec2
                    var length = u.normalize();
                    // float
                    var C = length - this.m_maxLength;
                    // float
                    C = Math1.clamp(C, 0, Settings.maxLinearCorrection);
                    var impulse = -this.m_mass * C;
                    // float
                    var P = Vec2.mul(impulse, u);
                    // Vec2
                    cA.subMul(this.m_invMassA, P);
                    aA -= this.m_invIA * Vec2.cross(rA, P);
                    cB.addMul(this.m_invMassB, P);
                    aB += this.m_invIB * Vec2.cross(rB, P);
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return length - this.m_maxLength < Settings.linearSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        36: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = WeldJoint;
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                WeldJoint.TYPE = "weld-joint";
                WeldJoint._super = Joint;
                WeldJoint.prototype = create(WeldJoint._super.prototype);
                /**
 * @typedef {Object} WeldJointDef
 *
 * Weld joint definition. You need to specify local anchor points where they are
 * attached and the relative body angle. The position of the anchor points is
 * important for computing the reaction torque.
 * 
 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. Rotation
 *       only. Disable softness with a value of 0.
 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
 *       damping.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
 *       reference state (radians).
 */ var DEFAULTS = {
                    frequencyHz: 0,
                    dampingRatio: 0
                };
                /**
 * A weld joint essentially glues two bodies together. A weld joint may distort
 * somewhat because the island constraint solver is approximate.
 *
 * @param {WeldJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function WeldJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof WeldJoint)) {
                        return new WeldJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = WeldJoint.TYPE;
                    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero();
                    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero();
                    this.m_referenceAngle = Math1.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_impulse = Vec3();
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_mass = new Mat33();
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ WeldJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ WeldJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * Get the reference angle.
 */ WeldJoint.prototype.getReferenceAngle = function() {
                    return this.m_referenceAngle;
                };
                /**
 * Set/get frequency in Hz.
 */ WeldJoint.prototype.setFrequency = function(hz) {
                    this.m_frequencyHz = hz;
                };
                WeldJoint.prototype.getFrequency = function() {
                    return this.m_frequencyHz;
                };
                /**
 * Set/get damping ratio.
 */ WeldJoint.prototype.setDampingRatio = function(ratio) {
                    this.m_dampingRatio = ratio;
                };
                WeldJoint.prototype.getDampingRatio = function() {
                    return this.m_dampingRatio;
                };
                WeldJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                WeldJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                WeldJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
                };
                WeldJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * this.m_impulse.z;
                };
                WeldJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA), qB = Rot.neo(aB);
                    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var K = new Mat33();
                    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
                    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
                    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
                    K.ex.y = K.ey.x;
                    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
                    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
                    K.ex.z = K.ez.x;
                    K.ey.z = K.ez.y;
                    K.ez.z = iA + iB;
                    if (this.m_frequencyHz > 0) {
                        K.getInverse22(this.m_mass);
                        var invM = iA + iB;
                        // float
                        var m = invM > 0 ? 1 / invM : 0;
                        // float
                        var C = aB - aA - this.m_referenceAngle;
                        // float
                        // Frequency
                        var omega = 2 * Math1.PI * this.m_frequencyHz;
                        // float
                        // Damping coefficient
                        var d = 2 * m * this.m_dampingRatio * omega;
                        // float
                        // Spring stiffness
                        var k = m * omega * omega;
                        // float
                        // magic formulas
                        var h = step.dt;
                        // float
                        this.m_gamma = h * (d + h * k);
                        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
                        this.m_bias = C * h * k * this.m_gamma;
                        invM += this.m_gamma;
                        this.m_mass.ez.z = invM != 0 ? 1 / invM : 0;
                    } else if (K.ez.z == 0) {
                        K.getInverse22(this.m_mass);
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    } else {
                        K.getSymInverse33(this.m_mass);
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_impulse.mul(step.dtRatio);
                        var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                        vA.subMul(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_impulse.z);
                        vB.addMul(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_impulse.z);
                    } else {
                        this.m_impulse.setZero();
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                WeldJoint.prototype.solveVelocityConstraints = function(step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    if (this.m_frequencyHz > 0) {
                        var Cdot2 = wB - wA;
                        // float
                        var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
                        // float
                        this.m_impulse.z += impulse2;
                        wA -= iA * impulse2;
                        wB += iB * impulse2;
                        var Cdot1 = Vec2.zero();
                        Cdot1.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot1.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        // Vec2
                        var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1));
                        // Vec2
                        this.m_impulse.x += impulse1.x;
                        this.m_impulse.y += impulse1.y;
                        var P = Vec2.clone(impulse1);
                        // Vec2
                        vA.subMul(mA, P);
                        wA -= iA * Vec2.cross(this.m_rA, P);
                        vB.addMul(mB, P);
                        wB += iB * Vec2.cross(this.m_rB, P);
                    } else {
                        var Cdot1 = Vec2.zero();
                        Cdot1.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot1.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        // Vec2
                        var Cdot2 = wB - wA;
                        // float
                        var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        // Vec3
                        var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot));
                        // Vec3
                        this.m_impulse.add(impulse);
                        var P = Vec2.neo(impulse.x, impulse.y);
                        vA.subMul(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + impulse.z);
                        vB.addMul(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + impulse.z);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };
                WeldJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA), qB = Rot.neo(aB);
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA, iB = this.m_invIB;
                    // float
                    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    var positionError, angularError;
                    // float
                    var K = new Mat33();
                    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
                    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
                    K.ez.x = -rA.y * iA - rB.y * iB;
                    K.ex.y = K.ey.x;
                    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
                    K.ez.y = rA.x * iA + rB.x * iB;
                    K.ex.z = K.ez.x;
                    K.ey.z = K.ez.y;
                    K.ez.z = iA + iB;
                    if (this.m_frequencyHz > 0) {
                        var C1 = Vec2.zero();
                        C1.addCombine(1, cB, 1, rB);
                        C1.subCombine(1, cA, 1, rA);
                        // Vec2
                        positionError = C1.length();
                        angularError = 0;
                        var P = Vec2.neg(K.solve22(C1));
                        // Vec2
                        cA.subMul(mA, P);
                        aA -= iA * Vec2.cross(rA, P);
                        cB.addMul(mB, P);
                        aB += iB * Vec2.cross(rB, P);
                    } else {
                        var C1 = Vec2.zero();
                        C1.addCombine(1, cB, 1, rB);
                        C1.subCombine(1, cA, 1, rA);
                        var C2 = aB - aA - this.m_referenceAngle;
                        // float
                        positionError = C1.length();
                        angularError = Math1.abs(C2);
                        var C = Vec3(C1.x, C1.y, C2);
                        var impulse = Vec3();
                        if (K.ez.z > 0) {
                            impulse = Vec3.neg(K.solve33(C));
                        } else {
                            var impulse2 = Vec2.neg(K.solve22(C1));
                            impulse.set(impulse2.x, impulse2.y, 0);
                        }
                        var P = Vec2.neo(impulse.x, impulse.y);
                        cA.subMul(mA, P);
                        aA -= iA * (Vec2.cross(rA, P) + impulse.z);
                        cB.addMul(mB, P);
                        aB += iB * (Vec2.cross(rB, P) + impulse.z);
                    }
                    this.m_bodyA.c_position.c = cA;
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c = cB;
                    this.m_bodyB.c_position.a = aB;
                    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        37: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = WheelJoint;
                var options = require1("../util/options");
                var create = require1("../util/create");
                var Settings = require1("../Settings");
                var Math1 = require1("../common/Math");
                var Vec2 = require1("../common/Vec2");
                var Vec3 = require1("../common/Vec3");
                var Mat22 = require1("../common/Mat22");
                var Mat33 = require1("../common/Mat33");
                var Rot = require1("../common/Rot");
                var Sweep = require1("../common/Sweep");
                var Transform = require1("../common/Transform");
                var Velocity = require1("../common/Velocity");
                var Position = require1("../common/Position");
                var Joint = require1("../Joint");
                WheelJoint.TYPE = "wheel-joint";
                WheelJoint._super = Joint;
                WheelJoint.prototype = create(WheelJoint._super.prototype);
                /**
 * @typedef {Object} WheelJointDef
 *
 * Wheel joint definition. This requires defining a line of motion using an axis
 * and an anchor point. The definition uses local anchor points and a local axis
 * so that the initial configuration can violate the constraint slightly. The
 * joint translation is zero when the local anchor points coincide in world
 * space. Using local anchors and a local axis helps when saving and loading a
 * game.
 * 
 * @prop {boolean} enableMotor Enable/disable the joint motor.
 * @prop {float} maxMotorTorque The maximum motor torque, usually in N-m.
 * @prop {float} motorSpeed The desired motor speed in radians per second.
 * @prop {float} frequencyHz Suspension frequency, zero indicates no suspension.
 * @prop {float} dampingRatio Suspension damping ratio, one indicates critical
 *       damping.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {Vec2} localAxisA The local translation axis in bodyA.
 */ var DEFAULTS = {
                    enableMotor: false,
                    maxMotorTorque: 0,
                    motorSpeed: 0,
                    frequencyHz: 2,
                    dampingRatio: .7
                };
                /**
 * A wheel joint. This joint provides two degrees of freedom: translation along
 * an axis fixed in bodyA and rotation in the plane. In other words, it is a
 * point to line constraint with a rotational motor and a linear spring/damper.
 * This joint is designed for vehicle suspensions.
 *
 * @param {WheelJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */ function WheelJoint(def, bodyA, bodyB, anchor, axis) {
                    if (!(this instanceof WheelJoint)) {
                        return new WheelJoint(def, bodyA, bodyB, anchor, axis);
                    }
                    def = options(def, DEFAULTS);
                    Joint.call(this, def, bodyA, bodyB);
                    bodyA = this.m_bodyA;
                    bodyB = this.m_bodyB;
                    this.m_type = WheelJoint.TYPE;
                    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero();
                    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero();
                    this.m_localAxis = axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1, 0);
                    this.m_localXAxisA = this.m_localAxis;
                    this.m_localYAxisA = Vec2.cross(1, this.m_localXAxisA);
                    this.m_mass = 0;
                    this.m_impulse = 0;
                    this.m_motorMass = 0;
                    this.m_motorImpulse = 0;
                    this.m_springMass = 0;
                    this.m_springImpulse = 0;
                    this.m_maxMotorTorque = def.maxMotorTorque;
                    this.m_motorSpeed = def.motorSpeed;
                    this.m_enableMotor = def.enableMotor;
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    // Solver temp
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_ax = Vec2.zero();
                    this.m_ay = Vec2.zero();
                    // Vec2
                    this.m_sAx;
                    this.m_sBx;
                    // float
                    this.m_sAy;
                    this.m_sBy;
                }
                /**
 * The local anchor point relative to bodyA's origin.
 */ WheelJoint.prototype.getLocalAnchorA = function() {
                    return this.m_localAnchorA;
                };
                /**
 * The local anchor point relative to bodyB's origin.
 */ WheelJoint.prototype.getLocalAnchorB = function() {
                    return this.m_localAnchorB;
                };
                /**
 * The local joint axis relative to bodyA.
 */ WheelJoint.prototype.getLocalAxisA = function() {
                    return this.m_localXAxisA;
                };
                /**
 * Get the current joint translation, usually in meters.
 */ WheelJoint.prototype.getJointTranslation = function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    var pA = bA.getWorldPoint(this.m_localAnchorA);
                    // Vec2
                    var pB = bB.getWorldPoint(this.m_localAnchorB);
                    // Vec2
                    var d = Vec2.sub(pB, pA);
                    // Vec2
                    var axis = bA.getWorldVector(this.m_localXAxisA);
                    // Vec2
                    var translation = Vec2.dot(d, axis);
                    // float
                    return translation;
                };
                /**
 * Get the current joint translation speed, usually in meters per second.
 */ WheelJoint.prototype.getJointSpeed = function() {
                    var wA = this.m_bodyA.m_angularVelocity;
                    var wB = this.m_bodyB.m_angularVelocity;
                    return wB - wA;
                };
                /**
 * Is the joint motor enabled?
 */ WheelJoint.prototype.isMotorEnabled = function() {
                    return this.m_enableMotor;
                };
                /**
 * Enable/disable the joint motor.
 */ WheelJoint.prototype.enableMotor = function(flag) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_enableMotor = flag;
                };
                /**
 * Set the motor speed, usually in radians per second.
 */ WheelJoint.prototype.setMotorSpeed = function(speed) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_motorSpeed = speed;
                };
                /**
 * Get the motor speed, usually in radians per second.
 */ WheelJoint.prototype.getMotorSpeed = function() {
                    return this.m_motorSpeed;
                };
                /**
 * Set/Get the maximum motor force, usually in N-m.
 */ WheelJoint.prototype.setMaxMotorTorque = function(torque) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_maxMotorTorque = torque;
                };
                WheelJoint.prototype.getMaxMotorTorque = function() {
                    return this.m_maxMotorTorque;
                };
                /**
 * Get the current motor torque given the inverse time step, usually in N-m.
 */ WheelJoint.prototype.getMotorTorque = function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };
                /**
 * Set/Get the spring frequency in hertz. Setting the frequency to zero disables
 * the spring.
 */ WheelJoint.prototype.setSpringFrequencyHz = function(hz) {
                    this.m_frequencyHz = hz;
                };
                WheelJoint.prototype.getSpringFrequencyHz = function() {
                    return this.m_frequencyHz;
                };
                /**
 * Set/Get the spring damping ratio
 */ WheelJoint.prototype.setSpringDampingRatio = function(ratio) {
                    this.m_dampingRatio = ratio;
                };
                WheelJoint.prototype.getSpringDampingRatio = function() {
                    return this.m_dampingRatio;
                };
                WheelJoint.prototype.getAnchorA = function() {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };
                WheelJoint.prototype.getAnchorB = function() {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };
                WheelJoint.prototype.getReactionForce = function(inv_dt) {
                    return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);
                };
                WheelJoint.prototype.getReactionTorque = function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };
                WheelJoint.prototype.initVelocityConstraints = function(step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    // Compute the effective masses.
                    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    var d = Vec2.zero();
                    d.addCombine(1, cB, 1, rB);
                    d.subCombine(1, cA, 1, rA);
                    // Vec2
                    // Point to line constraint
                    {
                        this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);
                        this.m_sAy = Vec2.cross(Vec2.add(d, rA), this.m_ay);
                        this.m_sBy = Vec2.cross(rB, this.m_ay);
                        this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
                        if (this.m_mass > 0) {
                            this.m_mass = 1 / this.m_mass;
                        }
                    }
                    // Spring constraint
                    this.m_springMass = 0;
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    if (this.m_frequencyHz > 0) {
                        this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);
                        this.m_sAx = Vec2.cross(Vec2.add(d, rA), this.m_ax);
                        this.m_sBx = Vec2.cross(rB, this.m_ax);
                        var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
                        // float
                        if (invMass > 0) {
                            this.m_springMass = 1 / invMass;
                            var C = Vec2.dot(d, this.m_ax);
                            // float
                            // Frequency
                            var omega = 2 * Math1.PI * this.m_frequencyHz;
                            // float
                            // Damping coefficient
                            var d = 2 * this.m_springMass * this.m_dampingRatio * omega;
                            // float
                            // Spring stiffness
                            var k = this.m_springMass * omega * omega;
                            // float
                            // magic formulas
                            var h = step.dt;
                            // float
                            this.m_gamma = h * (d + h * k);
                            if (this.m_gamma > 0) {
                                this.m_gamma = 1 / this.m_gamma;
                            }
                            this.m_bias = C * h * k * this.m_gamma;
                            this.m_springMass = invMass + this.m_gamma;
                            if (this.m_springMass > 0) {
                                this.m_springMass = 1 / this.m_springMass;
                            }
                        }
                    } else {
                        this.m_springImpulse = 0;
                    }
                    // Rotational motor
                    if (this.m_enableMotor) {
                        this.m_motorMass = iA + iB;
                        if (this.m_motorMass > 0) {
                            this.m_motorMass = 1 / this.m_motorMass;
                        }
                    } else {
                        this.m_motorMass = 0;
                        this.m_motorImpulse = 0;
                    }
                    if (step.warmStarting) {
                        // Account for variable time step.
                        this.m_impulse *= step.dtRatio;
                        this.m_springImpulse *= step.dtRatio;
                        this.m_motorImpulse *= step.dtRatio;
                        var P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);
                        var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
                        var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
                        vA.subMul(this.m_invMassA, P);
                        wA -= this.m_invIA * LA;
                        vB.addMul(this.m_invMassB, P);
                        wB += this.m_invIB * LB;
                    } else {
                        this.m_impulse = 0;
                        this.m_springImpulse = 0;
                        this.m_motorImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };
                WheelJoint.prototype.solveVelocityConstraints = function(step) {
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    // Solve spring constraint
                    {
                        var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx * wB - this.m_sAx * wA;
                        // float
                        var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
                        // float
                        this.m_springImpulse += impulse;
                        var P = Vec2.mul(impulse, this.m_ax);
                        // Vec2
                        var LA = impulse * this.m_sAx;
                        // float
                        var LB = impulse * this.m_sBx;
                        // float
                        vA.subMul(mA, P);
                        wA -= iA * LA;
                        vB.addMul(mB, P);
                        wB += iB * LB;
                    }
                    // Solve rotational motor constraint
                    {
                        var Cdot = wB - wA - this.m_motorSpeed;
                        // float
                        var impulse = -this.m_motorMass * Cdot;
                        // float
                        var oldImpulse = this.m_motorImpulse;
                        // float
                        var maxImpulse = step.dt * this.m_maxMotorTorque;
                        // float
                        this.m_motorImpulse = Math1.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve point to line constraint
                    {
                        var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy * wB - this.m_sAy * wA;
                        // float
                        var impulse = -this.m_mass * Cdot;
                        // float
                        this.m_impulse += impulse;
                        var P = Vec2.mul(impulse, this.m_ay);
                        // Vec2
                        var LA = impulse * this.m_sAy;
                        // float
                        var LB = impulse * this.m_sBy;
                        // float
                        vA.subMul(mA, P);
                        wA -= iA * LA;
                        vB.addMul(mB, P);
                        wB += iB * LB;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };
                WheelJoint.prototype.solvePositionConstraints = function(step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    var d = Vec2.zero();
                    d.addCombine(1, cB, 1, rB);
                    d.subCombine(1, cA, 1, rA);
                    var ay = Rot.mulVec2(qA, this.m_localYAxisA);
                    var sAy = Vec2.cross(Vec2.add(d, rA), ay);
                    // float
                    var sBy = Vec2.cross(rB, ay);
                    // float
                    var C = Vec2.dot(d, ay);
                    // float
                    var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
                    // float
                    var impulse;
                    // float
                    if (k != 0) {
                        impulse = -C / k;
                    } else {
                        impulse = 0;
                    }
                    var P = Vec2.mul(impulse, ay);
                    // Vec2
                    var LA = impulse * sAy;
                    // float
                    var LB = impulse * sBy;
                    // float
                    cA.subMul(this.m_invMassA, P);
                    aA -= this.m_invIA * LA;
                    cB.addMul(this.m_invMassB, P);
                    aB += this.m_invIB * LB;
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return Math1.abs(C) <= Settings.linearSlop;
                };
            },
            {
                "../Joint": 5,
                "../Settings": 7,
                "../common/Mat22": 16,
                "../common/Mat33": 17,
                "../common/Math": 18,
                "../common/Position": 19,
                "../common/Rot": 20,
                "../common/Sweep": 21,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../common/Vec3": 24,
                "../common/Velocity": 25,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        38: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = BoxShape;
                var common1 = require1("../util/common");
                var create = require1("../util/create");
                var PolygonShape = require1("./PolygonShape");
                BoxShape._super = PolygonShape;
                BoxShape.prototype = create(BoxShape._super.prototype);
                BoxShape.TYPE = "polygon";
                /**
 * A rectangle polygon which extend PolygonShape.
 */ function BoxShape(hx, hy, center, angle) {
                    if (!(this instanceof BoxShape)) {
                        return new BoxShape(hx, hy, center, angle);
                    }
                    BoxShape._super.call(this);
                    this._setAsBox(hx, hy, center, angle);
                }
            },
            {
                "../util/common": 50,
                "../util/create": 51,
                "./PolygonShape": 47
            }
        ],
        39: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = ChainShape;
                var common1 = require1("../util/common");
                var create = require1("../util/create");
                var options = require1("../util/options");
                var Math1 = require1("../common/Math");
                var Transform = require1("../common/Transform");
                var Rot = require1("../common/Rot");
                var Vec2 = require1("../common/Vec2");
                var AABB = require1("../collision/AABB");
                var Settings = require1("../Settings");
                var Shape = require1("../Shape");
                var EdgeShape = require1("./EdgeShape");
                ChainShape._super = Shape;
                ChainShape.prototype = create(ChainShape._super.prototype);
                ChainShape.TYPE = "chain";
                /**
 * A chain shape is a free form sequence of line segments. The chain has
 * two-sided collision, so you can use inside and outside collision. Therefore,
 * you may use any winding order. Connectivity information is used to create
 * smooth collisions.
 * 
 * WARNING: The chain will not collide properly if there are self-intersections.
 */ function ChainShape(vertices, loop) {
                    if (!(this instanceof ChainShape)) {
                        return new ChainShape(vertices, loop);
                    }
                    ChainShape._super.call(this);
                    this.m_type = ChainShape.TYPE;
                    this.m_radius = Settings.polygonRadius;
                    this.m_vertices = [];
                    this.m_count = 0;
                    this.m_prevVertex = null;
                    this.m_nextVertex = null;
                    this.m_hasPrevVertex = false;
                    this.m_hasNextVertex = false;
                    if (vertices && vertices.length) {
                        if (loop) {
                            this._createLoop(vertices);
                        } else {
                            this._createChain(vertices);
                        }
                    }
                }
                // ChainShape.clear = function() {
                // this.m_vertices.length = 0;
                // this.m_count = 0;
                // }
                /**
 * Create a loop. This automatically adjusts connectivity.
 * 
 * @param vertices an array of vertices, these are copied
 * @param count the vertex count
 */ ChainShape.prototype._createLoop = function(vertices) {
                    _ASSERT && common1.assert(this.m_vertices.length == 0 && this.m_count == 0);
                    _ASSERT && common1.assert(vertices.length >= 3);
                    for(var i = 1; i < vertices.length; ++i){
                        var v1 = vertices[i - 1];
                        var v2 = vertices[i];
                        // If the code crashes here, it means your vertices are too close together.
                        _ASSERT && common1.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);
                    }
                    this.m_vertices.length = 0;
                    this.m_count = vertices.length + 1;
                    for(var i = 0; i < vertices.length; ++i){
                        this.m_vertices[i] = vertices[i].clone();
                    }
                    this.m_vertices[vertices.length] = vertices[0].clone();
                    this.m_prevVertex = this.m_vertices[this.m_count - 2];
                    this.m_nextVertex = this.m_vertices[1];
                    this.m_hasPrevVertex = true;
                    this.m_hasNextVertex = true;
                    return this;
                };
                /**
 * Create a chain with isolated end vertices.
 * 
 * @param vertices an array of vertices, these are copied
 * @param count the vertex count
 */ ChainShape.prototype._createChain = function(vertices) {
                    _ASSERT && common1.assert(this.m_vertices.length == 0 && this.m_count == 0);
                    _ASSERT && common1.assert(vertices.length >= 2);
                    for(var i = 1; i < vertices.length; ++i){
                        // If the code crashes here, it means your vertices are too close together.
                        var v1 = vertices[i - 1];
                        var v2 = vertices[i];
                        _ASSERT && common1.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);
                    }
                    this.m_count = vertices.length;
                    for(var i = 0; i < vertices.length; ++i){
                        this.m_vertices[i] = vertices[i].clone();
                    }
                    this.m_hasPrevVertex = false;
                    this.m_hasNextVertex = false;
                    this.m_prevVertex = null;
                    this.m_nextVertex = null;
                    return this;
                };
                /**
 * Establish connectivity to a vertex that precedes the first vertex. Don't call
 * this for loops.
 */ ChainShape.prototype._setPrevVertex = function(prevVertex) {
                    this.m_prevVertex = prevVertex;
                    this.m_hasPrevVertex = true;
                };
                /**
 * Establish connectivity to a vertex that follows the last vertex. Don't call
 * this for loops.
 */ ChainShape.prototype._setNextVertex = function(nextVertex) {
                    this.m_nextVertex = nextVertex;
                    this.m_hasNextVertex = true;
                };
                /**
 * @deprecated
 */ ChainShape.prototype._clone = function() {
                    var clone = new ChainShape();
                    clone.createChain(this.m_vertices);
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_prevVertex = this.m_prevVertex;
                    clone.m_nextVertex = this.m_nextVertex;
                    clone.m_hasPrevVertex = this.m_hasPrevVertex;
                    clone.m_hasNextVertex = this.m_hasNextVertex;
                    return clone;
                };
                ChainShape.prototype.getChildCount = function() {
                    // edge count = vertex count - 1
                    return this.m_count - 1;
                };
                // Get a child edge.
                ChainShape.prototype.getChildEdge = function(edge, childIndex) {
                    _ASSERT && common1.assert(0 <= childIndex && childIndex < this.m_count - 1);
                    edge.m_type = EdgeShape.TYPE;
                    edge.m_radius = this.m_radius;
                    edge.m_vertex1 = this.m_vertices[childIndex];
                    edge.m_vertex2 = this.m_vertices[childIndex + 1];
                    if (childIndex > 0) {
                        edge.m_vertex0 = this.m_vertices[childIndex - 1];
                        edge.m_hasVertex0 = true;
                    } else {
                        edge.m_vertex0 = this.m_prevVertex;
                        edge.m_hasVertex0 = this.m_hasPrevVertex;
                    }
                    if (childIndex < this.m_count - 2) {
                        edge.m_vertex3 = this.m_vertices[childIndex + 2];
                        edge.m_hasVertex3 = true;
                    } else {
                        edge.m_vertex3 = this.m_nextVertex;
                        edge.m_hasVertex3 = this.m_hasNextVertex;
                    }
                };
                ChainShape.prototype.getVertex = function(index) {
                    _ASSERT && common1.assert(0 <= index && index <= this.m_count);
                    if (index < this.m_count) {
                        return this.m_vertices[index];
                    } else {
                        return this.m_vertices[0];
                    }
                };
                /**
 * This always return false.
 */ ChainShape.prototype.testPoint = function(xf, p) {
                    return false;
                };
                ChainShape.prototype.rayCast = function(output, input, xf, childIndex) {
                    _ASSERT && common1.assert(0 <= childIndex && childIndex < this.m_count);
                    var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));
                    return edgeShape.rayCast(output, input, xf, 0);
                };
                ChainShape.prototype.computeAABB = function(aabb, xf, childIndex) {
                    _ASSERT && common1.assert(0 <= childIndex && childIndex < this.m_count);
                    var v1 = Transform.mulVec2(xf, this.getVertex(childIndex));
                    var v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));
                    aabb.combinePoints(v1, v2);
                };
                /**
 * Chains have zero mass.
 */ ChainShape.prototype.computeMass = function(massData, density) {
                    massData.mass = 0;
                    massData.center = Vec2.neo();
                    massData.I = 0;
                };
                ChainShape.prototype.computeDistanceProxy = function(proxy, childIndex) {
                    _ASSERT && common1.assert(0 <= childIndex && childIndex < this.m_count);
                    proxy.m_buffer[0] = this.getVertex(childIndex);
                    proxy.m_buffer[1] = this.getVertex(childIndex + 1);
                    proxy.m_vertices = proxy.m_buffer;
                    proxy.m_count = 2;
                    proxy.m_radius = this.m_radius;
                };
            },
            {
                "../Settings": 7,
                "../Shape": 8,
                "../collision/AABB": 11,
                "../common/Math": 18,
                "../common/Rot": 20,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52,
                "./EdgeShape": 46
            }
        ],
        40: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = CircleShape;
                var common1 = require1("../util/common");
                var create = require1("../util/create");
                var options = require1("../util/options");
                var Math1 = require1("../common/Math");
                var Transform = require1("../common/Transform");
                var Rot = require1("../common/Rot");
                var Vec2 = require1("../common/Vec2");
                var AABB = require1("../collision/AABB");
                var Settings = require1("../Settings");
                var Shape = require1("../Shape");
                CircleShape._super = Shape;
                CircleShape.prototype = create(CircleShape._super.prototype);
                CircleShape.TYPE = "circle";
                function CircleShape(a, b) {
                    if (!(this instanceof CircleShape)) {
                        return new CircleShape(a, b);
                    }
                    CircleShape._super.call(this);
                    this.m_type = CircleShape.TYPE;
                    this.m_p = Vec2.zero();
                    this.m_radius = 1;
                    if (typeof a === "object" && Vec2.isValid(a)) {
                        this.m_p.set(a);
                        if (typeof b === "number") {
                            this.m_radius = b;
                        }
                    } else if (typeof a === "number") {
                        this.m_radius = a;
                    }
                }
                CircleShape.prototype.getRadius = function() {
                    return this.m_radius;
                };
                CircleShape.prototype.getCenter = function() {
                    return this.m_p;
                };
                CircleShape.prototype.getVertex = function(index) {
                    _ASSERT && common1.assert(index == 0);
                    return this.m_p;
                };
                CircleShape.prototype.getVertexCount = function(index) {
                    return 1;
                };
                /**
 * @deprecated
 */ CircleShape.prototype._clone = function() {
                    var clone = new CircleShape();
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_p = this.m_p.clone();
                    return clone;
                };
                CircleShape.prototype.getChildCount = function() {
                    return 1;
                };
                CircleShape.prototype.testPoint = function(xf, p) {
                    var center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
                    var d = Vec2.sub(p, center);
                    return Vec2.dot(d, d) <= this.m_radius * this.m_radius;
                };
                // Collision Detection in Interactive 3D Environments by Gino van den Bergen
                // From Section 3.1.2
                // x = s + a * r
                // norm(x) = radius
                CircleShape.prototype.rayCast = function(output, input, xf, childIndex) {
                    var position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
                    var s = Vec2.sub(input.p1, position);
                    var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;
                    // Solve quadratic equation.
                    var r = Vec2.sub(input.p2, input.p1);
                    var c = Vec2.dot(s, r);
                    var rr = Vec2.dot(r, r);
                    var sigma = c * c - rr * b;
                    // Check for negative discriminant and short segment.
                    if (sigma < 0 || rr < Math1.EPSILON) {
                        return false;
                    }
                    // Find the point of intersection of the line with the circle.
                    var a = -(c + Math1.sqrt(sigma));
                    // Is the intersection point on the segment?
                    if (0 <= a && a <= input.maxFraction * rr) {
                        a /= rr;
                        output.fraction = a;
                        output.normal = Vec2.add(s, Vec2.mul(a, r));
                        output.normal.normalize();
                        return true;
                    }
                    return false;
                };
                CircleShape.prototype.computeAABB = function(aabb, xf, childIndex) {
                    var p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
                    aabb.lowerBound.set(p.x - this.m_radius, p.y - this.m_radius);
                    aabb.upperBound.set(p.x + this.m_radius, p.y + this.m_radius);
                };
                CircleShape.prototype.computeMass = function(massData, density) {
                    massData.mass = density * Math1.PI * this.m_radius * this.m_radius;
                    massData.center = this.m_p;
                    // inertia about the local origin
                    massData.I = massData.mass * (.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));
                };
                CircleShape.prototype.computeDistanceProxy = function(proxy) {
                    proxy.m_vertices.push(this.m_p);
                    proxy.m_count = 1;
                    proxy.m_radius = this.m_radius;
                };
            },
            {
                "../Settings": 7,
                "../Shape": 8,
                "../collision/AABB": 11,
                "../common/Math": 18,
                "../common/Rot": 20,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        41: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("../util/common");
                var Transform = require1("../common/Transform");
                var Vec2 = require1("../common/Vec2");
                var Contact = require1("../Contact");
                var Manifold = require1("../Manifold");
                var CircleShape = require1("./CircleShape");
                Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);
                function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    _ASSERT && common1.assert(fixtureA.getType() == CircleShape.TYPE);
                    _ASSERT && common1.assert(fixtureB.getType() == CircleShape.TYPE);
                    CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
                }
                var cc_pA = Vec2.zero();
                var cc_pB = Vec2.zero();
                function CollideCircles(manifold, circleA, xfA, circleB, xfB) {
                    manifold.pointCount = 0;
                    var pA = Transform.mulVec2_(xfA, circleA.m_p, cc_pA);
                    var pB = Transform.mulVec2_(xfB, circleB.m_p, cc_pB);
                    var distSqr = Vec2.distanceSquared(pB, pA);
                    var rA = circleA.m_radius;
                    var rB = circleB.m_radius;
                    var radius = rA + rB;
                    if (distSqr > radius * radius) {
                        return;
                    }
                    manifold.type = Manifold.e_circles;
                    manifold.localPoint.set(circleA.m_p);
                    manifold.localNormal.setZero();
                    manifold.pointCount = 1;
                    manifold.points[0].localPoint.set(circleB.m_p);
                    // manifold.points[0].id.key = 0;
                    manifold.points[0].id.cf.indexA = 0;
                    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                    manifold.points[0].id.cf.indexB = 0;
                    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                }
                exports1.CollideCircles = CollideCircles;
            },
            {
                "../Contact": 3,
                "../Manifold": 6,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "./CircleShape": 40
            }
        ],
        42: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("../util/common");
                var Math1 = require1("../common/Math");
                var Transform = require1("../common/Transform");
                var Vec2 = require1("../common/Vec2");
                var Manifold = require1("../Manifold");
                var Contact = require1("../Contact");
                var CircleShape = require1("./CircleShape");
                var PolygonShape = require1("./PolygonShape");
                Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);
                function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    _ASSERT && common1.assert(fixtureA.getType() === PolygonShape.TYPE);
                    _ASSERT && common1.assert(fixtureB.getType() === CircleShape.TYPE);
                    CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
                }
                var cpc_c = Vec2.zero();
                var cpc_cLocal = Vec2.zero();
                var cpc_t1 = Vec2.zero();
                var cpc_t2 = Vec2.zero();
                function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {
                    manifold.pointCount = 0;
                    // Compute circle position in the frame of the polygon.
                    var c = Transform.mulVec2_(xfB, circleB.m_p, cpc_c);
                    var cLocal = Transform.mulTVec2_(xfA, c, cpc_cLocal);
                    // Find the min separating edge.
                    var normalIndex = 0;
                    var separation = -Infinity;
                    var radius = polygonA.m_radius + circleB.m_radius;
                    var vertexCount = polygonA.m_count;
                    var vertices = polygonA.m_vertices;
                    var normals = polygonA.m_normals;
                    for(var i = 0; i < vertexCount; ++i){
                        var s = Vec2.dot(normals[i], Vec2.sub_(cLocal, vertices[i], cpc_t1));
                        if (s > radius) {
                            // Early out.
                            return;
                        }
                        if (s > separation) {
                            separation = s;
                            normalIndex = i;
                        }
                    }
                    // Vertices that subtend the incident face.
                    var vertIndex1 = normalIndex;
                    var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
                    var v1 = vertices[vertIndex1];
                    var v2 = vertices[vertIndex2];
                    // If the center is inside the polygon ...
                    if (separation < Math1.EPSILON) {
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.set(normals[normalIndex]);
                        manifold.localPoint.setCombine(.5, v1, .5, v2);
                        manifold.points[0].localPoint.set(circleB.m_p);
                        // manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 0;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                        return;
                    }
                    // Compute barycentric coordinates
                    var u1 = Vec2.dot(Vec2.sub_(cLocal, v1, cpc_t1), Vec2.sub_(v2, v1, cpc_t2));
                    var u2 = Vec2.dot(Vec2.sub_(cLocal, v2, cpc_t1), Vec2.sub_(v1, v2, cpc_t2));
                    if (u1 <= 0) {
                        if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.setCombine(1, cLocal, -1, v1);
                        manifold.localNormal.normalize();
                        manifold.localPoint.set(v1);
                        manifold.points[0].localPoint.set(circleB.m_p);
                        // manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 0;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                    } else if (u2 <= 0) {
                        if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.setCombine(1, cLocal, -1, v2);
                        manifold.localNormal.normalize();
                        manifold.localPoint.set(v2);
                        manifold.points[0].localPoint.set(circleB.m_p);
                        // manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 0;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                    } else {
                        var faceCenter = Vec2.mid(v1, v2);
                        var separation = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);
                        if (separation > radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.set(normals[vertIndex1]);
                        manifold.localPoint.set(faceCenter);
                        manifold.points[0].localPoint.set(circleB.m_p);
                        // manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 0;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                    }
                }
            },
            {
                "../Contact": 3,
                "../Manifold": 6,
                "../common/Math": 18,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "./CircleShape": 40,
                "./PolygonShape": 47
            }
        ],
        43: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("../util/common");
                var Transform = require1("../common/Transform");
                var Vec2 = require1("../common/Vec2");
                var Contact = require1("../Contact");
                var Manifold = require1("../Manifold");
                var EdgeShape = require1("./EdgeShape");
                var ChainShape = require1("./ChainShape");
                var CircleShape = require1("./CircleShape");
                Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);
                Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);
                function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    _ASSERT && common1.assert(fixtureA.getType() == EdgeShape.TYPE);
                    _ASSERT && common1.assert(fixtureB.getType() == CircleShape.TYPE);
                    var shapeA = fixtureA.getShape();
                    var shapeB = fixtureB.getShape();
                    CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
                }
                var ccc_edge = new EdgeShape();
                function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    _ASSERT && common1.assert(fixtureA.getType() === ChainShape.TYPE);
                    _ASSERT && common1.assert(fixtureB.getType() === CircleShape.TYPE);
                    var chain = fixtureA.getShape();
                    var edge = ccc_edge;
                    chain.getChildEdge(ccc_edge, indexA);
                    var shapeA = ccc_edge;
                    var shapeB = fixtureB.getShape();
                    CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
                }
                var cec_e = Vec2.zero();
                var cec_Q = Vec2.zero();
                var cec_P = Vec2.zero();
                var cec_d = Vec2.zero();
                var cec_n = Vec2.zero();
                var cec_e1 = Vec2.zero();
                var cec_e2 = Vec2.zero();
                var cec_t1 = Vec2.zero();
                // Compute contact points for edge versus circle.
                // This accounts for edge connectivity.
                function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {
                    manifold.pointCount = 0;
                    // Compute circle in frame of edge
                    var Q = Transform.mulTVec2_(xfA, Transform.mulVec2_(xfB, circleB.m_p, cec_t1), cec_Q);
                    var A = edgeA.m_vertex1;
                    var B = edgeA.m_vertex2;
                    var e = Vec2.sub_(B, A, cec_e);
                    // Barycentric coordinates
                    var u = Vec2.dot(e, Vec2.sub_(B, Q, cec_t1));
                    var v = Vec2.dot(e, Vec2.sub_(Q, A, cec_t1));
                    var radius = edgeA.m_radius + circleB.m_radius;
                    // Region A
                    if (v <= 0) {
                        var P = cec_P.setVec2(A);
                        var d = Vec2.sub(Q, P, cec_d);
                        var dd = Vec2.dot(d, d);
                        if (dd > radius * radius) {
                            return;
                        }
                        // Is there an edge connected to A?
                        if (edgeA.m_hasVertex0) {
                            var A1 = edgeA.m_vertex0;
                            var B1 = A;
                            var e1 = Vec2.sub_(B1, A1, cec_e1);
                            var u1 = Vec2.dot(e1, Vec2.sub(B1, Q, cec_t1));
                            // Is the circle in Region AB of the previous edge?
                            if (u1 > 0) {
                                return;
                            }
                        }
                        manifold.type = Manifold.e_circles;
                        manifold.localNormal.setZero();
                        manifold.localPoint.set(P);
                        manifold.pointCount = 1;
                        manifold.points[0].localPoint.set(circleB.m_p);
                        // manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 0;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                        return;
                    }
                    // Region B
                    if (u <= 0) {
                        var P = cec_P.setVec2(B);
                        var d = Vec2.sub_(Q, P, cec_d);
                        var dd = Vec2.dot(d, d);
                        if (dd > radius * radius) {
                            return;
                        }
                        // Is there an edge connected to B?
                        if (edgeA.m_hasVertex3) {
                            var B2 = edgeA.m_vertex3;
                            var A2 = B;
                            var e2 = Vec2.sub_(B2, A2, cec_e2);
                            var v2 = Vec2.dot(e2, Vec2.sub_(Q, A2, cec_t1));
                            // Is the circle in Region AB of the next edge?
                            if (v2 > 0) {
                                return;
                            }
                        }
                        manifold.type = Manifold.e_circles;
                        manifold.localNormal.setZero();
                        manifold.localPoint.set(P);
                        manifold.pointCount = 1;
                        manifold.points[0].localPoint.set(circleB.m_p);
                        // manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 1;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                        return;
                    }
                    // Region AB
                    var den = Vec2.dot(e, e);
                    _ASSERT && common1.assert(den > 0);
                    var P = cec_P.setCombine(u / den, A, v / den, B);
                    var d = Vec2.sub_(Q, P, cec_d);
                    var dd = Vec2.dot(d, d);
                    if (dd > radius * radius) {
                        return;
                    }
                    var n = cec_n.setXY(-e.y, e.x);
                    if (Vec2.dot(n, Vec2.sub_(Q, A, cec_t1)) < 0) {
                        n.set(-n.x, -n.y);
                    }
                    n.normalize();
                    manifold.type = Manifold.e_faceA;
                    manifold.localNormal.set(n);
                    manifold.localPoint.set(A);
                    manifold.pointCount = 1;
                    manifold.points[0].localPoint.set(circleB.m_p);
                    // manifold.points[0].id.key = 0;
                    manifold.points[0].id.cf.indexA = 0;
                    manifold.points[0].id.cf.typeA = Manifold.e_face;
                    manifold.points[0].id.cf.indexB = 0;
                    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                }
            },
            {
                "../Contact": 3,
                "../Manifold": 6,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "./ChainShape": 39,
                "./CircleShape": 40,
                "./EdgeShape": 46
            }
        ],
        44: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("../util/common");
                var Math1 = require1("../common/Math");
                var Transform = require1("../common/Transform");
                var Vec2 = require1("../common/Vec2");
                var Rot = require1("../common/Rot");
                var Settings = require1("../Settings");
                var Contact = require1("../Contact");
                var Manifold = require1("../Manifold");
                var EdgeShape = require1("./EdgeShape");
                var ChainShape = require1("./ChainShape");
                var PolygonShape = require1("./PolygonShape");
                Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);
                Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);
                function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
                    _ASSERT && common1.assert(fA.getType() === EdgeShape.TYPE);
                    _ASSERT && common1.assert(fB.getType() === PolygonShape.TYPE);
                    CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);
                }
                var cpc_edge = new EdgeShape();
                function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
                    _ASSERT && common1.assert(fA.getType() === ChainShape.TYPE);
                    _ASSERT && common1.assert(fB.getType() === PolygonShape.TYPE);
                    var chain = fA.getShape();
                    var edge = cpc_edge;
                    chain.getChildEdge(edge, indexA);
                    CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);
                }
                // EPAxis Type
                var e_unknown = -1;
                var e_edgeA = 1;
                var e_edgeB = 2;
                // VertexType unused?
                var e_isolated = 0;
                var e_concave = 1;
                var e_convex = 2;
                // This structure is used to keep track of the best separating axis.
                function EPAxis() {
                    this.type;
                    // Type
                    this.index;
                    this.separation;
                }
                // This holds polygon B expressed in frame A.
                function TempPolygon() {
                    this.vertices = [];
                    // Vec2[Settings.maxPolygonVertices]
                    this.normals = [];
                    // Vec2[Settings.maxPolygonVertices];
                    this.count = 0;
                    for(var i = 0; i < Settings.maxPolygonVertices; i++){
                        this.vertices.push(Vec2.zero());
                        this.normals.push(Vec2.zero());
                    }
                }
                // Reference face used for clipping
                function ReferenceFace() {
                    this.i1 = -1;
                    this.i2 = -1;
                    this.v1 = Vec2.zero();
                    this.v2 = Vec2.zero();
                    this.normal = Vec2.zero();
                    this.sideNormal1 = Vec2.zero();
                    this.sideOffset1 = 0;
                    this.sideNormal2 = Vec2.zero();
                    this.sideOffset2 = 0;
                }
                // reused
                var edgeAxis = new EPAxis();
                var polygonAxis = new EPAxis();
                var polygonBA = new TempPolygon();
                var rf = new ReferenceFace();
                var cep_t1 = Vec2.zero();
                var cep_t2 = Vec2.zero();
                var cep_n = Vec2.zero();
                var cep_perp = Vec2.zero();
                var cep_centroidB = Vec2.zero();
                var cep_edge1 = Vec2.zero();
                var cep_normal1 = Vec2.zero();
                var cep_edge0 = Vec2.zero();
                var cep_normal0 = Vec2.zero();
                var cep_edge2 = Vec2.zero();
                var cep_normal2 = Vec2.zero();
                var cep_normal = Vec2.zero();
                var cep_lowerLimit = Vec2.zero();
                var cep_upperLimit = Vec2.zero();
                var cep_xf = Transform.identity();
                var cep_clipPoints1 = [
                    new Manifold.clipVertex(),
                    new Manifold.clipVertex()
                ];
                var cep_clipPoints2 = [
                    new Manifold.clipVertex(),
                    new Manifold.clipVertex()
                ];
                var cep_ie = [
                    new Manifold.clipVertex(),
                    new Manifold.clipVertex()
                ];
                /**
 * This function collides and edge and a polygon, taking into account edge
 * adjacency.
 */ function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {
                    // Algorithm:
                    // 1. Classify v1 and v2
                    // 2. Classify polygon centroid as front or back
                    // 3. Flip normal if necessary
                    // 4. Initialize normal range to [-pi, pi] about face normal
                    // 5. Adjust normal range according to adjacent edges
                    // 6. Visit each separating axes, only accept axes within the range
                    // 7. Return if _any_ axis indicates separation
                    // 8. Clip
                    var m_type1, m_type2;
                    // VertexType unused?
                    var xf = Transform.mulTXf_(xfA, xfB, cep_xf);
                    var centroidB = Transform.mulVec2_(xf, polygonB.m_centroid, cep_centroidB);
                    var v0 = edgeA.m_vertex0;
                    var v1 = edgeA.m_vertex1;
                    var v2 = edgeA.m_vertex2;
                    var v3 = edgeA.m_vertex3;
                    var hasVertex0 = edgeA.m_hasVertex0;
                    var hasVertex3 = edgeA.m_hasVertex3;
                    var edge1 = Vec2.sub_(v2, v1, cep_edge1);
                    edge1.normalize();
                    var normal1 = cep_normal1.setXY(edge1.y, -edge1.x);
                    var offset1 = Vec2.dot(normal1, Vec2.sub_(centroidB, v1, cep_t1));
                    var offset0 = 0;
                    var offset2 = 0;
                    var convex1 = false;
                    var convex2 = false;
                    // Is there a preceding edge?
                    if (hasVertex0) {
                        var edge0 = Vec2.sub_(v1, v0, cep_edge0);
                        edge0.normalize();
                        var normal0 = cep_normal0.setXY(edge0.y, -edge0.x);
                        convex1 = Vec2.cross(edge0, edge1) >= 0;
                        offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);
                    }
                    // Is there a following edge?
                    if (hasVertex3) {
                        var edge2 = Vec2.sub_(v3, v2, cep_edge2);
                        edge2.normalize();
                        var normal2 = cep_normal2.set(edge2.y, -edge2.x);
                        convex2 = Vec2.cross(edge1, edge2) > 0;
                        offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);
                    }
                    var front = 0;
                    var normal = cep_normal.setZero();
                    var lowerLimit = cep_lowerLimit.setZero();
                    var upperLimit = cep_upperLimit.setZero();
                    // Determine front or back collision. Determine collision normal limits.
                    if (hasVertex0 && hasVertex3) {
                        if (convex1 && convex2) {
                            front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal0);
                                upperLimit.set(normal2);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.setMul(-1, normal1);
                                upperLimit.setMul(-1, normal1);
                            }
                        } else if (convex1) {
                            front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal0);
                                upperLimit.set(normal1);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.setMul(-1, normal2);
                                upperLimit.setMul(-1, normal1);
                            }
                        } else if (convex2) {
                            front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal1);
                                upperLimit.set(normal2);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.setMul(-1, normal1);
                                upperLimit.setMul(-1, normal0);
                            }
                        } else {
                            front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal1);
                                upperLimit.set(normal1);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.setMul(-1, normal2);
                                upperLimit.setMul(-1, normal0);
                            }
                        }
                    } else if (hasVertex0) {
                        if (convex1) {
                            front = offset0 >= 0 || offset1 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal0);
                                upperLimit.setMul(-1, normal1);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.set(normal1);
                                upperLimit.setMul(-1, normal1);
                            }
                        } else {
                            front = offset0 >= 0 && offset1 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal1);
                                upperLimit.setMul(-1, normal1);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.set(normal1);
                                upperLimit.setMul(-1, normal0);
                            }
                        }
                    } else if (hasVertex3) {
                        if (convex2) {
                            front = offset1 >= 0 || offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.setMul(-1, normal1);
                                upperLimit.set(normal2);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.setMul(-1, normal1);
                                upperLimit.set(normal1);
                            }
                        } else {
                            front = offset1 >= 0 && offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.setMul(-1, normal1);
                                upperLimit.set(normal1);
                            } else {
                                normal.setMul(-1, normal1);
                                lowerLimit.setMul(-1, normal2);
                                upperLimit.set(normal1);
                            }
                        }
                    } else {
                        front = offset1 >= 0;
                        if (front) {
                            normal.set(normal1);
                            lowerLimit.setMul(-1, normal1);
                            upperLimit.setMul(-1, normal1);
                        } else {
                            normal.setMul(-1, normal1);
                            lowerLimit.set(normal1);
                            upperLimit.set(normal1);
                        }
                    }
                    // Get polygonB in frameA
                    polygonBA.count = polygonB.m_count;
                    for(var i = 0; i < polygonB.m_count; ++i){
                        polygonBA.vertices[i] = Transform.mulVec2_(xf, polygonB.m_vertices[i], polygonBA.vertices[i]);
                        polygonBA.normals[i] = Rot.mulVec2_(xf.q, polygonB.m_normals[i], polygonBA.normals[i]);
                    }
                    var radius = 2 * Settings.polygonRadius;
                    manifold.pointCount = 0;
                    {
                        // ComputeEdgeSeparation
                        edgeAxis.type = e_edgeA;
                        edgeAxis.index = front ? 0 : 1;
                        edgeAxis.separation = Infinity;
                        for(var i = 0; i < polygonBA.count; ++i){
                            var s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1, cep_t1));
                            if (s < edgeAxis.separation) {
                                edgeAxis.separation = s;
                            }
                        }
                    }
                    // If no valid normal can be found than this edge should not collide.
                    if (edgeAxis.type === e_unknown) {
                        return;
                    }
                    if (edgeAxis.separation > radius) {
                        return;
                    }
                    {
                        // ComputePolygonSeparation
                        polygonAxis.type = e_unknown;
                        polygonAxis.index = -1;
                        polygonAxis.separation = -Infinity;
                        var perp = cep_perp.set(-normal.y, normal.x);
                        for(var i = 0; i < polygonBA.count; ++i){
                            var n = cep_n.set(polygonBA.normals[i]).neg();
                            var s1 = Vec2.dot(n, Vec2.sub_(polygonBA.vertices[i], v1, cep_t1));
                            var s2 = Vec2.dot(n, Vec2.sub_(polygonBA.vertices[i], v2, cep_t1));
                            var s = Math1.min(s1, s2);
                            if (s > radius) {
                                // No collision
                                polygonAxis.type = e_edgeB;
                                polygonAxis.index = i;
                                polygonAxis.separation = s;
                                break;
                            }
                            // Adjacency
                            if (Vec2.dot(n, perp) >= 0) {
                                if (Vec2.dot(Vec2.sub_(n, upperLimit, cep_t1), normal) < -Settings.angularSlop) {
                                    continue;
                                }
                            } else {
                                if (Vec2.dot(Vec2.sub_(n, lowerLimit, cep_t1), normal) < -Settings.angularSlop) {
                                    continue;
                                }
                            }
                            if (s > polygonAxis.separation) {
                                polygonAxis.type = e_edgeB;
                                polygonAxis.index = i;
                                polygonAxis.separation = s;
                            }
                        }
                    }
                    if (polygonAxis.type !== e_unknown && polygonAxis.separation > radius) {
                        return;
                    }
                    // Use hysteresis for jitter reduction.
                    var k_relativeTol = .98;
                    var k_absoluteTol = .001;
                    var primaryAxis;
                    if (polygonAxis.type === e_unknown) {
                        primaryAxis = edgeAxis;
                    } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
                        primaryAxis = polygonAxis;
                    } else {
                        primaryAxis = edgeAxis;
                    }
                    cep_ie[0].init();
                    cep_ie[1].init();
                    var ie = cep_ie;
                    if (primaryAxis.type === e_edgeA) {
                        manifold.type = Manifold.e_faceA;
                        // Search for the polygon normal that is most anti-parallel to the edge
                        // normal.
                        var bestIndex = 0;
                        var bestValue = Vec2.dot(normal, polygonBA.normals[0]);
                        for(var i = 1; i < polygonBA.count; ++i){
                            var value = Vec2.dot(normal, polygonBA.normals[i]);
                            if (value < bestValue) {
                                bestValue = value;
                                bestIndex = i;
                            }
                        }
                        var i1 = bestIndex;
                        var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;
                        ie[0].v.set(polygonBA.vertices[i1]);
                        ie[0].id.cf.indexA = 0;
                        ie[0].id.cf.indexB = i1;
                        ie[0].id.cf.typeA = Manifold.e_face;
                        ie[0].id.cf.typeB = Manifold.e_vertex;
                        ie[1].v.set(polygonBA.vertices[i2]);
                        ie[1].id.cf.indexA = 0;
                        ie[1].id.cf.indexB = i2;
                        ie[1].id.cf.typeA = Manifold.e_face;
                        ie[1].id.cf.typeB = Manifold.e_vertex;
                        if (front) {
                            rf.i1 = 0;
                            rf.i2 = 1;
                            rf.v1.set(v1);
                            rf.v2.set(v2);
                            rf.normal.set(normal1);
                        } else {
                            rf.i1 = 1;
                            rf.i2 = 0;
                            rf.v1.set(v2);
                            rf.v2.set(v1);
                            rf.normal.set(normal1).neg();
                        }
                    } else {
                        manifold.type = Manifold.e_faceB;
                        ie[0].v.set(v1);
                        ie[0].id.cf.indexA = 0;
                        ie[0].id.cf.indexB = primaryAxis.index;
                        ie[0].id.cf.typeA = Manifold.e_vertex;
                        ie[0].id.cf.typeB = Manifold.e_face;
                        ie[1].v.set(v2);
                        ie[1].id.cf.indexA = 0;
                        ie[1].id.cf.indexB = primaryAxis.index;
                        ie[1].id.cf.typeA = Manifold.e_vertex;
                        ie[1].id.cf.typeB = Manifold.e_face;
                        rf.i1 = primaryAxis.index;
                        rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;
                        rf.v1.set(polygonBA.vertices[rf.i1]);
                        rf.v2.set(polygonBA.vertices[rf.i2]);
                        rf.normal.set(polygonBA.normals[rf.i1]);
                    }
                    rf.sideNormal1.set(rf.normal.y, -rf.normal.x);
                    rf.sideNormal2.setMul(-1, rf.sideNormal1);
                    rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);
                    rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);
                    // Clip incident edge against extruded edge1 side edges.
                    cep_clipPoints1[0].init();
                    cep_clipPoints1[1].init();
                    cep_clipPoints2[0].init();
                    cep_clipPoints2[1].init();
                    var clipPoints1 = cep_clipPoints1;
                    var clipPoints2 = cep_clipPoints2;
                    var np;
                    // Clip to box side 1
                    np = Manifold.clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
                    if (np < Settings.maxManifoldPoints) {
                        return;
                    }
                    // Clip to negative box side 1
                    np = Manifold.clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
                    if (np < Settings.maxManifoldPoints) {
                        return;
                    }
                    // Now clipPoints2 contains the clipped points.
                    if (primaryAxis.type === e_edgeA) {
                        manifold.localNormal.set(rf.normal);
                        manifold.localPoint.set(rf.v1);
                    } else {
                        manifold.localNormal.set(polygonB.m_normals[rf.i1]);
                        manifold.localPoint.set(polygonB.m_vertices[rf.i1]);
                    }
                    var pointCount = 0;
                    for(var i = 0; i < Settings.maxManifoldPoints; ++i){
                        var separation = Vec2.dot(rf.normal, Vec2.sub_(clipPoints2[i].v, rf.v1, cep_t1));
                        if (separation <= radius) {
                            var cp = manifold.points[pointCount];
                            // ManifoldPoint
                            if (primaryAxis.type === e_edgeA) {
                                cp.localPoint = Transform.mulTVec2_(xf, clipPoints2[i].v, cp.localPoint);
                                cp.id.set(clipPoints2[i].id);
                            } else {
                                cp.localPoint.set(clipPoints2[i].v);
                                cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
                                cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
                                cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
                                cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
                            }
                            ++pointCount;
                        }
                    }
                    manifold.pointCount = pointCount;
                }
            },
            {
                "../Contact": 3,
                "../Manifold": 6,
                "../Settings": 7,
                "../common/Math": 18,
                "../common/Rot": 20,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "./ChainShape": 39,
                "./EdgeShape": 46,
                "./PolygonShape": 47
            }
        ],
        45: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var common1 = require1("../util/common");
                var Transform = require1("../common/Transform");
                var Rot = require1("../common/Rot");
                var Vec2 = require1("../common/Vec2");
                var Settings = require1("../Settings");
                var Manifold = require1("../Manifold");
                var Contact = require1("../Contact");
                var PolygonShape = require1("./PolygonShape");
                module1.exports = CollidePolygons;
                Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);
                function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    _ASSERT && common1.assert(fixtureA.getType() == PolygonShape.TYPE);
                    _ASSERT && common1.assert(fixtureB.getType() == PolygonShape.TYPE);
                    CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
                }
                var fms_v1 = Vec2.zero();
                var fms_n = Vec2.zero();
                var fms_xf = Transform.identity();
                var fms_maxSeparation;
                var fms_bestIndex;
                /**
 * Find the max separation between poly1 and poly2 using edge normals from
 * poly1.
 */ function FindMaxSeparation(poly1, xf1, poly2, xf2) {
                    var count1 = poly1.m_count;
                    var count2 = poly2.m_count;
                    var n1s = poly1.m_normals;
                    var v1s = poly1.m_vertices;
                    var v2s = poly2.m_vertices;
                    var xf = Transform.mulTXf_(xf2, xf1, fms_xf);
                    var bestIndex = 0;
                    var maxSeparation = -Infinity;
                    for(var i = 0; i < count1; ++i){
                        // Get poly1 normal in frame2.
                        var n = Rot.mulVec2_(xf.q, n1s[i], fms_n);
                        var v1 = Transform.mulVec2_(xf, v1s[i], fms_v1);
                        // Find deepest point for normal i.
                        var si = Infinity;
                        for(var j = 0; j < count2; ++j){
                            var sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);
                            if (sij < si) {
                                si = sij;
                            }
                        }
                        if (si > maxSeparation) {
                            maxSeparation = si;
                            bestIndex = i;
                        }
                    }
                    // used to keep last FindMaxSeparation call values
                    fms_maxSeparation = maxSeparation;
                    fms_bestIndex = bestIndex;
                }
                var fie_t1 = Vec2.zero();
                var fie_normal1 = Vec2.zero();
                /**
 * @param {ClipVertex[2]} c
 * @param {int} edge1
 */ function FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
                    var normals1 = poly1.m_normals;
                    var count2 = poly2.m_count;
                    var vertices2 = poly2.m_vertices;
                    var normals2 = poly2.m_normals;
                    _ASSERT && common1.assert(0 <= edge1 && edge1 < poly1.m_count);
                    // Get the normal of the reference edge in poly2's frame.
                    var normal1 = Rot.mulTVec2_(xf2.q, Rot.mulVec2_(xf1.q, normals1[edge1], fie_t1), fie_normal1);
                    // Find the incident edge on poly2.
                    var index = 0;
                    var minDot = Infinity;
                    for(var i = 0; i < count2; ++i){
                        var dot = Vec2.dot(normal1, normals2[i]);
                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }
                    // Build the clip vertices for the incident edge.
                    var i1 = index;
                    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
                    c[0].v = Transform.mulVec2(xf2, vertices2[i1]);
                    c[0].id.cf.indexA = edge1;
                    c[0].id.cf.indexB = i1;
                    c[0].id.cf.typeA = Manifold.e_face;
                    c[0].id.cf.typeB = Manifold.e_vertex;
                    c[1].v = Transform.mulVec2(xf2, vertices2[i2]);
                    c[1].id.cf.indexA = edge1;
                    c[1].id.cf.indexB = i2;
                    c[1].id.cf.typeA = Manifold.e_face;
                    c[1].id.cf.typeB = Manifold.e_vertex;
                }
                var cpg_planePoint = Vec2.zero();
                var cpg_tangent = Vec2.zero();
                var cpg_normal = Vec2.zero();
                var cpg_localTangent = Vec2.zero();
                var cpg_localNormal = Vec2.zero();
                var cpg_v11 = Vec2.zero();
                var cpg_v12 = Vec2.zero();
                var cpg_t1 = Vec2.zero();
                var cpg_clipPoints1 = [
                    new Manifold.clipVertex(),
                    new Manifold.clipVertex()
                ];
                var cpg_clipPoints2 = [
                    new Manifold.clipVertex(),
                    new Manifold.clipVertex()
                ];
                var cpg_incidentEdge = [
                    new Manifold.clipVertex(),
                    new Manifold.clipVertex()
                ];
                /**
 * 
 * Find edge normal of max separation on A - return if separating axis is found<br>
 * Find edge normal of max separation on B - return if separation axis is found<br>
 * Choose reference edge as min(minA, minB)<br>
 * Find incident edge<br>
 * Clip
 * 
 * The normal points from 1 to 2
 */ function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
                    manifold.pointCount = 0;
                    var totalRadius = polyA.m_radius + polyB.m_radius;
                    FindMaxSeparation(polyA, xfA, polyB, xfB);
                    var edgeA = fms_bestIndex;
                    var separationA = fms_maxSeparation;
                    if (separationA > totalRadius) return;
                    FindMaxSeparation(polyB, xfB, polyA, xfA);
                    var edgeB = fms_bestIndex;
                    var separationB = fms_maxSeparation;
                    if (separationB > totalRadius) return;
                    var poly1;
                    // reference polygon
                    var poly2;
                    // incident polygon
                    var xf1;
                    var xf2;
                    var edge1;
                    // reference edge
                    var flip;
                    var k_tol = .1 * Settings.linearSlop;
                    if (separationB > separationA + k_tol) {
                        poly1 = polyB;
                        poly2 = polyA;
                        xf1 = xfB;
                        xf2 = xfA;
                        edge1 = edgeB;
                        manifold.type = Manifold.e_faceB;
                        flip = 1;
                    } else {
                        poly1 = polyA;
                        poly2 = polyB;
                        xf1 = xfA;
                        xf2 = xfB;
                        edge1 = edgeA;
                        manifold.type = Manifold.e_faceA;
                        flip = 0;
                    }
                    var incidentEdge = cpg_incidentEdge;
                    cpg_incidentEdge[0].init();
                    cpg_incidentEdge[1].init();
                    FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
                    var count1 = poly1.m_count;
                    var vertices1 = poly1.m_vertices;
                    var iv1 = edge1;
                    var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
                    var v11 = cpg_v11.set(vertices1[iv1]);
                    var v12 = cpg_v12.set(vertices1[iv2]);
                    var localTangent = Vec2.sub_(v12, v11, cpg_localTangent);
                    localTangent.normalize();
                    var localNormal = Vec2.crossVec2Num_(localTangent, 1, cpg_localNormal);
                    var planePoint = Vec2.combine_(.5, v11, .5, v12, cpg_planePoint);
                    var tangent = Rot.mulVec2_(xf1.q, localTangent, cpg_tangent);
                    var normal = Vec2.crossVec2Num_(tangent, 1, cpg_normal);
                    v11 = Transform.mulVec2_(xf1, v11, v11);
                    v12 = Transform.mulVec2_(xf1, v12, v12);
                    // Face offset.
                    var frontOffset = Vec2.dot(normal, v11);
                    // Side offsets, extended by polytope skin thickness.
                    var sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;
                    var sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;
                    // Clip incident edge against extruded edge1 side edges.
                    cpg_clipPoints1[0].init();
                    cpg_clipPoints1[1].init();
                    cpg_clipPoints2[0].init();
                    cpg_clipPoints2[1].init();
                    var clipPoints1 = cpg_clipPoints1;
                    var clipPoints2 = cpg_clipPoints2;
                    var np;
                    // Clip to box side 1
                    np = Manifold.clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg_(tangent, cpg_t1), sideOffset1, iv1);
                    if (np < Settings.maxManifoldPoints) {
                        return;
                    }
                    // Clip to negative box side 1
                    np = Manifold.clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);
                    if (np < Settings.maxManifoldPoints) {
                        return;
                    }
                    // Now clipPoints2 contains the clipped points.
                    manifold.localNormal.set(localNormal);
                    manifold.localPoint.set(planePoint);
                    var pointCount = 0;
                    for(var i = 0; i < Settings.maxManifoldPoints; ++i){
                        var separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;
                        if (separation <= totalRadius) {
                            var cp = manifold.points[i];
                            // ManifoldPoint
                            cp.init();
                            cp.localPoint.set(Transform.mulTVec2(xf2, clipPoints2[i].v, cpg_t1));
                            cp.id.set(clipPoints2[i].id);
                            if (flip) {
                                // Swap features
                                var cf = cp.id.cf;
                                // ContactFeature
                                var indexA = cf.indexA;
                                var indexB = cf.indexB;
                                var typeA = cf.typeA;
                                var typeB = cf.typeB;
                                cf.indexA = indexB;
                                cf.indexB = indexA;
                                cf.typeA = typeB;
                                cf.typeB = typeA;
                            }
                            ++pointCount;
                        }
                    }
                    manifold.pointCount = pointCount;
                }
            },
            {
                "../Contact": 3,
                "../Manifold": 6,
                "../Settings": 7,
                "../common/Rot": 20,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "./PolygonShape": 47
            }
        ],
        46: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = EdgeShape;
                var create = require1("../util/create");
                var options = require1("../util/options");
                var Settings = require1("../Settings");
                var Shape = require1("../Shape");
                var Math1 = require1("../common/Math");
                var Transform = require1("../common/Transform");
                var Rot = require1("../common/Rot");
                var Vec2 = require1("../common/Vec2");
                var AABB = require1("../collision/AABB");
                EdgeShape._super = Shape;
                EdgeShape.prototype = create(EdgeShape._super.prototype);
                EdgeShape.TYPE = "edge";
                /**
 * A line segment (edge) shape. These can be connected in chains or loops to
 * other edge shapes. The connectivity information is used to ensure correct
 * contact normals.
 */ function EdgeShape(v1, v2) {
                    if (!(this instanceof EdgeShape)) {
                        return new EdgeShape(v1, v2);
                    }
                    EdgeShape._super.call(this);
                    this.m_type = EdgeShape.TYPE;
                    this.m_radius = Settings.polygonRadius;
                    // These are the edge vertices
                    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();
                    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();
                    // Optional adjacent vertices. These are used for smooth collision.
                    // Used by chain shape.
                    this.m_vertex0 = Vec2.zero();
                    this.m_vertex3 = Vec2.zero();
                    this.m_hasVertex0 = false;
                    this.m_hasVertex3 = false;
                }
                EdgeShape.prototype.setNext = function(v3) {
                    if (v3) {
                        this.m_vertex3.set(v3);
                        this.m_hasVertex3 = true;
                    } else {
                        this.m_vertex3.setZero();
                        this.m_hasVertex3 = false;
                    }
                    return this;
                };
                EdgeShape.prototype.setPrev = function(v0) {
                    if (v0) {
                        this.m_vertex0.set(v0);
                        this.m_hasVertex0 = true;
                    } else {
                        this.m_vertex0.setZero();
                        this.m_hasVertex0 = false;
                    }
                    return this;
                };
                /**
 * Set this as an isolated edge.
 */ EdgeShape.prototype._set = function(v1, v2) {
                    this.m_vertex1.set(v1);
                    this.m_vertex2.set(v2);
                    this.m_hasVertex0 = false;
                    this.m_hasVertex3 = false;
                    return this;
                };
                /**
 * @deprecated
 */ EdgeShape.prototype._clone = function() {
                    var clone = new EdgeShape();
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_vertex1.set(this.m_vertex1);
                    clone.m_vertex2.set(this.m_vertex2);
                    clone.m_vertex0.set(this.m_vertex0);
                    clone.m_vertex3.set(this.m_vertex3);
                    clone.m_hasVertex0 = this.m_hasVertex0;
                    clone.m_hasVertex3 = this.m_hasVertex3;
                    return clone;
                };
                EdgeShape.prototype.getChildCount = function() {
                    return 1;
                };
                EdgeShape.prototype.testPoint = function(xf, p) {
                    return false;
                };
                // p = p1 + t * d
                // v = v1 + s * e
                // p1 + t * d = v1 + s * e
                // s * e - t * d = p1 - v1
                EdgeShape.prototype.rayCast = function(output, input, xf, childIndex) {
                    // NOT_USED(childIndex);
                    // Put the ray into the edge's frame of reference.
                    var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));
                    var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));
                    var d = Vec2.sub(p2, p1);
                    var v1 = this.m_vertex1;
                    var v2 = this.m_vertex2;
                    var e = Vec2.sub(v2, v1);
                    var normal = Vec2.neo(e.y, -e.x);
                    normal.normalize();
                    // q = p1 + t * d
                    // dot(normal, q - v1) = 0
                    // dot(normal, p1 - v1) + t * dot(normal, d) = 0
                    var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));
                    var denominator = Vec2.dot(normal, d);
                    if (denominator == 0) {
                        return false;
                    }
                    var t = numerator / denominator;
                    if (t < 0 || input.maxFraction < t) {
                        return false;
                    }
                    var q = Vec2.add(p1, Vec2.mul(t, d));
                    // q = v1 + s * r
                    // s = dot(q - v1, r) / dot(r, r)
                    var r = Vec2.sub(v2, v1);
                    var rr = Vec2.dot(r, r);
                    if (rr == 0) {
                        return false;
                    }
                    var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;
                    if (s < 0 || 1 < s) {
                        return false;
                    }
                    output.fraction = t;
                    if (numerator > 0) {
                        output.normal = Rot.mulVec2(xf.q, normal).neg();
                    } else {
                        output.normal = Rot.mulVec2(xf.q, normal);
                    }
                    return true;
                };
                EdgeShape.prototype.computeAABB = function(aabb, xf, childIndex) {
                    var v1 = Transform.mulVec2(xf, this.m_vertex1);
                    var v2 = Transform.mulVec2(xf, this.m_vertex2);
                    aabb.combinePoints(v1, v2);
                    aabb.extend(this.m_radius);
                };
                EdgeShape.prototype.computeMass = function(massData, density) {
                    massData.mass = 0;
                    massData.center.setCombine(.5, this.m_vertex1, .5, this.m_vertex2);
                    massData.I = 0;
                };
                EdgeShape.prototype.computeDistanceProxy = function(proxy) {
                    proxy.m_vertices.push(this.m_vertex1);
                    proxy.m_vertices.push(this.m_vertex2);
                    proxy.m_count = 2;
                    proxy.m_radius = this.m_radius;
                };
            },
            {
                "../Settings": 7,
                "../Shape": 8,
                "../collision/AABB": 11,
                "../common/Math": 18,
                "../common/Rot": 20,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        47: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = PolygonShape;
                var common1 = require1("../util/common");
                var create = require1("../util/create");
                var options = require1("../util/options");
                var Math1 = require1("../common/Math");
                var Transform = require1("../common/Transform");
                var Rot = require1("../common/Rot");
                var Vec2 = require1("../common/Vec2");
                var AABB = require1("../collision/AABB");
                var Settings = require1("../Settings");
                var Shape = require1("../Shape");
                PolygonShape._super = Shape;
                PolygonShape.prototype = create(PolygonShape._super.prototype);
                PolygonShape.TYPE = "polygon";
                /**
 * A convex polygon. It is assumed that the interior of the polygon is to the
 * left of each edge. Polygons have a maximum number of vertices equal to
 * Settings.maxPolygonVertices. In most cases you should not need many vertices
 * for a convex polygon. extends Shape
 */ function PolygonShape(vertices) {
                    if (!(this instanceof PolygonShape)) {
                        return new PolygonShape(vertices);
                    }
                    PolygonShape._super.call(this);
                    this.m_type = PolygonShape.TYPE;
                    this.m_radius = Settings.polygonRadius;
                    this.m_centroid = Vec2.zero();
                    this.m_vertices = [];
                    // Vec2[Settings.maxPolygonVertices]
                    this.m_normals = [];
                    // Vec2[Settings.maxPolygonVertices]
                    this.m_count = 0;
                    if (vertices && vertices.length) {
                        this._set(vertices);
                    }
                }
                PolygonShape.prototype.getVertex = function(index) {
                    _ASSERT && common1.assert(0 <= index && index < this.m_count);
                    return this.m_vertices[index];
                };
                /**
 * @deprecated
 */ PolygonShape.prototype._clone = function() {
                    var clone = new PolygonShape();
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_count = this.m_count;
                    clone.m_centroid.set(this.m_centroid);
                    for(var i = 0; i < this.m_count; i++){
                        clone.m_vertices.push(this.m_vertices[i].clone());
                    }
                    for(var i = 0; i < this.m_normals.length; i++){
                        clone.m_normals.push(this.m_normals[i].clone());
                    }
                    return clone;
                };
                PolygonShape.prototype.getChildCount = function() {
                    return 1;
                };
                function ComputeCentroid(vs, count) {
                    _ASSERT && common1.assert(count >= 3);
                    var c = Vec2.zero();
                    var area = 0;
                    // pRef is the reference point for forming triangles.
                    // It's location doesn't change the result (except for rounding error).
                    var pRef = Vec2.zero();
                    if (false) {
                        // This code would put the reference point inside the polygon.
                        for(var i = 0; i < count; ++i){
                            pRef.add(vs[i]);
                        }
                        pRef.mul(1 / count);
                    }
                    var inv3 = 1 / 3;
                    for(var i = 0; i < count; ++i){
                        // Triangle vertices.
                        var p1 = pRef;
                        var p2 = vs[i];
                        var p3 = i + 1 < count ? vs[i + 1] : vs[0];
                        var e1 = Vec2.sub(p2, p1);
                        var e2 = Vec2.sub(p3, p1);
                        var D = Vec2.cross(e1, e2);
                        var triangleArea = .5 * D;
                        area += triangleArea;
                        // Area weighted centroid
                        c.addMul(triangleArea * inv3, p1);
                        c.addMul(triangleArea * inv3, p2);
                        c.addMul(triangleArea * inv3, p3);
                    }
                    // Centroid
                    _ASSERT && common1.assert(area > Math1.EPSILON);
                    c.mul(1 / area);
                    return c;
                }
                /**
 * @private
 *
 * Create a convex hull from the given array of local points. The count must be
 * in the range [3, Settings.maxPolygonVertices].
 * 
 * Warning: the points may be re-ordered, even if they form a convex polygon
 * Warning: collinear points are handled but not removed. Collinear points may
 * lead to poor stacking behavior.
 */ PolygonShape.prototype._set = function(vertices) {
                    _ASSERT && common1.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);
                    if (vertices.length < 3) {
                        this._setAsBox(1, 1);
                        return;
                    }
                    var n = Math1.min(vertices.length, Settings.maxPolygonVertices);
                    // Perform welding and copy vertices into local buffer.
                    var ps = [];
                    // [Settings.maxPolygonVertices];
                    var tempCount = 0;
                    for(var i = 0; i < n; ++i){
                        var v = vertices[i];
                        var unique = true;
                        for(var j = 0; j < tempCount; ++j){
                            if (Vec2.distanceSquared(v, ps[j]) < .25 * Settings.linearSlopSquared) {
                                unique = false;
                                break;
                            }
                        }
                        if (unique) {
                            ps[tempCount++] = v;
                        }
                    }
                    n = tempCount;
                    if (n < 3) {
                        // Polygon is degenerate.
                        _ASSERT && common1.assert(false);
                        this._setAsBox(1, 1);
                        return;
                    }
                    // Create the convex hull using the Gift wrapping algorithm
                    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
                    // Find the right most point on the hull
                    var i0 = 0;
                    var x0 = ps[0].x;
                    for(var i = 1; i < n; ++i){
                        var x = ps[i].x;
                        if (x > x0 || x == x0 && ps[i].y < ps[i0].y) {
                            i0 = i;
                            x0 = x;
                        }
                    }
                    var hull = [];
                    // [Settings.maxPolygonVertices];
                    var m = 0;
                    var ih = i0;
                    for(;;){
                        hull[m] = ih;
                        var ie = 0;
                        for(var j = 1; j < n; ++j){
                            if (ie == ih) {
                                ie = j;
                                continue;
                            }
                            var r = Vec2.sub(ps[ie], ps[hull[m]]);
                            var v = Vec2.sub(ps[j], ps[hull[m]]);
                            var c = Vec2.cross(r, v);
                            if (c < 0) {
                                ie = j;
                            }
                            // Collinearity check
                            if (c == 0 && v.lengthSquared() > r.lengthSquared()) {
                                ie = j;
                            }
                        }
                        ++m;
                        ih = ie;
                        if (ie == i0) {
                            break;
                        }
                    }
                    if (m < 3) {
                        // Polygon is degenerate.
                        _ASSERT && common1.assert(false);
                        this._setAsBox(1, 1);
                        return;
                    }
                    this.m_count = m;
                    // Copy vertices.
                    for(var i = 0; i < m; ++i){
                        this.m_vertices[i] = ps[hull[i]];
                    }
                    // Compute normals. Ensure the edges have non-zero length.
                    for(var i = 0; i < m; ++i){
                        var i1 = i;
                        var i2 = i + 1 < m ? i + 1 : 0;
                        var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);
                        _ASSERT && common1.assert(edge.lengthSquared() > Math1.EPSILON * Math1.EPSILON);
                        this.m_normals[i] = Vec2.cross(edge, 1);
                        this.m_normals[i].normalize();
                    }
                    // Compute the polygon centroid.
                    this.m_centroid = ComputeCentroid(this.m_vertices, m);
                };
                /**
 * @private
 */ PolygonShape.prototype._setAsBox = function(hx, hy, center, angle) {
                    this.m_vertices[0] = Vec2.neo(-hx, -hy);
                    this.m_vertices[1] = Vec2.neo(hx, -hy);
                    this.m_vertices[2] = Vec2.neo(hx, hy);
                    this.m_vertices[3] = Vec2.neo(-hx, hy);
                    this.m_normals[0] = Vec2.neo(0, -1);
                    this.m_normals[1] = Vec2.neo(1, 0);
                    this.m_normals[2] = Vec2.neo(0, 1);
                    this.m_normals[3] = Vec2.neo(-1, 0);
                    this.m_count = 4;
                    if (Vec2.isValid(center)) {
                        angle = angle || 0;
                        this.m_centroid.set(center);
                        var xf = Transform.identity();
                        xf.p.set(center);
                        xf.q.set(angle);
                        // Transform vertices and normals.
                        for(var i = 0; i < this.m_count; ++i){
                            this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);
                            this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);
                        }
                    }
                };
                PolygonShape.prototype.testPoint = function(xf, p) {
                    var pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));
                    for(var i = 0; i < this.m_count; ++i){
                        var dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));
                        if (dot > 0) {
                            return false;
                        }
                    }
                    return true;
                };
                PolygonShape.prototype.rayCast = function(output, input, xf, childIndex) {
                    // Put the ray into the polygon's frame of reference.
                    var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));
                    var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));
                    var d = Vec2.sub(p2, p1);
                    var lower = 0;
                    var upper = input.maxFraction;
                    var index = -1;
                    for(var i = 0; i < this.m_count; ++i){
                        // p = p1 + a * d
                        // dot(normal, p - v) = 0
                        // dot(normal, p1 - v) + a * dot(normal, d) = 0
                        var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));
                        var denominator = Vec2.dot(this.m_normals[i], d);
                        if (denominator == 0) {
                            if (numerator < 0) {
                                return false;
                            }
                        } else {
                            // Note: we want this predicate without division:
                            // lower < numerator / denominator, where denominator < 0
                            // Since denominator < 0, we have to flip the inequality:
                            // lower < numerator / denominator <==> denominator * lower > numerator.
                            if (denominator < 0 && numerator < lower * denominator) {
                                // Increase lower.
                                // The segment enters this half-space.
                                lower = numerator / denominator;
                                index = i;
                            } else if (denominator > 0 && numerator < upper * denominator) {
                                // Decrease upper.
                                // The segment exits this half-space.
                                upper = numerator / denominator;
                            }
                        }
                        // The use of epsilon here causes the assert on lower to trip
                        // in some cases. Apparently the use of epsilon was to make edge
                        // shapes work, but now those are handled separately.
                        // if (upper < lower - Math.EPSILON)
                        if (upper < lower) {
                            return false;
                        }
                    }
                    _ASSERT && common1.assert(0 <= lower && lower <= input.maxFraction);
                    if (index >= 0) {
                        output.fraction = lower;
                        output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);
                        return true;
                    }
                    return false;
                };
                PolygonShape.prototype.computeAABB = function(aabb, xf, childIndex) {
                    var minX = Infinity, minY = Infinity;
                    var maxX = -Infinity, maxY = -Infinity;
                    for(var i = 0; i < this.m_count; ++i){
                        var v = Transform.mulVec2(xf, this.m_vertices[i]);
                        minX = Math1.min(minX, v.x);
                        maxX = Math1.max(maxX, v.x);
                        minY = Math1.min(minY, v.y);
                        maxY = Math1.max(maxY, v.y);
                    }
                    aabb.lowerBound.set(minX, minY);
                    aabb.upperBound.set(maxX, maxY);
                    aabb.extend(this.m_radius);
                };
                PolygonShape.prototype.computeMass = function(massData, density) {
                    // Polygon mass, centroid, and inertia.
                    // Let rho be the polygon density in mass per unit area.
                    // Then:
                    // mass = rho * int(dA)
                    // centroid.x = (1/mass) * rho * int(x * dA)
                    // centroid.y = (1/mass) * rho * int(y * dA)
                    // I = rho * int((x*x + y*y) * dA)
                    //
                    // We can compute these integrals by summing all the integrals
                    // for each triangle of the polygon. To evaluate the integral
                    // for a single triangle, we make a change of variables to
                    // the (u,v) coordinates of the triangle:
                    // x = x0 + e1x * u + e2x * v
                    // y = y0 + e1y * u + e2y * v
                    // where 0 <= u && 0 <= v && u + v <= 1.
                    //
                    // We integrate u from [0,1-v] and then v from [0,1].
                    // We also need to use the Jacobian of the transformation:
                    // D = cross(e1, e2)
                    //
                    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
                    //
                    // The rest of the derivation is handled by computer algebra.
                    _ASSERT && common1.assert(this.m_count >= 3);
                    var center = Vec2.zero();
                    var area = 0;
                    var I = 0;
                    // s is the reference point for forming triangles.
                    // It's location doesn't change the result (except for rounding error).
                    var s = Vec2.zero();
                    // This code would put the reference point inside the polygon.
                    for(var i = 0; i < this.m_count; ++i){
                        s.add(this.m_vertices[i]);
                    }
                    s.mul(1 / this.m_count);
                    var k_inv3 = 1 / 3;
                    for(var i = 0; i < this.m_count; ++i){
                        // Triangle vertices.
                        var e1 = Vec2.sub(this.m_vertices[i], s);
                        var e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2.sub(this.m_vertices[0], s);
                        var D = Vec2.cross(e1, e2);
                        var triangleArea = .5 * D;
                        area += triangleArea;
                        // Area weighted centroid
                        center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);
                        var ex1 = e1.x;
                        var ey1 = e1.y;
                        var ex2 = e2.x;
                        var ey2 = e2.y;
                        var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
                        var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
                        I += .25 * k_inv3 * D * (intx2 + inty2);
                    }
                    // Total mass
                    massData.mass = density * area;
                    // Center of mass
                    _ASSERT && common1.assert(area > Math1.EPSILON);
                    center.mul(1 / area);
                    massData.center.setCombine(1, center, 1, s);
                    // Inertia tensor relative to the local origin (point s).
                    massData.I = density * I;
                    // Shift to center of mass then to original body origin.
                    massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));
                };
                // Validate convexity. This is a very time consuming operation.
                // @returns true if valid
                PolygonShape.prototype.validate = function() {
                    for(var i = 0; i < this.m_count; ++i){
                        var i1 = i;
                        var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
                        var p = this.m_vertices[i1];
                        var e = Vec2.sub(this.m_vertices[i2], p);
                        for(var j = 0; j < this.m_count; ++j){
                            if (j == i1 || j == i2) {
                                continue;
                            }
                            var v = Vec2.sub(this.m_vertices[j], p);
                            var c = Vec2.cross(e, v);
                            if (c < 0) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                PolygonShape.prototype.computeDistanceProxy = function(proxy) {
                    proxy.m_vertices = this.m_vertices;
                    proxy.m_count = this.m_count;
                    proxy.m_radius = this.m_radius;
                };
            },
            {
                "../Settings": 7,
                "../Shape": 8,
                "../collision/AABB": 11,
                "../common/Math": 18,
                "../common/Rot": 20,
                "../common/Transform": 22,
                "../common/Vec2": 23,
                "../util/common": 50,
                "../util/create": 51,
                "../util/options": 52
            }
        ],
        48: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports = Pool;
                function Pool(opts) {
                    var _queue = [];
                    var _max = opts.max || Infinity;
                    var _createFn = opts.create || function() {
                        return {};
                    };
                    var _outFn = opts.allocate || function() {};
                    var _inFn = opts.release || function() {};
                    var _discardFn = opts.discard || function() {};
                    var _createCount = 0;
                    var _outCount = 0;
                    var _inCount = 0;
                    var _discardCount = 0;
                    this.max = function(n) {
                        if (typeof n === "number") {
                            _max = n;
                            return this;
                        }
                        return _max;
                    };
                    this.size = function() {
                        return _queue.length;
                    };
                    this.allocate = function() {
                        var obj;
                        if (_queue.length > 0) {
                            obj = _queue.shift();
                        } else {
                            _createCount++;
                            obj = _createFn();
                        }
                        _outCount++;
                        _outFn(obj);
                        return obj;
                    };
                    this.release = function(obj) {
                        if (_queue.length < _max) {
                            _inCount++;
                            _inFn(obj);
                            _queue.push(obj);
                        } else {
                            _discardCount++;
                            _discardFn(obj);
                        }
                    };
                    this.toString = function() {
                        return " +" + _createCount + " >" + _outCount + " <" + _inCount + " -" + _discardCount + " =" + _queue.length + "/" + _max;
                    };
                }
            },
            {}
        ],
        49: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                module1.exports.now = function() {
                    return Date.now();
                };
                module1.exports.diff = function(time) {
                    return Date.now() - time;
                };
            },
            {}
        ],
        50: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                exports1.debug = function() {
                    if (!_DEBUG) return;
                    console.log.apply(console, arguments);
                };
                exports1.assert = function(statement, err, log) {
                    if (!_ASSERT) return;
                    if (statement) return;
                    log && console.log(log);
                    throw new Error(err);
                };
            },
            {}
        ],
        51: [
            function(require1, module1, exports1) {
                if (typeof Object.create == "function") {
                    module1.exports = function(proto, props) {
                        return Object.create.call(Object, proto, props);
                    };
                } else {
                    module1.exports = function(proto, props) {
                        if (props) throw Error("Second argument is not supported!");
                        if (typeof proto !== "object" || proto === null) throw Error("Invalid prototype!");
                        noop.prototype = proto;
                        return new noop();
                    };
                    function noop() {}
                }
            },
            {}
        ],
        52: [
            function(require1, module1, exports1) {
                var _DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;
                var _ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;
                var propIsEnumerable = Object.prototype.propertyIsEnumerable;
                module1.exports = function(to, from) {
                    if (to === null || typeof to === "undefined") {
                        to = {};
                    }
                    for(var key in from){
                        if (from.hasOwnProperty(key) && typeof to[key] === "undefined") {
                            to[key] = from[key];
                        }
                    }
                    if (typeof Object.getOwnPropertySymbols === "function") {
                        var symbols = Object.getOwnPropertySymbols(from);
                        for(var i = 0; i < symbols.length; i++){
                            var symbol = symbols[i];
                            if (from.propertyIsEnumerable(symbol) && typeof to[key] === "undefined") {
                                to[symbol] = from[symbol];
                            }
                        }
                    }
                    return to;
                };
            },
            {}
        ]
    }, {}, [
        1
    ])(1);
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NoZXJwYS9saWIvcGxhbmNrLTAuMy4wLXJjLjIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFBsYW5jay5qcyB2MC4zLjAtcmMuMlxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBBbGkgU2hha2liYSBodHRwOi8vc2hha2liYS5tZS9wbGFuY2suanNcbiAqIENvcHlyaWdodCAoYykgMjAwNi0yMDEzIEVyaW4gQ2F0dG8gIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tXG4gKiBcbiAqIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4gKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4gKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbiAqIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbiAqIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbiAqIFxuICogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3RcbiAqIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4gKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbiAqIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4gKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuICogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuICogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cbiAqL1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucGxhbmNrPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5pbnRlcm5hbCA9IHt9O1xuXG5leHBvcnRzLk1hdGggPSByZXF1aXJlKFwiLi9jb21tb24vTWF0aFwiKTtcblxuZXhwb3J0cy5WZWMyID0gcmVxdWlyZShcIi4vY29tbW9uL1ZlYzJcIik7XG5cbmV4cG9ydHMuVmVjMyA9IHJlcXVpcmUoXCIuL2NvbW1vbi9WZWMzXCIpO1xuXG5leHBvcnRzLk1hdDIyID0gcmVxdWlyZShcIi4vY29tbW9uL01hdDIyXCIpO1xuXG5leHBvcnRzLk1hdDMzID0gcmVxdWlyZShcIi4vY29tbW9uL01hdDMzXCIpO1xuXG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbmV4cG9ydHMuUm90ID0gcmVxdWlyZShcIi4vY29tbW9uL1JvdFwiKTtcblxuZXhwb3J0cy5BQUJCID0gcmVxdWlyZShcIi4vY29sbGlzaW9uL0FBQkJcIik7XG5cbmV4cG9ydHMuU2hhcGUgPSByZXF1aXJlKFwiLi9TaGFwZVwiKTtcblxuZXhwb3J0cy5GaXh0dXJlID0gcmVxdWlyZShcIi4vRml4dHVyZVwiKTtcblxuZXhwb3J0cy5Cb2R5ID0gcmVxdWlyZShcIi4vQm9keVwiKTtcblxuZXhwb3J0cy5Db250YWN0ID0gcmVxdWlyZShcIi4vQ29udGFjdFwiKTtcblxuZXhwb3J0cy5Kb2ludCA9IHJlcXVpcmUoXCIuL0pvaW50XCIpO1xuXG5leHBvcnRzLldvcmxkID0gcmVxdWlyZShcIi4vV29ybGRcIik7XG5cbmV4cG9ydHMuQ2lyY2xlID0gcmVxdWlyZShcIi4vc2hhcGUvQ2lyY2xlU2hhcGVcIik7XG5cbmV4cG9ydHMuRWRnZSA9IHJlcXVpcmUoXCIuL3NoYXBlL0VkZ2VTaGFwZVwiKTtcblxuZXhwb3J0cy5Qb2x5Z29uID0gcmVxdWlyZShcIi4vc2hhcGUvUG9seWdvblNoYXBlXCIpO1xuXG5leHBvcnRzLkNoYWluID0gcmVxdWlyZShcIi4vc2hhcGUvQ2hhaW5TaGFwZVwiKTtcblxuZXhwb3J0cy5Cb3ggPSByZXF1aXJlKFwiLi9zaGFwZS9Cb3hTaGFwZVwiKTtcblxucmVxdWlyZShcIi4vc2hhcGUvQ29sbGlkZUNpcmNsZVwiKTtcblxucmVxdWlyZShcIi4vc2hhcGUvQ29sbGlkZUVkZ2VDaXJjbGVcIik7XG5cbmV4cG9ydHMuaW50ZXJuYWwuQ29sbGlkZVBvbHlnb25zID0gcmVxdWlyZShcIi4vc2hhcGUvQ29sbGlkZVBvbHlnb25cIik7XG5cbnJlcXVpcmUoXCIuL3NoYXBlL0NvbGxpZGVDaXJjbGVQb2x5Z29uZVwiKTtcblxucmVxdWlyZShcIi4vc2hhcGUvQ29sbGlkZUVkZ2VQb2x5Z29uXCIpO1xuXG5leHBvcnRzLkRpc3RhbmNlSm9pbnQgPSByZXF1aXJlKFwiLi9qb2ludC9EaXN0YW5jZUpvaW50XCIpO1xuXG5leHBvcnRzLkZyaWN0aW9uSm9pbnQgPSByZXF1aXJlKFwiLi9qb2ludC9GcmljdGlvbkpvaW50XCIpO1xuXG5leHBvcnRzLkdlYXJKb2ludCA9IHJlcXVpcmUoXCIuL2pvaW50L0dlYXJKb2ludFwiKTtcblxuZXhwb3J0cy5Nb3RvckpvaW50ID0gcmVxdWlyZShcIi4vam9pbnQvTW90b3JKb2ludFwiKTtcblxuZXhwb3J0cy5Nb3VzZUpvaW50ID0gcmVxdWlyZShcIi4vam9pbnQvTW91c2VKb2ludFwiKTtcblxuZXhwb3J0cy5QcmlzbWF0aWNKb2ludCA9IHJlcXVpcmUoXCIuL2pvaW50L1ByaXNtYXRpY0pvaW50XCIpO1xuXG5leHBvcnRzLlB1bGxleUpvaW50ID0gcmVxdWlyZShcIi4vam9pbnQvUHVsbGV5Sm9pbnRcIik7XG5cbmV4cG9ydHMuUmV2b2x1dGVKb2ludCA9IHJlcXVpcmUoXCIuL2pvaW50L1Jldm9sdXRlSm9pbnRcIik7XG5cbmV4cG9ydHMuUm9wZUpvaW50ID0gcmVxdWlyZShcIi4vam9pbnQvUm9wZUpvaW50XCIpO1xuXG5leHBvcnRzLldlbGRKb2ludCA9IHJlcXVpcmUoXCIuL2pvaW50L1dlbGRKb2ludFwiKTtcblxuZXhwb3J0cy5XaGVlbEpvaW50ID0gcmVxdWlyZShcIi4vam9pbnQvV2hlZWxKb2ludFwiKTtcblxuZXhwb3J0cy5pbnRlcm5hbC5Td2VlcCA9IHJlcXVpcmUoXCIuL2NvbW1vbi9Td2VlcFwiKTtcblxuZXhwb3J0cy5pbnRlcm5hbC5zdGF0cyA9IHJlcXVpcmUoXCIuL2NvbW1vbi9zdGF0c1wiKTtcblxuZXhwb3J0cy5pbnRlcm5hbC5NYW5pZm9sZCA9IHJlcXVpcmUoXCIuL01hbmlmb2xkXCIpO1xuXG5leHBvcnRzLmludGVybmFsLkRpc3RhbmNlID0gcmVxdWlyZShcIi4vY29sbGlzaW9uL0Rpc3RhbmNlXCIpO1xuXG5leHBvcnRzLmludGVybmFsLlRpbWVPZkltcGFjdCA9IHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9UaW1lT2ZJbXBhY3RcIik7XG5cbmV4cG9ydHMuaW50ZXJuYWwuRHluYW1pY1RyZWUgPSByZXF1aXJlKFwiLi9jb2xsaXNpb24vRHluYW1pY1RyZWVcIik7XG5cbmV4cG9ydHMuaW50ZXJuYWwuU2V0dGluZ3MgPSByZXF1aXJlKFwiLi9TZXR0aW5nc1wiKTtcbn0se1wiLi9Cb2R5XCI6MixcIi4vQ29udGFjdFwiOjMsXCIuL0ZpeHR1cmVcIjo0LFwiLi9Kb2ludFwiOjUsXCIuL01hbmlmb2xkXCI6NixcIi4vU2V0dGluZ3NcIjo3LFwiLi9TaGFwZVwiOjgsXCIuL1dvcmxkXCI6MTAsXCIuL2NvbGxpc2lvbi9BQUJCXCI6MTEsXCIuL2NvbGxpc2lvbi9EaXN0YW5jZVwiOjEzLFwiLi9jb2xsaXNpb24vRHluYW1pY1RyZWVcIjoxNCxcIi4vY29sbGlzaW9uL1RpbWVPZkltcGFjdFwiOjE1LFwiLi9jb21tb24vTWF0MjJcIjoxNixcIi4vY29tbW9uL01hdDMzXCI6MTcsXCIuL2NvbW1vbi9NYXRoXCI6MTgsXCIuL2NvbW1vbi9Sb3RcIjoyMCxcIi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuL2NvbW1vbi9UcmFuc2Zvcm1cIjoyMixcIi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4vY29tbW9uL3N0YXRzXCI6MjYsXCIuL2pvaW50L0Rpc3RhbmNlSm9pbnRcIjoyNyxcIi4vam9pbnQvRnJpY3Rpb25Kb2ludFwiOjI4LFwiLi9qb2ludC9HZWFySm9pbnRcIjoyOSxcIi4vam9pbnQvTW90b3JKb2ludFwiOjMwLFwiLi9qb2ludC9Nb3VzZUpvaW50XCI6MzEsXCIuL2pvaW50L1ByaXNtYXRpY0pvaW50XCI6MzIsXCIuL2pvaW50L1B1bGxleUpvaW50XCI6MzMsXCIuL2pvaW50L1Jldm9sdXRlSm9pbnRcIjozNCxcIi4vam9pbnQvUm9wZUpvaW50XCI6MzUsXCIuL2pvaW50L1dlbGRKb2ludFwiOjM2LFwiLi9qb2ludC9XaGVlbEpvaW50XCI6MzcsXCIuL3NoYXBlL0JveFNoYXBlXCI6MzgsXCIuL3NoYXBlL0NoYWluU2hhcGVcIjozOSxcIi4vc2hhcGUvQ2lyY2xlU2hhcGVcIjo0MCxcIi4vc2hhcGUvQ29sbGlkZUNpcmNsZVwiOjQxLFwiLi9zaGFwZS9Db2xsaWRlQ2lyY2xlUG9seWdvbmVcIjo0MixcIi4vc2hhcGUvQ29sbGlkZUVkZ2VDaXJjbGVcIjo0MyxcIi4vc2hhcGUvQ29sbGlkZUVkZ2VQb2x5Z29uXCI6NDQsXCIuL3NoYXBlL0NvbGxpZGVQb2x5Z29uXCI6NDUsXCIuL3NoYXBlL0VkZ2VTaGFwZVwiOjQ2LFwiLi9zaGFwZS9Qb2x5Z29uU2hhcGVcIjo0N31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvZHk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi91dGlsL2NvbW1vblwiKTtcblxudmFyIG9wdGlvbnMgPSByZXF1aXJlKFwiLi91dGlsL29wdGlvbnNcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi9jb21tb24vUm90XCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi9jb21tb24vU3dlZXBcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgVmVsb2NpdHkgPSByZXF1aXJlKFwiLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuL2NvbW1vbi9Qb3NpdGlvblwiKTtcblxudmFyIEZpeHR1cmUgPSByZXF1aXJlKFwiLi9GaXh0dXJlXCIpO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKFwiLi9TaGFwZVwiKTtcblxudmFyIFdvcmxkID0gcmVxdWlyZShcIi4vV29ybGRcIik7XG5cbnZhciBzdGF0aWNCb2R5ID0gQm9keS5TVEFUSUMgPSBcInN0YXRpY1wiO1xuXG52YXIga2luZW1hdGljQm9keSA9IEJvZHkuS0lORU1BVElDID0gXCJraW5lbWF0aWNcIjtcblxudmFyIGR5bmFtaWNCb2R5ID0gQm9keS5EWU5BTUlDID0gXCJkeW5hbWljXCI7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQm9keURlZlxuICpcbiAqIEBwcm9wIHR5cGUgQm9keSB0eXBlcyBhcmUgc3RhdGljLCBraW5lbWF0aWMsIG9yIGR5bmFtaWMuIE5vdGU6IGlmIGEgZHluYW1pY1xuICogICAgICAgYm9keSB3b3VsZCBoYXZlIHplcm8gbWFzcywgdGhlIG1hc3MgaXMgc2V0IHRvIG9uZS5cbiAqXG4gKiBAcHJvcCBwb3NpdGlvbiBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIGJvZHkuIEF2b2lkIGNyZWF0aW5nIGJvZGllcyBhdCB0aGVcbiAqICAgICAgIG9yaWdpbiBzaW5jZSB0aGlzIGNhbiBsZWFkIHRvIG1hbnkgb3ZlcmxhcHBpbmcgc2hhcGVzLlxuICpcbiAqIEBwcm9wIGFuZ2xlIFRoZSB3b3JsZCBhbmdsZSBvZiB0aGUgYm9keSBpbiByYWRpYW5zLlxuICpcbiAqIEBwcm9wIGxpbmVhclZlbG9jaXR5IFRoZSBsaW5lYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkncyBvcmlnaW4gaW4gd29ybGRcbiAqICAgICAgIGNvLW9yZGluYXRlcy5cbiAqXG4gKiBAcHJvcCBsaW5lYXJEYW1waW5nIExpbmVhciBkYW1waW5nIGlzIHVzZSB0byByZWR1Y2UgdGhlIGxpbmVhciB2ZWxvY2l0eS4gVGhlXG4gKiAgICAgICBkYW1waW5nIHBhcmFtZXRlciBjYW4gYmUgbGFyZ2VyIHRoYW4gMS4wIGJ1dCB0aGUgZGFtcGluZyBlZmZlY3QgYmVjb21lc1xuICogICAgICAgc2Vuc2l0aXZlIHRvIHRoZSB0aW1lIHN0ZXAgd2hlbiB0aGUgZGFtcGluZyBwYXJhbWV0ZXIgaXMgbGFyZ2UuXG4gKlxuICogQHByb3AgYW5ndWxhckRhbXBpbmcgQW5ndWxhciBkYW1waW5nIGlzIHVzZSB0byByZWR1Y2UgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXG4gKiAgICAgICBUaGUgZGFtcGluZyBwYXJhbWV0ZXIgY2FuIGJlIGxhcmdlciB0aGFuIDEuMCBidXQgdGhlIGRhbXBpbmcgZWZmZWN0XG4gKiAgICAgICBiZWNvbWVzIHNlbnNpdGl2ZSB0byB0aGUgdGltZSBzdGVwIHdoZW4gdGhlIGRhbXBpbmcgcGFyYW1ldGVyIGlzIGxhcmdlLlxuICpcbiAqIEBwcm9wIGZpeGVkUm90YXRpb24gU2hvdWxkIHRoaXMgYm9keSBiZSBwcmV2ZW50ZWQgZnJvbSByb3RhdGluZz8gVXNlZnVsIGZvclxuICogICAgICAgY2hhcmFjdGVycy5cbiAqXG4gKiBAcHJvcCBidWxsZXQgSXMgdGhpcyBhIGZhc3QgbW92aW5nIGJvZHkgdGhhdCBzaG91bGQgYmUgcHJldmVudGVkIGZyb21cbiAqICAgICAgIHR1bm5lbGluZyB0aHJvdWdoIG90aGVyIG1vdmluZyBib2RpZXM/IE5vdGUgdGhhdCBhbGwgYm9kaWVzIGFyZVxuICogICAgICAgcHJldmVudGVkIGZyb20gdHVubmVsaW5nIHRocm91Z2gga2luZW1hdGljIGFuZCBzdGF0aWMgYm9kaWVzLiBUaGlzXG4gKiAgICAgICBzZXR0aW5nIGlzIG9ubHkgY29uc2lkZXJlZCBvbiBkeW5hbWljIGJvZGllcy4gV2FybmluZzogWW91IHNob3VsZCB1c2VcbiAqICAgICAgIHRoaXMgZmxhZyBzcGFyaW5nbHkgc2luY2UgaXQgaW5jcmVhc2VzIHByb2Nlc3NpbmcgdGltZS5cbiAqXG4gKiBAcHJvcCBhY3RpdmUgRG9lcyB0aGlzIGJvZHkgc3RhcnQgb3V0IGFjdGl2ZT9cbiAqXG4gKiBAcHJvcCBhd2FrZSBJcyB0aGlzIGJvZHkgaW5pdGlhbGx5IGF3YWtlIG9yIHNsZWVwaW5nP1xuICpcbiAqIEBwcm9wIGFsbG93U2xlZXAgU2V0IHRoaXMgZmxhZyB0byBmYWxzZSBpZiB0aGlzIGJvZHkgc2hvdWxkIG5ldmVyIGZhbGxcbiAqICAgICAgIGFzbGVlcC4gTm90ZSB0aGF0IHRoaXMgaW5jcmVhc2VzIENQVSB1c2FnZS5cbiAqL1xudmFyIEJvZHlEZWYgPSB7XG4gICAgdHlwZTogc3RhdGljQm9keSxcbiAgICBwb3NpdGlvbjogVmVjMi56ZXJvKCksXG4gICAgYW5nbGU6IDAsXG4gICAgbGluZWFyVmVsb2NpdHk6IFZlYzIuemVybygpLFxuICAgIGFuZ3VsYXJWZWxvY2l0eTogMCxcbiAgICBsaW5lYXJEYW1waW5nOiAwLFxuICAgIGFuZ3VsYXJEYW1waW5nOiAwLFxuICAgIGZpeGVkUm90YXRpb246IGZhbHNlLFxuICAgIGJ1bGxldDogZmFsc2UsXG4gICAgZ3Jhdml0eVNjYWxlOiAxLFxuICAgIGFsbG93U2xlZXA6IHRydWUsXG4gICAgYXdha2U6IHRydWUsXG4gICAgYWN0aXZlOiB0cnVlLFxuICAgIHVzZXJEYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBjbGFzc1xuICogXG4gKiBBIHJpZ2lkIGJvZHkgY29tcG9zZWQgb2Ygb25lIG9yIG1vcmUgZml4dHVyZXMuXG4gKiBcbiAqIEBwYXJhbSB7Qm9keURlZn0gZGVmXG4gKi9cbmZ1bmN0aW9uIEJvZHkod29ybGQsIGRlZikge1xuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBCb2R5RGVmKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoVmVjMi5pc1ZhbGlkKGRlZi5wb3NpdGlvbikpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChWZWMyLmlzVmFsaWQoZGVmLmxpbmVhclZlbG9jaXR5KSk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUoZGVmLmFuZ2xlKSk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUoZGVmLmFuZ3VsYXJWZWxvY2l0eSkpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChNYXRoLmlzRmluaXRlKGRlZi5hbmd1bGFyRGFtcGluZykgJiYgZGVmLmFuZ3VsYXJEYW1waW5nID49IDApO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChNYXRoLmlzRmluaXRlKGRlZi5saW5lYXJEYW1waW5nKSAmJiBkZWYubGluZWFyRGFtcGluZyA+PSAwKTtcbiAgICB0aGlzLm1fd29ybGQgPSB3b3JsZDtcbiAgICB0aGlzLm1fYXdha2VGbGFnID0gZGVmLmF3YWtlO1xuICAgIHRoaXMubV9hdXRvU2xlZXBGbGFnID0gZGVmLmFsbG93U2xlZXA7XG4gICAgdGhpcy5tX2J1bGxldEZsYWcgPSBkZWYuYnVsbGV0O1xuICAgIHRoaXMubV9maXhlZFJvdGF0aW9uRmxhZyA9IGRlZi5maXhlZFJvdGF0aW9uO1xuICAgIHRoaXMubV9hY3RpdmVGbGFnID0gZGVmLmFjdGl2ZTtcbiAgICB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMubV90b2lGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5tX3VzZXJEYXRhID0gZGVmLnVzZXJEYXRhO1xuICAgIHRoaXMubV90eXBlID0gZGVmLnR5cGU7XG4gICAgaWYgKHRoaXMubV90eXBlID09IGR5bmFtaWNCb2R5KSB7XG4gICAgICAgIHRoaXMubV9tYXNzID0gMTtcbiAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9tYXNzID0gMDtcbiAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAwO1xuICAgIH1cbiAgICAvLyBSb3RhdGlvbmFsIGluZXJ0aWEgYWJvdXQgdGhlIGNlbnRlciBvZiBtYXNzLlxuICAgIHRoaXMubV9JID0gMDtcbiAgICB0aGlzLm1faW52SSA9IDA7XG4gICAgLy8gdGhlIGJvZHkgb3JpZ2luIHRyYW5zZm9ybVxuICAgIHRoaXMubV94ZiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgIHRoaXMubV94Zi5wID0gVmVjMi5jbG9uZShkZWYucG9zaXRpb24pO1xuICAgIHRoaXMubV94Zi5xLnNldEFuZ2xlKGRlZi5hbmdsZSk7XG4gICAgLy8gdGhlIHN3ZXB0IG1vdGlvbiBmb3IgQ0NEXG4gICAgdGhpcy5tX3N3ZWVwID0gbmV3IFN3ZWVwKCk7XG4gICAgdGhpcy5tX3N3ZWVwLnNldFRyYW5zZm9ybSh0aGlzLm1feGYpO1xuICAgIC8vIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSBjb3JyZWN0aW9uXG4gICAgdGhpcy5jX3ZlbG9jaXR5ID0gbmV3IFZlbG9jaXR5KCk7XG4gICAgdGhpcy5jX3Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgdGhpcy5tX2ZvcmNlID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX3RvcnF1ZSA9IDA7XG4gICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5ID0gVmVjMi5jbG9uZShkZWYubGluZWFyVmVsb2NpdHkpO1xuICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSBkZWYuYW5ndWxhclZlbG9jaXR5O1xuICAgIHRoaXMubV9saW5lYXJEYW1waW5nID0gZGVmLmxpbmVhckRhbXBpbmc7XG4gICAgdGhpcy5tX2FuZ3VsYXJEYW1waW5nID0gZGVmLmFuZ3VsYXJEYW1waW5nO1xuICAgIHRoaXMubV9ncmF2aXR5U2NhbGUgPSBkZWYuZ3Jhdml0eVNjYWxlO1xuICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwO1xuICAgIHRoaXMubV9qb2ludExpc3QgPSBudWxsO1xuICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLm1fcHJldiA9IG51bGw7XG4gICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgIHRoaXMubV9kZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuQm9keS5wcm90b3R5cGUuaXNXb3JsZExvY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fd29ybGQgJiYgdGhpcy5tX3dvcmxkLmlzTG9ja2VkKCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRXb3JsZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fd29ybGQ7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9uZXh0O1xufTtcblxuQm9keS5wcm90b3R5cGUuc2V0VXNlckRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5tX3VzZXJEYXRhID0gZGF0YTtcbn07XG5cbkJvZHkucHJvdG90eXBlLmdldFVzZXJEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV91c2VyRGF0YTtcbn07XG5cbkJvZHkucHJvdG90eXBlLmdldEZpeHR1cmVMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9maXh0dXJlTGlzdDtcbn07XG5cbkJvZHkucHJvdG90eXBlLmdldEpvaW50TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fam9pbnRMaXN0O1xufTtcblxuLyoqXG4gKiBXYXJuaW5nOiB0aGlzIGxpc3QgY2hhbmdlcyBkdXJpbmcgdGhlIHRpbWUgc3RlcCBhbmQgeW91IG1heSBtaXNzIHNvbWVcbiAqIGNvbGxpc2lvbnMgaWYgeW91IGRvbid0IHVzZSBDb250YWN0TGlzdGVuZXIuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldENvbnRhY3RMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9jb250YWN0TGlzdDtcbn07XG5cbkJvZHkucHJvdG90eXBlLmlzU3RhdGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV90eXBlID09IHN0YXRpY0JvZHk7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5pc0R5bmFtaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3R5cGUgPT0gZHluYW1pY0JvZHk7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5pc0tpbmVtYXRpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdHlwZSA9PSBraW5lbWF0aWNCb2R5O1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgYWx0ZXIgdGhlIG1hc3MgYW5kIHZlbG9jaXR5LlxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRTdGF0aWMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFR5cGUoc3RhdGljQm9keSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5zZXREeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRUeXBlKGR5bmFtaWNCb2R5KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkJvZHkucHJvdG90eXBlLnNldEtpbmVtYXRpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0VHlwZShraW5lbWF0aWNCb2R5KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbn07XG5cbi8qKlxuICogXG4gKiBAcHJpdmF0ZVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0eXBlID09PSBzdGF0aWNCb2R5IHx8IHR5cGUgPT09IGtpbmVtYXRpY0JvZHkgfHwgdHlwZSA9PT0gZHluYW1pY0JvZHkpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0aGlzLmlzV29ybGRMb2NrZWQoKSA9PSBmYWxzZSk7XG4gICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tX3R5cGUgPT0gdHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubV90eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlc2V0TWFzc0RhdGEoKTtcbiAgICBpZiAodGhpcy5tX3R5cGUgPT0gc3RhdGljQm9keSkge1xuICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuc2V0WmVybygpO1xuICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy5tX3N3ZWVwLmZvcndhcmQoKTtcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZUZpeHR1cmVzKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2ZvcmNlLnNldFplcm8oKTtcbiAgICB0aGlzLm1fdG9ycXVlID0gMDtcbiAgICAvLyBEZWxldGUgdGhlIGF0dGFjaGVkIGNvbnRhY3RzLlxuICAgIHZhciBjZSA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgdmFyIGNlMCA9IGNlO1xuICAgICAgICBjZSA9IGNlLm5leHQ7XG4gICAgICAgIHRoaXMubV93b3JsZC5kZXN0cm95Q29udGFjdChjZTAuY29udGFjdCk7XG4gICAgfVxuICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgLy8gVG91Y2ggdGhlIHByb3hpZXMgc28gdGhhdCBuZXcgY29udGFjdHMgd2lsbCBiZSBjcmVhdGVkICh3aGVuIGFwcHJvcHJpYXRlKVxuICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICBmb3IgKHZhciBmID0gdGhpcy5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgdmFyIHByb3h5Q291bnQgPSBmLm1fcHJveHlDb3VudDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm94eUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGJyb2FkUGhhc2UudG91Y2hQcm94eShmLm1fcHJveGllc1tpXS5wcm94eUlkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJvZHkucHJvdG90eXBlLmlzQnVsbGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9idWxsZXRGbGFnO1xufTtcblxuLyoqXG4gKiBTaG91bGQgdGhpcyBib2R5IGJlIHRyZWF0ZWQgbGlrZSBhIGJ1bGxldCBmb3IgY29udGludW91cyBjb2xsaXNpb24gZGV0ZWN0aW9uP1xuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRCdWxsZXQgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgdGhpcy5tX2J1bGxldEZsYWcgPSAhIWZsYWc7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5pc1NsZWVwaW5nQWxsb3dlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYXV0b1NsZWVwRmxhZztcbn07XG5cbkJvZHkucHJvdG90eXBlLnNldFNsZWVwaW5nQWxsb3dlZCA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICB0aGlzLm1fYXV0b1NsZWVwRmxhZyA9ICEhZmxhZztcbiAgICBpZiAodGhpcy5tX2F1dG9TbGVlcEZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICB9XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5pc0F3YWtlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9hd2FrZUZsYWc7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc2xlZXAgc3RhdGUgb2YgdGhlIGJvZHkuIEEgc2xlZXBpbmcgYm9keSBoYXMgdmVyeSBsb3cgQ1BVIGNvc3QuXG4gKiBcbiAqIEBwYXJhbSBmbGFnIFNldCB0byB0cnVlIHRvIHdha2UgdGhlIGJvZHksIGZhbHNlIHRvIHB1dCBpdCB0byBzbGVlcC5cbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0QXdha2UgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgaWYgKGZsYWcpIHtcbiAgICAgICAgaWYgKHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubV9hd2FrZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tX3NsZWVwVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1fYXdha2VGbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwO1xuICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuc2V0WmVybygpO1xuICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy5tX2ZvcmNlLnNldFplcm8oKTtcbiAgICAgICAgdGhpcy5tX3RvcnF1ZSA9IDA7XG4gICAgfVxufTtcblxuQm9keS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2FjdGl2ZUZsYWc7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBib2R5LiBBbiBpbmFjdGl2ZSBib2R5IGlzIG5vdCBzaW11bGF0ZWQgYW5kXG4gKiBjYW5ub3QgYmUgY29sbGlkZWQgd2l0aCBvciB3b2tlbiB1cC4gSWYgeW91IHBhc3MgYSBmbGFnIG9mIHRydWUsIGFsbCBmaXh0dXJlc1xuICogd2lsbCBiZSBhZGRlZCB0byB0aGUgYnJvYWQtcGhhc2UuIElmIHlvdSBwYXNzIGEgZmxhZyBvZiBmYWxzZSwgYWxsIGZpeHR1cmVzXG4gKiB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYnJvYWQtcGhhc2UgYW5kIGFsbCBjb250YWN0cyB3aWxsIGJlIGRlc3Ryb3llZC5cbiAqIEZpeHR1cmVzIGFuZCBqb2ludHMgYXJlIG90aGVyd2lzZSB1bmFmZmVjdGVkLlxuICogXG4gKiBZb3UgbWF5IGNvbnRpbnVlIHRvIGNyZWF0ZS9kZXN0cm95IGZpeHR1cmVzIGFuZCBqb2ludHMgb24gaW5hY3RpdmUgYm9kaWVzLlxuICogRml4dHVyZXMgb24gYW4gaW5hY3RpdmUgYm9keSBhcmUgaW1wbGljaXRseSBpbmFjdGl2ZSBhbmQgd2lsbCBub3QgcGFydGljaXBhdGVcbiAqIGluIGNvbGxpc2lvbnMsIHJheS1jYXN0cywgb3IgcXVlcmllcy4gSm9pbnRzIGNvbm5lY3RlZCB0byBhbiBpbmFjdGl2ZSBib2R5XG4gKiBhcmUgaW1wbGljaXRseSBpbmFjdGl2ZS4gQW4gaW5hY3RpdmUgYm9keSBpcyBzdGlsbCBvd25lZCBieSBhIFdvcmxkIG9iamVjdFxuICogYW5kIHJlbWFpbnNcbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24oZmxhZykge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0aGlzLmlzV29ybGRMb2NrZWQoKSA9PSBmYWxzZSk7XG4gICAgaWYgKGZsYWcgPT0gdGhpcy5tX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1fYWN0aXZlRmxhZyA9ICEhZmxhZztcbiAgICBpZiAodGhpcy5tX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBwcm94aWVzLlxuICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2Jyb2FkUGhhc2U7XG4gICAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgZi5jcmVhdGVQcm94aWVzKGJyb2FkUGhhc2UsIHRoaXMubV94Zik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZXN0cm95IGFsbCBwcm94aWVzLlxuICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2Jyb2FkUGhhc2U7XG4gICAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgZi5kZXN0cm95UHJveGllcyhicm9hZFBoYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXN0cm95IHRoZSBhdHRhY2hlZCBjb250YWN0cy5cbiAgICAgICAgdmFyIGNlID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgICAgIGNlID0gY2UubmV4dDtcbiAgICAgICAgICAgIHRoaXMubV93b3JsZC5kZXN0cm95Q29udGFjdChjZTAuY29udGFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcbiAgICB9XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5pc0ZpeGVkUm90YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnO1xufTtcblxuLyoqXG4gKiBTZXQgdGhpcyBib2R5IHRvIGhhdmUgZml4ZWQgcm90YXRpb24uIFRoaXMgY2F1c2VzIHRoZSBtYXNzIHRvIGJlIHJlc2V0LlxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRGaXhlZFJvdGF0aW9uID0gZnVuY3Rpb24oZmxhZykge1xuICAgIGlmICh0aGlzLm1fZml4ZWRSb3RhdGlvbkZsYWcgPT0gZmxhZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubV9maXhlZFJvdGF0aW9uRmxhZyA9ICEhZmxhZztcbiAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLnJlc2V0TWFzc0RhdGEoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gZm9yIHRoZSBib2R5J3Mgb3JpZ2luLlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3hmO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5J3Mgb3JpZ2luIGFuZCByb3RhdGlvbi4gTWFuaXB1bGF0aW5nIGEgYm9keSdzXG4gKiB0cmFuc2Zvcm0gbWF5IGNhdXNlIG5vbi1waHlzaWNhbCBiZWhhdmlvci4gTm90ZTogY29udGFjdHMgYXJlIHVwZGF0ZWQgb24gdGhlXG4gKiBuZXh0IGNhbGwgdG8gV29ybGQuc3RlcC5cbiAqIFxuICogQHBhcmFtIHBvc2l0aW9uIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIGxvY2FsIG9yaWdpbi5cbiAqIEBwYXJhbSBhbmdsZSBUaGUgd29ybGQgcm90YXRpb24gaW4gcmFkaWFucy5cbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24ocG9zaXRpb24sIGFuZ2xlKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMuaXNXb3JsZExvY2tlZCgpID09IGZhbHNlKTtcbiAgICBpZiAodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubV94Zi5zZXQocG9zaXRpb24sIGFuZ2xlKTtcbiAgICB0aGlzLm1fc3dlZXAuc2V0VHJhbnNmb3JtKHRoaXMubV94Zik7XG4gICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICBmLnN5bmNocm9uaXplKGJyb2FkUGhhc2UsIHRoaXMubV94ZiwgdGhpcy5tX3hmKTtcbiAgICB9XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5zeW5jaHJvbml6ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubV9zd2VlcC5nZXRUcmFuc2Zvcm0odGhpcy5tX3hmLCAxKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGZpeHR1cmVzIGluIGJyb2FkLXBoYXNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5zeW5jaHJvbml6ZUZpeHR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHhmID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgdGhpcy5tX3N3ZWVwLmdldFRyYW5zZm9ybSh4ZiwgMCk7XG4gICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICBmLnN5bmNocm9uaXplKGJyb2FkUGhhc2UsIHhmLCB0aGlzLm1feGYpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXNlZCBpbiBUT0kuXG4gKi9cbkJvZHkucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5ldyBzYWZlIHRpbWUuIFRoaXMgZG9lc24ndCBzeW5jIHRoZSBicm9hZC1waGFzZS5cbiAgICB0aGlzLm1fc3dlZXAuYWR2YW5jZShhbHBoYSk7XG4gICAgdGhpcy5tX3N3ZWVwLmMuc2V0KHRoaXMubV9zd2VlcC5jMCk7XG4gICAgdGhpcy5tX3N3ZWVwLmEgPSB0aGlzLm1fc3dlZXAuYTA7XG4gICAgdGhpcy5tX3N3ZWVwLmdldFRyYW5zZm9ybSh0aGlzLm1feGYsIDEpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHBvc2l0aW9uIGZvciB0aGUgYm9keSdzIG9yaWdpbi5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3hmLnA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHApIHtcbiAgICB0aGlzLnNldFRyYW5zZm9ybShwLCB0aGlzLm1fc3dlZXAuYSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB3b3JsZCByb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zLlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fc3dlZXAuYTtcbn07XG5cbkJvZHkucHJvdG90eXBlLnNldEFuZ2xlID0gZnVuY3Rpb24oYW5nbGUpIHtcbiAgICB0aGlzLnNldFRyYW5zZm9ybSh0aGlzLm1feGYucCwgYW5nbGUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0V29ybGRDZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3N3ZWVwLmM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRMb2NhbENlbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqIFxuICogQHJldHVybiB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyVmVsb2NpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xpbmVhclZlbG9jaXR5O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIGxpbmVhciB2ZWxvY2l0eSBvZiBhIHdvcmxkIHBvaW50IGF0dGFjaGVkIHRvIHRoaXMgYm9keS5cbiAqIFxuICogQHBhcmFtIHdvcmxkUG9pbnQgQSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludCA9IGZ1bmN0aW9uKHdvcmxkUG9pbnQpIHtcbiAgICB2YXIgbG9jYWxDZW50ZXIgPSBWZWMyLnN1Yih3b3JsZFBvaW50LCB0aGlzLm1fc3dlZXAuYyk7XG4gICAgcmV0dXJuIFZlYzIuYWRkKHRoaXMubV9saW5lYXJWZWxvY2l0eSwgVmVjMi5jcm9zcyh0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBsb2NhbENlbnRlcikpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHZlbG9jaXR5IG9mIGEgbG9jYWwgcG9pbnQuXG4gKiBcbiAqIEBwYXJhbSBsb2NhbFBvaW50IEEgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXMuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldExpbmVhclZlbG9jaXR5RnJvbUxvY2FsUG9pbnQgPSBmdW5jdGlvbihsb2NhbFBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludCh0aGlzLmdldFdvcmxkUG9pbnQobG9jYWxQb2ludCkpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXG4gKiBcbiAqIEBwYXJhbSB2IFRoZSBuZXcgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0TGluZWFyVmVsb2NpdHkgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHRoaXMubV90eXBlID09IHN0YXRpY0JvZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoVmVjMi5kb3QodiwgdikgPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5zZXQodik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5ndWxhciB2ZWxvY2l0eS5cbiAqIFxuICogQHJldHVybnMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmQuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYW5ndWxhclZlbG9jaXR5O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXG4gKiBcbiAqIEBwYXJhbSBvbWVnYSBUaGUgbmV3IGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmQuXG4gKi9cbkJvZHkucHJvdG90eXBlLnNldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uKHcpIHtcbiAgICBpZiAodGhpcy5tX3R5cGUgPT0gc3RhdGljQm9keSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3ICogdyA+IDApIHtcbiAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IHc7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRMaW5lYXJEYW1waW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9saW5lYXJEYW1waW5nO1xufTtcblxuQm9keS5wcm90b3R5cGUuc2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uKGxpbmVhckRhbXBpbmcpIHtcbiAgICB0aGlzLm1fbGluZWFyRGFtcGluZyA9IGxpbmVhckRhbXBpbmc7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRBbmd1bGFyRGFtcGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYW5ndWxhckRhbXBpbmc7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5zZXRBbmd1bGFyRGFtcGluZyA9IGZ1bmN0aW9uKGFuZ3VsYXJEYW1waW5nKSB7XG4gICAgdGhpcy5tX2FuZ3VsYXJEYW1waW5nID0gYW5ndWxhckRhbXBpbmc7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRHcmF2aXR5U2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2dyYXZpdHlTY2FsZTtcbn07XG5cbi8qKlxuICogU2NhbGUgdGhlIGdyYXZpdHkgYXBwbGllZCB0byB0aGlzIGJvZHkuXG4gKi9cbkJvZHkucHJvdG90eXBlLnNldEdyYXZpdHlTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgdGhpcy5tX2dyYXZpdHlTY2FsZSA9IHNjYWxlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRvdGFsIG1hc3Mgb2YgdGhlIGJvZHkuXG4gKiBcbiAqIEByZXR1cm5zIFRoZSBtYXNzLCB1c3VhbGx5IGluIGtpbG9ncmFtcyAoa2cpLlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRNYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tYXNzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHJvdGF0aW9uYWwgaW5lcnRpYSBvZiB0aGUgYm9keSBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLlxuICogXG4gKiBAcmV0dXJuIHRoZSByb3RhdGlvbmFsIGluZXJ0aWEsIHVzdWFsbHkgaW4ga2ctbV4yLlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRJbmVydGlhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9JICsgdGhpcy5tX21hc3MgKiBWZWMyLmRvdCh0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIsIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcik7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hc3NEYXRhIFRoaXMgaG9sZHMgdGhlIG1hc3MgZGF0YSBjb21wdXRlZCBmb3IgYSBzaGFwZS5cbiAqIFxuICogQHByb3AgbWFzcyBUaGUgbWFzcyBvZiB0aGUgc2hhcGUsIHVzdWFsbHkgaW4ga2lsb2dyYW1zLlxuICogQHByb3AgY2VudGVyIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGUncyBjZW50cm9pZCByZWxhdGl2ZSB0byB0aGUgc2hhcGUnc1xuICogICAgICAgb3JpZ2luLlxuICogQHByb3AgSSBUaGUgcm90YXRpb25hbCBpbmVydGlhIG9mIHRoZSBzaGFwZSBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLlxuICovXG5mdW5jdGlvbiBNYXNzRGF0YSgpIHtcbiAgICB0aGlzLm1hc3MgPSAwO1xuICAgIHRoaXMuY2VudGVyID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5JID0gMDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSBtYXNzIGRhdGEgb2YgdGhlIGJvZHkgdG8gZGF0YS5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0TWFzc0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YS5tYXNzID0gdGhpcy5tX21hc3M7XG4gICAgZGF0YS5JID0gdGhpcy5nZXRJbmVydGlhKCk7XG4gICAgZGF0YS5jZW50ZXIuc2V0KHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcik7XG59O1xuXG4vKipcbiAqIFRoaXMgcmVzZXRzIHRoZSBtYXNzIHByb3BlcnRpZXMgdG8gdGhlIHN1bSBvZiB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoZVxuICogZml4dHVyZXMuIFRoaXMgbm9ybWFsbHkgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgdW5sZXNzIHlvdSBjYWxsZWRcbiAqIFNldE1hc3NEYXRhIHRvIG92ZXJyaWRlIHRoZSBtYXNzIGFuZCB5b3UgbGF0ZXIgd2FudCB0byByZXNldCB0aGUgbWFzcy5cbiAqL1xuQm9keS5wcm90b3R5cGUucmVzZXRNYXNzRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIENvbXB1dGUgbWFzcyBkYXRhIGZyb20gc2hhcGVzLiBFYWNoIHNoYXBlIGhhcyBpdHMgb3duIGRlbnNpdHkuXG4gICAgdGhpcy5tX21hc3MgPSAwO1xuICAgIHRoaXMubV9pbnZNYXNzID0gMDtcbiAgICB0aGlzLm1fSSA9IDA7XG4gICAgdGhpcy5tX2ludkkgPSAwO1xuICAgIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlci5zZXRaZXJvKCk7XG4gICAgLy8gU3RhdGljIGFuZCBraW5lbWF0aWMgYm9kaWVzIGhhdmUgemVybyBtYXNzLlxuICAgIGlmICh0aGlzLmlzU3RhdGljKCkgfHwgdGhpcy5pc0tpbmVtYXRpYygpKSB7XG4gICAgICAgIHRoaXMubV9zd2VlcC5jMC5zZXQodGhpcy5tX3hmLnApO1xuICAgICAgICB0aGlzLm1fc3dlZXAuYy5zZXQodGhpcy5tX3hmLnApO1xuICAgICAgICB0aGlzLm1fc3dlZXAuYTAgPSB0aGlzLm1fc3dlZXAuYTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5pc0R5bmFtaWMoKSk7XG4gICAgLy8gQWNjdW11bGF0ZSBtYXNzIG92ZXIgYWxsIGZpeHR1cmVzLlxuICAgIHZhciBsb2NhbENlbnRlciA9IFZlYzIuemVybygpO1xuICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICBpZiAoZi5tX2RlbnNpdHkgPT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hc3NEYXRhID0gbmV3IE1hc3NEYXRhKCk7XG4gICAgICAgIGYuZ2V0TWFzc0RhdGEobWFzc0RhdGEpO1xuICAgICAgICB0aGlzLm1fbWFzcyArPSBtYXNzRGF0YS5tYXNzO1xuICAgICAgICBsb2NhbENlbnRlci5hZGRNdWwobWFzc0RhdGEubWFzcywgbWFzc0RhdGEuY2VudGVyKTtcbiAgICAgICAgdGhpcy5tX0kgKz0gbWFzc0RhdGEuSTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBjZW50ZXIgb2YgbWFzcy5cbiAgICBpZiAodGhpcy5tX21hc3MgPiAwKSB7XG4gICAgICAgIHRoaXMubV9pbnZNYXNzID0gMSAvIHRoaXMubV9tYXNzO1xuICAgICAgICBsb2NhbENlbnRlci5tdWwodGhpcy5tX2ludk1hc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvcmNlIGFsbCBkeW5hbWljIGJvZGllcyB0byBoYXZlIGEgcG9zaXRpdmUgbWFzcy5cbiAgICAgICAgdGhpcy5tX21hc3MgPSAxO1xuICAgICAgICB0aGlzLm1faW52TWFzcyA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm1fSSA+IDAgJiYgdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnID09IGZhbHNlKSB7XG4gICAgICAgIC8vIENlbnRlciB0aGUgaW5lcnRpYSBhYm91dCB0aGUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgIHRoaXMubV9JIC09IHRoaXMubV9tYXNzICogVmVjMi5kb3QobG9jYWxDZW50ZXIsIGxvY2FsQ2VudGVyKTtcbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMubV9JID4gMCk7XG4gICAgICAgIHRoaXMubV9pbnZJID0gMSAvIHRoaXMubV9JO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9JID0gMDtcbiAgICAgICAgdGhpcy5tX2ludkkgPSAwO1xuICAgIH1cbiAgICAvLyBNb3ZlIGNlbnRlciBvZiBtYXNzLlxuICAgIHZhciBvbGRDZW50ZXIgPSBWZWMyLmNsb25lKHRoaXMubV9zd2VlcC5jKTtcbiAgICB0aGlzLm1fc3dlZXAuc2V0TG9jYWxDZW50ZXIobG9jYWxDZW50ZXIsIHRoaXMubV94Zik7XG4gICAgLy8gVXBkYXRlIGNlbnRlciBvZiBtYXNzIHZlbG9jaXR5LlxuICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5hZGQoVmVjMi5jcm9zcyh0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBWZWMyLnN1Yih0aGlzLm1fc3dlZXAuYywgb2xkQ2VudGVyKSkpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1hc3MgcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoZSBmaXh0dXJlcy4gTm90ZVxuICogdGhhdCB0aGlzIGNoYW5nZXMgdGhlIGNlbnRlciBvZiBtYXNzIHBvc2l0aW9uLiBOb3RlIHRoYXQgY3JlYXRpbmcgb3JcbiAqIGRlc3Ryb3lpbmcgZml4dHVyZXMgY2FuIGFsc28gYWx0ZXIgdGhlIG1hc3MuIFRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdCBpZlxuICogdGhlIGJvZHkgaXNuJ3QgZHluYW1pYy5cbiAqIFxuICogQHBhcmFtIG1hc3NEYXRhIFRoZSBtYXNzIHByb3BlcnRpZXMuXG4gKi9cbkJvZHkucHJvdG90eXBlLnNldE1hc3NEYXRhID0gZnVuY3Rpb24obWFzc0RhdGEpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gZmFsc2UpO1xuICAgIGlmICh0aGlzLmlzV29ybGRMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubV90eXBlICE9IGR5bmFtaWNCb2R5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tX2ludk1hc3MgPSAwO1xuICAgIHRoaXMubV9JID0gMDtcbiAgICB0aGlzLm1faW52SSA9IDA7XG4gICAgdGhpcy5tX21hc3MgPSBtYXNzRGF0YS5tYXNzO1xuICAgIGlmICh0aGlzLm1fbWFzcyA8PSAwKSB7XG4gICAgICAgIHRoaXMubV9tYXNzID0gMTtcbiAgICB9XG4gICAgdGhpcy5tX2ludk1hc3MgPSAxIC8gdGhpcy5tX21hc3M7XG4gICAgaWYgKG1hc3NEYXRhLkkgPiAwICYmIHRoaXMubV9maXhlZFJvdGF0aW9uRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm1fSSA9IG1hc3NEYXRhLkkgLSB0aGlzLm1fbWFzcyAqIFZlYzIuZG90KG1hc3NEYXRhLmNlbnRlciwgbWFzc0RhdGEuY2VudGVyKTtcbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMubV9JID4gMCk7XG4gICAgICAgIHRoaXMubV9pbnZJID0gMSAvIHRoaXMubV9JO1xuICAgIH1cbiAgICAvLyBNb3ZlIGNlbnRlciBvZiBtYXNzLlxuICAgIHZhciBvbGRDZW50ZXIgPSBWZWMyLmNsb25lKHRoaXMubV9zd2VlcC5jKTtcbiAgICB0aGlzLm1fc3dlZXAuc2V0TG9jYWxDZW50ZXIobWFzc0RhdGEuY2VudGVyLCB0aGlzLm1feGYpO1xuICAgIC8vIFVwZGF0ZSBjZW50ZXIgb2YgbWFzcyB2ZWxvY2l0eS5cbiAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuYWRkKFZlYzIuY3Jvc3ModGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSwgVmVjMi5zdWIodGhpcy5tX3N3ZWVwLmMsIG9sZENlbnRlcikpKTtcbn07XG5cbi8qKlxuICogQXBwbHkgYSBmb3JjZSBhdCBhIHdvcmxkIHBvaW50LiBJZiB0aGUgZm9yY2UgaXMgbm90IGFwcGxpZWQgYXQgdGhlIGNlbnRlciBvZlxuICogbWFzcywgaXQgd2lsbCBnZW5lcmF0ZSBhIHRvcnF1ZSBhbmQgYWZmZWN0IHRoZSBhbmd1bGFyIHZlbG9jaXR5LiBUaGlzIHdha2VzXG4gKiB1cCB0aGUgYm9keS5cbiAqIFxuICogQHBhcmFtIGZvcmNlIFRoZSB3b3JsZCBmb3JjZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTmV3dG9ucyAoTikuXG4gKiBAcGFyYW0gcG9pbnQgVGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oZm9yY2UsIHBvaW50LCB3YWtlKSB7XG4gICAgaWYgKHRoaXMubV90eXBlICE9IGR5bmFtaWNCb2R5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdha2UgJiYgdGhpcy5tX2F3YWtlRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldEF3YWtlKHRydWUpO1xuICAgIH1cbiAgICAvLyBEb24ndCBhY2N1bXVsYXRlIGEgZm9yY2UgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcuXG4gICAgaWYgKHRoaXMubV9hd2FrZUZsYWcpIHtcbiAgICAgICAgdGhpcy5tX2ZvcmNlLmFkZChmb3JjZSk7XG4gICAgICAgIHRoaXMubV90b3JxdWUgKz0gVmVjMi5jcm9zcyhWZWMyLnN1Yihwb2ludCwgdGhpcy5tX3N3ZWVwLmMpLCBmb3JjZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBhIGZvcmNlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcy4gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cbiAqIFxuICogQHBhcmFtIGZvcmNlIFRoZSB3b3JsZCBmb3JjZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTmV3dG9ucyAoTikuXG4gKiBAcGFyYW0gd2FrZSBBbHNvIHdha2UgdXAgdGhlIGJvZHlcbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZVRvQ2VudGVyID0gZnVuY3Rpb24oZm9yY2UsIHdha2UpIHtcbiAgICBpZiAodGhpcy5tX3R5cGUgIT0gZHluYW1pY0JvZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2FrZSAmJiB0aGlzLm1fYXdha2VGbGFnID09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgfVxuICAgIC8vIERvbid0IGFjY3VtdWxhdGUgYSBmb3JjZSBpZiB0aGUgYm9keSBpcyBzbGVlcGluZ1xuICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgIHRoaXMubV9mb3JjZS5hZGQoZm9yY2UpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgYSB0b3JxdWUuIFRoaXMgYWZmZWN0cyB0aGUgYW5ndWxhciB2ZWxvY2l0eSB3aXRob3V0IGFmZmVjdGluZyB0aGVcbiAqIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXG4gKiBcbiAqIEBwYXJhbSB0b3JxdWUgQWJvdXQgdGhlIHotYXhpcyAob3V0IG9mIHRoZSBzY3JlZW4pLCB1c3VhbGx5IGluIE4tbS5cbiAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseVRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSwgd2FrZSkge1xuICAgIGlmICh0aGlzLm1fdHlwZSAhPSBkeW5hbWljQm9keSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3YWtlICYmIHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYWNjdW11bGF0ZSBhIGZvcmNlIGlmIHRoZSBib2R5IGlzIHNsZWVwaW5nXG4gICAgaWYgKHRoaXMubV9hd2FrZUZsYWcpIHtcbiAgICAgICAgdGhpcy5tX3RvcnF1ZSArPSB0b3JxdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBhbiBpbXB1bHNlIGF0IGEgcG9pbnQuIFRoaXMgaW1tZWRpYXRlbHkgbW9kaWZpZXMgdGhlIHZlbG9jaXR5LiBJdCBhbHNvXG4gKiBtb2RpZmllcyB0aGUgYW5ndWxhciB2ZWxvY2l0eSBpZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24gaXMgbm90IGF0IHRoZVxuICogY2VudGVyIG9mIG1hc3MuIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXG4gKiBcbiAqIEBwYXJhbSBpbXB1bHNlIFRoZSB3b3JsZCBpbXB1bHNlIHZlY3RvciwgdXN1YWxseSBpbiBOLXNlY29uZHMgb3Iga2ctbS9zLlxuICogQHBhcmFtIHBvaW50IFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24uXG4gKiBAcGFyYW0gd2FrZSBBbHNvIHdha2UgdXAgdGhlIGJvZHlcbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlMaW5lYXJJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZSwgcG9pbnQsIHdha2UpIHtcbiAgICBpZiAodGhpcy5tX3R5cGUgIT0gZHluYW1pY0JvZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2FrZSAmJiB0aGlzLm1fYXdha2VGbGFnID09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgfVxuICAgIC8vIERvbid0IGFjY3VtdWxhdGUgdmVsb2NpdHkgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmdcbiAgICBpZiAodGhpcy5tX2F3YWtlRmxhZykge1xuICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuYWRkTXVsKHRoaXMubV9pbnZNYXNzLCBpbXB1bHNlKTtcbiAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLm1faW52SSAqIFZlYzIuY3Jvc3MoVmVjMi5zdWIocG9pbnQsIHRoaXMubV9zd2VlcC5jKSwgaW1wdWxzZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBhbiBhbmd1bGFyIGltcHVsc2UuXG4gKiBcbiAqIEBwYXJhbSBpbXB1bHNlIFRoZSBhbmd1bGFyIGltcHVsc2UgaW4gdW5pdHMgb2Yga2cqbSptL3NcbiAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseUFuZ3VsYXJJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZSwgd2FrZSkge1xuICAgIGlmICh0aGlzLm1fdHlwZSAhPSBkeW5hbWljQm9keSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3YWtlICYmIHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYWNjdW11bGF0ZSB2ZWxvY2l0eSBpZiB0aGUgYm9keSBpcyBzbGVlcGluZ1xuICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5tX2ludkkgKiBpbXB1bHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgY29ubmVjdGVkIGJvZGllcyAoYnkgam9pbnRzKSBmcm9tIGNvbGxpZGluZyxcbiAqIGRlcGVuZGluZyBvbiB0aGUgam9pbnQncyBjb2xsaWRlQ29ubmVjdGVkIGZsYWcuXG4gKi9cbkJvZHkucHJvdG90eXBlLnNob3VsZENvbGxpZGUgPSBmdW5jdGlvbih0aGF0KSB7XG4gICAgLy8gQXQgbGVhc3Qgb25lIGJvZHkgc2hvdWxkIGJlIGR5bmFtaWMuXG4gICAgaWYgKHRoaXMubV90eXBlICE9IGR5bmFtaWNCb2R5ICYmIHRoYXQubV90eXBlICE9IGR5bmFtaWNCb2R5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRG9lcyBhIGpvaW50IHByZXZlbnQgY29sbGlzaW9uP1xuICAgIGZvciAodmFyIGpuID0gdGhpcy5tX2pvaW50TGlzdDsgam47IGpuID0gam4ubmV4dCkge1xuICAgICAgICBpZiAoam4ub3RoZXIgPT0gdGhhdCkge1xuICAgICAgICAgICAgaWYgKGpuLmpvaW50Lm1fY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZpeHR1cmUgYW5kIGF0dGFjaCBpdCB0byB0aGlzIGJvZHkuXG4gKiBcbiAqIElmIHRoZSBkZW5zaXR5IGlzIG5vbi16ZXJvLCB0aGlzIGZ1bmN0aW9uIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgbWFzcyBvZlxuICogdGhlIGJvZHkuXG4gKiBcbiAqIENvbnRhY3RzIGFyZSBub3QgY3JlYXRlZCB1bnRpbCB0aGUgbmV4dCB0aW1lIHN0ZXAuXG4gKiBcbiAqIFdhcm5pbmc6IFRoaXMgZnVuY3Rpb24gaXMgbG9ja2VkIGR1cmluZyBjYWxsYmFja3MuXG5cbiAqIEBwYXJhbSB7U2hhcGV8Rml4dHVyZURlZn0gc2hhcGUgU2hhcGUgb3IgZml4dHVyZSBkZWZpbml0aW9uLlxuICogQHBhcmFtIHtGaXh0dXJlRGVmfG51bWJlcn0gZml4ZGVmIEZpeHR1cmUgZGVmaW5pdGlvbiBvciBqdXN0IGRlbnNpdHkuXG4gKi9cbkJvZHkucHJvdG90eXBlLmNyZWF0ZUZpeHR1cmUgPSBmdW5jdGlvbihzaGFwZSwgZml4ZGVmKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMuaXNXb3JsZExvY2tlZCgpID09IGZhbHNlKTtcbiAgICBpZiAodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZpeHR1cmUgPSBuZXcgRml4dHVyZSh0aGlzLCBzaGFwZSwgZml4ZGVmKTtcbiAgICBpZiAodGhpcy5tX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICBmaXh0dXJlLmNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgdGhpcy5tX3hmKTtcbiAgICB9XG4gICAgZml4dHVyZS5tX25leHQgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZml4dHVyZTtcbiAgICAvLyBBZGp1c3QgbWFzcyBwcm9wZXJ0aWVzIGlmIG5lZWRlZC5cbiAgICBpZiAoZml4dHVyZS5tX2RlbnNpdHkgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzZXRNYXNzRGF0YSgpO1xuICAgIH1cbiAgICAvLyBMZXQgdGhlIHdvcmxkIGtub3cgd2UgaGF2ZSBhIG5ldyBmaXh0dXJlLiBUaGlzIHdpbGwgY2F1c2UgbmV3IGNvbnRhY3RzXG4gICAgLy8gdG8gYmUgY3JlYXRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IHRpbWUgc3RlcC5cbiAgICB0aGlzLm1fd29ybGQubV9uZXdGaXh0dXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gZml4dHVyZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSBhIGZpeHR1cmUuIFRoaXMgcmVtb3ZlcyB0aGUgZml4dHVyZSBmcm9tIHRoZSBicm9hZC1waGFzZSBhbmQgZGVzdHJveXNcbiAqIGFsbCBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaXh0dXJlLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBhZGp1c3QgdGhlXG4gKiBtYXNzIG9mIHRoZSBib2R5IGlmIHRoZSBib2R5IGlzIGR5bmFtaWMgYW5kIHRoZSBmaXh0dXJlIGhhcyBwb3NpdGl2ZSBkZW5zaXR5LlxuICogQWxsIGZpeHR1cmVzIGF0dGFjaGVkIHRvIGEgYm9keSBhcmUgaW1wbGljaXRseSBkZXN0cm95ZWQgd2hlbiB0aGUgYm9keSBpc1xuICogZGVzdHJveWVkLlxuICogXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICogXG4gKiBAcGFyYW0gZml4dHVyZSBUaGUgZml4dHVyZSB0byBiZSByZW1vdmVkLlxuICovXG5Cb2R5LnByb3RvdHlwZS5kZXN0cm95Rml4dHVyZSA9IGZ1bmN0aW9uKGZpeHR1cmUpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gZmFsc2UpO1xuICAgIGlmICh0aGlzLmlzV29ybGRMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZpeHR1cmUubV9ib2R5ID09IHRoaXMpO1xuICAgIC8vIFJlbW92ZSB0aGUgZml4dHVyZSBmcm9tIHRoaXMgYm9keSdzIHNpbmdseSBsaW5rZWQgbGlzdC5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5tX2ZpeHR1cmVMaXN0ID09PSBmaXh0dXJlKSB7XG4gICAgICAgIHRoaXMubV9maXh0dXJlTGlzdCA9IGZpeHR1cmUubV9uZXh0O1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm1fbmV4dCA9PT0gZml4dHVyZSkge1xuICAgICAgICAgICAgICAgIG5vZGUubV9uZXh0ID0gZml4dHVyZS5tX25leHQ7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubV9uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFlvdSB0cmllZCB0byByZW1vdmUgYSBzaGFwZSB0aGF0IGlzIG5vdCBhdHRhY2hlZCB0byB0aGlzIGJvZHkuXG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZvdW5kKTtcbiAgICAvLyBEZXN0cm95IGFueSBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGZpeHR1cmUuXG4gICAgdmFyIGVkZ2UgPSB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgdmFyIGMgPSBlZGdlLmNvbnRhY3Q7XG4gICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgIHZhciBmaXh0dXJlQSA9IGMuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgdmFyIGZpeHR1cmVCID0gYy5nZXRGaXh0dXJlQigpO1xuICAgICAgICBpZiAoZml4dHVyZSA9PSBmaXh0dXJlQSB8fCBmaXh0dXJlID09IGZpeHR1cmVCKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRlc3Ryb3lzIHRoZSBjb250YWN0IGFuZCByZW1vdmVzIGl0IGZyb21cbiAgICAgICAgICAgIC8vIHRoaXMgYm9keSdzIGNvbnRhY3QgbGlzdC5cbiAgICAgICAgICAgIHRoaXMubV93b3JsZC5kZXN0cm95Q29udGFjdChjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICBmaXh0dXJlLmRlc3Ryb3lQcm94aWVzKGJyb2FkUGhhc2UpO1xuICAgIH1cbiAgICBmaXh0dXJlLm1fYm9keSA9IG51bGw7XG4gICAgZml4dHVyZS5tX25leHQgPSBudWxsO1xuICAgIHRoaXMubV93b3JsZC5wdWJsaXNoKFwicmVtb3ZlLWZpeHR1cmVcIiwgZml4dHVyZSk7XG4gICAgLy8gUmVzZXQgdGhlIG1hc3MgZGF0YS5cbiAgICB0aGlzLnJlc2V0TWFzc0RhdGEoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb3JyZXNwb25kaW5nIHdvcmxkIHBvaW50IG9mIGEgbG9jYWwgcG9pbnQuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldFdvcmxkUG9pbnQgPSBmdW5jdGlvbihsb2NhbFBvaW50KSB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5tdWxWZWMyKHRoaXMubV94ZiwgbG9jYWxQb2ludCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29ycmVzcG9uZGluZyB3b3JsZCB2ZWN0b3Igb2YgYSBsb2NhbCB2ZWN0b3IuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldFdvcmxkVmVjdG9yID0gZnVuY3Rpb24obG9jYWxWZWN0b3IpIHtcbiAgICByZXR1cm4gUm90Lm11bFZlYzIodGhpcy5tX3hmLnEsIGxvY2FsVmVjdG9yKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBsb2NhbCBwb2ludCBvZiBhIHdvcmxkIHBvaW50LlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRMb2NhbFBvaW50ID0gZnVuY3Rpb24od29ybGRQb2ludCkge1xuICAgIHJldHVybiBUcmFuc2Zvcm0ubXVsVFZlYzIodGhpcy5tX3hmLCB3b3JsZFBvaW50KTtcbn07XG5cbi8qKlxuICogXG4gKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHZlY3RvciBvZiBhIHdvcmxkIHZlY3Rvci5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0TG9jYWxWZWN0b3IgPSBmdW5jdGlvbih3b3JsZFZlY3Rvcikge1xuICAgIHJldHVybiBSb3QubXVsVFZlYzIodGhpcy5tX3hmLnEsIHdvcmxkVmVjdG9yKTtcbn07XG5cblxufSx7XCIuL0ZpeHR1cmVcIjo0LFwiLi9TaGFwZVwiOjgsXCIuL1dvcmxkXCI6MTAsXCIuL2NvbW1vbi9NYXRoXCI6MTgsXCIuL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi9jb21tb24vUm90XCI6MjAsXCIuL2NvbW1vbi9Td2VlcFwiOjIxLFwiLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuL2NvbW1vbi9WZWMyXCI6MjMsXCIuL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi91dGlsL2NvbW1vblwiOjUwLFwiLi91dGlsL29wdGlvbnNcIjo1Mn1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG52YXIgREVCVUdfU09MVkVSID0gZmFsc2U7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi91dGlsL2NvbW1vblwiKTtcblxudmFyIFBvb2wgPSByZXF1aXJlKFwiLi91dGlsL1Bvb2xcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgTWF0MjIgPSByZXF1aXJlKFwiLi9jb21tb24vTWF0MjJcIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi9jb21tb24vUm90XCIpO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi9TZXR0aW5nc1wiKTtcblxudmFyIE1hbmlmb2xkID0gcmVxdWlyZShcIi4vTWFuaWZvbGRcIik7XG5cbnZhciBEaXN0YW5jZSA9IHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9EaXN0YW5jZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0O1xuXG4vKipcbiAqIEEgY29udGFjdCBlZGdlIGlzIHVzZWQgdG8gY29ubmVjdCBib2RpZXMgYW5kIGNvbnRhY3RzIHRvZ2V0aGVyIGluIGEgY29udGFjdFxuICogZ3JhcGggd2hlcmUgZWFjaCBib2R5IGlzIGEgbm9kZSBhbmQgZWFjaCBjb250YWN0IGlzIGFuIGVkZ2UuIEEgY29udGFjdCBlZGdlXG4gKiBiZWxvbmdzIHRvIGEgZG91Ymx5IGxpbmtlZCBsaXN0IG1haW50YWluZWQgaW4gZWFjaCBhdHRhY2hlZCBib2R5LiBFYWNoXG4gKiBjb250YWN0IGhhcyB0d28gY29udGFjdCBub2Rlcywgb25lIGZvciBlYWNoIGF0dGFjaGVkIGJvZHkuXG4gKiBcbiAqIEBwcm9wIHtDb250YWN0fSBjb250YWN0IFRoZSBjb250YWN0XG4gKiBAcHJvcCB7Q29udGFjdEVkZ2V9IHByZXYgVGhlIHByZXZpb3VzIGNvbnRhY3QgZWRnZSBpbiB0aGUgYm9keSdzIGNvbnRhY3QgbGlzdFxuICogQHByb3Age0NvbnRhY3RFZGdlfSBuZXh0IFRoZSBuZXh0IGNvbnRhY3QgZWRnZSBpbiB0aGUgYm9keSdzIGNvbnRhY3QgbGlzdFxuICogQHByb3Age0JvZHl9IG90aGVyIFByb3ZpZGVzIHF1aWNrIGFjY2VzcyB0byB0aGUgb3RoZXIgYm9keSBhdHRhY2hlZC5cbiAqL1xuZnVuY3Rpb24gQ29udGFjdEVkZ2UoY29udGFjdCkge1xuICAgIHRoaXMuY29udGFjdCA9IGNvbnRhY3Q7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMub3RoZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBDb250YWN0fmV2YWx1YXRlXG4gKiBcbiAqIEBwYXJhbSBtYW5pZm9sZFxuICogQHBhcmFtIHhmQVxuICogQHBhcmFtIGZpeHR1cmVBXG4gKiBAcGFyYW0gaW5kZXhBXG4gKiBAcGFyYW0geGZCXG4gKiBAcGFyYW0gZml4dHVyZUJcbiAqIEBwYXJhbSBpbmRleEJcbiAqL1xuLyoqXG4gKiBUaGUgY2xhc3MgbWFuYWdlcyBjb250YWN0IGJldHdlZW4gdHdvIHNoYXBlcy4gQSBjb250YWN0IGV4aXN0cyBmb3IgZWFjaFxuICogb3ZlcmxhcHBpbmcgQUFCQiBpbiB0aGUgYnJvYWQtcGhhc2UgKGV4Y2VwdCBpZiBmaWx0ZXJlZCkuIFRoZXJlZm9yZSBhIGNvbnRhY3RcbiAqIG9iamVjdCBtYXkgZXhpc3QgdGhhdCBoYXMgbm8gY29udGFjdCBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3QoKSB7XG4gICAgLy8gTm9kZXMgZm9yIGNvbm5lY3RpbmcgYm9kaWVzLlxuICAgIHRoaXMubV9ub2RlQSA9IG5ldyBDb250YWN0RWRnZSh0aGlzKTtcbiAgICB0aGlzLm1fbm9kZUIgPSBuZXcgQ29udGFjdEVkZ2UodGhpcyk7XG4gICAgdGhpcy5tX21hbmlmb2xkID0gbmV3IE1hbmlmb2xkKCk7XG4gICAgdGhpcy52X3BvaW50c19jYWNoZSA9IFsgbmV3IFZlbG9jaXR5Q29uc3RyYWludFBvaW50KCksIG5ldyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludCgpIF07XG4gICAgdGhpcy52X3BvaW50cyA9IFtdO1xuICAgIC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50W21heE1hbmlmb2xkUG9pbnRzXVxuICAgIHRoaXMudl9ub3JtYWwgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnZfbm9ybWFsTWFzcyA9IG5ldyBNYXQyMigpO1xuICAgIHRoaXMudl9LID0gbmV3IE1hdDIyKCk7XG4gICAgdGhpcy5wX2xvY2FsUG9pbnRzX2NhY2hlID0gWyBWZWMyLnplcm8oKSwgVmVjMi56ZXJvKCkgXTtcbiAgICB0aGlzLnBfbG9jYWxQb2ludHMgPSBbXTtcbiAgICAvLyBWZWMyW21heE1hbmlmb2xkUG9pbnRzXTtcbiAgICB0aGlzLnBfbG9jYWxOb3JtYWwgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnBfbG9jYWxQb2ludCA9IFZlYzIuemVybygpO1xuICAgIHRoaXMucF9sb2NhbENlbnRlckEgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnBfbG9jYWxDZW50ZXJCID0gVmVjMi56ZXJvKCk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIENvbnRhY3QuXG4gKlxuICogQHBhcmFtIHtGaXh0dXJlfSBmQVxuICogQHBhcmFtIHtpbnR9IGluZGV4QVxuICogQHBhcmFtIHtGaXh0dXJlfSBmQlxuICogQHBhcmFtIHtpbnR9IGluZGV4QlxuICogQHBhcmFtIHtDb250YWN0fmV2YWx1YXRlfSBldmFsdWF0ZUZjblxuICovXG5Db250YWN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZkEsIGluZGV4QSwgZkIsIGluZGV4QiwgZXZhbHVhdGVGY24pIHtcbiAgICB0aGlzLm1fZml4dHVyZUEgPSBmQTtcbiAgICB0aGlzLm1fZml4dHVyZUIgPSBmQjtcbiAgICB0aGlzLm1faW5kZXhBID0gaW5kZXhBO1xuICAgIHRoaXMubV9pbmRleEIgPSBpbmRleEI7XG4gICAgdGhpcy5tX2V2YWx1YXRlRmNuID0gZXZhbHVhdGVGY247XG4gICAgdGhpcy5tX21hbmlmb2xkLmluaXQoKTtcbiAgICB0aGlzLm1fcHJldiA9IG51bGw7XG4gICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgIHRoaXMubV90b2kgPSAxO1xuICAgIHRoaXMubV90b2lDb3VudCA9IDA7XG4gICAgLy8gVGhpcyBjb250YWN0IGhhcyBhIHZhbGlkIFRPSSBpbiBtX3RvaVxuICAgIHRoaXMubV90b2lGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5tX2ZyaWN0aW9uID0gbWl4RnJpY3Rpb24odGhpcy5tX2ZpeHR1cmVBLm1fZnJpY3Rpb24sIHRoaXMubV9maXh0dXJlQi5tX2ZyaWN0aW9uKTtcbiAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBtaXhSZXN0aXR1dGlvbih0aGlzLm1fZml4dHVyZUEubV9yZXN0aXR1dGlvbiwgdGhpcy5tX2ZpeHR1cmVCLm1fcmVzdGl0dXRpb24pO1xuICAgIHRoaXMubV90YW5nZW50U3BlZWQgPSAwO1xuICAgIC8vIFRoaXMgY29udGFjdCBjYW4gYmUgZGlzYWJsZWQgKGJ5IHVzZXIpXG4gICAgdGhpcy5tX2VuYWJsZWRGbGFnID0gdHJ1ZTtcbiAgICAvLyBVc2VkIHdoZW4gY3Jhd2xpbmcgY29udGFjdCBncmFwaCB3aGVuIGZvcm1pbmcgaXNsYW5kcy5cbiAgICB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgIC8vIFNldCB3aGVuIHRoZSBzaGFwZXMgYXJlIHRvdWNoaW5nLlxuICAgIHRoaXMubV90b3VjaGluZ0ZsYWcgPSBmYWxzZTtcbiAgICAvLyBUaGlzIGNvbnRhY3QgbmVlZHMgZmlsdGVyaW5nIGJlY2F1c2UgYSBmaXh0dXJlIGZpbHRlciB3YXMgY2hhbmdlZC5cbiAgICB0aGlzLm1fZmlsdGVyRmxhZyA9IGZhbHNlO1xuICAgIC8vIFRoaXMgYnVsbGV0IGNvbnRhY3QgaGFkIGEgVE9JIGV2ZW50XG4gICAgdGhpcy5tX2J1bGxldEhpdEZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLnZfcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52X25vcm1hbC5zZXRaZXJvKCk7XG4gICAgdGhpcy52X25vcm1hbE1hc3Muc2V0WmVybygpO1xuICAgIHRoaXMudl9LLnNldFplcm8oKTtcbiAgICB0aGlzLnZfcG9pbnRDb3VudCA9IG51bGw7XG4gICAgdGhpcy52X3RhbmdlbnRTcGVlZCA9IG51bGw7XG4gICAgdGhpcy52X2ZyaWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnZfcmVzdGl0dXRpb24gPSBudWxsO1xuICAgIHRoaXMudl9pbnZNYXNzQSA9IG51bGw7XG4gICAgdGhpcy52X2ludk1hc3NCID0gbnVsbDtcbiAgICB0aGlzLnZfaW52SUEgPSBudWxsO1xuICAgIHRoaXMudl9pbnZJQiA9IG51bGw7XG4gICAgdGhpcy5wX2xvY2FsUG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wX2xvY2FsTm9ybWFsLnNldFplcm8oKTtcbiAgICB0aGlzLnBfbG9jYWxQb2ludC5zZXRaZXJvKCk7XG4gICAgdGhpcy5wX2xvY2FsQ2VudGVyQS5zZXRaZXJvKCk7XG4gICAgdGhpcy5wX2xvY2FsQ2VudGVyQi5zZXRaZXJvKCk7XG4gICAgdGhpcy5wX3R5cGUgPSBudWxsO1xuICAgIC8vIE1hbmlmb2xkLlR5cGVcbiAgICB0aGlzLnBfcmFkaXVzQSA9IG51bGw7XG4gICAgdGhpcy5wX3JhZGl1c0IgPSBudWxsO1xuICAgIHRoaXMucF9wb2ludENvdW50ID0gbnVsbDtcbiAgICB0aGlzLnBfaW52TWFzc0EgPSBudWxsO1xuICAgIHRoaXMucF9pbnZNYXNzQiA9IG51bGw7XG4gICAgdGhpcy5wX2ludklBID0gbnVsbDtcbiAgICB0aGlzLnBfaW52SUIgPSBudWxsO1xufTtcblxuQ29udGFjdC5wcm90b3R5cGUuaW5pdENvbnN0cmFpbnQgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgIHZhciBmaXh0dXJlQiA9IHRoaXMubV9maXh0dXJlQjtcbiAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEuZ2V0U2hhcGUoKTtcbiAgICB2YXIgc2hhcGVCID0gZml4dHVyZUIuZ2V0U2hhcGUoKTtcbiAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgIHZhciBtYW5pZm9sZCA9IHRoaXMubV9tYW5pZm9sZDtcbiAgICB2YXIgcG9pbnRDb3VudCA9IG1hbmlmb2xkLnBvaW50Q291bnQ7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHBvaW50Q291bnQgPiAwKTtcbiAgICB0aGlzLnZfaW52TWFzc0EgPSBib2R5QS5tX2ludk1hc3M7XG4gICAgdGhpcy52X2ludk1hc3NCID0gYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMudl9pbnZJQSA9IGJvZHlBLm1faW52STtcbiAgICB0aGlzLnZfaW52SUIgPSBib2R5Qi5tX2ludkk7XG4gICAgdGhpcy52X2ZyaWN0aW9uID0gdGhpcy5tX2ZyaWN0aW9uO1xuICAgIHRoaXMudl9yZXN0aXR1dGlvbiA9IHRoaXMubV9yZXN0aXR1dGlvbjtcbiAgICB0aGlzLnZfdGFuZ2VudFNwZWVkID0gdGhpcy5tX3RhbmdlbnRTcGVlZDtcbiAgICB0aGlzLnZfcG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG4gICAgdGhpcy52X0suc2V0WmVybygpO1xuICAgIHRoaXMudl9ub3JtYWxNYXNzLnNldFplcm8oKTtcbiAgICB0aGlzLnBfaW52TWFzc0EgPSBib2R5QS5tX2ludk1hc3M7XG4gICAgdGhpcy5wX2ludk1hc3NCID0gYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMucF9pbnZJQSA9IGJvZHlBLm1faW52STtcbiAgICB0aGlzLnBfaW52SUIgPSBib2R5Qi5tX2ludkk7XG4gICAgdGhpcy5wX2xvY2FsQ2VudGVyQS5zZXRWZWMyKGJvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXIpO1xuICAgIHRoaXMucF9sb2NhbENlbnRlckIuc2V0VmVjMihib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcbiAgICB0aGlzLnBfcmFkaXVzQSA9IHNoYXBlQS5tX3JhZGl1cztcbiAgICB0aGlzLnBfcmFkaXVzQiA9IHNoYXBlQi5tX3JhZGl1cztcbiAgICB0aGlzLnBfdHlwZSA9IG1hbmlmb2xkLnR5cGU7XG4gICAgdGhpcy5wX2xvY2FsTm9ybWFsLnNldFZlYzIobWFuaWZvbGQubG9jYWxOb3JtYWwpO1xuICAgIHRoaXMucF9sb2NhbFBvaW50LnNldFZlYzIobWFuaWZvbGQubG9jYWxQb2ludCk7XG4gICAgdGhpcy5wX3BvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgIHZhciBjcCA9IG1hbmlmb2xkLnBvaW50c1tqXTtcbiAgICAgICAgLy8gTWFuaWZvbGRQb2ludFxuICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tqXSA9IHRoaXMudl9wb2ludHNfY2FjaGVbal0uaW5pdCgpO1xuICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgIHZjcC5ub3JtYWxJbXB1bHNlID0gc3RlcC5kdFJhdGlvICogY3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIHZjcC50YW5nZW50SW1wdWxzZSA9IHN0ZXAuZHRSYXRpbyAqIGNwLnRhbmdlbnRJbXB1bHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmNwLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgdmNwLnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2Y3AuckEuc2V0WmVybygpO1xuICAgICAgICB2Y3AuckIuc2V0WmVybygpO1xuICAgICAgICB2Y3Aubm9ybWFsTWFzcyA9IDA7XG4gICAgICAgIHZjcC50YW5nZW50TWFzcyA9IDA7XG4gICAgICAgIHZjcC52ZWxvY2l0eUJpYXMgPSAwO1xuICAgICAgICB0aGlzLnBfbG9jYWxQb2ludHNbal0gPSB0aGlzLnBfbG9jYWxQb2ludHNfY2FjaGVbal0uc2V0VmVjMihjcC5sb2NhbFBvaW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29udGFjdCBtYW5pZm9sZC4gRG8gbm90IG1vZGlmeSB0aGUgbWFuaWZvbGQgdW5sZXNzIHlvdSB1bmRlcnN0YW5kXG4gKiB0aGUgaW50ZXJuYWxzIG9mIHRoZSBsaWJyYXJ5LlxuICovXG5Db250YWN0LnByb3RvdHlwZS5nZXRNYW5pZm9sZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbWFuaWZvbGQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgd29ybGQgbWFuaWZvbGQuXG4gKiBcbiAqIEBwYXJhbSB7V29ybGRNYW5pZm9sZH0gW3dvcmxkTWFuaWZvbGRdXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLmdldFdvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbih3b3JsZE1hbmlmb2xkKSB7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLmdldEJvZHkoKTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLm1fZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgIHZhciBzaGFwZUEgPSB0aGlzLm1fZml4dHVyZUEuZ2V0U2hhcGUoKTtcbiAgICB2YXIgc2hhcGVCID0gdGhpcy5tX2ZpeHR1cmVCLmdldFNoYXBlKCk7XG4gICAgdmFyIG1hbmlmb2xkID0gdGhpcy5tX21hbmlmb2xkLmdldFdvcmxkTWFuaWZvbGQod29ybGRNYW5pZm9sZCwgYm9keUEuZ2V0VHJhbnNmb3JtKCksIHNoYXBlQS5tX3JhZGl1cywgYm9keUIuZ2V0VHJhbnNmb3JtKCksIHNoYXBlQi5tX3JhZGl1cyk7XG4gICAgcmV0dXJuIG1hbmlmb2xkO1xufTtcblxuLyoqXG4gKiBFbmFibGUvZGlzYWJsZSB0aGlzIGNvbnRhY3QuIFRoaXMgY2FuIGJlIHVzZWQgaW5zaWRlIHRoZSBwcmUtc29sdmUgY29udGFjdFxuICogbGlzdGVuZXIuIFRoZSBjb250YWN0IGlzIG9ubHkgZGlzYWJsZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgc3RlcCAob3Igc3ViLXN0ZXBcbiAqIGluIGNvbnRpbnVvdXMgY29sbGlzaW9ucykuXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgdGhpcy5tX2VuYWJsZWRGbGFnID0gISFmbGFnO1xufTtcblxuLyoqXG4gKiBIYXMgdGhpcyBjb250YWN0IGJlZW4gZGlzYWJsZWQ/XG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZW5hYmxlZEZsYWc7XG59O1xuXG4vKipcbiAqIElzIHRoaXMgY29udGFjdCB0b3VjaGluZz9cbiAqL1xuQ29udGFjdC5wcm90b3R5cGUuaXNUb3VjaGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdG91Y2hpbmdGbGFnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgY29udGFjdCBpbiB0aGUgd29ybGQncyBjb250YWN0IGxpc3QuXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX25leHQ7XG59O1xuXG4vKipcbiAqIEdldCBmaXh0dXJlIEEgaW4gdGhpcyBjb250YWN0LlxuICovXG5Db250YWN0LnByb3RvdHlwZS5nZXRGaXh0dXJlQSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZml4dHVyZUE7XG59O1xuXG4vKipcbiAqIEdldCBmaXh0dXJlIEIgaW4gdGhpcyBjb250YWN0LlxuICovXG5Db250YWN0LnByb3RvdHlwZS5nZXRGaXh0dXJlQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZml4dHVyZUI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY2hpbGQgcHJpbWl0aXZlIGluZGV4IGZvciBmaXh0dXJlIEEuXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLmdldENoaWxkSW5kZXhBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9pbmRleEE7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY2hpbGQgcHJpbWl0aXZlIGluZGV4IGZvciBmaXh0dXJlIEIuXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLmdldENoaWxkSW5kZXhCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9pbmRleEI7XG59O1xuXG4vKipcbiAqIEZsYWcgdGhpcyBjb250YWN0IGZvciBmaWx0ZXJpbmcuIEZpbHRlcmluZyB3aWxsIG9jY3VyIHRoZSBuZXh0IHRpbWUgc3RlcC5cbiAqL1xuQ29udGFjdC5wcm90b3R5cGUuZmxhZ0ZvckZpbHRlcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubV9maWx0ZXJGbGFnID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgZnJpY3Rpb24gbWl4dHVyZS4gWW91IGNhbiBjYWxsIHRoaXMgaW5cbiAqIENvbnRhY3RMaXN0ZW5lci5wcmVTb2x2ZS4gVGhpcyB2YWx1ZSBwZXJzaXN0cyB1bnRpbCBzZXQgb3IgcmVzZXQuXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLnNldEZyaWN0aW9uID0gZnVuY3Rpb24oZnJpY3Rpb24pIHtcbiAgICB0aGlzLm1fZnJpY3Rpb24gPSBmcmljdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmcmljdGlvbi5cbiAqL1xuQ29udGFjdC5wcm90b3R5cGUuZ2V0RnJpY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2ZyaWN0aW9uO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgZnJpY3Rpb24gbWl4dHVyZSB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqL1xuQ29udGFjdC5wcm90b3R5cGUucmVzZXRGcmljdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubV9mcmljdGlvbiA9IG1peEZyaWN0aW9uKHRoaXMubV9maXh0dXJlQS5tX2ZyaWN0aW9uLCB0aGlzLm1fZml4dHVyZUIubV9mcmljdGlvbik7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHJlc3RpdHV0aW9uIG1peHR1cmUuIFlvdSBjYW4gY2FsbCB0aGlzIGluXG4gKiBDb250YWN0TGlzdGVuZXIucHJlU29sdmUuIFRoZSB2YWx1ZSBwZXJzaXN0cyB1bnRpbCB5b3Ugc2V0IG9yIHJlc2V0LlxuICovXG5Db250YWN0LnByb3RvdHlwZS5zZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uKHJlc3RpdHV0aW9uKSB7XG4gICAgdGhpcy5tX3Jlc3RpdHV0aW9uID0gcmVzdGl0dXRpb247XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcmVzdGl0dXRpb24uXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLmdldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9yZXN0aXR1dGlvbjtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHJlc3RpdHV0aW9uIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICovXG5Db250YWN0LnByb3RvdHlwZS5yZXNldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tX3Jlc3RpdHV0aW9uID0gbWl4UmVzdGl0dXRpb24odGhpcy5tX2ZpeHR1cmVBLm1fcmVzdGl0dXRpb24sIHRoaXMubV9maXh0dXJlQi5tX3Jlc3RpdHV0aW9uKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNpcmVkIHRhbmdlbnQgc3BlZWQgZm9yIGEgY29udmV5b3IgYmVsdCBiZWhhdmlvci4gSW4gbWV0ZXJzIHBlclxuICogc2Vjb25kLlxuICovXG5Db250YWN0LnByb3RvdHlwZS5zZXRUYW5nZW50U3BlZWQgPSBmdW5jdGlvbihzcGVlZCkge1xuICAgIHRoaXMubV90YW5nZW50U3BlZWQgPSBzcGVlZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkZXNpcmVkIHRhbmdlbnQgc3BlZWQuIEluIG1ldGVycyBwZXIgc2Vjb25kLlxuICovXG5Db250YWN0LnByb3RvdHlwZS5nZXRUYW5nZW50U3BlZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3RhbmdlbnRTcGVlZDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGJ5IFVwZGF0ZSBtZXRob2QsIGFuZCBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzLlxuICovXG5Db250YWN0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKG1hbmlmb2xkLCB4ZkEsIHhmQikge1xuICAgIHRoaXMubV9ldmFsdWF0ZUZjbihtYW5pZm9sZCwgeGZBLCB0aGlzLm1fZml4dHVyZUEsIHRoaXMubV9pbmRleEEsIHhmQiwgdGhpcy5tX2ZpeHR1cmVCLCB0aGlzLm1faW5kZXhCKTtcbn07XG5cbnZhciBjdXBfbWFuaWZvbGQgPSBuZXcgTWFuaWZvbGQoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBjb250YWN0IG1hbmlmb2xkIGFuZCB0b3VjaGluZyBzdGF0dXMuXG4gKiBcbiAqIE5vdGU6IGRvIG5vdCBhc3N1bWUgdGhlIGZpeHR1cmUgQUFCQnMgYXJlIG92ZXJsYXBwaW5nIG9yIGFyZSB2YWxpZC5cbiAqIFxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIuYmVnaW5Db250YWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lci5lbmRDb250YWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lci5wcmVTb2x2ZVxuICovXG5Db250YWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIC8vIFJlLWVuYWJsZSB0aGlzIGNvbnRhY3QuXG4gICAgdGhpcy5tX2VuYWJsZWRGbGFnID0gdHJ1ZTtcbiAgICB2YXIgdG91Y2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FzVG91Y2hpbmcgPSB0aGlzLm1fdG91Y2hpbmdGbGFnO1xuICAgIHZhciBzZW5zb3JBID0gdGhpcy5tX2ZpeHR1cmVBLmlzU2Vuc29yKCk7XG4gICAgdmFyIHNlbnNvckIgPSB0aGlzLm1fZml4dHVyZUIuaXNTZW5zb3IoKTtcbiAgICB2YXIgc2Vuc29yID0gc2Vuc29yQSB8fCBzZW5zb3JCO1xuICAgIHZhciBib2R5QSA9IHRoaXMubV9maXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgdmFyIGJvZHlCID0gdGhpcy5tX2ZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICB2YXIgeGZBID0gYm9keUEuZ2V0VHJhbnNmb3JtKCk7XG4gICAgdmFyIHhmQiA9IGJvZHlCLmdldFRyYW5zZm9ybSgpO1xuICAgIC8vIElzIHRoaXMgY29udGFjdCBhIHNlbnNvcj9cbiAgICBpZiAoc2Vuc29yKSB7XG4gICAgICAgIHZhciBzaGFwZUEgPSB0aGlzLm1fZml4dHVyZUEuZ2V0U2hhcGUoKTtcbiAgICAgICAgdmFyIHNoYXBlQiA9IHRoaXMubV9maXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgICAgICB0b3VjaGluZyA9IERpc3RhbmNlLnRlc3RPdmVybGFwKHNoYXBlQSwgdGhpcy5tX2luZGV4QSwgc2hhcGVCLCB0aGlzLm1faW5kZXhCLCB4ZkEsIHhmQik7XG4gICAgICAgIC8vIFNlbnNvcnMgZG9uJ3QgZ2VuZXJhdGUgbWFuaWZvbGRzLlxuICAgICAgICB0aGlzLm1fbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9sZE1hbmlmb2xkID0gdGhpcy5tX21hbmlmb2xkO1xuICAgICAgICB0aGlzLm1fbWFuaWZvbGQgPSBjdXBfbWFuaWZvbGQuaW5pdCgpO1xuICAgICAgICBjdXBfbWFuaWZvbGQgPSBvbGRNYW5pZm9sZDtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZSh0aGlzLm1fbWFuaWZvbGQsIHhmQSwgeGZCKTtcbiAgICAgICAgdG91Y2hpbmcgPSB0aGlzLm1fbWFuaWZvbGQucG9pbnRDb3VudCA+IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX21hbmlmb2xkLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5tcCA9IHRoaXMubV9tYW5pZm9sZC5wb2ludHNbaV07XG4gICAgICAgICAgICBubXAubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICBubXAudGFuZ2VudEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgLy8gTWF0Y2ggb2xkIGNvbnRhY3QgaWRzIHRvIG5ldyBjb250YWN0IGlkcyBhbmQgY29weSB0aGVcbiAgICAgICAgICAgIC8vIHN0b3JlZCBpbXB1bHNlcyB0byB3YXJtIHN0YXJ0IHRoZSBzb2x2ZXIuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZE1hbmlmb2xkLnBvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBvbXAgPSBvbGRNYW5pZm9sZC5wb2ludHNbal07XG4gICAgICAgICAgICAgICAgaWYgKG9tcC5pZC5rZXkgPT0gbm1wLmlkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb250YWN0SUQua2V5XG4gICAgICAgICAgICAgICAgICAgIG5tcC5ub3JtYWxJbXB1bHNlID0gb21wLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIG5tcC50YW5nZW50SW1wdWxzZSA9IG9tcC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaGluZyAhPT0gd2FzVG91Y2hpbmcpIHtcbiAgICAgICAgICAgIGJvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tX3RvdWNoaW5nRmxhZyA9IHRvdWNoaW5nO1xuICAgIGlmICghd2FzVG91Y2hpbmcgJiYgdG91Y2hpbmcgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIuYmVnaW5Db250YWN0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAod2FzVG91Y2hpbmcgJiYgIXRvdWNoaW5nICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyLmVuZENvbnRhY3QodGhpcyk7XG4gICAgfVxuICAgIGlmICghc2Vuc29yICYmIHRvdWNoaW5nICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyLnByZVNvbHZlKHRoaXMsIG9sZE1hbmlmb2xkKTtcbiAgICB9XG59O1xuXG5Db250YWN0LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludCA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICByZXR1cm4gdGhpcy5fc29sdmVQb3NpdGlvbkNvbnN0cmFpbnQoc3RlcCwgZmFsc2UpO1xufTtcblxuQ29udGFjdC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRUT0kgPSBmdW5jdGlvbihzdGVwLCB0b2lBLCB0b2lCKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvbHZlUG9zaXRpb25Db25zdHJhaW50KHN0ZXAsIHRydWUsIHRvaUEsIHRvaUIpO1xufTtcblxudmFyIHNwY19sb2NhbENlbnRlckEgPSBWZWMyLnplcm8oKTtcblxudmFyIHNwY19sb2NhbENlbnRlckIgPSBWZWMyLnplcm8oKTtcblxudmFyIHNwY19jQSA9IFZlYzIuemVybygpO1xuXG52YXIgc3BjX2NCID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzcGNfeGZBID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG5cbnZhciBzcGNfeGZCID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG5cbnZhciBzcGNfdDEgPSBWZWMyLnplcm8oKTtcblxudmFyIHNwY190MiA9IFZlYzIuemVybygpO1xuXG52YXIgc3BjX25vcm1hbCA9IFZlYzIuemVybygpO1xuXG52YXIgc3BjX3BvaW50ID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzcGNfcG9pbnRBID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzcGNfcG9pbnRCID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzcGNfcGxhbmVQb2ludCA9IFZlYzIuemVybygpO1xuXG52YXIgc3BjX2NsaXBQb2ludCA9IFZlYzIuemVybygpO1xuXG52YXIgc3BjX3JBID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzcGNfckIgPSBWZWMyLnplcm8oKTtcblxudmFyIHNwY19QID0gVmVjMi56ZXJvKCk7XG5cbkNvbnRhY3QucHJvdG90eXBlLl9zb2x2ZVBvc2l0aW9uQ29uc3RyYWludCA9IGZ1bmN0aW9uKHN0ZXAsIHRvaSwgdG9pQSwgdG9pQikge1xuICAgIHZhciBmaXh0dXJlQSA9IHRoaXMubV9maXh0dXJlQTtcbiAgICB2YXIgZml4dHVyZUIgPSB0aGlzLm1fZml4dHVyZUI7XG4gICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICB2YXIgdmVsb2NpdHlBID0gYm9keUEuY192ZWxvY2l0eTtcbiAgICB2YXIgdmVsb2NpdHlCID0gYm9keUIuY192ZWxvY2l0eTtcbiAgICB2YXIgcG9zaXRpb25BID0gYm9keUEuY19wb3NpdGlvbjtcbiAgICB2YXIgcG9zaXRpb25CID0gYm9keUIuY19wb3NpdGlvbjtcbiAgICB2YXIgbG9jYWxDZW50ZXJBID0gc3BjX2xvY2FsQ2VudGVyQS5zZXRWZWMyKHRoaXMucF9sb2NhbENlbnRlckEpO1xuICAgIHZhciBsb2NhbENlbnRlckIgPSBzcGNfbG9jYWxDZW50ZXJCLnNldFZlYzIodGhpcy5wX2xvY2FsQ2VudGVyQik7XG4gICAgdmFyIG1BID0gMDtcbiAgICB2YXIgaUEgPSAwO1xuICAgIGlmICghdG9pIHx8IChib2R5QSA9PT0gdG9pQSB8fCBib2R5QSA9PT0gdG9pQikpIHtcbiAgICAgICAgbUEgPSB0aGlzLnBfaW52TWFzc0E7XG4gICAgICAgIGlBID0gdGhpcy5wX2ludklBO1xuICAgIH1cbiAgICB2YXIgbUIgPSAwO1xuICAgIHZhciBpQiA9IDA7XG4gICAgaWYgKCF0b2kgfHwgKGJvZHlCID09PSB0b2lBIHx8IGJvZHlCID09PSB0b2lCKSkge1xuICAgICAgICBtQiA9IHRoaXMucF9pbnZNYXNzQjtcbiAgICAgICAgaUIgPSB0aGlzLnBfaW52SUI7XG4gICAgfVxuICAgIHZhciBjQSA9IHNwY19jQS5zZXRWZWMyKHBvc2l0aW9uQS5jKTtcbiAgICB2YXIgYUEgPSBwb3NpdGlvbkEuYTtcbiAgICB2YXIgY0IgPSBzcGNfY0Iuc2V0VmVjMihwb3NpdGlvbkIuYyk7XG4gICAgdmFyIGFCID0gcG9zaXRpb25CLmE7XG4gICAgdmFyIG1pblNlcGFyYXRpb24gPSAwO1xuICAgIC8vIFNvbHZlIG5vcm1hbCBjb25zdHJhaW50c1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5wX3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICB2YXIgeGZBID0gc3BjX3hmQS5zZXRJZGVudGl0eSgpO1xuICAgICAgICB2YXIgeGZCID0gc3BjX3hmQi5zZXRJZGVudGl0eSgpO1xuICAgICAgICB4ZkEucS5zZXQoYUEpO1xuICAgICAgICB4ZkIucS5zZXQoYUIpO1xuICAgICAgICB4ZkEucC5zZXRWZWMyKFZlYzIuc3ViXyhjQSwgUm90Lm11bFZlYzJfKHhmQS5xLCBsb2NhbENlbnRlckEsIHNwY190MSksIHNwY190MikpO1xuICAgICAgICB4ZkIucC5zZXRWZWMyKFZlYzIuc3ViXyhjQiwgUm90Lm11bFZlYzJfKHhmQi5xLCBsb2NhbENlbnRlckIsIHNwY190MSksIHNwY190MikpO1xuICAgICAgICAvLyBQb3NpdGlvblNvbHZlck1hbmlmb2xkXG4gICAgICAgIHZhciBub3JtYWwsIHBvaW50LCBzZXBhcmF0aW9uO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucF90eXBlKSB7XG4gICAgICAgICAgY2FzZSBNYW5pZm9sZC5lX2NpcmNsZXM6XG4gICAgICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzJfKHhmQSwgdGhpcy5wX2xvY2FsUG9pbnQsIHNwY19wb2ludEEpO1xuICAgICAgICAgICAgdmFyIHBvaW50QiA9IFRyYW5zZm9ybS5tdWxWZWMyXyh4ZkIsIHRoaXMucF9sb2NhbFBvaW50c1swXSwgc3BjX3BvaW50Qik7XG4gICAgICAgICAgICBub3JtYWwgPSBWZWMyLnN1Yl8ocG9pbnRCLCBwb2ludEEsIHNwY19ub3JtYWwpO1xuICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgcG9pbnQgPSBWZWMyLmNvbWJpbmVfKC41LCBwb2ludEEsIC41LCBwb2ludEIsIHNwY19wb2ludCk7XG4gICAgICAgICAgICBzZXBhcmF0aW9uID0gVmVjMi5kb3QoVmVjMi5zdWIocG9pbnRCLCBwb2ludEEpLCBub3JtYWwpIC0gdGhpcy5wX3JhZGl1c0EgLSB0aGlzLnBfcmFkaXVzQjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBNYW5pZm9sZC5lX2ZhY2VBOlxuICAgICAgICAgICAgbm9ybWFsID0gUm90Lm11bFZlYzJfKHhmQS5xLCB0aGlzLnBfbG9jYWxOb3JtYWwsIHNwY19ub3JtYWwpO1xuICAgICAgICAgICAgdmFyIHBsYW5lUG9pbnQgPSBUcmFuc2Zvcm0ubXVsVmVjMl8oeGZBLCB0aGlzLnBfbG9jYWxQb2ludCwgc3BjX3BsYW5lUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGNsaXBQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyXyh4ZkIsIHRoaXMucF9sb2NhbFBvaW50c1tqXSwgc3BjX2NsaXBQb2ludCk7XG4gICAgICAgICAgICBzZXBhcmF0aW9uID0gVmVjMi5kb3QoVmVjMi5zdWJfKGNsaXBQb2ludCwgcGxhbmVQb2ludCwgc3BjX3QxKSwgbm9ybWFsKSAtIHRoaXMucF9yYWRpdXNBIC0gdGhpcy5wX3JhZGl1c0I7XG4gICAgICAgICAgICBwb2ludCA9IHNwY19wb2ludC5zZXRWZWMyKGNsaXBQb2ludCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgTWFuaWZvbGQuZV9mYWNlQjpcbiAgICAgICAgICAgIG5vcm1hbCA9IFJvdC5tdWxWZWMyXyh4ZkIucSwgdGhpcy5wX2xvY2FsTm9ybWFsLCBzcGNfbm9ybWFsKTtcbiAgICAgICAgICAgIHZhciBwbGFuZVBvaW50ID0gVHJhbnNmb3JtLm11bFZlYzJfKHhmQiwgdGhpcy5wX2xvY2FsUG9pbnQsIHNwY19wbGFuZVBvaW50KTtcbiAgICAgICAgICAgIHZhciBjbGlwUG9pbnQgPSBUcmFuc2Zvcm0ubXVsVmVjMl8oeGZBLCB0aGlzLnBfbG9jYWxQb2ludHNbal0sIHNwY19jbGlwUG9pbnQpO1xuICAgICAgICAgICAgc2VwYXJhdGlvbiA9IFZlYzIuZG90KFZlYzIuc3ViXyhjbGlwUG9pbnQsIHBsYW5lUG9pbnQsIHNwY190MSksIG5vcm1hbCkgLSB0aGlzLnBfcmFkaXVzQSAtIHRoaXMucF9yYWRpdXNCO1xuICAgICAgICAgICAgcG9pbnQgPSBzcGNfcG9pbnQuc2V0VmVjMihjbGlwUG9pbnQpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIG5vcm1hbCBwb2ludHMgZnJvbSBBIHRvIEJcbiAgICAgICAgICAgIG5vcm1hbC5tdWwoLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJBID0gVmVjMi5zdWJfKHBvaW50LCBjQSwgc3BjX3JBKTtcbiAgICAgICAgdmFyIHJCID0gVmVjMi5zdWJfKHBvaW50LCBjQiwgc3BjX3JCKTtcbiAgICAgICAgLy8gVHJhY2sgbWF4IGNvbnN0cmFpbnQgZXJyb3IuXG4gICAgICAgIG1pblNlcGFyYXRpb24gPSBNYXRoLm1pbihtaW5TZXBhcmF0aW9uLCBzZXBhcmF0aW9uKTtcbiAgICAgICAgdmFyIGJhdW1nYXJ0ZSA9IHRvaSA/IFNldHRpbmdzLnRvaUJhdWdhcnRlIDogU2V0dGluZ3MuYmF1bWdhcnRlO1xuICAgICAgICB2YXIgbGluZWFyU2xvcCA9IFNldHRpbmdzLmxpbmVhclNsb3A7XG4gICAgICAgIHZhciBtYXhMaW5lYXJDb3JyZWN0aW9uID0gU2V0dGluZ3MubWF4TGluZWFyQ29ycmVjdGlvbjtcbiAgICAgICAgLy8gUHJldmVudCBsYXJnZSBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc2xvcC5cbiAgICAgICAgdmFyIEMgPSBNYXRoLmNsYW1wKGJhdW1nYXJ0ZSAqIChzZXBhcmF0aW9uICsgbGluZWFyU2xvcCksIC1tYXhMaW5lYXJDb3JyZWN0aW9uLCAwKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgIHZhciBybkEgPSBWZWMyLmNyb3NzVmVjMlZlYzIockEsIG5vcm1hbCk7XG4gICAgICAgIHZhciBybkIgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIG5vcm1hbCk7XG4gICAgICAgIHZhciBLID0gbUEgKyBtQiArIGlBICogcm5BICogcm5BICsgaUIgKiBybkIgKiBybkI7XG4gICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIGltcHVsc2VcbiAgICAgICAgdmFyIGltcHVsc2UgPSBLID4gMCA/IC1DIC8gSyA6IDA7XG4gICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyXyhpbXB1bHNlLCBub3JtYWwsIHNwY19QKTtcbiAgICAgICAgY0Euc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgYUEgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIockEsIFApO1xuICAgICAgICBjQi5hZGRNdWwobUIsIFApO1xuICAgICAgICBhQiArPSBpQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgUCk7XG4gICAgfVxuICAgIHBvc2l0aW9uQS5jLnNldFZlYzIoY0EpO1xuICAgIHBvc2l0aW9uQS5hID0gYUE7XG4gICAgcG9zaXRpb25CLmMuc2V0VmVjMihjQik7XG4gICAgcG9zaXRpb25CLmEgPSBhQjtcbiAgICByZXR1cm4gbWluU2VwYXJhdGlvbjtcbn07XG5cbmZ1bmN0aW9uIFZlbG9jaXR5Q29uc3RyYWludFBvaW50KCkge1xuICAgIHRoaXMuckEgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnJCID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICB0aGlzLm5vcm1hbE1hc3MgPSAwO1xuICAgIHRoaXMudGFuZ2VudE1hc3MgPSAwO1xuICAgIHRoaXMudmVsb2NpdHlCaWFzID0gMDtcbn1cblxuVmVsb2NpdHlDb25zdHJhaW50UG9pbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJBLnNldFplcm8oKTtcbiAgICB0aGlzLnJCLnNldFplcm8oKTtcbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSAwO1xuICAgIHRoaXMubm9ybWFsTWFzcyA9IDA7XG4gICAgdGhpcy50YW5nZW50TWFzcyA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxudmFyIGl2Y19sb2NhbENlbnRlckEgPSBWZWMyLnplcm8oKTtcblxudmFyIGl2Y19sb2NhbENlbnRlckIgPSBWZWMyLnplcm8oKTtcblxudmFyIGl2Y19ub3JtYWwgPSBWZWMyLnplcm8oKTtcblxudmFyIGl2Y19jQSA9IFZlYzIuemVybygpO1xuXG52YXIgaXZjX2NCID0gVmVjMi56ZXJvKCk7XG5cbnZhciBpdmNfdkEgPSBWZWMyLnplcm8oKTtcblxudmFyIGl2Y192QiA9IFZlYzIuemVybygpO1xuXG52YXIgaXZjX3QxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBpdmNfdDIgPSBWZWMyLnplcm8oKTtcblxudmFyIGl2Y194ZkEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcblxudmFyIGl2Y194ZkIgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcblxuQ29udGFjdC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludCA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgZml4dHVyZUEgPSB0aGlzLm1fZml4dHVyZUE7XG4gICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLmdldEJvZHkoKTtcbiAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5nZXRCb2R5KCk7XG4gICAgdmFyIHZlbG9jaXR5QSA9IGJvZHlBLmNfdmVsb2NpdHk7XG4gICAgdmFyIHZlbG9jaXR5QiA9IGJvZHlCLmNfdmVsb2NpdHk7XG4gICAgdmFyIHBvc2l0aW9uQSA9IGJvZHlBLmNfcG9zaXRpb247XG4gICAgdmFyIHBvc2l0aW9uQiA9IGJvZHlCLmNfcG9zaXRpb247XG4gICAgdmFyIHJhZGl1c0EgPSB0aGlzLnBfcmFkaXVzQTtcbiAgICB2YXIgcmFkaXVzQiA9IHRoaXMucF9yYWRpdXNCO1xuICAgIHZhciBtYW5pZm9sZCA9IHRoaXMubV9tYW5pZm9sZDtcbiAgICB2YXIgbUEgPSB0aGlzLnZfaW52TWFzc0E7XG4gICAgdmFyIG1CID0gdGhpcy52X2ludk1hc3NCO1xuICAgIHZhciBpQSA9IHRoaXMudl9pbnZJQTtcbiAgICB2YXIgaUIgPSB0aGlzLnZfaW52SUI7XG4gICAgdmFyIGxvY2FsQ2VudGVyQSA9IGl2Y19sb2NhbENlbnRlckEuc2V0VmVjMih0aGlzLnBfbG9jYWxDZW50ZXJBKTtcbiAgICB2YXIgbG9jYWxDZW50ZXJCID0gaXZjX2xvY2FsQ2VudGVyQi5zZXRWZWMyKHRoaXMucF9sb2NhbENlbnRlckIpO1xuICAgIHZhciBjQSA9IGl2Y19jQS5zZXRWZWMyKHBvc2l0aW9uQS5jKTtcbiAgICB2YXIgYUEgPSBwb3NpdGlvbkEuYTtcbiAgICB2YXIgdkEgPSBpdmNfdkEuc2V0VmVjMih2ZWxvY2l0eUEudik7XG4gICAgdmFyIHdBID0gdmVsb2NpdHlBLnc7XG4gICAgdmFyIGNCID0gaXZjX2NCLnNldChwb3NpdGlvbkIuYyk7XG4gICAgdmFyIGFCID0gcG9zaXRpb25CLmE7XG4gICAgdmFyIHZCID0gaXZjX3ZCLnNldCh2ZWxvY2l0eUIudik7XG4gICAgdmFyIHdCID0gdmVsb2NpdHlCLnc7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KG1hbmlmb2xkLnBvaW50Q291bnQgPiAwKTtcbiAgICB2YXIgeGZBID0gaXZjX3hmQS5zZXRJZGVudGl0eSgpO1xuICAgIHZhciB4ZkIgPSBpdmNfeGZCLnNldElkZW50aXR5KCk7XG4gICAgeGZBLnEuc2V0KGFBKTtcbiAgICB4ZkIucS5zZXQoYUIpO1xuICAgIHhmQS5wLnNldENvbWJpbmUoMSwgY0EsIC0xLCBSb3QubXVsVmVjMih4ZkEucSwgbG9jYWxDZW50ZXJBKSk7XG4gICAgeGZCLnAuc2V0Q29tYmluZSgxLCBjQiwgLTEsIFJvdC5tdWxWZWMyKHhmQi5xLCBsb2NhbENlbnRlckIpKTtcbiAgICB2YXIgd29ybGRNYW5pZm9sZCA9IG1hbmlmb2xkLmdldFdvcmxkTWFuaWZvbGQobnVsbCwgeGZBLCByYWRpdXNBLCB4ZkIsIHJhZGl1c0IpO1xuICAgIHRoaXMudl9ub3JtYWwuc2V0KHdvcmxkTWFuaWZvbGQubm9ybWFsKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudl9wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgdmFyIHZjcCA9IHRoaXMudl9wb2ludHNbal07XG4gICAgICAgIC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgIHZjcC5yQS5zZXRDb21iaW5lKDEsIHdvcmxkTWFuaWZvbGQucG9pbnRzW2pdLCAtMSwgY0EpO1xuICAgICAgICB2Y3AuckIuc2V0Q29tYmluZSgxLCB3b3JsZE1hbmlmb2xkLnBvaW50c1tqXSwgLTEsIGNCKTtcbiAgICAgICAgdmFyIHJuQSA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AuckEsIHRoaXMudl9ub3JtYWwpO1xuICAgICAgICB2YXIgcm5CID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQiwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgIHZhciBrTm9ybWFsID0gbUEgKyBtQiArIGlBICogcm5BICogcm5BICsgaUIgKiBybkIgKiBybkI7XG4gICAgICAgIHZjcC5ub3JtYWxNYXNzID0ga05vcm1hbCA+IDAgPyAxIC8ga05vcm1hbCA6IDA7XG4gICAgICAgIHZhciB0YW5nZW50ID0gVmVjMi5jcm9zc1ZlYzJOdW1fKHRoaXMudl9ub3JtYWwsIDEsIGl2Y19ub3JtYWwpO1xuICAgICAgICB2YXIgcnRBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQSwgdGFuZ2VudCk7XG4gICAgICAgIHZhciBydEIgPSBWZWMyLmNyb3NzVmVjMlZlYzIodmNwLnJCLCB0YW5nZW50KTtcbiAgICAgICAgdmFyIGtUYW5nZW50ID0gbUEgKyBtQiArIGlBICogcnRBICogcnRBICsgaUIgKiBydEIgKiBydEI7XG4gICAgICAgIHZjcC50YW5nZW50TWFzcyA9IGtUYW5nZW50ID4gMCA/IDEgLyBrVGFuZ2VudCA6IDA7XG4gICAgICAgIC8vIFNldHVwIGEgdmVsb2NpdHkgYmlhcyBmb3IgcmVzdGl0dXRpb24uXG4gICAgICAgIHZjcC52ZWxvY2l0eUJpYXMgPSAwO1xuICAgICAgICB2YXIgdlJlbCA9IFZlYzIuZG90KHRoaXMudl9ub3JtYWwsIHZCKSArIFZlYzIuZG90KHRoaXMudl9ub3JtYWwsIFZlYzIuY3Jvc3NOdW1WZWMyXyh3QiwgdmNwLnJCLCBpdmNfdDEpKSAtIFZlYzIuZG90KHRoaXMudl9ub3JtYWwsIHZBKSAtIFZlYzIuZG90KHRoaXMudl9ub3JtYWwsIFZlYzIuY3Jvc3NOdW1WZWMyXyh3QSwgdmNwLnJBLCBpdmNfdDIpKTtcbiAgICAgICAgaWYgKHZSZWwgPCAtU2V0dGluZ3MudmVsb2NpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHZjcC52ZWxvY2l0eUJpYXMgPSAtdGhpcy52X3Jlc3RpdHV0aW9uICogdlJlbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIHR3byBwb2ludHMsIHRoZW4gcHJlcGFyZSB0aGUgYmxvY2sgc29sdmVyLlxuICAgIGlmICh0aGlzLnZfcG9pbnRDb3VudCA9PT0gMiAmJiBzdGVwLmJsb2NrU29sdmUpIHtcbiAgICAgICAgdmFyIHZjcDEgPSB0aGlzLnZfcG9pbnRzWzBdO1xuICAgICAgICAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICB2YXIgdmNwMiA9IHRoaXMudl9wb2ludHNbMV07XG4gICAgICAgIC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgIHZhciBybjFBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcDEuckEsIHRoaXMudl9ub3JtYWwpO1xuICAgICAgICB2YXIgcm4xQiA9IFZlYzIuY3Jvc3NWZWMyVmVjMih2Y3AxLnJCLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgdmFyIHJuMkEgPSBWZWMyLmNyb3NzVmVjMlZlYzIodmNwMi5yQSwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgIHZhciBybjJCID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcDIuckIsIHRoaXMudl9ub3JtYWwpO1xuICAgICAgICB2YXIgazExID0gbUEgKyBtQiArIGlBICogcm4xQSAqIHJuMUEgKyBpQiAqIHJuMUIgKiBybjFCO1xuICAgICAgICB2YXIgazIyID0gbUEgKyBtQiArIGlBICogcm4yQSAqIHJuMkEgKyBpQiAqIHJuMkIgKiBybjJCO1xuICAgICAgICB2YXIgazEyID0gbUEgKyBtQiArIGlBICogcm4xQSAqIHJuMkEgKyBpQiAqIHJuMUIgKiBybjJCO1xuICAgICAgICAvLyBFbnN1cmUgYSByZWFzb25hYmxlIGNvbmRpdGlvbiBudW1iZXIuXG4gICAgICAgIHZhciBrX21heENvbmRpdGlvbk51bWJlciA9IDFlMztcbiAgICAgICAgaWYgKGsxMSAqIGsxMSA8IGtfbWF4Q29uZGl0aW9uTnVtYmVyICogKGsxMSAqIGsyMiAtIGsxMiAqIGsxMikpIHtcbiAgICAgICAgICAgIC8vIEsgaXMgc2FmZSB0byBpbnZlcnQuXG4gICAgICAgICAgICB0aGlzLnZfSy5leC5zZXQoazExLCBrMTIpO1xuICAgICAgICAgICAgdGhpcy52X0suZXkuc2V0KGsxMiwgazIyKTtcbiAgICAgICAgICAgIHRoaXMudl9ub3JtYWxNYXNzLnNldCh0aGlzLnZfSy5nZXRJbnZlcnNlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGNvbnN0cmFpbnRzIGFyZSByZWR1bmRhbnQsIGp1c3QgdXNlIG9uZS5cbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiB1c2UgZGVlcGVzdD9cbiAgICAgICAgICAgIHRoaXMudl9wb2ludENvdW50ID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbkEuYy5zZXQoY0EpO1xuICAgIHBvc2l0aW9uQS5hID0gYUE7XG4gICAgdmVsb2NpdHlBLnYuc2V0KHZBKTtcbiAgICB2ZWxvY2l0eUEudyA9IHdBO1xuICAgIHBvc2l0aW9uQi5jLnNldChjQik7XG4gICAgcG9zaXRpb25CLmEgPSBhQjtcbiAgICB2ZWxvY2l0eUIudi5zZXQodkIpO1xuICAgIHZlbG9jaXR5Qi53ID0gd0I7XG59O1xuXG52YXIgd3NjX3ZBID0gVmVjMi56ZXJvKCk7XG5cbnZhciB3c2NfdkIgPSBWZWMyLnplcm8oKTtcblxudmFyIHdzY19ub3JtYWwgPSBWZWMyLnplcm8oKTtcblxudmFyIHdzY19QID0gVmVjMi56ZXJvKCk7XG5cbkNvbnRhY3QucHJvdG90eXBlLndhcm1TdGFydENvbnN0cmFpbnQgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgIHZhciBmaXh0dXJlQiA9IHRoaXMubV9maXh0dXJlQjtcbiAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgIHZhciB2ZWxvY2l0eUEgPSBib2R5QS5jX3ZlbG9jaXR5O1xuICAgIHZhciB2ZWxvY2l0eUIgPSBib2R5Qi5jX3ZlbG9jaXR5O1xuICAgIHZhciBwb3NpdGlvbkEgPSBib2R5QS5jX3Bvc2l0aW9uO1xuICAgIHZhciBwb3NpdGlvbkIgPSBib2R5Qi5jX3Bvc2l0aW9uO1xuICAgIHZhciBtQSA9IHRoaXMudl9pbnZNYXNzQTtcbiAgICB2YXIgaUEgPSB0aGlzLnZfaW52SUE7XG4gICAgdmFyIG1CID0gdGhpcy52X2ludk1hc3NCO1xuICAgIHZhciBpQiA9IHRoaXMudl9pbnZJQjtcbiAgICB2YXIgdkEgPSB3c2NfdkEuc2V0KHZlbG9jaXR5QS52KTtcbiAgICB2YXIgd0EgPSB2ZWxvY2l0eUEudztcbiAgICB2YXIgdkIgPSB3c2NfdkIuc2V0KHZlbG9jaXR5Qi52KTtcbiAgICB2YXIgd0IgPSB2ZWxvY2l0eUIudztcbiAgICB2YXIgbm9ybWFsID0gdGhpcy52X25vcm1hbDtcbiAgICB2YXIgdGFuZ2VudCA9IFZlYzIuY3Jvc3NWZWMyTnVtXyhub3JtYWwsIDEsIHdzY19ub3JtYWwpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52X3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tqXTtcbiAgICAgICAgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgdmFyIFAgPSB3c2NfUC5zZXRDb21iaW5lKHZjcC5ub3JtYWxJbXB1bHNlLCBub3JtYWwsIHZjcC50YW5nZW50SW1wdWxzZSwgdGFuZ2VudCk7XG4gICAgICAgIHdBIC09IGlBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQSwgUCk7XG4gICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHZjcC5yQiwgUCk7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgfVxuICAgIHZlbG9jaXR5QS52LnNldCh2QSk7XG4gICAgdmVsb2NpdHlBLncgPSB3QTtcbiAgICB2ZWxvY2l0eUIudi5zZXQodkIpO1xuICAgIHZlbG9jaXR5Qi53ID0gd0I7XG59O1xuXG5Db250YWN0LnByb3RvdHlwZS5zdG9yZUNvbnN0cmFpbnRJbXB1bHNlcyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgbWFuaWZvbGQgPSB0aGlzLm1fbWFuaWZvbGQ7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZfcG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1tqXS5ub3JtYWxJbXB1bHNlID0gdGhpcy52X3BvaW50c1tqXS5ub3JtYWxJbXB1bHNlO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbal0udGFuZ2VudEltcHVsc2UgPSB0aGlzLnZfcG9pbnRzW2pdLnRhbmdlbnRJbXB1bHNlO1xuICAgIH1cbn07XG5cbnZhciBzdmNfdkEgPSBWZWMyLnplcm8oKTtcblxudmFyIHN2Y192QiA9IFZlYzIuemVybygpO1xuXG52YXIgc3ZjX2R2ID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzdmNfUCA9IFZlYzIuemVybygpO1xuXG52YXIgc3ZjX3RhbmdlbnQgPSBWZWMyLnplcm8oKTtcblxudmFyIHN2Y19hID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzdmNfYiA9IFZlYzIuemVybygpO1xuXG52YXIgc3ZjX2QgPSBWZWMyLnplcm8oKTtcblxudmFyIHN2Y194ID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzdmNfZHYxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzdmNfZHYyID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzdmNfUDEgPSBWZWMyLnplcm8oKTtcblxudmFyIHN2Y19QMiA9IFZlYzIuemVybygpO1xuXG52YXIgc3ZjX3QxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBzdmNfdDIgPSBWZWMyLnplcm8oKTtcblxuQ29udGFjdC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnQgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLm1fYm9keTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLm1fZml4dHVyZUIubV9ib2R5O1xuICAgIHZhciB2ZWxvY2l0eUEgPSBib2R5QS5jX3ZlbG9jaXR5O1xuICAgIHZhciBwb3NpdGlvbkEgPSBib2R5QS5jX3Bvc2l0aW9uO1xuICAgIHZhciB2ZWxvY2l0eUIgPSBib2R5Qi5jX3ZlbG9jaXR5O1xuICAgIHZhciBwb3NpdGlvbkIgPSBib2R5Qi5jX3Bvc2l0aW9uO1xuICAgIHZhciBtQSA9IHRoaXMudl9pbnZNYXNzQTtcbiAgICB2YXIgaUEgPSB0aGlzLnZfaW52SUE7XG4gICAgdmFyIG1CID0gdGhpcy52X2ludk1hc3NCO1xuICAgIHZhciBpQiA9IHRoaXMudl9pbnZJQjtcbiAgICAvLyB2YXIgdkEgPSBzdmNfdkEuc2V0VmVjMih2ZWxvY2l0eUEudik7XG4gICAgdmFyIHZBWCA9IHZlbG9jaXR5QS52Lng7XG4gICAgdmFyIHZBWSA9IHZlbG9jaXR5QS52Lnk7XG4gICAgdmFyIHdBID0gdmVsb2NpdHlBLnc7XG4gICAgLy8gdmFyIHZCID0gc3ZjX3ZCLnNldFZlYzIodmVsb2NpdHlCLnYpO1xuICAgIHZhciB2QlggPSB2ZWxvY2l0eUIudi54O1xuICAgIHZhciB2QlkgPSB2ZWxvY2l0eUIudi55O1xuICAgIHZhciB3QiA9IHZlbG9jaXR5Qi53O1xuICAgIHZhciBub3JtYWwgPSB0aGlzLnZfbm9ybWFsO1xuICAgIHZhciB0YW5nZW50ID0gVmVjMi5jcm9zc1ZlYzJOdW1fKG5vcm1hbCwgMSwgc3ZjX3RhbmdlbnQpO1xuICAgIHZhciBmcmljdGlvbiA9IHRoaXMudl9mcmljdGlvbjtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy52X3BvaW50Q291bnQgPT09IDEgfHwgdGhpcy52X3BvaW50Q291bnQgPT09IDIpO1xuICAgIC8vIFNvbHZlIHRhbmdlbnQgY29uc3RyYWludHMgZmlyc3QgYmVjYXVzZSBub24tcGVuZXRyYXRpb24gaXMgbW9yZSBpbXBvcnRhbnRcbiAgICAvLyB0aGFuIGZyaWN0aW9uLlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52X3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tqXTtcbiAgICAgICAgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgYXQgY29udGFjdFxuICAgICAgICAvLyB2YXIgZHYgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgdmFyIGR2WCA9IDA7XG4gICAgICAgIHZhciBkdlkgPSAwO1xuICAgICAgICAvLyBkdi5hZGRDb21iaW5lKDEsIHZCLCAxLCBWZWMyLmNyb3NzKHdCLCB2Y3AuckIpKTtcbiAgICAgICAgZHZYICs9IHZCWCArIC13QiAqIHZjcC5yQi55O1xuICAgICAgICBkdlkgKz0gdkJZICsgd0IgKiB2Y3AuckIueDtcbiAgICAgICAgLy8gZHYuc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zcyh3QSwgdmNwLnJBKSk7XG4gICAgICAgIGR2WCAtPSB2QVggKyAtd0EgKiB2Y3AuckEueTtcbiAgICAgICAgZHZZIC09IHZBWSArIHdBICogdmNwLnJBLng7XG4gICAgICAgIC8vIENvbXB1dGUgdGFuZ2VudCBmb3JjZVxuICAgICAgICAvLyB2YXIgdnQgPSBWZWMyLmRvdChkdiwgdGFuZ2VudCkgLSB0aGlzLnZfdGFuZ2VudFNwZWVkO1xuICAgICAgICB2YXIgdnQgPSBkdlggKiB0YW5nZW50LnggKyBkdlkgKiB0YW5nZW50LnkgLSB0aGlzLnZfdGFuZ2VudFNwZWVkO1xuICAgICAgICB2YXIgbGFtYmRhID0gdmNwLnRhbmdlbnRNYXNzICogLXZ0O1xuICAgICAgICAvLyBDbGFtcCB0aGUgYWNjdW11bGF0ZWQgZm9yY2VcbiAgICAgICAgdmFyIG1heEZyaWN0aW9uID0gZnJpY3Rpb24gKiB2Y3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgdmFyIG5ld0ltcHVsc2UgPSBNYXRoLmNsYW1wKHZjcC50YW5nZW50SW1wdWxzZSArIGxhbWJkYSwgLW1heEZyaWN0aW9uLCBtYXhGcmljdGlvbik7XG4gICAgICAgIGxhbWJkYSA9IG5ld0ltcHVsc2UgLSB2Y3AudGFuZ2VudEltcHVsc2U7XG4gICAgICAgIHZjcC50YW5nZW50SW1wdWxzZSA9IG5ld0ltcHVsc2U7XG4gICAgICAgIC8vIEFwcGx5IGNvbnRhY3QgaW1wdWxzZVxuICAgICAgICAvLyB2YXIgUCA9IFZlYzIubXVsKGxhbWJkYSwgdGFuZ2VudCk7XG4gICAgICAgIHZhciBQWCA9IGxhbWJkYSAqIHRhbmdlbnQueDtcbiAgICAgICAgdmFyIFBZID0gbGFtYmRhICogdGFuZ2VudC55O1xuICAgICAgICAvLyB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICB2QVggLT0gbUEgKiBQWDtcbiAgICAgICAgdkFYIC09IG1BICogUFk7XG4gICAgICAgIC8vIHdBIC09IGlBICogVmVjMi5jcm9zcyh2Y3AuckEsIFApO1xuICAgICAgICB3QSAtPSBpQSAqICh2Y3AuckEueCAqIFBZIC0gdmNwLnJBLnkgKiBQWCk7XG4gICAgICAgIC8vIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHZCWCArPSBtQiAqIFBYO1xuICAgICAgICB2QlkgKz0gbUIgKiBQWTtcbiAgICAgICAgLy8gd0IgKz0gaUIgKiBWZWMyLmNyb3NzKHZjcC5yQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogKHZjcC5yQi54ICogUFkgLSB2Y3AuckIueSAqIFBYKTtcbiAgICB9XG4gICAgLy8gU29sdmUgbm9ybWFsIGNvbnN0cmFpbnRzXG4gICAgaWYgKHRoaXMudl9wb2ludENvdW50ID09PSAxIHx8IHN0ZXAuYmxvY2tTb2x2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZfcG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tpXTtcbiAgICAgICAgICAgIC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBhdCBjb250YWN0XG4gICAgICAgICAgICAvLyB2YXIgZHYgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHZhciBkdlggPSAwO1xuICAgICAgICAgICAgdmFyIGR2WSA9IDA7XG4gICAgICAgICAgICAvLyBkdi5hZGRDb21iaW5lKDEsIHZCLCAxLCBWZWMyLmNyb3NzKHdCLCB2Y3AuckIpKTtcbiAgICAgICAgICAgIGR2WCArPSB2QlggKyAtd0IgKiB2Y3AuckIueTtcbiAgICAgICAgICAgIGR2WSArPSB2QlkgKyB3QiAqIHZjcC5yQi54O1xuICAgICAgICAgICAgLy8gZHYuc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zcyh3QSwgdmNwLnJBKSk7XG4gICAgICAgICAgICBkdlggLT0gdkFYICsgLXdBICogdmNwLnJBLnk7XG4gICAgICAgICAgICBkdlkgLT0gdkFZICsgd0EgKiB2Y3AuckEueDtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIGltcHVsc2VcbiAgICAgICAgICAgIC8vIHZhciB2biA9IFZlYzIuZG90KGR2LCBub3JtYWwpO1xuICAgICAgICAgICAgdmFyIHZuID0gZHZYICogbm9ybWFsLnggKyBkdlkgKiBub3JtYWwueTtcbiAgICAgICAgICAgIHZhciBsYW1iZGEgPSAtdmNwLm5vcm1hbE1hc3MgKiAodm4gLSB2Y3AudmVsb2NpdHlCaWFzKTtcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlXG4gICAgICAgICAgICB2YXIgbmV3SW1wdWxzZSA9IE1hdGgubWF4KHZjcC5ub3JtYWxJbXB1bHNlICsgbGFtYmRhLCAwKTtcbiAgICAgICAgICAgIGxhbWJkYSA9IG5ld0ltcHVsc2UgLSB2Y3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIHZjcC5ub3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbnRhY3QgaW1wdWxzZVxuICAgICAgICAgICAgLy8gdmFyIFAgPSBWZWMyLm11bChsYW1iZGEsIG5vcm1hbCk7XG4gICAgICAgICAgICB2YXIgUFggPSBsYW1iZGEgKiBub3JtYWwueDtcbiAgICAgICAgICAgIHZhciBQWSA9IGxhbWJkYSAqIG5vcm1hbC55O1xuICAgICAgICAgICAgLy8gdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgIHZBWCAtPSBtQSAqIFBYO1xuICAgICAgICAgICAgdkFZIC09IG1BICogUFk7XG4gICAgICAgICAgICAvLyB3QSAtPSBpQSAqIFZlYzIuY3Jvc3ModmNwLnJBLCBQKTtcbiAgICAgICAgICAgIHdBIC09IGlBICogKHZjcC5yQS54ICogUFkgLSB2Y3AuckEueSAqIFBYKTtcbiAgICAgICAgICAgIC8vIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICB2QlggKz0gbUIgKiBQWDtcbiAgICAgICAgICAgIHZCWSArPSBtQiAqIFBZO1xuICAgICAgICAgICAgLy8gd0IgKz0gaUIgKiBWZWMyLmNyb3NzKHZjcC5yQiwgUCk7XG4gICAgICAgICAgICB3QiArPSBpQiAqICh2Y3AuckIueCAqIFBZIC0gdmNwLnJCLnkgKiBQWCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCbG9jayBzb2x2ZXIgZGV2ZWxvcGVkIGluIGNvbGxhYm9yYXRpb24gd2l0aCBEaXJrIEdyZWdvcml1cyAoYmFjayBpblxuICAgICAgICAvLyAwMS8wNyBvbiBCb3gyRF9MaXRlKS5cbiAgICAgICAgLy8gQnVpbGQgdGhlIG1pbmkgTENQIGZvciB0aGlzIGNvbnRhY3QgcGF0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdm4gPSBBICogeCArIGIsIHZuID49IDAsICwgdm4gPj0gMCwgeCA+PSAwIGFuZCB2bl9pICogeF9pID0gMCB3aXRoIGkgPVxuICAgICAgICAvLyAxLi4yXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEEgPSBKICogVyAqIEpUIGFuZCBKID0gKCAtbiwgLXIxIHggbiwgbiwgcjIgeCBuIClcbiAgICAgICAgLy8gYiA9IHZuMCAtIHZlbG9jaXR5Qmlhc1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgc3lzdGVtIGlzIHNvbHZlZCB1c2luZyB0aGUgXCJUb3RhbCBlbnVtZXJhdGlvbiBtZXRob2RcIiAocy4gTXVydHkpLlxuICAgICAgICAvLyBUaGUgY29tcGxlbWVudGFyeSBjb25zdHJhaW50IHZuX2kgKiB4X2lcbiAgICAgICAgLy8gaW1wbGllcyB0aGF0IHdlIG11c3QgaGF2ZSBpbiBhbnkgc29sdXRpb24gZWl0aGVyIHZuX2kgPSAwIG9yIHhfaSA9IDAuXG4gICAgICAgIC8vIFNvIGZvciB0aGUgMkQgY29udGFjdCBwcm9ibGVtIHRoZSBjYXNlc1xuICAgICAgICAvLyB2bjEgPSAwIGFuZCB2bjIgPSAwLCB4MSA9IDAgYW5kIHgyID0gMCwgeDEgPSAwIGFuZCB2bjIgPSAwLCB4MiA9IDAgYW5kXG4gICAgICAgIC8vIHZuMSA9IDAgbmVlZCB0byBiZSB0ZXN0ZWQuIFRoZSBmaXJzdCB2YWxpZFxuICAgICAgICAvLyBzb2x1dGlvbiB0aGF0IHNhdGlzZmllcyB0aGUgcHJvYmxlbSBpcyBjaG9zZW4uXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBJbiBvcmRlciB0byBhY2NvdW50IG9mIHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlICdhJyAoYmVjYXVzZSBvZiB0aGVcbiAgICAgICAgLy8gaXRlcmF0aXZlIG5hdHVyZSBvZiB0aGUgc29sdmVyIHdoaWNoIG9ubHkgcmVxdWlyZXNcbiAgICAgICAgLy8gdGhhdCB0aGUgYWNjdW11bGF0ZWQgaW1wdWxzZSBpcyBjbGFtcGVkIGFuZCBub3QgdGhlIGluY3JlbWVudGFsXG4gICAgICAgIC8vIGltcHVsc2UpIHdlIGNoYW5nZSB0aGUgaW1wdWxzZSB2YXJpYWJsZSAoeF9pKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU3Vic3RpdHV0ZTpcbiAgICAgICAgLy8gXG4gICAgICAgIC8vIHggPSBhICsgZFxuICAgICAgICAvLyBcbiAgICAgICAgLy8gYSA6PSBvbGQgdG90YWwgaW1wdWxzZVxuICAgICAgICAvLyB4IDo9IG5ldyB0b3RhbCBpbXB1bHNlXG4gICAgICAgIC8vIGQgOj0gaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAvL1xuICAgICAgICAvLyBGb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uIHdlIGV4dGVuZCB0aGUgZm9ybXVsYSBmb3IgdGhlIGluY3JlbWVudGFsXG4gICAgICAgIC8vIGltcHVsc2VcbiAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGUgbmV3IHRvdGFsIGltcHVsc2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHZuID0gQSAqIGQgKyBiXG4gICAgICAgIC8vID0gQSAqICh4IC0gYSkgKyBiXG4gICAgICAgIC8vID0gQSAqIHggKyBiIC0gQSAqIGFcbiAgICAgICAgLy8gPSBBICogeCArIGInXG4gICAgICAgIC8vIGInID0gYiAtIEEgKiBhO1xuICAgICAgICB2YXIgdmNwMSA9IHRoaXMudl9wb2ludHNbMF07XG4gICAgICAgIC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgIHZhciB2Y3AyID0gdGhpcy52X3BvaW50c1sxXTtcbiAgICAgICAgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgLy8gdmFyIGEgPSBWZWMyLm5lbyh2Y3AxLm5vcm1hbEltcHVsc2UsIHZjcDIubm9ybWFsSW1wdWxzZSk7XG4gICAgICAgIHZhciBhWCA9IHZjcDEubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgdmFyIGFZID0gdmNwMi5ub3JtYWxJbXB1bHNlO1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoYVggPj0gMCAmJiBhWSA+PSAwKTtcbiAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgYXQgY29udGFjdFxuICAgICAgICAvLyB2YXIgZHYxID0gc3ZjX2R2MS5zZXRaZXJvKCkuYWRkKHZCKS5hZGQoVmVjMi5jcm9zc051bVZlYzJfKHdCLCB2Y3AxLnJCLCBzdmNfdDEpKS5zdWIodkEpLnN1YihWZWMyLmNyb3NzTnVtVmVjMl8od0EsIHZjcDEuckEsIHN2Y190MikpO1xuICAgICAgICB2YXIgZHYxWCA9IHZCWCArIC13QiAqIHZjcDEuckIueSAtICh2QVggKyAtd0EgKiB2Y3AxLnJBLnkpO1xuICAgICAgICB2YXIgZHYxWSA9IHZCWSArIHdCICogdmNwMS5yQi54IC0gKHZBWSArIHdBICogdmNwMS5yQS54KTtcbiAgICAgICAgLy8gdmFyIGR2MiA9IHN2Y19kdjIuc2V0WmVybygpLmFkZCh2QikuYWRkKFZlYzIuY3Jvc3NOdW1WZWMyXyh3QiwgdmNwMi5yQiwgc3ZjX3QxKSkuc3ViKHZBKS5zdWIoVmVjMi5jcm9zc051bVZlYzJfKHdBLCB2Y3AyLnJBLCBzdmNfdDIpKTtcbiAgICAgICAgdmFyIGR2MlggPSB2QlggKyAtd0IgKiB2Y3AyLnJCLnkgLSAodkFYICsgLXdBICogdmNwMi5yQS55KTtcbiAgICAgICAgdmFyIGR2MlkgPSB2QlkgKyB3QiAqIHZjcDIuckIueCAtICh2QVkgKyB3QSAqIHZjcDIuckEueCk7XG4gICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIHZlbG9jaXR5XG4gICAgICAgIHZhciB2bjEgPSBkdjFYICogbm9ybWFsLnggKyBkdjFZICogbm9ybWFsLnk7XG4gICAgICAgIHZhciB2bjIgPSBkdjJYICogbm9ybWFsLnggKyBkdjJZICogbm9ybWFsLnk7XG4gICAgICAgIC8vIHZhciBiID0gVmVjMi5uZW8odm4xIC0gdmNwMS52ZWxvY2l0eUJpYXMsIHZuMiAtIHZjcDIudmVsb2NpdHlCaWFzKTtcbiAgICAgICAgdmFyIGJYID0gdm4xIC0gdmNwMS52ZWxvY2l0eUJpYXM7XG4gICAgICAgIHZhciBiWSA9IHZuMiAtIHZjcDIudmVsb2NpdHlCaWFzO1xuICAgICAgICAvLyBDb21wdXRlIGInXG4gICAgICAgIC8vIGIuc3ViKE1hdDIyLm11bFZlYzIodGhpcy52X0ssIGEpKTtcbiAgICAgICAgYlggLT0gdGhpcy52X0suZXgueCAqIGFYICsgdGhpcy52X0suZXkueCAqIGFZO1xuICAgICAgICBiWSAtPSB0aGlzLnZfSy5leC55ICogYVggKyB0aGlzLnZfSy5leS55ICogYVk7XG4gICAgICAgIHZhciBrX2Vycm9yVG9sID0gLjAwMTtcbiAgICAgICAgLy8gTk9UX1VTRUQoa19lcnJvclRvbCk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDYXNlIDE6IHZuID0gMFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDAgPSBBICogeCArIGInXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU29sdmUgZm9yIHg6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8geCA9IC0gaW52KEEpICogYidcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB2YXIgeCA9IE1hdDIyLm11bFZlYzIodGhpcy52X25vcm1hbE1hc3MsIGIpLm5lZygpO1xuICAgICAgICAgICAgdmFyIHhYID0gLSh0aGlzLnZfbm9ybWFsTWFzcy5leC54ICogYlggKyB0aGlzLnZfbm9ybWFsTWFzcy5leS54ICogYlkpO1xuICAgICAgICAgICAgdmFyIHhZID0gLSh0aGlzLnZfbm9ybWFsTWFzcy5leC55ICogYlggKyB0aGlzLnZfbm9ybWFsTWFzcy5leS55ICogYlkpO1xuICAgICAgICAgICAgaWYgKHhYID49IDAgJiYgeFkgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHZhciBkWCA9IHhYIC0gYVg7XG4gICAgICAgICAgICAgICAgdmFyIGRZID0geFkgLSBhWTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgLy8gdmFyIFAxID0gVmVjMi5tdWwoZC54LCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIHZhciBQMVggPSBkWCAqIG5vcm1hbC54O1xuICAgICAgICAgICAgICAgIHZhciBQMVkgPSBkWCAqIG5vcm1hbC55O1xuICAgICAgICAgICAgICAgIC8vIHZhciBQMiA9IFZlYzIubXVsKGQueSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgUDJYID0gZFkgKiBub3JtYWwueDtcbiAgICAgICAgICAgICAgICB2YXIgUDJZID0gZFkgKiBub3JtYWwueTtcbiAgICAgICAgICAgICAgICAvLyB2QS5zdWJDb21iaW5lKG1BLCBQMSwgbUEsIFAyKTtcbiAgICAgICAgICAgICAgICB2QVggLT0gbUEgKiBQMVggKyBtQSAqIFAyWDtcbiAgICAgICAgICAgICAgICB2QVkgLT0gbUEgKiBQMVkgKyBtQSAqIFAyWTtcbiAgICAgICAgICAgICAgICAvLyB3QSAtPSBpQSAqIChWZWMyLmNyb3NzKHZjcDEuckEsIFAxKSArIFZlYzIuY3Jvc3ModmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqICh2Y3AxLnJBLnggKiBQMVkgLSB2Y3AxLnJBLnkgKiBQMVggKyB2Y3AyLnJBLnggKiBQMlkgLSB2Y3AyLnJBLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgIC8vIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgIHZCWCArPSBtQiAqIFAxWCArIG1CICogUDJYO1xuICAgICAgICAgICAgICAgIHZCWSArPSBtQiAqIFAxWSArIG1CICogUDJZO1xuICAgICAgICAgICAgICAgIC8vIHdCICs9IGlCICogKFZlYzIuY3Jvc3ModmNwMS5yQiwgUDEpICsgVmVjMi5jcm9zcyh2Y3AyLnJCLCBQMikpO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogKHZjcDEuckIueCAqIFAxWSAtIHZjcDEuckIueSAqIFAxWCArIHZjcDIuckIueCAqIFAyWSAtIHZjcDIuckIueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxuICAgICAgICAgICAgICAgIHZjcDEubm9ybWFsSW1wdWxzZSA9IHhYO1xuICAgICAgICAgICAgICAgIHZjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xuICAgICAgICAgICAgICAgIGlmIChERUJVR19TT0xWRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLy8gUG9zdGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZHYxID0gdkIgKyBWZWMyLmNyb3NzKHdCLCB2Y3AxLnJCKSAtIHZBIC0gVmVjMi5jcm9zcyh3QSwgdmNwMS5yQSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGR2MiA9IHZCICsgVmVjMi5jcm9zcyh3QiwgdmNwMi5yQikgLSB2QSAtIFZlYzIuY3Jvc3Mod0EsIHZjcDIuckEpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAvLyBDb21wdXRlIG5vcm1hbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgICAgICAvLyB2bjEgPSBWZWMyLmRvdChkdjEsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMiA9IFZlYzIuZG90KGR2Miwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguYWJzKHZuMSAtIHZjcDEudmVsb2NpdHlCaWFzKSA8IGtfZXJyb3JUb2wpO1xuICAgICAgICAgICAgICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoTWF0aC5hYnModm4yIC0gdmNwMi52ZWxvY2l0eUJpYXMpIDwga19lcnJvclRvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENhc2UgMjogdm4xID0gMCBhbmQgeDIgPSAwXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMCA9IGExMSAqIHgxICsgYTEyICogMCArIGIxJ1xuICAgICAgICAgICAgLy8gdm4yID0gYTIxICogeDEgKyBhMjIgKiAwICsgYjInXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgeFggPSAtdmNwMS5ub3JtYWxNYXNzICogYlg7XG4gICAgICAgICAgICB4WSA9IDA7XG4gICAgICAgICAgICB2bjEgPSAwO1xuICAgICAgICAgICAgdm4yID0gdGhpcy52X0suZXgueSAqIHhYICsgYlk7XG4gICAgICAgICAgICBpZiAoeFggPj0gMCAmJiB2bjIgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHZhciBkWCA9IHhYIC0gYVg7XG4gICAgICAgICAgICAgICAgdmFyIGRZID0geFkgLSBhWTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgLy8gdmFyIFAxID0gVmVjMi5tdWwoZC54LCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIHZhciBQMVggPSBkWCAqIG5vcm1hbC54O1xuICAgICAgICAgICAgICAgIHZhciBQMVkgPSBkWCAqIG5vcm1hbC55O1xuICAgICAgICAgICAgICAgIC8vIHZhciBQMiA9IFZlYzIubXVsKGQueSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgUDJYID0gZFkgKiBub3JtYWwueDtcbiAgICAgICAgICAgICAgICB2YXIgUDJZID0gZFkgKiBub3JtYWwueTtcbiAgICAgICAgICAgICAgICAvLyB2QS5zdWJDb21iaW5lKG1BLCBQMSwgbUEsIFAyKTtcbiAgICAgICAgICAgICAgICB2QVggLT0gbUEgKiBQMVggKyBtQSAqIFAyWDtcbiAgICAgICAgICAgICAgICB2QVkgLT0gbUEgKiBQMVkgKyBtQSAqIFAyWTtcbiAgICAgICAgICAgICAgICAvLyB3QSAtPSBpQSAqIChWZWMyLmNyb3NzKHZjcDEuckEsIFAxKSArIFZlYzIuY3Jvc3ModmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqICh2Y3AxLnJBLnggKiBQMVkgLSB2Y3AxLnJBLnkgKiBQMVggKyB2Y3AyLnJBLnggKiBQMlkgLSB2Y3AyLnJBLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgIC8vIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgIHZCWCArPSBtQiAqIFAxWCArIG1CICogUDJYO1xuICAgICAgICAgICAgICAgIHZCWSArPSBtQiAqIFAxWSArIG1CICogUDJZO1xuICAgICAgICAgICAgICAgIC8vIHdCICs9IGlCICogKFZlYzIuY3Jvc3ModmNwMS5yQiwgUDEpICsgVmVjMi5jcm9zcyh2Y3AyLnJCLCBQMikpO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogKHZjcDEuckIueCAqIFAxWSAtIHZjcDEuckIueSAqIFAxWCArIHZjcDIuckIueCAqIFAyWSAtIHZjcDIuckIueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxuICAgICAgICAgICAgICAgIHZjcDEubm9ybWFsSW1wdWxzZSA9IHhYO1xuICAgICAgICAgICAgICAgIHZjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xuICAgICAgICAgICAgICAgIGlmIChERUJVR19TT0xWRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLy8gUG9zdGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGR2MUIgPSBWZWMyLmFkZCh2QiwgVmVjMi5jcm9zcyh3QiwgdmNwMS5yQikpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZHYxQSA9IFZlYzIuYWRkKHZBLCBWZWMyLmNyb3NzKHdBLCB2Y3AxLnJBKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIC8vIHZhciBkdjEgPSBWZWMyLnN1YihkdjFCLCBkdjFBKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGR2MVggPSBkdjFCLnggLSBkdjFBLng7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBkdjFZID0gZHYxQi55IC0gZHYxQS55O1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAvLyBDb21wdXRlIG5vcm1hbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgICAgICAvLyAvLyB2bjEgPSBWZWMyLmRvdChkdjEsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMSA9IGR2MVggKiBub3JtYWwueCArIGR2MVkgKiBub3JtYWwueTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguYWJzKHZuMSAtIHZjcDEudmVsb2NpdHlCaWFzKSA8IGtfZXJyb3JUb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDYXNlIDM6IHZuMiA9IDAgYW5kIHgxID0gMFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHZuMSA9IGExMSAqIDAgKyBhMTIgKiB4MiArIGIxJ1xuICAgICAgICAgICAgLy8gMCA9IGEyMSAqIDAgKyBhMjIgKiB4MiArIGIyJ1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHhYID0gMDtcbiAgICAgICAgICAgIHhZID0gLXZjcDIubm9ybWFsTWFzcyAqIGJZO1xuICAgICAgICAgICAgdm4xID0gdGhpcy52X0suZXkueCAqIHhZICsgYlg7XG4gICAgICAgICAgICB2bjIgPSAwO1xuICAgICAgICAgICAgaWYgKHhZID49IDAgJiYgdm4xID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgLy8gdmFyIGQgPSBWZWMyLnN1Yih4LCBhKTtcbiAgICAgICAgICAgICAgICB2YXIgZFggPSB4WCAtIGFYO1xuICAgICAgICAgICAgICAgIHZhciBkWSA9IHhZIC0gYVk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIC8vIHZhciBQMSA9IFZlYzIubXVsKGQueCwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgUDFYID0gZFggKiBub3JtYWwueDtcbiAgICAgICAgICAgICAgICB2YXIgUDFZID0gZFggKiBub3JtYWwueTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgUDIgPSBWZWMyLm11bChkLnksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmFyIFAyWCA9IGRZICogbm9ybWFsLng7XG4gICAgICAgICAgICAgICAgdmFyIFAyWSA9IGRZICogbm9ybWFsLnk7XG4gICAgICAgICAgICAgICAgLy8gdkEuc3ViQ29tYmluZShtQSwgUDEsIG1BLCBQMik7XG4gICAgICAgICAgICAgICAgdkFYIC09IG1BICogUDFYICsgbUEgKiBQMlg7XG4gICAgICAgICAgICAgICAgdkFZIC09IG1BICogUDFZICsgbUEgKiBQMlk7XG4gICAgICAgICAgICAgICAgLy8gd0EgLT0gaUEgKiAoVmVjMi5jcm9zcyh2Y3AxLnJBLCBQMSkgKyBWZWMyLmNyb3NzKHZjcDIuckEsIFAyKSk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAodmNwMS5yQS54ICogUDFZIC0gdmNwMS5yQS55ICogUDFYICsgdmNwMi5yQS54ICogUDJZIC0gdmNwMi5yQS55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAvLyB2Qi5hZGRDb21iaW5lKG1CLCBQMSwgbUIsIFAyKTtcbiAgICAgICAgICAgICAgICB2QlggKz0gbUIgKiBQMVggKyBtQiAqIFAyWDtcbiAgICAgICAgICAgICAgICB2QlkgKz0gbUIgKiBQMVkgKyBtQiAqIFAyWTtcbiAgICAgICAgICAgICAgICAvLyB3QiArPSBpQiAqIChWZWMyLmNyb3NzKHZjcDEuckIsIFAxKSArIFZlYzIuY3Jvc3ModmNwMi5yQiwgUDIpKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqICh2Y3AxLnJCLnggKiBQMVkgLSB2Y3AxLnJCLnkgKiBQMVggKyB2Y3AyLnJCLnggKiBQMlkgLSB2Y3AyLnJCLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICB2Y3AxLm5vcm1hbEltcHVsc2UgPSB4WDtcbiAgICAgICAgICAgICAgICB2Y3AyLm5vcm1hbEltcHVsc2UgPSB4WTtcbiAgICAgICAgICAgICAgICBpZiAoREVCVUdfU09MVkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC8vIFBvc3Rjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBkdjJCID0gVmVjMi5hZGQodkIsIFZlYzIuY3Jvc3Mod0IsIHZjcDIuckIpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGR2MkEgPSBWZWMyLmFkZCh2QSwgVmVjMi5jcm9zcyh3QSwgdmNwMi5yQSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZHYxID0gVmVjMi5zdWIoZHYyQiwgZHYyQSk7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIC8vIENvbXB1dGUgbm9ybWFsIHZlbG9jaXR5XG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMiA9IFZlYzIuZG90KGR2Miwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguYWJzKHZuMiAtIHZjcDIudmVsb2NpdHlCaWFzKSA8IGtfZXJyb3JUb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDYXNlIDQ6IHgxID0gMCBhbmQgeDIgPSAwXG4gICAgICAgICAgICAvLyBcbiAgICAgICAgICAgIC8vIHZuMSA9IGIxXG4gICAgICAgICAgICAvLyB2bjIgPSBiMjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB4WCA9IDA7XG4gICAgICAgICAgICB4WSA9IDA7XG4gICAgICAgICAgICB2bjEgPSBiWDtcbiAgICAgICAgICAgIHZuMiA9IGJZO1xuICAgICAgICAgICAgaWYgKHZuMSA+PSAwICYmIHZuMiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzdWJzdGl0dXRlIGZvciB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIC8vIHZhciBkID0gVmVjMi5zdWIoeCwgYSk7XG4gICAgICAgICAgICAgICAgdmFyIGRYID0geFggLSBhWDtcbiAgICAgICAgICAgICAgICB2YXIgZFkgPSB4WSAtIGFZO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAvLyB2YXIgUDEgPSBWZWMyLm11bChkLngsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmFyIFAxWCA9IGRYICogbm9ybWFsLng7XG4gICAgICAgICAgICAgICAgdmFyIFAxWSA9IGRYICogbm9ybWFsLnk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIFAyID0gVmVjMi5tdWwoZC55LCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIHZhciBQMlggPSBkWSAqIG5vcm1hbC54O1xuICAgICAgICAgICAgICAgIHZhciBQMlkgPSBkWSAqIG5vcm1hbC55O1xuICAgICAgICAgICAgICAgIC8vIHZBLnN1YkNvbWJpbmUobUEsIFAxLCBtQSwgUDIpO1xuICAgICAgICAgICAgICAgIHZBWCAtPSBtQSAqIFAxWCArIG1BICogUDJYO1xuICAgICAgICAgICAgICAgIHZBWSAtPSBtQSAqIFAxWSArIG1BICogUDJZO1xuICAgICAgICAgICAgICAgIC8vIHdBIC09IGlBICogKFZlYzIuY3Jvc3ModmNwMS5yQSwgUDEpICsgVmVjMi5jcm9zcyh2Y3AyLnJBLCBQMikpO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogKHZjcDEuckEueCAqIFAxWSAtIHZjcDEuckEueSAqIFAxWCArIHZjcDIuckEueCAqIFAyWSAtIHZjcDIuckEueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgLy8gdkIuYWRkQ29tYmluZShtQiwgUDEsIG1CLCBQMik7XG4gICAgICAgICAgICAgICAgdkJYICs9IG1CICogUDFYICsgbUIgKiBQMlg7XG4gICAgICAgICAgICAgICAgdkJZICs9IG1CICogUDFZICsgbUIgKiBQMlk7XG4gICAgICAgICAgICAgICAgLy8gd0IgKz0gaUIgKiAoVmVjMi5jcm9zcyh2Y3AxLnJCLCBQMSkgKyBWZWMyLmNyb3NzKHZjcDIuckIsIFAyKSk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAodmNwMS5yQi54ICogUDFZIC0gdmNwMS5yQi55ICogUDFYICsgdmNwMi5yQi54ICogUDJZIC0gdmNwMi5yQi55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlXG4gICAgICAgICAgICAgICAgdmNwMS5ub3JtYWxJbXB1bHNlID0geFg7XG4gICAgICAgICAgICAgICAgdmNwMi5ub3JtYWxJbXB1bHNlID0geFk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBzb2x1dGlvbiwgZ2l2ZSB1cC4gVGhpcyBpcyBoaXQgc29tZXRpbWVzLCBidXQgaXQgZG9lc24ndCBzZWVtIHRvXG4gICAgICAgICAgICAvLyBtYXR0ZXIuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB2ZWxvY2l0eUEudi5zZXQodkEpO1xuICAgIHZlbG9jaXR5QS52LnggPSB2QVg7XG4gICAgdmVsb2NpdHlBLnYueSA9IHZBWTtcbiAgICB2ZWxvY2l0eUEudyA9IHdBO1xuICAgIC8vIHZlbG9jaXR5Qi52LnNldCh2Qik7XG4gICAgdmVsb2NpdHlCLnYueCA9IHZCWDtcbiAgICB2ZWxvY2l0eUIudi55ID0gdkJZO1xuICAgIHZlbG9jaXR5Qi53ID0gd0I7XG59O1xuXG4vKipcbiAqIEZyaWN0aW9uIG1peGluZyBsYXcuIFRoZSBpZGVhIGlzIHRvIGFsbG93IGVpdGhlciBmaXh0dXJlIHRvIGRyaXZlIHRoZVxuICogcmVzdGl0dXRpb24gdG8gemVyby4gRm9yIGV4YW1wbGUsIGFueXRoaW5nIHNsaWRlcyBvbiBpY2UuXG4gKi9cbmZ1bmN0aW9uIG1peEZyaWN0aW9uKGZyaWN0aW9uMSwgZnJpY3Rpb24yKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChmcmljdGlvbjEgKiBmcmljdGlvbjIpO1xufVxuXG4vKipcbiAqIFJlc3RpdHV0aW9uIG1peGluZyBsYXcuIFRoZSBpZGVhIGlzIGFsbG93IGZvciBhbnl0aGluZyB0byBib3VuY2Ugb2ZmIGFuXG4gKiBpbmVsYXN0aWMgc3VyZmFjZS4gRm9yIGV4YW1wbGUsIGEgc3VwZXJiYWxsIGJvdW5jZXMgb24gYW55dGhpbmcuXG4gKi9cbmZ1bmN0aW9uIG1peFJlc3RpdHV0aW9uKHJlc3RpdHV0aW9uMSwgcmVzdGl0dXRpb24yKSB7XG4gICAgcmV0dXJuIHJlc3RpdHV0aW9uMSA+IHJlc3RpdHV0aW9uMiA/IHJlc3RpdHV0aW9uMSA6IHJlc3RpdHV0aW9uMjtcbn1cblxudmFyIHNfcmVnaXN0ZXJzID0gW107XG5cbnZhciBjb250YWN0UG9vbCA9IG5ldyBQb29sKHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRhY3QoKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAcGFyYW0gZm4gZnVuY3Rpb24oZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4QikgQ29udGFjdFxuICovXG5Db250YWN0LmFkZFR5cGUgPSBmdW5jdGlvbih0eXBlMSwgdHlwZTIsIGNhbGxiYWNrKSB7XG4gICAgc19yZWdpc3RlcnNbdHlwZTFdID0gc19yZWdpc3RlcnNbdHlwZTFdIHx8IHt9O1xuICAgIHNfcmVnaXN0ZXJzW3R5cGUxXVt0eXBlMl0gPSBjYWxsYmFjaztcbn07XG5cbkNvbnRhY3QuY3JlYXRlID0gZnVuY3Rpb24oZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4Qikge1xuICAgIHZhciB0eXBlQSA9IGZpeHR1cmVBLmdldFR5cGUoKTtcbiAgICAvLyBTaGFwZS5UeXBlXG4gICAgdmFyIHR5cGVCID0gZml4dHVyZUIuZ2V0VHlwZSgpO1xuICAgIC8vIFNoYXBlLlR5cGVcbiAgICAvLyBUT0RPOiBwb29sIGNvbnRhY3RzXG4gICAgdmFyIGNvbnRhY3QsIGV2YWx1YXRlRmNuO1xuICAgIGlmIChldmFsdWF0ZUZjbiA9IHNfcmVnaXN0ZXJzW3R5cGVBXSAmJiBzX3JlZ2lzdGVyc1t0eXBlQV1bdHlwZUJdKSB7XG4gICAgICAgIGNvbnRhY3QgPSBjb250YWN0UG9vbC5hbGxvY2F0ZSgpO1xuICAgICAgICBjb250YWN0LmluaXQoZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4QiwgZXZhbHVhdGVGY24pO1xuICAgIH0gZWxzZSBpZiAoZXZhbHVhdGVGY24gPSBzX3JlZ2lzdGVyc1t0eXBlQl0gJiYgc19yZWdpc3RlcnNbdHlwZUJdW3R5cGVBXSkge1xuICAgICAgICBjb250YWN0ID0gY29udGFjdFBvb2wuYWxsb2NhdGUoKTtcbiAgICAgICAgY29udGFjdC5pbml0KGZpeHR1cmVCLCBpbmRleEIsIGZpeHR1cmVBLCBpbmRleEEsIGV2YWx1YXRlRmNuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ29udGFjdCBjcmVhdGlvbiBtYXkgc3dhcCBmaXh0dXJlcy5cbiAgICBmaXh0dXJlQSA9IGNvbnRhY3QuZ2V0Rml4dHVyZUEoKTtcbiAgICBmaXh0dXJlQiA9IGNvbnRhY3QuZ2V0Rml4dHVyZUIoKTtcbiAgICBpbmRleEEgPSBjb250YWN0LmdldENoaWxkSW5kZXhBKCk7XG4gICAgaW5kZXhCID0gY29udGFjdC5nZXRDaGlsZEluZGV4QigpO1xuICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLmdldEJvZHkoKTtcbiAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5nZXRCb2R5KCk7XG4gICAgLy8gQ29ubmVjdCB0byBib2R5IEFcbiAgICBjb250YWN0Lm1fbm9kZUEuY29udGFjdCA9IGNvbnRhY3Q7XG4gICAgY29udGFjdC5tX25vZGVBLm90aGVyID0gYm9keUI7XG4gICAgY29udGFjdC5tX25vZGVBLnByZXYgPSBudWxsO1xuICAgIGNvbnRhY3QubV9ub2RlQS5uZXh0ID0gYm9keUEubV9jb250YWN0TGlzdDtcbiAgICBpZiAoYm9keUEubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHlBLm1fY29udGFjdExpc3QucHJldiA9IGNvbnRhY3QubV9ub2RlQTtcbiAgICB9XG4gICAgYm9keUEubV9jb250YWN0TGlzdCA9IGNvbnRhY3QubV9ub2RlQTtcbiAgICAvLyBDb25uZWN0IHRvIGJvZHkgQlxuICAgIGNvbnRhY3QubV9ub2RlQi5jb250YWN0ID0gY29udGFjdDtcbiAgICBjb250YWN0Lm1fbm9kZUIub3RoZXIgPSBib2R5QTtcbiAgICBjb250YWN0Lm1fbm9kZUIucHJldiA9IG51bGw7XG4gICAgY29udGFjdC5tX25vZGVCLm5leHQgPSBib2R5Qi5tX2NvbnRhY3RMaXN0O1xuICAgIGlmIChib2R5Qi5tX2NvbnRhY3RMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keUIubV9jb250YWN0TGlzdC5wcmV2ID0gY29udGFjdC5tX25vZGVCO1xuICAgIH1cbiAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gY29udGFjdC5tX25vZGVCO1xuICAgIC8vIFdha2UgdXAgdGhlIGJvZGllc1xuICAgIGlmICghZml4dHVyZUEuaXNTZW5zb3IoKSAmJiAhZml4dHVyZUIuaXNTZW5zb3IoKSkge1xuICAgICAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWN0O1xufTtcblxuQ29udGFjdC5kZXN0cm95ID0gZnVuY3Rpb24oY29udGFjdCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0Lm1fZml4dHVyZUE7XG4gICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5tX2ZpeHR1cmVCO1xuICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLmdldEJvZHkoKTtcbiAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5nZXRCb2R5KCk7XG4gICAgaWYgKGNvbnRhY3QuaXNUb3VjaGluZygpKSB7XG4gICAgICAgIGxpc3RlbmVyLmVuZENvbnRhY3QoY29udGFjdCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBmcm9tIGJvZHkgMVxuICAgIGlmIChjb250YWN0Lm1fbm9kZUEucHJldikge1xuICAgICAgICBjb250YWN0Lm1fbm9kZUEucHJldi5uZXh0ID0gY29udGFjdC5tX25vZGVBLm5leHQ7XG4gICAgfVxuICAgIGlmIChjb250YWN0Lm1fbm9kZUEubmV4dCkge1xuICAgICAgICBjb250YWN0Lm1fbm9kZUEubmV4dC5wcmV2ID0gY29udGFjdC5tX25vZGVBLnByZXY7XG4gICAgfVxuICAgIGlmIChjb250YWN0Lm1fbm9kZUEgPT09IGJvZHlBLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgYm9keUEubV9jb250YWN0TGlzdCA9IGNvbnRhY3QubV9ub2RlQS5uZXh0O1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDJcbiAgICBpZiAoY29udGFjdC5tX25vZGVCLnByZXYpIHtcbiAgICAgICAgY29udGFjdC5tX25vZGVCLnByZXYubmV4dCA9IGNvbnRhY3QubV9ub2RlQi5uZXh0O1xuICAgIH1cbiAgICBpZiAoY29udGFjdC5tX25vZGVCLm5leHQpIHtcbiAgICAgICAgY29udGFjdC5tX25vZGVCLm5leHQucHJldiA9IGNvbnRhY3QubV9ub2RlQi5wcmV2O1xuICAgIH1cbiAgICBpZiAoY29udGFjdC5tX25vZGVCID09PSBib2R5Qi5tX2NvbnRhY3RMaXN0KSB7XG4gICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QgPSBjb250YWN0Lm1fbm9kZUIubmV4dDtcbiAgICB9XG4gICAgaWYgKGNvbnRhY3QubV9tYW5pZm9sZC5wb2ludENvdW50ID4gMCAmJiAhZml4dHVyZUEuaXNTZW5zb3IoKSAmJiAhZml4dHVyZUIuaXNTZW5zb3IoKSkge1xuICAgICAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgfVxuICAgIHZhciB0eXBlQSA9IGZpeHR1cmVBLmdldFR5cGUoKTtcbiAgICAvLyBTaGFwZS5UeXBlXG4gICAgdmFyIHR5cGVCID0gZml4dHVyZUIuZ2V0VHlwZSgpO1xuICAgIC8vIFNoYXBlLlR5cGVcbiAgICB2YXIgZGVzdHJveUZjbiA9IHNfcmVnaXN0ZXJzW3R5cGVBXVt0eXBlQl0uZGVzdHJveUZjbjtcbiAgICBpZiAodHlwZW9mIGRlc3Ryb3lGY24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkZXN0cm95RmNuKGNvbnRhY3QpO1xuICAgIH1cbiAgICBjb250YWN0UG9vbC5yZWxlYXNlKGNvbnRhY3QpO1xufTtcblxuXG59LHtcIi4vTWFuaWZvbGRcIjo2LFwiLi9TZXR0aW5nc1wiOjcsXCIuL2NvbGxpc2lvbi9EaXN0YW5jZVwiOjEzLFwiLi9jb21tb24vTWF0MjJcIjoxNixcIi4vY29tbW9uL01hdGhcIjoxOCxcIi4vY29tbW9uL1JvdFwiOjIwLFwiLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuL2NvbW1vbi9WZWMyXCI6MjMsXCIuL3V0aWwvUG9vbFwiOjQ4LFwiLi91dGlsL2NvbW1vblwiOjUwfV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRml4dHVyZTtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgb3B0aW9ucyA9IHJlcXVpcmUoXCIuL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi9jb21tb24vVmVjMlwiKTtcblxudmFyIEFBQkIgPSByZXF1aXJlKFwiLi9jb2xsaXNpb24vQUFCQlwiKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaXh0dXJlRGVmXG4gKlxuICogQSBmaXh0dXJlIGRlZmluaXRpb24gaXMgdXNlZCB0byBjcmVhdGUgYSBmaXh0dXJlLiBUaGlzIGNsYXNzIGRlZmluZXMgYW5cbiAqIGFic3RyYWN0IGZpeHR1cmUgZGVmaW5pdGlvbi4gWW91IGNhbiByZXVzZSBmaXh0dXJlIGRlZmluaXRpb25zIHNhZmVseS5cbiAqIFxuICogQHByb3AgZnJpY3Rpb24gVGhlIGZyaWN0aW9uIGNvZWZmaWNpZW50LCB1c3VhbGx5IGluIHRoZSByYW5nZSBbMCwxXVxuICogQHByb3AgcmVzdGl0dXRpb24gVGhlIHJlc3RpdHV0aW9uIChlbGFzdGljaXR5KSB1c3VhbGx5IGluIHRoZSByYW5nZSBbMCwxXVxuICogQHByb3AgZGVuc2l0eSBUaGUgZGVuc2l0eSwgdXN1YWxseSBpbiBrZy9tXjJcbiAqIEBwcm9wIGlzU2Vuc29yIEEgc2Vuc29yIHNoYXBlIGNvbGxlY3RzIGNvbnRhY3QgaW5mb3JtYXRpb24gYnV0IG5ldmVyXG4gKiAgICAgICBnZW5lcmF0ZXMgYSBjb2xsaXNpb24gcmVzcG9uc2VcbiAqIEBwcm9wIHVzZXJEYXRhXG4gKiBAcHJvcCBmaWx0ZXJHcm91cEluZGV4IFplcm8sIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGNvbGxpc2lvbiBncm91cC4gRml4dHVyZXMgd2l0aCBzYW1lIHBvc2l0aXZlIGdyb3VwSW5kZXggYWx3YXlzIGNvbGxpZGUgYW5kIGZpeHR1cmVzIHdpdGggc2FtZVxuICogbmVnYXRpdmUgZ3JvdXBJbmRleCBuZXZlciBjb2xsaWRlLlxuICogQHByb3AgZmlsdGVyQ2F0ZWdvcnlCaXRzIENvbGxpc2lvbiBjYXRlZ29yeSBiaXQgb3IgYml0cyB0aGF0IHRoaXMgZml4dHVyZSBiZWxvbmdzXG4gKiAgICAgICB0by4gSWYgZ3JvdXBJbmRleCBpcyB6ZXJvIG9yIG5vdCBtYXRjaGluZywgdGhlbiBhdCBsZWFzdCBvbmUgYml0IGluIHRoaXMgZml4dHVyZVxuICogY2F0ZWdvcnlCaXRzIHNob3VsZCBtYXRjaCBvdGhlciBmaXh0dXJlIG1hc2tCaXRzIGFuZCB2aWNlIHZlcnNhLlxuICogQHByb3AgZmlsdGVyTWFza0JpdHMgQ29sbGlzaW9uIGNhdGVnb3J5IGJpdCBvciBiaXRzIHRoYXQgdGhpcyBmaXh0dXJlIGFjY2VwdCBmb3JcbiAqICAgICAgIGNvbGxpc2lvbi5cbiAqL1xudmFyIEZpeHR1cmVEZWYgPSB7XG4gICAgdXNlckRhdGE6IG51bGwsXG4gICAgZnJpY3Rpb246IC4yLFxuICAgIHJlc3RpdHV0aW9uOiAwLFxuICAgIGRlbnNpdHk6IDAsXG4gICAgaXNTZW5zb3I6IGZhbHNlLFxuICAgIGZpbHRlckdyb3VwSW5kZXg6IDAsXG4gICAgZmlsdGVyQ2F0ZWdvcnlCaXRzOiAxLFxuICAgIGZpbHRlck1hc2tCaXRzOiA2NTUzNVxufTtcblxuLyoqXG4gKiBUaGlzIHByb3h5IGlzIHVzZWQgaW50ZXJuYWxseSB0byBjb25uZWN0IHNoYXBlIGNoaWxkcmVuIHRvIHRoZSBicm9hZC1waGFzZS5cbiAqL1xuZnVuY3Rpb24gRml4dHVyZVByb3h5KGZpeHR1cmUsIGNoaWxkSW5kZXgpIHtcbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuICAgIHRoaXMuZml4dHVyZSA9IGZpeHR1cmU7XG4gICAgdGhpcy5jaGlsZEluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB0aGlzLnByb3h5SWQ7XG59XG5cbi8qKlxuICogQSBmaXh0dXJlIGlzIHVzZWQgdG8gYXR0YWNoIGEgc2hhcGUgdG8gYSBib2R5IGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLiBBXG4gKiBmaXh0dXJlIGluaGVyaXRzIGl0cyB0cmFuc2Zvcm0gZnJvbSBpdHMgcGFyZW50LiBGaXh0dXJlcyBob2xkIGFkZGl0aW9uYWxcbiAqIG5vbi1nZW9tZXRyaWMgZGF0YSBzdWNoIGFzIGZyaWN0aW9uLCBjb2xsaXNpb24gZmlsdGVycywgZXRjLiBGaXh0dXJlcyBhcmVcbiAqIGNyZWF0ZWQgdmlhIEJvZHkuY3JlYXRlRml4dHVyZS5cbiAqIFxuICogQHBhcmFtIHtTaGFwZXxGaXh0dXJlRGVmfSBzaGFwZSBTaGFwZSBvZiBmaXh0dXJlIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge0ZpeHR1cmVEZWZ8bnVtYmVyfSBkZWYgRml4dHVyZSBkZWZpbml0aW9uIG9yIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gRml4dHVyZShib2R5LCBzaGFwZSwgZGVmKSB7XG4gICAgaWYgKHNoYXBlLnNoYXBlKSB7XG4gICAgICAgIGRlZiA9IHNoYXBlO1xuICAgICAgICBzaGFwZSA9IHNoYXBlLnNoYXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkZWYgPSB7XG4gICAgICAgICAgICBkZW5zaXR5OiBkZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGVmID0gb3B0aW9ucyhkZWYsIEZpeHR1cmVEZWYpO1xuICAgIHRoaXMubV9ib2R5ID0gYm9keTtcbiAgICB0aGlzLm1fZnJpY3Rpb24gPSBkZWYuZnJpY3Rpb247XG4gICAgdGhpcy5tX3Jlc3RpdHV0aW9uID0gZGVmLnJlc3RpdHV0aW9uO1xuICAgIHRoaXMubV9kZW5zaXR5ID0gZGVmLmRlbnNpdHk7XG4gICAgdGhpcy5tX2lzU2Vuc29yID0gZGVmLmlzU2Vuc29yO1xuICAgIHRoaXMubV9maWx0ZXJHcm91cEluZGV4ID0gZGVmLmZpbHRlckdyb3VwSW5kZXg7XG4gICAgdGhpcy5tX2ZpbHRlckNhdGVnb3J5Qml0cyA9IGRlZi5maWx0ZXJDYXRlZ29yeUJpdHM7XG4gICAgdGhpcy5tX2ZpbHRlck1hc2tCaXRzID0gZGVmLmZpbHRlck1hc2tCaXRzO1xuICAgIC8vIFRPRE8gdmFsaWRhdGUgc2hhcGVcbiAgICB0aGlzLm1fc2hhcGUgPSBzaGFwZTtcbiAgICAvLy5jbG9uZSgpO1xuICAgIHRoaXMubV9uZXh0ID0gbnVsbDtcbiAgICB0aGlzLm1fcHJveGllcyA9IFtdO1xuICAgIHRoaXMubV9wcm94eUNvdW50ID0gMDtcbiAgICB2YXIgY2hpbGRDb3VudCA9IHRoaXMubV9zaGFwZS5nZXRDaGlsZENvdW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgdGhpcy5tX3Byb3hpZXNbaV0gPSBuZXcgRml4dHVyZVByb3h5KHRoaXMsIGkpO1xuICAgIH1cbiAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBjaGlsZCBzaGFwZS4gWW91IGNhbiB1c2UgdGhpcyB0byBkb3duIGNhc3QgdG8gdGhlXG4gKiBjb25jcmV0ZSBzaGFwZS5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fc2hhcGUuZ2V0VHlwZSgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNoaWxkIHNoYXBlLiBZb3UgY2FuIG1vZGlmeSB0aGUgY2hpbGQgc2hhcGUsIGhvd2V2ZXIgeW91IHNob3VsZCBub3RcbiAqIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGJlY2F1c2UgdGhpcyB3aWxsIGNyYXNoIHNvbWUgY29sbGlzaW9uIGNhY2hpbmdcbiAqIG1lY2hhbmlzbXMuIE1hbmlwdWxhdGluZyB0aGUgc2hhcGUgbWF5IGxlYWQgdG8gbm9uLXBoeXNpY2FsIGJlaGF2aW9yLlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5nZXRTaGFwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fc2hhcGU7XG59O1xuXG4vKipcbiAqIEEgc2Vuc29yIHNoYXBlIGNvbGxlY3RzIGNvbnRhY3QgaW5mb3JtYXRpb24gYnV0IG5ldmVyIGdlbmVyYXRlcyBhIGNvbGxpc2lvblxuICogcmVzcG9uc2UuXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLmlzU2Vuc29yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9pc1NlbnNvcjtcbn07XG5cbi8qKlxuICogU2V0IGlmIHRoaXMgZml4dHVyZSBpcyBhIHNlbnNvci5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuc2V0U2Vuc29yID0gZnVuY3Rpb24oc2Vuc29yKSB7XG4gICAgaWYgKHNlbnNvciAhPSB0aGlzLm1faXNTZW5zb3IpIHtcbiAgICAgICAgdGhpcy5tX2JvZHkuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIHRoaXMubV9pc1NlbnNvciA9IHNlbnNvcjtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29udGFjdCBmaWx0ZXJpbmcgZGF0YS5cbiAqL1xuLy8gRml4dHVyZS5wcm90b3R5cGUuZ2V0RmlsdGVyRGF0YSA9IGZ1bmN0aW9uKCkge1xuLy8gICByZXR1cm4gdGhpcy5tX2ZpbHRlcjtcbi8vIH1cbi8qKlxuICogR2V0IHRoZSB1c2VyIGRhdGEgdGhhdCB3YXMgYXNzaWduZWQgaW4gdGhlIGZpeHR1cmUgZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG9cbiAqIHN0b3JlIHlvdXIgYXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YS5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3VzZXJEYXRhO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHVzZXIgZGF0YS4gVXNlIHRoaXMgdG8gc3RvcmUgeW91ciBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhLlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5zZXRVc2VyRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLm1fdXNlckRhdGEgPSBkYXRhO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBhcmVudCBib2R5IG9mIHRoaXMgZml4dHVyZS4gVGhpcyBpcyBudWxsIGlmIHRoZSBmaXh0dXJlIGlzIG5vdFxuICogYXR0YWNoZWQuXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBmaXh0dXJlIGluIHRoZSBwYXJlbnQgYm9keSdzIGZpeHR1cmUgbGlzdC5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkZW5zaXR5IG9mIHRoaXMgZml4dHVyZS5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuZ2V0RGVuc2l0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZGVuc2l0eTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZW5zaXR5IG9mIHRoaXMgZml4dHVyZS4gVGhpcyB3aWxsIF9ub3RfIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZVxuICogbWFzcyBvZiB0aGUgYm9keS4gWW91IG11c3QgY2FsbCBCb2R5LnJlc2V0TWFzc0RhdGEgdG8gdXBkYXRlIHRoZSBib2R5J3MgbWFzcy5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuc2V0RGVuc2l0eSA9IGZ1bmN0aW9uKGRlbnNpdHkpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoTWF0aC5pc0Zpbml0ZShkZW5zaXR5KSAmJiBkZW5zaXR5ID49IDApO1xuICAgIHRoaXMubV9kZW5zaXR5ID0gZGVuc2l0eTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbiwgdXN1YWxseSBpbiB0aGUgcmFuZ2UgWzAsMV0uXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLmdldEZyaWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9mcmljdGlvbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbi4gVGhpcyB3aWxsIG5vdCBjaGFuZ2UgdGhlIGZyaWN0aW9uIG9mXG4gKiBleGlzdGluZyBjb250YWN0cy5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbihmcmljdGlvbikge1xuICAgIHRoaXMubV9mcmljdGlvbiA9IGZyaWN0aW9uO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uLlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5nZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fcmVzdGl0dXRpb247XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24uIFRoaXMgd2lsbCBub3QgY2hhbmdlIHRoZSByZXN0aXR1dGlvbiBvZlxuICogZXhpc3RpbmcgY29udGFjdHMuXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLnNldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24ocmVzdGl0dXRpb24pIHtcbiAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSByZXN0aXR1dGlvbjtcbn07XG5cbi8qKlxuICogVGVzdCBhIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzIGZvciBjb250YWlubWVudCBpbiB0aGlzIGZpeHR1cmUuXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gdGhpcy5tX3NoYXBlLnRlc3RQb2ludCh0aGlzLm1fYm9keS5nZXRUcmFuc2Zvcm0oKSwgcCk7XG59O1xuXG4vKipcbiAqIENhc3QgYSByYXkgYWdhaW5zdCB0aGlzIHNoYXBlLlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24ob3V0cHV0LCBpbnB1dCwgY2hpbGRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1fc2hhcGUucmF5Q2FzdChvdXRwdXQsIGlucHV0LCB0aGlzLm1fYm9keS5nZXRUcmFuc2Zvcm0oKSwgY2hpbGRJbmRleCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWFzcyBkYXRhIGZvciB0aGlzIGZpeHR1cmUuIFRoZSBtYXNzIGRhdGEgaXMgYmFzZWQgb24gdGhlIGRlbnNpdHkgYW5kXG4gKiB0aGUgc2hhcGUuIFRoZSByb3RhdGlvbmFsIGluZXJ0aWEgaXMgYWJvdXQgdGhlIHNoYXBlJ3Mgb3JpZ2luLiBUaGlzIG9wZXJhdGlvblxuICogbWF5IGJlIGV4cGVuc2l2ZS5cbiAqL1xuRml4dHVyZS5wcm90b3R5cGUuZ2V0TWFzc0RhdGEgPSBmdW5jdGlvbihtYXNzRGF0YSkge1xuICAgIHRoaXMubV9zaGFwZS5jb21wdXRlTWFzcyhtYXNzRGF0YSwgdGhpcy5tX2RlbnNpdHkpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpeHR1cmUncyBBQUJCLiBUaGlzIEFBQkIgbWF5IGJlIGVubGFyZ2UgYW5kL29yIHN0YWxlLiBJZiB5b3UgbmVlZCBhXG4gKiBtb3JlIGFjY3VyYXRlIEFBQkIsIGNvbXB1dGUgaXQgdXNpbmcgdGhlIHNoYXBlIGFuZCB0aGUgYm9keSB0cmFuc2Zvcm0uXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLmdldEFBQkIgPSBmdW5jdGlvbihjaGlsZEluZGV4KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gY2hpbGRJbmRleCAmJiBjaGlsZEluZGV4IDwgdGhpcy5tX3Byb3h5Q291bnQpO1xuICAgIHJldHVybiB0aGlzLm1fcHJveGllc1tjaGlsZEluZGV4XS5hYWJiO1xufTtcblxuLyoqXG4gKiBUaGVzZSBzdXBwb3J0IGJvZHkgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24uXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLmNyZWF0ZVByb3hpZXMgPSBmdW5jdGlvbihicm9hZFBoYXNlLCB4Zikge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0aGlzLm1fcHJveHlDb3VudCA9PSAwKTtcbiAgICAvLyBDcmVhdGUgcHJveGllcyBpbiB0aGUgYnJvYWQtcGhhc2UuXG4gICAgdGhpcy5tX3Byb3h5Q291bnQgPSB0aGlzLm1fc2hhcGUuZ2V0Q2hpbGRDb3VudCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICB2YXIgcHJveHkgPSB0aGlzLm1fcHJveGllc1tpXTtcbiAgICAgICAgdGhpcy5tX3NoYXBlLmNvbXB1dGVBQUJCKHByb3h5LmFhYmIsIHhmLCBpKTtcbiAgICAgICAgcHJveHkucHJveHlJZCA9IGJyb2FkUGhhc2UuY3JlYXRlUHJveHkocHJveHkuYWFiYiwgcHJveHkpO1xuICAgIH1cbn07XG5cbkZpeHR1cmUucHJvdG90eXBlLmRlc3Ryb3lQcm94aWVzID0gZnVuY3Rpb24oYnJvYWRQaGFzZSkge1xuICAgIC8vIERlc3Ryb3kgcHJveGllcyBpbiB0aGUgYnJvYWQtcGhhc2UuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fcHJveHlDb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBwcm94eSA9IHRoaXMubV9wcm94aWVzW2ldO1xuICAgICAgICBicm9hZFBoYXNlLmRlc3Ryb3lQcm94eShwcm94eS5wcm94eUlkKTtcbiAgICAgICAgcHJveHkucHJveHlJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubV9wcm94eUNvdW50ID0gMDtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIGZpeHR1cmUgcHJveHkgaW4gYnJvYWQtcGhhc2UgKHdpdGggY29tYmluZWQgQUFCQiBvZiBjdXJyZW50IGFuZFxuICogbmV4dCB0cmFuc2Zvcm1hdGlvbikuXG4gKi9cbkZpeHR1cmUucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oYnJvYWRQaGFzZSwgeGYxLCB4ZjIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9wcm94eUNvdW50OyArK2kpIHtcbiAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5tX3Byb3hpZXNbaV07XG4gICAgICAgIC8vIENvbXB1dGUgYW4gQUFCQiB0aGF0IGNvdmVycyB0aGUgc3dlcHQgc2hhcGUgKG1heSBtaXNzIHNvbWUgcm90YXRpb25cbiAgICAgICAgLy8gZWZmZWN0KS5cbiAgICAgICAgdmFyIGFhYmIxID0gbmV3IEFBQkIoKTtcbiAgICAgICAgdmFyIGFhYmIyID0gbmV3IEFBQkIoKTtcbiAgICAgICAgdGhpcy5tX3NoYXBlLmNvbXB1dGVBQUJCKGFhYmIxLCB4ZjEsIHByb3h5LmNoaWxkSW5kZXgpO1xuICAgICAgICB0aGlzLm1fc2hhcGUuY29tcHV0ZUFBQkIoYWFiYjIsIHhmMiwgcHJveHkuY2hpbGRJbmRleCk7XG4gICAgICAgIHByb3h5LmFhYmIuY29tYmluZShhYWJiMSwgYWFiYjIpO1xuICAgICAgICB2YXIgZGlzcGxhY2VtZW50ID0gVmVjMi5zdWIoeGYyLnAsIHhmMS5wKTtcbiAgICAgICAgYnJvYWRQaGFzZS5tb3ZlUHJveHkocHJveHkucHJveHlJZCwgcHJveHkuYWFiYiwgZGlzcGxhY2VtZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29udGFjdCBmaWx0ZXJpbmcgZGF0YS4gVGhpcyB3aWxsIG5vdCB1cGRhdGUgY29udGFjdHMgdW50aWwgdGhlIG5leHRcbiAqIHRpbWUgc3RlcCB3aGVuIGVpdGhlciBwYXJlbnQgYm9keSBpcyBhY3RpdmUgYW5kIGF3YWtlLiBUaGlzIGF1dG9tYXRpY2FsbHlcbiAqIGNhbGxzIHJlZmlsdGVyLlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5zZXRGaWx0ZXJEYXRhID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdGhpcy5tX2ZpbHRlckdyb3VwSW5kZXggPSBmaWx0ZXIuZ3JvdXBJbmRleDtcbiAgICB0aGlzLm1fZmlsdGVyQ2F0ZWdvcnlCaXRzID0gZmlsdGVyLmNhdGVnb3J5Qml0cztcbiAgICB0aGlzLm1fZmlsdGVyTWFza0JpdHMgPSBmaWx0ZXIubWFza0JpdHM7XG4gICAgdGhpcy5yZWZpbHRlcigpO1xufTtcblxuRml4dHVyZS5wcm90b3R5cGUuZ2V0RmlsdGVyR3JvdXBJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZmlsdGVyR3JvdXBJbmRleDtcbn07XG5cbkZpeHR1cmUucHJvdG90eXBlLmdldEZpbHRlckNhdGVnb3J5Qml0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZmlsdGVyQ2F0ZWdvcnlCaXRzO1xufTtcblxuRml4dHVyZS5wcm90b3R5cGUuZ2V0RmlsdGVyTWFza0JpdHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2ZpbHRlck1hc2tCaXRzO1xufTtcblxuLyoqXG4gKiBDYWxsIHRoaXMgaWYgeW91IHdhbnQgdG8gZXN0YWJsaXNoIGNvbGxpc2lvbiB0aGF0IHdhcyBwcmV2aW91c2x5IGRpc2FibGVkIGJ5XG4gKiBDb250YWN0RmlsdGVyLlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5yZWZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1fYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmxhZyBhc3NvY2lhdGVkIGNvbnRhY3RzIGZvciBmaWx0ZXJpbmcuXG4gICAgdmFyIGVkZ2UgPSB0aGlzLm1fYm9keS5nZXRDb250YWN0TGlzdCgpO1xuICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgIHZhciBjb250YWN0ID0gZWRnZS5jb250YWN0O1xuICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0LmdldEZpeHR1cmVBKCk7XG4gICAgICAgIHZhciBmaXh0dXJlQiA9IGNvbnRhY3QuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgaWYgKGZpeHR1cmVBID09IHRoaXMgfHwgZml4dHVyZUIgPT0gdGhpcykge1xuICAgICAgICAgICAgY29udGFjdC5mbGFnRm9yRmlsdGVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICB9XG4gICAgdmFyIHdvcmxkID0gdGhpcy5tX2JvZHkuZ2V0V29ybGQoKTtcbiAgICBpZiAod29ybGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRvdWNoIGVhY2ggcHJveHkgc28gdGhhdCBuZXcgcGFpcnMgbWF5IGJlIGNyZWF0ZWRcbiAgICB2YXIgYnJvYWRQaGFzZSA9IHdvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9wcm94eUNvdW50OyArK2kpIHtcbiAgICAgICAgYnJvYWRQaGFzZS50b3VjaFByb3h5KHRoaXMubV9wcm94aWVzW2ldLnByb3h5SWQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgY29sbGlzaW9uIGZpbHRlcmluZywgaWYgeW91IHdhbnQgZmluZXJcbiAqIGNvbnRyb2wgb3ZlciBjb250YWN0IGNyZWF0aW9uLlxuICogXG4gKiBSZXR1cm4gdHJ1ZSBpZiBjb250YWN0IGNhbGN1bGF0aW9ucyBzaG91bGQgYmUgcGVyZm9ybWVkIGJldHdlZW4gdGhlc2UgdHdvXG4gKiBmaXh0dXJlcy5cbiAqIFxuICogV2FybmluZzogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgdGhpcyBpcyBvbmx5IGNhbGxlZCB3aGVuIHRoZSBBQUJCcyBiZWdpbiB0b1xuICogb3ZlcmxhcC5cbiAqIFxuICogQHBhcmFtIHtGaXh0dXJlfSBmaXh0dXJlQVxuICogQHBhcmFtIHtGaXh0dXJlfSBmaXh0dXJlQlxuICovXG5GaXh0dXJlLnByb3RvdHlwZS5zaG91bGRDb2xsaWRlID0gZnVuY3Rpb24odGhhdCkge1xuICAgIGlmICh0aGF0Lm1fZmlsdGVyR3JvdXBJbmRleCA9PSB0aGlzLm1fZmlsdGVyR3JvdXBJbmRleCAmJiB0aGF0Lm1fZmlsdGVyR3JvdXBJbmRleCAhPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGF0Lm1fZmlsdGVyR3JvdXBJbmRleCA+IDA7XG4gICAgfVxuICAgIHZhciBjb2xsaWRlID0gKHRoYXQubV9maWx0ZXJNYXNrQml0cyAmIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMpICE9IDAgJiYgKHRoYXQubV9maWx0ZXJDYXRlZ29yeUJpdHMgJiB0aGlzLm1fZmlsdGVyTWFza0JpdHMpICE9IDA7XG4gICAgcmV0dXJuIGNvbGxpZGU7XG59O1xuXG5cbn0se1wiLi9jb2xsaXNpb24vQUFCQlwiOjExLFwiLi9jb21tb24vTWF0aFwiOjE4LFwiLi9jb21tb24vVmVjMlwiOjIzLFwiLi91dGlsL2NvbW1vblwiOjUwLFwiLi91dGlsL29wdGlvbnNcIjo1Mn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpvaW50O1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4vdXRpbC9jb21tb25cIik7XG5cbi8qKlxuICogQSBqb2ludCBlZGdlIGlzIHVzZWQgdG8gY29ubmVjdCBib2RpZXMgYW5kIGpvaW50cyB0b2dldGhlciBpbiBhIGpvaW50IGdyYXBoXG4gKiB3aGVyZSBlYWNoIGJvZHkgaXMgYSBub2RlIGFuZCBlYWNoIGpvaW50IGlzIGFuIGVkZ2UuIEEgam9pbnQgZWRnZSBiZWxvbmdzIHRvXG4gKiBhIGRvdWJseSBsaW5rZWQgbGlzdCBtYWludGFpbmVkIGluIGVhY2ggYXR0YWNoZWQgYm9keS4gRWFjaCBqb2ludCBoYXMgdHdvXG4gKiBqb2ludCBub2Rlcywgb25lIGZvciBlYWNoIGF0dGFjaGVkIGJvZHkuXG4gKiBcbiAqIEBwcm9wIHtCb2R5fSBvdGhlciBwcm92aWRlcyBxdWljayBhY2Nlc3MgdG8gdGhlIG90aGVyIGJvZHkgYXR0YWNoZWQuXG4gKiBAcHJvcCB7Sm9pbnR9IGpvaW50IHRoZSBqb2ludFxuICogQHByb3Age0pvaW50RWRnZX0gcHJldiB0aGUgcHJldmlvdXMgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3RcbiAqIEBwcm9wIHtKb2ludEVkZ2V9IG5leHQgdGhlIG5leHQgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3RcbiAqL1xuZnVuY3Rpb24gSm9pbnRFZGdlKCkge1xuICAgIHRoaXMub3RoZXIgPSBudWxsO1xuICAgIHRoaXMuam9pbnQgPSBudWxsO1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBKb2ludERlZlxuICpcbiAqIEpvaW50IGRlZmluaXRpb25zIGFyZSB1c2VkIHRvIGNvbnN0cnVjdCBqb2ludHMuXG4gKiBcbiAqIEBwcm9wIHVzZXJEYXRhIFVzZSB0aGlzIHRvIGF0dGFjaCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhIHRvIHlvdXIgam9pbnRzLlxuICogICAgICAgdm9pZCB1c2VyRGF0YTtcbiAqIEBwcm9wIHtib29sZWFufSBjb2xsaWRlQ29ubmVjdGVkIFNldCB0aGlzIGZsYWcgdG8gdHJ1ZSBpZiB0aGUgYXR0YWNoZWQgYm9kaWVzXG4gKiAgICAgICBzaG91bGQgY29sbGlkZS5cbiAqXG4gKiBAcHJvcCB7Qm9keX0gYm9keUEgVGhlIGZpcnN0IGF0dGFjaGVkIGJvZHkuXG4gKiBAcHJvcCB7Qm9keX0gYm9keUIgVGhlIHNlY29uZCBhdHRhY2hlZCBib2R5LlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gICAgdXNlckRhdGE6IG51bGwsXG4gICAgY29sbGlkZUNvbm5lY3RlZDogZmFsc2Vcbn07XG5cbi8qKlxuICogVGhlIGJhc2Ugam9pbnQgY2xhc3MuIEpvaW50cyBhcmUgdXNlZCB0byBjb25zdHJhaW50IHR3byBib2RpZXMgdG9nZXRoZXIgaW5cbiAqIHZhcmlvdXMgZmFzaGlvbnMuIFNvbWUgam9pbnRzIGFsc28gZmVhdHVyZSBsaW1pdHMgYW5kIG1vdG9ycy5cbiAqIFxuICogQHBhcmFtIHtKb2ludERlZn0gZGVmXG4gKi9cbmZ1bmN0aW9uIEpvaW50KGRlZiwgYm9keUEsIGJvZHlCKSB7XG4gICAgYm9keUEgPSBkZWYuYm9keUEgfHwgYm9keUE7XG4gICAgYm9keUIgPSBkZWYuYm9keUIgfHwgYm9keUI7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGJvZHlBKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoYm9keUIpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChib2R5QSAhPSBib2R5Qik7XG4gICAgdGhpcy5tX3R5cGUgPSBcInVua25vd24tam9pbnRcIjtcbiAgICB0aGlzLm1fYm9keUEgPSBib2R5QTtcbiAgICB0aGlzLm1fYm9keUIgPSBib2R5QjtcbiAgICB0aGlzLm1faW5kZXggPSAwO1xuICAgIHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkID0gISFkZWYuY29sbGlkZUNvbm5lY3RlZDtcbiAgICB0aGlzLm1fcHJldiA9IG51bGw7XG4gICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgIHRoaXMubV9lZGdlQSA9IG5ldyBKb2ludEVkZ2UoKTtcbiAgICB0aGlzLm1fZWRnZUIgPSBuZXcgSm9pbnRFZGdlKCk7XG4gICAgdGhpcy5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG59XG5cbi8qKlxuICogU2hvcnQtY3V0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBlaXRoZXIgYm9keSBpcyBpbmFjdGl2ZS5cbiAqIFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkpvaW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYm9keUEuaXNBY3RpdmUoKSAmJiB0aGlzLm1fYm9keUIuaXNBY3RpdmUoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBjb25jcmV0ZSBqb2ludC5cbiAqIFxuICogQHJldHVybnMgSm9pbnRUeXBlXG4gKi9cbkpvaW50LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV90eXBlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGJvZHkgYXR0YWNoZWQgdG8gdGhpcyBqb2ludC5cbiAqIFxuICogQHJldHVybnMgQm9keVxuICovXG5Kb2ludC5wcm90b3R5cGUuZ2V0Qm9keUEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlBO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlY29uZCBib2R5IGF0dGFjaGVkIHRvIHRoaXMgam9pbnQuXG4gKiBcbiAqIEByZXR1cm5zIEJvZHlcbiAqL1xuSm9pbnQucHJvdG90eXBlLmdldEJvZHlCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGpvaW50IHRoZSB3b3JsZCBqb2ludCBsaXN0LlxuICogXG4gKiBAcmV0dXJucyBKb2ludFxuICovXG5Kb2ludC5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbn07XG5cbkpvaW50LnByb3RvdHlwZS5nZXRVc2VyRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG59O1xuXG5Kb2ludC5wcm90b3R5cGUuc2V0VXNlckRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5tX3VzZXJEYXRhID0gZGF0YTtcbn07XG5cbi8qKlxuICogR2V0IGNvbGxpZGUgY29ubmVjdGVkLiBOb3RlOiBtb2RpZnlpbmcgdGhlIGNvbGxpZGUgY29ubmVjdCBmbGFnIHdvbid0IHdvcmtcbiAqIGNvcnJlY3RseSBiZWNhdXNlIHRoZSBmbGFnIGlzIG9ubHkgY2hlY2tlZCB3aGVuIGZpeHR1cmUgQUFCQnMgYmVnaW4gdG9cbiAqIG92ZXJsYXAuXG4gKiBcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Kb2ludC5wcm90b3R5cGUuZ2V0Q29sbGlkZUNvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbkpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIFxuICogQHJldHVybiB7VmVjMn1cbiAqL1xuSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICogXG4gKiBAcGFyYW0ge2Zsb2F0fSBpbnZfZHRcbiAqIEByZXR1cm4ge1ZlYzJ9XG4gKi9cbkpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24oaW52X2R0KSB7fTtcblxuLyoqXG4gKiBHZXQgdGhlIHJlYWN0aW9uIHRvcnF1ZSBvbiBib2R5QiBpbiBOKm0uXG4gKiBcbiAqIEBwYXJhbSB7ZmxvYXR9IGludl9kdFxuICogQHJldHVybiB7ZmxvYXR9XG4gKi9cbkpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uKGludl9kdCkge307XG5cbi8qKlxuICogU2hpZnQgdGhlIG9yaWdpbiBmb3IgYW55IHBvaW50cyBzdG9yZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBcbiAqIEBwYXJhbSB7VmVjMn0gbmV3T3JpZ2luXG4gKi9cbkpvaW50LnByb3RvdHlwZS5zaGlmdE9yaWdpbiA9IGZ1bmN0aW9uKG5ld09yaWdpbikge307XG5cbi8qKlxuICovXG5Kb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7fTtcblxuLyoqXG4gKi9cbkpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7fTtcblxuLyoqXG4gKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICovXG5Kb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge307XG5cblxufSx7XCIuL3V0aWwvY29tbW9uXCI6NTB9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuL2NvbW1vbi9Sb3RcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFuaWZvbGQ7XG5cbm1vZHVsZS5leHBvcnRzLmNsaXBTZWdtZW50VG9MaW5lID0gY2xpcFNlZ21lbnRUb0xpbmU7XG5cbm1vZHVsZS5leHBvcnRzLmNsaXBWZXJ0ZXggPSBDbGlwVmVydGV4O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRQb2ludFN0YXRlcyA9IGdldFBvaW50U3RhdGVzO1xuXG5tb2R1bGUuZXhwb3J0cy5Qb2ludFN0YXRlID0gUG9pbnRTdGF0ZTtcblxuLy8gTWFuaWZvbGQgVHlwZVxuTWFuaWZvbGQuZV9jaXJjbGVzID0gMDtcblxuTWFuaWZvbGQuZV9mYWNlQSA9IDE7XG5cbk1hbmlmb2xkLmVfZmFjZUIgPSAyO1xuXG4vLyBDb250YWN0RmVhdHVyZSBUeXBlXG5NYW5pZm9sZC5lX3ZlcnRleCA9IDA7XG5cbk1hbmlmb2xkLmVfZmFjZSA9IDE7XG5cbi8qKlxuICogQSBtYW5pZm9sZCBmb3IgdHdvIHRvdWNoaW5nIGNvbnZleCBzaGFwZXMuIE1hbmlmb2xkcyBhcmUgY3JlYXRlZCBpbiBgZXZhbHVhdGVgXG4gKiBtZXRob2Qgb2YgQ29udGFjdCBzdWJjbGFzc2VzLlxuICogXG4gKiBTdXBwb3J0ZWQgbWFuaWZvbGQgdHlwZXMgYXJlIGVfZmFjZUEgb3IgZV9mYWNlQiBmb3IgY2xpcCBwb2ludCB2ZXJzdXMgcGxhbmVcbiAqIHdpdGggcmFkaXVzIGFuZCBlX2NpcmNsZXMgcG9pbnQgdmVyc3VzIHBvaW50IHdpdGggcmFkaXVzLlxuICogXG4gKiBXZSBzdG9yZSBjb250YWN0cyBpbiB0aGlzIHdheSBzbyB0aGF0IHBvc2l0aW9uIGNvcnJlY3Rpb24gY2FuIGFjY291bnQgZm9yXG4gKiBtb3ZlbWVudCwgd2hpY2ggaXMgY3JpdGljYWwgZm9yIGNvbnRpbnVvdXMgcGh5c2ljcy4gQWxsIGNvbnRhY3Qgc2NlbmFyaW9zXG4gKiBtdXN0IGJlIGV4cHJlc3NlZCBpbiBvbmUgb2YgdGhlc2UgdHlwZXMuIFRoaXMgc3RydWN0dXJlIGlzIHN0b3JlZCBhY3Jvc3MgdGltZVxuICogc3RlcHMsIHNvIHdlIGtlZXAgaXQgc21hbGwuXG4gKiBcbiAqIEBwcm9wIHR5cGUgZV9jaXJjbGUsIGVfZmFjZUEsIGVfZmFjZUJcbiAqIEBwcm9wIGxvY2FsUG9pbnQgVXNhZ2UgZGVwZW5kcyBvbiBtYW5pZm9sZCB0eXBlOjxicj5cbiAqICAgICAgIGVfY2lyY2xlczogdGhlIGxvY2FsIGNlbnRlciBvZiBjaXJjbGVBIDxicj5cbiAqICAgICAgIGVfZmFjZUE6IHRoZSBjZW50ZXIgb2YgZmFjZUEgPGJyPlxuICogICAgICAgZV9mYWNlQjogdGhlIGNlbnRlciBvZiBmYWNlQlxuICogQHByb3AgbG9jYWxOb3JtYWwgVXNhZ2UgZGVwZW5kcyBvbiBtYW5pZm9sZCB0eXBlOjxicj5cbiAqICAgICAgIGVfY2lyY2xlczogbm90IHVzZWQgPGJyPlxuICogICAgICAgZV9mYWNlQTogdGhlIG5vcm1hbCBvbiBwb2x5Z29uQSA8YnI+XG4gKiAgICAgICBlX2ZhY2VCOiB0aGUgbm9ybWFsIG9uIHBvbHlnb25CXG4gKiBAcHJvcCBwb2ludHMgVGhlIHBvaW50cyBvZiBjb250YWN0IHtNYW5pZm9sZFBvaW50W119XG4gKiBAcHJvcCBwb2ludENvdW50IFRoZSBudW1iZXIgb2YgbWFuaWZvbGQgcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIE1hbmlmb2xkKCkge1xuICAgIHRoaXMudHlwZSA9IC0xO1xuICAgIHRoaXMubG9jYWxOb3JtYWwgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLmxvY2FsUG9pbnQgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnBvaW50cyA9IFsgbmV3IE1hbmlmb2xkUG9pbnQoKSwgbmV3IE1hbmlmb2xkUG9pbnQoKSBdO1xuICAgIHRoaXMucG9pbnRDb3VudCA9IDA7XG59XG5cbk1hbmlmb2xkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50eXBlID0gLTE7XG4gICAgdGhpcy5sb2NhbE5vcm1hbC5zZXRaZXJvKCk7XG4gICAgdGhpcy5sb2NhbFBvaW50LnNldFplcm8oKTtcbiAgICB0aGlzLnBvaW50c1swXS5pbml0KCk7XG4gICAgdGhpcy5wb2ludHNbMV0uaW5pdCgpO1xuICAgIHRoaXMucG9pbnRDb3VudCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEEgbWFuaWZvbGQgcG9pbnQgaXMgYSBjb250YWN0IHBvaW50IGJlbG9uZ2luZyB0byBhIGNvbnRhY3QgbWFuaWZvbGQuIEl0IGhvbGRzXG4gKiBkZXRhaWxzIHJlbGF0ZWQgdG8gdGhlIGdlb21ldHJ5IGFuZCBkeW5hbWljcyBvZiB0aGUgY29udGFjdCBwb2ludHMuXG4gKiBcbiAqIFRoaXMgc3RydWN0dXJlIGlzIHN0b3JlZCBhY3Jvc3MgdGltZSBzdGVwcywgc28gd2Uga2VlcCBpdCBzbWFsbC5cbiAqIFxuICogTm90ZTogaW1wdWxzZXMgYXJlIHVzZWQgZm9yIGludGVybmFsIGNhY2hpbmcgYW5kIG1heSBub3QgcHJvdmlkZSByZWxpYWJsZVxuICogY29udGFjdCBmb3JjZXMsIGVzcGVjaWFsbHkgZm9yIGhpZ2ggc3BlZWQgY29sbGlzaW9ucy5cbiAqIFxuICogQHByb3Age1ZlYzJ9IGxvY2FsUG9pbnQgVXNhZ2UgZGVwZW5kcyBvbiBtYW5pZm9sZCB0eXBlOjxicj5cbiAqICAgICAgIGVfY2lyY2xlczogdGhlIGxvY2FsIGNlbnRlciBvZiBjaXJjbGVCPGJyPlxuICogICAgICAgZV9mYWNlQTogdGhlIGxvY2FsIGNlbnRlciBvZiBjaXJsY2VCIG9yIHRoZSBjbGlwIHBvaW50IG9mIHBvbHlnb25CPGJyPlxuICogICAgICAgZV9mYWNlQjogdGhlIGNsaXAgcG9pbnQgb2YgcG9seWdvbkEuXG4gKiBAcHJvcCBub3JtYWxJbXB1bHNlIFRoZSBub24tcGVuZXRyYXRpb24gaW1wdWxzZVxuICogQHByb3AgdGFuZ2VudEltcHVsc2UgVGhlIGZyaWN0aW9uIGltcHVsc2VcbiAqIEBwcm9wIHtDb250YWN0SUR9IGlkIFVuaXF1ZWx5IGlkZW50aWZpZXMgYSBjb250YWN0IHBvaW50IGJldHdlZW4gdHdvIHNoYXBlc1xuICogICAgICAgdG8gZmFjaWxhdGF0ZSB3YXJtIHN0YXJ0aW5nXG4gKi9cbmZ1bmN0aW9uIE1hbmlmb2xkUG9pbnQoKSB7XG4gICAgdGhpcy5sb2NhbFBvaW50ID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICB0aGlzLmlkID0gbmV3IENvbnRhY3RJRCgpO1xufVxuXG5NYW5pZm9sZFBvaW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2NhbFBvaW50LnNldFplcm8oKTtcbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSAwO1xuICAgIHRoaXMuaWQuaW5pdCgpO1xufTtcblxuLyoqXG4gKiBDb250YWN0IGlkcyB0byBmYWNpbGl0YXRlIHdhcm0gc3RhcnRpbmcuXG4gKiBcbiAqIEBwcm9wIHtDb250YWN0RmVhdHVyZX0gY2ZcbiAqIEBwcm9wIGtleSBVc2VkIHRvIHF1aWNrbHkgY29tcGFyZSBjb250YWN0IGlkcy5cbiAqIFxuICovXG5mdW5jdGlvbiBDb250YWN0SUQoKSB7XG4gICAgdGhpcy5jZiA9IG5ldyBDb250YWN0RmVhdHVyZSgpO1xufVxuXG5Db250YWN0SUQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNmLmluaXQoKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWN0SUQucHJvdG90eXBlLCBcImtleVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2YuaW5kZXhBICsgdGhpcy5jZi5pbmRleEIgKiA0ICsgdGhpcy5jZi50eXBlQSAqIDE2ICsgdGhpcy5jZi50eXBlQiAqIDY0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5Db250YWN0SUQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG8pIHtcbiAgICAvLyB0aGlzLmtleSA9IG8ua2V5O1xuICAgIHRoaXMuY2Yuc2V0KG8uY2YpO1xufTtcblxuLyoqXG4gKiBUaGUgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdG8gZm9ybSB0aGUgY29udGFjdCBwb2ludC5cbiAqIFxuICogQHByb3AgaW5kZXhBIEZlYXR1cmUgaW5kZXggb24gc2hhcGVBXG4gKiBAcHJvcCBpbmRleEIgRmVhdHVyZSBpbmRleCBvbiBzaGFwZUJcbiAqIEBwcm9wIHR5cGVBIFRoZSBmZWF0dXJlIHR5cGUgb24gc2hhcGVBXG4gKiBAcHJvcCB0eXBlQiBUaGUgZmVhdHVyZSB0eXBlIG9uIHNoYXBlQlxuICovXG5mdW5jdGlvbiBDb250YWN0RmVhdHVyZSgpIHtcbiAgICB0aGlzLmluZGV4QTtcbiAgICB0aGlzLmluZGV4QjtcbiAgICB0aGlzLnR5cGVBO1xuICAgIHRoaXMudHlwZUI7XG59XG5cbkNvbnRhY3RGZWF0dXJlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbmRleEEgPSAwO1xuICAgIHRoaXMuaW5kZXhCID0gMDtcbiAgICB0aGlzLnR5cGVBID0gMDtcbiAgICB0aGlzLnR5cGVCID0gMDtcbn07XG5cbkNvbnRhY3RGZWF0dXJlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvKSB7XG4gICAgdGhpcy5pbmRleEEgPSBvLmluZGV4QTtcbiAgICB0aGlzLmluZGV4QiA9IG8uaW5kZXhCO1xuICAgIHRoaXMudHlwZUEgPSBvLnR5cGVBO1xuICAgIHRoaXMudHlwZUIgPSBvLnR5cGVCO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIGNvbnRhY3QgbWFuaWZvbGQuXG4gKiBcbiAqIEBwcm9wIG5vcm1hbCBXb3JsZCB2ZWN0b3IgcG9pbnRpbmcgZnJvbSBBIHRvIEJcbiAqIEBwcm9wIHBvaW50cyBXb3JsZCBjb250YWN0IHBvaW50IChwb2ludCBvZiBpbnRlcnNlY3Rpb24pXG4gKiBAcHJvcCBzZXBhcmF0aW9ucyBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyBvdmVybGFwLCBpbiBtZXRlcnNcbiAqL1xuZnVuY3Rpb24gV29ybGRNYW5pZm9sZCgpIHtcbiAgICB0aGlzLm5vcm1hbDtcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIC8vIFttYXhNYW5pZm9sZFBvaW50c11cbiAgICB0aGlzLnNlcGFyYXRpb25zID0gW107XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIG1hbmlmb2xkIHdpdGggc3VwcGxpZWQgdHJhbnNmb3Jtcy4gVGhpcyBhc3N1bWVzIG1vZGVzdCBtb3Rpb25cbiAqIGZyb20gdGhlIG9yaWdpbmFsIHN0YXRlLiBUaGlzIGRvZXMgbm90IGNoYW5nZSB0aGUgcG9pbnQgY291bnQsIGltcHVsc2VzLCBldGMuXG4gKiBUaGUgcmFkaWkgbXVzdCBjb21lIGZyb20gdGhlIHNoYXBlcyB0aGF0IGdlbmVyYXRlZCB0aGUgbWFuaWZvbGQuXG4gKiBcbiAqIEBwYXJhbSB7V29ybGRNYW5pZm9sZH0gW3dtXVxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUuZ2V0V29ybGRNYW5pZm9sZCA9IGZ1bmN0aW9uKHdtLCB4ZkEsIHJhZGl1c0EsIHhmQiwgcmFkaXVzQikge1xuICAgIGlmICh0aGlzLnBvaW50Q291bnQgPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdtID0gd20gfHwgbmV3IFdvcmxkTWFuaWZvbGQoKTtcbiAgICB2YXIgbm9ybWFsID0gd20ubm9ybWFsO1xuICAgIHZhciBwb2ludHMgPSB3bS5wb2ludHM7XG4gICAgdmFyIHNlcGFyYXRpb25zID0gd20uc2VwYXJhdGlvbnM7XG4gICAgLy8gVE9ETzogaW1wcm92ZVxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIE1hbmlmb2xkLmVfY2lyY2xlczpcbiAgICAgICAgbm9ybWFsID0gVmVjMi5uZW8oMSwgMCk7XG4gICAgICAgIHZhciBwb2ludEEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHRoaXMubG9jYWxQb2ludCk7XG4gICAgICAgIHZhciBwb2ludEIgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIHRoaXMucG9pbnRzWzBdLmxvY2FsUG9pbnQpO1xuICAgICAgICB2YXIgZGlzdCA9IFZlYzIuc3ViKHBvaW50QiwgcG9pbnRBKTtcbiAgICAgICAgaWYgKFZlYzIubGVuZ3RoU3F1YXJlZChkaXN0KSA+IE1hdGguRVBTSUxPTiAqIE1hdGguRVBTSUxPTikge1xuICAgICAgICAgICAgbm9ybWFsLnNldChkaXN0KTtcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludHNbMF0gPSBWZWMyLm1pZChwb2ludEEsIHBvaW50Qik7XG4gICAgICAgIHNlcGFyYXRpb25zWzBdID0gLXJhZGl1c0IgLSByYWRpdXNBO1xuICAgICAgICBwb2ludHMubGVuZ3RoID0gMTtcbiAgICAgICAgc2VwYXJhdGlvbnMubGVuZ3RoID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTWFuaWZvbGQuZV9mYWNlQTpcbiAgICAgICAgbm9ybWFsID0gUm90Lm11bFZlYzIoeGZBLnEsIHRoaXMubG9jYWxOb3JtYWwpO1xuICAgICAgICB2YXIgcGxhbmVQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgdGhpcy5sb2NhbFBvaW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNsaXBQb2ludCA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgdGhpcy5wb2ludHNbaV0ubG9jYWxQb2ludCk7XG4gICAgICAgICAgICB2YXIgY0EgPSBWZWMyLmNsb25lKGNsaXBQb2ludCkuYWRkTXVsKHJhZGl1c0EgLSBWZWMyLmRvdChWZWMyLnN1YihjbGlwUG9pbnQsIHBsYW5lUG9pbnQpLCBub3JtYWwpLCBub3JtYWwpO1xuICAgICAgICAgICAgdmFyIGNCID0gVmVjMi5jbG9uZShjbGlwUG9pbnQpLnN1Yk11bChyYWRpdXNCLCBub3JtYWwpO1xuICAgICAgICAgICAgcG9pbnRzW2ldID0gVmVjMi5taWQoY0EsIGNCKTtcbiAgICAgICAgICAgIHNlcGFyYXRpb25zW2ldID0gVmVjMi5kb3QoVmVjMi5zdWIoY0IsIGNBKSwgbm9ybWFsKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludHMubGVuZ3RoID0gdGhpcy5wb2ludENvdW50O1xuICAgICAgICBzZXBhcmF0aW9ucy5sZW5ndGggPSB0aGlzLnBvaW50Q291bnQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE1hbmlmb2xkLmVfZmFjZUI6XG4gICAgICAgIG5vcm1hbCA9IFJvdC5tdWxWZWMyKHhmQi5xLCB0aGlzLmxvY2FsTm9ybWFsKTtcbiAgICAgICAgdmFyIHBsYW5lUG9pbnQgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIHRoaXMubG9jYWxQb2ludCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjbGlwUG9pbnQgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHRoaXMucG9pbnRzW2ldLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGNCID0gVmVjMi5jb21iaW5lKDEsIGNsaXBQb2ludCwgcmFkaXVzQiAtIFZlYzIuZG90KFZlYzIuc3ViKGNsaXBQb2ludCwgcGxhbmVQb2ludCksIG5vcm1hbCksIG5vcm1hbCk7XG4gICAgICAgICAgICB2YXIgY0EgPSBWZWMyLmNvbWJpbmUoMSwgY2xpcFBvaW50LCAtcmFkaXVzQSwgbm9ybWFsKTtcbiAgICAgICAgICAgIHBvaW50c1tpXSA9IFZlYzIubWlkKGNBLCBjQik7XG4gICAgICAgICAgICBzZXBhcmF0aW9uc1tpXSA9IFZlYzIuZG90KFZlYzIuc3ViKGNBLCBjQiksIG5vcm1hbCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IHRoaXMucG9pbnRDb3VudDtcbiAgICAgICAgc2VwYXJhdGlvbnMubGVuZ3RoID0gdGhpcy5wb2ludENvdW50O1xuICAgICAgICAvLyBFbnN1cmUgbm9ybWFsIHBvaW50cyBmcm9tIEEgdG8gQi5cbiAgICAgICAgbm9ybWFsLm11bCgtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB3bS5ub3JtYWwgPSBub3JtYWw7XG4gICAgd20ucG9pbnRzID0gcG9pbnRzO1xuICAgIHdtLnNlcGFyYXRpb25zID0gc2VwYXJhdGlvbnM7XG4gICAgcmV0dXJuIHdtO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzdGF0ZSBvZiBjb250YWN0IHBvaW50cy5cbiAqIFxuICogQHByb3AgezB9IG51bGxTdGF0ZSBQb2ludCBkb2VzIG5vdCBleGlzdFxuICogQHByb3AgezF9IGFkZFN0YXRlIFBvaW50IHdhcyBhZGRlZCBpbiB0aGUgdXBkYXRlXG4gKiBAcHJvcCB7Mn0gcGVyc2lzdFN0YXRlIFBvaW50IHBlcnNpc3RlZCBhY3Jvc3MgdGhlIHVwZGF0ZVxuICogQHByb3AgezN9IHJlbW92ZVN0YXRlIFBvaW50IHdhcyByZW1vdmVkIGluIHRoZSB1cGRhdGVcbiAqL1xudmFyIFBvaW50U3RhdGUgPSB7XG4gICAgLy8gVE9ETzogdXNlIGNvbnN0YW50c1xuICAgIG51bGxTdGF0ZTogMCxcbiAgICBhZGRTdGF0ZTogMSxcbiAgICBwZXJzaXN0U3RhdGU6IDIsXG4gICAgcmVtb3ZlU3RhdGU6IDNcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcG9pbnQgc3RhdGVzIGdpdmVuIHR3byBtYW5pZm9sZHMuIFRoZSBzdGF0ZXMgcGVydGFpbiB0byB0aGVcbiAqIHRyYW5zaXRpb24gZnJvbSBtYW5pZm9sZDEgdG8gbWFuaWZvbGQyLiBTbyBzdGF0ZTEgaXMgZWl0aGVyIHBlcnNpc3Qgb3IgcmVtb3ZlXG4gKiB3aGlsZSBzdGF0ZTIgaXMgZWl0aGVyIGFkZCBvciBwZXJzaXN0LlxuICogXG4gKiBAcGFyYW0ge1BvaW50U3RhdGVbU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHNdfSBzdGF0ZTFcbiAqIEBwYXJhbSB7UG9pbnRTdGF0ZVtTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50c119IHN0YXRlMlxuICovXG5mdW5jdGlvbiBnZXRQb2ludFN0YXRlcyhzdGF0ZTEsIHN0YXRlMiwgbWFuaWZvbGQxLCBtYW5pZm9sZDIpIHtcbiAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IFNldHRpbmdzLm1heE1hbmlmb2xkUG9pbnRzOyArK2kpIHtcbiAgICAvLyBzdGF0ZTFbaV0gPSBQb2ludFN0YXRlLm51bGxTdGF0ZTtcbiAgICAvLyBzdGF0ZTJbaV0gPSBQb2ludFN0YXRlLm51bGxTdGF0ZTtcbiAgICAvLyB9XG4gICAgLy8gRGV0ZWN0IHBlcnNpc3RzIGFuZCByZW1vdmVzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFuaWZvbGQxLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICB2YXIgaWQgPSBtYW5pZm9sZDEucG9pbnRzW2ldLmlkO1xuICAgICAgICAvLyBDb250YWN0SURcbiAgICAgICAgc3RhdGUxW2ldID0gUG9pbnRTdGF0ZS5yZW1vdmVTdGF0ZTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYW5pZm9sZDIucG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICBpZiAobWFuaWZvbGQyLnBvaW50c1tqXS5pZC5rZXkgPT0gaWQua2V5KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUxW2ldID0gUG9pbnRTdGF0ZS5wZXJzaXN0U3RhdGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZWN0IHBlcnNpc3RzIGFuZCBhZGRzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFuaWZvbGQyLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICB2YXIgaWQgPSBtYW5pZm9sZDIucG9pbnRzW2ldLmlkO1xuICAgICAgICAvLyBDb250YWN0SURcbiAgICAgICAgc3RhdGUyW2ldID0gUG9pbnRTdGF0ZS5hZGRTdGF0ZTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYW5pZm9sZDEucG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICBpZiAobWFuaWZvbGQxLnBvaW50c1tqXS5pZC5rZXkgPT0gaWQua2V5KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUyW2ldID0gUG9pbnRTdGF0ZS5wZXJzaXN0U3RhdGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVXNlZCBmb3IgY29tcHV0aW5nIGNvbnRhY3QgbWFuaWZvbGRzLlxuICogXG4gKiBAcHJvcCB7VmVjMn0gdlxuICogQHByb3Age0NvbnRhY3RJRH0gaWRcbiAqL1xuZnVuY3Rpb24gQ2xpcFZlcnRleCgpIHtcbiAgICB0aGlzLnYgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLmlkID0gbmV3IENvbnRhY3RJRCgpO1xufVxuXG5DbGlwVmVydGV4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvKSB7XG4gICAgdGhpcy52LnNldChvLnYpO1xuICAgIHRoaXMuaWQuc2V0KG8uaWQpO1xufTtcblxuQ2xpcFZlcnRleC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudi5zZXRaZXJvKCk7XG4gICAgdGhpcy5pZC5pbml0KCk7XG59O1xuXG4vKipcbiAqIENsaXBwaW5nIGZvciBjb250YWN0IG1hbmlmb2xkcy4gU3V0aGVybGFuZC1Ib2RnbWFuIGNsaXBwaW5nLlxuICogXG4gKiBAcGFyYW0ge0NsaXBWZXJ0ZXhbMl19IHZPdXRcbiAqIEBwYXJhbSB7Q2xpcFZlcnRleFsyXX0gdkluXG4gKi9cbmZ1bmN0aW9uIGNsaXBTZWdtZW50VG9MaW5lKHZPdXQsIHZJbiwgbm9ybWFsLCBvZmZzZXQsIHZlcnRleEluZGV4QSkge1xuICAgIC8vIFN0YXJ0IHdpdGggbm8gb3V0cHV0IHBvaW50c1xuICAgIHZhciBudW1PdXQgPSAwO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgZW5kIHBvaW50cyB0byB0aGUgbGluZVxuICAgIHZhciBkaXN0YW5jZTAgPSBWZWMyLmRvdChub3JtYWwsIHZJblswXS52KSAtIG9mZnNldDtcbiAgICB2YXIgZGlzdGFuY2UxID0gVmVjMi5kb3Qobm9ybWFsLCB2SW5bMV0udikgLSBvZmZzZXQ7XG4gICAgLy8gSWYgdGhlIHBvaW50cyBhcmUgYmVoaW5kIHRoZSBwbGFuZVxuICAgIGlmIChkaXN0YW5jZTAgPD0gMCkgdk91dFtudW1PdXQrK10uc2V0KHZJblswXSk7XG4gICAgaWYgKGRpc3RhbmNlMSA8PSAwKSB2T3V0W251bU91dCsrXS5zZXQodkluWzFdKTtcbiAgICAvLyBJZiB0aGUgcG9pbnRzIGFyZSBvbiBkaWZmZXJlbnQgc2lkZXMgb2YgdGhlIHBsYW5lXG4gICAgaWYgKGRpc3RhbmNlMCAqIGRpc3RhbmNlMSA8IDApIHtcbiAgICAgICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgZWRnZSBhbmQgcGxhbmVcbiAgICAgICAgdmFyIGludGVycCA9IGRpc3RhbmNlMCAvIChkaXN0YW5jZTAgLSBkaXN0YW5jZTEpO1xuICAgICAgICB2T3V0W251bU91dF0udi5zZXRDb21iaW5lKDEgLSBpbnRlcnAsIHZJblswXS52LCBpbnRlcnAsIHZJblsxXS52KTtcbiAgICAgICAgLy8gVmVydGV4QSBpcyBoaXR0aW5nIGVkZ2VCLlxuICAgICAgICB2T3V0W251bU91dF0uaWQuY2YuaW5kZXhBID0gdmVydGV4SW5kZXhBO1xuICAgICAgICB2T3V0W251bU91dF0uaWQuY2YuaW5kZXhCID0gdkluWzBdLmlkLmNmLmluZGV4QjtcbiAgICAgICAgdk91dFtudW1PdXRdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgICAgIHZPdXRbbnVtT3V0XS5pZC5jZi50eXBlQiA9IE1hbmlmb2xkLmVfZmFjZTtcbiAgICAgICAgKytudW1PdXQ7XG4gICAgfVxuICAgIHJldHVybiBudW1PdXQ7XG59XG5cblxufSx7XCIuL2NvbW1vbi9NYXRoXCI6MTgsXCIuL2NvbW1vbi9Sb3RcIjoyMCxcIi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi9jb21tb24vVmVjMlwiOjIzLFwiLi91dGlsL2NvbW1vblwiOjUwfV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbi8vIFRPRE8gbWVyZ2Ugd2l0aCBXb3JsZCBvcHRpb25zP1xudmFyIFNldHRpbmdzID0gZXhwb3J0cztcblxuLyoqXG4gKiBUdW5pbmcgY29uc3RhbnRzIGJhc2VkIG9uIG1ldGVycy1raWxvZ3JhbXMtc2Vjb25kcyAoTUtTKSB1bml0cy5cbiAqL1xuLy8gQ29sbGlzaW9uXG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb250YWN0IHBvaW50cyBiZXR3ZWVuIHR3byBjb252ZXggc2hhcGVzLiBEbyBub3QgY2hhbmdlXG4gKiB0aGlzIHZhbHVlLlxuICovXG5TZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50cyA9IDI7XG5cbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIG9uIGEgY29udmV4IHBvbHlnb24uIFlvdSBjYW5ub3QgaW5jcmVhc2UgdGhpc1xuICogdG9vIG11Y2ggYmVjYXVzZSBCbG9ja0FsbG9jYXRvciBoYXMgYSBtYXhpbXVtIG9iamVjdCBzaXplLlxuICovXG5TZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMgPSAxMjtcblxuLyoqXG4gKiBUaGlzIGlzIHVzZWQgdG8gZmF0dGVuIEFBQkJzIGluIHRoZSBkeW5hbWljIHRyZWUuIFRoaXMgYWxsb3dzIHByb3hpZXMgdG8gbW92ZVxuICogYnkgYSBzbWFsbCBhbW91bnQgd2l0aG91dCB0cmlnZ2VyaW5nIGEgdHJlZSBhZGp1c3RtZW50LiBUaGlzIGlzIGluIG1ldGVycy5cbiAqL1xuU2V0dGluZ3MuYWFiYkV4dGVuc2lvbiA9IC4xO1xuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBmYXR0ZW4gQUFCQnMgaW4gdGhlIGR5bmFtaWMgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIHByZWRpY3QgdGhlXG4gKiBmdXR1cmUgcG9zaXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgZGlzcGxhY2VtZW50LiBUaGlzIGlzIGEgZGltZW5zaW9ubGVzc1xuICogbXVsdGlwbGllci5cbiAqL1xuU2V0dGluZ3MuYWFiYk11bHRpcGxpZXIgPSAyO1xuXG4vKipcbiAqIEEgc21hbGwgbGVuZ3RoIHVzZWQgYXMgYSBjb2xsaXNpb24gYW5kIGNvbnN0cmFpbnQgdG9sZXJhbmNlLiBVc3VhbGx5IGl0IGlzXG4gKiBjaG9zZW4gdG8gYmUgbnVtZXJpY2FsbHkgc2lnbmlmaWNhbnQsIGJ1dCB2aXN1YWxseSBpbnNpZ25pZmljYW50LlxuICovXG5TZXR0aW5ncy5saW5lYXJTbG9wID0gLjAwNTtcblxuU2V0dGluZ3MubGluZWFyU2xvcFNxdWFyZWQgPSBTZXR0aW5ncy5saW5lYXJTbG9wICogU2V0dGluZ3MubGluZWFyU2xvcDtcblxuLyoqXG4gKiBBIHNtYWxsIGFuZ2xlIHVzZWQgYXMgYSBjb2xsaXNpb24gYW5kIGNvbnN0cmFpbnQgdG9sZXJhbmNlLiBVc3VhbGx5IGl0IGlzXG4gKiBjaG9zZW4gdG8gYmUgbnVtZXJpY2FsbHkgc2lnbmlmaWNhbnQsIGJ1dCB2aXN1YWxseSBpbnNpZ25pZmljYW50LlxuICovXG5TZXR0aW5ncy5hbmd1bGFyU2xvcCA9IDIgLyAxODAgKiBNYXRoLlBJO1xuXG4vKipcbiAqIFRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24vZWRnZSBzaGFwZSBza2luLiBUaGlzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG4gKiBNYWtpbmcgdGhpcyBzbWFsbGVyIG1lYW5zIHBvbHlnb25zIHdpbGwgaGF2ZSBhbiBpbnN1ZmZpY2llbnQgYnVmZmVyIGZvclxuICogY29udGludW91cyBjb2xsaXNpb24uIE1ha2luZyBpdCBsYXJnZXIgbWF5IGNyZWF0ZSBhcnRpZmFjdHMgZm9yIHZlcnRleFxuICogY29sbGlzaW9uLlxuICovXG5TZXR0aW5ncy5wb2x5Z29uUmFkaXVzID0gMiAqIFNldHRpbmdzLmxpbmVhclNsb3A7XG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygc3ViLXN0ZXBzIHBlciBjb250YWN0IGluIGNvbnRpbnVvdXMgcGh5c2ljcyBzaW11bGF0aW9uLlxuICovXG5TZXR0aW5ncy5tYXhTdWJTdGVwcyA9IDg7XG5cbi8vIER5bmFtaWNzXG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIGNvbnRhY3RzIHRvIGJlIGhhbmRsZWQgdG8gc29sdmUgYSBUT0kgaW1wYWN0LlxuICovXG5TZXR0aW5ncy5tYXhUT0lDb250YWN0cyA9IDMyO1xuXG4vKipcbiAqIE1heGltdW0gaXRlcmF0aW9ucyB0byBzb2x2ZSBhIFRPSS5cbiAqL1xuU2V0dGluZ3MubWF4VE9JSXRlcmF0aW9ucyA9IDIwO1xuXG4vKipcbiAqIE1heGltdW0gaXRlcmF0aW9ucyB0byBmaW5kIERpc3RhbmNlLlxuICovXG5TZXR0aW5ncy5tYXhEaXN0bmNlSXRlcmF0aW9ucyA9IDIwO1xuXG4vKipcbiAqIEEgdmVsb2NpdHkgdGhyZXNob2xkIGZvciBlbGFzdGljIGNvbGxpc2lvbnMuIEFueSBjb2xsaXNpb24gd2l0aCBhIHJlbGF0aXZlXG4gKiBsaW5lYXIgdmVsb2NpdHkgYmVsb3cgdGhpcyB0aHJlc2hvbGQgd2lsbCBiZSB0cmVhdGVkIGFzIGluZWxhc3RpYy5cbiAqL1xuU2V0dGluZ3MudmVsb2NpdHlUaHJlc2hvbGQgPSAxO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGxpbmVhciBwb3NpdGlvbiBjb3JyZWN0aW9uIHVzZWQgd2hlbiBzb2x2aW5nIGNvbnN0cmFpbnRzLiBUaGlzXG4gKiBoZWxwcyB0byBwcmV2ZW50IG92ZXJzaG9vdC5cbiAqL1xuU2V0dGluZ3MubWF4TGluZWFyQ29ycmVjdGlvbiA9IC4yO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGFuZ3VsYXIgcG9zaXRpb24gY29ycmVjdGlvbiB1c2VkIHdoZW4gc29sdmluZyBjb25zdHJhaW50cy4gVGhpc1xuICogaGVscHMgdG8gcHJldmVudCBvdmVyc2hvb3QuXG4gKi9cblNldHRpbmdzLm1heEFuZ3VsYXJDb3JyZWN0aW9uID0gOCAvIDE4MCAqIE1hdGguUEk7XG5cbi8qKlxuICogVGhlIG1heGltdW0gbGluZWFyIHZlbG9jaXR5IG9mIGEgYm9keS4gVGhpcyBsaW1pdCBpcyB2ZXJ5IGxhcmdlIGFuZCBpcyB1c2VkXG4gKiB0byBwcmV2ZW50IG51bWVyaWNhbCBwcm9ibGVtcy4gWW91IHNob3VsZG4ndCBuZWVkIHRvIGFkanVzdCB0aGlzLlxuICovXG5TZXR0aW5ncy5tYXhUcmFuc2xhdGlvbiA9IDI7XG5cblNldHRpbmdzLm1heFRyYW5zbGF0aW9uU3F1YXJlZCA9IFNldHRpbmdzLm1heFRyYW5zbGF0aW9uICogU2V0dGluZ3MubWF4VHJhbnNsYXRpb247XG5cbi8qKlxuICogVGhlIG1heGltdW0gYW5ndWxhciB2ZWxvY2l0eSBvZiBhIGJvZHkuIFRoaXMgbGltaXQgaXMgdmVyeSBsYXJnZSBhbmQgaXMgdXNlZFxuICogdG8gcHJldmVudCBudW1lcmljYWwgcHJvYmxlbXMuIFlvdSBzaG91bGRuJ3QgbmVlZCB0byBhZGp1c3QgdGhpcy5cbiAqL1xuU2V0dGluZ3MubWF4Um90YXRpb24gPSAuNSAqIE1hdGguUEk7XG5cblNldHRpbmdzLm1heFJvdGF0aW9uU3F1YXJlZCA9IFNldHRpbmdzLm1heFJvdGF0aW9uICogU2V0dGluZ3MubWF4Um90YXRpb247XG5cbi8qKlxuICogVGhpcyBzY2FsZSBmYWN0b3IgY29udHJvbHMgaG93IGZhc3Qgb3ZlcmxhcCBpcyByZXNvbHZlZC4gSWRlYWxseSB0aGlzIHdvdWxkXG4gKiBiZSAxIHNvIHRoYXQgb3ZlcmxhcCBpcyByZW1vdmVkIGluIG9uZSB0aW1lIHN0ZXAuIEhvd2V2ZXIgdXNpbmcgdmFsdWVzIGNsb3NlXG4gKiB0byAxIG9mdGVuIGxlYWQgdG8gb3ZlcnNob290LlxuICovXG5TZXR0aW5ncy5iYXVtZ2FydGUgPSAuMjtcblxuU2V0dGluZ3MudG9pQmF1Z2FydGUgPSAuNzU7XG5cbi8vIFNsZWVwXG4vKipcbiAqIFRoZSB0aW1lIHRoYXQgYSBib2R5IG11c3QgYmUgc3RpbGwgYmVmb3JlIGl0IHdpbGwgZ28gdG8gc2xlZXAuXG4gKi9cblNldHRpbmdzLnRpbWVUb1NsZWVwID0gLjU7XG5cbi8qKlxuICogQSBib2R5IGNhbm5vdCBzbGVlcCBpZiBpdHMgbGluZWFyIHZlbG9jaXR5IGlzIGFib3ZlIHRoaXMgdG9sZXJhbmNlLlxuICovXG5TZXR0aW5ncy5saW5lYXJTbGVlcFRvbGVyYW5jZSA9IC4wMTtcblxuU2V0dGluZ3MubGluZWFyU2xlZXBUb2xlcmFuY2VTcXIgPSBNYXRoLnBvdyhTZXR0aW5ncy5saW5lYXJTbGVlcFRvbGVyYW5jZSwgMik7XG5cbi8qKlxuICogQSBib2R5IGNhbm5vdCBzbGVlcCBpZiBpdHMgYW5ndWxhciB2ZWxvY2l0eSBpcyBhYm92ZSB0aGlzIHRvbGVyYW5jZS5cbiAqL1xuU2V0dGluZ3MuYW5ndWxhclNsZWVwVG9sZXJhbmNlID0gMiAvIDE4MCAqIE1hdGguUEk7XG5cblNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZVNxciA9IE1hdGgucG93KFNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZSwgMik7XG5cblxufSx7fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4vY29tbW9uL01hdGhcIik7XG5cbi8qKlxuICogQSBzaGFwZSBpcyB1c2VkIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLiBZb3UgY2FuIGNyZWF0ZSBhIHNoYXBlIGhvd2V2ZXIgeW91XG4gKiBsaWtlLiBTaGFwZXMgdXNlZCBmb3Igc2ltdWxhdGlvbiBpbiBXb3JsZCBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYVxuICogRml4dHVyZSBpcyBjcmVhdGVkLiBTaGFwZXMgbWF5IGVuY2Fwc3VsYXRlIG9uZSBvciBtb3JlIGNoaWxkIHNoYXBlcy5cbiAqL1xuZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgdGhpcy5tX3R5cGU7XG4gICAgdGhpcy5tX3JhZGl1cztcbn1cblxuU2hhcGUuaXNWYWxpZCA9IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgcmV0dXJuICEhc2hhcGU7XG59O1xuXG5TaGFwZS5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9yYWRpdXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGRvd24gY2FzdCB0byB0aGUgY29uY3JldGVcbiAqIHNoYXBlLlxuICogXG4gKiBAcmV0dXJuIHRoZSBzaGFwZSB0eXBlLlxuICovXG5TaGFwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgU2hhcGVzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBjbG9uZSB0aGUgY29uY3JldGUgc2hhcGUuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIC8vIEdldCB0aGUgbnVtYmVyIG9mIGNoaWxkIHByaW1pdGl2ZXMuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4XG4gKiBzaGFwZXMuXG4gKiBcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB4ZiBUaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLlxuICogQHBhcmFtIHAgQSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqL1xuU2hhcGUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uKHhmLCBwKSB7fTtcblxuLyoqXG4gKiBDYXN0IGEgcmF5IGFnYWluc3QgYSBjaGlsZCBzaGFwZS5cbiAqIFxuICogQHBhcmFtIHtSYXlDYXN0T3V0cHV0fSBvdXRwdXQgVGhlIHJheS1jYXN0IHJlc3VsdHMuXG4gKiBAcGFyYW0ge1JheUNhc3RJbnB1dH0gaW5wdXQgVGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuXG4gKiBAcGFyYW0gY2hpbGRJbmRleCBUaGUgY2hpbGQgc2hhcGUgaW5kZXhcbiAqL1xuU2hhcGUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbihvdXRwdXQsIGlucHV0LCB0cmFuc2Zvcm0sIGNoaWxkSW5kZXgpIHt9O1xuXG4vKipcbiAqIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFcbiAqIGNoaWxkIHNoYXBlLlxuICogXG4gKiBAcGFyYW0ge0FBQkJ9IGFhYmIgUmV0dXJucyB0aGUgYXhpcyBhbGlnbmVkIGJveC5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB4ZiBUaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS5cbiAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZVxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihhYWJiLCB4ZiwgY2hpbGRJbmRleCkge307XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoaXMgc2hhcGUgdXNpbmcgaXRzIGRpbWVuc2lvbnMgYW5kIGRlbnNpdHkuXG4gKiBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbi5cbiAqIFxuICogQHBhcmFtIHtNYXNzRGF0YX0gbWFzc0RhdGEgUmV0dXJucyB0aGUgbWFzcyBkYXRhIGZvciB0aGlzIHNoYXBlLlxuICogQHBhcmFtIGRlbnNpdHkgVGhlIGRlbnNpdHkgaW4ga2lsb2dyYW1zIHBlciBtZXRlciBzcXVhcmVkLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbihtYXNzRGF0YSwgZGVuc2l0eSkge307XG5cbi8qKlxuICogQHBhcmFtIHtEaXN0YW5jZVByb3h5fSBwcm94eVxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZURpc3RhbmNlUHJveHkgPSBmdW5jdGlvbihwcm94eSkge307XG5cblxufSx7XCIuL2NvbW1vbi9NYXRoXCI6MTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XG5cbm1vZHVsZS5leHBvcnRzLlRpbWVTdGVwID0gVGltZVN0ZXA7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuL1NldHRpbmdzXCIpO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBCb2R5ID0gcmVxdWlyZShcIi4vQm9keVwiKTtcblxudmFyIENvbnRhY3QgPSByZXF1aXJlKFwiLi9Db250YWN0XCIpO1xuXG52YXIgSm9pbnQgPSByZXF1aXJlKFwiLi9Kb2ludFwiKTtcblxudmFyIFRpbWVPZkltcGFjdCA9IHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9UaW1lT2ZJbXBhY3RcIik7XG5cbnZhciBUT0lJbnB1dCA9IFRpbWVPZkltcGFjdC5JbnB1dDtcblxudmFyIFRPSU91dHB1dCA9IFRpbWVPZkltcGFjdC5PdXRwdXQ7XG5cbnZhciBEaXN0YW5jZSA9IHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9EaXN0YW5jZVwiKTtcblxudmFyIERpc3RhbmNlSW5wdXQgPSBEaXN0YW5jZS5JbnB1dDtcblxudmFyIERpc3RhbmNlT3V0cHV0ID0gRGlzdGFuY2UuT3V0cHV0O1xuXG52YXIgRGlzdGFuY2VQcm94eSA9IERpc3RhbmNlLlByb3h5O1xuXG52YXIgU2ltcGxleENhY2hlID0gRGlzdGFuY2UuQ2FjaGU7XG5cbmZ1bmN0aW9uIFRpbWVTdGVwKGR0KSB7XG4gICAgdGhpcy5kdCA9IDA7XG4gICAgLy8gdGltZSBzdGVwXG4gICAgdGhpcy5pbnZfZHQgPSAwO1xuICAgIC8vIGludmVyc2UgdGltZSBzdGVwICgwIGlmIGR0ID09IDApXG4gICAgdGhpcy52ZWxvY2l0eUl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMucG9zaXRpb25JdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLndhcm1TdGFydGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYmxvY2tTb2x2ZSA9IHRydWU7XG4gICAgLy8gdGltZXN0ZXAgcmF0aW8gZm9yIHZhcmlhYmxlIHRpbWVzdGVwXG4gICAgdGhpcy5pbnZfZHQwID0gMDtcbiAgICB0aGlzLmR0UmF0aW8gPSAxO1xufVxuXG5UaW1lU3RlcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkdCkge1xuICAgIGlmICh0aGlzLmR0ID4gMCkge1xuICAgICAgICB0aGlzLmludl9kdDAgPSB0aGlzLmludl9kdDtcbiAgICB9XG4gICAgdGhpcy5kdCA9IGR0O1xuICAgIHRoaXMuaW52X2R0ID0gZHQgPT0gMCA/IDAgOiAxIC8gZHQ7XG4gICAgdGhpcy5kdFJhdGlvID0gZHQgKiB0aGlzLmludl9kdDA7XG59O1xuXG4vKipcbiAqIEZpbmRzIGFuZCBzb2x2ZXMgaXNsYW5kcy4gQW4gaXNsYW5kIGlzIGEgY29ubmVjdGVkIHN1YnNldCBvZiB0aGUgd29ybGQuXG4gKiBcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cbmZ1bmN0aW9uIFNvbHZlcih3b3JsZCkge1xuICAgIHRoaXMubV93b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMubV9zdGFjayA9IFtdO1xuICAgIHRoaXMubV9ib2RpZXMgPSBbXTtcbiAgICB0aGlzLm1fY29udGFjdHMgPSBbXTtcbiAgICB0aGlzLm1fam9pbnRzID0gW107XG59XG5cblNvbHZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1fc3RhY2subGVuZ3RoID0gMDtcbiAgICB0aGlzLm1fYm9kaWVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tX2pvaW50cy5sZW5ndGggPSAwO1xufTtcblxuU29sdmVyLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChib2R5IGluc3RhbmNlb2YgQm9keSwgXCJOb3QgYSBCb2R5IVwiLCBib2R5KTtcbiAgICB0aGlzLm1fYm9kaWVzLnB1c2goYm9keSk7XG59O1xuXG5Tb2x2ZXIucHJvdG90eXBlLmFkZENvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGNvbnRhY3QgaW5zdGFuY2VvZiBDb250YWN0LCBcIk5vdCBhIENvbnRhY3QhXCIsIGNvbnRhY3QpO1xuICAgIHRoaXMubV9jb250YWN0cy5wdXNoKGNvbnRhY3QpO1xufTtcblxuU29sdmVyLnByb3RvdHlwZS5hZGRKb2ludCA9IGZ1bmN0aW9uKGpvaW50KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGpvaW50IGluc3RhbmNlb2YgSm9pbnQsIFwiTm90IGEgSm9pbnQhXCIsIGpvaW50KTtcbiAgICB0aGlzLm1fam9pbnRzLnB1c2goam9pbnQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTdGVwfSBzdGVwXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmVXb3JsZCA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgd29ybGQgPSB0aGlzLm1fd29ybGQ7XG4gICAgLy8gQ2xlYXIgYWxsIHRoZSBpc2xhbmQgZmxhZ3MuXG4gICAgZm9yICh2YXIgYiA9IHdvcmxkLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICBiLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBjID0gd29ybGQubV9jb250YWN0TGlzdDsgYzsgYyA9IGMubV9uZXh0KSB7XG4gICAgICAgIGMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSB3b3JsZC5tX2pvaW50TGlzdDsgajsgaiA9IGoubV9uZXh0KSB7XG4gICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEJ1aWxkIGFuZCBzaW11bGF0ZSBhbGwgYXdha2UgaXNsYW5kcy5cbiAgICB2YXIgc3RhY2sgPSB0aGlzLm1fc3RhY2s7XG4gICAgdmFyIGxvb3AgPSAtMTtcbiAgICBmb3IgKHZhciBzZWVkID0gd29ybGQubV9ib2R5TGlzdDsgc2VlZDsgc2VlZCA9IHNlZWQubV9uZXh0KSB7XG4gICAgICAgIGxvb3ArKztcbiAgICAgICAgaWYgKHNlZWQubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlZC5pc0F3YWtlKCkgPT0gZmFsc2UgfHwgc2VlZC5pc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc2VlZCBjYW4gYmUgZHluYW1pYyBvciBraW5lbWF0aWMuXG4gICAgICAgIGlmIChzZWVkLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IGlzbGFuZCBhbmQgc3RhY2suXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgc3RhY2sucHVzaChzZWVkKTtcbiAgICAgICAgc2VlZC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBQZXJmb3JtIGEgZGVwdGggZmlyc3Qgc2VhcmNoIChERlMpIG9uIHRoZSBjb25zdHJhaW50IGdyYXBoLlxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gR3JhYiB0aGUgbmV4dCBib2R5IG9mZiB0aGUgc3RhY2sgYW5kIGFkZCBpdCB0byB0aGUgaXNsYW5kLlxuICAgICAgICAgICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChiLmlzQWN0aXZlKCkgPT0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEJvZHkoYik7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJvZHkgaXMgYXdha2UuXG4gICAgICAgICAgICBiLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgLy8gVG8ga2VlcCBpc2xhbmRzIGFzIHNtYWxsIGFzIHBvc3NpYmxlLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGlzbGFuZHMgYWNyb3NzIHN0YXRpYyBib2RpZXMuXG4gICAgICAgICAgICBpZiAoYi5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWFyY2ggYWxsIGNvbnRhY3RzIGNvbm5lY3RlZCB0byB0aGlzIGJvZHkuXG4gICAgICAgICAgICBmb3IgKHZhciBjZSA9IGIubV9jb250YWN0TGlzdDsgY2U7IGNlID0gY2UubmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gY2UuY29udGFjdDtcbiAgICAgICAgICAgICAgICAvLyBIYXMgdGhpcyBjb250YWN0IGFscmVhZHkgYmVlbiBhZGRlZCB0byBhbiBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGNvbnRhY3Qgc29saWQgYW5kIHRvdWNoaW5nP1xuICAgICAgICAgICAgICAgIGlmIChjb250YWN0LmlzRW5hYmxlZCgpID09IGZhbHNlIHx8IGNvbnRhY3QuaXNUb3VjaGluZygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTa2lwIHNlbnNvcnMuXG4gICAgICAgICAgICAgICAgdmFyIHNlbnNvckEgPSBjb250YWN0Lm1fZml4dHVyZUEubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICB2YXIgc2Vuc29yQiA9IGNvbnRhY3QubV9maXh0dXJlQi5tX2lzU2Vuc29yO1xuICAgICAgICAgICAgICAgIGlmIChzZW5zb3JBIHx8IHNlbnNvckIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udGFjdChjb250YWN0KTtcbiAgICAgICAgICAgICAgICBjb250YWN0Lm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY2Uub3RoZXI7XG4gICAgICAgICAgICAgICAgLy8gV2FzIHRoZSBvdGhlciBib2R5IGFscmVhZHkgYWRkZWQgdG8gdGhpcyBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyLm1faXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHN0YWNrLmxlbmd0aCA8IHdvcmxkLm1fYm9keUNvdW50KTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgICBvdGhlci5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VhcmNoIGFsbCBqb2ludHMgY29ubmVjdCB0byB0aGlzIGJvZHkuXG4gICAgICAgICAgICBmb3IgKHZhciBqZSA9IGIubV9qb2ludExpc3Q7IGplOyBqZSA9IGplLm5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoamUuam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGplLm90aGVyO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHNpbXVsYXRlIGpvaW50cyBjb25uZWN0ZWQgdG8gaW5hY3RpdmUgYm9kaWVzLlxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5pc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEpvaW50KGplLmpvaW50KTtcbiAgICAgICAgICAgICAgICBqZS5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChzdGFjay5sZW5ndGggPCB3b3JsZC5tX2JvZHlDb3VudCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgb3RoZXIubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvbHZlSXNsYW5kKHN0ZXApO1xuICAgICAgICAvLyBQb3N0IHNvbHZlIGNsZWFudXAuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gQWxsb3cgc3RhdGljIGJvZGllcyB0byBwYXJ0aWNpcGF0ZSBpbiBvdGhlciBpc2xhbmRzLlxuICAgICAgICAgICAgLy8gVE9ETzogYXJlIHRoZXkgYWRkZWQgYXQgYWxsP1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgIGIubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGltZVN0ZXB9IHN0ZXBcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAvLyBCMjogSXNsYW5kIFNvbHZlXG4gICAgdmFyIHdvcmxkID0gdGhpcy5tX3dvcmxkO1xuICAgIHZhciBncmF2aXR5ID0gd29ybGQubV9ncmF2aXR5O1xuICAgIHZhciBhbGxvd1NsZWVwID0gd29ybGQubV9hbGxvd1NsZWVwO1xuICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAvLyBJbnRlZ3JhdGUgdmVsb2NpdGllcyBhbmQgYXBwbHkgZGFtcGluZy4gSW5pdGlhbGl6ZSB0aGUgYm9keSBzdGF0ZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICB2YXIgYyA9IFZlYzIuY2xvbmUoYm9keS5tX3N3ZWVwLmMpO1xuICAgICAgICB2YXIgYSA9IGJvZHkubV9zd2VlcC5hO1xuICAgICAgICB2YXIgdiA9IFZlYzIuY2xvbmUoYm9keS5tX2xpbmVhclZlbG9jaXR5KTtcbiAgICAgICAgdmFyIHcgPSBib2R5Lm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbnMgZm9yIGNvbnRpbnVvdXMgY29sbGlzaW9uLlxuICAgICAgICBib2R5Lm1fc3dlZXAuYzAuc2V0KGJvZHkubV9zd2VlcC5jKTtcbiAgICAgICAgYm9keS5tX3N3ZWVwLmEwID0gYm9keS5tX3N3ZWVwLmE7XG4gICAgICAgIGlmIChib2R5LmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICAvLyBJbnRlZ3JhdGUgdmVsb2NpdGllcy5cbiAgICAgICAgICAgIHYuYWRkTXVsKGggKiBib2R5Lm1fZ3Jhdml0eVNjYWxlLCBncmF2aXR5KTtcbiAgICAgICAgICAgIHYuYWRkTXVsKGggKiBib2R5Lm1faW52TWFzcywgYm9keS5tX2ZvcmNlKTtcbiAgICAgICAgICAgIHcgKz0gaCAqIGJvZHkubV9pbnZJICogYm9keS5tX3RvcnF1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogPHByZT5cbiAgICAgICAqIEFwcGx5IGRhbXBpbmcuXG4gICAgICAgKiBPREU6IGR2L2R0ICsgYyAqIHYgPSAwXG4gICAgICAgKiBTb2x1dGlvbjogdih0KSA9IHYwICogZXhwKC1jICogdClcbiAgICAgICAqIFRpbWUgc3RlcDogdih0ICsgZHQpID0gdjAgKiBleHAoLWMgKiAodCArIGR0KSkgPSB2MCAqIGV4cCgtYyAqIHQpICogZXhwKC1jICogZHQpID0gdiAqIGV4cCgtYyAqIGR0KVxuICAgICAgICogdjIgPSBleHAoLWMgKiBkdCkgKiB2MVxuICAgICAgICogUGFkZSBhcHByb3hpbWF0aW9uOlxuICAgICAgICogdjIgPSB2MSAqIDEgLyAoMSArIGMgKiBkdClcbiAgICAgICAqIDwvcHJlPlxuICAgICAgICovXG4gICAgICAgICAgICB2Lm11bCgxIC8gKDEgKyBoICogYm9keS5tX2xpbmVhckRhbXBpbmcpKTtcbiAgICAgICAgICAgIHcgKj0gMSAvICgxICsgaCAqIGJvZHkubV9hbmd1bGFyRGFtcGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmMgPSBjO1xuICAgICAgICBib2R5LmNfcG9zaXRpb24uYSA9IGE7XG4gICAgICAgIGJvZHkuY192ZWxvY2l0eS52ID0gdjtcbiAgICAgICAgYm9keS5jX3ZlbG9jaXR5LncgPSB3O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgY29udGFjdC5pbml0Q29uc3RyYWludChzdGVwKTtcbiAgICB9XG4gICAgX0RFQlVHICYmIHRoaXMucHJpbnRCb2RpZXMoXCJNOiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgIGNvbnRhY3QuaW5pdFZlbG9jaXR5Q29uc3RyYWludChzdGVwKTtcbiAgICB9XG4gICAgX0RFQlVHICYmIHRoaXMucHJpbnRCb2RpZXMoXCJSOiBcIik7XG4gICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgIC8vIFdhcm0gc3RhcnQuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgIGNvbnRhY3Qud2FybVN0YXJ0Q29uc3RyYWludChzdGVwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfREVCVUcgJiYgdGhpcy5wcmludEJvZGllcyhcIlE6IFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9qb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGpvaW50ID0gdGhpcy5tX2pvaW50c1tpXTtcbiAgICAgICAgam9pbnQuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XG4gICAgfVxuICAgIF9ERUJVRyAmJiB0aGlzLnByaW50Qm9kaWVzKFwiRTogXCIpO1xuICAgIC8vIFNvbHZlIHZlbG9jaXR5IGNvbnN0cmFpbnRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwLnZlbG9jaXR5SXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX2pvaW50cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGpvaW50ID0gdGhpcy5tX2pvaW50c1tqXTtcbiAgICAgICAgICAgIGpvaW50LnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbal07XG4gICAgICAgICAgICBjb250YWN0LnNvbHZlVmVsb2NpdHlDb25zdHJhaW50KHN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9ERUJVRyAmJiB0aGlzLnByaW50Qm9kaWVzKFwiRDogXCIpO1xuICAgIC8vIFN0b3JlIGltcHVsc2VzIGZvciB3YXJtIHN0YXJ0aW5nXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgIGNvbnRhY3Quc3RvcmVDb25zdHJhaW50SW1wdWxzZXMoc3RlcCk7XG4gICAgfVxuICAgIF9ERUJVRyAmJiB0aGlzLnByaW50Qm9kaWVzKFwiQzogXCIpO1xuICAgIC8vIEludGVncmF0ZSBwb3NpdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICB2YXIgYyA9IFZlYzIuY2xvbmUoYm9keS5jX3Bvc2l0aW9uLmMpO1xuICAgICAgICB2YXIgYSA9IGJvZHkuY19wb3NpdGlvbi5hO1xuICAgICAgICB2YXIgdiA9IFZlYzIuY2xvbmUoYm9keS5jX3ZlbG9jaXR5LnYpO1xuICAgICAgICB2YXIgdyA9IGJvZHkuY192ZWxvY2l0eS53O1xuICAgICAgICAvLyBDaGVjayBmb3IgbGFyZ2UgdmVsb2NpdGllc1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSBWZWMyLm11bChoLCB2KTtcbiAgICAgICAgaWYgKFZlYzIubGVuZ3RoU3F1YXJlZCh0cmFuc2xhdGlvbikgPiBTZXR0aW5ncy5tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IFNldHRpbmdzLm1heFRyYW5zbGF0aW9uIC8gdHJhbnNsYXRpb24ubGVuZ3RoKCk7XG4gICAgICAgICAgICB2Lm11bChyYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdGF0aW9uID0gaCAqIHc7XG4gICAgICAgIGlmIChyb3RhdGlvbiAqIHJvdGF0aW9uID4gU2V0dGluZ3MubWF4Um90YXRpb25TcXVhcmVkKSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBTZXR0aW5ncy5tYXhSb3RhdGlvbiAvIE1hdGguYWJzKHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHcgKj0gcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZWdyYXRlXG4gICAgICAgIGMuYWRkTXVsKGgsIHYpO1xuICAgICAgICBhICs9IGggKiB3O1xuICAgICAgICBib2R5LmNfcG9zaXRpb24uYy5zZXQoYyk7XG4gICAgICAgIGJvZHkuY19wb3NpdGlvbi5hID0gYTtcbiAgICAgICAgYm9keS5jX3ZlbG9jaXR5LnYuc2V0KHYpO1xuICAgICAgICBib2R5LmNfdmVsb2NpdHkudyA9IHc7XG4gICAgfVxuICAgIF9ERUJVRyAmJiB0aGlzLnByaW50Qm9kaWVzKFwiQjogXCIpO1xuICAgIC8vIFNvbHZlIHBvc2l0aW9uIGNvbnN0cmFpbnRzXG4gICAgdmFyIHBvc2l0aW9uU29sdmVkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwLnBvc2l0aW9uSXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgIHZhciBtaW5TZXBhcmF0aW9uID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2pdO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBjb250YWN0LnNvbHZlUG9zaXRpb25Db25zdHJhaW50KHN0ZXApO1xuICAgICAgICAgICAgbWluU2VwYXJhdGlvbiA9IE1hdGgubWluKG1pblNlcGFyYXRpb24sIHNlcGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNhbid0IGV4cGVjdCBtaW5TcGVwYXJhdGlvbiA+PSAtU2V0dGluZ3MubGluZWFyU2xvcCBiZWNhdXNlIHdlIGRvbid0XG4gICAgICAgIC8vIHB1c2ggdGhlIHNlcGFyYXRpb24gYWJvdmUgLVNldHRpbmdzLmxpbmVhclNsb3AuXG4gICAgICAgIHZhciBjb250YWN0c09rYXkgPSBtaW5TZXBhcmF0aW9uID49IC0zICogU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICAgICAgdmFyIGpvaW50c09rYXkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9qb2ludHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IHRoaXMubV9qb2ludHNbal07XG4gICAgICAgICAgICB2YXIgam9pbnRPa2F5ID0gam9pbnQuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKHN0ZXApO1xuICAgICAgICAgICAgam9pbnRzT2theSA9IGpvaW50c09rYXkgJiYgam9pbnRPa2F5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWN0c09rYXkgJiYgam9pbnRzT2theSkge1xuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSBzbWFsbC5cbiAgICAgICAgICAgIHBvc2l0aW9uU29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9ERUJVRyAmJiB0aGlzLnByaW50Qm9kaWVzKFwiTDogXCIpO1xuICAgIC8vIENvcHkgc3RhdGUgYnVmZmVycyBiYWNrIHRvIHRoZSBib2RpZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICBib2R5Lm1fc3dlZXAuYy5zZXQoYm9keS5jX3Bvc2l0aW9uLmMpO1xuICAgICAgICBib2R5Lm1fc3dlZXAuYSA9IGJvZHkuY19wb3NpdGlvbi5hO1xuICAgICAgICBib2R5Lm1fbGluZWFyVmVsb2NpdHkuc2V0KGJvZHkuY192ZWxvY2l0eS52KTtcbiAgICAgICAgYm9keS5tX2FuZ3VsYXJWZWxvY2l0eSA9IGJvZHkuY192ZWxvY2l0eS53O1xuICAgICAgICBib2R5LnN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgfVxuICAgIHRoaXMucG9zdFNvbHZlSXNsYW5kKCk7XG4gICAgaWYgKGFsbG93U2xlZXApIHtcbiAgICAgICAgdmFyIG1pblNsZWVwVGltZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbGluVG9sU3FyID0gU2V0dGluZ3MubGluZWFyU2xlZXBUb2xlcmFuY2VTcXI7XG4gICAgICAgIHZhciBhbmdUb2xTcXIgPSBTZXR0aW5ncy5hbmd1bGFyU2xlZXBUb2xlcmFuY2VTcXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJvZHkubV9hdXRvU2xlZXBGbGFnID09IGZhbHNlIHx8IGJvZHkubV9hbmd1bGFyVmVsb2NpdHkgKiBib2R5Lm1fYW5ndWxhclZlbG9jaXR5ID4gYW5nVG9sU3FyIHx8IFZlYzIubGVuZ3RoU3F1YXJlZChib2R5Lm1fbGluZWFyVmVsb2NpdHkpID4gbGluVG9sU3FyKSB7XG4gICAgICAgICAgICAgICAgYm9keS5tX3NsZWVwVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgbWluU2xlZXBUaW1lID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keS5tX3NsZWVwVGltZSArPSBoO1xuICAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IE1hdGgubWluKG1pblNsZWVwVGltZSwgYm9keS5tX3NsZWVwVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pblNsZWVwVGltZSA+PSBTZXR0aW5ncy50aW1lVG9TbGVlcCAmJiBwb3NpdGlvblNvbHZlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGJvZHkuc2V0QXdha2UoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuU29sdmVyLnByb3RvdHlwZS5wcmludEJvZGllcyA9IGZ1bmN0aW9uKHRhZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgIGNvbW1vbi5kZWJ1Zyh0YWcsIGIuY19wb3NpdGlvbi5hLCBiLmNfcG9zaXRpb24uYy54LCBiLmNfcG9zaXRpb24uYy55LCBiLmNfdmVsb2NpdHkudywgYi5jX3ZlbG9jaXR5LnYueCwgYi5jX3ZlbG9jaXR5LnYueSk7XG4gICAgfVxufTtcblxudmFyIHNfc3ViU3RlcCA9IG5ldyBUaW1lU3RlcCgpO1xuXG4vLyByZXVzZVxuLyoqXG4gKiBGaW5kIFRPSSBjb250YWN0cyBhbmQgc29sdmUgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge1RpbWVTdGVwfSBzdGVwXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmVXb3JsZFRPSSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgd29ybGQgPSB0aGlzLm1fd29ybGQ7XG4gICAgaWYgKHdvcmxkLm1fc3RlcENvbXBsZXRlKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSB3b3JsZC5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgICAgIGIubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBiLm1fc3dlZXAuYWxwaGEwID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBjID0gd29ybGQubV9jb250YWN0TGlzdDsgYzsgYyA9IGMubV9uZXh0KSB7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIFRPSVxuICAgICAgICAgICAgYy5tX3RvaUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBjLm1fdG9pQ291bnQgPSAwO1xuICAgICAgICAgICAgYy5tX3RvaSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBUT0kgZXZlbnRzIGFuZCBzb2x2ZSB0aGVtLlxuICAgIGZvciAoOzspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgVE9JLlxuICAgICAgICB2YXIgbWluQ29udGFjdCA9IG51bGw7XG4gICAgICAgIC8vIENvbnRhY3RcbiAgICAgICAgdmFyIG1pbkFscGhhID0gMTtcbiAgICAgICAgZm9yICh2YXIgYyA9IHdvcmxkLm1fY29udGFjdExpc3Q7IGM7IGMgPSBjLm1fbmV4dCkge1xuICAgICAgICAgICAgLy8gSXMgdGhpcyBjb250YWN0IGRpc2FibGVkP1xuICAgICAgICAgICAgaWYgKGMuaXNFbmFibGVkKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXZlbnQgZXhjZXNzaXZlIHN1Yi1zdGVwcGluZy5cbiAgICAgICAgICAgIGlmIChjLm1fdG9pQ291bnQgPiBTZXR0aW5ncy5tYXhTdWJTdGVwcykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFscGhhID0gMTtcbiAgICAgICAgICAgIGlmIChjLm1fdG9pRmxhZykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29udGFjdCBoYXMgYSB2YWxpZCBjYWNoZWQgVE9JLlxuICAgICAgICAgICAgICAgIGFscGhhID0gYy5tX3RvaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZBID0gYy5nZXRGaXh0dXJlQSgpO1xuICAgICAgICAgICAgICAgIHZhciBmQiA9IGMuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIHNlbnNvcj9cbiAgICAgICAgICAgICAgICBpZiAoZkEuaXNTZW5zb3IoKSB8fCBmQi5pc1NlbnNvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYkEgPSBmQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJCID0gZkIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChiQS5pc0R5bmFtaWMoKSB8fCBiQi5pc0R5bmFtaWMoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUEgPSBiQS5pc0F3YWtlKCkgJiYgIWJBLmlzU3RhdGljKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUIgPSBiQi5pc0F3YWtlKCkgJiYgIWJCLmlzU3RhdGljKCk7XG4gICAgICAgICAgICAgICAgLy8gSXMgYXQgbGVhc3Qgb25lIGJvZHkgYWN0aXZlIChhd2FrZSBhbmQgZHluYW1pYyBvciBraW5lbWF0aWMpP1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVBID09IGZhbHNlICYmIGFjdGl2ZUIgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2xsaWRlQSA9IGJBLmlzQnVsbGV0KCkgfHwgIWJBLmlzRHluYW1pYygpO1xuICAgICAgICAgICAgICAgIHZhciBjb2xsaWRlQiA9IGJCLmlzQnVsbGV0KCkgfHwgIWJCLmlzRHluYW1pYygpO1xuICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVzZSB0d28gbm9uLWJ1bGxldCBkeW5hbWljIGJvZGllcz9cbiAgICAgICAgICAgICAgICBpZiAoY29sbGlkZUEgPT0gZmFsc2UgJiYgY29sbGlkZUIgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIFRPSSBmb3IgdGhpcyBjb250YWN0LlxuICAgICAgICAgICAgICAgIC8vIFB1dCB0aGUgc3dlZXBzIG9udG8gdGhlIHNhbWUgdGltZSBpbnRlcnZhbC5cbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEwID0gYkEubV9zd2VlcC5hbHBoYTA7XG4gICAgICAgICAgICAgICAgaWYgKGJBLm1fc3dlZXAuYWxwaGEwIDwgYkIubV9zd2VlcC5hbHBoYTApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEwID0gYkIubV9zd2VlcC5hbHBoYTA7XG4gICAgICAgICAgICAgICAgICAgIGJBLm1fc3dlZXAuYWR2YW5jZShhbHBoYTApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYkIubV9zd2VlcC5hbHBoYTAgPCBiQS5tX3N3ZWVwLmFscGhhMCkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYTAgPSBiQS5tX3N3ZWVwLmFscGhhMDtcbiAgICAgICAgICAgICAgICAgICAgYkIubV9zd2VlcC5hZHZhbmNlKGFscGhhMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChhbHBoYTAgPCAxKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBID0gYy5nZXRDaGlsZEluZGV4QSgpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEIgPSBjLmdldENoaWxkSW5kZXhCKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN3ZWVwQSA9IGJBLm1fc3dlZXA7XG4gICAgICAgICAgICAgICAgdmFyIHN3ZWVwQiA9IGJCLm1fc3dlZXA7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdGltZSBvZiBpbXBhY3QgaW4gaW50ZXJ2YWwgWzAsIG1pblRPSV1cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBuZXcgVE9JSW5wdXQoKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXVzZVxuICAgICAgICAgICAgICAgIGlucHV0LnByb3h5QS5zZXQoZkEuZ2V0U2hhcGUoKSwgaW5kZXhBKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5wcm94eUIuc2V0KGZCLmdldFNoYXBlKCksIGluZGV4Qik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3dlZXBBLnNldChiQS5tX3N3ZWVwKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zd2VlcEIuc2V0KGJCLm1fc3dlZXApO1xuICAgICAgICAgICAgICAgIGlucHV0LnRNYXggPSAxO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBuZXcgVE9JT3V0cHV0KCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV1c2VcbiAgICAgICAgICAgICAgICBUaW1lT2ZJbXBhY3Qob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgLy8gQmV0YSBpcyB0aGUgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBwb3J0aW9uIG9mIHRoZSBbdGltZT9dLlxuICAgICAgICAgICAgICAgIHZhciBiZXRhID0gb3V0cHV0LnQ7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5zdGF0ZSA9PSBUT0lPdXRwdXQuZV90b3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IE1hdGgubWluKGFscGhhMCArICgxIC0gYWxwaGEwKSAqIGJldGEsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYy5tX3RvaSA9IGFscGhhO1xuICAgICAgICAgICAgICAgIGMubV90b2lGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSA8IG1pbkFscGhhKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbWluaW11bSBUT0kgZm91bmQgc28gZmFyLlxuICAgICAgICAgICAgICAgIG1pbkNvbnRhY3QgPSBjO1xuICAgICAgICAgICAgICAgIG1pbkFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxIC0gMTAgKiBNYXRoLkVQU0lMT04gPCBtaW5BbHBoYSkge1xuICAgICAgICAgICAgLy8gTm8gbW9yZSBUT0kgZXZlbnRzLiBEb25lIVxuICAgICAgICAgICAgd29ybGQubV9zdGVwQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgYm9kaWVzIHRvIHRoZSBUT0kuXG4gICAgICAgIHZhciBmQSA9IG1pbkNvbnRhY3QuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgdmFyIGZCID0gbWluQ29udGFjdC5nZXRGaXh0dXJlQigpO1xuICAgICAgICB2YXIgYkEgPSBmQS5nZXRCb2R5KCk7XG4gICAgICAgIHZhciBiQiA9IGZCLmdldEJvZHkoKTtcbiAgICAgICAgdmFyIGJhY2t1cDEgPSBiQS5tX3N3ZWVwLmNsb25lKCk7XG4gICAgICAgIHZhciBiYWNrdXAyID0gYkIubV9zd2VlcC5jbG9uZSgpO1xuICAgICAgICBiQS5hZHZhbmNlKG1pbkFscGhhKTtcbiAgICAgICAgYkIuYWR2YW5jZShtaW5BbHBoYSk7XG4gICAgICAgIC8vIFRoZSBUT0kgY29udGFjdCBsaWtlbHkgaGFzIHNvbWUgbmV3IGNvbnRhY3QgcG9pbnRzLlxuICAgICAgICBtaW5Db250YWN0LnVwZGF0ZSh3b3JsZCk7XG4gICAgICAgIG1pbkNvbnRhY3QubV90b2lGbGFnID0gZmFsc2U7XG4gICAgICAgICsrbWluQ29udGFjdC5tX3RvaUNvdW50O1xuICAgICAgICAvLyBJcyB0aGUgY29udGFjdCBzb2xpZD9cbiAgICAgICAgaWYgKG1pbkNvbnRhY3QuaXNFbmFibGVkKCkgPT0gZmFsc2UgfHwgbWluQ29udGFjdC5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHN3ZWVwcy5cbiAgICAgICAgICAgIG1pbkNvbnRhY3Quc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICBiQS5tX3N3ZWVwLnNldChiYWNrdXAxKTtcbiAgICAgICAgICAgIGJCLm1fc3dlZXAuc2V0KGJhY2t1cDIpO1xuICAgICAgICAgICAgYkEuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGJCLnN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBiQS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgYkIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBpc2xhbmRcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmFkZEJvZHkoYkEpO1xuICAgICAgICB0aGlzLmFkZEJvZHkoYkIpO1xuICAgICAgICB0aGlzLmFkZENvbnRhY3QobWluQ29udGFjdCk7XG4gICAgICAgIGJBLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgIGJCLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgIG1pbkNvbnRhY3QubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gR2V0IGNvbnRhY3RzIG9uIGJvZHlBIGFuZCBib2R5Qi5cbiAgICAgICAgdmFyIGJvZGllcyA9IFsgYkEsIGJCIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmIChib2R5LmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2UgPSBib2R5Lm1fY29udGFjdExpc3Q7IGNlOyBjZSA9IGNlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMubV9ib2R5Q291bnQgPT0gdGhpcy5tX2JvZHlDYXBhY2l0eSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5tX2NvbnRhY3RDb3VudCA9PSB0aGlzLm1fY29udGFjdENhcGFjaXR5KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gY2UuY29udGFjdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFzIHRoaXMgY29udGFjdCBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIGlzbGFuZD9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBpZiBlaXRoZXIgaXMgc3RhdGljLCBraW5lbWF0aWMgb3IgYnVsbGV0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjZS5vdGhlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLmlzRHluYW1pYygpICYmICFib2R5LmlzQnVsbGV0KCkgJiYgIW90aGVyLmlzQnVsbGV0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgc2Vuc29ycy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbnNvckEgPSBjb250YWN0Lm1fZml4dHVyZUEubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbnNvckIgPSBjb250YWN0Lm1fZml4dHVyZUIubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbnNvckEgfHwgc2Vuc29yQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVudGF0aXZlbHkgYWR2YW5jZSB0aGUgYm9keSB0byB0aGUgVE9JLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFja3VwID0gb3RoZXIubV9zd2VlcC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIubV9pc2xhbmRGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5hZHZhbmNlKG1pbkFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRhY3QgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QudXBkYXRlKHdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FzIHRoZSBjb250YWN0IGRpc2FibGVkIGJ5IHRoZSB1c2VyP1xuICAgICAgICAgICAgICAgICAgICAvLyBBcmUgdGhlcmUgY29udGFjdCBwb2ludHM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LmlzRW5hYmxlZCgpID09IGZhbHNlIHx8IGNvbnRhY3QuaXNUb3VjaGluZygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5tX3N3ZWVwLnNldChiYWNrdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29udGFjdCB0byB0aGUgaXNsYW5kXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb250YWN0KGNvbnRhY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhlIG90aGVyIGJvZHkgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb3RoZXIgYm9keSB0byB0aGUgaXNsYW5kLlxuICAgICAgICAgICAgICAgICAgICBvdGhlci5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9keShvdGhlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNfc3ViU3RlcC5yZXNldCgoMSAtIG1pbkFscGhhKSAqIHN0ZXAuZHQpO1xuICAgICAgICBzX3N1YlN0ZXAuZHRSYXRpbyA9IDE7XG4gICAgICAgIHNfc3ViU3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnMgPSAyMDtcbiAgICAgICAgc19zdWJTdGVwLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zO1xuICAgICAgICBzX3N1YlN0ZXAud2FybVN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc29sdmVJc2xhbmRUT0koc19zdWJTdGVwLCBiQSwgYkIpO1xuICAgICAgICAvLyBSZXNldCBpc2xhbmQgZmxhZ3MgYW5kIHN5bmNocm9uaXplIGJyb2FkLXBoYXNlIHByb3hpZXMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgYm9keS5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghYm9keS5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5zeW5jaHJvbml6ZUZpeHR1cmVzKCk7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBjb250YWN0IFRPSXMgb24gdGhpcyBkaXNwbGFjZWQgYm9keS5cbiAgICAgICAgICAgIGZvciAodmFyIGNlID0gYm9keS5tX2NvbnRhY3RMaXN0OyBjZTsgY2UgPSBjZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2UuY29udGFjdC5tX3RvaUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjZS5jb250YWN0Lm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbW1pdCBmaXh0dXJlIHByb3h5IG1vdmVtZW50cyB0byB0aGUgYnJvYWQtcGhhc2Ugc28gdGhhdCBuZXcgY29udGFjdHNcbiAgICAgICAgLy8gYXJlIGNyZWF0ZWQuXG4gICAgICAgIC8vIEFsc28sIHNvbWUgY29udGFjdHMgY2FuIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgd29ybGQuZmluZE5ld0NvbnRhY3RzKCk7XG4gICAgICAgIGlmICh3b3JsZC5tX3N1YlN0ZXBwaW5nKSB7XG4gICAgICAgICAgICB3b3JsZC5tX3N0ZXBDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9ERUJVRykgZm9yICh2YXIgYiA9IHdvcmxkLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICB2YXIgYyA9IGIubV9zd2VlcC5jO1xuICAgICAgICB2YXIgYSA9IGIubV9zd2VlcC5hO1xuICAgICAgICB2YXIgdiA9IGIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgICAgdmFyIHcgPSBiLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU3RlcH0gc3ViU3RlcFxuICogQHBhcmFtIHRvaUFcbiAqIEBwYXJhbSB0b2lCXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmVJc2xhbmRUT0kgPSBmdW5jdGlvbihzdWJTdGVwLCB0b2lBLCB0b2lCKSB7XG4gICAgdmFyIHdvcmxkID0gdGhpcy5tX3dvcmxkO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGJvZHkgc3RhdGUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmMuc2V0KGJvZHkubV9zd2VlcC5jKTtcbiAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmEgPSBib2R5Lm1fc3dlZXAuYTtcbiAgICAgICAgYm9keS5jX3ZlbG9jaXR5LnYuc2V0KGJvZHkubV9saW5lYXJWZWxvY2l0eSk7XG4gICAgICAgIGJvZHkuY192ZWxvY2l0eS53ID0gYm9keS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgIGNvbnRhY3QuaW5pdENvbnN0cmFpbnQoc3ViU3RlcCk7XG4gICAgfVxuICAgIC8vIFNvbHZlIHBvc2l0aW9uIGNvbnN0cmFpbnRzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViU3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tqXTtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gY29udGFjdC5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludFRPSShzdWJTdGVwLCB0b2lBLCB0b2lCKTtcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb24gPSBNYXRoLm1pbihtaW5TZXBhcmF0aW9uLCBzZXBhcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBjYW4ndCBleHBlY3QgbWluU3BlcGFyYXRpb24gPj0gLVNldHRpbmdzLmxpbmVhclNsb3AgYmVjYXVzZSB3ZSBkb24ndFxuICAgICAgICAvLyBwdXNoIHRoZSBzZXBhcmF0aW9uIGFib3ZlIC1TZXR0aW5ncy5saW5lYXJTbG9wLlxuICAgICAgICB2YXIgY29udGFjdHNPa2F5ID0gbWluU2VwYXJhdGlvbiA+PSAtMS41ICogU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICAgICAgaWYgKGNvbnRhY3RzT2theSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vIElzIHRoZSBuZXcgcG9zaXRpb24gcmVhbGx5IHNhZmU/XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgIHZhciBmQSA9IGMuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgICAgIHZhciBmQiA9IGMuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgIHZhciBiQSA9IGZBLmdldEJvZHkoKTtcbiAgICAgICAgICAgIHZhciBiQiA9IGZCLmdldEJvZHkoKTtcbiAgICAgICAgICAgIHZhciBpbmRleEEgPSBjLmdldENoaWxkSW5kZXhBKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXhCID0gYy5nZXRDaGlsZEluZGV4QigpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gbmV3IERpc3RhbmNlSW5wdXQoKTtcbiAgICAgICAgICAgIGlucHV0LnByb3h5QS5zZXQoZkEuZ2V0U2hhcGUoKSwgaW5kZXhBKTtcbiAgICAgICAgICAgIGlucHV0LnByb3h5Qi5zZXQoZkIuZ2V0U2hhcGUoKSwgaW5kZXhCKTtcbiAgICAgICAgICAgIGlucHV0LnRyYW5zZm9ybUEgPSBiQS5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlucHV0LnRyYW5zZm9ybUIgPSBiQi5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlucHV0LnVzZVJhZGlpID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gbmV3IERpc3RhbmNlT3V0cHV0KCk7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBuZXcgU2ltcGxleENhY2hlKCk7XG4gICAgICAgICAgICBEaXN0YW5jZShvdXRwdXQsIGNhY2hlLCBpbnB1dCk7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmRpc3RhbmNlID09IDAgfHwgY2FjaGUuY291bnQgPT0gMykge1xuICAgICAgICAgICAgICAgIGNhY2hlLmNvdW50ICs9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTGVhcCBvZiBmYWl0aCB0byBuZXcgc2FmZSBzdGF0ZS5cbiAgICB0b2lBLm1fc3dlZXAuYzAuc2V0KHRvaUEuY19wb3NpdGlvbi5jKTtcbiAgICB0b2lBLm1fc3dlZXAuYTAgPSB0b2lBLmNfcG9zaXRpb24uYTtcbiAgICB0b2lCLm1fc3dlZXAuYzAuc2V0KHRvaUIuY19wb3NpdGlvbi5jKTtcbiAgICB0b2lCLm1fc3dlZXAuYTAgPSB0b2lCLmNfcG9zaXRpb24uYTtcbiAgICAvLyBObyB3YXJtIHN0YXJ0aW5nIGlzIG5lZWRlZCBmb3IgVE9JIGV2ZW50cyBiZWNhdXNlIHdhcm1cbiAgICAvLyBzdGFydGluZyBpbXB1bHNlcyB3ZXJlIGFwcGxpZWQgaW4gdGhlIGRpc2NyZXRlIHNvbHZlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgY29udGFjdC5pbml0VmVsb2NpdHlDb25zdHJhaW50KHN1YlN0ZXApO1xuICAgIH1cbiAgICAvLyBTb2x2ZSB2ZWxvY2l0eSBjb25zdHJhaW50cy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2pdO1xuICAgICAgICAgICAgY29udGFjdC5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludChzdWJTdGVwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEb24ndCBzdG9yZSB0aGUgVE9JIGNvbnRhY3QgZm9yY2VzIGZvciB3YXJtIHN0YXJ0aW5nXG4gICAgLy8gYmVjYXVzZSB0aGV5IGNhbiBiZSBxdWl0ZSBsYXJnZS5cbiAgICB2YXIgaCA9IHN1YlN0ZXAuZHQ7XG4gICAgLy8gSW50ZWdyYXRlIHBvc2l0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgIHZhciBjID0gVmVjMi5jbG9uZShib2R5LmNfcG9zaXRpb24uYyk7XG4gICAgICAgIHZhciBhID0gYm9keS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgIHZhciB2ID0gVmVjMi5jbG9uZShib2R5LmNfdmVsb2NpdHkudik7XG4gICAgICAgIHZhciB3ID0gYm9keS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgIC8vIENoZWNrIGZvciBsYXJnZSB2ZWxvY2l0aWVzXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IFZlYzIubXVsKGgsIHYpO1xuICAgICAgICBpZiAoVmVjMi5kb3QodHJhbnNsYXRpb24sIHRyYW5zbGF0aW9uKSA+IFNldHRpbmdzLm1heFRyYW5zbGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gU2V0dGluZ3MubWF4VHJhbnNsYXRpb24gLyB0cmFuc2xhdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgICAgIHYubXVsKHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm90YXRpb24gPSBoICogdztcbiAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBTZXR0aW5ncy5tYXhSb3RhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IFNldHRpbmdzLm1heFJvdGF0aW9uIC8gTWF0aC5hYnMocm90YXRpb24pO1xuICAgICAgICAgICAgdyAqPSByYXRpbztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlZ3JhdGVcbiAgICAgICAgYy5hZGRNdWwoaCwgdik7XG4gICAgICAgIGEgKz0gaCAqIHc7XG4gICAgICAgIGJvZHkuY19wb3NpdGlvbi5jID0gYztcbiAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmEgPSBhO1xuICAgICAgICBib2R5LmNfdmVsb2NpdHkudiA9IHY7XG4gICAgICAgIGJvZHkuY192ZWxvY2l0eS53ID0gdztcbiAgICAgICAgLy8gU3luYyBib2RpZXNcbiAgICAgICAgYm9keS5tX3N3ZWVwLmMgPSBjO1xuICAgICAgICBib2R5Lm1fc3dlZXAuYSA9IGE7XG4gICAgICAgIGJvZHkubV9saW5lYXJWZWxvY2l0eSA9IHY7XG4gICAgICAgIGJvZHkubV9hbmd1bGFyVmVsb2NpdHkgPSB3O1xuICAgICAgICBib2R5LnN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgfVxuICAgIHRoaXMucG9zdFNvbHZlSXNsYW5kKCk7XG59O1xuXG4vKipcbiAqIENvbnRhY3QgaW1wdWxzZXMgZm9yIHJlcG9ydGluZy4gSW1wdWxzZXMgYXJlIHVzZWQgaW5zdGVhZCBvZiBmb3JjZXMgYmVjYXVzZVxuICogc3ViLXN0ZXAgZm9yY2VzIG1heSBhcHByb2FjaCBpbmZpbml0eSBmb3IgcmlnaWQgYm9keSBjb2xsaXNpb25zLiBUaGVzZSBtYXRjaFxuICogdXAgb25lLXRvLW9uZSB3aXRoIHRoZSBjb250YWN0IHBvaW50cyBpbiBNYW5pZm9sZC5cbiAqL1xuZnVuY3Rpb24gQ29udGFjdEltcHVsc2UoKSB7XG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlcyA9IFtdO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2VzID0gW107XG59XG5cblNvbHZlci5wcm90b3R5cGUucG9zdFNvbHZlSXNsYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogcmVwb3J0IGNvbnRhY3Qudl9wb2ludHMgaW5zdGVhZCBvZiBuZXcgb2JqZWN0P1xuICAgIHZhciBpbXB1bHNlID0gbmV3IENvbnRhY3RJbXB1bHNlKCk7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbY107XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgY29udGFjdC52X3BvaW50cy5sZW5ndGg7ICsrcCkge1xuICAgICAgICAgICAgaW1wdWxzZS5ub3JtYWxJbXB1bHNlcy5wdXNoKGNvbnRhY3Qudl9wb2ludHNbcF0ubm9ybWFsSW1wdWxzZSk7XG4gICAgICAgICAgICBpbXB1bHNlLnRhbmdlbnRJbXB1bHNlcy5wdXNoKGNvbnRhY3Qudl9wb2ludHNbcF0udGFuZ2VudEltcHVsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubV93b3JsZC5wb3N0U29sdmUoY29udGFjdCwgaW1wdWxzZSk7XG4gICAgfVxufTtcblxuXG59LHtcIi4vQm9keVwiOjIsXCIuL0NvbnRhY3RcIjozLFwiLi9Kb2ludFwiOjUsXCIuL1NldHRpbmdzXCI6NyxcIi4vY29sbGlzaW9uL0Rpc3RhbmNlXCI6MTMsXCIuL2NvbGxpc2lvbi9UaW1lT2ZJbXBhY3RcIjoxNSxcIi4vY29tbW9uL01hdGhcIjoxOCxcIi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4vdXRpbC9jb21tb25cIjo1MH1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcblxudmFyIG9wdGlvbnMgPSByZXF1aXJlKFwiLi91dGlsL29wdGlvbnNcIik7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi91dGlsL2NvbW1vblwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi9jb21tb24vVmVjMlwiKTtcblxudmFyIEJyb2FkUGhhc2UgPSByZXF1aXJlKFwiLi9jb2xsaXNpb24vQnJvYWRQaGFzZVwiKTtcblxudmFyIFNvbHZlciA9IHJlcXVpcmUoXCIuL1NvbHZlclwiKTtcblxudmFyIEJvZHkgPSByZXF1aXJlKFwiLi9Cb2R5XCIpO1xuXG52YXIgQ29udGFjdCA9IHJlcXVpcmUoXCIuL0NvbnRhY3RcIik7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV29ybGREZWZcbiAqXG4gKiBAcHJvcCB7VmVjMn0gW2dyYXZpdHkgPSB7IHggOiAwLCB5IDogMH1dXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW2FsbG93U2xlZXAgPSB0cnVlXVxuICogQHByb3Age2Jvb2xlYW59IFt3YXJtU3RhcnRpbmcgPSBmYWxzZV1cbiAqIEBwcm9wIHtib29sZWFufSBbY29udGludW91c1BoeXNpY3MgPSBmYWxzZV1cbiAqIEBwcm9wIHtib29sZWFufSBbc3ViU3RlcHBpbmcgPSBmYWxzZV1cbiAqIEBwcm9wIHtib29sZWFufSBbYmxvY2tTb2x2ZSA9IHRydWVdXG4gKiBAcHJvcCB7aW50fSBbdmVsb2NpdHlJdGVyYXRpb25zID0gOF0gRm9yIHRoZSB2ZWxvY2l0eSBjb25zdHJhaW50IHNvbHZlci5cbiAqIEBwcm9wIHtpbnR9IFtwb3NpdGlvbkl0ZXJhdGlvbnMgPSAzXSBGb3IgdGhlIHBvc2l0aW9uIGNvbnN0cmFpbnQgc29sdmVyLlxuICovXG52YXIgV29ybGREZWYgPSB7XG4gICAgZ3Jhdml0eTogVmVjMi56ZXJvKCksXG4gICAgYWxsb3dTbGVlcDogdHJ1ZSxcbiAgICB3YXJtU3RhcnRpbmc6IHRydWUsXG4gICAgY29udGludW91c1BoeXNpY3M6IHRydWUsXG4gICAgc3ViU3RlcHBpbmc6IGZhbHNlLFxuICAgIGJsb2NrU29sdmU6IHRydWUsXG4gICAgdmVsb2NpdHlJdGVyYXRpb25zOiA4LFxuICAgIHBvc2l0aW9uSXRlcmF0aW9uczogM1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1dvcmREZWZ8VmVjMn0gZGVmIFdvcmxkIGRlZmluaXRpb24gb3IgZ3Jhdml0eSB2ZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIFdvcmxkKGRlZikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXb3JsZCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JsZChkZWYpO1xuICAgIH1cbiAgICBpZiAoZGVmICYmIFZlYzIuaXNWYWxpZChkZWYpKSB7XG4gICAgICAgIGRlZiA9IHtcbiAgICAgICAgICAgIGdyYXZpdHk6IGRlZlxuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWYgPSBvcHRpb25zKGRlZiwgV29ybGREZWYpO1xuICAgIHRoaXMubV9zb2x2ZXIgPSBuZXcgU29sdmVyKHRoaXMpO1xuICAgIHRoaXMubV9icm9hZFBoYXNlID0gbmV3IEJyb2FkUGhhc2UoKTtcbiAgICB0aGlzLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgIHRoaXMubV9jb250YWN0Q291bnQgPSAwO1xuICAgIHRoaXMubV9ib2R5TGlzdCA9IG51bGw7XG4gICAgdGhpcy5tX2JvZHlDb3VudCA9IDA7XG4gICAgdGhpcy5tX2pvaW50TGlzdCA9IG51bGw7XG4gICAgdGhpcy5tX2pvaW50Q291bnQgPSAwO1xuICAgIHRoaXMubV9zdGVwQ29tcGxldGUgPSB0cnVlO1xuICAgIHRoaXMubV9hbGxvd1NsZWVwID0gZGVmLmFsbG93U2xlZXA7XG4gICAgdGhpcy5tX2dyYXZpdHkgPSBWZWMyLmNsb25lKGRlZi5ncmF2aXR5KTtcbiAgICB0aGlzLm1fY2xlYXJGb3JjZXMgPSB0cnVlO1xuICAgIHRoaXMubV9uZXdGaXh0dXJlID0gZmFsc2U7XG4gICAgdGhpcy5tX2xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIFRoZXNlIGFyZSBmb3IgZGVidWdnaW5nIHRoZSBzb2x2ZXIuXG4gICAgdGhpcy5tX3dhcm1TdGFydGluZyA9IGRlZi53YXJtU3RhcnRpbmc7XG4gICAgdGhpcy5tX2NvbnRpbnVvdXNQaHlzaWNzID0gZGVmLmNvbnRpbnVvdXNQaHlzaWNzO1xuICAgIHRoaXMubV9zdWJTdGVwcGluZyA9IGRlZi5zdWJTdGVwcGluZztcbiAgICB0aGlzLm1fYmxvY2tTb2x2ZSA9IGRlZi5ibG9ja1NvbHZlO1xuICAgIHRoaXMubV92ZWxvY2l0eUl0ZXJhdGlvbnMgPSBkZWYudmVsb2NpdHlJdGVyYXRpb25zO1xuICAgIHRoaXMubV9wb3NpdGlvbkl0ZXJhdGlvbnMgPSBkZWYucG9zaXRpb25JdGVyYXRpb25zO1xuICAgIHRoaXMubV90ID0gMDtcbiAgICB0aGlzLm1fc3RlcENvdW50ID0gMDtcbiAgICAvLyBCcm9hZC1waGFzZSBjYWxsYmFjay5cbiAgICB0aGlzLmFkZFBhaXIgPSB0aGlzLmNyZWF0ZUNvbnRhY3QuYmluZCh0aGlzKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIGJvZHkgbGlzdC4gV2l0aCB0aGUgcmV0dXJuZWQgYm9keSwgdXNlIEJvZHkuZ2V0TmV4dCB0byBnZXQgdGhlXG4gKiBuZXh0IGJvZHkgaW4gdGhlIHdvcmxkIGxpc3QuIEEgbnVsbCBib2R5IGluZGljYXRlcyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGhlYWQgb2YgdGhlIHdvcmxkIGJvZHkgbGlzdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldEJvZHlMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5TGlzdDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBqb2ludCBsaXN0LiBXaXRoIHRoZSByZXR1cm5lZCBqb2ludCwgdXNlIEpvaW50LmdldE5leHQgdG8gZ2V0XG4gKiB0aGUgbmV4dCBqb2ludCBpbiB0aGUgd29ybGQgbGlzdC4gQSBudWxsIGpvaW50IGluZGljYXRlcyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGhlYWQgb2YgdGhlIHdvcmxkIGpvaW50IGxpc3QuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5nZXRKb2ludExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2pvaW50TGlzdDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBjb250YWN0IGxpc3QuIFdpdGggdGhlIHJldHVybmVkIGNvbnRhY3QsIHVzZSBDb250YWN0LmdldE5leHQgdG9cbiAqIGdldCB0aGUgbmV4dCBjb250YWN0IGluIHRoZSB3b3JsZCBsaXN0LiBBIG51bGwgY29udGFjdCBpbmRpY2F0ZXMgdGhlIGVuZCBvZlxuICogdGhlIGxpc3QuXG4gKlxuICogQHJldHVybiB0aGUgaGVhZCBvZiB0aGUgd29ybGQgY29udGFjdCBsaXN0LiBXYXJuaW5nOiBjb250YWN0cyBhcmUgY3JlYXRlZCBhbmRcbiAqICAgICAgICAgZGVzdHJveWVkIGluIHRoZSBtaWRkbGUgb2YgYSB0aW1lIHN0ZXAuIFVzZSBDb250YWN0TGlzdGVuZXIgdG8gYXZvaWRcbiAqICAgICAgICAgbWlzc2luZyBjb250YWN0cy5cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9jb250YWN0TGlzdDtcbn07XG5cbldvcmxkLnByb3RvdHlwZS5nZXRCb2R5Q291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlDb3VudDtcbn07XG5cbldvcmxkLnByb3RvdHlwZS5nZXRKb2ludENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9qb2ludENvdW50O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjb250YWN0cyAoZWFjaCBtYXkgaGF2ZSAwIG9yIG1vcmUgY29udGFjdCBwb2ludHMpLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9jb250YWN0Q291bnQ7XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgZ2xvYmFsIGdyYXZpdHkgdmVjdG9yLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R3Jhdml0eSA9IGZ1bmN0aW9uKGdyYXZpdHkpIHtcbiAgICB0aGlzLm1fZ3Jhdml0eSA9IGdyYXZpdHk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZ2xvYmFsIGdyYXZpdHkgdmVjdG9yLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0R3Jhdml0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZ3Jhdml0eTtcbn07XG5cbi8qKlxuICogSXMgdGhlIHdvcmxkIGxvY2tlZCAoaW4gdGhlIG1pZGRsZSBvZiBhIHRpbWUgc3RlcCkuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5pc0xvY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9ja2VkO1xufTtcblxuLyoqXG4gKiBFbmFibGUvZGlzYWJsZSBzbGVlcC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEFsbG93U2xlZXBpbmcgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgaWYgKGZsYWcgPT0gdGhpcy5tX2FsbG93U2xlZXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1fYWxsb3dTbGVlcCA9IGZsYWc7XG4gICAgaWYgKHRoaXMubV9hbGxvd1NsZWVwID09IGZhbHNlKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSB0aGlzLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgYi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbldvcmxkLnByb3RvdHlwZS5nZXRBbGxvd1NsZWVwaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9hbGxvd1NsZWVwO1xufTtcblxuLyoqXG4gKiBFbmFibGUvZGlzYWJsZSB3YXJtIHN0YXJ0aW5nLiBGb3IgdGVzdGluZy5cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldFdhcm1TdGFydGluZyA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICB0aGlzLm1fd2FybVN0YXJ0aW5nID0gZmxhZztcbn07XG5cbldvcmxkLnByb3RvdHlwZS5nZXRXYXJtU3RhcnRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3dhcm1TdGFydGluZztcbn07XG5cbi8qKlxuICogRW5hYmxlL2Rpc2FibGUgY29udGludW91cyBwaHlzaWNzLiBGb3IgdGVzdGluZy5cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldENvbnRpbnVvdXNQaHlzaWNzID0gZnVuY3Rpb24oZmxhZykge1xuICAgIHRoaXMubV9jb250aW51b3VzUGh5c2ljcyA9IGZsYWc7XG59O1xuXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGludW91c1BoeXNpY3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2NvbnRpbnVvdXNQaHlzaWNzO1xufTtcblxuLyoqXG4gKiBFbmFibGUvZGlzYWJsZSBzaW5nbGUgc3RlcHBlZCBjb250aW51b3VzIHBoeXNpY3MuIEZvciB0ZXN0aW5nLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0U3ViU3RlcHBpbmcgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgdGhpcy5tX3N1YlN0ZXBwaW5nID0gZmxhZztcbn07XG5cbldvcmxkLnByb3RvdHlwZS5nZXRTdWJTdGVwcGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fc3ViU3RlcHBpbmc7XG59O1xuXG4vKipcbiAqIFNldCBmbGFnIHRvIGNvbnRyb2wgYXV0b21hdGljIGNsZWFyaW5nIG9mIGZvcmNlcyBhZnRlciBlYWNoIHRpbWUgc3RlcC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEF1dG9DbGVhckZvcmNlcyA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICB0aGlzLm1fY2xlYXJGb3JjZXMgPSBmbGFnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZsYWcgdGhhdCBjb250cm9scyBhdXRvbWF0aWMgY2xlYXJpbmcgb2YgZm9yY2VzIGFmdGVyIGVhY2ggdGltZSBzdGVwLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0QXV0b0NsZWFyRm9yY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9jbGVhckZvcmNlcztcbn07XG5cbi8qKlxuICogTWFudWFsbHkgY2xlYXIgdGhlIGZvcmNlIGJ1ZmZlciBvbiBhbGwgYm9kaWVzLiBCeSBkZWZhdWx0LCBmb3JjZXMgYXJlIGNsZWFyZWRcbiAqIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0ZXAuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIG1vZGlmaWVkIGJ5XG4gKiBjYWxsaW5nIHNldEF1dG9DbGVhckZvcmNlcy4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBzdXBwb3J0XG4gKiBzdWItc3RlcHBpbmcuIFN1Yi1zdGVwcGluZyBpcyBvZnRlbiB1c2VkIHRvIG1haW50YWluIGEgZml4ZWQgc2l6ZWQgdGltZSBzdGVwXG4gKiB1bmRlciBhIHZhcmlhYmxlIGZyYW1lLXJhdGUuIFdoZW4geW91IHBlcmZvcm0gc3ViLXN0ZXBwaW5nIHlvdSB3aWxsIGRpc2FibGVcbiAqIGF1dG8gY2xlYXJpbmcgb2YgZm9yY2VzIGFuZCBpbnN0ZWFkIGNhbGwgY2xlYXJGb3JjZXMgYWZ0ZXIgYWxsIHN1Yi1zdGVwcyBhcmVcbiAqIGNvbXBsZXRlIGluIG9uZSBwYXNzIG9mIHlvdXIgZ2FtZSBsb29wLlxuICpcbiAqIEBzZWUgc2V0QXV0b0NsZWFyRm9yY2VzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5jbGVhckZvcmNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGJvZHkgPSB0aGlzLm1fYm9keUxpc3Q7IGJvZHk7IGJvZHkgPSBib2R5LmdldE5leHQoKSkge1xuICAgICAgICBib2R5Lm1fZm9yY2Uuc2V0WmVybygpO1xuICAgICAgICBib2R5Lm1fdG9ycXVlID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBXb3JsZH5yYXlDYXN0Q2FsbGJhY2tcbiAqXG4gKiBAcGFyYW0gZml4dHVyZVxuICovXG4vKipcbiAqIFF1ZXJ5IHRoZSB3b3JsZCBmb3IgYWxsIGZpeHR1cmVzIHRoYXQgcG90ZW50aWFsbHkgb3ZlcmxhcCB0aGUgcHJvdmlkZWQgQUFCQi5cbiAqXG4gKiBAcGFyYW0ge1dvcmxkfnF1ZXJ5Q2FsbGJhY2t9IHF1ZXJ5Q2FsbGJhY2sgQ2FsbGVkIGZvciBlYWNoIGZpeHR1cmVcbiAqICAgICAgICAgIGZvdW5kIGluIHRoZSBxdWVyeSBBQUJCLiBJdCBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gdGVybWluYXRlIHRoZVxuICogICAgICAgICAgcXVlcnkuXG4gKlxuICogQHBhcmFtIGFhYmIgVGhlIHF1ZXJ5IGJveC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnF1ZXJ5QUFCQiA9IGZ1bmN0aW9uKGFhYmIsIHF1ZXJ5Q2FsbGJhY2spIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodHlwZW9mIHF1ZXJ5Q2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fYnJvYWRQaGFzZTtcbiAgICB0aGlzLm1fYnJvYWRQaGFzZS5xdWVyeShhYWJiLCBmdW5jdGlvbihwcm94eUlkKSB7XG4gICAgICAgIC8vVE9ETyBHQ1xuICAgICAgICB2YXIgcHJveHkgPSBicm9hZFBoYXNlLmdldFVzZXJEYXRhKHByb3h5SWQpO1xuICAgICAgICAvLyBGaXh0dXJlUHJveHlcbiAgICAgICAgcmV0dXJuIHF1ZXJ5Q2FsbGJhY2socHJveHkuZml4dHVyZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBXb3JsZH5yYXlDYXN0Q2FsbGJhY2tcbiAqXG4gKiBDYWxsYmFjayBjbGFzcyBmb3IgcmF5IGNhc3RzLiBTZWUgV29ybGQucmF5Q2FzdFxuICpcbiAqIENhbGxlZCBmb3IgZWFjaCBmaXh0dXJlIGZvdW5kIGluIHRoZSBxdWVyeS4gWW91IGNvbnRyb2wgaG93IHRoZSByYXkgY2FzdFxuICogcHJvY2VlZHMgYnkgcmV0dXJuaW5nIGEgZmxvYXQ6IHJldHVybiAtMTogaWdub3JlIHRoaXMgZml4dHVyZSBhbmQgY29udGludWVcbiAqIHJldHVybiAwOiB0ZXJtaW5hdGUgdGhlIHJheSBjYXN0IHJldHVybiBmcmFjdGlvbjogY2xpcCB0aGUgcmF5IHRvIHRoaXMgcG9pbnRcbiAqIHJldHVybiAxOiBkb24ndCBjbGlwIHRoZSByYXkgYW5kIGNvbnRpbnVlXG4gKlxuICogQHBhcmFtIGZpeHR1cmUgVGhlIGZpeHR1cmUgaGl0IGJ5IHRoZSByYXlcbiAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgb2YgaW5pdGlhbCBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSBub3JtYWwgVGhlIG5vcm1hbCB2ZWN0b3IgYXQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxuICogQHBhcmFtIGZyYWN0aW9uXG4gKlxuICogQHJldHVybiB7ZmxvYXR9IC0xIHRvIGZpbHRlciwgMCB0byB0ZXJtaW5hdGUsIGZyYWN0aW9uIHRvIGNsaXAgdGhlIHJheSBmb3JcbiAqICAgICAgICAgY2xvc2VzdCBoaXQsIDEgdG8gY29udGludWVcbiAqL1xuLyoqXG4gKlxuICogUmF5LWNhc3QgdGhlIHdvcmxkIGZvciBhbGwgZml4dHVyZXMgaW4gdGhlIHBhdGggb2YgdGhlIHJheS4gWW91ciBjYWxsYmFja1xuICogY29udHJvbHMgd2hldGhlciB5b3UgZ2V0IHRoZSBjbG9zZXN0IHBvaW50LCBhbnkgcG9pbnQsIG9yIG4tcG9pbnRzLiBUaGVcbiAqIHJheS1jYXN0IGlnbm9yZXMgc2hhcGVzIHRoYXQgY29udGFpbiB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogQHBhcmFtIHtXb3JsZH5SYXlDYXN0Q2FsbGJhY2t9IHJlcG9ydEZpeHR1cmVDYWxsYmFjayBBIHVzZXIgaW1wbGVtZW50ZWRcbiAqICAgICAgICAgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHBvaW50MSBUaGUgcmF5IHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0gcG9pbnQyIFRoZSByYXkgZW5kaW5nIHBvaW50XG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24ocG9pbnQxLCBwb2ludDIsIHJlcG9ydEZpeHR1cmVDYWxsYmFjaykge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0eXBlb2YgcmVwb3J0Rml4dHVyZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX2Jyb2FkUGhhc2U7XG4gICAgdGhpcy5tX2Jyb2FkUGhhc2UucmF5Q2FzdCh7XG4gICAgICAgIG1heEZyYWN0aW9uOiAxLFxuICAgICAgICBwMTogcG9pbnQxLFxuICAgICAgICBwMjogcG9pbnQyXG4gICAgfSwgZnVuY3Rpb24oaW5wdXQsIHByb3h5SWQpIHtcbiAgICAgICAgLy8gVE9ETyBHQ1xuICAgICAgICB2YXIgcHJveHkgPSBicm9hZFBoYXNlLmdldFVzZXJEYXRhKHByb3h5SWQpO1xuICAgICAgICAvLyBGaXh0dXJlUHJveHlcbiAgICAgICAgdmFyIGZpeHR1cmUgPSBwcm94eS5maXh0dXJlO1xuICAgICAgICB2YXIgaW5kZXggPSBwcm94eS5jaGlsZEluZGV4O1xuICAgICAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgICAgIC8vIFRPRE8gR0NcbiAgICAgICAgdmFyIGhpdCA9IGZpeHR1cmUucmF5Q2FzdChvdXRwdXQsIGlucHV0LCBpbmRleCk7XG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgIHZhciBmcmFjdGlvbiA9IG91dHB1dC5mcmFjdGlvbjtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IFZlYzIuYWRkKFZlYzIubXVsKDEgLSBmcmFjdGlvbiwgaW5wdXQucDEpLCBWZWMyLm11bChmcmFjdGlvbiwgaW5wdXQucDIpKTtcbiAgICAgICAgICAgIHJldHVybiByZXBvcnRGaXh0dXJlQ2FsbGJhY2soZml4dHVyZSwgcG9pbnQsIG91dHB1dC5ub3JtYWwsIGZyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGJyb2FkLXBoYXNlIHByb3hpZXMuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5nZXRQcm94eUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9icm9hZFBoYXNlLmdldFByb3h5Q291bnQoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBoZWlnaHQgb2YgYnJvYWQtcGhhc2UgZHluYW1pYyB0cmVlLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0VHJlZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYnJvYWRQaGFzZS5nZXRUcmVlSGVpZ2h0KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYmFsYW5jZSBvZiBicm9hZC1waGFzZSBkeW5hbWljIHRyZWUuXG4gKlxuICogQHJldHVybnMge2ludH1cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldFRyZWVCYWxhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9icm9hZFBoYXNlLmdldFRyZWVCYWxhbmNlKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVhbGl0eSBtZXRyaWMgb2YgYnJvYWQtcGhhc2UgZHluYW1pYyB0cmVlLiBUaGUgc21hbGxlciB0aGUgYmV0dGVyLlxuICogVGhlIG1pbmltdW0gaXMgMS5cbiAqXG4gKiBAcmV0dXJucyB7ZmxvYXR9XG4gKi9cbldvcmxkLnByb3RvdHlwZS5nZXRUcmVlUXVhbGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYnJvYWRQaGFzZS5nZXRUcmVlUXVhbGl0eSgpO1xufTtcblxuLyoqXG4gKiBTaGlmdCB0aGUgd29ybGQgb3JpZ2luLiBVc2VmdWwgZm9yIGxhcmdlIHdvcmxkcy4gVGhlIGJvZHkgc2hpZnQgZm9ybXVsYSBpczpcbiAqIHBvc2l0aW9uIC09IG5ld09yaWdpblxuICpcbiAqIEBwYXJhbSB7VmVjMn0gbmV3T3JpZ2luIFRoZSBuZXcgb3JpZ2luIHdpdGggcmVzcGVjdCB0byB0aGUgb2xkIG9yaWdpblxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbihuZXdPcmlnaW4pIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5tX2xvY2tlZCA9PSBmYWxzZSk7XG4gICAgaWYgKHRoaXMubV9sb2NrZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBiID0gdGhpcy5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgYi5tX3hmLnAuc3ViKG5ld09yaWdpbik7XG4gICAgICAgIGIubV9zd2VlcC5jMC5zdWIobmV3T3JpZ2luKTtcbiAgICAgICAgYi5tX3N3ZWVwLmMuc3ViKG5ld09yaWdpbik7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSB0aGlzLm1fam9pbnRMaXN0OyBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgai5zaGlmdE9yaWdpbihuZXdPcmlnaW4pO1xuICAgIH1cbiAgICB0aGlzLm1fYnJvYWRQaGFzZS5zaGlmdE9yaWdpbihuZXdPcmlnaW4pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByaWdpZCBib2R5IGdpdmVuIGEgZGVmaW5pdGlvbi4gTm8gcmVmZXJlbmNlIHRvIHRoZSBkZWZpbml0aW9uIGlzXG4gKiByZXRhaW5lZC5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7Qm9keURlZnxWZWMyfSBkZWYgQm9keSBkZWZpbml0aW9uIG9yIHBvc2l0aW9uLlxuICogQHBhcmFtIHtmbG9hdH0gYW5nbGUgQm9keSBhbmdsZSBpZiBkZWYgaXMgcG9zaXRpb24uXG4gKi9cbldvcmxkLnByb3RvdHlwZS5jcmVhdGVCb2R5ID0gZnVuY3Rpb24oZGVmLCBhbmdsZSkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0aGlzLmlzTG9ja2VkKCkgPT0gZmFsc2UpO1xuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkZWYgJiYgVmVjMi5pc1ZhbGlkKGRlZikpIHtcbiAgICAgICAgZGVmID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IGRlZixcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHRoaXMsIGRlZik7XG4gICAgLy8gQWRkIHRvIHdvcmxkIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAgICBib2R5Lm1fcHJldiA9IG51bGw7XG4gICAgYm9keS5tX25leHQgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgaWYgKHRoaXMubV9ib2R5TGlzdCkge1xuICAgICAgICB0aGlzLm1fYm9keUxpc3QubV9wcmV2ID0gYm9keTtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlMaXN0ID0gYm9keTtcbiAgICArK3RoaXMubV9ib2R5Q291bnQ7XG4gICAgcmV0dXJuIGJvZHk7XG59O1xuXG5Xb3JsZC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY0JvZHkgPSBmdW5jdGlvbihkZWYsIGFuZ2xlKSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgICAgZGVmID0ge307XG4gICAgfSBlbHNlIGlmIChWZWMyLmlzVmFsaWQoZGVmKSkge1xuICAgICAgICBkZWYgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogZGVmLFxuICAgICAgICAgICAgYW5nbGU6IGFuZ2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRlZi50eXBlID0gXCJkeW5hbWljXCI7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQm9keShkZWYpO1xufTtcblxuV29ybGQucHJvdG90eXBlLmNyZWF0ZUtpbmVtYXRpY0JvZHkgPSBmdW5jdGlvbihkZWYsIGFuZ2xlKSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgICAgZGVmID0ge307XG4gICAgfSBlbHNlIGlmIChWZWMyLmlzVmFsaWQoZGVmKSkge1xuICAgICAgICBkZWYgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogZGVmLFxuICAgICAgICAgICAgYW5nbGU6IGFuZ2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRlZi50eXBlID0gXCJraW5lbWF0aWNcIjtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVCb2R5KGRlZik7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgYSByaWdpZCBib2R5IGdpdmVuIGEgZGVmaW5pdGlvbi4gTm8gcmVmZXJlbmNlIHRvIHRoZSBkZWZpbml0aW9uIGlzXG4gKiByZXRhaW5lZC5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGF1dG9tYXRpY2FsbHkgZGVsZXRlcyBhbGwgYXNzb2NpYXRlZCBzaGFwZXMgYW5kIGpvaW50cy5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7Qm9keX0gYlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZGVzdHJveUJvZHkgPSBmdW5jdGlvbihiKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMubV9ib2R5Q291bnQgPiAwKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5pc0xvY2tlZCgpID09IGZhbHNlKTtcbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGIubV9kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBEZWxldGUgdGhlIGF0dGFjaGVkIGpvaW50cy5cbiAgICB2YXIgamUgPSBiLm1fam9pbnRMaXN0O1xuICAgIHdoaWxlIChqZSkge1xuICAgICAgICB2YXIgamUwID0gamU7XG4gICAgICAgIGplID0gamUubmV4dDtcbiAgICAgICAgdGhpcy5wdWJsaXNoKFwicmVtb3ZlLWpvaW50XCIsIGplMC5qb2ludCk7XG4gICAgICAgIHRoaXMuZGVzdHJveUpvaW50KGplMC5qb2ludCk7XG4gICAgICAgIGIubV9qb2ludExpc3QgPSBqZTtcbiAgICB9XG4gICAgYi5tX2pvaW50TGlzdCA9IG51bGw7XG4gICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBjb250YWN0cy5cbiAgICB2YXIgY2UgPSBiLm1fY29udGFjdExpc3Q7XG4gICAgd2hpbGUgKGNlKSB7XG4gICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgY2UgPSBjZS5uZXh0O1xuICAgICAgICB0aGlzLmRlc3Ryb3lDb250YWN0KGNlMC5jb250YWN0KTtcbiAgICAgICAgYi5tX2NvbnRhY3RMaXN0ID0gY2U7XG4gICAgfVxuICAgIGIubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBmaXh0dXJlcy4gVGhpcyBkZXN0cm95cyBicm9hZC1waGFzZSBwcm94aWVzLlxuICAgIHZhciBmID0gYi5tX2ZpeHR1cmVMaXN0O1xuICAgIHdoaWxlIChmKSB7XG4gICAgICAgIHZhciBmMCA9IGY7XG4gICAgICAgIGYgPSBmLm1fbmV4dDtcbiAgICAgICAgdGhpcy5wdWJsaXNoKFwicmVtb3ZlLWZpeHR1cmVcIiwgZjApO1xuICAgICAgICBmMC5kZXN0cm95UHJveGllcyh0aGlzLm1fYnJvYWRQaGFzZSk7XG4gICAgICAgIGIubV9maXh0dXJlTGlzdCA9IGY7XG4gICAgfVxuICAgIGIubV9maXh0dXJlTGlzdCA9IG51bGw7XG4gICAgLy8gUmVtb3ZlIHdvcmxkIGJvZHkgbGlzdC5cbiAgICBpZiAoYi5tX3ByZXYpIHtcbiAgICAgICAgYi5tX3ByZXYubV9uZXh0ID0gYi5tX25leHQ7XG4gICAgfVxuICAgIGlmIChiLm1fbmV4dCkge1xuICAgICAgICBiLm1fbmV4dC5tX3ByZXYgPSBiLm1fcHJldjtcbiAgICB9XG4gICAgaWYgKGIgPT0gdGhpcy5tX2JvZHlMaXN0KSB7XG4gICAgICAgIHRoaXMubV9ib2R5TGlzdCA9IGIubV9uZXh0O1xuICAgIH1cbiAgICBiLm1fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAtLXRoaXMubV9ib2R5Q291bnQ7XG4gICAgdGhpcy5wdWJsaXNoKFwicmVtb3ZlLWJvZHlcIiwgYik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGpvaW50IHRvIGNvbnN0cmFpbiBib2RpZXMgdG9nZXRoZXIuIE5vIHJlZmVyZW5jZSB0byB0aGUgZGVmaW5pdGlvblxuICogaXMgcmV0YWluZWQuIFRoaXMgbWF5IGNhdXNlIHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGNlYXNlIGNvbGxpZGluZy5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7Sm9pbnR9IGpvaW5cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqL1xuV29ybGQucHJvdG90eXBlLmNyZWF0ZUpvaW50ID0gZnVuY3Rpb24oam9pbnQpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoISFqb2ludC5tX2JvZHlBKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoISFqb2ludC5tX2JvZHlCKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5pc0xvY2tlZCgpID09IGZhbHNlKTtcbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb25uZWN0IHRvIHRoZSB3b3JsZCBsaXN0LlxuICAgIGpvaW50Lm1fcHJldiA9IG51bGw7XG4gICAgam9pbnQubV9uZXh0ID0gdGhpcy5tX2pvaW50TGlzdDtcbiAgICBpZiAodGhpcy5tX2pvaW50TGlzdCkge1xuICAgICAgICB0aGlzLm1fam9pbnRMaXN0Lm1fcHJldiA9IGpvaW50O1xuICAgIH1cbiAgICB0aGlzLm1fam9pbnRMaXN0ID0gam9pbnQ7XG4gICAgKyt0aGlzLm1fam9pbnRDb3VudDtcbiAgICAvLyBDb25uZWN0IHRvIHRoZSBib2RpZXMnIGRvdWJseSBsaW5rZWQgbGlzdHMuXG4gICAgam9pbnQubV9lZGdlQS5qb2ludCA9IGpvaW50O1xuICAgIGpvaW50Lm1fZWRnZUEub3RoZXIgPSBqb2ludC5tX2JvZHlCO1xuICAgIGpvaW50Lm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgam9pbnQubV9lZGdlQS5uZXh0ID0gam9pbnQubV9ib2R5QS5tX2pvaW50TGlzdDtcbiAgICBpZiAoam9pbnQubV9ib2R5QS5tX2pvaW50TGlzdCkgam9pbnQubV9ib2R5QS5tX2pvaW50TGlzdC5wcmV2ID0gam9pbnQubV9lZGdlQTtcbiAgICBqb2ludC5tX2JvZHlBLm1fam9pbnRMaXN0ID0gam9pbnQubV9lZGdlQTtcbiAgICBqb2ludC5tX2VkZ2VCLmpvaW50ID0gam9pbnQ7XG4gICAgam9pbnQubV9lZGdlQi5vdGhlciA9IGpvaW50Lm1fYm9keUE7XG4gICAgam9pbnQubV9lZGdlQi5wcmV2ID0gbnVsbDtcbiAgICBqb2ludC5tX2VkZ2VCLm5leHQgPSBqb2ludC5tX2JvZHlCLm1fam9pbnRMaXN0O1xuICAgIGlmIChqb2ludC5tX2JvZHlCLm1fam9pbnRMaXN0KSBqb2ludC5tX2JvZHlCLm1fam9pbnRMaXN0LnByZXYgPSBqb2ludC5tX2VkZ2VCO1xuICAgIGpvaW50Lm1fYm9keUIubV9qb2ludExpc3QgPSBqb2ludC5tX2VkZ2VCO1xuICAgIC8vIElmIHRoZSBqb2ludCBwcmV2ZW50cyBjb2xsaXNpb25zLCB0aGVuIGZsYWcgYW55IGNvbnRhY3RzIGZvciBmaWx0ZXJpbmcuXG4gICAgaWYgKGpvaW50Lm1fY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICBmb3IgKHZhciBlZGdlID0gam9pbnQubV9ib2R5Qi5nZXRDb250YWN0TGlzdCgpOyBlZGdlOyBlZGdlID0gZWRnZS5uZXh0KSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBqb2ludC5tX2JvZHlBKSB7XG4gICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgY29udGFjdCBmb3IgZmlsdGVyaW5nIGF0IHRoZSBuZXh0IHRpbWUgc3RlcCAod2hlcmUgZWl0aGVyXG4gICAgICAgICAgICAgICAgLy8gYm9keSBpcyBhd2FrZSkuXG4gICAgICAgICAgICAgICAgZWRnZS5jb250YWN0LmZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RlOiBjcmVhdGluZyBhIGpvaW50IGRvZXNuJ3Qgd2FrZSB0aGUgYm9kaWVzLlxuICAgIHJldHVybiBqb2ludDtcbn07XG5cbi8qKlxuICogRGVzdHJveSBhIGpvaW50LiBUaGlzIG1heSBjYXVzZSB0aGUgY29ubmVjdGVkIGJvZGllcyB0byBiZWdpbiBjb2xsaWRpbmcuXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7Sm9pbnR9IGpvaW5cbiAqL1xuV29ybGQucHJvdG90eXBlLmRlc3Ryb3lKb2ludCA9IGZ1bmN0aW9uKGpvaW50KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMuaXNMb2NrZWQoKSA9PSBmYWxzZSk7XG4gICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBkb3VibHkgbGlua2VkIGxpc3QuXG4gICAgaWYgKGpvaW50Lm1fcHJldikge1xuICAgICAgICBqb2ludC5tX3ByZXYubV9uZXh0ID0gam9pbnQubV9uZXh0O1xuICAgIH1cbiAgICBpZiAoam9pbnQubV9uZXh0KSB7XG4gICAgICAgIGpvaW50Lm1fbmV4dC5tX3ByZXYgPSBqb2ludC5tX3ByZXY7XG4gICAgfVxuICAgIGlmIChqb2ludCA9PSB0aGlzLm1fam9pbnRMaXN0KSB7XG4gICAgICAgIHRoaXMubV9qb2ludExpc3QgPSBqb2ludC5tX25leHQ7XG4gICAgfVxuICAgIC8vIERpc2Nvbm5lY3QgZnJvbSBib2RpZXMuXG4gICAgdmFyIGJvZHlBID0gam9pbnQubV9ib2R5QTtcbiAgICB2YXIgYm9keUIgPSBqb2ludC5tX2JvZHlCO1xuICAgIC8vIFdha2UgdXAgY29ubmVjdGVkIGJvZGllcy5cbiAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICBib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDEuXG4gICAgaWYgKGpvaW50Lm1fZWRnZUEucHJldikge1xuICAgICAgICBqb2ludC5tX2VkZ2VBLnByZXYubmV4dCA9IGpvaW50Lm1fZWRnZUEubmV4dDtcbiAgICB9XG4gICAgaWYgKGpvaW50Lm1fZWRnZUEubmV4dCkge1xuICAgICAgICBqb2ludC5tX2VkZ2VBLm5leHQucHJldiA9IGpvaW50Lm1fZWRnZUEucHJldjtcbiAgICB9XG4gICAgaWYgKGpvaW50Lm1fZWRnZUEgPT0gYm9keUEubV9qb2ludExpc3QpIHtcbiAgICAgICAgYm9keUEubV9qb2ludExpc3QgPSBqb2ludC5tX2VkZ2VBLm5leHQ7XG4gICAgfVxuICAgIGpvaW50Lm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgam9pbnQubV9lZGdlQS5uZXh0ID0gbnVsbDtcbiAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDJcbiAgICBpZiAoam9pbnQubV9lZGdlQi5wcmV2KSB7XG4gICAgICAgIGpvaW50Lm1fZWRnZUIucHJldi5uZXh0ID0gam9pbnQubV9lZGdlQi5uZXh0O1xuICAgIH1cbiAgICBpZiAoam9pbnQubV9lZGdlQi5uZXh0KSB7XG4gICAgICAgIGpvaW50Lm1fZWRnZUIubmV4dC5wcmV2ID0gam9pbnQubV9lZGdlQi5wcmV2O1xuICAgIH1cbiAgICBpZiAoam9pbnQubV9lZGdlQiA9PSBib2R5Qi5tX2pvaW50TGlzdCkge1xuICAgICAgICBib2R5Qi5tX2pvaW50TGlzdCA9IGpvaW50Lm1fZWRnZUIubmV4dDtcbiAgICB9XG4gICAgam9pbnQubV9lZGdlQi5wcmV2ID0gbnVsbDtcbiAgICBqb2ludC5tX2VkZ2VCLm5leHQgPSBudWxsO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0aGlzLm1fam9pbnRDb3VudCA+IDApO1xuICAgIC0tdGhpcy5tX2pvaW50Q291bnQ7XG4gICAgLy8gSWYgdGhlIGpvaW50IHByZXZlbnRzIGNvbGxpc2lvbnMsIHRoZW4gZmxhZyBhbnkgY29udGFjdHMgZm9yIGZpbHRlcmluZy5cbiAgICBpZiAoam9pbnQubV9jb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKSB7XG4gICAgICAgIHZhciBlZGdlID0gYm9keUIuZ2V0Q29udGFjdExpc3QoKTtcbiAgICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLm90aGVyID09IGJvZHlBKSB7XG4gICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgY29udGFjdCBmb3IgZmlsdGVyaW5nIGF0IHRoZSBuZXh0IHRpbWUgc3RlcCAod2hlcmUgZWl0aGVyXG4gICAgICAgICAgICAgICAgLy8gYm9keSBpcyBhd2FrZSkuXG4gICAgICAgICAgICAgICAgZWRnZS5jb250YWN0LmZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wdWJsaXNoKFwicmVtb3ZlLWpvaW50XCIsIGpvaW50KTtcbn07XG5cbnZhciBzX3N0ZXAgPSBuZXcgU29sdmVyLlRpbWVTdGVwKCk7XG5cbi8vIHJldXNlXG4vKipcbiAqIFRha2UgYSB0aW1lIHN0ZXAuIFRoaXMgcGVyZm9ybXMgY29sbGlzaW9uIGRldGVjdGlvbiwgaW50ZWdyYXRpb24sIGFuZFxuICogY29uc3RyYWludCBzb2x1dGlvbi5cbiAqXG4gKiBCcm9hZC1waGFzZSwgbmFycm93LXBoYXNlLCBzb2x2ZSBhbmQgc29sdmUgdGltZSBvZiBpbXBhY3RzLlxuICpcbiAqIEBwYXJhbSB7ZmxvYXR9IHRpbWVTdGVwIFRpbWUgc3RlcCwgdGhpcyBzaG91bGQgbm90IHZhcnkuXG4gKiBAcGFyYW0ge2ludH0gdmVsb2NpdHlJdGVyYXRpb25zXG4gKiBAcGFyYW0ge2ludH0gcG9zaXRpb25JdGVyYXRpb25zXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24odGltZVN0ZXAsIHZlbG9jaXR5SXRlcmF0aW9ucywgcG9zaXRpb25JdGVyYXRpb25zKSB7XG4gICAgaWYgKCh2ZWxvY2l0eUl0ZXJhdGlvbnMgfCAwKSAhPT0gdmVsb2NpdHlJdGVyYXRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGluIGZ1dHVyZVxuICAgICAgICB2ZWxvY2l0eUl0ZXJhdGlvbnMgPSAwO1xuICAgIH1cbiAgICB2ZWxvY2l0eUl0ZXJhdGlvbnMgPSB2ZWxvY2l0eUl0ZXJhdGlvbnMgfHwgdGhpcy5tX3ZlbG9jaXR5SXRlcmF0aW9ucztcbiAgICBwb3NpdGlvbkl0ZXJhdGlvbnMgPSBwb3NpdGlvbkl0ZXJhdGlvbnMgfHwgdGhpcy5tX3Bvc2l0aW9uSXRlcmF0aW9ucztcbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gdGVzdGJlZFxuICAgIHRoaXMubV9zdGVwQ291bnQrKztcbiAgICAvLyBJZiBuZXcgZml4dHVyZXMgd2VyZSBhZGRlZCwgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXcgY29udGFjdHMuXG4gICAgaWYgKHRoaXMubV9uZXdGaXh0dXJlKSB7XG4gICAgICAgIHRoaXMuZmluZE5ld0NvbnRhY3RzKCk7XG4gICAgICAgIHRoaXMubV9uZXdGaXh0dXJlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubV9sb2NrZWQgPSB0cnVlO1xuICAgIHNfc3RlcC5yZXNldCh0aW1lU3RlcCk7XG4gICAgc19zdGVwLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHZlbG9jaXR5SXRlcmF0aW9ucztcbiAgICBzX3N0ZXAucG9zaXRpb25JdGVyYXRpb25zID0gcG9zaXRpb25JdGVyYXRpb25zO1xuICAgIHNfc3RlcC53YXJtU3RhcnRpbmcgPSB0aGlzLm1fd2FybVN0YXJ0aW5nO1xuICAgIHNfc3RlcC5ibG9ja1NvbHZlID0gdGhpcy5tX2Jsb2NrU29sdmU7XG4gICAgLy8gVXBkYXRlIGNvbnRhY3RzLiBUaGlzIGlzIHdoZXJlIHNvbWUgY29udGFjdHMgYXJlIGRlc3Ryb3llZC5cbiAgICB0aGlzLnVwZGF0ZUNvbnRhY3RzKCk7XG4gICAgLy8gSW50ZWdyYXRlIHZlbG9jaXRpZXMsIHNvbHZlIHZlbG9jaXR5IGNvbnN0cmFpbnRzLCBhbmQgaW50ZWdyYXRlIHBvc2l0aW9ucy5cbiAgICBpZiAodGhpcy5tX3N0ZXBDb21wbGV0ZSAmJiB0aW1lU3RlcCA+IDApIHtcbiAgICAgICAgdGhpcy5tX3NvbHZlci5zb2x2ZVdvcmxkKHNfc3RlcCk7XG4gICAgICAgIC8vIFN5bmNocm9uaXplIGZpeHR1cmVzLCBjaGVjayBmb3Igb3V0IG9mIHJhbmdlIGJvZGllcy5cbiAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMubV9ib2R5TGlzdDsgYjsgYiA9IGIuZ2V0TmV4dCgpKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGJvZHkgd2FzIG5vdCBpbiBhbiBpc2xhbmQgdGhlbiBpdCBkaWQgbm90IG1vdmUuXG4gICAgICAgICAgICBpZiAoYi5tX2lzbGFuZEZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBmaXh0dXJlcyAoZm9yIGJyb2FkLXBoYXNlKS5cbiAgICAgICAgICAgIGIuc3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgZm9yIG5ldyBjb250YWN0cy5cbiAgICAgICAgdGhpcy5maW5kTmV3Q29udGFjdHMoKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIFRPSSBldmVudHMuXG4gICAgaWYgKHRoaXMubV9jb250aW51b3VzUGh5c2ljcyAmJiB0aW1lU3RlcCA+IDApIHtcbiAgICAgICAgdGhpcy5tX3NvbHZlci5zb2x2ZVdvcmxkVE9JKHNfc3RlcCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1fY2xlYXJGb3JjZXMpIHtcbiAgICAgICAgdGhpcy5jbGVhckZvcmNlcygpO1xuICAgIH1cbiAgICB0aGlzLm1fbG9ja2VkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIENhbGwgdGhpcyBtZXRob2QgdG8gZmluZCBuZXcgY29udGFjdHMuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5maW5kTmV3Q29udGFjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1fYnJvYWRQaGFzZS51cGRhdGVQYWlycyh0aGlzLmFkZFBhaXIpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Rml4dHVyZVByb3h5fSBwcm94eUFcbiAqIEBwYXJhbSB7Rml4dHVyZVByb3h5fSBwcm94eUJcbiAqL1xuV29ybGQucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3QgPSBmdW5jdGlvbihwcm94eUEsIHByb3h5Qikge1xuICAgIHZhciBmaXh0dXJlQSA9IHByb3h5QS5maXh0dXJlO1xuICAgIHZhciBmaXh0dXJlQiA9IHByb3h5Qi5maXh0dXJlO1xuICAgIHZhciBpbmRleEEgPSBwcm94eUEuY2hpbGRJbmRleDtcbiAgICB2YXIgaW5kZXhCID0gcHJveHlCLmNoaWxkSW5kZXg7XG4gICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICAvLyBBcmUgdGhlIGZpeHR1cmVzIG9uIHRoZSBzYW1lIGJvZHk/XG4gICAgaWYgKGJvZHlBID09PSBib2R5Qikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRPRE9fRVJJTiB1c2UgYSBoYXNoIHRhYmxlIHRvIHJlbW92ZSBhIHBvdGVudGlhbCBib3R0bGVuZWNrIHdoZW4gYm90aFxuICAgIC8vIGJvZGllcyBoYXZlIGEgbG90IG9mIGNvbnRhY3RzLlxuICAgIC8vIERvZXMgYSBjb250YWN0IGFscmVhZHkgZXhpc3Q/XG4gICAgdmFyIGVkZ2UgPSBib2R5Qi5nZXRDb250YWN0TGlzdCgpO1xuICAgIC8vIENvbnRhY3RFZGdlXG4gICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgaWYgKGVkZ2Uub3RoZXIgPT09IGJvZHlBKSB7XG4gICAgICAgICAgICB2YXIgZkEgPSBlZGdlLmNvbnRhY3QuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgICAgIHZhciBmQiA9IGVkZ2UuY29udGFjdC5nZXRGaXh0dXJlQigpO1xuICAgICAgICAgICAgdmFyIGlBID0gZWRnZS5jb250YWN0LmdldENoaWxkSW5kZXhBKCk7XG4gICAgICAgICAgICB2YXIgaUIgPSBlZGdlLmNvbnRhY3QuZ2V0Q2hpbGRJbmRleEIoKTtcbiAgICAgICAgICAgIGlmIChmQSA9PT0gZml4dHVyZUEgJiYgZkIgPT09IGZpeHR1cmVCICYmIGlBID09PSBpbmRleEEgJiYgaUIgPT09IGluZGV4Qikge1xuICAgICAgICAgICAgICAgIC8vIEEgY29udGFjdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZkEgPT09IGZpeHR1cmVCICYmIGZCID09PSBmaXh0dXJlQSAmJiBpQSA9PT0gaW5kZXhCICYmIGlCID09PSBpbmRleEEpIHtcbiAgICAgICAgICAgICAgICAvLyBBIGNvbnRhY3QgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgfVxuICAgIGlmIChib2R5Qi5zaG91bGRDb2xsaWRlKGJvZHlBKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZml4dHVyZUIuc2hvdWxkQ29sbGlkZShmaXh0dXJlQSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2FsbCB0aGUgZmFjdG9yeS5cbiAgICB2YXIgY29udGFjdCA9IENvbnRhY3QuY3JlYXRlKGZpeHR1cmVBLCBpbmRleEEsIGZpeHR1cmVCLCBpbmRleEIpO1xuICAgIGlmIChjb250YWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgaW50byB0aGUgd29ybGQuXG4gICAgY29udGFjdC5tX3ByZXYgPSBudWxsO1xuICAgIGlmICh0aGlzLm1fY29udGFjdExpc3QgIT0gbnVsbCkge1xuICAgICAgICBjb250YWN0Lm1fbmV4dCA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0Lm1fcHJldiA9IGNvbnRhY3Q7XG4gICAgfVxuICAgIHRoaXMubV9jb250YWN0TGlzdCA9IGNvbnRhY3Q7XG4gICAgKyt0aGlzLm1fY29udGFjdENvdW50O1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIG9sZCBub24tb3ZlcmxhcHBpbmcgY29udGFjdHMsIGFwcGxpZXMgZmlsdGVycyBhbmQgdXBkYXRlcyBjb250YWN0cy5cbiAqL1xuV29ybGQucHJvdG90eXBlLnVwZGF0ZUNvbnRhY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIGF3YWtlIGNvbnRhY3RzLlxuICAgIHZhciBjLCBuZXh0X2MgPSB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgd2hpbGUgKGMgPSBuZXh0X2MpIHtcbiAgICAgICAgbmV4dF9jID0gYy5nZXROZXh0KCk7XG4gICAgICAgIHZhciBmaXh0dXJlQSA9IGMuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgdmFyIGZpeHR1cmVCID0gYy5nZXRGaXh0dXJlQigpO1xuICAgICAgICB2YXIgaW5kZXhBID0gYy5nZXRDaGlsZEluZGV4QSgpO1xuICAgICAgICB2YXIgaW5kZXhCID0gYy5nZXRDaGlsZEluZGV4QigpO1xuICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5nZXRCb2R5KCk7XG4gICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICAgICAgLy8gSXMgdGhpcyBjb250YWN0IGZsYWdnZWQgZm9yIGZpbHRlcmluZz9cbiAgICAgICAgaWYgKGMubV9maWx0ZXJGbGFnKSB7XG4gICAgICAgICAgICBpZiAoYm9keUIuc2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lDb250YWN0KGMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpeHR1cmVCLnNob3VsZENvbGxpZGUoZml4dHVyZUEpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Q29udGFjdChjKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBmaWx0ZXJpbmcgZmxhZy5cbiAgICAgICAgICAgIGMubV9maWx0ZXJGbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZUEgPSBib2R5QS5pc0F3YWtlKCkgJiYgIWJvZHlBLmlzU3RhdGljKCk7XG4gICAgICAgIHZhciBhY3RpdmVCID0gYm9keUIuaXNBd2FrZSgpICYmICFib2R5Qi5pc1N0YXRpYygpO1xuICAgICAgICAvLyBBdCBsZWFzdCBvbmUgYm9keSBtdXN0IGJlIGF3YWtlIGFuZCBpdCBtdXN0IGJlIGR5bmFtaWMgb3Iga2luZW1hdGljLlxuICAgICAgICBpZiAoYWN0aXZlQSA9PSBmYWxzZSAmJiBhY3RpdmVCID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJveHlJZEEgPSBmaXh0dXJlQS5tX3Byb3hpZXNbaW5kZXhBXS5wcm94eUlkO1xuICAgICAgICB2YXIgcHJveHlJZEIgPSBmaXh0dXJlQi5tX3Byb3hpZXNbaW5kZXhCXS5wcm94eUlkO1xuICAgICAgICB2YXIgb3ZlcmxhcCA9IHRoaXMubV9icm9hZFBoYXNlLnRlc3RPdmVybGFwKHByb3h5SWRBLCBwcm94eUlkQik7XG4gICAgICAgIC8vIEhlcmUgd2UgZGVzdHJveSBjb250YWN0cyB0aGF0IGNlYXNlIHRvIG92ZXJsYXAgaW4gdGhlIGJyb2FkLXBoYXNlLlxuICAgICAgICBpZiAob3ZlcmxhcCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95Q29udGFjdChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjb250YWN0IHBlcnNpc3RzLlxuICAgICAgICBjLnVwZGF0ZSh0aGlzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Q29udGFjdH0gY29udGFjdFxuICovXG5Xb3JsZC5wcm90b3R5cGUuZGVzdHJveUNvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0KSB7XG4gICAgQ29udGFjdC5kZXN0cm95KGNvbnRhY3QsIHRoaXMpO1xuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB3b3JsZC5cbiAgICBpZiAoY29udGFjdC5tX3ByZXYpIHtcbiAgICAgICAgY29udGFjdC5tX3ByZXYubV9uZXh0ID0gY29udGFjdC5tX25leHQ7XG4gICAgfVxuICAgIGlmIChjb250YWN0Lm1fbmV4dCkge1xuICAgICAgICBjb250YWN0Lm1fbmV4dC5tX3ByZXYgPSBjb250YWN0Lm1fcHJldjtcbiAgICB9XG4gICAgaWYgKGNvbnRhY3QgPT0gdGhpcy5tX2NvbnRhY3RMaXN0KSB7XG4gICAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IGNvbnRhY3QubV9uZXh0O1xuICAgIH1cbiAgICAtLXRoaXMubV9jb250YWN0Q291bnQ7XG59O1xuXG5Xb3JsZC5wcm90b3R5cGUuX2xpc3RlbmVycyA9IG51bGw7XG5cbi8qKlxuICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG4gKi9cbldvcmxkLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuICovXG5Xb3JsZC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW25hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuV29ybGQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbihuYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbbmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGlzdGVuZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tsXS5jYWxsKHRoaXMsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQGV2ZW50IFdvcmxkI3JlbW92ZS1ib2R5XG4gKiBAZXZlbnQgV29ybGQjcmVtb3ZlLWpvaW50XG4gKiBAZXZlbnQgV29ybGQjcmVtb3ZlLWZpeHR1cmVcbiAqXG4gKiBKb2ludHMgYW5kIGZpeHR1cmVzIGFyZSBkZXN0cm95ZWQgd2hlbiB0aGVpciBhc3NvY2lhdGVkIGJvZHkgaXMgZGVzdHJveWVkLlxuICogUmVnaXN0ZXIgYSBkZXN0cnVjdGlvbiBsaXN0ZW5lciBzbyB0aGF0IHlvdSBtYXkgbnVsbGlmeSByZWZlcmVuY2VzIHRvIHRoZXNlXG4gKiBqb2ludHMgYW5kIHNoYXBlcy5cbiAqXG4gKiBgZnVuY3Rpb24ob2JqZWN0KWAgaXMgY2FsbGVkIHdoZW4gYW55IGpvaW50IG9yIGZpeHR1cmUgaXMgYWJvdXQgdG9cbiAqIGJlIGRlc3Ryb3llZCBkdWUgdG8gdGhlIGRlc3RydWN0aW9uIG9mIG9uZSBvZiBpdHMgYXR0YWNoZWQgb3IgcGFyZW50IGJvZGllcy5cbiAqL1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtDb250YWN0fSBjb250YWN0XG4gKi9cbldvcmxkLnByb3RvdHlwZS5iZWdpbkNvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0KSB7XG4gICAgdGhpcy5wdWJsaXNoKFwiYmVnaW4tY29udGFjdFwiLCBjb250YWN0KTtcbn07XG5cbi8qKlxuICogQGV2ZW50IFdvcmxkI2JlZ2luLWNvbnRhY3RcbiAqXG4gKiBDYWxsZWQgd2hlbiB0d28gZml4dHVyZXMgYmVnaW4gdG8gdG91Y2guXG4gKlxuICogSW1wbGVtZW50IGNvbnRhY3QgY2FsbGJhY2tzIHRvIGdldCBjb250YWN0IGluZm9ybWF0aW9uLiBZb3UgY2FuIHVzZSB0aGVzZVxuICogcmVzdWx0cyBmb3IgdGhpbmdzIGxpa2Ugc291bmRzIGFuZCBnYW1lIGxvZ2ljLiBZb3UgY2FuIGFsc28gZ2V0IGNvbnRhY3RcbiAqIHJlc3VsdHMgYnkgdHJhdmVyc2luZyB0aGUgY29udGFjdCBsaXN0cyBhZnRlciB0aGUgdGltZSBzdGVwLiBIb3dldmVyLCB5b3VcbiAqIG1pZ2h0IG1pc3Mgc29tZSBjb250YWN0cyBiZWNhdXNlIGNvbnRpbnVvdXMgcGh5c2ljcyBsZWFkcyB0byBzdWItc3RlcHBpbmcuXG4gKiBBZGRpdGlvbmFsbHkgeW91IG1heSByZWNlaXZlIG11bHRpcGxlIGNhbGxiYWNrcyBmb3IgdGhlIHNhbWUgY29udGFjdCBpbiBhXG4gKiBzaW5nbGUgdGltZSBzdGVwLiBZb3Ugc2hvdWxkIHN0cml2ZSB0byBtYWtlIHlvdXIgY2FsbGJhY2tzIGVmZmljaWVudCBiZWNhdXNlXG4gKiB0aGVyZSBtYXkgYmUgbWFueSBjYWxsYmFja3MgcGVyIHRpbWUgc3RlcC5cbiAqXG4gKiBXYXJuaW5nOiBZb3UgY2Fubm90IGNyZWF0ZS9kZXN0cm95IHdvcmxkIGVudGl0aWVzIGluc2lkZSB0aGVzZSBjYWxsYmFja3MuXG4gKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q29udGFjdH0gY29udGFjdFxuICovXG5Xb3JsZC5wcm90b3R5cGUuZW5kQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QpIHtcbiAgICB0aGlzLnB1Ymxpc2goXCJlbmQtY29udGFjdFwiLCBjb250YWN0KTtcbn07XG5cbi8qKlxuICogQGV2ZW50IFdvcmxkI2VuZC1jb250YWN0XG4gKlxuICogQ2FsbGVkIHdoZW4gdHdvIGZpeHR1cmVzIGNlYXNlIHRvIHRvdWNoLlxuICpcbiAqIEltcGxlbWVudCBjb250YWN0IGNhbGxiYWNrcyB0byBnZXQgY29udGFjdCBpbmZvcm1hdGlvbi4gWW91IGNhbiB1c2UgdGhlc2VcbiAqIHJlc3VsdHMgZm9yIHRoaW5ncyBsaWtlIHNvdW5kcyBhbmQgZ2FtZSBsb2dpYy4gWW91IGNhbiBhbHNvIGdldCBjb250YWN0XG4gKiByZXN1bHRzIGJ5IHRyYXZlcnNpbmcgdGhlIGNvbnRhY3QgbGlzdHMgYWZ0ZXIgdGhlIHRpbWUgc3RlcC4gSG93ZXZlciwgeW91XG4gKiBtaWdodCBtaXNzIHNvbWUgY29udGFjdHMgYmVjYXVzZSBjb250aW51b3VzIHBoeXNpY3MgbGVhZHMgdG8gc3ViLXN0ZXBwaW5nLlxuICogQWRkaXRpb25hbGx5IHlvdSBtYXkgcmVjZWl2ZSBtdWx0aXBsZSBjYWxsYmFja3MgZm9yIHRoZSBzYW1lIGNvbnRhY3QgaW4gYVxuICogc2luZ2xlIHRpbWUgc3RlcC4gWW91IHNob3VsZCBzdHJpdmUgdG8gbWFrZSB5b3VyIGNhbGxiYWNrcyBlZmZpY2llbnQgYmVjYXVzZVxuICogdGhlcmUgbWF5IGJlIG1hbnkgY2FsbGJhY2tzIHBlciB0aW1lIHN0ZXAuXG4gKlxuICogV2FybmluZzogWW91IGNhbm5vdCBjcmVhdGUvZGVzdHJveSB3b3JsZCBlbnRpdGllcyBpbnNpZGUgdGhlc2UgY2FsbGJhY2tzLlxuICovXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0NvbnRhY3R9IGNvbnRhY3RcbiAqIEBwYXJhbSB7TWFuaWZvbGR9IG9sZE1hbmlmb2xkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5wcmVTb2x2ZSA9IGZ1bmN0aW9uKGNvbnRhY3QsIG9sZE1hbmlmb2xkKSB7XG4gICAgdGhpcy5wdWJsaXNoKFwicHJlLXNvbHZlXCIsIGNvbnRhY3QsIG9sZE1hbmlmb2xkKTtcbn07XG5cbi8qKlxuICogQGV2ZW50IFdvcmxkI3ByZS1zb2x2ZVxuICpcbiAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIGEgY29udGFjdCBpcyB1cGRhdGVkLiBUaGlzIGFsbG93cyB5b3UgdG8gaW5zcGVjdCBhXG4gKiBjb250YWN0IGJlZm9yZSBpdCBnb2VzIHRvIHRoZSBzb2x2ZXIuIElmIHlvdSBhcmUgY2FyZWZ1bCwgeW91IGNhbiBtb2RpZnkgdGhlXG4gKiBjb250YWN0IG1hbmlmb2xkIChlLmcuIGRpc2FibGUgY29udGFjdCkuIEEgY29weSBvZiB0aGUgb2xkIG1hbmlmb2xkIGlzXG4gKiBwcm92aWRlZCBzbyB0aGF0IHlvdSBjYW4gZGV0ZWN0IGNoYW5nZXMuIE5vdGU6IHRoaXMgaXMgY2FsbGVkIG9ubHkgZm9yIGF3YWtlXG4gKiBib2RpZXMuIE5vdGU6IHRoaXMgaXMgY2FsbGVkIGV2ZW4gd2hlbiB0aGUgbnVtYmVyIG9mIGNvbnRhY3QgcG9pbnRzIGlzIHplcm8uXG4gKiBOb3RlOiB0aGlzIGlzIG5vdCBjYWxsZWQgZm9yIHNlbnNvcnMuIE5vdGU6IGlmIHlvdSBzZXQgdGhlIG51bWJlciBvZiBjb250YWN0XG4gKiBwb2ludHMgdG8gemVybywgeW91IHdpbGwgbm90IGdldCBhbiBlbmRDb250YWN0IGNhbGxiYWNrLiBIb3dldmVyLCB5b3UgbWF5IGdldFxuICogYSBiZWdpbkNvbnRhY3QgY2FsbGJhY2sgdGhlIG5leHQgc3RlcC5cbiAqXG4gKiBXYXJuaW5nOiBZb3UgY2Fubm90IGNyZWF0ZS9kZXN0cm95IHdvcmxkIGVudGl0aWVzIGluc2lkZSB0aGVzZSBjYWxsYmFja3MuXG4gKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q29udGFjdH0gY29udGFjdFxuICogQHBhcmFtIHtDb250YWN0SW1wdWxzZX0gaW1wdWxzZVxuICovXG5Xb3JsZC5wcm90b3R5cGUucG9zdFNvbHZlID0gZnVuY3Rpb24oY29udGFjdCwgaW1wdWxzZSkge1xuICAgIHRoaXMucHVibGlzaChcInBvc3Qtc29sdmVcIiwgY29udGFjdCwgaW1wdWxzZSk7XG59O1xuXG5cbn0se1wiLi9Cb2R5XCI6MixcIi4vQ29udGFjdFwiOjMsXCIuL1NvbHZlclwiOjksXCIuL2NvbGxpc2lvbi9Ccm9hZFBoYXNlXCI6MTIsXCIuL2NvbW1vbi9WZWMyXCI6MjMsXCIuL3V0aWwvY29tbW9uXCI6NTAsXCIuL3V0aWwvb3B0aW9uc1wiOjUyfV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vU2V0dGluZ3NcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjMlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG5mdW5jdGlvbiBBQUJCKGxvd2VyLCB1cHBlcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBQUJCKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFBQkIobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgdGhpcy5sb3dlckJvdW5kID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy51cHBlckJvdW5kID0gVmVjMi56ZXJvKCk7XG4gICAgaWYgKHR5cGVvZiBsb3dlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLmxvd2VyQm91bmQuc2V0KGxvd2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cHBlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQuc2V0KHVwcGVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgdGhlIGJvdW5kcyBhcmUgc29ydGVkLlxuICovXG5BQUJCLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEFBQkIuaXNWYWxpZCh0aGlzKTtcbn07XG5cbkFBQkIuaXNWYWxpZCA9IGZ1bmN0aW9uKGFhYmIpIHtcbiAgICB2YXIgZCA9IFZlYzIuc3ViKGFhYmIudXBwZXJCb3VuZCwgYWFiYi5sb3dlckJvdW5kKTtcbiAgICB2YXIgdmFsaWQgPSBkLnggPj0gMCAmJiBkLnkgPj0gMCAmJiBWZWMyLmlzVmFsaWQoYWFiYi5sb3dlckJvdW5kKSAmJiBWZWMyLmlzVmFsaWQoYWFiYi51cHBlckJvdW5kKTtcbiAgICByZXR1cm4gdmFsaWQ7XG59O1xuXG5BQUJCLmFzc2VydCA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIV9BU1NFUlQpIHJldHVybjtcbiAgICBpZiAoIUFBQkIuaXNWYWxpZChvKSkge1xuICAgICAgICBfREVCVUcgJiYgY29tbW9uLmRlYnVnKG8pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFBQkIhXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIEFBQkIuXG4gKi9cbkFBQkIucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWZWMyLm5lbygodGhpcy5sb3dlckJvdW5kLnggKyB0aGlzLnVwcGVyQm91bmQueCkgKiAuNSwgKHRoaXMubG93ZXJCb3VuZC55ICsgdGhpcy51cHBlckJvdW5kLnkpICogLjUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudHMgb2YgdGhlIEFBQkIgKGhhbGYtd2lkdGhzKS5cbiAqL1xuQUFCQi5wcm90b3R5cGUuZ2V0RXh0ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWZWMyLm5lbygodGhpcy51cHBlckJvdW5kLnggLSB0aGlzLmxvd2VyQm91bmQueCkgKiAuNSwgKHRoaXMudXBwZXJCb3VuZC55IC0gdGhpcy5sb3dlckJvdW5kLnkpICogLjUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBlcmltZXRlciBsZW5ndGguXG4gKi9cbkFBQkIucHJvdG90eXBlLmdldFBlcmltZXRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAyICogKHRoaXMudXBwZXJCb3VuZC54IC0gdGhpcy5sb3dlckJvdW5kLnggKyB0aGlzLnVwcGVyQm91bmQueSAtIHRoaXMubG93ZXJCb3VuZC55KTtcbn07XG5cbi8qKlxuICogQ29tYmluZSBvbmUgb3IgdHdvIEFBQkIgaW50byB0aGlzIG9uZS5cbiAqL1xuQUFCQi5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbG93ZXJBID0gYS5sb3dlckJvdW5kO1xuICAgIHZhciB1cHBlckEgPSBhLnVwcGVyQm91bmQ7XG4gICAgdmFyIGxvd2VyQiA9IGIubG93ZXJCb3VuZDtcbiAgICB2YXIgdXBwZXJCID0gYi51cHBlckJvdW5kO1xuICAgIHZhciBsb3dlclggPSBNYXRoLm1pbihsb3dlckEueCwgbG93ZXJCLngpO1xuICAgIHZhciBsb3dlclkgPSBNYXRoLm1pbihsb3dlckEueSwgbG93ZXJCLnkpO1xuICAgIHZhciB1cHBlclggPSBNYXRoLm1heCh1cHBlckIueCwgdXBwZXJBLngpO1xuICAgIHZhciB1cHBlclkgPSBNYXRoLm1heCh1cHBlckIueSwgdXBwZXJBLnkpO1xuICAgIHRoaXMubG93ZXJCb3VuZC5zZXQobG93ZXJYLCBsb3dlclkpO1xuICAgIHRoaXMudXBwZXJCb3VuZC5zZXQodXBwZXJYLCB1cHBlclkpO1xufTtcblxuQUFCQi5wcm90b3R5cGUuY29tYmluZVBvaW50cyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB0aGlzLmxvd2VyQm91bmQuc2V0KE1hdGgubWluKGEueCwgYi54KSwgTWF0aC5taW4oYS55LCBiLnkpKTtcbiAgICB0aGlzLnVwcGVyQm91bmQuc2V0KE1hdGgubWF4KGEueCwgYi54KSwgTWF0aC5tYXgoYS55LCBiLnkpKTtcbn07XG5cbkFBQkIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGFhYmIpIHtcbiAgICB0aGlzLmxvd2VyQm91bmQuc2V0KGFhYmIubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueSk7XG4gICAgdGhpcy51cHBlckJvdW5kLnNldChhYWJiLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnkpO1xufTtcblxuQUFCQi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihhYWJiKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMubG93ZXJCb3VuZC54IDw9IGFhYmIubG93ZXJCb3VuZC54O1xuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLmxvd2VyQm91bmQueSA8PSBhYWJiLmxvd2VyQm91bmQueTtcbiAgICByZXN1bHQgPSByZXN1bHQgJiYgYWFiYi51cHBlckJvdW5kLnggPD0gdGhpcy51cHBlckJvdW5kLng7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmIGFhYmIudXBwZXJCb3VuZC55IDw9IHRoaXMudXBwZXJCb3VuZC55O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIEFBQkIuZXh0ZW5kKHRoaXMsIHZhbHVlKTtcbn07XG5cbkFBQkIuZXh0ZW5kID0gZnVuY3Rpb24oYWFiYiwgdmFsdWUpIHtcbiAgICBhYWJiLmxvd2VyQm91bmQueCAtPSB2YWx1ZTtcbiAgICBhYWJiLmxvd2VyQm91bmQueSAtPSB2YWx1ZTtcbiAgICBhYWJiLnVwcGVyQm91bmQueCArPSB2YWx1ZTtcbiAgICBhYWJiLnVwcGVyQm91bmQueSArPSB2YWx1ZTtcbn07XG5cbkFBQkIudGVzdE92ZXJsYXAgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGQxeCA9IGIubG93ZXJCb3VuZC54IC0gYS51cHBlckJvdW5kLng7XG4gICAgdmFyIGQyeCA9IGEubG93ZXJCb3VuZC54IC0gYi51cHBlckJvdW5kLng7XG4gICAgdmFyIGQxeSA9IGIubG93ZXJCb3VuZC55IC0gYS51cHBlckJvdW5kLnk7XG4gICAgdmFyIGQyeSA9IGEubG93ZXJCb3VuZC55IC0gYi51cHBlckJvdW5kLnk7XG4gICAgaWYgKGQxeCA+IDAgfHwgZDF5ID4gMCB8fCBkMnggPiAwIHx8IGQyeSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkFBQkIuYXJlRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIFZlYzIuYXJlRXF1YWwoYS5sb3dlckJvdW5kLCBiLmxvd2VyQm91bmQpICYmIFZlYzIuYXJlRXF1YWwoYS51cHBlckJvdW5kLCBiLnVwcGVyQm91bmQpO1xufTtcblxuQUFCQi5kaWZmID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB3RCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGEudXBwZXJCb3VuZC54LCBiLnVwcGVyQm91bmQueCkgLSBNYXRoLm1heChiLmxvd2VyQm91bmQueCwgYS5sb3dlckJvdW5kLngpKTtcbiAgICB2YXIgaEQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhLnVwcGVyQm91bmQueSwgYi51cHBlckJvdW5kLnkpIC0gTWF0aC5tYXgoYi5sb3dlckJvdW5kLnksIGEubG93ZXJCb3VuZC55KSk7XG4gICAgdmFyIHdBID0gYS51cHBlckJvdW5kLnggLSBhLmxvd2VyQm91bmQueDtcbiAgICB2YXIgaEEgPSBhLnVwcGVyQm91bmQueSAtIGEubG93ZXJCb3VuZC55O1xuICAgIHZhciB3QiA9IGIudXBwZXJCb3VuZC54IC0gYi5sb3dlckJvdW5kLng7XG4gICAgdmFyIGhCID0gYi51cHBlckJvdW5kLnkgLSBiLmxvd2VyQm91bmQueTtcbiAgICByZXR1cm4gd0EgKiBoQSArIHdCICogaEIgLSB3RCAqIGhEO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBSYXlDYXN0SW5wdXRcbiAqXG4gKiBSYXktY2FzdCBpbnB1dCBkYXRhLiBUaGUgcmF5IGV4dGVuZHMgZnJvbSBwMSB0byBwMSArIG1heEZyYWN0aW9uICogKHAyIC0gcDEpLlxuICpcbiAqIEBwcm9wIHtWZWMyfSBwMVxuICogQHByb3Age1ZlYzJ9IHAyXG4gKiBAcHJvcCB7bnVtYmVyfSBtYXhGcmFjdGlvblxuICovXG4vKipcbiAqIEB0eXBlZGVmIFJheUNhc3RJbnB1dFxuICpcbiAqIFJheS1jYXN0IG91dHB1dCBkYXRhLiBUaGUgcmF5IGhpdHMgYXQgcDEgKyBmcmFjdGlvbiAqIChwMiAtIHAxKSwgd2hlcmUgcDEgYW5kXG4gKiBwMiBjb21lIGZyb20gUmF5Q2FzdElucHV0LlxuICpcbiAqIEBwcm9wIHtWZWMyfSBub3JtYWxcbiAqIEBwcm9wIHtudW1iZXJ9IGZyYWN0aW9uXG4gKi9cbi8qKlxuICogQHBhcmFtIHtSYXlDYXN0T3V0cHV0fSBvdXRwdXRcbiAqIEBwYXJhbSB7UmF5Q2FzdElucHV0fSBpbnB1dFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbihvdXRwdXQsIGlucHV0KSB7XG4gICAgLy8gRnJvbSBSZWFsLXRpbWUgQ29sbGlzaW9uIERldGVjdGlvbiwgcDE3OS5cbiAgICB2YXIgdG1pbiA9IC1JbmZpbml0eTtcbiAgICB2YXIgdG1heCA9IEluZmluaXR5O1xuICAgIHZhciBwID0gaW5wdXQucDE7XG4gICAgdmFyIGQgPSBWZWMyLnN1YihpbnB1dC5wMiwgaW5wdXQucDEpO1xuICAgIHZhciBhYnNEID0gVmVjMi5hYnMoZCk7XG4gICAgdmFyIG5vcm1hbCA9IFZlYzIuemVybygpO1xuICAgIGZvciAodmFyIGYgPSBcInhcIjsgZiAhPT0gbnVsbDsgZiA9IGYgPT09IFwieFwiID8gXCJ5XCIgOiBudWxsKSB7XG4gICAgICAgIGlmIChhYnNELnggPCBNYXRoLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIFBhcmFsbGVsLlxuICAgICAgICAgICAgaWYgKHBbZl0gPCB0aGlzLmxvd2VyQm91bmRbZl0gfHwgdGhpcy51cHBlckJvdW5kW2ZdIDwgcFtmXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnZfZCA9IDEgLyBkW2ZdO1xuICAgICAgICAgICAgdmFyIHQxID0gKHRoaXMubG93ZXJCb3VuZFtmXSAtIHBbZl0pICogaW52X2Q7XG4gICAgICAgICAgICB2YXIgdDIgPSAodGhpcy51cHBlckJvdW5kW2ZdIC0gcFtmXSkgKiBpbnZfZDtcbiAgICAgICAgICAgIC8vIFNpZ24gb2YgdGhlIG5vcm1hbCB2ZWN0b3IuXG4gICAgICAgICAgICB2YXIgcyA9IC0xO1xuICAgICAgICAgICAgaWYgKHQxID4gdDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHQxO1xuICAgICAgICAgICAgICAgIHQxID0gdDIsIHQyID0gdGVtcDtcbiAgICAgICAgICAgICAgICBzID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIG1pbiB1cFxuICAgICAgICAgICAgaWYgKHQxID4gdG1pbikge1xuICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgbm9ybWFsW2ZdID0gcztcbiAgICAgICAgICAgICAgICB0bWluID0gdDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQdWxsIHRoZSBtYXggZG93blxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIHQyKTtcbiAgICAgICAgICAgIGlmICh0bWluID4gdG1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEb2VzIHRoZSByYXkgc3RhcnQgaW5zaWRlIHRoZSBib3g/XG4gICAgLy8gRG9lcyB0aGUgcmF5IGludGVyc2VjdCBiZXlvbmQgdGhlIG1heCBmcmFjdGlvbj9cbiAgICBpZiAodG1pbiA8IDAgfHwgaW5wdXQubWF4RnJhY3Rpb24gPCB0bWluKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSW50ZXJzZWN0aW9uLlxuICAgIG91dHB1dC5mcmFjdGlvbiA9IHRtaW47XG4gICAgb3V0cHV0Lm5vcm1hbCA9IG5vcm1hbDtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkFBQkIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xufTtcblxuXG59LHtcIi4uL1NldHRpbmdzXCI6NyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vVmVjMlwiOjIzfV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vU2V0dGluZ3NcIik7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgQUFCQiA9IHJlcXVpcmUoXCIuL0FBQkJcIik7XG5cbnZhciBEeW5hbWljVHJlZSA9IHJlcXVpcmUoXCIuL0R5bmFtaWNUcmVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkUGhhc2U7XG5cbi8qKlxuICogVGhlIGJyb2FkLXBoYXNlIHdyYXBzIGFuZCBleHRlbmRzIGEgZHluYW1pYy10cmVlIHRvIGtlZXAgdHJhY2sgb2YgbW92ZWRcbiAqIG9iamVjdHMgYW5kIHF1ZXJ5IHRoZW0gb24gdXBkYXRlLlxuICovXG5mdW5jdGlvbiBCcm9hZFBoYXNlKCkge1xuICAgIHRoaXMubV90cmVlID0gbmV3IER5bmFtaWNUcmVlKCk7XG4gICAgdGhpcy5tX3Byb3h5Q291bnQgPSAwO1xuICAgIHRoaXMubV9tb3ZlQnVmZmVyID0gW107XG4gICAgdGhpcy5xdWVyeUNhbGxiYWNrID0gdGhpcy5xdWVyeUNhbGxiYWNrLmJpbmQodGhpcyk7XG59XG5cbi8qKlxuICogR2V0IHVzZXIgZGF0YSBmcm9tIGEgcHJveHkuIFJldHVybnMgbnVsbCBpZiB0aGUgaWQgaXMgaW52YWxpZC5cbiAqL1xuQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbihwcm94eUlkKSB7XG4gICAgcmV0dXJuIHRoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWQpO1xufTtcblxuLyoqXG4gKiBUZXN0IG92ZXJsYXAgb2YgZmF0IEFBQkJzLlxuICovXG5Ccm9hZFBoYXNlLnByb3RvdHlwZS50ZXN0T3ZlcmxhcCA9IGZ1bmN0aW9uKHByb3h5SWRBLCBwcm94eUlkQikge1xuICAgIHZhciBhYWJiQSA9IHRoaXMubV90cmVlLmdldEZhdEFBQkIocHJveHlJZEEpO1xuICAgIHZhciBhYWJiQiA9IHRoaXMubV90cmVlLmdldEZhdEFBQkIocHJveHlJZEIpO1xuICAgIHJldHVybiBBQUJCLnRlc3RPdmVybGFwKGFhYmJBLCBhYWJiQik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmF0IEFBQkIgZm9yIGEgcHJveHkuXG4gKi9cbkJyb2FkUGhhc2UucHJvdG90eXBlLmdldEZhdEFBQkIgPSBmdW5jdGlvbihwcm94eUlkKSB7XG4gICAgcmV0dXJuIHRoaXMubV90cmVlLmdldEZhdEFBQkIocHJveHlJZCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHByb3hpZXMuXG4gKi9cbkJyb2FkUGhhc2UucHJvdG90eXBlLmdldFByb3h5Q291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3Byb3h5Q291bnQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBlbWJlZGRlZCB0cmVlLlxuICovXG5Ccm9hZFBoYXNlLnByb3RvdHlwZS5nZXRUcmVlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV90cmVlLmdldEhlaWdodCgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGJhbGFuY2UgKGludGVnZXIpIG9mIHRoZSBlbWJlZGRlZCB0cmVlLlxuICovXG5Ccm9hZFBoYXNlLnByb3RvdHlwZS5nZXRUcmVlQmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdHJlZS5nZXRNYXhCYWxhbmNlKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVhbGl0eSBtZXRyaWMgb2YgdGhlIGVtYmVkZGVkIHRyZWUuXG4gKi9cbkJyb2FkUGhhc2UucHJvdG90eXBlLmdldFRyZWVRdWFsaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV90cmVlLmdldEFyZWFSYXRpbygpO1xufTtcblxuLyoqXG4gKiBRdWVyeSBhbiBBQUJCIGZvciBvdmVybGFwcGluZyBwcm94aWVzLiBUaGUgY2FsbGJhY2sgY2xhc3MgaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBwcm94eSB0aGF0IG92ZXJsYXBzIHRoZSBzdXBwbGllZCBBQUJCLlxuICovXG5Ccm9hZFBoYXNlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGFhYmIsIHF1ZXJ5Q2FsbGJhY2spIHtcbiAgICB0aGlzLm1fdHJlZS5xdWVyeShhYWJiLCBxdWVyeUNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmF5LWNhc3QgYWdhaW5zdCB0aGUgcHJveGllcyBpbiB0aGUgdHJlZS4gVGhpcyByZWxpZXMgb24gdGhlIGNhbGxiYWNrIHRvXG4gKiBwZXJmb3JtIGEgZXhhY3QgcmF5LWNhc3QgaW4gdGhlIGNhc2Ugd2VyZSB0aGUgcHJveHkgY29udGFpbnMgYSBzaGFwZS4gVGhlXG4gKiBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAqIHJvdWdobHkgZXF1YWwgdG8gayAqIGxvZyhuKSwgd2hlcmUgayBpcyB0aGUgbnVtYmVyIG9mIGNvbGxpc2lvbnMgYW5kIG4gaXMgdGhlXG4gKiBudW1iZXIgb2YgcHJveGllcyBpbiB0aGUgdHJlZS5cbiAqIFxuICogQHBhcmFtIGlucHV0IFRoZSByYXktY2FzdCBpbnB1dCBkYXRhLiBUaGUgcmF5IGV4dGVuZHMgZnJvbSBwMSB0byBwMSArXG4gKiAgICAgICAgICBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKS5cbiAqIEBwYXJhbSByYXlDYXN0Q2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieVxuICogICAgICAgICAgdGhlIHJheS5cbiAqL1xuQnJvYWRQaGFzZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uKGlucHV0LCByYXlDYXN0Q2FsbGJhY2spIHtcbiAgICB0aGlzLm1fdHJlZS5yYXlDYXN0KGlucHV0LCByYXlDYXN0Q2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaGlmdCB0aGUgd29ybGQgb3JpZ2luLiBVc2VmdWwgZm9yIGxhcmdlIHdvcmxkcy4gVGhlIHNoaWZ0IGZvcm11bGEgaXM6XG4gKiBwb3NpdGlvbiAtPSBuZXdPcmlnaW5cbiAqIFxuICogQHBhcmFtIG5ld09yaWdpbiBUaGUgbmV3IG9yaWdpbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9sZCBvcmlnaW5cbiAqL1xuQnJvYWRQaGFzZS5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbihuZXdPcmlnaW4pIHtcbiAgICB0aGlzLm1fdHJlZS5zaGlmdE9yaWdpbihuZXdPcmlnaW4pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwcm94eSB3aXRoIGFuIGluaXRpYWwgQUFCQi4gUGFpcnMgYXJlIG5vdCByZXBvcnRlZCB1bnRpbCBVcGRhdGVQYWlyc1xuICogaXMgY2FsbGVkLlxuICovXG5Ccm9hZFBoYXNlLnByb3RvdHlwZS5jcmVhdGVQcm94eSA9IGZ1bmN0aW9uKGFhYmIsIHVzZXJEYXRhKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KEFBQkIuaXNWYWxpZChhYWJiKSk7XG4gICAgdmFyIHByb3h5SWQgPSB0aGlzLm1fdHJlZS5jcmVhdGVQcm94eShhYWJiLCB1c2VyRGF0YSk7XG4gICAgdGhpcy5tX3Byb3h5Q291bnQrKztcbiAgICB0aGlzLmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgcmV0dXJuIHByb3h5SWQ7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgYSBwcm94eS4gSXQgaXMgdXAgdG8gdGhlIGNsaWVudCB0byByZW1vdmUgYW55IHBhaXJzLlxuICovXG5Ccm9hZFBoYXNlLnByb3RvdHlwZS5kZXN0cm95UHJveHkgPSBmdW5jdGlvbihwcm94eUlkKSB7XG4gICAgdGhpcy51bmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgdGhpcy5tX3Byb3h5Q291bnQtLTtcbiAgICB0aGlzLm1fdHJlZS5kZXN0cm95UHJveHkocHJveHlJZCk7XG59O1xuXG4vKipcbiAqIENhbGwgbW92ZVByb3h5IGFzIG1hbnkgdGltZXMgYXMgeW91IGxpa2UsIHRoZW4gd2hlbiB5b3UgYXJlIGRvbmUgY2FsbFxuICogVXBkYXRlUGFpcnMgdG8gZmluYWxpemVkIHRoZSBwcm94eSBwYWlycyAoZm9yIHlvdXIgdGltZSBzdGVwKS5cbiAqL1xuQnJvYWRQaGFzZS5wcm90b3R5cGUubW92ZVByb3h5ID0gZnVuY3Rpb24ocHJveHlJZCwgYWFiYiwgZGlzcGxhY2VtZW50KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KEFBQkIuaXNWYWxpZChhYWJiKSk7XG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLm1fdHJlZS5tb3ZlUHJveHkocHJveHlJZCwgYWFiYiwgZGlzcGxhY2VtZW50KTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxsIHRvIHRyaWdnZXIgYSByZS1wcm9jZXNzaW5nIG9mIGl0J3MgcGFpcnMgb24gdGhlIG5leHQgY2FsbCB0b1xuICogVXBkYXRlUGFpcnMuXG4gKi9cbkJyb2FkUGhhc2UucHJvdG90eXBlLnRvdWNoUHJveHkgPSBmdW5jdGlvbihwcm94eUlkKSB7XG4gICAgdGhpcy5idWZmZXJNb3ZlKHByb3h5SWQpO1xufTtcblxuQnJvYWRQaGFzZS5wcm90b3R5cGUuYnVmZmVyTW92ZSA9IGZ1bmN0aW9uKHByb3h5SWQpIHtcbiAgICB0aGlzLm1fbW92ZUJ1ZmZlci5wdXNoKHByb3h5SWQpO1xufTtcblxuQnJvYWRQaGFzZS5wcm90b3R5cGUudW5idWZmZXJNb3ZlID0gZnVuY3Rpb24ocHJveHlJZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMubV9tb3ZlQnVmZmVyW2ldID09IHByb3h5SWQpIHtcbiAgICAgICAgICAgIHRoaXMubV9tb3ZlQnVmZmVyW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIEJyb2FkUGhhc2V+YWRkUGFpclxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhQVxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhQlxuICovXG4vKipcbiAqIFVwZGF0ZSB0aGUgcGFpcnMuIFRoaXMgcmVzdWx0cyBpbiBwYWlyIGNhbGxiYWNrcy4gVGhpcyBjYW4gb25seSBhZGQgcGFpcnMuXG4gKiBcbiAqIEBwYXJhbSB7QnJvYWRQaGFzZX5BZGRQYWlyfSBhZGRQYWlyQ2FsbGJhY2tcbiAqL1xuQnJvYWRQaGFzZS5wcm90b3R5cGUudXBkYXRlUGFpcnMgPSBmdW5jdGlvbihhZGRQYWlyQ2FsbGJhY2spIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodHlwZW9mIGFkZFBhaXJDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB0aGlzLm1fY2FsbGJhY2sgPSBhZGRQYWlyQ2FsbGJhY2s7XG4gICAgLy8gUGVyZm9ybSB0cmVlIHF1ZXJpZXMgZm9yIGFsbCBtb3ZpbmcgcHJveGllcy5cbiAgICB3aGlsZSAodGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLm1fcXVlcnlQcm94eUlkID0gdGhpcy5tX21vdmVCdWZmZXIucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLm1fcXVlcnlQcm94eUlkID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHRvIHF1ZXJ5IHRoZSB0cmVlIHdpdGggdGhlIGZhdCBBQUJCIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgZmFpbCB0byBjcmVhdGUgYSBwYWlyIHRoYXQgbWF5IHRvdWNoIGxhdGVyLlxuICAgICAgICB2YXIgZmF0QUFCQiA9IHRoaXMubV90cmVlLmdldEZhdEFBQkIodGhpcy5tX3F1ZXJ5UHJveHlJZCk7XG4gICAgICAgIC8vIFF1ZXJ5IHRyZWUsIGNyZWF0ZSBwYWlycyBhbmQgYWRkIHRoZW0gcGFpciBidWZmZXIuXG4gICAgICAgIHRoaXMubV90cmVlLnF1ZXJ5KGZhdEFBQkIsIHRoaXMucXVlcnlDYWxsYmFjayk7XG4gICAgfVxufTtcblxuQnJvYWRQaGFzZS5wcm90b3R5cGUucXVlcnlDYWxsYmFjayA9IGZ1bmN0aW9uKHByb3h5SWQpIHtcbiAgICAvLyBBIHByb3h5IGNhbm5vdCBmb3JtIGEgcGFpciB3aXRoIGl0c2VsZi5cbiAgICBpZiAocHJveHlJZCA9PSB0aGlzLm1fcXVlcnlQcm94eUlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJveHlJZEEgPSBNYXRoLm1pbihwcm94eUlkLCB0aGlzLm1fcXVlcnlQcm94eUlkKTtcbiAgICB2YXIgcHJveHlJZEIgPSBNYXRoLm1heChwcm94eUlkLCB0aGlzLm1fcXVlcnlQcm94eUlkKTtcbiAgICAvLyBUT0RPOiBTa2lwIGFueSBkdXBsaWNhdGUgcGFpcnMuXG4gICAgdmFyIHVzZXJEYXRhQSA9IHRoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWRBKTtcbiAgICB2YXIgdXNlckRhdGFCID0gdGhpcy5tX3RyZWUuZ2V0VXNlckRhdGEocHJveHlJZEIpO1xuICAgIC8vIFNlbmQgdGhlIHBhaXJzIGJhY2sgdG8gdGhlIGNsaWVudC5cbiAgICB0aGlzLm1fY2FsbGJhY2sodXNlckRhdGFBLCB1c2VyRGF0YUIpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG59LHtcIi4uL1NldHRpbmdzXCI6NyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9BQUJCXCI6MTEsXCIuL0R5bmFtaWNUcmVlXCI6MTR9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2U7XG5cbm1vZHVsZS5leHBvcnRzLklucHV0ID0gRGlzdGFuY2VJbnB1dDtcblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gRGlzdGFuY2VPdXRwdXQ7XG5cbm1vZHVsZS5leHBvcnRzLlByb3h5ID0gRGlzdGFuY2VQcm94eTtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGUgPSBTaW1wbGV4Q2FjaGU7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIHN0YXRzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdGF0c1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjM1wiKTtcblxudmFyIE1hdDIyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQyMlwiKTtcblxudmFyIE1hdDMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQzM1wiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi4vY29tbW9uL1N3ZWVwXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWxvY2l0eSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vUG9zaXRpb25cIik7XG5cbi8qKlxuICogR0pLIHVzaW5nIFZvcm9ub2kgcmVnaW9ucyAoQ2hyaXN0ZXIgRXJpY3NvbikgYW5kIEJhcnljZW50cmljIGNvb3JkaW5hdGVzLlxuICovXG5zdGF0cy5namtDYWxscyA9IDA7XG5cbnN0YXRzLmdqa0l0ZXJzID0gMDtcblxuc3RhdHMuZ2prTWF4SXRlcnMgPSAwO1xuXG4vKipcbiAqIElucHV0IGZvciBEaXN0YW5jZS4gWW91IGhhdmUgdG8gb3B0aW9uIHRvIHVzZSB0aGUgc2hhcGUgcmFkaWkgaW4gdGhlXG4gKiBjb21wdXRhdGlvbi4gRXZlblxuICovXG5mdW5jdGlvbiBEaXN0YW5jZUlucHV0KCkge1xuICAgIHRoaXMucHJveHlBID0gbmV3IERpc3RhbmNlUHJveHkoKTtcbiAgICB0aGlzLnByb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgdGhpcy50cmFuc2Zvcm1BID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybUIgPSBudWxsO1xuICAgIHRoaXMudXNlUmFkaWkgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPdXRwdXQgZm9yIERpc3RhbmNlLlxuICpcbiAqIEBwcm9wIHtWZWMyfSBwb2ludEEgY2xvc2VzdCBwb2ludCBvbiBzaGFwZUFcbiAqIEBwcm9wIHtWZWMyfSBwb2ludEIgY2xvc2VzdCBwb2ludCBvbiBzaGFwZUJcbiAqIEBwcm9wIGRpc3RhbmNlXG4gKiBAcHJvcCBpdGVyYXRpb25zIG51bWJlciBvZiBHSksgaXRlcmF0aW9ucyB1c2VkXG4gKi9cbmZ1bmN0aW9uIERpc3RhbmNlT3V0cHV0KCkge1xuICAgIHRoaXMucG9pbnRBID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5wb2ludEIgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLmRpc3RhbmNlO1xuICAgIHRoaXMuaXRlcmF0aW9ucztcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHdhcm0gc3RhcnQgRGlzdGFuY2UuIFNldCBjb3VudCB0byB6ZXJvIG9uIGZpcnN0IGNhbGwuXG4gKlxuICogQHByb3Age251bWJlcn0gbWV0cmljIGxlbmd0aCBvciBhcmVhXG4gKiBAcHJvcCB7YXJyYXl9IGluZGV4QSB2ZXJ0aWNlcyBvbiBzaGFwZSBBXG4gKiBAcHJvcCB7YXJyYXl9IGluZGV4QiB2ZXJ0aWNlcyBvbiBzaGFwZSBCXG4gKiBAcHJvcCB7bnVtYmVyfSBjb3VudFxuICovXG5mdW5jdGlvbiBTaW1wbGV4Q2FjaGUoKSB7XG4gICAgdGhpcy5tZXRyaWMgPSAwO1xuICAgIHRoaXMuaW5kZXhBID0gW107XG4gICAgdGhpcy5pbmRleEIgPSBbXTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjbG9zZXN0IHBvaW50cyBiZXR3ZWVuIHR3byBzaGFwZXMuIFN1cHBvcnRzIGFueSBjb21iaW5hdGlvbiBvZjpcbiAqIENpcmNsZVNoYXBlLCBQb2x5Z29uU2hhcGUsIEVkZ2VTaGFwZS4gVGhlIHNpbXBsZXggY2FjaGUgaXMgaW5wdXQvb3V0cHV0LiBPblxuICogdGhlIGZpcnN0IGNhbGwgc2V0IFNpbXBsZXhDYWNoZS5jb3VudCB0byB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7RGlzdGFuY2VPdXRwdXR9IG91dHB1dFxuICogQHBhcmFtIHtTaW1wbGV4Q2FjaGV9IGNhY2hlXG4gKiBAcGFyYW0ge0Rpc3RhbmNlSW5wdXR9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIERpc3RhbmNlKG91dHB1dCwgY2FjaGUsIGlucHV0KSB7XG4gICAgKytzdGF0cy5namtDYWxscztcbiAgICB2YXIgcHJveHlBID0gaW5wdXQucHJveHlBO1xuICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XG4gICAgdmFyIHhmQSA9IGlucHV0LnRyYW5zZm9ybUE7XG4gICAgdmFyIHhmQiA9IGlucHV0LnRyYW5zZm9ybUI7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc2ltcGxleC5cbiAgICB2YXIgc2ltcGxleCA9IG5ldyBTaW1wbGV4KCk7XG4gICAgc2ltcGxleC5yZWFkQ2FjaGUoY2FjaGUsIHByb3h5QSwgeGZBLCBwcm94eUIsIHhmQik7XG4gICAgLy8gR2V0IHNpbXBsZXggdmVydGljZXMgYXMgYW4gYXJyYXkuXG4gICAgdmFyIHZlcnRpY2VzID0gc2ltcGxleC5tX3Y7XG4gICAgLy8gU2ltcGxleFZlcnRleFxuICAgIHZhciBrX21heEl0ZXJzID0gU2V0dGluZ3MubWF4RGlzdG5jZUl0ZXJhdGlvbnM7XG4gICAgLy8gVGhlc2Ugc3RvcmUgdGhlIHZlcnRpY2VzIG9mIHRoZSBsYXN0IHNpbXBsZXggc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBjaGVjayBmb3IgZHVwbGljYXRlcyBhbmQgcHJldmVudCBjeWNsaW5nLlxuICAgIHZhciBzYXZlQSA9IFtdO1xuICAgIHZhciBzYXZlQiA9IFtdO1xuICAgIC8vIGludFszXVxuICAgIHZhciBzYXZlQ291bnQgPSAwO1xuICAgIHZhciBkaXN0YW5jZVNxcjEgPSBJbmZpbml0eTtcbiAgICB2YXIgZGlzdGFuY2VTcXIyID0gSW5maW5pdHk7XG4gICAgLy8gTWFpbiBpdGVyYXRpb24gbG9vcC5cbiAgICB2YXIgaXRlciA9IDA7XG4gICAgd2hpbGUgKGl0ZXIgPCBrX21heEl0ZXJzKSB7XG4gICAgICAgIC8vIENvcHkgc2ltcGxleCBzbyB3ZSBjYW4gaWRlbnRpZnkgZHVwbGljYXRlcy5cbiAgICAgICAgc2F2ZUNvdW50ID0gc2ltcGxleC5tX2NvdW50O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhdmVDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBzYXZlQVtpXSA9IHZlcnRpY2VzW2ldLmluZGV4QTtcbiAgICAgICAgICAgIHNhdmVCW2ldID0gdmVydGljZXNbaV0uaW5kZXhCO1xuICAgICAgICB9XG4gICAgICAgIHNpbXBsZXguc29sdmUoKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSAzIHBvaW50cywgdGhlbiB0aGUgb3JpZ2luIGlzIGluIHRoZSBjb3JyZXNwb25kaW5nIHRyaWFuZ2xlLlxuICAgICAgICBpZiAoc2ltcGxleC5tX2NvdW50ID09IDMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgY2xvc2VzdCBwb2ludC5cbiAgICAgICAgdmFyIHAgPSBzaW1wbGV4LmdldENsb3Nlc3RQb2ludCgpO1xuICAgICAgICBkaXN0YW5jZVNxcjIgPSBwLmxlbmd0aFNxdWFyZWQoKTtcbiAgICAgICAgLy8gRW5zdXJlIHByb2dyZXNzXG4gICAgICAgIGlmIChkaXN0YW5jZVNxcjIgPj0gZGlzdGFuY2VTcXIxKSB7fVxuICAgICAgICBkaXN0YW5jZVNxcjEgPSBkaXN0YW5jZVNxcjI7XG4gICAgICAgIC8vIEdldCBzZWFyY2ggZGlyZWN0aW9uLlxuICAgICAgICB2YXIgZCA9IHNpbXBsZXguZ2V0U2VhcmNoRGlyZWN0aW9uKCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2VhcmNoIGRpcmVjdGlvbiBpcyBudW1lcmljYWxseSBmaXQuXG4gICAgICAgIGlmIChkLmxlbmd0aFNxdWFyZWQoKSA8IE1hdGguRVBTSUxPTiAqIE1hdGguRVBTSUxPTikge1xuICAgICAgICAgICAgLy8gVGhlIG9yaWdpbiBpcyBwcm9iYWJseSBjb250YWluZWQgYnkgYSBsaW5lIHNlZ21lbnRcbiAgICAgICAgICAgIC8vIG9yIHRyaWFuZ2xlLiBUaHVzIHRoZSBzaGFwZXMgYXJlIG92ZXJsYXBwZWQuXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCByZXR1cm4gemVybyBoZXJlIGV2ZW4gdGhvdWdoIHRoZXJlIG1heSBiZSBvdmVybGFwLlxuICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgc2ltcGxleCBpcyBhIHBvaW50LCBzZWdtZW50LCBvciB0cmlhbmdsZSBpdCBpcyBkaWZmaWN1bHRcbiAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSBpZiB0aGUgb3JpZ2luIGlzIGNvbnRhaW5lZCBpbiB0aGUgQ1NPIG9yIHZlcnkgY2xvc2UgdG8gaXQuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIGEgdGVudGF0aXZlIG5ldyBzaW1wbGV4IHZlcnRleCB1c2luZyBzdXBwb3J0IHBvaW50cy5cbiAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW3NpbXBsZXgubV9jb3VudF07XG4gICAgICAgIC8vIFNpbXBsZXhWZXJ0ZXhcbiAgICAgICAgdmVydGV4LmluZGV4QSA9IHByb3h5QS5nZXRTdXBwb3J0KFJvdC5tdWxUVmVjMih4ZkEucSwgVmVjMi5uZWcoZCkpKTtcbiAgICAgICAgdmVydGV4LndBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCBwcm94eUEuZ2V0VmVydGV4KHZlcnRleC5pbmRleEEpKTtcbiAgICAgICAgdmVydGV4LmluZGV4QiA9IHByb3h5Qi5nZXRTdXBwb3J0KFJvdC5tdWxUVmVjMih4ZkIucSwgZCkpO1xuICAgICAgICB2ZXJ0ZXgud0IgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIHByb3h5Qi5nZXRWZXJ0ZXgodmVydGV4LmluZGV4QikpO1xuICAgICAgICB2ZXJ0ZXgudyA9IFZlYzIuc3ViKHZlcnRleC53QiwgdmVydGV4LndBKTtcbiAgICAgICAgLy8gSXRlcmF0aW9uIGNvdW50IGlzIGVxdWF0ZWQgdG8gdGhlIG51bWJlciBvZiBzdXBwb3J0IHBvaW50IGNhbGxzLlxuICAgICAgICArK2l0ZXI7XG4gICAgICAgICsrc3RhdHMuZ2prSXRlcnM7XG4gICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgc3VwcG9ydCBwb2ludHMuIFRoaXMgaXMgdGhlIG1haW4gdGVybWluYXRpb25cbiAgICAgICAgLy8gY3JpdGVyaWEuXG4gICAgICAgIHZhciBkdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYXZlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKHZlcnRleC5pbmRleEEgPT0gc2F2ZUFbaV0gJiYgdmVydGV4LmluZGV4QiA9PSBzYXZlQltpXSkge1xuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBkdXBsaWNhdGUgc3VwcG9ydCBwb2ludCB3ZSBtdXN0IGV4aXQgdG8gYXZvaWQgY3ljbGluZy5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV3IHZlcnRleCBpcyBvayBhbmQgbmVlZGVkLlxuICAgICAgICArK3NpbXBsZXgubV9jb3VudDtcbiAgICB9XG4gICAgc3RhdHMuZ2prTWF4SXRlcnMgPSBNYXRoLm1heChzdGF0cy5namtNYXhJdGVycywgaXRlcik7XG4gICAgLy8gUHJlcGFyZSBvdXRwdXQuXG4gICAgc2ltcGxleC5nZXRXaXRuZXNzUG9pbnRzKG91dHB1dC5wb2ludEEsIG91dHB1dC5wb2ludEIpO1xuICAgIG91dHB1dC5kaXN0YW5jZSA9IFZlYzIuZGlzdGFuY2Uob3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50Qik7XG4gICAgb3V0cHV0Lml0ZXJhdGlvbnMgPSBpdGVyO1xuICAgIC8vIENhY2hlIHRoZSBzaW1wbGV4LlxuICAgIHNpbXBsZXgud3JpdGVDYWNoZShjYWNoZSk7XG4gICAgLy8gQXBwbHkgcmFkaWkgaWYgcmVxdWVzdGVkLlxuICAgIGlmIChpbnB1dC51c2VSYWRpaSkge1xuICAgICAgICB2YXIgckEgPSBwcm94eUEubV9yYWRpdXM7XG4gICAgICAgIHZhciByQiA9IHByb3h5Qi5tX3JhZGl1cztcbiAgICAgICAgaWYgKG91dHB1dC5kaXN0YW5jZSA+IHJBICsgckIgJiYgb3V0cHV0LmRpc3RhbmNlID4gTWF0aC5FUFNJTE9OKSB7XG4gICAgICAgICAgICAvLyBTaGFwZXMgYXJlIHN0aWxsIG5vIG92ZXJsYXBwZWQuXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB3aXRuZXNzIHBvaW50cyB0byB0aGUgb3V0ZXIgc3VyZmFjZS5cbiAgICAgICAgICAgIG91dHB1dC5kaXN0YW5jZSAtPSByQSArIHJCO1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFZlYzIuc3ViKG91dHB1dC5wb2ludEIsIG91dHB1dC5wb2ludEEpO1xuICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50QS5hZGRNdWwockEsIG5vcm1hbCk7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnRCLnN1Yk11bChyQiwgbm9ybWFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNoYXBlcyBhcmUgb3ZlcmxhcHBlZCB3aGVuIHJhZGlpIGFyZSBjb25zaWRlcmVkLlxuICAgICAgICAgICAgLy8gTW92ZSB0aGUgd2l0bmVzcyBwb2ludHMgdG8gdGhlIG1pZGRsZS5cbiAgICAgICAgICAgIHZhciBwID0gVmVjMi5taWQob3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50Qik7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnRBLnNldChwKTtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEIuc2V0KHApO1xuICAgICAgICAgICAgb3V0cHV0LmRpc3RhbmNlID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGRpc3RhbmNlIHByb3h5IGlzIHVzZWQgYnkgdGhlIEdKSyBhbGdvcml0aG0uIEl0IGVuY2Fwc3VsYXRlcyBhbnkgc2hhcGUuXG4gKi9cbmZ1bmN0aW9uIERpc3RhbmNlUHJveHkoKSB7XG4gICAgdGhpcy5tX2J1ZmZlciA9IFtdO1xuICAgIC8vIFZlYzJbMl1cbiAgICB0aGlzLm1fdmVydGljZXMgPSBbXTtcbiAgICAvLyBWZWMyW11cbiAgICB0aGlzLm1fY291bnQgPSAwO1xuICAgIHRoaXMubV9yYWRpdXMgPSAwO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmVydGV4IGNvdW50LlxuICovXG5EaXN0YW5jZVByb3h5LnByb3RvdHlwZS5nZXRWZXJ0ZXhDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fY291bnQ7XG59O1xuXG4vKipcbiAqIEdldCBhIHZlcnRleCBieSBpbmRleC4gVXNlZCBieSBEaXN0YW5jZS5cbiAqL1xuRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0VmVydGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMubV9jb3VudCk7XG4gICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlc1tpbmRleF07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3VwcG9ydGluZyB2ZXJ0ZXggaW5kZXggaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAqL1xuRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0U3VwcG9ydCA9IGZ1bmN0aW9uKGQpIHtcbiAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICB2YXIgYmVzdFZhbHVlID0gVmVjMi5kb3QodGhpcy5tX3ZlcnRpY2VzWzBdLCBkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IFZlYzIuZG90KHRoaXMubV92ZXJ0aWNlc1tpXSwgZCk7XG4gICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0SW5kZXg7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3VwcG9ydGluZyB2ZXJ0ZXggaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAqL1xuRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0U3VwcG9ydFZlcnRleCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW3RoaXMuZ2V0U3VwcG9ydChkKV07XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIHByb3h5IHVzaW5nIHRoZSBnaXZlbiBzaGFwZS4gVGhlIHNoYXBlIG11c3QgcmVtYWluIGluIHNjb3BlXG4gKiB3aGlsZSB0aGUgcHJveHkgaXMgaW4gdXNlLlxuICovXG5EaXN0YW5jZVByb3h5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzaGFwZSwgaW5kZXgpIHtcbiAgICAvLyBUT0RPIHJlbW92ZSwgdXNlIHNoYXBlIGluc3RlYWRcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodHlwZW9mIHNoYXBlLmNvbXB1dGVEaXN0YW5jZVByb3h5ID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIHNoYXBlLmNvbXB1dGVEaXN0YW5jZVByb3h5KHRoaXMsIGluZGV4KTtcbn07XG5cbmZ1bmN0aW9uIFNpbXBsZXhWZXJ0ZXgoKSB7XG4gICAgdGhpcy5pbmRleEE7XG4gICAgLy8gd0EgaW5kZXhcbiAgICB0aGlzLmluZGV4QjtcbiAgICAvLyB3QiBpbmRleFxuICAgIHRoaXMud0EgPSBWZWMyLnplcm8oKTtcbiAgICAvLyBzdXBwb3J0IHBvaW50IGluIHByb3h5QVxuICAgIHRoaXMud0IgPSBWZWMyLnplcm8oKTtcbiAgICAvLyBzdXBwb3J0IHBvaW50IGluIHByb3h5QlxuICAgIHRoaXMudyA9IFZlYzIuemVybygpO1xuICAgIC8vIHdCIC0gd0FcbiAgICB0aGlzLmE7XG59XG5cblNpbXBsZXhWZXJ0ZXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLmluZGV4QSA9IHYuaW5kZXhBO1xuICAgIHRoaXMuaW5kZXhCID0gdi5pbmRleEI7XG4gICAgdGhpcy53QSA9IFZlYzIuY2xvbmUodi53QSk7XG4gICAgdGhpcy53QiA9IFZlYzIuY2xvbmUodi53Qik7XG4gICAgdGhpcy53ID0gVmVjMi5jbG9uZSh2LncpO1xuICAgIHRoaXMuYSA9IHYuYTtcbn07XG5cbmZ1bmN0aW9uIFNpbXBsZXgoKSB7XG4gICAgdGhpcy5tX3YxID0gbmV3IFNpbXBsZXhWZXJ0ZXgoKTtcbiAgICB0aGlzLm1fdjIgPSBuZXcgU2ltcGxleFZlcnRleCgpO1xuICAgIHRoaXMubV92MyA9IG5ldyBTaW1wbGV4VmVydGV4KCk7XG4gICAgdGhpcy5tX3YgPSBbIHRoaXMubV92MSwgdGhpcy5tX3YyLCB0aGlzLm1fdjMgXTtcbiAgICB0aGlzLm1fY291bnQ7XG59XG5cblNpbXBsZXgucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubV9jb3VudCA9PSAzKSB7XG4gICAgICAgIHJldHVybiBbIFwiK1wiICsgdGhpcy5tX2NvdW50LCB0aGlzLm1fdjEuYSwgdGhpcy5tX3YxLndBLngsIHRoaXMubV92MS53QS55LCB0aGlzLm1fdjEud0IueCwgdGhpcy5tX3YxLndCLnksIHRoaXMubV92Mi5hLCB0aGlzLm1fdjIud0EueCwgdGhpcy5tX3YyLndBLnksIHRoaXMubV92Mi53Qi54LCB0aGlzLm1fdjIud0IueSwgdGhpcy5tX3YzLmEsIHRoaXMubV92My53QS54LCB0aGlzLm1fdjMud0EueSwgdGhpcy5tX3YzLndCLngsIHRoaXMubV92My53Qi55IF0udG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubV9jb3VudCA9PSAyKSB7XG4gICAgICAgIHJldHVybiBbIFwiK1wiICsgdGhpcy5tX2NvdW50LCB0aGlzLm1fdjEuYSwgdGhpcy5tX3YxLndBLngsIHRoaXMubV92MS53QS55LCB0aGlzLm1fdjEud0IueCwgdGhpcy5tX3YxLndCLnksIHRoaXMubV92Mi5hLCB0aGlzLm1fdjIud0EueCwgdGhpcy5tX3YyLndBLnksIHRoaXMubV92Mi53Qi54LCB0aGlzLm1fdjIud0IueSBdLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1fY291bnQgPT0gMSkge1xuICAgICAgICByZXR1cm4gWyBcIitcIiArIHRoaXMubV9jb3VudCwgdGhpcy5tX3YxLmEsIHRoaXMubV92MS53QS54LCB0aGlzLm1fdjEud0EueSwgdGhpcy5tX3YxLndCLngsIHRoaXMubV92MS53Qi55IF0udG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCIrXCIgKyB0aGlzLm1fY291bnQ7XG4gICAgfVxufTtcblxuLy8gKFNpbXBsZXhDYWNoZSwgRGlzdGFuY2VQcm94eSwgLi4uKVxuU2ltcGxleC5wcm90b3R5cGUucmVhZENhY2hlID0gZnVuY3Rpb24oY2FjaGUsIHByb3h5QSwgdHJhbnNmb3JtQSwgcHJveHlCLCB0cmFuc2Zvcm1CKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGNhY2hlLmNvdW50IDw9IDMpO1xuICAgIC8vIENvcHkgZGF0YSBmcm9tIGNhY2hlLlxuICAgIHRoaXMubV9jb3VudCA9IGNhY2hlLmNvdW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLm1fdltpXTtcbiAgICAgICAgdi5pbmRleEEgPSBjYWNoZS5pbmRleEFbaV07XG4gICAgICAgIHYuaW5kZXhCID0gY2FjaGUuaW5kZXhCW2ldO1xuICAgICAgICB2YXIgd0FMb2NhbCA9IHByb3h5QS5nZXRWZXJ0ZXgodi5pbmRleEEpO1xuICAgICAgICB2YXIgd0JMb2NhbCA9IHByb3h5Qi5nZXRWZXJ0ZXgodi5pbmRleEIpO1xuICAgICAgICB2LndBID0gVHJhbnNmb3JtLm11bFZlYzIodHJhbnNmb3JtQSwgd0FMb2NhbCk7XG4gICAgICAgIHYud0IgPSBUcmFuc2Zvcm0ubXVsVmVjMih0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcbiAgICAgICAgdi53ID0gVmVjMi5zdWIodi53Qiwgdi53QSk7XG4gICAgICAgIHYuYSA9IDA7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBzaW1wbGV4IG1ldHJpYywgaWYgaXQgaXMgc3Vic3RhbnRpYWxseSBkaWZmZXJlbnQgdGhhblxuICAgIC8vIG9sZCBtZXRyaWMgdGhlbiBmbHVzaCB0aGUgc2ltcGxleC5cbiAgICBpZiAodGhpcy5tX2NvdW50ID4gMSkge1xuICAgICAgICB2YXIgbWV0cmljMSA9IGNhY2hlLm1ldHJpYztcbiAgICAgICAgdmFyIG1ldHJpYzIgPSB0aGlzLmdldE1ldHJpYygpO1xuICAgICAgICBpZiAobWV0cmljMiA8IC41ICogbWV0cmljMSB8fCAyICogbWV0cmljMSA8IG1ldHJpYzIgfHwgbWV0cmljMiA8IE1hdGguRVBTSUxPTikge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHNpbXBsZXguXG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBjYWNoZSBpcyBlbXB0eSBvciBpbnZhbGlkLi4uXG4gICAgaWYgKHRoaXMubV9jb3VudCA9PSAwKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5tX3ZbMF07XG4gICAgICAgIC8vIFNpbXBsZXhWZXJ0ZXhcbiAgICAgICAgdi5pbmRleEEgPSAwO1xuICAgICAgICB2LmluZGV4QiA9IDA7XG4gICAgICAgIHZhciB3QUxvY2FsID0gcHJveHlBLmdldFZlcnRleCgwKTtcbiAgICAgICAgdmFyIHdCTG9jYWwgPSBwcm94eUIuZ2V0VmVydGV4KDApO1xuICAgICAgICB2LndBID0gVHJhbnNmb3JtLm11bFZlYzIodHJhbnNmb3JtQSwgd0FMb2NhbCk7XG4gICAgICAgIHYud0IgPSBUcmFuc2Zvcm0ubXVsVmVjMih0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcbiAgICAgICAgdi53ID0gVmVjMi5zdWIodi53Qiwgdi53QSk7XG4gICAgICAgIHYuYSA9IDE7XG4gICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgfVxufTtcblxuLy8gKFNpbXBsZXhDYWNoZSlcblNpbXBsZXgucHJvdG90eXBlLndyaXRlQ2FjaGUgPSBmdW5jdGlvbihjYWNoZSkge1xuICAgIGNhY2hlLm1ldHJpYyA9IHRoaXMuZ2V0TWV0cmljKCk7XG4gICAgY2FjaGUuY291bnQgPSB0aGlzLm1fY291bnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICBjYWNoZS5pbmRleEFbaV0gPSB0aGlzLm1fdltpXS5pbmRleEE7XG4gICAgICAgIGNhY2hlLmluZGV4QltpXSA9IHRoaXMubV92W2ldLmluZGV4QjtcbiAgICB9XG59O1xuXG5TaW1wbGV4LnByb3RvdHlwZS5nZXRTZWFyY2hEaXJlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gVmVjMi5uZWcodGhpcy5tX3YxLncpO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlMTIgPSBWZWMyLnN1Yih0aGlzLm1fdjIudywgdGhpcy5tX3YxLncpO1xuICAgICAgICAgICAgdmFyIHNnbiA9IFZlYzIuY3Jvc3MoZTEyLCBWZWMyLm5lZyh0aGlzLm1fdjEudykpO1xuICAgICAgICAgICAgaWYgKHNnbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW4gaXMgbGVmdCBvZiBlMTIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIuY3Jvc3MoMSwgZTEyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3JpZ2luIGlzIHJpZ2h0IG9mIGUxMi5cbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5jcm9zcyhlMTIsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHJldHVybiBWZWMyLnplcm8oKTtcbiAgICB9XG59O1xuXG5TaW1wbGV4LnByb3RvdHlwZS5nZXRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gVmVjMi56ZXJvKCk7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFZlYzIuY2xvbmUodGhpcy5tX3YxLncpO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBWZWMyLmNvbWJpbmUodGhpcy5tX3YxLmEsIHRoaXMubV92MS53LCB0aGlzLm1fdjIuYSwgdGhpcy5tX3YyLncpO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBWZWMyLnplcm8oKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIFZlYzIuemVybygpO1xuICAgIH1cbn07XG5cblNpbXBsZXgucHJvdG90eXBlLmdldFdpdG5lc3NQb2ludHMgPSBmdW5jdGlvbihwQSwgcEIpIHtcbiAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBwQS5zZXQodGhpcy5tX3YxLndBKTtcbiAgICAgICAgcEIuc2V0KHRoaXMubV92MS53Qik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHBBLnNldENvbWJpbmUodGhpcy5tX3YxLmEsIHRoaXMubV92MS53QSwgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53QSk7XG4gICAgICAgIHBCLnNldENvbWJpbmUodGhpcy5tX3YxLmEsIHRoaXMubV92MS53QiwgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53Qik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHBBLnNldENvbWJpbmUodGhpcy5tX3YxLmEsIHRoaXMubV92MS53QSwgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53QSk7XG4gICAgICAgIHBBLmFkZE11bCh0aGlzLm1fdjMuYSwgdGhpcy5tX3YzLndBKTtcbiAgICAgICAgcEIuc2V0KHBBKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cblNpbXBsZXgucHJvdG90eXBlLmdldE1ldHJpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBWZWMyLmRpc3RhbmNlKHRoaXMubV92MS53LCB0aGlzLm1fdjIudyk7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFZlYzIuY3Jvc3MoVmVjMi5zdWIodGhpcy5tX3YyLncsIHRoaXMubV92MS53KSwgVmVjMi5zdWIodGhpcy5tX3YzLncsIHRoaXMubV92MS53KSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cblNpbXBsZXgucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5zb2x2ZTIoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy5zb2x2ZTMoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgfVxufTtcblxuLy8gU29sdmUgYSBsaW5lIHNlZ21lbnQgdXNpbmcgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMuXG4vL1xuLy8gcCA9IGExICogdzEgKyBhMiAqIHcyXG4vLyBhMSArIGEyID0gMVxuLy9cbi8vIFRoZSB2ZWN0b3IgZnJvbSB0aGUgb3JpZ2luIHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIGlzXG4vLyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lLlxuLy8gZTEyID0gdzIgLSB3MVxuLy8gZG90KHAsIGUpID0gMFxuLy8gYTEgKiBkb3QodzEsIGUpICsgYTIgKiBkb3QodzIsIGUpID0gMFxuLy9cbi8vIDItYnktMiBsaW5lYXIgc3lzdGVtXG4vLyBbMSAxIF1bYTFdID0gWzFdXG4vLyBbdzEuZTEyIHcyLmUxMl1bYTJdID0gWzBdXG4vL1xuLy8gRGVmaW5lXG4vLyBkMTJfMSA9IGRvdCh3MiwgZTEyKVxuLy8gZDEyXzIgPSAtZG90KHcxLCBlMTIpXG4vLyBkMTIgPSBkMTJfMSArIGQxMl8yXG4vL1xuLy8gU29sdXRpb25cbi8vIGExID0gZDEyXzEgLyBkMTJcbi8vIGEyID0gZDEyXzIgLyBkMTJcblNpbXBsZXgucHJvdG90eXBlLnNvbHZlMiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3MSA9IHRoaXMubV92MS53O1xuICAgIHZhciB3MiA9IHRoaXMubV92Mi53O1xuICAgIHZhciBlMTIgPSBWZWMyLnN1Yih3MiwgdzEpO1xuICAgIC8vIHcxIHJlZ2lvblxuICAgIHZhciBkMTJfMiA9IC1WZWMyLmRvdCh3MSwgZTEyKTtcbiAgICBpZiAoZDEyXzIgPD0gMCkge1xuICAgICAgICAvLyBhMiA8PSAwLCBzbyB3ZSBjbGFtcCBpdCB0byAwXG4gICAgICAgIHRoaXMubV92MS5hID0gMTtcbiAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3MiByZWdpb25cbiAgICB2YXIgZDEyXzEgPSBWZWMyLmRvdCh3MiwgZTEyKTtcbiAgICBpZiAoZDEyXzEgPD0gMCkge1xuICAgICAgICAvLyBhMSA8PSAwLCBzbyB3ZSBjbGFtcCBpdCB0byAwXG4gICAgICAgIHRoaXMubV92Mi5hID0gMTtcbiAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgdGhpcy5tX3YxLnNldCh0aGlzLm1fdjIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE11c3QgYmUgaW4gZTEyIHJlZ2lvbi5cbiAgICB2YXIgaW52X2QxMiA9IDEgLyAoZDEyXzEgKyBkMTJfMik7XG4gICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XG4gICAgdGhpcy5tX3YyLmEgPSBkMTJfMiAqIGludl9kMTI7XG4gICAgdGhpcy5tX2NvdW50ID0gMjtcbn07XG5cbi8vIFBvc3NpYmxlIHJlZ2lvbnM6XG4vLyAtIHBvaW50c1syXVxuLy8gLSBlZGdlIHBvaW50c1swXS1wb2ludHNbMl1cbi8vIC0gZWRnZSBwb2ludHNbMV0tcG9pbnRzWzJdXG4vLyAtIGluc2lkZSB0aGUgdHJpYW5nbGVcblNpbXBsZXgucHJvdG90eXBlLnNvbHZlMyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3MSA9IHRoaXMubV92MS53O1xuICAgIHZhciB3MiA9IHRoaXMubV92Mi53O1xuICAgIHZhciB3MyA9IHRoaXMubV92My53O1xuICAgIC8vIEVkZ2UxMlxuICAgIC8vIFsxIDEgXVthMV0gPSBbMV1cbiAgICAvLyBbdzEuZTEyIHcyLmUxMl1bYTJdID0gWzBdXG4gICAgLy8gYTMgPSAwXG4gICAgdmFyIGUxMiA9IFZlYzIuc3ViKHcyLCB3MSk7XG4gICAgdmFyIHcxZTEyID0gVmVjMi5kb3QodzEsIGUxMik7XG4gICAgdmFyIHcyZTEyID0gVmVjMi5kb3QodzIsIGUxMik7XG4gICAgdmFyIGQxMl8xID0gdzJlMTI7XG4gICAgdmFyIGQxMl8yID0gLXcxZTEyO1xuICAgIC8vIEVkZ2UxM1xuICAgIC8vIFsxIDEgXVthMV0gPSBbMV1cbiAgICAvLyBbdzEuZTEzIHczLmUxM11bYTNdID0gWzBdXG4gICAgLy8gYTIgPSAwXG4gICAgdmFyIGUxMyA9IFZlYzIuc3ViKHczLCB3MSk7XG4gICAgdmFyIHcxZTEzID0gVmVjMi5kb3QodzEsIGUxMyk7XG4gICAgdmFyIHczZTEzID0gVmVjMi5kb3QodzMsIGUxMyk7XG4gICAgdmFyIGQxM18xID0gdzNlMTM7XG4gICAgdmFyIGQxM18yID0gLXcxZTEzO1xuICAgIC8vIEVkZ2UyM1xuICAgIC8vIFsxIDEgXVthMl0gPSBbMV1cbiAgICAvLyBbdzIuZTIzIHczLmUyM11bYTNdID0gWzBdXG4gICAgLy8gYTEgPSAwXG4gICAgdmFyIGUyMyA9IFZlYzIuc3ViKHczLCB3Mik7XG4gICAgLy8gVmVjMlxuICAgIHZhciB3MmUyMyA9IFZlYzIuZG90KHcyLCBlMjMpO1xuICAgIHZhciB3M2UyMyA9IFZlYzIuZG90KHczLCBlMjMpO1xuICAgIHZhciBkMjNfMSA9IHczZTIzO1xuICAgIHZhciBkMjNfMiA9IC13MmUyMztcbiAgICAvLyBUcmlhbmdsZTEyM1xuICAgIHZhciBuMTIzID0gVmVjMi5jcm9zcyhlMTIsIGUxMyk7XG4gICAgdmFyIGQxMjNfMSA9IG4xMjMgKiBWZWMyLmNyb3NzKHcyLCB3Myk7XG4gICAgdmFyIGQxMjNfMiA9IG4xMjMgKiBWZWMyLmNyb3NzKHczLCB3MSk7XG4gICAgdmFyIGQxMjNfMyA9IG4xMjMgKiBWZWMyLmNyb3NzKHcxLCB3Mik7XG4gICAgLy8gdzEgcmVnaW9uXG4gICAgaWYgKGQxMl8yIDw9IDAgJiYgZDEzXzIgPD0gMCkge1xuICAgICAgICB0aGlzLm1fdjEuYSA9IDE7XG4gICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZTEyXG4gICAgaWYgKGQxMl8xID4gMCAmJiBkMTJfMiA+IDAgJiYgZDEyM18zIDw9IDApIHtcbiAgICAgICAgdmFyIGludl9kMTIgPSAxIC8gKGQxMl8xICsgZDEyXzIpO1xuICAgICAgICB0aGlzLm1fdjEuYSA9IGQxMl8xICogaW52X2QxMjtcbiAgICAgICAgdGhpcy5tX3YyLmEgPSBkMTJfMiAqIGludl9kMTI7XG4gICAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZTEzXG4gICAgaWYgKGQxM18xID4gMCAmJiBkMTNfMiA+IDAgJiYgZDEyM18yIDw9IDApIHtcbiAgICAgICAgdmFyIGludl9kMTMgPSAxIC8gKGQxM18xICsgZDEzXzIpO1xuICAgICAgICB0aGlzLm1fdjEuYSA9IGQxM18xICogaW52X2QxMztcbiAgICAgICAgdGhpcy5tX3YzLmEgPSBkMTNfMiAqIGludl9kMTM7XG4gICAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICAgICAgIHRoaXMubV92Mi5zZXQodGhpcy5tX3YzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3MiByZWdpb25cbiAgICBpZiAoZDEyXzEgPD0gMCAmJiBkMjNfMiA8PSAwKSB7XG4gICAgICAgIHRoaXMubV92Mi5hID0gMTtcbiAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgdGhpcy5tX3YxLnNldCh0aGlzLm1fdjIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHczIHJlZ2lvblxuICAgIGlmIChkMTNfMSA8PSAwICYmIGQyM18xIDw9IDApIHtcbiAgICAgICAgdGhpcy5tX3YzLmEgPSAxO1xuICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xuICAgICAgICB0aGlzLm1fdjEuc2V0KHRoaXMubV92Myk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZTIzXG4gICAgaWYgKGQyM18xID4gMCAmJiBkMjNfMiA+IDAgJiYgZDEyM18xIDw9IDApIHtcbiAgICAgICAgdmFyIGludl9kMjMgPSAxIC8gKGQyM18xICsgZDIzXzIpO1xuICAgICAgICB0aGlzLm1fdjIuYSA9IGQyM18xICogaW52X2QyMztcbiAgICAgICAgdGhpcy5tX3YzLmEgPSBkMjNfMiAqIGludl9kMjM7XG4gICAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICAgICAgIHRoaXMubV92MS5zZXQodGhpcy5tX3YzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNdXN0IGJlIGluIHRyaWFuZ2xlMTIzXG4gICAgdmFyIGludl9kMTIzID0gMSAvIChkMTIzXzEgKyBkMTIzXzIgKyBkMTIzXzMpO1xuICAgIHRoaXMubV92MS5hID0gZDEyM18xICogaW52X2QxMjM7XG4gICAgdGhpcy5tX3YyLmEgPSBkMTIzXzIgKiBpbnZfZDEyMztcbiAgICB0aGlzLm1fdjMuYSA9IGQxMjNfMyAqIGludl9kMTIzO1xuICAgIHRoaXMubV9jb3VudCA9IDM7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZ2VuZXJpYyBzaGFwZXMgb3ZlcmxhcC5cbiAqL1xuRGlzdGFuY2UudGVzdE92ZXJsYXAgPSBmdW5jdGlvbihzaGFwZUEsIGluZGV4QSwgc2hhcGVCLCBpbmRleEIsIHhmQSwgeGZCKSB7XG4gICAgdmFyIGlucHV0ID0gbmV3IERpc3RhbmNlSW5wdXQoKTtcbiAgICBpbnB1dC5wcm94eUEuc2V0KHNoYXBlQSwgaW5kZXhBKTtcbiAgICBpbnB1dC5wcm94eUIuc2V0KHNoYXBlQiwgaW5kZXhCKTtcbiAgICBpbnB1dC50cmFuc2Zvcm1BID0geGZBO1xuICAgIGlucHV0LnRyYW5zZm9ybUIgPSB4ZkI7XG4gICAgaW5wdXQudXNlUmFkaWkgPSB0cnVlO1xuICAgIHZhciBjYWNoZSA9IG5ldyBTaW1wbGV4Q2FjaGUoKTtcbiAgICB2YXIgb3V0cHV0ID0gbmV3IERpc3RhbmNlT3V0cHV0KCk7XG4gICAgRGlzdGFuY2Uob3V0cHV0LCBjYWNoZSwgaW5wdXQpO1xuICAgIHJldHVybiBvdXRwdXQuZGlzdGFuY2UgPCAxMCAqIE1hdGguRVBTSUxPTjtcbn07XG5cblxufSx7XCIuLi9TZXR0aW5nc1wiOjcsXCIuLi9jb21tb24vTWF0MjJcIjoxNixcIi4uL2NvbW1vbi9NYXQzM1wiOjE3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4uL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi4vY29tbW9uL3N0YXRzXCI6MjYsXCIuLi91dGlsL2NvbW1vblwiOjUwfV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vU2V0dGluZ3NcIik7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBQb29sID0gcmVxdWlyZShcIi4uL3V0aWwvUG9vbFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgQUFCQiA9IHJlcXVpcmUoXCIuL0FBQkJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY1RyZWU7XG5cbnZhciBhYWJiUG9vbCA9IG5ldyBQb29sKHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFBQkIoKTtcbiAgICB9LFxuICAgIHJlbGVhc2U6IGZ1bmN0aW9uKGFhYmIpIHtcbiAgICAgICAgYWFiYi5sb3dlckJvdW5kLnNldFplcm8oKTtcbiAgICAgICAgYWFiYi51cHBlckJvdW5kLnNldFplcm8oKTtcbiAgICB9XG59KTtcblxudmFyIG5vZGVQb29sID0gbmV3IFBvb2woe1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUoKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIG5vZGUgaW4gdGhlIGR5bmFtaWMgdHJlZS4gVGhlIGNsaWVudCBkb2VzIG5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZGlyZWN0bHkuXG4gKiBcbiAqIEBwcm9wIHtBQUJCfSBhYWJiIEVubGFyZ2VkIEFBQkJcbiAqIEBwcm9wIHtpbnRlZ2VyfSBoZWlnaHQgMDogbGVhZiwgLTE6IGZyZWUgbm9kZVxuICovXG5mdW5jdGlvbiBUcmVlTm9kZShpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuICAgIHRoaXMudXNlckRhdGEgPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkMSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZDIgPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArIFwiOiBcIiArIHRoaXMudXNlckRhdGE7XG4gICAgfTtcbn1cblxuVHJlZU5vZGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkMSA9PSBudWxsO1xufTtcblxuLyoqXG4gKiBBIGR5bmFtaWMgQUFCQiB0cmVlIGJyb2FkLXBoYXNlLCBpbnNwaXJlZCBieSBOYXRoYW5hZWwgUHJlc3NvbidzIGJ0RGJ2dC4gQVxuICogZHluYW1pYyB0cmVlIGFycmFuZ2VzIGRhdGEgaW4gYSBiaW5hcnkgdHJlZSB0byBhY2NlbGVyYXRlIHF1ZXJpZXMgc3VjaCBhc1xuICogdm9sdW1lIHF1ZXJpZXMgYW5kIHJheSBjYXN0cy4gTGVhZnMgYXJlIHByb3hpZXMgd2l0aCBhbiBBQUJCLiBJbiB0aGUgdHJlZSB3ZVxuICogZXhwYW5kIHRoZSBwcm94eSBBQUJCIGJ5IGBhYWJiRXh0ZW5zaW9uYCBzbyB0aGF0IHRoZSBwcm94eSBBQUJCIGlzIGJpZ2dlclxuICogdGhhbiB0aGUgY2xpZW50IG9iamVjdC4gVGhpcyBhbGxvd3MgdGhlIGNsaWVudCBvYmplY3QgdG8gbW92ZSBieSBzbWFsbFxuICogYW1vdW50cyB3aXRob3V0IHRyaWdnZXJpbmcgYSB0cmVlIHVwZGF0ZS5cbiAqIFxuICogTm9kZXMgYXJlIHBvb2xlZCBhbmQgcmVsb2NhdGFibGUsIHNvIHdlIHVzZSBub2RlIGluZGljZXMgcmF0aGVyIHRoYW5cbiAqIHBvaW50ZXJzLlxuICovXG5mdW5jdGlvbiBEeW5hbWljVHJlZSgpIHtcbiAgICB0aGlzLm1fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5tX25vZGVzID0ge307XG4gICAgdGhpcy5tX2xhc3RQcm94eUlkID0gMDtcbn1cblxuLyoqXG4gKiBHZXQgcHJveHkgdXNlciBkYXRhLlxuICogXG4gKiBAcmV0dXJuIHRoZSBwcm94eSB1c2VyIGRhdGEgb3IgMCBpZiB0aGUgaWQgaXMgaW52YWxpZC5cbiAqL1xuRHluYW1pY1RyZWUucHJvdG90eXBlLmdldFVzZXJEYXRhID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KCEhbm9kZSk7XG4gICAgcmV0dXJuIG5vZGUudXNlckRhdGE7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmF0IEFBQkIgZm9yIGEgbm9kZSBpZC5cbiAqIFxuICogQHJldHVybiB0aGUgcHJveHkgdXNlciBkYXRhIG9yIDAgaWYgdGhlIGlkIGlzIGludmFsaWQuXG4gKi9cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRGYXRBQUJCID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KCEhbm9kZSk7XG4gICAgcmV0dXJuIG5vZGUuYWFiYjtcbn07XG5cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5hbGxvY2F0ZU5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVQb29sLmFsbG9jYXRlKCk7XG4gICAgbm9kZS5pZCA9ICsrdGhpcy5tX2xhc3RQcm94eUlkO1xuICAgIG5vZGUudXNlckRhdGEgPSBudWxsO1xuICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICBub2RlLmNoaWxkMSA9IG51bGw7XG4gICAgbm9kZS5jaGlsZDIgPSBudWxsO1xuICAgIG5vZGUuaGVpZ2h0ID0gLTE7XG4gICAgdGhpcy5tX25vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5mcmVlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlUG9vbC5yZWxlYXNlKG5vZGUpO1xuICAgIG5vZGUuaGVpZ2h0ID0gLTE7XG4gICAgZGVsZXRlIHRoaXMubV9ub2Rlc1tub2RlLmlkXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcHJveHkgaW4gdGhlIHRyZWUgYXMgYSBsZWFmIG5vZGUuIFdlIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIG5vZGVcbiAqIGluc3RlYWQgb2YgYSBwb2ludGVyIHNvIHRoYXQgd2UgY2FuIGdyb3cgdGhlIG5vZGUgcG9vbC5cbiAqIFxuICogQ3JlYXRlIGEgcHJveHkuIFByb3ZpZGUgYSB0aWdodCBmaXR0aW5nIEFBQkIgYW5kIGEgdXNlckRhdGEgcG9pbnRlci5cbiAqL1xuRHluYW1pY1RyZWUucHJvdG90eXBlLmNyZWF0ZVByb3h5ID0gZnVuY3Rpb24oYWFiYiwgdXNlckRhdGEpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoQUFCQi5pc1ZhbGlkKGFhYmIpKTtcbiAgICB2YXIgbm9kZSA9IHRoaXMuYWxsb2NhdGVOb2RlKCk7XG4gICAgbm9kZS5hYWJiLnNldChhYWJiKTtcbiAgICAvLyBGYXR0ZW4gdGhlIGFhYmIuXG4gICAgbm9kZS5hYWJiLmV4dGVuZChTZXR0aW5ncy5hYWJiRXh0ZW5zaW9uKTtcbiAgICBub2RlLnVzZXJEYXRhID0gdXNlckRhdGE7XG4gICAgbm9kZS5oZWlnaHQgPSAwO1xuICAgIHRoaXMuaW5zZXJ0TGVhZihub2RlKTtcbiAgICByZXR1cm4gbm9kZS5pZDtcbn07XG5cbi8qKlxuICogRGVzdHJveSBhIHByb3h5LiBUaGlzIGFzc2VydHMgaWYgdGhlIGlkIGlzIGludmFsaWQuXG4gKi9cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5kZXN0cm95UHJveHkgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciBub2RlID0gdGhpcy5tX25vZGVzW2lkXTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoISFub2RlKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQobm9kZS5pc0xlYWYoKSk7XG4gICAgdGhpcy5yZW1vdmVMZWFmKG5vZGUpO1xuICAgIHRoaXMuZnJlZU5vZGUobm9kZSk7XG59O1xuXG4vKipcbiAqIE1vdmUgYSBwcm94eSB3aXRoIGEgc3dlcHRlZCBBQUJCLiBJZiB0aGUgcHJveHkgaGFzIG1vdmVkIG91dHNpZGUgb2YgaXRzXG4gKiBmYXR0ZW5lZCBBQUJCLCB0aGVuIHRoZSBwcm94eSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUgYW5kIHJlLWluc2VydGVkLlxuICogT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5LlxuICogXG4gKiBAcGFyYW0gaWRcbiAqIEBwYXJhbSBhYWJiXG4gKiBAcGFyYW0ge1ZlYzJ9IGQgRGlzcGxhY2VtZW50XG4gKiBcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgcHJveHkgd2FzIHJlLWluc2VydGVkLlxuICovXG5EeW5hbWljVHJlZS5wcm90b3R5cGUubW92ZVByb3h5ID0gZnVuY3Rpb24oaWQsIGFhYmIsIGQpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoQUFCQi5pc1ZhbGlkKGFhYmIpKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoIWQgfHwgVmVjMi5pc1ZhbGlkKGQpKTtcbiAgICB2YXIgbm9kZSA9IHRoaXMubV9ub2Rlc1tpZF07XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KCEhbm9kZSk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KG5vZGUuaXNMZWFmKCkpO1xuICAgIGlmIChub2RlLmFhYmIuY29udGFpbnMoYWFiYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUxlYWYobm9kZSk7XG4gICAgbm9kZS5hYWJiLnNldChhYWJiKTtcbiAgICAvLyBFeHRlbmQgQUFCQi5cbiAgICBhYWJiID0gbm9kZS5hYWJiO1xuICAgIEFBQkIuZXh0ZW5kKGFhYmIsIFNldHRpbmdzLmFhYmJFeHRlbnNpb24pO1xuICAgIC8vIFByZWRpY3QgQUFCQiBkaXNwbGFjZW1lbnQuXG4gICAgLy8gdmFyIGQgPSBWZWMyLm11bChTZXR0aW5ncy5hYWJiTXVsdGlwbGllciwgZGlzcGxhY2VtZW50KTtcbiAgICBpZiAoZC54IDwgMCkge1xuICAgICAgICBhYWJiLmxvd2VyQm91bmQueCArPSBkLnggKiBTZXR0aW5ncy5hYWJiTXVsdGlwbGllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhYWJiLnVwcGVyQm91bmQueCArPSBkLnggKiBTZXR0aW5ncy5hYWJiTXVsdGlwbGllcjtcbiAgICB9XG4gICAgaWYgKGQueSA8IDApIHtcbiAgICAgICAgYWFiYi5sb3dlckJvdW5kLnkgKz0gZC55ICogU2V0dGluZ3MuYWFiYk11bHRpcGxpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWFiYi51cHBlckJvdW5kLnkgKz0gZC55ICogU2V0dGluZ3MuYWFiYk11bHRpcGxpZXI7XG4gICAgfVxuICAgIHRoaXMuaW5zZXJ0TGVhZihub2RlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5pbnNlcnRMZWFmID0gZnVuY3Rpb24obGVhZikge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChBQUJCLmlzVmFsaWQobGVhZi5hYWJiKSk7XG4gICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5tX3Jvb3QgPSBsZWFmO1xuICAgICAgICB0aGlzLm1fcm9vdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGJlc3Qgc2libGluZyBmb3IgdGhpcyBub2RlXG4gICAgdmFyIGxlYWZBQUJCID0gbGVhZi5hYWJiO1xuICAgIHZhciBpbmRleCA9IHRoaXMubV9yb290O1xuICAgIHdoaWxlIChpbmRleC5pc0xlYWYoKSA9PSBmYWxzZSkge1xuICAgICAgICB2YXIgY2hpbGQxID0gaW5kZXguY2hpbGQxO1xuICAgICAgICB2YXIgY2hpbGQyID0gaW5kZXguY2hpbGQyO1xuICAgICAgICB2YXIgYXJlYSA9IGluZGV4LmFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgIHZhciBjb21iaW5lZEFBQkIgPSBhYWJiUG9vbC5hbGxvY2F0ZSgpO1xuICAgICAgICBjb21iaW5lZEFBQkIuY29tYmluZShpbmRleC5hYWJiLCBsZWFmQUFCQik7XG4gICAgICAgIHZhciBjb21iaW5lZEFyZWEgPSBjb21iaW5lZEFBQkIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgIGFhYmJQb29sLnJlbGVhc2UoY29tYmluZWRBQUJCKTtcbiAgICAgICAgLy8gQ29zdCBvZiBjcmVhdGluZyBhIG5ldyBwYXJlbnQgZm9yIHRoaXMgbm9kZSBhbmQgdGhlIG5ldyBsZWFmXG4gICAgICAgIHZhciBjb3N0ID0gMiAqIGNvbWJpbmVkQXJlYTtcbiAgICAgICAgLy8gTWluaW11bSBjb3N0IG9mIHB1c2hpbmcgdGhlIGxlYWYgZnVydGhlciBkb3duIHRoZSB0cmVlXG4gICAgICAgIHZhciBpbmhlcml0YW5jZUNvc3QgPSAyICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xuICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmcgaW50byBjaGlsZDFcbiAgICAgICAgdmFyIGNvc3QxO1xuICAgICAgICBpZiAoY2hpbGQxLmlzTGVhZigpKSB7XG4gICAgICAgICAgICB2YXIgYWFiYiA9IGFhYmJQb29sLmFsbG9jYXRlKCk7XG4gICAgICAgICAgICBhYWJiLmNvbWJpbmUobGVhZkFBQkIsIGNoaWxkMS5hYWJiKTtcbiAgICAgICAgICAgIGNvc3QxID0gYWFiYi5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgIGFhYmJQb29sLnJlbGVhc2UoYWFiYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWFiYiA9IGFhYmJQb29sLmFsbG9jYXRlKCk7XG4gICAgICAgICAgICBhYWJiLmNvbWJpbmUobGVhZkFBQkIsIGNoaWxkMS5hYWJiKTtcbiAgICAgICAgICAgIHZhciBvbGRBcmVhID0gY2hpbGQxLmFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICB2YXIgbmV3QXJlYSA9IGFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICBjb3N0MSA9IG5ld0FyZWEgLSBvbGRBcmVhICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgYWFiYlBvb2wucmVsZWFzZShhYWJiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmcgaW50byBjaGlsZDJcbiAgICAgICAgdmFyIGNvc3QyO1xuICAgICAgICBpZiAoY2hpbGQyLmlzTGVhZigpKSB7XG4gICAgICAgICAgICB2YXIgYWFiYiA9IGFhYmJQb29sLmFsbG9jYXRlKCk7XG4gICAgICAgICAgICBhYWJiLmNvbWJpbmUobGVhZkFBQkIsIGNoaWxkMi5hYWJiKTtcbiAgICAgICAgICAgIGNvc3QyID0gYWFiYi5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgIGFhYmJQb29sLnJlbGVhc2UoYWFiYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWFiYiA9IGFhYmJQb29sLmFsbG9jYXRlKCk7XG4gICAgICAgICAgICBhYWJiLmNvbWJpbmUobGVhZkFBQkIsIGNoaWxkMi5hYWJiKTtcbiAgICAgICAgICAgIHZhciBvbGRBcmVhID0gY2hpbGQyLmFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICB2YXIgbmV3QXJlYSA9IGFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICBjb3N0MiA9IG5ld0FyZWEgLSBvbGRBcmVhICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgYWFiYlBvb2wucmVsZWFzZShhYWJiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXNjZW5kIGFjY29yZGluZyB0byB0aGUgbWluaW11bSBjb3N0LlxuICAgICAgICBpZiAoY29zdCA8IGNvc3QxICYmIGNvc3QgPCBjb3N0Mikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVzY2VuZFxuICAgICAgICBpZiAoY29zdDEgPCBjb3N0Mikge1xuICAgICAgICAgICAgaW5kZXggPSBjaGlsZDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IGNoaWxkMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2libGluZyA9IGluZGV4O1xuICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJlbnQuXG4gICAgdmFyIG9sZFBhcmVudCA9IHNpYmxpbmcucGFyZW50O1xuICAgIHZhciBuZXdQYXJlbnQgPSB0aGlzLmFsbG9jYXRlTm9kZSgpO1xuICAgIG5ld1BhcmVudC5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgbmV3UGFyZW50LnVzZXJEYXRhID0gbnVsbDtcbiAgICBuZXdQYXJlbnQuYWFiYi5jb21iaW5lKGxlYWZBQUJCLCBzaWJsaW5nLmFhYmIpO1xuICAgIG5ld1BhcmVudC5oZWlnaHQgPSBzaWJsaW5nLmhlaWdodCArIDE7XG4gICAgaWYgKG9sZFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBzaWJsaW5nIHdhcyBub3QgdGhlIHJvb3QuXG4gICAgICAgIGlmIChvbGRQYXJlbnQuY2hpbGQxID09IHNpYmxpbmcpIHtcbiAgICAgICAgICAgIG9sZFBhcmVudC5jaGlsZDEgPSBuZXdQYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbGRQYXJlbnQuY2hpbGQyID0gbmV3UGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZDEgPSBzaWJsaW5nO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGQyID0gbGVhZjtcbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBzaWJsaW5nIHdhcyB0aGUgcm9vdC5cbiAgICAgICAgbmV3UGFyZW50LmNoaWxkMSA9IHNpYmxpbmc7XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZDIgPSBsZWFmO1xuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgIHRoaXMubV9yb290ID0gbmV3UGFyZW50O1xuICAgIH1cbiAgICAvLyBXYWxrIGJhY2sgdXAgdGhlIHRyZWUgZml4aW5nIGhlaWdodHMgYW5kIEFBQkJzXG4gICAgaW5kZXggPSBsZWFmLnBhcmVudDtcbiAgICB3aGlsZSAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBpbmRleCA9IHRoaXMuYmFsYW5jZShpbmRleCk7XG4gICAgICAgIHZhciBjaGlsZDEgPSBpbmRleC5jaGlsZDE7XG4gICAgICAgIHZhciBjaGlsZDIgPSBpbmRleC5jaGlsZDI7XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChjaGlsZDEgIT0gbnVsbCk7XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChjaGlsZDIgIT0gbnVsbCk7XG4gICAgICAgIGluZGV4LmhlaWdodCA9IDEgKyBNYXRoLm1heChjaGlsZDEuaGVpZ2h0LCBjaGlsZDIuaGVpZ2h0KTtcbiAgICAgICAgaW5kZXguYWFiYi5jb21iaW5lKGNoaWxkMS5hYWJiLCBjaGlsZDIuYWFiYik7XG4gICAgICAgIGluZGV4ID0gaW5kZXgucGFyZW50O1xuICAgIH1cbn07XG5cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5yZW1vdmVMZWFmID0gZnVuY3Rpb24obGVhZikge1xuICAgIGlmIChsZWFmID09IHRoaXMubV9yb290KSB7XG4gICAgICAgIHRoaXMubV9yb290ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbGVhZi5wYXJlbnQ7XG4gICAgdmFyIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB2YXIgc2libGluZztcbiAgICBpZiAocGFyZW50LmNoaWxkMSA9PSBsZWFmKSB7XG4gICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuY2hpbGQyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuY2hpbGQxO1xuICAgIH1cbiAgICBpZiAoZ3JhbmRQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBEZXN0cm95IHBhcmVudCBhbmQgY29ubmVjdCBzaWJsaW5nIHRvIGdyYW5kUGFyZW50LlxuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQuY2hpbGQxID09IHBhcmVudCkge1xuICAgICAgICAgICAgZ3JhbmRQYXJlbnQuY2hpbGQxID0gc2libGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyYW5kUGFyZW50LmNoaWxkMiA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBncmFuZFBhcmVudDtcbiAgICAgICAgdGhpcy5mcmVlTm9kZShwYXJlbnQpO1xuICAgICAgICAvLyBBZGp1c3QgYW5jZXN0b3IgYm91bmRzLlxuICAgICAgICB2YXIgaW5kZXggPSBncmFuZFBhcmVudDtcbiAgICAgICAgd2hpbGUgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5iYWxhbmNlKGluZGV4KTtcbiAgICAgICAgICAgIHZhciBjaGlsZDEgPSBpbmRleC5jaGlsZDE7XG4gICAgICAgICAgICB2YXIgY2hpbGQyID0gaW5kZXguY2hpbGQyO1xuICAgICAgICAgICAgaW5kZXguYWFiYi5jb21iaW5lKGNoaWxkMS5hYWJiLCBjaGlsZDIuYWFiYik7XG4gICAgICAgICAgICBpbmRleC5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY2hpbGQxLmhlaWdodCwgY2hpbGQyLmhlaWdodCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4LnBhcmVudDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9yb290ID0gc2libGluZztcbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZyZWVOb2RlKHBhcmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgbGVmdCBvciByaWdodCByb3RhdGlvbiBpZiBub2RlIEEgaXMgaW1iYWxhbmNlZC4gUmV0dXJucyB0aGUgbmV3XG4gKiByb290IGluZGV4LlxuICovXG5EeW5hbWljVHJlZS5wcm90b3R5cGUuYmFsYW5jZSA9IGZ1bmN0aW9uKGlBKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGlBICE9IG51bGwpO1xuICAgIHZhciBBID0gaUE7XG4gICAgaWYgKEEuaXNMZWFmKCkgfHwgQS5oZWlnaHQgPCAyKSB7XG4gICAgICAgIHJldHVybiBpQTtcbiAgICB9XG4gICAgdmFyIEIgPSBBLmNoaWxkMTtcbiAgICB2YXIgQyA9IEEuY2hpbGQyO1xuICAgIHZhciBiYWxhbmNlID0gQy5oZWlnaHQgLSBCLmhlaWdodDtcbiAgICAvLyBSb3RhdGUgQyB1cFxuICAgIGlmIChiYWxhbmNlID4gMSkge1xuICAgICAgICB2YXIgRiA9IEMuY2hpbGQxO1xuICAgICAgICB2YXIgRyA9IEMuY2hpbGQyO1xuICAgICAgICAvLyBTd2FwIEEgYW5kIENcbiAgICAgICAgQy5jaGlsZDEgPSBBO1xuICAgICAgICBDLnBhcmVudCA9IEEucGFyZW50O1xuICAgICAgICBBLnBhcmVudCA9IEM7XG4gICAgICAgIC8vIEEncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBDXG4gICAgICAgIGlmIChDLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoQy5wYXJlbnQuY2hpbGQxID09IGlBKSB7XG4gICAgICAgICAgICAgICAgQy5wYXJlbnQuY2hpbGQxID0gQztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQy5wYXJlbnQuY2hpbGQyID0gQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9yb290ID0gQztcbiAgICAgICAgfVxuICAgICAgICAvLyBSb3RhdGVcbiAgICAgICAgaWYgKEYuaGVpZ2h0ID4gRy5oZWlnaHQpIHtcbiAgICAgICAgICAgIEMuY2hpbGQyID0gRjtcbiAgICAgICAgICAgIEEuY2hpbGQyID0gRztcbiAgICAgICAgICAgIEcucGFyZW50ID0gQTtcbiAgICAgICAgICAgIEEuYWFiYi5jb21iaW5lKEIuYWFiYiwgRy5hYWJiKTtcbiAgICAgICAgICAgIEMuYWFiYi5jb21iaW5lKEEuYWFiYiwgRi5hYWJiKTtcbiAgICAgICAgICAgIEEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KEIuaGVpZ2h0LCBHLmhlaWdodCk7XG4gICAgICAgICAgICBDLmhlaWdodCA9IDEgKyBNYXRoLm1heChBLmhlaWdodCwgRi5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQy5jaGlsZDIgPSBHO1xuICAgICAgICAgICAgQS5jaGlsZDIgPSBGO1xuICAgICAgICAgICAgRi5wYXJlbnQgPSBBO1xuICAgICAgICAgICAgQS5hYWJiLmNvbWJpbmUoQi5hYWJiLCBGLmFhYmIpO1xuICAgICAgICAgICAgQy5hYWJiLmNvbWJpbmUoQS5hYWJiLCBHLmFhYmIpO1xuICAgICAgICAgICAgQS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoQi5oZWlnaHQsIEYuaGVpZ2h0KTtcbiAgICAgICAgICAgIEMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KEEuaGVpZ2h0LCBHLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEM7XG4gICAgfVxuICAgIC8vIFJvdGF0ZSBCIHVwXG4gICAgaWYgKGJhbGFuY2UgPCAtMSkge1xuICAgICAgICB2YXIgRCA9IEIuY2hpbGQxO1xuICAgICAgICB2YXIgRSA9IEIuY2hpbGQyO1xuICAgICAgICAvLyBTd2FwIEEgYW5kIEJcbiAgICAgICAgQi5jaGlsZDEgPSBBO1xuICAgICAgICBCLnBhcmVudCA9IEEucGFyZW50O1xuICAgICAgICBBLnBhcmVudCA9IEI7XG4gICAgICAgIC8vIEEncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBCXG4gICAgICAgIGlmIChCLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoQi5wYXJlbnQuY2hpbGQxID09IEEpIHtcbiAgICAgICAgICAgICAgICBCLnBhcmVudC5jaGlsZDEgPSBCO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCLnBhcmVudC5jaGlsZDIgPSBCO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBCO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJvdGF0ZVxuICAgICAgICBpZiAoRC5oZWlnaHQgPiBFLmhlaWdodCkge1xuICAgICAgICAgICAgQi5jaGlsZDIgPSBEO1xuICAgICAgICAgICAgQS5jaGlsZDEgPSBFO1xuICAgICAgICAgICAgRS5wYXJlbnQgPSBBO1xuICAgICAgICAgICAgQS5hYWJiLmNvbWJpbmUoQy5hYWJiLCBFLmFhYmIpO1xuICAgICAgICAgICAgQi5hYWJiLmNvbWJpbmUoQS5hYWJiLCBELmFhYmIpO1xuICAgICAgICAgICAgQS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoQy5oZWlnaHQsIEUuaGVpZ2h0KTtcbiAgICAgICAgICAgIEIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KEEuaGVpZ2h0LCBELmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBCLmNoaWxkMiA9IEU7XG4gICAgICAgICAgICBBLmNoaWxkMSA9IEQ7XG4gICAgICAgICAgICBELnBhcmVudCA9IEE7XG4gICAgICAgICAgICBBLmFhYmIuY29tYmluZShDLmFhYmIsIEQuYWFiYik7XG4gICAgICAgICAgICBCLmFhYmIuY29tYmluZShBLmFhYmIsIEUuYWFiYik7XG4gICAgICAgICAgICBBLmhlaWdodCA9IDEgKyBNYXRoLm1heChDLmhlaWdodCwgRC5oZWlnaHQpO1xuICAgICAgICAgICAgQi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoQS5oZWlnaHQsIEUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGhlaWdodCBvZiB0aGUgYmluYXJ5IHRyZWUgaW4gTyhOKSB0aW1lLiBTaG91bGQgbm90IGJlIGNhbGxlZFxuICogb2Z0ZW4uXG4gKi9cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubV9yb290LmhlaWdodDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByYXRpbyBvZiB0aGUgc3VtIG9mIHRoZSBub2RlIGFyZWFzIHRvIHRoZSByb290IGFyZWEuXG4gKi9cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRBcmVhUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSB0aGlzLm1fcm9vdDtcbiAgICB2YXIgcm9vdEFyZWEgPSByb290LmFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG4gICAgdmFyIG5vZGUsIGl0ID0gaXRlcmF0b3JQb29sLmFsbG9jYXRlKCkucHJlb3JkZXIoKTtcbiAgICB3aGlsZSAobm9kZSA9IGl0Lm5leHQoKSkge1xuICAgICAgICBpZiAobm9kZS5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAvLyBGcmVlIG5vZGUgaW4gcG9vbFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWxBcmVhICs9IG5vZGUuYWFiYi5nZXRQZXJpbWV0ZXIoKTtcbiAgICB9XG4gICAgaXRlcmF0b3JQb29sLnJlbGVhc2UoaXQpO1xuICAgIHJldHVybiB0b3RhbEFyZWEgLyByb290QXJlYTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaGVpZ2h0IG9mIGEgc3ViLXRyZWUuXG4gKi9cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5jb21wdXRlSGVpZ2h0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLm1fbm9kZXNbaWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLm1fcm9vdDtcbiAgICB9XG4gICAgLy8gX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gaWQgJiYgaWQgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGhlaWdodDEgPSBDb21wdXRlSGVpZ2h0KG5vZGUuY2hpbGQxKTtcbiAgICB2YXIgaGVpZ2h0MiA9IENvbXB1dGVIZWlnaHQobm9kZS5jaGlsZDIpO1xuICAgIHJldHVybiAxICsgTWF0aC5tYXgoaGVpZ2h0MSwgaGVpZ2h0Mik7XG59O1xuXG5EeW5hbWljVHJlZS5wcm90b3R5cGUudmFsaWRhdGVTdHJ1Y3R1cmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlID09IHRoaXMubV9yb290KSB7XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChub2RlLnBhcmVudCA9PSBudWxsKTtcbiAgICB9XG4gICAgdmFyIGNoaWxkMSA9IG5vZGUuY2hpbGQxO1xuICAgIHZhciBjaGlsZDIgPSBub2RlLmNoaWxkMjtcbiAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoY2hpbGQxID09IG51bGwpO1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoY2hpbGQyID09IG51bGwpO1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQobm9kZS5oZWlnaHQgPT0gMCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gY2hpbGQxICYmIGNoaWxkMSA8IHRoaXMubV9ub2RlQ2FwYWNpdHkpO1xuICAgIC8vIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCgwIDw9IGNoaWxkMiAmJiBjaGlsZDIgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoY2hpbGQxLnBhcmVudCA9PSBub2RlKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoY2hpbGQyLnBhcmVudCA9PSBub2RlKTtcbiAgICB0aGlzLnZhbGlkYXRlU3RydWN0dXJlKGNoaWxkMSk7XG4gICAgdGhpcy52YWxpZGF0ZVN0cnVjdHVyZShjaGlsZDIpO1xufTtcblxuRHluYW1pY1RyZWUucHJvdG90eXBlLnZhbGlkYXRlTWV0cmljcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNoaWxkMSA9IG5vZGUuY2hpbGQxO1xuICAgIHZhciBjaGlsZDIgPSBub2RlLmNoaWxkMjtcbiAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoY2hpbGQxID09IG51bGwpO1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoY2hpbGQyID09IG51bGwpO1xuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQobm9kZS5oZWlnaHQgPT0gMCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gY2hpbGQxICYmIGNoaWxkMSA8IHRoaXMubV9ub2RlQ2FwYWNpdHkpO1xuICAgIC8vIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCgwIDw9IGNoaWxkMiAmJiBjaGlsZDIgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICB2YXIgaGVpZ2h0MSA9IHRoaXMubV9ub2Rlc1tjaGlsZDFdLmhlaWdodDtcbiAgICB2YXIgaGVpZ2h0MiA9IHRoaXMubV9ub2Rlc1tjaGlsZDJdLmhlaWdodDtcbiAgICB2YXIgaGVpZ2h0ID0gMSArIE1hdGgubWF4KGhlaWdodDEsIGhlaWdodDIpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChub2RlLmhlaWdodCA9PSBoZWlnaHQpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChBQUJCLmFyZUVxdWFsKG5ldyBBQUJCKCkuY29tYmluZShjaGlsZDEuYWFiYiwgY2hpbGQyLmFhYmIpLCBub2RlLmFhYmIpKTtcbiAgICB0aGlzLnZhbGlkYXRlTWV0cmljcyhjaGlsZDEpO1xuICAgIHRoaXMudmFsaWRhdGVNZXRyaWNzKGNoaWxkMik7XG59O1xuXG4vLyBWYWxpZGF0ZSB0aGlzIHRyZWUuIEZvciB0ZXN0aW5nLlxuRHluYW1pY1RyZWUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgVmFsaWRhdGVTdHJ1Y3R1cmUodGhpcy5tX3Jvb3QpO1xuICAgIFZhbGlkYXRlTWV0cmljcyh0aGlzLm1fcm9vdCk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMuZ2V0SGVpZ2h0KCkgPT0gdGhpcy5jb21wdXRlSGVpZ2h0KCkpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gYmFsYW5jZSBvZiBhbiBub2RlIGluIHRoZSB0cmVlLiBUaGUgYmFsYW5jZSBpcyB0aGUgZGlmZmVyZW5jZVxuICogaW4gaGVpZ2h0IG9mIHRoZSB0d28gY2hpbGRyZW4gb2YgYSBub2RlLlxuICovXG5EeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0TWF4QmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXhCYWxhbmNlID0gMDtcbiAgICB2YXIgbm9kZSwgaXQgPSBpdGVyYXRvclBvb2wuYWxsb2NhdGUoKS5wcmVvcmRlcigpO1xuICAgIHdoaWxlIChub2RlID0gaXQubmV4dCgpKSB7XG4gICAgICAgIGlmIChub2RlLmhlaWdodCA8PSAxKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQobm9kZS5pc0xlYWYoKSA9PSBmYWxzZSk7XG4gICAgICAgIHZhciBiYWxhbmNlID0gTWF0aC5hYnMobm9kZS5jaGlsZDIuaGVpZ2h0IC0gbm9kZS5jaGlsZDEuaGVpZ2h0KTtcbiAgICAgICAgbWF4QmFsYW5jZSA9IE1hdGgubWF4KG1heEJhbGFuY2UsIGJhbGFuY2UpO1xuICAgIH1cbiAgICBpdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgcmV0dXJuIG1heEJhbGFuY2U7XG59O1xuXG4vKipcbiAqIEJ1aWxkIGFuIG9wdGltYWwgdHJlZS4gVmVyeSBleHBlbnNpdmUuIEZvciB0ZXN0aW5nLlxuICovXG5EeW5hbWljVHJlZS5wcm90b3R5cGUucmVidWlsZEJvdHRvbVVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyBCdWlsZCBhcnJheSBvZiBsZWF2ZXMuIEZyZWUgdGhlIHJlc3QuXG4gICAgdmFyIG5vZGUsIGl0ID0gaXRlcmF0b3JQb29sLmFsbG9jYXRlKCkucHJlb3JkZXIoKTtcbiAgICB3aGlsZSAobm9kZSA9IGl0Lm5leHQoKSkge1xuICAgICAgICBpZiAobm9kZS5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAvLyBmcmVlIG5vZGUgaW4gcG9vbFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIG5vZGVzW2NvdW50XSA9IG5vZGU7XG4gICAgICAgICAgICArK2NvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mcmVlTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgICB2YXIgbWluQ29zdCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgaU1pbiA9IC0xLCBqTWluID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGFhYmJpID0gbm9kZXNbaV0uYWFiYjtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGNvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgYWFiYmogPSBub2Rlc1tqXS5hYWJiO1xuICAgICAgICAgICAgICAgIHZhciBiID0gYWFiYlBvb2wuYWxsb2NhdGUoKTtcbiAgICAgICAgICAgICAgICBiLmNvbWJpbmUoYWFiYmksIGFhYmJqKTtcbiAgICAgICAgICAgICAgICB2YXIgY29zdCA9IGIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvc3QgPCBtaW5Db3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlNaW4gPSBpO1xuICAgICAgICAgICAgICAgICAgICBqTWluID0gajtcbiAgICAgICAgICAgICAgICAgICAgbWluQ29zdCA9IGNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFhYmJQb29sLnJlbGVhc2UoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkMSA9IG5vZGVzW2lNaW5dO1xuICAgICAgICB2YXIgY2hpbGQyID0gbm9kZXNbak1pbl07XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmFsbG9jYXRlTm9kZSgpO1xuICAgICAgICBwYXJlbnQuY2hpbGQxID0gY2hpbGQxO1xuICAgICAgICBwYXJlbnQuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICBwYXJlbnQuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGNoaWxkMS5oZWlnaHQsIGNoaWxkMi5oZWlnaHQpO1xuICAgICAgICBwYXJlbnQuYWFiYi5jb21iaW5lKGNoaWxkMS5hYWJiLCBjaGlsZDIuYWFiYik7XG4gICAgICAgIHBhcmVudC5wYXJlbnQgPSBudWxsO1xuICAgICAgICBjaGlsZDEucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBjaGlsZDIucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBub2Rlc1tqTWluXSA9IG5vZGVzW2NvdW50IC0gMV07XG4gICAgICAgIG5vZGVzW2lNaW5dID0gcGFyZW50O1xuICAgICAgICAtLWNvdW50O1xuICAgIH1cbiAgICB0aGlzLm1fcm9vdCA9IG5vZGVzWzBdO1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbn07XG5cbi8qKlxuICogU2hpZnQgdGhlIHdvcmxkIG9yaWdpbi4gVXNlZnVsIGZvciBsYXJnZSB3b3JsZHMuIFRoZSBzaGlmdCBmb3JtdWxhIGlzOlxuICogcG9zaXRpb24gLT0gbmV3T3JpZ2luXG4gKiBcbiAqIEBwYXJhbSBuZXdPcmlnaW4gVGhlIG5ldyBvcmlnaW4gd2l0aCByZXNwZWN0IHRvIHRoZSBvbGQgb3JpZ2luXG4gKi9cbkR5bmFtaWNUcmVlLnByb3RvdHlwZS5zaGlmdE9yaWdpbiA9IGZ1bmN0aW9uKG5ld09yaWdpbikge1xuICAgIC8vIEJ1aWxkIGFycmF5IG9mIGxlYXZlcy4gRnJlZSB0aGUgcmVzdC5cbiAgICB2YXIgbm9kZSwgaXQgPSBpdGVyYXRvclBvb2wuYWxsb2NhdGUoKS5wcmVvcmRlcigpO1xuICAgIHdoaWxlIChub2RlID0gaXQubmV4dCgpKSB7XG4gICAgICAgIHZhciBhYWJiID0gbm9kZS5hYWJiO1xuICAgICAgICBhYWJiLmxvd2VyQm91bmQueCAtPSBuZXdPcmlnaW4ueDtcbiAgICAgICAgYWFiYi5sb3dlckJvdW5kLnkgLT0gbmV3T3JpZ2luLnk7XG4gICAgICAgIGFhYmIudXBwZXJCb3VuZC54IC09IG5ld09yaWdpbi54O1xuICAgICAgICBhYWJiLnVwcGVyQm91bmQueSAtPSBuZXdPcmlnaW4ueTtcbiAgICB9XG4gICAgaXRlcmF0b3JQb29sLnJlbGVhc2UoaXQpO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24ge0R5bmFtaWNUcmVlfnF1ZXJ5Q2FsbGJhY2t9XG4gKiBcbiAqIEBwYXJhbSBpZCBOb2RlIGlkLlxuICovXG4vKipcbiAqIFF1ZXJ5IGFuIEFBQkIgZm9yIG92ZXJsYXBwaW5nIHByb3hpZXMuIFRoZSBjYWxsYmFjayBjbGFzcyBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHByb3h5IHRoYXQgb3ZlcmxhcHMgdGhlIHN1cHBsaWVkIEFBQkIuXG4gKiBcbiAqIEBwYXJhbSB7RHluYW1pY1RyZWV+cXVlcnlDYWxsYmFja30gcXVlcnlDYWxsYmFja1xuICovXG5EeW5hbWljVHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihhYWJiLCBxdWVyeUNhbGxiYWNrKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHR5cGVvZiBxdWVyeUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIHZhciBzdGFjayA9IHN0YWNrUG9vbC5hbGxvY2F0ZSgpO1xuICAgIHN0YWNrLnB1c2godGhpcy5tX3Jvb3QpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBQUJCLnRlc3RPdmVybGFwKG5vZGUuYWFiYiwgYWFiYikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2NlZWQgPSBxdWVyeUNhbGxiYWNrKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZWVkID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZDEpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YWNrUG9vbC5yZWxlYXNlKHN0YWNrKTtcbn07XG5cbi8qKlxuICogUmF5LWNhc3QgYWdhaW5zdCB0aGUgcHJveGllcyBpbiB0aGUgdHJlZS4gVGhpcyByZWxpZXMgb24gdGhlIGNhbGxiYWNrIHRvXG4gKiBwZXJmb3JtIGEgZXhhY3QgcmF5LWNhc3QgaW4gdGhlIGNhc2Ugd2VyZSB0aGUgcHJveHkgY29udGFpbnMgYSBzaGFwZS4gVGhlXG4gKiBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAqIHJvdWdobHkgZXF1YWwgdG8gayAqIGxvZyhuKSwgd2hlcmUgayBpcyB0aGUgbnVtYmVyIG9mIGNvbGxpc2lvbnMgYW5kIG4gaXMgdGhlXG4gKiBudW1iZXIgb2YgcHJveGllcyBpbiB0aGUgdHJlZS5cbiAqIFxuICogQHBhcmFtIGlucHV0IFRoZSByYXktY2FzdCBpbnB1dCBkYXRhLiBUaGUgcmF5IGV4dGVuZHMgZnJvbSBwMSB0byBwMSArXG4gKiAgICAgICAgICBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKS5cbiAqIEBwYXJhbSByYXlDYXN0Q2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieVxuICogICAgICAgICAgdGhlIHJheS5cbiAqL1xuRHluYW1pY1RyZWUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbihpbnB1dCwgcmF5Q2FzdENhbGxiYWNrKSB7XG4gICAgLy8gVE9ETyBHQ1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0eXBlb2YgcmF5Q2FzdENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIHZhciBwMSA9IGlucHV0LnAxO1xuICAgIHZhciBwMiA9IGlucHV0LnAyO1xuICAgIHZhciByID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoci5sZW5ndGhTcXVhcmVkKCkgPiAwKTtcbiAgICByLm5vcm1hbGl6ZSgpO1xuICAgIC8vIHYgaXMgcGVycGVuZGljdWxhciB0byB0aGUgc2VnbWVudC5cbiAgICB2YXIgdiA9IFZlYzIuY3Jvc3MoMSwgcik7XG4gICAgdmFyIGFic192ID0gVmVjMi5hYnModik7XG4gICAgLy8gU2VwYXJhdGluZyBheGlzIGZvciBzZWdtZW50IChHaW5vLCBwODApLlxuICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxuICAgIHZhciBtYXhGcmFjdGlvbiA9IGlucHV0Lm1heEZyYWN0aW9uO1xuICAgIC8vIEJ1aWxkIGEgYm91bmRpbmcgYm94IGZvciB0aGUgc2VnbWVudC5cbiAgICB2YXIgc2VnbWVudEFBQkIgPSBuZXcgQUFCQigpO1xuICAgIHZhciB0ID0gVmVjMi5jb21iaW5lKDEgLSBtYXhGcmFjdGlvbiwgcDEsIG1heEZyYWN0aW9uLCBwMik7XG4gICAgc2VnbWVudEFBQkIuY29tYmluZVBvaW50cyhwMSwgdCk7XG4gICAgdmFyIHN0YWNrID0gc3RhY2tQb29sLmFsbG9jYXRlKCk7XG4gICAgdmFyIHN1YklucHV0ID0gaW5wdXRQb29sLmFsbG9jYXRlKCk7XG4gICAgc3RhY2sucHVzaCh0aGlzLm1fcm9vdCk7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFBQkIudGVzdE92ZXJsYXAobm9kZS5hYWJiLCBzZWdtZW50QUFCQikgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcGFyYXRpbmcgYXhpcyBmb3Igc2VnbWVudCAoR2lubywgcDgwKS5cbiAgICAgICAgLy8gfGRvdCh2LCBwMSAtIGMpfCA+IGRvdCh8dnwsIGgpXG4gICAgICAgIHZhciBjID0gbm9kZS5hYWJiLmdldENlbnRlcigpO1xuICAgICAgICB2YXIgaCA9IG5vZGUuYWFiYi5nZXRFeHRlbnRzKCk7XG4gICAgICAgIHZhciBzZXBhcmF0aW9uID0gTWF0aC5hYnMoVmVjMi5kb3QodiwgVmVjMi5zdWIocDEsIGMpKSkgLSBWZWMyLmRvdChhYnNfdiwgaCk7XG4gICAgICAgIGlmIChzZXBhcmF0aW9uID4gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgIHN1YklucHV0LnAxID0gVmVjMi5jbG9uZShpbnB1dC5wMSk7XG4gICAgICAgICAgICBzdWJJbnB1dC5wMiA9IFZlYzIuY2xvbmUoaW5wdXQucDIpO1xuICAgICAgICAgICAgc3ViSW5wdXQubWF4RnJhY3Rpb24gPSBtYXhGcmFjdGlvbjtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJheUNhc3RDYWxsYmFjayhzdWJJbnB1dCwgbm9kZS5pZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjbGllbnQgaGFzIHRlcm1pbmF0ZWQgdGhlIHJheSBjYXN0LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc2VnbWVudCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgICAgbWF4RnJhY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0ID0gVmVjMi5jb21iaW5lKDEgLSBtYXhGcmFjdGlvbiwgcDEsIG1heEZyYWN0aW9uLCBwMik7XG4gICAgICAgICAgICAgICAgc2VnbWVudEFBQkIuY29tYmluZVBvaW50cyhwMSwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUuY2hpbGQxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YWNrUG9vbC5yZWxlYXNlKHN0YWNrKTtcbiAgICBpbnB1dFBvb2wucmVsZWFzZShzdWJJbnB1dCk7XG59O1xuXG52YXIgaW5wdXRQb29sID0gbmV3IFBvb2woe1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHJlbGVhc2U6IGZ1bmN0aW9uKHN0YWNrKSB7fVxufSk7XG5cbnZhciBzdGFja1Bvb2wgPSBuZXcgUG9vbCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgcmVsZWFzZTogZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG59KTtcblxudmFyIGl0ZXJhdG9yUG9vbCA9IG5ldyBQb29sKHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKCk7XG4gICAgfSxcbiAgICByZWxlYXNlOiBmdW5jdGlvbihpdGVyYXRvcikge1xuICAgICAgICBpdGVyYXRvci5jbG9zZSgpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBJdGVyYXRvcigpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVvcmRlcjogZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHJvb3QpO1xuICAgICAgICAgICAgc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBzdGF0ZXMucHVzaCgwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlc1tpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXNbaV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlc1tpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXNbaV0gPSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChub2RlLmNoaWxkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVzW2ldID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlc1tpXSA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUuY2hpbGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGQyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbn0se1wiLi4vU2V0dGluZ3NcIjo3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9WZWMyXCI6MjMsXCIuLi91dGlsL1Bvb2xcIjo0OCxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuL0FBQkJcIjoxMX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lT2ZJbXBhY3Q7XG5cbm1vZHVsZS5leHBvcnRzLklucHV0ID0gVE9JSW5wdXQ7XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IFRPSU91dHB1dDtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgVGltZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9UaW1lclwiKTtcblxudmFyIHN0YXRzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdGF0c1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjM1wiKTtcblxudmFyIE1hdDIyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQyMlwiKTtcblxudmFyIE1hdDMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQzM1wiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi4vY29tbW9uL1N3ZWVwXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWxvY2l0eSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vUG9zaXRpb25cIik7XG5cbnZhciBEaXN0YW5jZSA9IHJlcXVpcmUoXCIuL0Rpc3RhbmNlXCIpO1xuXG52YXIgRGlzdGFuY2VJbnB1dCA9IERpc3RhbmNlLklucHV0O1xuXG52YXIgRGlzdGFuY2VPdXRwdXQgPSBEaXN0YW5jZS5PdXRwdXQ7XG5cbnZhciBEaXN0YW5jZVByb3h5ID0gRGlzdGFuY2UuUHJveHk7XG5cbnZhciBTaW1wbGV4Q2FjaGUgPSBEaXN0YW5jZS5DYWNoZTtcblxuLyoqXG4gKiBJbnB1dCBwYXJhbWV0ZXJzIGZvciBUaW1lT2ZJbXBhY3QuXG4gKiBcbiAqIEBwcm9wIHtEaXN0YW5jZVByb3h5fSBwcm94eUFcbiAqIEBwcm9wIHtEaXN0YW5jZVByb3h5fSBwcm94eUJcbiAqIEBwcm9wIHtTd2VlcH0gc3dlZXBBXG4gKiBAcHJvcCB7U3dlZXB9IHN3ZWVwQlxuICogQHByb3AgdE1heCBkZWZpbmVzIHN3ZWVwIGludGVydmFsIFswLCB0TWF4XVxuICovXG5mdW5jdGlvbiBUT0lJbnB1dCgpIHtcbiAgICB0aGlzLnByb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgdGhpcy5wcm94eUIgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xuICAgIHRoaXMuc3dlZXBBID0gbmV3IFN3ZWVwKCk7XG4gICAgdGhpcy5zd2VlcEIgPSBuZXcgU3dlZXAoKTtcbiAgICB0aGlzLnRNYXg7XG59XG5cbi8vIFRPSU91dHB1dCBTdGF0ZVxuVE9JT3V0cHV0LmVfdW5rbm93biA9IDA7XG5cblRPSU91dHB1dC5lX2ZhaWxlZCA9IDE7XG5cblRPSU91dHB1dC5lX292ZXJsYXBwZWQgPSAyO1xuXG5UT0lPdXRwdXQuZV90b3VjaGluZyA9IDM7XG5cblRPSU91dHB1dC5lX3NlcGFyYXRlZCA9IDQ7XG5cbi8qKlxuICogT3V0cHV0IHBhcmFtZXRlcnMgZm9yIFRpbWVPZkltcGFjdC5cbiAqIFxuICogQHByb3Agc3RhdGVcbiAqIEBwcm9wIHRcbiAqL1xuZnVuY3Rpb24gVE9JT3V0cHV0KCkge1xuICAgIHRoaXMuc3RhdGU7XG4gICAgdGhpcy50O1xufVxuXG5zdGF0cy50b2lUaW1lID0gMDtcblxuc3RhdHMudG9pTWF4VGltZSA9IDA7XG5cbnN0YXRzLnRvaUNhbGxzID0gMDtcblxuc3RhdHMudG9pSXRlcnMgPSAwO1xuXG5zdGF0cy50b2lNYXhJdGVycyA9IDA7XG5cbnN0YXRzLnRvaVJvb3RJdGVycyA9IDA7XG5cbnN0YXRzLnRvaU1heFJvb3RJdGVycyA9IDA7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgdXBwZXIgYm91bmQgb24gdGltZSBiZWZvcmUgdHdvIHNoYXBlcyBwZW5ldHJhdGUuIFRpbWUgaXNcbiAqIHJlcHJlc2VudGVkIGFzIGEgZnJhY3Rpb24gYmV0d2VlbiBbMCx0TWF4XS4gVGhpcyB1c2VzIGEgc3dlcHQgc2VwYXJhdGluZyBheGlzXG4gKiBhbmQgbWF5IG1pc3Mgc29tZSBpbnRlcm1lZGlhdGUsIG5vbi10dW5uZWxpbmcgY29sbGlzaW9uLiBJZiB5b3UgY2hhbmdlIHRoZVxuICogdGltZSBpbnRlcnZhbCwgeW91IHNob3VsZCBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4uXG4gKiBcbiAqIE5vdGU6IHVzZSBEaXN0YW5jZSB0byBjb21wdXRlIHRoZSBjb250YWN0IHBvaW50IGFuZCBub3JtYWwgYXQgdGhlIHRpbWUgb2ZcbiAqIGltcGFjdC5cbiAqIFxuICogQ0NEIHZpYSB0aGUgbG9jYWwgc2VwYXJhdGluZyBheGlzIG1ldGhvZC4gVGhpcyBzZWVrcyBwcm9ncmVzc2lvbiBieSBjb21wdXRpbmdcbiAqIHRoZSBsYXJnZXN0IHRpbWUgYXQgd2hpY2ggc2VwYXJhdGlvbiBpcyBtYWludGFpbmVkLlxuICovXG5mdW5jdGlvbiBUaW1lT2ZJbXBhY3Qob3V0cHV0LCBpbnB1dCkge1xuICAgIHZhciB0aW1lciA9IFRpbWVyLm5vdygpO1xuICAgICsrc3RhdHMudG9pQ2FsbHM7XG4gICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0LmVfdW5rbm93bjtcbiAgICBvdXRwdXQudCA9IGlucHV0LnRNYXg7XG4gICAgdmFyIHByb3h5QSA9IGlucHV0LnByb3h5QTtcbiAgICAvLyBEaXN0YW5jZVByb3h5XG4gICAgdmFyIHByb3h5QiA9IGlucHV0LnByb3h5QjtcbiAgICAvLyBEaXN0YW5jZVByb3h5XG4gICAgdmFyIHN3ZWVwQSA9IGlucHV0LnN3ZWVwQTtcbiAgICAvLyBTd2VlcFxuICAgIHZhciBzd2VlcEIgPSBpbnB1dC5zd2VlcEI7XG4gICAgLy8gU3dlZXBcbiAgICAvLyBMYXJnZSByb3RhdGlvbnMgY2FuIG1ha2UgdGhlIHJvb3QgZmluZGVyIGZhaWwsIHNvIHdlIG5vcm1hbGl6ZSB0aGVcbiAgICAvLyBzd2VlcCBhbmdsZXMuXG4gICAgc3dlZXBBLm5vcm1hbGl6ZSgpO1xuICAgIHN3ZWVwQi5ub3JtYWxpemUoKTtcbiAgICB2YXIgdE1heCA9IGlucHV0LnRNYXg7XG4gICAgdmFyIHRvdGFsUmFkaXVzID0gcHJveHlBLm1fcmFkaXVzICsgcHJveHlCLm1fcmFkaXVzO1xuICAgIHZhciB0YXJnZXQgPSBNYXRoLm1heChTZXR0aW5ncy5saW5lYXJTbG9wLCB0b3RhbFJhZGl1cyAtIDMgKiBTZXR0aW5ncy5saW5lYXJTbG9wKTtcbiAgICB2YXIgdG9sZXJhbmNlID0gLjI1ICogU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGFyZ2V0ID4gdG9sZXJhbmNlKTtcbiAgICB2YXIgdDEgPSAwO1xuICAgIHZhciBrX21heEl0ZXJhdGlvbnMgPSBTZXR0aW5ncy5tYXhUT0lJdGVyYXRpb25zO1xuICAgIHZhciBpdGVyID0gMDtcbiAgICAvLyBQcmVwYXJlIGlucHV0IGZvciBkaXN0YW5jZSBxdWVyeS5cbiAgICB2YXIgY2FjaGUgPSBuZXcgU2ltcGxleENhY2hlKCk7XG4gICAgdmFyIGRpc3RhbmNlSW5wdXQgPSBuZXcgRGlzdGFuY2VJbnB1dCgpO1xuICAgIGRpc3RhbmNlSW5wdXQucHJveHlBID0gaW5wdXQucHJveHlBO1xuICAgIGRpc3RhbmNlSW5wdXQucHJveHlCID0gaW5wdXQucHJveHlCO1xuICAgIGRpc3RhbmNlSW5wdXQudXNlUmFkaWkgPSBmYWxzZTtcbiAgICAvLyBUaGUgb3V0ZXIgbG9vcCBwcm9ncmVzc2l2ZWx5IGF0dGVtcHRzIHRvIGNvbXB1dGUgbmV3IHNlcGFyYXRpbmcgYXhlcy5cbiAgICAvLyBUaGlzIGxvb3AgdGVybWluYXRlcyB3aGVuIGFuIGF4aXMgaXMgcmVwZWF0ZWQgKG5vIHByb2dyZXNzIGlzIG1hZGUpLlxuICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIHhmQSA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICB2YXIgeGZCID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgICAgIHN3ZWVwQS5nZXRUcmFuc2Zvcm0oeGZBLCB0MSk7XG4gICAgICAgIHN3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCLCB0MSk7XG4gICAgICAgIC8vIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzaGFwZXMuIFdlIGNhbiBhbHNvIHVzZSB0aGUgcmVzdWx0c1xuICAgICAgICAvLyB0byBnZXQgYSBzZXBhcmF0aW5nIGF4aXMuXG4gICAgICAgIGRpc3RhbmNlSW5wdXQudHJhbnNmb3JtQSA9IHhmQTtcbiAgICAgICAgZGlzdGFuY2VJbnB1dC50cmFuc2Zvcm1CID0geGZCO1xuICAgICAgICB2YXIgZGlzdGFuY2VPdXRwdXQgPSBuZXcgRGlzdGFuY2VPdXRwdXQoKTtcbiAgICAgICAgRGlzdGFuY2UoZGlzdGFuY2VPdXRwdXQsIGNhY2hlLCBkaXN0YW5jZUlucHV0KTtcbiAgICAgICAgLy8gSWYgdGhlIHNoYXBlcyBhcmUgb3ZlcmxhcHBlZCwgd2UgZ2l2ZSB1cCBvbiBjb250aW51b3VzIGNvbGxpc2lvbi5cbiAgICAgICAgaWYgKGRpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDw9IDApIHtcbiAgICAgICAgICAgIC8vIEZhaWx1cmUhXG4gICAgICAgICAgICBvdXRwdXQuc3RhdGUgPSBUT0lPdXRwdXQuZV9vdmVybGFwcGVkO1xuICAgICAgICAgICAgb3V0cHV0LnQgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDwgdGFyZ2V0ICsgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBWaWN0b3J5IVxuICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0LmVfdG91Y2hpbmc7XG4gICAgICAgICAgICBvdXRwdXQudCA9IHQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VwYXJhdGluZyBheGlzLlxuICAgICAgICB2YXIgZmNuID0gbmV3IFNlcGFyYXRpb25GdW5jdGlvbigpO1xuICAgICAgICBmY24uaW5pdGlhbGl6ZShjYWNoZSwgcHJveHlBLCBzd2VlcEEsIHByb3h5Qiwgc3dlZXBCLCB0MSk7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgLy8gRHVtcCB0aGUgY3VydmUgc2VlbiBieSB0aGUgcm9vdCBmaW5kZXJcbiAgICAgICAgICAgIHZhciBOID0gMTAwO1xuICAgICAgICAgICAgdmFyIGR4ID0gMSAvIE47XG4gICAgICAgICAgICB2YXIgeHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFsgTiArIDEgXTtcbiAgICAgICAgICAgIHZhciBmcyA9IFtdO1xuICAgICAgICAgICAgLy8gWyBOICsgMSBdO1xuICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3dlZXBBLmdldFRyYW5zZm9ybSh4ZkEsIHgpO1xuICAgICAgICAgICAgICAgIHN3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCLCB4KTtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZjbi5ldmFsdWF0ZSh4ZkEsIHhmQikgLSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgcHJpbnRmKFwiJWcgJWdcXG5cIiwgeCwgZik7XG4gICAgICAgICAgICAgICAgeHNbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGZzW2ldID0gZjtcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIFRPSSBvbiB0aGUgc2VwYXJhdGluZyBheGlzLiBXZSBkbyB0aGlzIGJ5IHN1Y2Nlc3NpdmVseVxuICAgICAgICAvLyByZXNvbHZpbmcgdGhlIGRlZXBlc3QgcG9pbnQuIFRoaXMgbG9vcCBpcyBib3VuZGVkIGJ5IHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gdmVydGljZXMuXG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciB0MiA9IHRNYXg7XG4gICAgICAgIHZhciBwdXNoQmFja0l0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBkZWVwZXN0IHBvaW50IGF0IHQyLiBTdG9yZSB0aGUgd2l0bmVzcyBwb2ludCBpbmRpY2VzLlxuICAgICAgICAgICAgdmFyIHMyID0gZmNuLmZpbmRNaW5TZXBhcmF0aW9uKHQyKTtcbiAgICAgICAgICAgIHZhciBpbmRleEEgPSBmY24uaW5kZXhBO1xuICAgICAgICAgICAgdmFyIGluZGV4QiA9IGZjbi5pbmRleEI7XG4gICAgICAgICAgICAvLyBJcyB0aGUgZmluYWwgY29uZmlndXJhdGlvbiBzZXBhcmF0ZWQ/XG4gICAgICAgICAgICBpZiAoczIgPiB0YXJnZXQgKyB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBWaWN0b3J5IVxuICAgICAgICAgICAgICAgIG91dHB1dC5zdGF0ZSA9IFRPSU91dHB1dC5lX3NlcGFyYXRlZDtcbiAgICAgICAgICAgICAgICBvdXRwdXQudCA9IHRNYXg7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYXMgdGhlIHNlcGFyYXRpb24gcmVhY2hlZCB0b2xlcmFuY2U/XG4gICAgICAgICAgICBpZiAoczIgPiB0YXJnZXQgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBzd2VlcHNcbiAgICAgICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5pdGlhbCBzZXBhcmF0aW9uIG9mIHRoZSB3aXRuZXNzIHBvaW50cy5cbiAgICAgICAgICAgIHZhciBzMSA9IGZjbi5ldmFsdWF0ZSh0MSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhBID0gZmNuLmluZGV4QTtcbiAgICAgICAgICAgIHZhciBpbmRleEIgPSBmY24uaW5kZXhCO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGluaXRpYWwgb3ZlcmxhcC4gVGhpcyBtaWdodCBoYXBwZW4gaWYgdGhlIHJvb3QgZmluZGVyXG4gICAgICAgICAgICAvLyBydW5zIG91dCBvZiBpdGVyYXRpb25zLlxuICAgICAgICAgICAgaWYgKHMxIDwgdGFyZ2V0IC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0LmVfZmFpbGVkO1xuICAgICAgICAgICAgICAgIG91dHB1dC50ID0gdDE7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdG91Y2hpbmdcbiAgICAgICAgICAgIGlmIChzMSA8PSB0YXJnZXQgKyB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBWaWN0b3J5ISB0MSBzaG91bGQgaG9sZCB0aGUgVE9JIChjb3VsZCBiZSAwLjApLlxuICAgICAgICAgICAgICAgIG91dHB1dC5zdGF0ZSA9IFRPSU91dHB1dC5lX3RvdWNoaW5nO1xuICAgICAgICAgICAgICAgIG91dHB1dC50ID0gdDE7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIDFEIHJvb3Qgb2Y6IGYoeCkgLSB0YXJnZXQgPSAwXG4gICAgICAgICAgICB2YXIgcm9vdEl0ZXJDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgYTEgPSB0MSwgYTIgPSB0MjtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBtaXggb2YgdGhlIHNlY2FudCBydWxlIGFuZCBiaXNlY3Rpb24uXG4gICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RJdGVyQ291bnQgJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY2FudCBydWxlIHRvIGltcHJvdmUgY29udmVyZ2VuY2UuXG4gICAgICAgICAgICAgICAgICAgIHQgPSBhMSArICh0YXJnZXQgLSBzMSkgKiAoYTIgLSBhMSkgLyAoczIgLSBzMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmlzZWN0aW9uIHRvIGd1YXJhbnRlZSBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAgICAgdCA9IC41ICogKGExICsgYTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK3Jvb3RJdGVyQ291bnQ7XG4gICAgICAgICAgICAgICAgKytzdGF0cy50b2lSb290SXRlcnM7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBmY24uZXZhbHVhdGUodCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QSA9IGZjbi5pbmRleEE7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QiA9IGZjbi5pbmRleEI7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHMgLSB0YXJnZXQpIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHQyIGhvbGRzIGEgdGVudGF0aXZlIHZhbHVlIGZvciB0MVxuICAgICAgICAgICAgICAgICAgICB0MiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgY29udGludWUgdG8gYnJhY2tldCB0aGUgcm9vdC5cbiAgICAgICAgICAgICAgICBpZiAocyA+IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBhMSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhMiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIHMyID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RJdGVyQ291bnQgPT0gNTApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdHMudG9pTWF4Um9vdEl0ZXJzID0gTWF0aC5tYXgoc3RhdHMudG9pTWF4Um9vdEl0ZXJzLCByb290SXRlckNvdW50KTtcbiAgICAgICAgICAgICsrcHVzaEJhY2tJdGVyO1xuICAgICAgICAgICAgaWYgKHB1c2hCYWNrSXRlciA9PSBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICArK2l0ZXI7XG4gICAgICAgICsrc3RhdHMudG9pSXRlcnM7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlciA9PSBrX21heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFJvb3QgZmluZGVyIGdvdCBzdHVjay4gU2VtaS12aWN0b3J5LlxuICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gVE9JT3V0cHV0LmVfZmFpbGVkO1xuICAgICAgICAgICAgb3V0cHV0LnQgPSB0MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRzLnRvaU1heEl0ZXJzID0gTWF0aC5tYXgoc3RhdHMudG9pTWF4SXRlcnMsIGl0ZXIpO1xuICAgIHZhciB0aW1lID0gVGltZXIuZGlmZih0aW1lcik7XG4gICAgc3RhdHMudG9pTWF4VGltZSA9IE1hdGgubWF4KHN0YXRzLnRvaU1heFRpbWUsIHRpbWUpO1xuICAgIHN0YXRzLnRvaVRpbWUgKz0gdGltZTtcbn1cblxuLy8gU2VwYXJhdGlvbkZ1bmN0aW9uIFR5cGVcbnZhciBlX3BvaW50cyA9IDE7XG5cbnZhciBlX2ZhY2VBID0gMjtcblxudmFyIGVfZmFjZUIgPSAzO1xuXG5mdW5jdGlvbiBTZXBhcmF0aW9uRnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tX3Byb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgdGhpcy5tX3Byb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgdGhpcy5tX3N3ZWVwQTtcbiAgICAvLyBTd2VlcFxuICAgIHRoaXMubV9zd2VlcEI7XG4gICAgLy8gU3dlZXBcbiAgICB0aGlzLm1fdHlwZTtcbiAgICB0aGlzLm1fbG9jYWxQb2ludCA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9heGlzID0gVmVjMi56ZXJvKCk7XG59XG5cbi8vIFRPRE9fRVJJTiBtaWdodCBub3QgbmVlZCB0byByZXR1cm4gdGhlIHNlcGFyYXRpb25cbi8qKlxuICogQHBhcmFtIHtTaW1wbGV4Q2FjaGV9IGNhY2hlXG4gKiBAcGFyYW0ge0Rpc3RhbmNlUHJveHl9IHByb3h5QVxuICogQHBhcmFtIHtTd2VlcH0gc3dlZXBBXG4gKiBAcGFyYW0ge0Rpc3RhbmNlUHJveHl9IHByb3h5QlxuICogQHBhcmFtIHtTd2VlcH0gc3dlZXBCXG4gKiBAcGFyYW0ge2Zsb2F0fSB0MVxuICovXG5TZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihjYWNoZSwgcHJveHlBLCBzd2VlcEEsIHByb3h5Qiwgc3dlZXBCLCB0MSkge1xuICAgIHRoaXMubV9wcm94eUEgPSBwcm94eUE7XG4gICAgdGhpcy5tX3Byb3h5QiA9IHByb3h5QjtcbiAgICB2YXIgY291bnQgPSBjYWNoZS5jb3VudDtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoMCA8IGNvdW50ICYmIGNvdW50IDwgMyk7XG4gICAgdGhpcy5tX3N3ZWVwQSA9IHN3ZWVwQTtcbiAgICB0aGlzLm1fc3dlZXBCID0gc3dlZXBCO1xuICAgIHZhciB4ZkEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICB2YXIgeGZCID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgdGhpcy5tX3N3ZWVwQS5nZXRUcmFuc2Zvcm0oeGZBLCB0MSk7XG4gICAgdGhpcy5tX3N3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCLCB0MSk7XG4gICAgaWYgKGNvdW50ID09IDEpIHtcbiAgICAgICAgdGhpcy5tX3R5cGUgPSBlX3BvaW50cztcbiAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnRCID0gdGhpcy5tX3Byb3h5Qi5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzBdKTtcbiAgICAgICAgdmFyIHBvaW50QSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgbG9jYWxQb2ludEEpO1xuICAgICAgICB2YXIgcG9pbnRCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCBsb2NhbFBvaW50Qik7XG4gICAgICAgIHRoaXMubV9heGlzLnNldENvbWJpbmUoMSwgcG9pbnRCLCAtMSwgcG9pbnRBKTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLm1fYXhpcy5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfSBlbHNlIGlmIChjYWNoZS5pbmRleEFbMF0gPT0gY2FjaGUuaW5kZXhBWzFdKSB7XG4gICAgICAgIC8vIFR3byBwb2ludHMgb24gQiBhbmQgb25lIG9uIEEuXG4gICAgICAgIHRoaXMubV90eXBlID0gZV9mYWNlQjtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnRCMSA9IHByb3h5Qi5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzBdKTtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnRCMiA9IHByb3h5Qi5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzFdKTtcbiAgICAgICAgdGhpcy5tX2F4aXMgPSBWZWMyLmNyb3NzKFZlYzIuc3ViKGxvY2FsUG9pbnRCMiwgbG9jYWxQb2ludEIxKSwgMSk7XG4gICAgICAgIHRoaXMubV9heGlzLm5vcm1hbGl6ZSgpO1xuICAgICAgICB2YXIgbm9ybWFsID0gUm90Lm11bFZlYzIoeGZCLnEsIHRoaXMubV9heGlzKTtcbiAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQgPSBWZWMyLm1pZChsb2NhbFBvaW50QjEsIGxvY2FsUG9pbnRCMik7XG4gICAgICAgIHZhciBwb2ludEIgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gcHJveHlBLmdldFZlcnRleChjYWNoZS5pbmRleEFbMF0pO1xuICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCBsb2NhbFBvaW50QSk7XG4gICAgICAgIHZhciBzID0gVmVjMi5kb3QocG9pbnRBLCBub3JtYWwpIC0gVmVjMi5kb3QocG9pbnRCLCBub3JtYWwpO1xuICAgICAgICBpZiAocyA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubV9heGlzID0gVmVjMi5uZWcodGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgcyA9IC1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR3byBwb2ludHMgb24gQSBhbmQgb25lIG9yIHR3byBwb2ludHMgb24gQi5cbiAgICAgICAgdGhpcy5tX3R5cGUgPSBlX2ZhY2VBO1xuICAgICAgICB2YXIgbG9jYWxQb2ludEExID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnRBMiA9IHRoaXMubV9wcm94eUEuZ2V0VmVydGV4KGNhY2hlLmluZGV4QVsxXSk7XG4gICAgICAgIHRoaXMubV9heGlzID0gVmVjMi5jcm9zcyhWZWMyLnN1Yihsb2NhbFBvaW50QTIsIGxvY2FsUG9pbnRBMSksIDEpO1xuICAgICAgICB0aGlzLm1fYXhpcy5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIG5vcm1hbCA9IFJvdC5tdWxWZWMyKHhmQS5xLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gVmVjMi5taWQobG9jYWxQb2ludEExLCBsb2NhbFBvaW50QTIpO1xuICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCB0aGlzLm1fbG9jYWxQb2ludCk7XG4gICAgICAgIHZhciBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuZ2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XG4gICAgICAgIHZhciBwb2ludEIgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkIsIGxvY2FsUG9pbnRCKTtcbiAgICAgICAgdmFyIHMgPSBWZWMyLmRvdChwb2ludEIsIG5vcm1hbCkgLSBWZWMyLmRvdChwb2ludEEsIG5vcm1hbCk7XG4gICAgICAgIGlmIChzIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5tX2F4aXMgPSBWZWMyLm5lZyh0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICBzID0gLXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufTtcblxuU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24oZmluZCwgdCkge1xuICAgIC8vIEl0IHdhcyBmaW5kTWluU2VwYXJhdGlvbiBhbmQgZXZhbHVhdGVcbiAgICB2YXIgeGZBID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgdmFyIHhmQiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgIHRoaXMubV9zd2VlcEEuZ2V0VHJhbnNmb3JtKHhmQSwgdCk7XG4gICAgdGhpcy5tX3N3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCLCB0KTtcbiAgICBzd2l0Y2ggKHRoaXMubV90eXBlKSB7XG4gICAgICBjYXNlIGVfcG9pbnRzOlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzQSA9IFJvdC5tdWxUVmVjMih4ZkEucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgIHZhciBheGlzQiA9IFJvdC5tdWxUVmVjMih4ZkIucSwgVmVjMi5uZWcodGhpcy5tX2F4aXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QSA9IHRoaXMubV9wcm94eUEuZ2V0U3VwcG9ydChheGlzQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEIgPSB0aGlzLm1fcHJveHlCLmdldFN1cHBvcnQoYXhpc0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgodGhpcy5pbmRleEEpO1xuICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRCID0gdGhpcy5tX3Byb3h5Qi5nZXRWZXJ0ZXgodGhpcy5pbmRleEIpO1xuICAgICAgICAgICAgdmFyIHBvaW50QSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgbG9jYWxQb2ludEEpO1xuICAgICAgICAgICAgdmFyIHBvaW50QiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgbG9jYWxQb2ludEIpO1xuICAgICAgICAgICAgdmFyIHNlcCA9IFZlYzIuZG90KHBvaW50QiwgdGhpcy5tX2F4aXMpIC0gVmVjMi5kb3QocG9pbnRBLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICByZXR1cm4gc2VwO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgZV9mYWNlQTpcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFJvdC5tdWxWZWMyKHhmQS5xLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICB2YXIgcG9pbnRBID0gVHJhbnNmb3JtLm11bFZlYzIoeGZBLCB0aGlzLm1fbG9jYWxQb2ludCk7XG4gICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzQiA9IFJvdC5tdWxUVmVjMih4ZkIucSwgVmVjMi5uZWcobm9ybWFsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEEgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QiA9IHRoaXMubV9wcm94eUIuZ2V0U3VwcG9ydChheGlzQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLmdldFZlcnRleCh0aGlzLmluZGV4Qik7XG4gICAgICAgICAgICB2YXIgcG9pbnRCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCBsb2NhbFBvaW50Qik7XG4gICAgICAgICAgICB2YXIgc2VwID0gVmVjMi5kb3QocG9pbnRCLCBub3JtYWwpIC0gVmVjMi5kb3QocG9pbnRBLCBub3JtYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGVfZmFjZUI6XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBSb3QubXVsVmVjMih4ZkIucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgdmFyIHBvaW50QiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQiwgdGhpcy5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGZpbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc0EgPSBSb3QubXVsVFZlYzIoeGZBLnEsIFZlYzIubmVnKG5vcm1hbCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEEgPSB0aGlzLm1fcHJveHlBLmdldFN1cHBvcnQoYXhpc0EpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgodGhpcy5pbmRleEEpO1xuICAgICAgICAgICAgdmFyIHBvaW50QSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmQSwgbG9jYWxQb2ludEEpO1xuICAgICAgICAgICAgdmFyIHNlcCA9IFZlYzIuZG90KHBvaW50QSwgbm9ybWFsKSAtIFZlYzIuZG90KHBvaW50Qiwgbm9ybWFsKTtcbiAgICAgICAgICAgIHJldHVybiBzZXA7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgaWYgKGZpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gLTE7XG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cblNlcGFyYXRpb25GdW5jdGlvbi5wcm90b3R5cGUuZmluZE1pblNlcGFyYXRpb24gPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZSh0cnVlLCB0KTtcbn07XG5cblNlcGFyYXRpb25GdW5jdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShmYWxzZSwgdCk7XG59O1xuXG5cbn0se1wiLi4vU2V0dGluZ3NcIjo3LFwiLi4vY29tbW9uL01hdDIyXCI6MTYsXCIuLi9jb21tb24vTWF0MzNcIjoxNyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUG9zaXRpb25cIjoxOSxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9Td2VlcFwiOjIxLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL2NvbW1vbi9WZWMzXCI6MjQsXCIuLi9jb21tb24vVmVsb2NpdHlcIjoyNSxcIi4uL2NvbW1vbi9zdGF0c1wiOjI2LFwiLi4vdXRpbC9UaW1lclwiOjQ5LFwiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4vRGlzdGFuY2VcIjoxM31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXQyMjtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi9NYXRoXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuL1ZlYzJcIik7XG5cbi8qKlxuICogQSAyLWJ5LTIgbWF0cml4LiBTdG9yZWQgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXQyMihhLCBiLCBjLCBkKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5leCA9IFZlYzIuY2xvbmUoYSk7XG4gICAgICAgIHRoaXMuZXkgPSBWZWMyLmNsb25lKGIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5leCA9IFZlYzIubmVvKGEsIGMpO1xuICAgICAgICB0aGlzLmV5ID0gVmVjMi5uZW8oYiwgZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leCA9IFZlYzIuemVybygpO1xuICAgICAgICB0aGlzLmV5ID0gVmVjMi56ZXJvKCk7XG4gICAgfVxufVxuXG5NYXQyMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG59O1xuXG5NYXQyMi5pc1ZhbGlkID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBvICYmIFZlYzIuaXNWYWxpZChvLmV4KSAmJiBWZWMyLmlzVmFsaWQoby5leSk7XG59O1xuXG5NYXQyMi5hc3NlcnQgPSBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCFfQVNTRVJUKSByZXR1cm47XG4gICAgaWYgKCFNYXQyMi5pc1ZhbGlkKG8pKSB7XG4gICAgICAgIF9ERUJVRyAmJiBjb21tb24uZGVidWcobyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTWF0MjIhXCIpO1xuICAgIH1cbn07XG5cbk1hdDIyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBjID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuZXguc2V0KGEsIGMpO1xuICAgICAgICB0aGlzLmV5LnNldChiLCBkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMuZXguc2V0KGEpO1xuICAgICAgICB0aGlzLmV5LnNldChiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0MjIuYXNzZXJ0KGEpO1xuICAgICAgICB0aGlzLmV4LnNldChhLmV4KTtcbiAgICAgICAgdGhpcy5leS5zZXQoYS5leSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZhbHNlKTtcbiAgICB9XG59O1xuXG5NYXQyMi5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4LnggPSAxO1xuICAgIHRoaXMuZXkueCA9IDA7XG4gICAgdGhpcy5leC55ID0gMDtcbiAgICB0aGlzLmV5LnkgPSAxO1xufTtcblxuTWF0MjIucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4LnggPSAwO1xuICAgIHRoaXMuZXkueCA9IDA7XG4gICAgdGhpcy5leC55ID0gMDtcbiAgICB0aGlzLmV5LnkgPSAwO1xufTtcblxuTWF0MjIucHJvdG90eXBlLmdldEludmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMuZXgueDtcbiAgICB2YXIgYiA9IHRoaXMuZXkueDtcbiAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICB2YXIgZCA9IHRoaXMuZXkueTtcbiAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICBpZiAoZGV0ICE9IDApIHtcbiAgICAgICAgZGV0ID0gMSAvIGRldDtcbiAgICB9XG4gICAgdmFyIGlteCA9IG5ldyBNYXQyMigpO1xuICAgIGlteC5leC54ID0gZGV0ICogZDtcbiAgICBpbXguZXkueCA9IC1kZXQgKiBiO1xuICAgIGlteC5leC55ID0gLWRldCAqIGM7XG4gICAgaW14LmV5LnkgPSBkZXQgKiBhO1xuICAgIHJldHVybiBpbXg7XG59O1xuXG4vKipcbiAqIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhblxuICogY29tcHV0aW5nIHRoZSBpbnZlcnNlIGluIG9uZS1zaG90IGNhc2VzLlxuICovXG5NYXQyMi5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbih2KSB7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICB2YXIgYSA9IHRoaXMuZXgueDtcbiAgICB2YXIgYiA9IHRoaXMuZXkueDtcbiAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICB2YXIgZCA9IHRoaXMuZXkueTtcbiAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICBpZiAoZGV0ICE9IDApIHtcbiAgICAgICAgZGV0ID0gMSAvIGRldDtcbiAgICB9XG4gICAgdmFyIHcgPSBWZWMyLnplcm8oKTtcbiAgICB3LnggPSBkZXQgKiAoZCAqIHYueCAtIGIgKiB2LnkpO1xuICAgIHcueSA9IGRldCAqIChhICogdi55IC0gYyAqIHYueCk7XG4gICAgcmV0dXJuIHc7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgbWF0cml4IHRpbWVzIGEgdmVjdG9yLiBJZiBhIHJvdGF0aW9uIG1hdHJpeCBpcyBwcm92aWRlZCwgdGhlbiB0aGlzXG4gKiB0cmFuc2Zvcm1zIHRoZSB2ZWN0b3IgZnJvbSBvbmUgZnJhbWUgdG8gYW5vdGhlci5cbiAqL1xuTWF0MjIubXVsID0gZnVuY3Rpb24obXgsIHYpIHtcbiAgICBpZiAodiAmJiBcInhcIiBpbiB2ICYmIFwieVwiIGluIHYpIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICAgICAgdmFyIHggPSBteC5leC54ICogdi54ICsgbXguZXkueCAqIHYueTtcbiAgICAgICAgdmFyIHkgPSBteC5leC55ICogdi54ICsgbXguZXkueSAqIHYueTtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgIH0gZWxzZSBpZiAodiAmJiBcImV4XCIgaW4gdiAmJiBcImV5XCIgaW4gdikge1xuICAgICAgICAvLyBNYXQyMlxuICAgICAgICBfQVNTRVJUICYmIE1hdDIyLmFzc2VydCh2KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXQyMihWZWMyLm11bChteCwgdi5leCksIFZlYzIubXVsKG14LCB2LmV5KSk7XG4gICAgfVxuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG59O1xuXG5NYXQyMi5tdWxWZWMyID0gZnVuY3Rpb24obXgsIHYpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIHZhciB4ID0gbXguZXgueCAqIHYueCArIG14LmV5LnggKiB2Lnk7XG4gICAgdmFyIHkgPSBteC5leC55ICogdi54ICsgbXguZXkueSAqIHYueTtcbiAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG59O1xuXG5NYXQyMi5tdWxWZWMyXyA9IGZ1bmN0aW9uKG14LCB2LCBfKSB7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICB2YXIgeCA9IG14LmV4LnggKiB2LnggKyBteC5leS54ICogdi55O1xuICAgIHZhciB5ID0gbXguZXgueSAqIHYueCArIG14LmV5LnkgKiB2Lnk7XG4gICAgcmV0dXJuIF8uc2V0KHgsIHkpO1xufTtcblxuTWF0MjIubXVsTWF0MjIgPSBmdW5jdGlvbihteCwgdikge1xuICAgIF9BU1NFUlQgJiYgTWF0MjIuYXNzZXJ0KHYpO1xuICAgIHJldHVybiBuZXcgTWF0MjIoVmVjMi5tdWwobXgsIHYuZXgpLCBWZWMyLm11bChteCwgdi5leSkpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgbWF0cml4IHRyYW5zcG9zZSB0aW1lcyBhIHZlY3Rvci4gSWYgYSByb3RhdGlvbiBtYXRyaXggaXMgcHJvdmlkZWQsXG4gKiB0aGVuIHRoaXMgdHJhbnNmb3JtcyB0aGUgdmVjdG9yIGZyb20gb25lIGZyYW1lIHRvIGFub3RoZXIgKGludmVyc2VcbiAqIHRyYW5zZm9ybSkuXG4gKi9cbk1hdDIyLm11bFQgPSBmdW5jdGlvbihteCwgdikge1xuICAgIGlmICh2ICYmIFwieFwiIGluIHYgJiYgXCJ5XCIgaW4gdikge1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbyhWZWMyLmRvdCh2LCBteC5leCksIFZlYzIuZG90KHYsIG14LmV5KSk7XG4gICAgfSBlbHNlIGlmICh2ICYmIFwiZXhcIiBpbiB2ICYmIFwiZXlcIiBpbiB2KSB7XG4gICAgICAgIC8vIE1hdDIyXG4gICAgICAgIF9BU1NFUlQgJiYgTWF0MjIuYXNzZXJ0KHYpO1xuICAgICAgICB2YXIgYzEgPSBWZWMyLm5lbyhWZWMyLmRvdChteC5leCwgdi5leCksIFZlYzIuZG90KG14LmV5LCB2LmV4KSk7XG4gICAgICAgIHZhciBjMiA9IFZlYzIubmVvKFZlYzIuZG90KG14LmV4LCB2LmV5KSwgVmVjMi5kb3QobXguZXksIHYuZXkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXQyMihjMSwgYzIpO1xuICAgIH1cbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZmFsc2UpO1xufTtcblxuTWF0MjIubXVsVFZlYzIgPSBmdW5jdGlvbihteCwgdikge1xuICAgIF9BU1NFUlQgJiYgTWF0MjIuYXNzZXJ0KG14KTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIHJldHVybiBWZWMyLm5lbyhWZWMyLmRvdCh2LCBteC5leCksIFZlYzIuZG90KHYsIG14LmV5KSk7XG59O1xuXG5NYXQyMi5tdWxUTWF0MjIgPSBmdW5jdGlvbihteCwgdikge1xuICAgIF9BU1NFUlQgJiYgTWF0MjIuYXNzZXJ0KG14KTtcbiAgICBfQVNTRVJUICYmIE1hdDIyLmFzc2VydCh2KTtcbiAgICB2YXIgYzEgPSBWZWMyLm5lbyhWZWMyLmRvdChteC5leCwgdi5leCksIFZlYzIuZG90KG14LmV5LCB2LmV4KSk7XG4gICAgdmFyIGMyID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXkpLCBWZWMyLmRvdChteC5leSwgdi5leSkpO1xuICAgIHJldHVybiBuZXcgTWF0MjIoYzEsIGMyKTtcbn07XG5cbk1hdDIyLmFicyA9IGZ1bmN0aW9uKG14KSB7XG4gICAgX0FTU0VSVCAmJiBNYXQyMi5hc3NlcnQobXgpO1xuICAgIHJldHVybiBuZXcgTWF0MjIoVmVjMi5hYnMobXguZXgpLCBWZWMyLmFicyhteC5leSkpO1xufTtcblxuTWF0MjIuYWRkID0gZnVuY3Rpb24obXgxLCBteDIpIHtcbiAgICBfQVNTRVJUICYmIE1hdDIyLmFzc2VydChteDEpO1xuICAgIF9BU1NFUlQgJiYgTWF0MjIuYXNzZXJ0KG14Mik7XG4gICAgcmV0dXJuIG5ldyBNYXQyMihWZWMyLmFkZChteDEuZXggKyBteDIuZXgpLCBWZWMyLmFkZChteDEuZXkgKyBteDIuZXkpKTtcbn07XG5cblxufSx7XCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9NYXRoXCI6MTgsXCIuL1ZlYzJcIjoyM31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXQzMztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi9NYXRoXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuL1ZlYzJcIik7XG5cbnZhciBWZWMzID0gcmVxdWlyZShcIi4vVmVjM1wiKTtcblxuLyoqXG4gKiBBIDMtYnktMyBtYXRyaXguIFN0b3JlZCBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hdDMzKGEsIGIsIGMpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgYSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmV4ID0gVmVjMy5jbG9uZShhKTtcbiAgICAgICAgdGhpcy5leSA9IFZlYzMuY2xvbmUoYik7XG4gICAgICAgIHRoaXMuZXogPSBWZWMzLmNsb25lKGMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXggPSBWZWMzKCk7XG4gICAgICAgIHRoaXMuZXkgPSBWZWMzKCk7XG4gICAgICAgIHRoaXMuZXogPSBWZWMzKCk7XG4gICAgfVxufVxuXG5NYXQzMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG59O1xuXG5NYXQzMy5pc1ZhbGlkID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBvICYmIFZlYzMuaXNWYWxpZChvLmV4KSAmJiBWZWMzLmlzVmFsaWQoby5leSkgJiYgVmVjMy5pc1ZhbGlkKG8uZXopO1xufTtcblxuTWF0MzMuYXNzZXJ0ID0gZnVuY3Rpb24obykge1xuICAgIGlmICghX0FTU0VSVCkgcmV0dXJuO1xuICAgIGlmICghTWF0MzMuaXNWYWxpZChvKSkge1xuICAgICAgICBfREVCVUcgJiYgY29tbW9uLmRlYnVnKG8pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE1hdDMzIVwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGlzIG1hdHJpeCB0byBhbGwgemVyb3MuXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5leC5zZXRaZXJvKCk7XG4gICAgdGhpcy5leS5zZXRaZXJvKCk7XG4gICAgdGhpcy5lei5zZXRaZXJvKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhblxuICogY29tcHV0aW5nIHRoZSBpbnZlcnNlIGluIG9uZS1zaG90IGNhc2VzLlxuICogXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEByZXR1cm5zIHtWZWMzfVxuICovXG5NYXQzMy5wcm90b3R5cGUuc29sdmUzMyA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgZGV0ID0gVmVjMy5kb3QodGhpcy5leCwgVmVjMy5jcm9zcyh0aGlzLmV5LCB0aGlzLmV6KSk7XG4gICAgaWYgKGRldCAhPSAwKSB7XG4gICAgICAgIGRldCA9IDEgLyBkZXQ7XG4gICAgfVxuICAgIHZhciByID0gbmV3IFZlYzMoKTtcbiAgICByLnggPSBkZXQgKiBWZWMzLmRvdCh2LCBWZWMzLmNyb3NzKHRoaXMuZXksIHRoaXMuZXopKTtcbiAgICByLnkgPSBkZXQgKiBWZWMzLmRvdCh0aGlzLmV4LCBWZWMzLmNyb3NzKHYsIHRoaXMuZXopKTtcbiAgICByLnogPSBkZXQgKiBWZWMzLmRvdCh0aGlzLmV4LCBWZWMzLmNyb3NzKHRoaXMuZXksIHYpKTtcbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogU29sdmUgQSAqIHggPSBiLCB3aGVyZSBiIGlzIGEgY29sdW1uIHZlY3Rvci4gVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuXG4gKiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuIFNvbHZlIG9ubHkgdGhlIHVwcGVyIDItYnktMiBtYXRyaXhcbiAqIGVxdWF0aW9uLlxuICogXG4gKiBAcGFyYW0ge1ZlYzJ9IHZcbiAqIFxuICogQHJldHVybnMge1ZlYzJ9XG4gKi9cbk1hdDMzLnByb3RvdHlwZS5zb2x2ZTIyID0gZnVuY3Rpb24odikge1xuICAgIHZhciBhMTEgPSB0aGlzLmV4Lng7XG4gICAgdmFyIGExMiA9IHRoaXMuZXkueDtcbiAgICB2YXIgYTIxID0gdGhpcy5leC55O1xuICAgIHZhciBhMjIgPSB0aGlzLmV5Lnk7XG4gICAgdmFyIGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgICBpZiAoZGV0ICE9IDApIHtcbiAgICAgICAgZGV0ID0gMSAvIGRldDtcbiAgICB9XG4gICAgdmFyIHIgPSBWZWMyLnplcm8oKTtcbiAgICByLnggPSBkZXQgKiAoYTIyICogdi54IC0gYTEyICogdi55KTtcbiAgICByLnkgPSBkZXQgKiAoYTExICogdi55IC0gYTIxICogdi54KTtcbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IGFzIGEgMi1ieS0yLiBSZXR1cm5zIHRoZSB6ZXJvIG1hdHJpeCBpZlxuICogc2luZ3VsYXIuXG4gKiBcbiAqIEBwYXJhbSB7TWF0MzN9IE1cbiAqL1xuTWF0MzMucHJvdG90eXBlLmdldEludmVyc2UyMiA9IGZ1bmN0aW9uKE0pIHtcbiAgICB2YXIgYSA9IHRoaXMuZXgueDtcbiAgICB2YXIgYiA9IHRoaXMuZXkueDtcbiAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICB2YXIgZCA9IHRoaXMuZXkueTtcbiAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICBpZiAoZGV0ICE9IDApIHtcbiAgICAgICAgZGV0ID0gMSAvIGRldDtcbiAgICB9XG4gICAgTS5leC54ID0gZGV0ICogZDtcbiAgICBNLmV5LnggPSAtZGV0ICogYjtcbiAgICBNLmV4LnogPSAwO1xuICAgIE0uZXgueSA9IC1kZXQgKiBjO1xuICAgIE0uZXkueSA9IGRldCAqIGE7XG4gICAgTS5leS56ID0gMDtcbiAgICBNLmV6LnggPSAwO1xuICAgIE0uZXoueSA9IDA7XG4gICAgTS5lei56ID0gMDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzeW1tZXRyaWMgaW52ZXJzZSBvZiB0aGlzIG1hdHJpeCBhcyBhIDMtYnktMy4gUmV0dXJucyB0aGUgemVybyBtYXRyaXhcbiAqIGlmIHNpbmd1bGFyLlxuICogXG4gKiBAcGFyYW0ge01hdDMzfSBNXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5nZXRTeW1JbnZlcnNlMzMgPSBmdW5jdGlvbihNKSB7XG4gICAgdmFyIGRldCA9IFZlYzMuZG90KHRoaXMuZXgsIFZlYzMuY3Jvc3ModGhpcy5leSwgdGhpcy5leikpO1xuICAgIGlmIChkZXQgIT0gMCkge1xuICAgICAgICBkZXQgPSAxIC8gZGV0O1xuICAgIH1cbiAgICB2YXIgYTExID0gdGhpcy5leC54O1xuICAgIHZhciBhMTIgPSB0aGlzLmV5Lng7XG4gICAgdmFyIGExMyA9IHRoaXMuZXoueDtcbiAgICB2YXIgYTIyID0gdGhpcy5leS55O1xuICAgIHZhciBhMjMgPSB0aGlzLmV6Lnk7XG4gICAgdmFyIGEzMyA9IHRoaXMuZXouejtcbiAgICBNLmV4LnggPSBkZXQgKiAoYTIyICogYTMzIC0gYTIzICogYTIzKTtcbiAgICBNLmV4LnkgPSBkZXQgKiAoYTEzICogYTIzIC0gYTEyICogYTMzKTtcbiAgICBNLmV4LnogPSBkZXQgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKTtcbiAgICBNLmV5LnggPSBNLmV4Lnk7XG4gICAgTS5leS55ID0gZGV0ICogKGExMSAqIGEzMyAtIGExMyAqIGExMyk7XG4gICAgTS5leS56ID0gZGV0ICogKGExMyAqIGExMiAtIGExMSAqIGEyMyk7XG4gICAgTS5lei54ID0gTS5leC56O1xuICAgIE0uZXoueSA9IE0uZXkuejtcbiAgICBNLmV6LnogPSBkZXQgKiAoYTExICogYTIyIC0gYTEyICogYTEyKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYSBtYXRyaXggdGltZXMgYSB2ZWN0b3IuXG4gKiBcbiAqIEBwYXJhbSB7TWF0MzN9IGFcbiAqIEBwYXJhbSB7VmVjM3xWZWMyfSBiXG4gKiBcbiAqIEByZXR1cm5zIHtWZWMzfFZlYzJ9XG4gKi9cbk1hdDMzLm11bCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBfQVNTRVJUICYmIE1hdDMzLmFzc2VydChhKTtcbiAgICBpZiAoYiAmJiBcInpcIiBpbiBiICYmIFwieVwiIGluIGIgJiYgXCJ4XCIgaW4gYikge1xuICAgICAgICBfQVNTRVJUICYmIFZlYzMuYXNzZXJ0KGIpO1xuICAgICAgICB2YXIgeCA9IGEuZXgueCAqIGIueCArIGEuZXkueCAqIGIueSArIGEuZXoueCAqIGIuejtcbiAgICAgICAgdmFyIHkgPSBhLmV4LnkgKiBiLnggKyBhLmV5LnkgKiBiLnkgKyBhLmV6LnkgKiBiLno7XG4gICAgICAgIHZhciB6ID0gYS5leC56ICogYi54ICsgYS5leS56ICogYi55ICsgYS5lei56ICogYi56O1xuICAgICAgICByZXR1cm4gbmV3IFZlYzMoeCwgeSwgeik7XG4gICAgfSBlbHNlIGlmIChiICYmIFwieVwiIGluIGIgJiYgXCJ4XCIgaW4gYikge1xuICAgICAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KGIpO1xuICAgICAgICB2YXIgeCA9IGEuZXgueCAqIGIueCArIGEuZXkueCAqIGIueTtcbiAgICAgICAgdmFyIHkgPSBhLmV4LnkgKiBiLnggKyBhLmV5LnkgKiBiLnk7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbyh4LCB5KTtcbiAgICB9XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZhbHNlKTtcbn07XG5cbk1hdDMzLm11bFZlYzMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgX0FTU0VSVCAmJiBNYXQzMy5hc3NlcnQoYSk7XG4gICAgX0FTU0VSVCAmJiBWZWMzLmFzc2VydChiKTtcbiAgICB2YXIgeCA9IGEuZXgueCAqIGIueCArIGEuZXkueCAqIGIueSArIGEuZXoueCAqIGIuejtcbiAgICB2YXIgeSA9IGEuZXgueSAqIGIueCArIGEuZXkueSAqIGIueSArIGEuZXoueSAqIGIuejtcbiAgICB2YXIgeiA9IGEuZXgueiAqIGIueCArIGEuZXkueiAqIGIueSArIGEuZXoueiAqIGIuejtcbiAgICByZXR1cm4gbmV3IFZlYzMoeCwgeSwgeik7XG59O1xuXG5NYXQzMy5tdWxWZWMyID0gZnVuY3Rpb24oYSwgYikge1xuICAgIF9BU1NFUlQgJiYgTWF0MzMuYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQoYik7XG4gICAgdmFyIHggPSBhLmV4LnggKiBiLnggKyBhLmV5LnggKiBiLnk7XG4gICAgdmFyIHkgPSBhLmV4LnkgKiBiLnggKyBhLmV5LnkgKiBiLnk7XG4gICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xufTtcblxuTWF0MzMuYWRkID0gZnVuY3Rpb24oYSwgYikge1xuICAgIF9BU1NFUlQgJiYgTWF0MzMuYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgTWF0MzMuYXNzZXJ0KGIpO1xuICAgIHJldHVybiBuZXcgTWF0MzMoVmVjMy5hZGQoYS5leCArIGIuZXgpLCBWZWMzLmFkZChhLmV5ICsgYi5leSksIFZlYzMuYWRkKGEuZXogKyBiLmV6KSk7XG59O1xuXG5cbn0se1wiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4vTWF0aFwiOjE4LFwiLi9WZWMyXCI6MjMsXCIuL1ZlYzNcIjoyNH1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL2NyZWF0ZVwiKTtcblxudmFyIG5hdGl2ZSA9IE1hdGg7XG5cbnZhciBtYXRoID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGUobmF0aXZlKTtcblxubWF0aC5FUFNJTE9OID0gMWUtOTtcblxuLy8gVE9ET1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYSBmbG9hdGluZyBwb2ludCBudW1iZXIgaXMgbm90IGEgTmFOIG9yXG4gKiBpbmZpbml0eS5cbiAqL1xubWF0aC5pc0Zpbml0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoeCkgJiYgIWlzTmFOKHgpO1xufTtcblxubWF0aC5hc3NlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFfQVNTRVJUKSByZXR1cm47XG4gICAgaWYgKCFtYXRoLmlzRmluaXRlKHgpKSB7XG4gICAgICAgIF9ERUJVRyAmJiBjb21tb24uZGVidWcoeCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTnVtYmVyIVwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRPRE86IFRoaXMgaXMgYSBhcHByb3hpbWF0ZSB5ZXQgZmFzdCBpbnZlcnNlIHNxdWFyZS1yb290LlxuICovXG5tYXRoLmludlNxcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiAxIC8gbmF0aXZlLnNxcnQoeCk7XG59O1xuXG4vKipcbiAqIE5leHQgTGFyZ2VzdCBQb3dlciBvZiAyIEdpdmVuIGEgYmluYXJ5IGludGVnZXIgdmFsdWUgeCwgdGhlIG5leHQgbGFyZ2VzdFxuICogcG93ZXIgb2YgMiBjYW4gYmUgY29tcHV0ZWQgYnkgYSBTV0FSIGFsZ29yaXRobSB0aGF0IHJlY3Vyc2l2ZWx5IFwiZm9sZHNcIiB0aGVcbiAqIHVwcGVyIGJpdHMgaW50byB0aGUgbG93ZXIgYml0cy4gVGhpcyBwcm9jZXNzIHlpZWxkcyBhIGJpdCB2ZWN0b3Igd2l0aCB0aGVcbiAqIHNhbWUgbW9zdCBzaWduaWZpY2FudCAxIGFzIHgsIGJ1dCBhbGwgMSdzIGJlbG93IGl0LiBBZGRpbmcgMSB0byB0aGF0IHZhbHVlXG4gKiB5aWVsZHMgdGhlIG5leHQgbGFyZ2VzdCBwb3dlciBvZiAyLiBGb3IgYSAzMi1iaXQgdmFsdWU6XG4gKi9cbm1hdGgubmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbih4KSB7XG4gICAgLy8gVE9ET1xuICAgIHggfD0geCA+PiAxO1xuICAgIHggfD0geCA+PiAyO1xuICAgIHggfD0geCA+PiA0O1xuICAgIHggfD0geCA+PiA4O1xuICAgIHggfD0geCA+PiAxNjtcbiAgICByZXR1cm4geCArIDE7XG59O1xuXG5tYXRoLmlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA+IDAgJiYgKHggJiB4IC0gMSkgPT0gMDtcbn07XG5cbm1hdGgubW9kID0gZnVuY3Rpb24obnVtLCBtaW4sIG1heCkge1xuICAgIGlmICh0eXBlb2YgbWluID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG1heCA9IDEsIG1pbiA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG1heCA9IG1pbiwgbWluID0gMDtcbiAgICB9XG4gICAgaWYgKG1heCA+IG1pbikge1xuICAgICAgICBudW0gPSAobnVtIC0gbWluKSAlIChtYXggLSBtaW4pO1xuICAgICAgICByZXR1cm4gbnVtICsgKG51bSA8IDAgPyBtYXggOiBtaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG51bSA9IChudW0gLSBtYXgpICUgKG1pbiAtIG1heCk7XG4gICAgICAgIHJldHVybiBudW0gKyAobnVtIDw9IDAgPyBtaW4gOiBtYXgpO1xuICAgIH1cbn07XG5cbm1hdGguY2xhbXAgPSBmdW5jdGlvbihudW0sIG1pbiwgbWF4KSB7XG4gICAgaWYgKG51bSA8IG1pbikge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH0gZWxzZSBpZiAobnVtID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG59O1xuXG5tYXRoLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKHR5cGVvZiBtaW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgbWluID0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluID09IG1heCA/IG1pbiA6IG5hdGl2ZS5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufTtcblxuXG59LHtcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuLi91dGlsL2NyZWF0ZVwiOjUxfV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuL1ZlYzJcIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi9Sb3RcIik7XG5cbi8qKlxuICogQHByb3Age1ZlYzJ9IGMgbG9jYXRpb25cbiAqIEBwcm9wIHtmbG9hdH0gYSBhbmdsZVxuICovXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgICB0aGlzLmMgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLmEgPSAwO1xufVxuXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oeGYsIHApIHtcbiAgICB4Zi5xLnNldCh0aGlzLmEpO1xuICAgIHhmLnAuc2V0KFZlYzIuc3ViKHRoaXMuYywgUm90Lm11bFZlYzIoeGYucSwgcCkpKTtcbiAgICByZXR1cm4geGY7XG59O1xuXG5cbn0se1wiLi9Sb3RcIjoyMCxcIi4vVmVjMlwiOjIzfV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi9WZWMyXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuL01hdGhcIik7XG5cbi8vIFRPRE8gbWVyZ2Ugd2l0aCBUcmFuc2Zvcm1cbi8qKlxuICogSW5pdGlhbGl6ZSBmcm9tIGFuIGFuZ2xlIGluIHJhZGlhbnMuXG4gKi9cbmZ1bmN0aW9uIFJvdChhbmdsZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm90KGFuZ2xlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbmdsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLnNldEFuZ2xlKGFuZ2xlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhbmdsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLnNldChhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRJZGVudGl0eSgpO1xuICAgIH1cbn1cblxuUm90Lm5lbyA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoUm90LnByb3RvdHlwZSk7XG4gICAgb2JqLnNldEFuZ2xlKGFuZ2xlKTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuUm90LmNsb25lID0gZnVuY3Rpb24ocm90KSB7XG4gICAgX0FTU0VSVCAmJiBSb3QuYXNzZXJ0KHJvdCk7XG4gICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoUm90LnByb3RvdHlwZSk7XG4gICAgb2JqLnMgPSByb3QucztcbiAgICBvYmouYyA9IHJvdC5jO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5Sb3QuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShSb3QucHJvdG90eXBlKTtcbiAgICBvYmoucyA9IDA7XG4gICAgb2JqLmMgPSAxO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5Sb3QuaXNWYWxpZCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gbyAmJiBNYXRoLmlzRmluaXRlKG8ucykgJiYgTWF0aC5pc0Zpbml0ZShvLmMpO1xufTtcblxuUm90LmFzc2VydCA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIV9BU1NFUlQpIHJldHVybjtcbiAgICBpZiAoIVJvdC5pc1ZhbGlkKG8pKSB7XG4gICAgICAgIF9ERUJVRyAmJiBjb21tb24uZGVidWcobyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUm90IVwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0byB0aGUgaWRlbnRpdHkgcm90YXRpb24uXG4gKi9cblJvdC5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnMgPSAwO1xuICAgIHRoaXMuYyA9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Sb3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgaWYgKHR5cGVvZiBhbmdsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBfQVNTRVJUICYmIFJvdC5hc3NlcnQoYW5nbGUpO1xuICAgICAgICB0aGlzLnMgPSBhbmdsZS5zO1xuICAgICAgICB0aGlzLmMgPSBhbmdsZS5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYW5nbGUpO1xuICAgICAgICAvLyBUT0RPX0VSSU4gb3B0aW1pemVcbiAgICAgICAgdGhpcy5zID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB0aGlzLmMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgdXNpbmcgYW4gYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuUm90LnByb3RvdHlwZS5zZXRBbmdsZSA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgX0FTU0VSVCAmJiBNYXRoLmFzc2VydChhbmdsZSk7XG4gICAgLy8gVE9ET19FUklOIG9wdGltaXplXG4gICAgdGhpcy5zID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHRoaXMuYyA9IE1hdGguY29zKGFuZ2xlKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICovXG5Sb3QucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5zLCB0aGlzLmMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHgtYXhpcy5cbiAqL1xuUm90LnByb3RvdHlwZS5nZXRYQXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWZWMyLm5lbyh0aGlzLmMsIHRoaXMucyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdS1heGlzLlxuICovXG5Sb3QucHJvdG90eXBlLmdldFlBeGlzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFZlYzIubmVvKC10aGlzLnMsIHRoaXMuYyk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHR3byByb3RhdGlvbnM6IHEgKiByXG4gKiBcbiAqIEByZXR1cm5zIFJvdFxuICogXG4gKiBSb3RhdGUgYSB2ZWN0b3JcbiAqIFxuICogQHJldHVybnMgVmVjMlxuICovXG5Sb3QubXVsID0gZnVuY3Rpb24ocm90LCBtKSB7XG4gICAgX0FTU0VSVCAmJiBSb3QuYXNzZXJ0KHJvdCk7XG4gICAgaWYgKFwiY1wiIGluIG0gJiYgXCJzXCIgaW4gbSkge1xuICAgICAgICBfQVNTRVJUICYmIFJvdC5hc3NlcnQobSk7XG4gICAgICAgIC8vIFtxYyAtcXNdICogW3JjIC1yc10gPSBbcWMqcmMtcXMqcnMgLXFjKnJzLXFzKnJjXVxuICAgICAgICAvLyBbcXMgcWNdIFtycyByY10gW3FzKnJjK3FjKnJzIC1xcypycytxYypyY11cbiAgICAgICAgLy8gcyA9IHFzICogcmMgKyBxYyAqIHJzXG4gICAgICAgIC8vIGMgPSBxYyAqIHJjIC0gcXMgKiByc1xuICAgICAgICB2YXIgcXIgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgcXIucyA9IHJvdC5zICogbS5jICsgcm90LmMgKiBtLnM7XG4gICAgICAgIHFyLmMgPSByb3QuYyAqIG0uYyAtIHJvdC5zICogbS5zO1xuICAgICAgICByZXR1cm4gcXI7XG4gICAgfSBlbHNlIGlmIChcInhcIiBpbiBtICYmIFwieVwiIGluIG0pIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydChtKTtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHJvdC5jICogbS54IC0gcm90LnMgKiBtLnksIHJvdC5zICogbS54ICsgcm90LmMgKiBtLnkpO1xuICAgIH1cbn07XG5cblJvdC5tdWxSb3QgPSBmdW5jdGlvbihyb3QsIG0pIHtcbiAgICBfQVNTRVJUICYmIFJvdC5hc3NlcnQocm90KTtcbiAgICBfQVNTRVJUICYmIFJvdC5hc3NlcnQobSk7XG4gICAgLy8gW3FjIC1xc10gKiBbcmMgLXJzXSA9IFtxYypyYy1xcypycyAtcWMqcnMtcXMqcmNdXG4gICAgLy8gW3FzIHFjXSBbcnMgcmNdIFtxcypyYytxYypycyAtcXMqcnMrcWMqcmNdXG4gICAgLy8gcyA9IHFzICogcmMgKyBxYyAqIHJzXG4gICAgLy8gYyA9IHFjICogcmMgLSBxcyAqIHJzXG4gICAgdmFyIHFyID0gUm90LmlkZW50aXR5KCk7XG4gICAgcXIucyA9IHJvdC5zICogbS5jICsgcm90LmMgKiBtLnM7XG4gICAgcXIuYyA9IHJvdC5jICogbS5jIC0gcm90LnMgKiBtLnM7XG4gICAgcmV0dXJuIHFyO1xufTtcblxuUm90Lm11bFZlYzIgPSBmdW5jdGlvbihyb3QsIG0pIHtcbiAgICBfQVNTRVJUICYmIFJvdC5hc3NlcnQocm90KTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KG0pO1xuICAgIHJldHVybiBWZWMyLm5lbyhyb3QuYyAqIG0ueCAtIHJvdC5zICogbS55LCByb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbn07XG5cblJvdC5tdWxWZWMyXyA9IGZ1bmN0aW9uKHJvdCwgbSwgXykge1xuICAgIF9BU1NFUlQgJiYgUm90LmFzc2VydChyb3QpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQobSk7XG4gICAgcmV0dXJuIF8uc2V0KHJvdC5jICogbS54IC0gcm90LnMgKiBtLnksIHJvdC5zICogbS54ICsgcm90LmMgKiBtLnkpO1xufTtcblxuUm90Lm11bFN1YiA9IGZ1bmN0aW9uKHJvdCwgdiwgdykge1xuICAgIHZhciB4ID0gcm90LmMgKiAodi54IC0gdy54KSAtIHJvdC5zICogKHYueSAtIHcueSk7XG4gICAgdmFyIHkgPSByb3QucyAqICh2LnggLSB3LnkpICsgcm90LmMgKiAodi55IC0gdy55KTtcbiAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSBtdWx0aXBseSB0d28gcm90YXRpb25zOiBxVCAqIHJcbiAqIFxuICogQHJldHVybnMgUm90XG4gKiBcbiAqIEludmVyc2Ugcm90YXRlIGEgdmVjdG9yXG4gKiBcbiAqIEByZXR1cm5zIFZlYzJcbiAqL1xuUm90Lm11bFQgPSBmdW5jdGlvbihyb3QsIG0pIHtcbiAgICBpZiAoXCJjXCIgaW4gbSAmJiBcInNcIiBpbiBtKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgUm90LmFzc2VydChtKTtcbiAgICAgICAgLy8gWyBxYyBxc10gKiBbcmMgLXJzXSA9IFtxYypyYytxcypycyAtcWMqcnMrcXMqcmNdXG4gICAgICAgIC8vIFstcXMgcWNdIFtycyByY10gWy1xcypyYytxYypycyBxcypycytxYypyY11cbiAgICAgICAgLy8gcyA9IHFjICogcnMgLSBxcyAqIHJjXG4gICAgICAgIC8vIGMgPSBxYyAqIHJjICsgcXMgKiByc1xuICAgICAgICB2YXIgcXIgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgcXIucyA9IHJvdC5jICogbS5zIC0gcm90LnMgKiBtLmM7XG4gICAgICAgIHFyLmMgPSByb3QuYyAqIG0uYyArIHJvdC5zICogbS5zO1xuICAgICAgICByZXR1cm4gcXI7XG4gICAgfSBlbHNlIGlmIChcInhcIiBpbiBtICYmIFwieVwiIGluIG0pIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydChtKTtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHJvdC5jICogbS54ICsgcm90LnMgKiBtLnksIC1yb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbiAgICB9XG59O1xuXG5Sb3QubXVsVFJvdCA9IGZ1bmN0aW9uKHJvdCwgbSkge1xuICAgIF9BU1NFUlQgJiYgUm90LmFzc2VydChtKTtcbiAgICAvLyBbIHFjIHFzXSAqIFtyYyAtcnNdID0gW3FjKnJjK3FzKnJzIC1xYypycytxcypyY11cbiAgICAvLyBbLXFzIHFjXSBbcnMgcmNdIFstcXMqcmMrcWMqcnMgcXMqcnMrcWMqcmNdXG4gICAgLy8gcyA9IHFjICogcnMgLSBxcyAqIHJjXG4gICAgLy8gYyA9IHFjICogcmMgKyBxcyAqIHJzXG4gICAgdmFyIHFyID0gUm90LmlkZW50aXR5KCk7XG4gICAgcXIucyA9IHJvdC5jICogbS5zIC0gcm90LnMgKiBtLmM7XG4gICAgcXIuYyA9IHJvdC5jICogbS5jICsgcm90LnMgKiBtLnM7XG4gICAgcmV0dXJuIHFyO1xufTtcblxuUm90Lm11bFRSb3RfID0gZnVuY3Rpb24ocm90LCBtLCBfKSB7XG4gICAgX0FTU0VSVCAmJiBSb3QuYXNzZXJ0KG0pO1xuICAgIC8vIFsgcWMgcXNdICogW3JjIC1yc10gPSBbcWMqcmMrcXMqcnMgLXFjKnJzK3FzKnJjXVxuICAgIC8vIFstcXMgcWNdIFtycyByY10gWy1xcypyYytxYypycyBxcypycytxYypyY11cbiAgICAvLyBzID0gcWMgKiBycyAtIHFzICogcmNcbiAgICAvLyBjID0gcWMgKiByYyArIHFzICogcnNcbiAgICB2YXIgcXIgPSBfLnNldElkZW50aXR5KCk7XG4gICAgcXIucyA9IHJvdC5jICogbS5zIC0gcm90LnMgKiBtLmM7XG4gICAgcXIuYyA9IHJvdC5jICogbS5jICsgcm90LnMgKiBtLnM7XG4gICAgcmV0dXJuIHFyO1xufTtcblxuUm90Lm11bFRWZWMyID0gZnVuY3Rpb24ocm90LCBtKSB7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydChtKTtcbiAgICByZXR1cm4gVmVjMi5uZW8ocm90LmMgKiBtLnggKyByb3QucyAqIG0ueSwgLXJvdC5zICogbS54ICsgcm90LmMgKiBtLnkpO1xufTtcblxuUm90Lm11bFRWZWMyXyA9IGZ1bmN0aW9uKHJvdCwgbSwgXykge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQobSk7XG4gICAgcmV0dXJuIF8uc2V0KHJvdC5jICogbS54ICsgcm90LnMgKiBtLnksIC1yb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbn07XG5cblxufSx7XCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9NYXRoXCI6MTgsXCIuL1ZlYzJcIjoyM31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBTd2VlcDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi9NYXRoXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuL1ZlYzJcIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi9Sb3RcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9UcmFuc2Zvcm1cIik7XG5cbi8qKlxuICogVGhpcyBkZXNjcmliZXMgdGhlIG1vdGlvbiBvZiBhIGJvZHkvc2hhcGUgZm9yIFRPSSBjb21wdXRhdGlvbi4gU2hhcGVzIGFyZVxuICogZGVmaW5lZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGJvZHkgb3JpZ2luLCB3aGljaCBtYXkgbm90IGNvaW5jaWRlIHdpdGggdGhlXG4gKiBjZW50ZXIgb2YgbWFzcy4gSG93ZXZlciwgdG8gc3VwcG9ydCBkeW5hbWljcyB3ZSBtdXN0IGludGVycG9sYXRlIHRoZSBjZW50ZXJcbiAqIG9mIG1hc3MgcG9zaXRpb24uXG4gKiBcbiAqIEBwcm9wIHtWZWMyfSBsb2NhbENlbnRlciBMb2NhbCBjZW50ZXIgb2YgbWFzcyBwb3NpdGlvblxuICogQHByb3Age1ZlYzJ9IGMgV29ybGQgY2VudGVyIHBvc2l0aW9uXG4gKiBAcHJvcCB7ZmxvYXR9IGEgV29ybGQgYW5nbGVcbiAqIEBwcm9wIHtmbG9hdH0gYWxwaGEwIEZyYWN0aW9uIG9mIHRoZSBjdXJyZW50IHRpbWUgc3RlcCBpbiB0aGUgcmFuZ2UgWzAsMV0sIGMwXG4gKiAgICAgICBhbmQgYTAgYXJlIGMgYW5kIGEgYXQgYWxwaGEwLlxuICovXG5mdW5jdGlvbiBTd2VlcChjLCBhKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHR5cGVvZiBjID09PSBcInVuZGVmaW5lZFwiKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodHlwZW9mIGEgPT09IFwidW5kZWZpbmVkXCIpO1xuICAgIHRoaXMubG9jYWxDZW50ZXIgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLmMgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMuYWxwaGEwID0gMDtcbiAgICB0aGlzLmMwID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5hMCA9IDA7XG59XG5cblN3ZWVwLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4Zikge1xuICAgIHZhciBjID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMubG9jYWxDZW50ZXIpO1xuICAgIHRoaXMuYy5zZXQoYyk7XG4gICAgdGhpcy5jMC5zZXQoYyk7XG4gICAgdGhpcy5hID0geGYucS5nZXRBbmdsZSgpO1xuICAgIHRoaXMuYTAgPSB4Zi5xLmdldEFuZ2xlKCk7XG59O1xuXG5Td2VlcC5wcm90b3R5cGUuc2V0TG9jYWxDZW50ZXIgPSBmdW5jdGlvbihsb2NhbENlbnRlciwgeGYpIHtcbiAgICB0aGlzLmxvY2FsQ2VudGVyLnNldChsb2NhbENlbnRlcik7XG4gICAgdmFyIGMgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5sb2NhbENlbnRlcik7XG4gICAgdGhpcy5jLnNldChjKTtcbiAgICB0aGlzLmMwLnNldChjKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgdHJhbnNmb3JtIGF0IGEgc3BlY2lmaWMgdGltZS5cbiAqIFxuICogQHBhcmFtIHhmXG4gKiBAcGFyYW0gYmV0YSBBIGZhY3RvciBpbiBbMCwxXSwgd2hlcmUgMCBpbmRpY2F0ZXMgYWxwaGEwXG4gKi9cblN3ZWVwLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4ZiwgYmV0YSkge1xuICAgIGJldGEgPSB0eXBlb2YgYmV0YSA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiBiZXRhO1xuICAgIHhmLnEuc2V0QW5nbGUoKDEgLSBiZXRhKSAqIHRoaXMuYTAgKyBiZXRhICogdGhpcy5hKTtcbiAgICB4Zi5wLnNldENvbWJpbmUoMSAtIGJldGEsIHRoaXMuYzAsIGJldGEsIHRoaXMuYyk7XG4gICAgLy8gc2hpZnQgdG8gb3JpZ2luXG4gICAgeGYucC5zdWIoUm90Lm11bFZlYzIoeGYucSwgdGhpcy5sb2NhbENlbnRlcikpO1xufTtcblxuLyoqXG4gKiBBZHZhbmNlIHRoZSBzd2VlcCBmb3J3YXJkLCB5aWVsZGluZyBhIG5ldyBpbml0aWFsIHN0YXRlLlxuICogXG4gKiBAcGFyYW0ge2Zsb2F0fSBhbHBoYSBUaGUgbmV3IGluaXRpYWwgdGltZVxuICovXG5Td2VlcC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMuYWxwaGEwIDwgMSk7XG4gICAgdmFyIGJldGEgPSAoYWxwaGEgLSB0aGlzLmFscGhhMCkgLyAoMSAtIHRoaXMuYWxwaGEwKTtcbiAgICB0aGlzLmMwLnNldENvbWJpbmUoYmV0YSwgdGhpcy5jLCAxIC0gYmV0YSwgdGhpcy5jMCk7XG4gICAgdGhpcy5hMCA9IGJldGEgKiB0aGlzLmEgKyAoMSAtIGJldGEpICogdGhpcy5hMDtcbiAgICB0aGlzLmFscGhhMCA9IGFscGhhO1xufTtcblxuU3dlZXAucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmEwID0gdGhpcy5hO1xuICAgIHRoaXMuYzAuc2V0KHRoaXMuYyk7XG59O1xuXG4vKipcbiAqIG5vcm1hbGl6ZSB0aGUgYW5nbGVzIGluIHJhZGlhbnMgdG8gYmUgYmV0d2VlbiAtcGkgYW5kIHBpLlxuICovXG5Td2VlcC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEwID0gTWF0aC5tb2QodGhpcy5hMCwgLU1hdGguUEksICtNYXRoLlBJKTtcbiAgICB0aGlzLmEgLT0gdGhpcy5hMCAtIGEwO1xuICAgIHRoaXMuYTAgPSBhMDtcbn07XG5cblN3ZWVwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBTd2VlcCgpO1xuICAgIGNsb25lLmxvY2FsQ2VudGVyLnNldCh0aGlzLmxvY2FsQ2VudGVyKTtcbiAgICBjbG9uZS5hbHBoYTAgPSB0aGlzLmFscGhhMDtcbiAgICBjbG9uZS5hMCA9IHRoaXMuYTA7XG4gICAgY2xvbmUuYSA9IHRoaXMuYTtcbiAgICBjbG9uZS5jMC5zZXQodGhpcy5jMCk7XG4gICAgY2xvbmUuYy5zZXQodGhpcy5jKTtcbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG5Td2VlcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odGhhdCkge1xuICAgIHRoaXMubG9jYWxDZW50ZXIuc2V0KHRoYXQubG9jYWxDZW50ZXIpO1xuICAgIHRoaXMuYWxwaGEwID0gdGhhdC5hbHBoYTA7XG4gICAgdGhpcy5hMCA9IHRoYXQuYTA7XG4gICAgdGhpcy5hID0gdGhhdC5hO1xuICAgIHRoaXMuYzAuc2V0KHRoYXQuYzApO1xuICAgIHRoaXMuYy5zZXQodGhhdC5jKTtcbn07XG5cblxufSx7XCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9NYXRoXCI6MTgsXCIuL1JvdFwiOjIwLFwiLi9UcmFuc2Zvcm1cIjoyMixcIi4vVmVjMlwiOjIzfV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi9WZWMyXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4vUm90XCIpO1xuXG4vLyBUT0RPIG1lcmdlIHdpdGggUm90XG4vKipcbiAqIEEgdHJhbnNmb3JtIGNvbnRhaW5zIHRyYW5zbGF0aW9uIGFuZCByb3RhdGlvbi4gSXQgaXMgdXNlZCB0byByZXByZXNlbnQgdGhlXG4gKiBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgcmlnaWQgZnJhbWVzLiBJbml0aWFsaXplIHVzaW5nIGEgcG9zaXRpb24gdmVjdG9yXG4gKiBhbmQgYSByb3RhdGlvbi5cbiAqXG4gKiBAcHJvcCB7VmVjMn0gcG9zaXRpb25cbiAqIEBwcm9wIHtSb3R9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybShwb3NpdGlvbiwgcm90YXRpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShwb3NpdGlvbiwgcm90YXRpb24pO1xuICAgIH1cbiAgICB0aGlzLnAgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnEgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMucC5zZXQocG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJvdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMucS5zZXQocm90YXRpb24pO1xuICAgIH1cbn1cblxuVHJhbnNmb3JtLmNsb25lID0gZnVuY3Rpb24oeGYpIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcbiAgICBvYmoucCA9IFZlYzIuY2xvbmUoeGYucCk7XG4gICAgb2JqLnEgPSBSb3QuY2xvbmUoeGYucSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblRyYW5zZm9ybS5uZW8gPSBmdW5jdGlvbihwb3NpdGlvbiwgcm90YXRpb24pIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcbiAgICBvYmoucCA9IFZlYzIuY2xvbmUocG9zaXRpb24pO1xuICAgIG9iai5xID0gUm90LmNsb25lKHJvdGF0aW9uKTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuVHJhbnNmb3JtLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSk7XG4gICAgb2JqLnAgPSBWZWMyLnplcm8oKTtcbiAgICBvYmoucSA9IFJvdC5pZGVudGl0eSgpO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFNldCB0aGlzIHRvIHRoZSBpZGVudGl0eSB0cmFuc2Zvcm0uXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnAuc2V0WmVybygpO1xuICAgIHRoaXMucS5zZXRJZGVudGl0eSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhpcyBiYXNlZCBvbiB0aGUgcG9zaXRpb24gYW5kIGFuZ2xlLlxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5wLnNldChhLnApO1xuICAgICAgICB0aGlzLnEuc2V0KGEucSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wLnNldChhKTtcbiAgICAgICAgdGhpcy5xLnNldChiKTtcbiAgICB9XG59O1xuXG5UcmFuc2Zvcm0uaXNWYWxpZCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gbyAmJiBWZWMyLmlzVmFsaWQoby5wKSAmJiBSb3QuaXNWYWxpZChvLnEpO1xufTtcblxuVHJhbnNmb3JtLmFzc2VydCA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIV9BU1NFUlQpIHJldHVybjtcbiAgICBpZiAoIVRyYW5zZm9ybS5pc1ZhbGlkKG8pKSB7XG4gICAgICAgIF9ERUJVRyAmJiBjb21tb24uZGVidWcobyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVHJhbnNmb3JtIVwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBhXG4gKiBAcGFyYW0ge1ZlYzJ9IGJcbiAqIEByZXR1cm5zIHtWZWMyfVxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBhXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gYlxuICogQHJldHVybnMge1RyYW5zZm9ybX1cbiAqL1xuVHJhbnNmb3JtLm11bCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBfQVNTRVJUICYmIFRyYW5zZm9ybS5hc3NlcnQoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IFRyYW5zZm9ybS5tdWwoYSwgYltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFwieFwiIGluIGIgJiYgXCJ5XCIgaW4gYikge1xuICAgICAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KGIpO1xuICAgICAgICB2YXIgeCA9IGEucS5jICogYi54IC0gYS5xLnMgKiBiLnkgKyBhLnAueDtcbiAgICAgICAgdmFyIHkgPSBhLnEucyAqIGIueCArIGEucS5jICogYi55ICsgYS5wLnk7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbyh4LCB5KTtcbiAgICB9IGVsc2UgaWYgKFwicFwiIGluIGIgJiYgXCJxXCIgaW4gYikge1xuICAgICAgICBfQVNTRVJUICYmIFRyYW5zZm9ybS5hc3NlcnQoYik7XG4gICAgICAgIC8vIHYyID0gQS5xLlJvdChCLnEuUm90KHYxKSArIEIucCkgKyBBLnBcbiAgICAgICAgLy8gPSAoQS5xICogQi5xKS5Sb3QodjEpICsgQS5xLlJvdChCLnApICsgQS5wXG4gICAgICAgIHZhciB4ZiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICB4Zi5xID0gUm90Lm11bFJvdChhLnEsIGIucSk7XG4gICAgICAgIHhmLnAgPSBWZWMyLmFkZChSb3QubXVsVmVjMihhLnEsIGIucCksIGEucCk7XG4gICAgICAgIHJldHVybiB4ZjtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBtdWxGbiBpbnN0ZWFkLlxuICovXG5UcmFuc2Zvcm0ubXVsQWxsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIF9BU1NFUlQgJiYgVHJhbnNmb3JtLmFzc2VydChhKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IFRyYW5zZm9ybS5tdWwoYSwgYltpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuVHJhbnNmb3JtLm11bEZuID0gZnVuY3Rpb24oYSkge1xuICAgIF9BU1NFUlQgJiYgVHJhbnNmb3JtLmFzc2VydChhKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bChhLCBiKTtcbiAgICB9O1xufTtcblxuVHJhbnNmb3JtLm11bFZlYzIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgX0FTU0VSVCAmJiBUcmFuc2Zvcm0uYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQoYik7XG4gICAgdmFyIHggPSBhLnEuYyAqIGIueCAtIGEucS5zICogYi55ICsgYS5wLng7XG4gICAgdmFyIHkgPSBhLnEucyAqIGIueCArIGEucS5jICogYi55ICsgYS5wLnk7XG4gICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xufTtcblxuVHJhbnNmb3JtLm11bFZlYzJfID0gZnVuY3Rpb24oYSwgYiwgXykge1xuICAgIF9BU1NFUlQgJiYgVHJhbnNmb3JtLmFzc2VydChhKTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KGIpO1xuICAgIHZhciB4ID0gYS5xLmMgKiBiLnggLSBhLnEucyAqIGIueSArIGEucC54O1xuICAgIHZhciB5ID0gYS5xLnMgKiBiLnggKyBhLnEuYyAqIGIueSArIGEucC55O1xuICAgIHJldHVybiBfLnNldCh4LCB5KTtcbn07XG5cblRyYW5zZm9ybS5tdWxYZiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBfQVNTRVJUICYmIFRyYW5zZm9ybS5hc3NlcnQoYSk7XG4gICAgX0FTU0VSVCAmJiBUcmFuc2Zvcm0uYXNzZXJ0KGIpO1xuICAgIC8vIHYyID0gQS5xLlJvdChCLnEuUm90KHYxKSArIEIucCkgKyBBLnBcbiAgICAvLyA9IChBLnEgKiBCLnEpLlJvdCh2MSkgKyBBLnEuUm90KEIucCkgKyBBLnBcbiAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICB4Zi5xID0gUm90Lm11bFJvdChhLnEsIGIucSk7XG4gICAgeGYucCA9IFZlYzIuYWRkKFJvdC5tdWxWZWMyKGEucSwgYi5wKSwgYS5wKTtcbiAgICByZXR1cm4geGY7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBhXG4gKiBAcGFyYW0ge1ZlYzJ9IGJcbiAqIEByZXR1cm5zIHtWZWMyfVxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBhXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gYlxuICogQHJldHVybnMge1RyYW5zZm9ybX1cbiAqL1xuVHJhbnNmb3JtLm11bFQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgX0FTU0VSVCAmJiBUcmFuc2Zvcm0uYXNzZXJ0KGEpO1xuICAgIGlmIChcInhcIiBpbiBiICYmIFwieVwiIGluIGIpIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydChiKTtcbiAgICAgICAgdmFyIHB4ID0gYi54IC0gYS5wLng7XG4gICAgICAgIHZhciBweSA9IGIueSAtIGEucC55O1xuICAgICAgICB2YXIgeCA9IGEucS5jICogcHggKyBhLnEucyAqIHB5O1xuICAgICAgICB2YXIgeSA9IC1hLnEucyAqIHB4ICsgYS5xLmMgKiBweTtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgIH0gZWxzZSBpZiAoXCJwXCIgaW4gYiAmJiBcInFcIiBpbiBiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgVHJhbnNmb3JtLmFzc2VydChiKTtcbiAgICAgICAgLy8gdjIgPSBBLnEnICogKEIucSAqIHYxICsgQi5wIC0gQS5wKVxuICAgICAgICAvLyA9IEEucScgKiBCLnEgKiB2MSArIEEucScgKiAoQi5wIC0gQS5wKVxuICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgeGYucS5zZXQoUm90Lm11bFRSb3QoYS5xLCBiLnEpKTtcbiAgICAgICAgeGYucC5zZXQoUm90Lm11bFRWZWMyKGEucSwgVmVjMi5zdWIoYi5wLCBhLnApKSk7XG4gICAgICAgIHJldHVybiB4ZjtcbiAgICB9XG59O1xuXG5UcmFuc2Zvcm0ubXVsVFZlYzIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgX0FTU0VSVCAmJiBUcmFuc2Zvcm0uYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQoYik7XG4gICAgdmFyIHB4ID0gYi54IC0gYS5wLng7XG4gICAgdmFyIHB5ID0gYi55IC0gYS5wLnk7XG4gICAgdmFyIHggPSBhLnEuYyAqIHB4ICsgYS5xLnMgKiBweTtcbiAgICB2YXIgeSA9IC1hLnEucyAqIHB4ICsgYS5xLmMgKiBweTtcbiAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG59O1xuXG5UcmFuc2Zvcm0ubXVsVFZlYzJfID0gZnVuY3Rpb24oYSwgYiwgXykge1xuICAgIF9BU1NFUlQgJiYgVHJhbnNmb3JtLmFzc2VydChhKTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KGIpO1xuICAgIHZhciBweCA9IGIueCAtIGEucC54O1xuICAgIHZhciBweSA9IGIueSAtIGEucC55O1xuICAgIHZhciB4ID0gYS5xLmMgKiBweCArIGEucS5zICogcHk7XG4gICAgdmFyIHkgPSAtYS5xLnMgKiBweCArIGEucS5jICogcHk7XG4gICAgcmV0dXJuIF8uc2V0KHgsIHkpO1xufTtcblxuVHJhbnNmb3JtLm11bFRYZiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBfQVNTRVJUICYmIFRyYW5zZm9ybS5hc3NlcnQoYSk7XG4gICAgX0FTU0VSVCAmJiBUcmFuc2Zvcm0uYXNzZXJ0KGIpO1xuICAgIC8vIHYyID0gQS5xJyAqIChCLnEgKiB2MSArIEIucCAtIEEucClcbiAgICAvLyA9IEEucScgKiBCLnEgKiB2MSArIEEucScgKiAoQi5wIC0gQS5wKVxuICAgIHZhciB4ZiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgIHhmLnEuc2V0KFJvdC5tdWxUUm90KGEucSwgYi5xKSk7XG4gICAgeGYucC5zZXQoUm90Lm11bFRWZWMyKGEucSwgVmVjMi5zdWIoYi5wLCBhLnApKSk7XG4gICAgcmV0dXJuIHhmO1xufTtcblxudmFyIF92dDEgPSBWZWMyLnplcm8oKTtcblxuVHJhbnNmb3JtLm11bFRYZl8gPSBmdW5jdGlvbihhLCBiLCBfKSB7XG4gICAgX0FTU0VSVCAmJiBUcmFuc2Zvcm0uYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgVHJhbnNmb3JtLmFzc2VydChiKTtcbiAgICAvLyB2MiA9IEEucScgKiAoQi5xICogdjEgKyBCLnAgLSBBLnApXG4gICAgLy8gPSBBLnEnICogQi5xICogdjEgKyBBLnEnICogKEIucCAtIEEucClcbiAgICBSb3QubXVsVFJvdF8oYS5xLCBiLnEsIF8ucSk7XG4gICAgUm90Lm11bFRWZWMyXyhhLnEsIFZlYzIuc3ViKGIucCwgYS5wLCBfdnQxKSwgXy5wKTtcbiAgICByZXR1cm4gXztcbn07XG5cblxufSx7XCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9Sb3RcIjoyMCxcIi4vVmVjMlwiOjIzfV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlYzI7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4vTWF0aFwiKTtcblxuZnVuY3Rpb24gVmVjMih4LCB5KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZlYzIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLnggPSB4Lng7XG4gICAgICAgIHRoaXMueSA9IHgueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHRoaXMpO1xufVxuXG5WZWMyLnplcm8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShWZWMyLnByb3RvdHlwZSk7XG4gICAgb2JqLnggPSAwO1xuICAgIG9iai55ID0gMDtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuVmVjMi5uZW8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVmVjMi5wcm90b3R5cGUpO1xuICAgIG9iai54ID0geDtcbiAgICBvYmoueSA9IHk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblZlYzIuY2xvbmUgPSBmdW5jdGlvbih2KSB7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICByZXR1cm4gVmVjMi5uZW8odi54LCB2LnkpO1xufTtcblxuVmVjMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG59O1xuXG4vKipcbiAqIERvZXMgdGhpcyB2ZWN0b3IgY29udGFpbiBmaW5pdGUgY29vcmRpbmF0ZXM/XG4gKi9cblZlYzIuaXNWYWxpZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdiAmJiBNYXRoLmlzRmluaXRlKHYueCkgJiYgTWF0aC5pc0Zpbml0ZSh2LnkpO1xufTtcblxuVmVjMi5hc3NlcnQgPSBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCFfQVNTRVJUKSByZXR1cm47XG4gICAgaWYgKCFWZWMyLmlzVmFsaWQobykpIHtcbiAgICAgICAgX0RFQlVHICYmIGNvbW1vbi5kZWJ1ZyhvKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBWZWMyIVwiKTtcbiAgICB9XG59O1xuXG5WZWMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWZWMyLmNsb25lKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhpcyB2ZWN0b3IgdG8gYWxsIHplcm9zLlxuICogXG4gKiBAcmV0dXJucyB0aGlzXG4gKi9cblZlYzIucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGlzIHZlY3RvciB0byBzb21lIHNwZWNpZmllZCBjb29yZGluYXRlcy5cbiAqIFxuICogQHJldHVybnMgdGhpc1xuICovXG5WZWMyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQoeCk7XG4gICAgICAgIHRoaXMueCA9IHgueDtcbiAgICAgICAgdGhpcy55ID0geC55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoeCk7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoeSk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuVmVjMi5wcm90b3R5cGUuc2V0WFkgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuVmVjMi5wcm90b3R5cGUuc2V0VmVjMiA9IGZ1bmN0aW9uKHgpIHtcbiAgICB0aGlzLnggPSB4Lng7XG4gICAgdGhpcy55ID0geC55O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Ugc2V0Q29tYmluZSBvciBzZXRNdWxcbiAqL1xuVmVjMi5wcm90b3R5cGUud1NldCA9IGZ1bmN0aW9uKGEsIHYsIGIsIHcpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHcgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q29tYmluZShhLCB2LCBiLCB3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRNdWwoYSwgdik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgbGluZWFyIGNvbWJpbmF0aW9uIG9mIHYgYW5kIHc6IGBhICogdiArIGIgKiB3YFxuICovXG5WZWMyLnByb3RvdHlwZS5zZXRDb21iaW5lID0gZnVuY3Rpb24oYSwgdiwgYiwgdykge1xuICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYSk7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICBfQVNTRVJUICYmIE1hdGguYXNzZXJ0KGIpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgdmFyIHggPSBhICogdi54ICsgYiAqIHcueDtcbiAgICB2YXIgeSA9IGEgKiB2LnkgKyBiICogdy55O1xuICAgIC8vIGB0aGlzYCBtYXkgYmUgYHdgXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuVmVjMi5wcm90b3R5cGUuc2V0TXVsID0gZnVuY3Rpb24oYSwgdikge1xuICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYSk7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICB2YXIgeCA9IGEgKiB2Lng7XG4gICAgdmFyIHkgPSBhICogdi55O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgdmVjdG9yIHRvIHRoaXMgdmVjdG9yLlxuICogXG4gKiBAcmV0dXJucyB0aGlzXG4gKi9cblZlYzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHcpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHcpO1xuICAgIHRoaXMueCArPSB3Lng7XG4gICAgdGhpcy55ICs9IHcueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGFkZENvbWJpbmUgb3IgYWRkTXVsXG4gKi9cblZlYzIucHJvdG90eXBlLndBZGQgPSBmdW5jdGlvbihhLCB2LCBiLCB3KSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB3ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENvbWJpbmUoYSwgdiwgYiwgdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTXVsKGEsIHYpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGxpbmVhciBjb21iaW5hdGlvbiBvZiB2IGFuZCB3OiBgYSAqIHYgKyBiICogd2BcbiAqL1xuVmVjMi5wcm90b3R5cGUuYWRkQ29tYmluZSA9IGZ1bmN0aW9uKGEsIHYsIGIsIHcpIHtcbiAgICBfQVNTRVJUICYmIE1hdGguYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgX0FTU0VSVCAmJiBNYXRoLmFzc2VydChiKTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHcpO1xuICAgIHZhciB4ID0gYSAqIHYueCArIGIgKiB3Lng7XG4gICAgdmFyIHkgPSBhICogdi55ICsgYiAqIHcueTtcbiAgICAvLyBgdGhpc2AgbWF5IGJlIGB3YFxuICAgIHRoaXMueCArPSB4O1xuICAgIHRoaXMueSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuVmVjMi5wcm90b3R5cGUuYWRkTXVsID0gZnVuY3Rpb24oYSwgdikge1xuICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYSk7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICB2YXIgeCA9IGEgKiB2Lng7XG4gICAgdmFyIHkgPSBhICogdi55O1xuICAgIHRoaXMueCArPSB4O1xuICAgIHRoaXMueSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Ugc3ViQ29tYmluZSBvciBzdWJNdWxcbiAqL1xuVmVjMi5wcm90b3R5cGUud1N1YiA9IGZ1bmN0aW9uKGEsIHYsIGIsIHcpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHcgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViQ29tYmluZShhLCB2LCBiLCB3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJNdWwoYSwgdik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBsaW5lYXIgY29tYmluYXRpb24gb2YgdiBhbmQgdzogYGEgKiB2ICsgYiAqIHdgXG4gKi9cblZlYzIucHJvdG90eXBlLnN1YkNvbWJpbmUgPSBmdW5jdGlvbihhLCB2LCBiLCB3KSB7XG4gICAgX0FTU0VSVCAmJiBNYXRoLmFzc2VydChhKTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYik7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh3KTtcbiAgICB2YXIgeCA9IGEgKiB2LnggKyBiICogdy54O1xuICAgIHZhciB5ID0gYSAqIHYueSArIGIgKiB3Lnk7XG4gICAgLy8gYHRoaXNgIG1heSBiZSBgd2BcbiAgICB0aGlzLnggLT0geDtcbiAgICB0aGlzLnkgLT0geTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzIucHJvdG90eXBlLnN1Yk11bCA9IGZ1bmN0aW9uKGEsIHYpIHtcbiAgICBfQVNTRVJUICYmIE1hdGguYXNzZXJ0KGEpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgdmFyIHggPSBhICogdi54O1xuICAgIHZhciB5ID0gYSAqIHYueTtcbiAgICB0aGlzLnggLT0geDtcbiAgICB0aGlzLnkgLT0geTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3VidHJhY3QgYSB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxuICogXG4gKiBAcmV0dXJucyB0aGlzXG4gKi9cblZlYzIucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHcpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHcpO1xuICAgIHRoaXMueCAtPSB3Lng7XG4gICAgdGhpcy55IC09IHcueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhpcyB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gKiBcbiAqIEByZXR1cm5zIHRoaXNcbiAqL1xuVmVjMi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24obSkge1xuICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQobSk7XG4gICAgdGhpcy54ICo9IG07XG4gICAgdGhpcy55ICo9IG07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yICh0aGUgbm9ybSkuXG4gKiBcbiAqIEZvciBwZXJmb3JtYW5jZSwgdXNlIHRoaXMgaW5zdGVhZCBvZiBsZW5ndGhTcXVhcmVkIChpZiBwb3NzaWJsZSkuXG4gKi9cblZlYzIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWZWMyLmxlbmd0aE9mKHRoaXMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBzcXVhcmVkLlxuICovXG5WZWMyLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFZlYzIubGVuZ3RoU3F1YXJlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGEgdW5pdCB2ZWN0b3IuXG4gKiBcbiAqIEByZXR1cm5zIG9sZCBsZW5ndGhcbiAqL1xuVmVjMi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgaWYgKGxlbmd0aCA8IE1hdGguRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGludkxlbmd0aCA9IDEgLyBsZW5ndGg7XG4gICAgdGhpcy54ICo9IGludkxlbmd0aDtcbiAgICB0aGlzLnkgKj0gaW52TGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGg7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yICh0aGUgbm9ybSkuXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlLCB1c2UgdGhpcyBpbnN0ZWFkIG9mIGxlbmd0aFNxdWFyZWQgKGlmIHBvc3NpYmxlKS5cbiAqL1xuVmVjMi5sZW5ndGhPZiA9IGZ1bmN0aW9uKHYpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIHJldHVybiBNYXRoLnNxcnQodi54ICogdi54ICsgdi55ICogdi55KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggc3F1YXJlZC5cbiAqL1xuVmVjMi5sZW5ndGhTcXVhcmVkID0gZnVuY3Rpb24odikge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgcmV0dXJuIHYueCAqIHYueCArIHYueSAqIHYueTtcbn07XG5cblZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbih2LCB3KSB7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHcpO1xuICAgIHZhciBkeCA9IHYueCAtIHcueCwgZHkgPSB2LnkgLSB3Lnk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59O1xuXG5WZWMyLmRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgdmFyIGR4ID0gdi54IC0gdy54LCBkeSA9IHYueSAtIHcueTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuXG5WZWMyLmFyZUVxdWFsID0gZnVuY3Rpb24odiwgdykge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh3KTtcbiAgICByZXR1cm4gdiA9PSB3IHx8IHR5cGVvZiB3ID09PSBcIm9iamVjdFwiICYmIHcgIT09IG51bGwgJiYgdi54ID09PSB3LnggJiYgdi55ID09PSB3Lnk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2tldyB2ZWN0b3Igc3VjaCB0aGF0IGRvdChza2V3X3ZlYywgb3RoZXIpID09IGNyb3NzKHZlYywgb3RoZXIpXG4gKi9cblZlYzIuc2tldyA9IGZ1bmN0aW9uKHYpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIHJldHVybiBWZWMyLm5lbygtdi55LCB2LngpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBkb3QgcHJvZHVjdCBvbiB0d28gdmVjdG9ycy5cbiAqL1xuVmVjMi5kb3QgPSBmdW5jdGlvbih2LCB3KSB7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHcpO1xuICAgIHJldHVybiB2LnggKiB3LnggKyB2LnkgKiB3Lnk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gdGhlIGNyb3NzIHByb2R1Y3Qgb24gdHdvIHZlY3RvcnMuIEluIDJEIHRoaXMgcHJvZHVjZXMgYSBzY2FsYXIuXG4gKiBcbiAqIFBlcmZvcm0gdGhlIGNyb3NzIHByb2R1Y3Qgb24gYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLiBJbiAyRCB0aGlzIHByb2R1Y2VzIGFcbiAqIHZlY3Rvci5cbiAqL1xuVmVjMi5jcm9zcyA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBpZiAodHlwZW9mIHcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICAgICAgX0FTU0VSVCAmJiBNYXRoLmFzc2VydCh3KTtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHcgKiB2LnksIC13ICogdi54KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQodik7XG4gICAgICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbygtdiAqIHcueSwgdiAqIHcueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh3KTtcbiAgICAgICAgcmV0dXJuIHYueCAqIHcueSAtIHYueSAqIHcueDtcbiAgICB9XG59O1xuXG5WZWMyLmNyb3NzVmVjMlZlYzIgPSBmdW5jdGlvbih2LCB3KSB7XG4gICAgcmV0dXJuIHYueCAqIHcueSAtIHYueSAqIHcueDtcbn07XG5cblZlYzIuY3Jvc3NOdW1WZWMyXyA9IGZ1bmN0aW9uKHYsIHcsIF8pIHtcbiAgICByZXR1cm4gXy5zZXRYWSgtdiAqIHcueSwgdiAqIHcueCk7XG59O1xuXG5WZWMyLmNyb3NzVmVjMk51bV8gPSBmdW5jdGlvbih2LCB3LCBfKSB7XG4gICAgcmV0dXJuIF8uc2V0WFkodyAqIHYueSwgLXcgKiB2LngpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGBhICsgKHYgeCB3KWBcbiAqL1xuVmVjMi5hZGRDcm9zcyA9IGZ1bmN0aW9uKGEsIHYsIHcpIHtcbiAgICBpZiAodHlwZW9mIHcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh2KTtcbiAgICAgICAgX0FTU0VSVCAmJiBNYXRoLmFzc2VydCh3KTtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHcgKiB2LnkgKyBhLngsIC13ICogdi54ICsgYS55KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQodik7XG4gICAgICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbygtdiAqIHcueSArIGEueCwgdiAqIHcueCArIGEueSk7XG4gICAgfVxuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG59O1xuXG5WZWMyLmFkZCA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgcmV0dXJuIFZlYzIubmVvKHYueCArIHcueCwgdi55ICsgdy55KTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGNvbWJpbmVcbiAqL1xuVmVjMi53QWRkID0gZnVuY3Rpb24oYSwgdiwgYiwgdykge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gVmVjMi5jb21iaW5lKGEsIHYsIGIsIHcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBWZWMyLm11bChhLCB2KTtcbiAgICB9XG59O1xuXG5WZWMyLmNvbWJpbmUgPSBmdW5jdGlvbihhLCB2LCBiLCB3KSB7XG4gICAgcmV0dXJuIFZlYzIuemVybygpLnNldENvbWJpbmUoYSwgdiwgYiwgdyk7XG59O1xuXG5WZWMyLmNvbWJpbmVfID0gZnVuY3Rpb24oYSwgdiwgYiwgdywgXykge1xuICAgIHJldHVybiBfLnNldENvbWJpbmUoYSwgdiwgYiwgdyk7XG59O1xuXG5WZWMyLnN1YiA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgcmV0dXJuIFZlYzIubmVvKHYueCAtIHcueCwgdi55IC0gdy55KTtcbn07XG5cblZlYzIuc3ViXyA9IGZ1bmN0aW9uKHYsIHcsIF8pIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgcmV0dXJuIF8uc2V0WFkodi54IC0gdy54LCB2LnkgLSB3LnkpO1xufTtcblxuVmVjMi5tdWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQoYSk7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYik7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbyhhLnggKiBiLCBhLnkgKiBiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIF9BU1NFUlQgJiYgTWF0aC5hc3NlcnQoYSk7XG4gICAgICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQoYik7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbyhhICogYi54LCBhICogYi55KTtcbiAgICB9XG59O1xuXG5WZWMyLm11bFZlYzJOdW1fID0gZnVuY3Rpb24oYSwgYiwgXykge1xuICAgIHJldHVybiBfLnNldFhZKGEueCAqIGIsIGEueSAqIGIpO1xufTtcblxuVmVjMi5tdWxOdW1WZWMyXyA9IGZ1bmN0aW9uKGEsIGIsIF8pIHtcbiAgICByZXR1cm4gXy5zZXRYWShhICogYi54LCBhICogYi55KTtcbn07XG5cblZlYzIucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzIubmVnID0gZnVuY3Rpb24odikge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgcmV0dXJuIFZlYzIubmVvKC12LngsIC12LnkpO1xufTtcblxuVmVjMi5uZWdfID0gZnVuY3Rpb24odiwgXykge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgcmV0dXJuIF8uc2V0WFkoLXYueCwgLXYueSk7XG59O1xuXG5WZWMyLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIHJldHVybiBWZWMyLm5lbyhNYXRoLmFicyh2LngpLCBNYXRoLmFicyh2LnkpKTtcbn07XG5cblZlYzIubWlkID0gZnVuY3Rpb24odiwgdykge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh3KTtcbiAgICByZXR1cm4gVmVjMi5uZW8oKHYueCArIHcueCkgKiAuNSwgKHYueSArIHcueSkgKiAuNSk7XG59O1xuXG5WZWMyLnVwcGVyID0gZnVuY3Rpb24odiwgdykge1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodik7XG4gICAgX0FTU0VSVCAmJiBWZWMyLmFzc2VydCh3KTtcbiAgICByZXR1cm4gVmVjMi5uZW8oTWF0aC5tYXgodi54LCB3LngpLCBNYXRoLm1heCh2LnksIHcueSkpO1xufTtcblxuVmVjMi5sb3dlciA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBfQVNTRVJUICYmIFZlYzIuYXNzZXJ0KHYpO1xuICAgIF9BU1NFUlQgJiYgVmVjMi5hc3NlcnQodyk7XG4gICAgcmV0dXJuIFZlYzIubmVvKE1hdGgubWluKHYueCwgdy54KSwgTWF0aC5taW4odi55LCB3LnkpKTtcbn07XG5cblZlYzIucHJvdG90eXBlLmNsYW1wID0gZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIGxlbmd0aFNxciA9IHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICBpZiAobGVuZ3RoU3FyID4gbWF4ICogbWF4KSB7XG4gICAgICAgIHZhciBpbnZMZW5ndGggPSBNYXRoLmludlNxcnQobGVuZ3RoU3FyKTtcbiAgICAgICAgdGhpcy54ICo9IGludkxlbmd0aCAqIG1heDtcbiAgICAgICAgdGhpcy55ICo9IGludkxlbmd0aCAqIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5WZWMyLmNsYW1wID0gZnVuY3Rpb24odiwgbWF4KSB7XG4gICAgdiA9IFZlYzIubmVvKHYueCwgdi55KTtcbiAgICB2LmNsYW1wKG1heCk7XG4gICAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuVmVjMi5zY2FsZUZuID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBWZWMyLm5lbyh2LnggKiB4LCB2LnkgKiB5KTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cblZlYzIudHJhbnNsYXRlRm4gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFZlYzIubmVvKHYueCArIHgsIHYueSArIHkpO1xuICAgIH07XG59O1xuXG5cbn0se1wiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4vTWF0aFwiOjE4fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlYzM7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4vTWF0aFwiKTtcblxuZnVuY3Rpb24gVmVjMyh4LCB5LCB6KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZlYzMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMueCA9IDAsIHRoaXMueSA9IDAsIHRoaXMueiA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLnggPSB4LngsIHRoaXMueSA9IHgueSwgdGhpcy56ID0geC56O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueCA9IHgsIHRoaXMueSA9IHksIHRoaXMueiA9IHo7XG4gICAgfVxuICAgIF9BU1NFUlQgJiYgVmVjMy5hc3NlcnQodGhpcyk7XG59XG5cblZlYzMubmVvID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFZlYzMucHJvdG90eXBlKTtcbiAgICBvYmoueCA9IHg7XG4gICAgb2JqLnkgPSB5O1xuICAgIG9iai56ID0gejtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuVmVjMy5jbG9uZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBfQVNTRVJUICYmIFZlYzMuYXNzZXJ0KHYpO1xuICAgIHJldHVybiBWZWMzLm5lbyh2LngsIHYueSwgdi56KTtcbn07XG5cblZlYzMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEb2VzIHRoaXMgdmVjdG9yIGNvbnRhaW4gZmluaXRlIGNvb3JkaW5hdGVzP1xuICovXG5WZWMzLmlzVmFsaWQgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYgJiYgTWF0aC5pc0Zpbml0ZSh2LngpICYmIE1hdGguaXNGaW5pdGUodi55KSAmJiBNYXRoLmlzRmluaXRlKHYueik7XG59O1xuXG5WZWMzLmFzc2VydCA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIV9BU1NFUlQpIHJldHVybjtcbiAgICBpZiAoIVZlYzMuaXNWYWxpZChvKSkge1xuICAgICAgICBfREVCVUcgJiYgY29tbW9uLmRlYnVnKG8pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFZlYzMhXCIpO1xuICAgIH1cbn07XG5cblZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy56ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHcpIHtcbiAgICB0aGlzLnggKz0gdy54O1xuICAgIHRoaXMueSArPSB3Lnk7XG4gICAgdGhpcy56ICs9IHcuejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzMucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHcpIHtcbiAgICB0aGlzLnggLT0gdy54O1xuICAgIHRoaXMueSAtPSB3Lnk7XG4gICAgdGhpcy56IC09IHcuejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzMucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKG0pIHtcbiAgICB0aGlzLnggKj0gbTtcbiAgICB0aGlzLnkgKj0gbTtcbiAgICB0aGlzLnogKj0gbTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzMuYXJlRXF1YWwgPSBmdW5jdGlvbih2LCB3KSB7XG4gICAgX0FTU0VSVCAmJiBWZWMzLmFzc2VydCh2KTtcbiAgICBfQVNTRVJUICYmIFZlYzMuYXNzZXJ0KHcpO1xuICAgIHJldHVybiB2ID09IHcgfHwgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCAmJiB0eXBlb2YgdyA9PT0gXCJvYmplY3RcIiAmJiB3ICE9PSBudWxsICYmIHYueCA9PT0gdy54ICYmIHYueSA9PT0gdy55ICYmIHYueiA9PT0gdy56O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBkb3QgcHJvZHVjdCBvbiB0d28gdmVjdG9ycy5cbiAqL1xuVmVjMy5kb3QgPSBmdW5jdGlvbih2LCB3KSB7XG4gICAgcmV0dXJuIHYueCAqIHcueCArIHYueSAqIHcueSArIHYueiAqIHcuejtcbn07XG5cbi8qKlxuICogUGVyZm9ybSB0aGUgY3Jvc3MgcHJvZHVjdCBvbiB0d28gdmVjdG9ycy4gSW4gMkQgdGhpcyBwcm9kdWNlcyBhIHNjYWxhci5cbiAqL1xuVmVjMy5jcm9zcyA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICByZXR1cm4gbmV3IFZlYzModi55ICogdy56IC0gdi56ICogdy55LCB2LnogKiB3LnggLSB2LnggKiB3LnosIHYueCAqIHcueSAtIHYueSAqIHcueCk7XG59O1xuXG5WZWMzLmFkZCA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICByZXR1cm4gbmV3IFZlYzModi54ICsgdy54LCB2LnkgKyB3LnksIHYueiArIHcueik7XG59O1xuXG5WZWMzLnN1YiA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICByZXR1cm4gbmV3IFZlYzModi54IC0gdy54LCB2LnkgLSB3LnksIHYueiAtIHcueik7XG59O1xuXG5WZWMzLm11bCA9IGZ1bmN0aW9uKHYsIG0pIHtcbiAgICByZXR1cm4gbmV3IFZlYzMobSAqIHYueCwgbSAqIHYueSwgbSAqIHYueik7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzMubmVnID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBuZXcgVmVjMygtdi54LCAtdi55LCAtdi56KTtcbn07XG5cblxufSx7XCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9NYXRoXCI6MTh9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVsb2NpdHk7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4vVmVjMlwiKTtcblxuLyoqXG4gKiBAcHJvcCB7VmVjMn0gdiBsaW5lYXJcbiAqIEBwcm9wIHtmbG9hdH0gdyBhbmd1bGFyXG4gKi9cbmZ1bmN0aW9uIFZlbG9jaXR5KCkge1xuICAgIHRoaXMudiA9IFZlYzIuemVybygpO1xuICAgIHRoaXMudyA9IDA7XG59XG5cblxufSx7XCIuL1ZlYzJcIjoyM31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxuZXhwb3J0cy50b1N0cmluZyA9IGZ1bmN0aW9uKG5ld2xpbmUpIHtcbiAgICBuZXdsaW5lID0gdHlwZW9mIG5ld2xpbmUgPT09IFwic3RyaW5nXCIgPyBuZXdsaW5lIDogXCJcXG5cIjtcbiAgICB2YXIgc3RyaW5nID0gXCJcIjtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHRoaXNbbmFtZV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBuYW1lICsgXCI6IFwiICsgdGhpc1tuYW1lXSArIG5ld2xpbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblxufSx7fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlSm9pbnQ7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL2NyZWF0ZVwiKTtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBWZWMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMzXCIpO1xuXG52YXIgTWF0MjIgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDIyXCIpO1xuXG52YXIgTWF0MzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDMzXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBTd2VlcCA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3dlZXBcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFZlbG9jaXR5ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWxvY2l0eVwiKTtcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Qb3NpdGlvblwiKTtcblxudmFyIEpvaW50ID0gcmVxdWlyZShcIi4uL0pvaW50XCIpO1xuXG5EaXN0YW5jZUpvaW50LlRZUEUgPSBcImRpc3RhbmNlLWpvaW50XCI7XG5cbkRpc3RhbmNlSm9pbnQuX3N1cGVyID0gSm9pbnQ7XG5cbkRpc3RhbmNlSm9pbnQucHJvdG90eXBlID0gY3JlYXRlKERpc3RhbmNlSm9pbnQuX3N1cGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGlzdGFuY2VKb2ludERlZlxuICpcbiAqIERpc3RhbmNlIGpvaW50IGRlZmluaXRpb24uIFRoaXMgcmVxdWlyZXMgZGVmaW5pbmcgYW4gYW5jaG9yIHBvaW50IG9uIGJvdGhcbiAqIGJvZGllcyBhbmQgdGhlIG5vbi16ZXJvIGxlbmd0aCBvZiB0aGUgZGlzdGFuY2Ugam9pbnQuIFRoZSBkZWZpbml0aW9uIHVzZXNcbiAqIGxvY2FsIGFuY2hvciBwb2ludHMgc28gdGhhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIGNhbiB2aW9sYXRlIHRoZVxuICogY29uc3RyYWludCBzbGlnaHRseS4gVGhpcyBoZWxwcyB3aGVuIHNhdmluZyBhbmQgbG9hZGluZyBhIGdhbWUuIFdhcm5pbmc6IERvXG4gKiBub3QgdXNlIGEgemVybyBvciBzaG9ydCBsZW5ndGguXG4gKiBcbiAqIEBwcm9wIHtmbG9hdH0gZnJlcXVlbmN5SHogVGhlIG1hc3Mtc3ByaW5nLWRhbXBlciBmcmVxdWVuY3kgaW4gSGVydHouIEEgdmFsdWVcbiAqICAgICAgIG9mIDAgZGlzYWJsZXMgc29mdG5lc3MuXG4gKiBAcHJvcCB7ZmxvYXR9IGRhbXBpbmdSYXRpbyBUaGUgZGFtcGluZyByYXRpby4gMCA9IG5vIGRhbXBpbmcsIDEgPSBjcml0aWNhbFxuICogICAgICAgZGFtcGluZy5cbiAqXG4gKiBAcHJvcCB7VmVjMn0gZGVmLmxvY2FsQW5jaG9yQSBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICogQHByb3Age1ZlYzJ9IGRlZi5sb2NhbEFuY2hvckIgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAqIEBwcm9wIHtudW1iZXJ9IGRlZi5sZW5ndGggRGlzdGFuY2UgbGVuZ3RoLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gICAgZnJlcXVlbmN5SHo6IDAsXG4gICAgZGFtcGluZ1JhdGlvOiAwXG59O1xuXG4vKipcbiAqIEEgZGlzdGFuY2Ugam9pbnQgY29uc3RyYWlucyB0d28gcG9pbnRzIG9uIHR3byBib2RpZXMgdG8gcmVtYWluIGF0IGEgZml4ZWRcbiAqIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gWW91IGNhbiB2aWV3IHRoaXMgYXMgYSBtYXNzbGVzcywgcmlnaWQgcm9kLlxuICpcbiAqIEBwYXJhbSB7RGlzdGFuY2VKb2ludERlZn0gZGVmXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge1ZlYzJ9IGFuY2hvckEgQW5jaG9yIEEgaW4gZ2xvYmFsIGNvb3JkaW5hdGlvbi5cbiAqIEBwYXJhbSB7VmVjMn0gYW5jaG9yQiBBbmNob3IgQiBpbiBnbG9iYWwgY29vcmRpbmF0aW9uLlxuICovXG5mdW5jdGlvbiBEaXN0YW5jZUpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3JBLCBhbmNob3JCKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERpc3RhbmNlSm9pbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGlzdGFuY2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yQSwgYW5jaG9yQik7XG4gICAgfVxuICAgIC8vIG9yZGVyIG9mIGNvbnN0cnVjdG9yIGFyZ3VtZW50cyBpcyBjaGFuZ2VkIGluIHYwLjJcbiAgICBpZiAoYm9keUIgJiYgYW5jaG9yQSAmJiBcIm1fdHlwZVwiIGluIGFuY2hvckEgJiYgXCJ4XCIgaW4gYm9keUIgJiYgXCJ5XCIgaW4gYm9keUIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBib2R5QjtcbiAgICAgICAgYm9keUIgPSBhbmNob3JBO1xuICAgICAgICBhbmNob3JBID0gdGVtcDtcbiAgICB9XG4gICAgZGVmID0gb3B0aW9ucyhkZWYsIERFRkFVTFRTKTtcbiAgICBKb2ludC5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKTtcbiAgICBib2R5QSA9IHRoaXMubV9ib2R5QTtcbiAgICBib2R5QiA9IHRoaXMubV9ib2R5QjtcbiAgICB0aGlzLm1fdHlwZSA9IERpc3RhbmNlSm9pbnQuVFlQRTtcbiAgICAvLyBTb2x2ZXIgc2hhcmVkXG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvckEgPyBib2R5QS5nZXRMb2NhbFBvaW50KGFuY2hvckEpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLnplcm8oKTtcbiAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gYW5jaG9yQiA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yQikgOiBkZWYubG9jYWxBbmNob3JCIHx8IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9sZW5ndGggPSBNYXRoLmlzRmluaXRlKGRlZi5sZW5ndGgpID8gZGVmLmxlbmd0aCA6IFZlYzIuZGlzdGFuY2UoYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKSwgYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKSk7XG4gICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gZGVmLmZyZXF1ZW5jeUh6O1xuICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgIHRoaXMubV9pbXB1bHNlID0gMDtcbiAgICB0aGlzLm1fZ2FtbWEgPSAwO1xuICAgIHRoaXMubV9iaWFzID0gMDtcbiAgICAvLyBTb2x2ZXIgdGVtcFxuICAgIHRoaXMubV91O1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9yQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2ludk1hc3NBO1xuICAgIHRoaXMubV9pbnZNYXNzQjtcbiAgICB0aGlzLm1faW52SUE7XG4gICAgdGhpcy5tX2ludklCO1xuICAgIHRoaXMubV9tYXNzO1xufVxuXG4vKipcbiAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gKi9cbkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JBO1xufTtcblxuLyoqXG4gKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICovXG5EaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbn07XG5cbi8qKlxuICogU2V0L2dldCB0aGUgbmF0dXJhbCBsZW5ndGguIE1hbmlwdWxhdGluZyB0aGUgbGVuZ3RoIGNhbiBsZWFkIHRvIG5vbi1waHlzaWNhbFxuICogYmVoYXZpb3Igd2hlbiB0aGUgZnJlcXVlbmN5IGlzIHplcm8uXG4gKi9cbkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHRoaXMubV9sZW5ndGggPSBsZW5ndGg7XG59O1xuXG5EaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xlbmd0aDtcbn07XG5cbkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uKGh6KSB7XG4gICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gaHo7XG59O1xuXG5EaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRGcmVxdWVuY3kgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xufTtcblxuRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuc2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24ocmF0aW8pIHtcbiAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gcmF0aW87XG59O1xuXG5EaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbn07XG5cbkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG59O1xuXG5EaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xufTtcblxuRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBWZWMyLm11bCh0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3UpLm11bChpbnZfZHQpO1xufTtcblxuRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbihpbnZfZHQpIHtcbiAgICByZXR1cm4gMDtcbn07XG5cbkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgIHRoaXMubV91ID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHRoaXMubV9yQiksIFZlYzIuYWRkKGNBLCB0aGlzLm1fckEpKTtcbiAgICAvLyBIYW5kbGUgc2luZ3VsYXJpdHkuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubV91Lmxlbmd0aCgpO1xuICAgIGlmIChsZW5ndGggPiBTZXR0aW5ncy5saW5lYXJTbG9wKSB7XG4gICAgICAgIHRoaXMubV91Lm11bCgxIC8gbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1fdS5zZXQoMCwgMCk7XG4gICAgfVxuICAgIHZhciBjckF1ID0gVmVjMi5jcm9zcyh0aGlzLm1fckEsIHRoaXMubV91KTtcbiAgICB2YXIgY3JCdSA9IFZlYzIuY3Jvc3ModGhpcy5tX3JCLCB0aGlzLm1fdSk7XG4gICAgdmFyIGludk1hc3MgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBjckF1ICogY3JBdSArIHRoaXMubV9pbnZNYXNzQiArIHRoaXMubV9pbnZJQiAqIGNyQnUgKiBjckJ1O1xuICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cbiAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMCA/IDEgLyBpbnZNYXNzIDogMDtcbiAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMCkge1xuICAgICAgICB2YXIgQyA9IGxlbmd0aCAtIHRoaXMubV9sZW5ndGg7XG4gICAgICAgIC8vIEZyZXF1ZW5jeVxuICAgICAgICB2YXIgb21lZ2EgPSAyICogTWF0aC5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejtcbiAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxuICAgICAgICB2YXIgZCA9IDIgKiB0aGlzLm1fbWFzcyAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcbiAgICAgICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xuICAgICAgICB2YXIgayA9IHRoaXMubV9tYXNzICogb21lZ2EgKiBvbWVnYTtcbiAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcbiAgICAgICAgdmFyIGggPSBzdGVwLmR0O1xuICAgICAgICB0aGlzLm1fZ2FtbWEgPSBoICogKGQgKyBoICogayk7XG4gICAgICAgIHRoaXMubV9nYW1tYSA9IHRoaXMubV9nYW1tYSAhPSAwID8gMSAvIHRoaXMubV9nYW1tYSA6IDA7XG4gICAgICAgIHRoaXMubV9iaWFzID0gQyAqIGggKiBrICogdGhpcy5tX2dhbW1hO1xuICAgICAgICBpbnZNYXNzICs9IHRoaXMubV9nYW1tYTtcbiAgICAgICAgdGhpcy5tX21hc3MgPSBpbnZNYXNzICE9IDAgPyAxIC8gaW52TWFzcyA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2dhbW1hID0gMDtcbiAgICAgICAgdGhpcy5tX2JpYXMgPSAwO1xuICAgIH1cbiAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgLy8gU2NhbGUgdGhlIGltcHVsc2UgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICB2YXIgUCA9IFZlYzIubXVsKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdSk7XG4gICAgICAgIHZBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgICAgICB3QSAtPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCk7XG4gICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldCh2QSk7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0KHZCKTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5EaXN0YW5jZUpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcbiAgICB2YXIgdnBBID0gVmVjMi5hZGQodkEsIFZlYzIuY3Jvc3Mod0EsIHRoaXMubV9yQSkpO1xuICAgIHZhciB2cEIgPSBWZWMyLmFkZCh2QiwgVmVjMi5jcm9zcyh3QiwgdGhpcy5tX3JCKSk7XG4gICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fdSwgdnBCKSAtIFZlYzIuZG90KHRoaXMubV91LCB2cEEpO1xuICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogKENkb3QgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlKTtcbiAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgIHZhciBQID0gVmVjMi5tdWwoaW1wdWxzZSwgdGhpcy5tX3UpO1xuICAgIHZBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgIHdBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3ModGhpcy5tX3JBLCBQKTtcbiAgICB2Qi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCk7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXQodkEpO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldCh2Qik7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHBvc2l0aW9uIGNvcnJlY3Rpb24gZm9yIHNvZnQgZGlzdGFuY2UgY29uc3RyYWludHMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgIHZhciByQSA9IFJvdC5tdWxTdWIocUEsIHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpO1xuICAgIHZhciByQiA9IFJvdC5tdWxTdWIocUIsIHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpO1xuICAgIHZhciB1ID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHJCKSwgVmVjMi5hZGQoY0EsIHJBKSk7XG4gICAgdmFyIGxlbmd0aCA9IHUubm9ybWFsaXplKCk7XG4gICAgdmFyIEMgPSBsZW5ndGggLSB0aGlzLm1fbGVuZ3RoO1xuICAgIEMgPSBNYXRoLmNsYW1wKEMsIC1TZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uLCBTZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzcyAqIEM7XG4gICAgdmFyIFAgPSBWZWMyLm11bChpbXB1bHNlLCB1KTtcbiAgICBjQS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICBhQSAtPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzKHJBLCBQKTtcbiAgICBjQi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICBhQiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzKHJCLCBQKTtcbiAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldChjQSk7XG4gICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMuc2V0KGNCKTtcbiAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgcmV0dXJuIE1hdGguYWJzKEMpIDwgU2V0dGluZ3MubGluZWFyU2xvcDtcbn07XG5cblxufSx7XCIuLi9Kb2ludFwiOjUsXCIuLi9TZXR0aW5nc1wiOjcsXCIuLi9jb21tb24vTWF0MjJcIjoxNixcIi4uL2NvbW1vbi9NYXQzM1wiOjE3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4uL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi4vdXRpbC9jcmVhdGVcIjo1MSxcIi4uL3V0aWwvb3B0aW9uc1wiOjUyfV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyaWN0aW9uSm9pbnQ7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL2NyZWF0ZVwiKTtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBWZWMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMzXCIpO1xuXG52YXIgTWF0MjIgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDIyXCIpO1xuXG52YXIgTWF0MzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDMzXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBTd2VlcCA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3dlZXBcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFZlbG9jaXR5ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWxvY2l0eVwiKTtcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Qb3NpdGlvblwiKTtcblxudmFyIEpvaW50ID0gcmVxdWlyZShcIi4uL0pvaW50XCIpO1xuXG5GcmljdGlvbkpvaW50LlRZUEUgPSBcImZyaWN0aW9uLWpvaW50XCI7XG5cbkZyaWN0aW9uSm9pbnQuX3N1cGVyID0gSm9pbnQ7XG5cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlID0gY3JlYXRlKEZyaWN0aW9uSm9pbnQuX3N1cGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRnJpY3Rpb25Kb2ludERlZlxuICpcbiAqIEZyaWN0aW9uIGpvaW50IGRlZmluaXRpb24uXG4gKiBcbiAqIEBwcm9wIHtmbG9hdH0gbWF4Rm9yY2UgVGhlIG1heGltdW0gZnJpY3Rpb24gZm9yY2UgaW4gTi5cbiAqIEBwcm9wIHtmbG9hdH0gbWF4VG9ycXVlIFRoZSBtYXhpbXVtIGZyaWN0aW9uIHRvcnF1ZSBpbiBOLW0uXG4gKlxuICogQHByb3Age1ZlYzJ9IGxvY2FsQW5jaG9yQSBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICogQHByb3Age1ZlYzJ9IGxvY2FsQW5jaG9yQiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gICAgbWF4Rm9yY2U6IDAsXG4gICAgbWF4VG9ycXVlOiAwXG59O1xuXG4vKipcbiAqIEZyaWN0aW9uIGpvaW50LiBUaGlzIGlzIHVzZWQgZm9yIHRvcC1kb3duIGZyaWN0aW9uLiBJdCBwcm92aWRlcyAyRFxuICogdHJhbnNsYXRpb25hbCBmcmljdGlvbiBhbmQgYW5ndWxhciBmcmljdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0ZyaWN0aW9uSm9pbnREZWZ9IGRlZlxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtWZWMyfSBhbmNob3IgQW5jaG9yIGluIGdsb2JhbCBjb29yZGluYXRpb24uXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGcmljdGlvbkpvaW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyaWN0aW9uSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgfVxuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgSm9pbnQuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgYm9keUEgPSB0aGlzLm1fYm9keUE7XG4gICAgYm9keUIgPSB0aGlzLm1fYm9keUI7XG4gICAgdGhpcy5tX3R5cGUgPSBGcmljdGlvbkpvaW50LlRZUEU7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCk7XG4gICAgLy8gU29sdmVyIHNoYXJlZFxuICAgIHRoaXMubV9saW5lYXJJbXB1bHNlID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMDtcbiAgICB0aGlzLm1fbWF4Rm9yY2UgPSBkZWYubWF4Rm9yY2U7XG4gICAgdGhpcy5tX21heFRvcnF1ZSA9IGRlZi5tYXhUb3JxdWU7XG4gICAgLy8gU29sdmVyIHRlbXBcbiAgICB0aGlzLm1fckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9yQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2ludk1hc3NBO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludk1hc3NCO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludklBO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludklCO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2xpbmVhck1hc3M7XG4gICAgLy8gTWF0MjJcbiAgICB0aGlzLm1fYW5ndWxhck1hc3M7XG59XG5cbi8qKlxuICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqL1xuRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG59O1xuXG4vKipcbiAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gKi9cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gZm9yY2UgaW4gTi5cbiAqL1xuRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChNYXRoLmlzRmluaXRlKGZvcmNlKSAmJiBmb3JjZSA+PSAwKTtcbiAgICB0aGlzLm1fbWF4Rm9yY2UgPSBmb3JjZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIGZvcmNlIGluIE4uXG4gKi9cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldE1heEZvcmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tYXhGb3JjZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIHRvcnF1ZSBpbiBOKm0uXG4gKi9cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChNYXRoLmlzRmluaXRlKHRvcnF1ZSkgJiYgdG9ycXVlID49IDApO1xuICAgIHRoaXMubV9tYXhUb3JxdWUgPSB0b3JxdWU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4aW11bSBmcmljdGlvbiB0b3JxdWUgaW4gTiptLlxuICovXG5GcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRNYXhUb3JxdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX21heFRvcnF1ZTtcbn07XG5cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG59O1xuXG5GcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xufTtcblxuRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBWZWMyLm11bChpbnZfZHQsIHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbn07XG5cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9hbmd1bGFySW1wdWxzZTtcbn07XG5cbkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKSwgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXG4gICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3XVxuICAgIC8vIFsgMCAtMSAwIDFdXG4gICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXG4gICAgLy8gTWF0bGFiXG4gICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIC1yMXkqaUEtcjJ5KmlCXVxuICAgIC8vIFsgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsIHIxeCppQStyMngqaUJdXG4gICAgLy8gWyAtcjF5KmlBLXIyeSppQiwgcjF4KmlBK3IyeCppQiwgaUEraUJdXG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBLCBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQSwgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgIEsuZXgueCA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9yQS55ICogdGhpcy5tX3JBLnkgKyBpQiAqIHRoaXMubV9yQi55ICogdGhpcy5tX3JCLnk7XG4gICAgSy5leC55ID0gLWlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueSAtIGlCICogdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueTtcbiAgICBLLmV5LnggPSBLLmV4Lnk7XG4gICAgSy5leS55ID0gbUEgKyBtQiArIGlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueCArIGlCICogdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueDtcbiAgICB0aGlzLm1fbGluZWFyTWFzcyA9IEsuZ2V0SW52ZXJzZSgpO1xuICAgIHRoaXMubV9hbmd1bGFyTWFzcyA9IGlBICsgaUI7XG4gICAgaWYgKHRoaXMubV9hbmd1bGFyTWFzcyA+IDApIHtcbiAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gMSAvIHRoaXMubV9hbmd1bGFyTWFzcztcbiAgICB9XG4gICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9saW5lYXJJbXB1bHNlLngsIHRoaXMubV9saW5lYXJJbXB1bHNlLnkpO1xuICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLnNldFplcm8oKTtcbiAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMDtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBLCBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQSwgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgaCA9IHN0ZXAuZHQ7XG4gICAgLy8gZmxvYXRcbiAgICAvLyBTb2x2ZSBhbmd1bGFyIGZyaWN0aW9uXG4gICAge1xuICAgICAgICB2YXIgQ2RvdCA9IHdCIC0gd0E7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9hbmd1bGFyTWFzcyAqIENkb3Q7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IGggKiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgPSBNYXRoLmNsYW1wKHRoaXMubV9hbmd1bGFySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcbiAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgIHdBIC09IGlBICogaW1wdWxzZTtcbiAgICAgICAgd0IgKz0gaUIgKiBpbXB1bHNlO1xuICAgIH1cbiAgICAvLyBTb2x2ZSBsaW5lYXIgZnJpY3Rpb25cbiAgICB7XG4gICAgICAgIHZhciBDZG90ID0gVmVjMi5zdWIoVmVjMi5hZGQodkIsIFZlYzIuY3Jvc3Mod0IsIHRoaXMubV9yQikpLCBWZWMyLmFkZCh2QSwgVmVjMi5jcm9zcyh3QSwgdGhpcy5tX3JBKSkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciBpbXB1bHNlID0gVmVjMi5uZWcoTWF0MjIubXVsVmVjMih0aGlzLm1fbGluZWFyTWFzcywgQ2RvdCkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2xpbmVhckltcHVsc2U7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IGggKiB0aGlzLm1fbWF4Rm9yY2U7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIGlmICh0aGlzLm1fbGluZWFySW1wdWxzZS5sZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2Uubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5tdWwobWF4SW1wdWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW1wdWxzZSA9IFZlYzIuc3ViKHRoaXMubV9saW5lYXJJbXB1bHNlLCBvbGRJbXB1bHNlKTtcbiAgICAgICAgdkEuc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzKHRoaXMubV9yQSwgaW1wdWxzZSk7XG4gICAgICAgIHZCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zcyh0aGlzLm1fckIsIGltcHVsc2UpO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5GcmljdGlvbkpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbn0se1wiLi4vSm9pbnRcIjo1LFwiLi4vU2V0dGluZ3NcIjo3LFwiLi4vY29tbW9uL01hdDIyXCI6MTYsXCIuLi9jb21tb24vTWF0MzNcIjoxNyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUG9zaXRpb25cIjoxOSxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9Td2VlcFwiOjIxLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL2NvbW1vbi9WZWMzXCI6MjQsXCIuLi9jb21tb24vVmVsb2NpdHlcIjoyNSxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuLi91dGlsL2NyZWF0ZVwiOjUxLFwiLi4vdXRpbC9vcHRpb25zXCI6NTJ9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VhckpvaW50O1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgb3B0aW9ucyA9IHJlcXVpcmUoXCIuLi91dGlsL29wdGlvbnNcIik7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjM1wiKTtcblxudmFyIE1hdDIyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQyMlwiKTtcblxudmFyIE1hdDMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQzM1wiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi4vY29tbW9uL1N3ZWVwXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWxvY2l0eSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vUG9zaXRpb25cIik7XG5cbnZhciBKb2ludCA9IHJlcXVpcmUoXCIuLi9Kb2ludFwiKTtcblxudmFyIFJldm9sdXRlSm9pbnQgPSByZXF1aXJlKFwiLi9SZXZvbHV0ZUpvaW50XCIpO1xuXG52YXIgUHJpc21hdGljSm9pbnQgPSByZXF1aXJlKFwiLi9QcmlzbWF0aWNKb2ludFwiKTtcblxuR2VhckpvaW50LlRZUEUgPSBcImdlYXItam9pbnRcIjtcblxuR2VhckpvaW50Ll9zdXBlciA9IEpvaW50O1xuXG5HZWFySm9pbnQucHJvdG90eXBlID0gY3JlYXRlKEdlYXJKb2ludC5fc3VwZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHZWFySm9pbnREZWZcbiAqXG4gKiBHZWFyIGpvaW50IGRlZmluaXRpb24uXG4gKlxuICogQHByb3Age2Zsb2F0fSByYXRpbyBUaGUgZ2VhciByYXRpby4gU2VlIEdlYXJKb2ludCBmb3IgZXhwbGFuYXRpb24uXG4gKlxuICogQHByb3Age1Jldm9sdXRlSm9pbnR8UHJpc21hdGljSm9pbnR9IGpvaW50MSBUaGUgZmlyc3QgcmV2b2x1dGUvcHJpc21hdGljXG4gKiAgICAgICAgICBqb2ludCBhdHRhY2hlZCB0byB0aGUgZ2VhciBqb2ludC5cbiAqIEBwcm9wIHtQcmlzbWF0aWNKb2ludHxSZXZvbHV0ZUpvaW50fSBqb2ludDIgVGhlIHNlY29uZCBwcmlzbWF0aWMvcmV2b2x1dGVcbiAqICAgICAgICAgIGpvaW50IGF0dGFjaGVkIHRvIHRoZSBnZWFyIGpvaW50LlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gICAgcmF0aW86IDFcbn07XG5cbi8qKlxuICogQSBnZWFyIGpvaW50IGlzIHVzZWQgdG8gY29ubmVjdCB0d28gam9pbnRzIHRvZ2V0aGVyLiBFaXRoZXIgam9pbnQgY2FuIGJlIGFcbiAqIHJldm9sdXRlIG9yIHByaXNtYXRpYyBqb2ludC4gWW91IHNwZWNpZnkgYSBnZWFyIHJhdGlvIHRvIGJpbmQgdGhlIG1vdGlvbnNcbiAqIHRvZ2V0aGVyOiBjb29yZGluYXRlMSArIHJhdGlvICogY29vcmRpbmF0ZTIgPSBjb25zdGFudFxuICogXG4gKiBUaGUgcmF0aW8gY2FuIGJlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlLiBJZiBvbmUgam9pbnQgaXMgYSByZXZvbHV0ZSBqb2ludCBhbmRcbiAqIHRoZSBvdGhlciBqb2ludCBpcyBhIHByaXNtYXRpYyBqb2ludCwgdGhlbiB0aGUgcmF0aW8gd2lsbCBoYXZlIHVuaXRzIG9mXG4gKiBsZW5ndGggb3IgdW5pdHMgb2YgMS9sZW5ndGguIFdhcm5pbmc6IFlvdSBoYXZlIHRvIG1hbnVhbGx5IGRlc3Ryb3kgdGhlIGdlYXJcbiAqIGpvaW50IGlmIGpvaW50MSBvciBqb2ludDIgaXMgZGVzdHJveWVkLlxuICogXG4gKiBUaGlzIGRlZmluaXRpb24gcmVxdWlyZXMgdHdvIGV4aXN0aW5nIHJldm9sdXRlIG9yIHByaXNtYXRpYyBqb2ludHMgKGFueVxuICogY29tYmluYXRpb24gd2lsbCB3b3JrKS5cbiAqXG4gKiBAcGFyYW0ge0dlYXJKb2ludERlZn0gZGVmXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIEdlYXJKb2ludChkZWYsIGJvZHlBLCBib2R5Qiwgam9pbnQxLCBqb2ludDIsIHJhdGlvKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdlYXJKb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZWFySm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGpvaW50MSwgam9pbnQyLCByYXRpbyk7XG4gICAgfVxuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgSm9pbnQuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgYm9keUEgPSB0aGlzLm1fYm9keUE7XG4gICAgYm9keUIgPSB0aGlzLm1fYm9keUI7XG4gICAgdGhpcy5tX3R5cGUgPSBHZWFySm9pbnQuVFlQRTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoam9pbnQxLm1fdHlwZSA9PT0gUmV2b2x1dGVKb2ludC5UWVBFIHx8IGpvaW50MS5tX3R5cGUgPT09IFByaXNtYXRpY0pvaW50LlRZUEUpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChqb2ludDIubV90eXBlID09PSBSZXZvbHV0ZUpvaW50LlRZUEUgfHwgam9pbnQyLm1fdHlwZSA9PT0gUHJpc21hdGljSm9pbnQuVFlQRSk7XG4gICAgdGhpcy5tX2pvaW50MSA9IGpvaW50MSA/IGpvaW50MSA6IGRlZi5qb2ludDE7XG4gICAgdGhpcy5tX2pvaW50MiA9IGpvaW50MiA/IGpvaW50MiA6IGRlZi5qb2ludDI7XG4gICAgdGhpcy5tX3JhdGlvID0gTWF0aC5pc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IGRlZi5yYXRpbztcbiAgICB0aGlzLm1fdHlwZTEgPSB0aGlzLm1fam9pbnQxLmdldFR5cGUoKTtcbiAgICB0aGlzLm1fdHlwZTIgPSB0aGlzLm1fam9pbnQyLmdldFR5cGUoKTtcbiAgICAvLyBqb2ludDEgY29ubmVjdHMgYm9keSBBIHRvIGJvZHkgQ1xuICAgIC8vIGpvaW50MiBjb25uZWN0cyBib2R5IEIgdG8gYm9keSBEXG4gICAgdmFyIGNvb3JkaW5hdGVBLCBjb29yZGluYXRlQjtcbiAgICAvLyBmbG9hdFxuICAgIC8vIFRPRE9fRVJJTiB0aGVyZSBtaWdodCBiZSBzb21lIHByb2JsZW0gd2l0aCB0aGUgam9pbnQgZWRnZXMgaW4gSm9pbnQuXG4gICAgdGhpcy5tX2JvZHlDID0gdGhpcy5tX2pvaW50MS5nZXRCb2R5QSgpO1xuICAgIHRoaXMubV9ib2R5QSA9IHRoaXMubV9qb2ludDEuZ2V0Qm9keUIoKTtcbiAgICAvLyBHZXQgZ2VvbWV0cnkgb2Ygam9pbnQxXG4gICAgdmFyIHhmQSA9IHRoaXMubV9ib2R5QS5tX3hmO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmE7XG4gICAgdmFyIHhmQyA9IHRoaXMubV9ib2R5Qy5tX3hmO1xuICAgIHZhciBhQyA9IHRoaXMubV9ib2R5Qy5tX3N3ZWVwLmE7XG4gICAgaWYgKHRoaXMubV90eXBlMSA9PT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgIHZhciByZXZvbHV0ZSA9IHRoaXMubV9qb2ludDE7XG4gICAgICAgIC8vIFJldm9sdXRlSm9pbnRcbiAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQyA9IHJldm9sdXRlLm1fbG9jYWxBbmNob3JBO1xuICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBID0gcmV2b2x1dGUubV9sb2NhbEFuY2hvckI7XG4gICAgICAgIHRoaXMubV9yZWZlcmVuY2VBbmdsZUEgPSByZXZvbHV0ZS5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICB0aGlzLm1fbG9jYWxBeGlzQyA9IFZlYzIuemVybygpO1xuICAgICAgICBjb29yZGluYXRlQSA9IGFBIC0gYUMgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGVBO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcmlzbWF0aWMgPSB0aGlzLm1fam9pbnQxO1xuICAgICAgICAvLyBQcmlzbWF0aWNKb2ludFxuICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JDID0gcHJpc21hdGljLm1fbG9jYWxBbmNob3JBO1xuICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBID0gcHJpc21hdGljLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICB0aGlzLm1fcmVmZXJlbmNlQW5nbGVBID0gcHJpc21hdGljLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgIHRoaXMubV9sb2NhbEF4aXNDID0gcHJpc21hdGljLm1fbG9jYWxYQXhpc0E7XG4gICAgICAgIHZhciBwQyA9IHRoaXMubV9sb2NhbEFuY2hvckM7XG4gICAgICAgIHZhciBwQSA9IFJvdC5tdWxUVmVjMih4ZkMucSwgVmVjMi5hZGQoUm90Lm11bCh4ZkEucSwgdGhpcy5tX2xvY2FsQW5jaG9yQSksIFZlYzIuc3ViKHhmQS5wLCB4ZkMucCkpKTtcbiAgICAgICAgY29vcmRpbmF0ZUEgPSBWZWMyLmRvdChwQSwgdGhpcy5tX2xvY2FsQXhpc0MpIC0gVmVjMi5kb3QocEMsIHRoaXMubV9sb2NhbEF4aXNDKTtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlEID0gdGhpcy5tX2pvaW50Mi5nZXRCb2R5QSgpO1xuICAgIHRoaXMubV9ib2R5QiA9IHRoaXMubV9qb2ludDIuZ2V0Qm9keUIoKTtcbiAgICAvLyBHZXQgZ2VvbWV0cnkgb2Ygam9pbnQyXG4gICAgdmFyIHhmQiA9IHRoaXMubV9ib2R5Qi5tX3hmO1xuICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmE7XG4gICAgdmFyIHhmRCA9IHRoaXMubV9ib2R5RC5tX3hmO1xuICAgIHZhciBhRCA9IHRoaXMubV9ib2R5RC5tX3N3ZWVwLmE7XG4gICAgaWYgKHRoaXMubV90eXBlMiA9PT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgIHZhciByZXZvbHV0ZSA9IHRoaXMubV9qb2ludDI7XG4gICAgICAgIC8vIFJldm9sdXRlSm9pbnRcbiAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yRCA9IHJldm9sdXRlLm1fbG9jYWxBbmNob3JBO1xuICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gcmV2b2x1dGUubV9sb2NhbEFuY2hvckI7XG4gICAgICAgIHRoaXMubV9yZWZlcmVuY2VBbmdsZUIgPSByZXZvbHV0ZS5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICB0aGlzLm1fbG9jYWxBeGlzRCA9IFZlYzIuemVybygpO1xuICAgICAgICBjb29yZGluYXRlQiA9IGFCIC0gYUQgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcmlzbWF0aWMgPSB0aGlzLm1fam9pbnQyO1xuICAgICAgICAvLyBQcmlzbWF0aWNKb2ludFxuICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JEID0gcHJpc21hdGljLm1fbG9jYWxBbmNob3JBO1xuICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gcHJpc21hdGljLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICB0aGlzLm1fcmVmZXJlbmNlQW5nbGVCID0gcHJpc21hdGljLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgIHRoaXMubV9sb2NhbEF4aXNEID0gcHJpc21hdGljLm1fbG9jYWxYQXhpc0E7XG4gICAgICAgIHZhciBwRCA9IHRoaXMubV9sb2NhbEFuY2hvckQ7XG4gICAgICAgIHZhciBwQiA9IFJvdC5tdWxUVmVjMih4ZkQucSwgVmVjMi5hZGQoUm90Lm11bCh4ZkIucSwgdGhpcy5tX2xvY2FsQW5jaG9yQiksIFZlYzIuc3ViKHhmQi5wLCB4ZkQucCkpKTtcbiAgICAgICAgY29vcmRpbmF0ZUIgPSBWZWMyLmRvdChwQiwgdGhpcy5tX2xvY2FsQXhpc0QpIC0gVmVjMi5kb3QocEQsIHRoaXMubV9sb2NhbEF4aXNEKTtcbiAgICB9XG4gICAgdGhpcy5tX2NvbnN0YW50ID0gY29vcmRpbmF0ZUEgKyB0aGlzLm1fcmF0aW8gKiBjb29yZGluYXRlQjtcbiAgICB0aGlzLm1faW1wdWxzZSA9IDA7XG4gICAgLy8gU29sdmVyIHRlbXBcbiAgICB0aGlzLm1fbGNBLCB0aGlzLm1fbGNCLCB0aGlzLm1fbGNDLCB0aGlzLm1fbGNEO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fbUEsIHRoaXMubV9tQiwgdGhpcy5tX21DLCB0aGlzLm1fbUQ7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faUEsIHRoaXMubV9pQiwgdGhpcy5tX2lDLCB0aGlzLm1faUQ7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fSnZBQywgdGhpcy5tX0p2QkQ7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9Kd0EsIHRoaXMubV9Kd0IsIHRoaXMubV9Kd0MsIHRoaXMubV9Kd0Q7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fbWFzcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGpvaW50LlxuICovXG5HZWFySm9pbnQucHJvdG90eXBlLmdldEpvaW50MSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fam9pbnQxO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlY29uZCBqb2ludC5cbiAqL1xuR2VhckpvaW50LnByb3RvdHlwZS5nZXRKb2ludDIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2pvaW50Mjtcbn07XG5cbi8qKlxuICogU2V0L0dldCB0aGUgZ2VhciByYXRpby5cbiAqL1xuR2VhckpvaW50LnByb3RvdHlwZS5zZXRSYXRpbyA9IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUocmF0aW8pKTtcbiAgICB0aGlzLm1fcmF0aW8gPSByYXRpbztcbn07XG5cbkdlYXJKb2ludC5wcm90b3R5cGUuZ2V0UmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3JhdGlvO1xufTtcblxuR2VhckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xufTtcblxuR2VhckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xufTtcblxuR2VhckpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIFZlYzIubXVsKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fSnZBQykubXVsKGludl9kdCk7XG59O1xuXG5HZWFySm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgdmFyIEwgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9Kd0E7XG4gICAgLy8gZmxvYXRcbiAgICByZXR1cm4gaW52X2R0ICogTDtcbn07XG5cbkdlYXJKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdGhpcy5tX2xjQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgIHRoaXMubV9sY0IgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1fbGNDID0gdGhpcy5tX2JvZHlDLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2xjRCA9IHRoaXMubV9ib2R5RC5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgIHRoaXMubV9tQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgdGhpcy5tX21CID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICB0aGlzLm1fbUMgPSB0aGlzLm1fYm9keUMubV9pbnZNYXNzO1xuICAgIHRoaXMubV9tRCA9IHRoaXMubV9ib2R5RC5tX2ludk1hc3M7XG4gICAgdGhpcy5tX2lBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICB0aGlzLm1faUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgIHRoaXMubV9pQyA9IHRoaXMubV9ib2R5Qy5tX2ludkk7XG4gICAgdGhpcy5tX2lEID0gdGhpcy5tX2JvZHlELm1faW52STtcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICB2YXIgYUMgPSB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QyA9IHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdDID0gdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudztcbiAgICB2YXIgYUQgPSB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2RCA9IHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdEID0gdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudztcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICB2YXIgcUMgPSBSb3QubmVvKGFDKTtcbiAgICB2YXIgcUQgPSBSb3QubmVvKGFEKTtcbiAgICB0aGlzLm1fbWFzcyA9IDA7XG4gICAgaWYgKHRoaXMubV90eXBlMSA9PSBSZXZvbHV0ZUpvaW50LlRZUEUpIHtcbiAgICAgICAgdGhpcy5tX0p2QUMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgdGhpcy5tX0p3QSA9IDE7XG4gICAgICAgIHRoaXMubV9Kd0MgPSAxO1xuICAgICAgICB0aGlzLm1fbWFzcyArPSB0aGlzLm1faUEgKyB0aGlzLm1faUM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHUgPSBSb3QubXVsVmVjMihxQywgdGhpcy5tX2xvY2FsQXhpc0MpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciByQyA9IFJvdC5tdWxTdWIocUMsIHRoaXMubV9sb2NhbEFuY2hvckMsIHRoaXMubV9sY0MpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciByQSA9IFJvdC5tdWxTdWIocUEsIHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sY0EpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHRoaXMubV9KdkFDID0gdTtcbiAgICAgICAgdGhpcy5tX0p3QyA9IFZlYzIuY3Jvc3MockMsIHUpO1xuICAgICAgICB0aGlzLm1fSndBID0gVmVjMi5jcm9zcyhyQSwgdSk7XG4gICAgICAgIHRoaXMubV9tYXNzICs9IHRoaXMubV9tQyArIHRoaXMubV9tQSArIHRoaXMubV9pQyAqIHRoaXMubV9Kd0MgKiB0aGlzLm1fSndDICsgdGhpcy5tX2lBICogdGhpcy5tX0p3QSAqIHRoaXMubV9Kd0E7XG4gICAgfVxuICAgIGlmICh0aGlzLm1fdHlwZTIgPT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgIHRoaXMubV9KdkJEID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIHRoaXMubV9Kd0IgPSB0aGlzLm1fcmF0aW87XG4gICAgICAgIHRoaXMubV9Kd0QgPSB0aGlzLm1fcmF0aW87XG4gICAgICAgIHRoaXMubV9tYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1faUIgKyB0aGlzLm1faUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB1ID0gUm90Lm11bFZlYzIocUQsIHRoaXMubV9sb2NhbEF4aXNEKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgckQgPSBSb3QubXVsU3ViKHFELCB0aGlzLm1fbG9jYWxBbmNob3JELCB0aGlzLm1fbGNEKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbGNCKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB0aGlzLm1fSnZCRCA9IFZlYzIubXVsKHRoaXMubV9yYXRpbywgdSk7XG4gICAgICAgIHRoaXMubV9Kd0QgPSB0aGlzLm1fcmF0aW8gKiBWZWMyLmNyb3NzKHJELCB1KTtcbiAgICAgICAgdGhpcy5tX0p3QiA9IHRoaXMubV9yYXRpbyAqIFZlYzIuY3Jvc3MockIsIHUpO1xuICAgICAgICB0aGlzLm1fbWFzcyArPSB0aGlzLm1fcmF0aW8gKiB0aGlzLm1fcmF0aW8gKiAodGhpcy5tX21EICsgdGhpcy5tX21CKSArIHRoaXMubV9pRCAqIHRoaXMubV9Kd0QgKiB0aGlzLm1fSndEICsgdGhpcy5tX2lCICogdGhpcy5tX0p3QiAqIHRoaXMubV9Kd0I7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgdGhpcy5tX21hc3MgPSB0aGlzLm1fbWFzcyA+IDAgPyAxIC8gdGhpcy5tX21hc3MgOiAwO1xuICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICB2QS5hZGRNdWwodGhpcy5tX21BICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkFDKTtcbiAgICAgICAgd0EgKz0gdGhpcy5tX2lBICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndBO1xuICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX21CICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICAgICAgd0IgKz0gdGhpcy5tX2lCICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndCO1xuICAgICAgICB2Qy5zdWJNdWwodGhpcy5tX21DICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkFDKTtcbiAgICAgICAgd0MgLT0gdGhpcy5tX2lDICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndDO1xuICAgICAgICB2RC5zdWJNdWwodGhpcy5tX21EICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICAgICAgd0QgLT0gdGhpcy5tX2lEICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndEO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9pbXB1bHNlID0gMDtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXQodkEpO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldCh2Qik7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgIHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LnYuc2V0KHZDKTtcbiAgICB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS53ID0gd0M7XG4gICAgdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudi5zZXQodkQpO1xuICAgIHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LncgPSB3RDtcbn07XG5cbkdlYXJKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHZDID0gdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0MgPSB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS53O1xuICAgIHZhciB2RCA9IHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdEID0gdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudztcbiAgICB2YXIgQ2RvdCA9IFZlYzIuZG90KHRoaXMubV9KdkFDLCB2QSkgLSBWZWMyLmRvdCh0aGlzLm1fSnZBQywgdkMpICsgVmVjMi5kb3QodGhpcy5tX0p2QkQsIHZCKSAtIFZlYzIuZG90KHRoaXMubV9KdkJELCB2RCk7XG4gICAgLy8gZmxvYXRcbiAgICBDZG90ICs9IHRoaXMubV9Kd0EgKiB3QSAtIHRoaXMubV9Kd0MgKiB3QyArICh0aGlzLm1fSndCICogd0IgLSB0aGlzLm1fSndEICogd0QpO1xuICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQ2RvdDtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgdkEuYWRkTXVsKHRoaXMubV9tQSAqIGltcHVsc2UsIHRoaXMubV9KdkFDKTtcbiAgICB3QSArPSB0aGlzLm1faUEgKiBpbXB1bHNlICogdGhpcy5tX0p3QTtcbiAgICB2Qi5hZGRNdWwodGhpcy5tX21CICogaW1wdWxzZSwgdGhpcy5tX0p2QkQpO1xuICAgIHdCICs9IHRoaXMubV9pQiAqIGltcHVsc2UgKiB0aGlzLm1fSndCO1xuICAgIHZDLnN1Yk11bCh0aGlzLm1fbUMgKiBpbXB1bHNlLCB0aGlzLm1fSnZBQyk7XG4gICAgd0MgLT0gdGhpcy5tX2lDICogaW1wdWxzZSAqIHRoaXMubV9Kd0M7XG4gICAgdkQuc3ViTXVsKHRoaXMubV9tRCAqIGltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICB3RCAtPSB0aGlzLm1faUQgKiBpbXB1bHNlICogdGhpcy5tX0p3RDtcbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldCh2QSk7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0KHZCKTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudi5zZXQodkMpO1xuICAgIHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LncgPSB3QztcbiAgICB0aGlzLm1fYm9keUQuY192ZWxvY2l0eS52LnNldCh2RCk7XG4gICAgdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudyA9IHdEO1xufTtcblxuR2VhckpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgY0MgPSB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQyA9IHRoaXMubV9ib2R5Qy5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIGNEID0gdGhpcy5tX2JvZHlELmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUQgPSB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5hO1xuICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgIHZhciBxQyA9IFJvdC5uZW8oYUMpO1xuICAgIHZhciBxRCA9IFJvdC5uZW8oYUQpO1xuICAgIHZhciBsaW5lYXJFcnJvciA9IDA7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgY29vcmRpbmF0ZUEsIGNvb3JkaW5hdGVCO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIEp2QUMsIEp2QkQ7XG4gICAgLy8gVmVjMlxuICAgIHZhciBKd0EsIEp3QiwgSndDLCBKd0Q7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgbWFzcyA9IDA7XG4gICAgLy8gZmxvYXRcbiAgICBpZiAodGhpcy5tX3R5cGUxID09IFJldm9sdXRlSm9pbnQuVFlQRSkge1xuICAgICAgICBKdkFDID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIEp3QSA9IDE7XG4gICAgICAgIEp3QyA9IDE7XG4gICAgICAgIG1hc3MgKz0gdGhpcy5tX2lBICsgdGhpcy5tX2lDO1xuICAgICAgICBjb29yZGluYXRlQSA9IGFBIC0gYUMgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGVBO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB1ID0gUm90Lm11bFZlYzIocUMsIHRoaXMubV9sb2NhbEF4aXNDKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgckMgPSBSb3QubXVsU3ViKHFDLCB0aGlzLm1fbG9jYWxBbmNob3JDLCB0aGlzLm1fbGNDKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgckEgPSBSb3QubXVsU3ViKHFBLCB0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbGNBKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICBKdkFDID0gdTtcbiAgICAgICAgSndDID0gVmVjMi5jcm9zcyhyQywgdSk7XG4gICAgICAgIEp3QSA9IFZlYzIuY3Jvc3MockEsIHUpO1xuICAgICAgICBtYXNzICs9IHRoaXMubV9tQyArIHRoaXMubV9tQSArIHRoaXMubV9pQyAqIEp3QyAqIEp3QyArIHRoaXMubV9pQSAqIEp3QSAqIEp3QTtcbiAgICAgICAgdmFyIHBDID0gVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQywgdGhpcy5tX2xjQyk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdmFyIHBBID0gUm90Lm11bFRWZWMyKHFDLCBWZWMyLmFkZChyQSwgVmVjMi5zdWIoY0EsIGNDKSkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIGNvb3JkaW5hdGVBID0gVmVjMi5kb3QoVmVjMi5zdWIocEEsIHBDKSwgdGhpcy5tX2xvY2FsQXhpc0MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tX3R5cGUyID09IFJldm9sdXRlSm9pbnQuVFlQRSkge1xuICAgICAgICBKdkJEID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIEp3QiA9IHRoaXMubV9yYXRpbztcbiAgICAgICAgSndEID0gdGhpcy5tX3JhdGlvO1xuICAgICAgICBtYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1faUIgKyB0aGlzLm1faUQpO1xuICAgICAgICBjb29yZGluYXRlQiA9IGFCIC0gYUQgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB1ID0gUm90Lm11bFZlYzIocUQsIHRoaXMubV9sb2NhbEF4aXNEKTtcbiAgICAgICAgdmFyIHJEID0gUm90Lm11bFN1YihxRCwgdGhpcy5tX2xvY2FsQW5jaG9yRCwgdGhpcy5tX2xjRCk7XG4gICAgICAgIHZhciByQiA9IFJvdC5tdWxTdWIocUIsIHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sY0IpO1xuICAgICAgICBKdkJEID0gVmVjMi5tdWwodGhpcy5tX3JhdGlvLCB1KTtcbiAgICAgICAgSndEID0gdGhpcy5tX3JhdGlvICogVmVjMi5jcm9zcyhyRCwgdSk7XG4gICAgICAgIEp3QiA9IHRoaXMubV9yYXRpbyAqIFZlYzIuY3Jvc3MockIsIHUpO1xuICAgICAgICBtYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1fbUQgKyB0aGlzLm1fbUIpICsgdGhpcy5tX2lEICogSndEICogSndEICsgdGhpcy5tX2lCICogSndCICogSndCO1xuICAgICAgICB2YXIgcEQgPSBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JELCB0aGlzLm1fbGNEKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgcEIgPSBSb3QubXVsVFZlYzIocUQsIFZlYzIuYWRkKHJCLCBWZWMyLnN1YihjQiwgY0QpKSk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgY29vcmRpbmF0ZUIgPSBWZWMyLmRvdChwQiwgdGhpcy5tX2xvY2FsQXhpc0QpIC0gVmVjMi5kb3QocEQsIHRoaXMubV9sb2NhbEF4aXNEKTtcbiAgICB9XG4gICAgdmFyIEMgPSBjb29yZGluYXRlQSArIHRoaXMubV9yYXRpbyAqIGNvb3JkaW5hdGVCIC0gdGhpcy5tX2NvbnN0YW50O1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGltcHVsc2UgPSAwO1xuICAgIC8vIGZsb2F0XG4gICAgaWYgKG1hc3MgPiAwKSB7XG4gICAgICAgIGltcHVsc2UgPSAtQyAvIG1hc3M7XG4gICAgfVxuICAgIGNBLmFkZE11bCh0aGlzLm1fbUEgKiBpbXB1bHNlLCBKdkFDKTtcbiAgICBhQSArPSB0aGlzLm1faUEgKiBpbXB1bHNlICogSndBO1xuICAgIGNCLmFkZE11bCh0aGlzLm1fbUIgKiBpbXB1bHNlLCBKdkJEKTtcbiAgICBhQiArPSB0aGlzLm1faUIgKiBpbXB1bHNlICogSndCO1xuICAgIGNDLnN1Yk11bCh0aGlzLm1fbUMgKiBpbXB1bHNlLCBKdkFDKTtcbiAgICBhQyAtPSB0aGlzLm1faUMgKiBpbXB1bHNlICogSndDO1xuICAgIGNELnN1Yk11bCh0aGlzLm1fbUQgKiBpbXB1bHNlLCBKdkJEKTtcbiAgICBhRCAtPSB0aGlzLm1faUQgKiBpbXB1bHNlICogSndEO1xuICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmMuc2V0KGNBKTtcbiAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXQoY0IpO1xuICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5jLnNldChjQyk7XG4gICAgdGhpcy5tX2JvZHlDLmNfcG9zaXRpb24uYSA9IGFDO1xuICAgIHRoaXMubV9ib2R5RC5jX3Bvc2l0aW9uLmMuc2V0KGNEKTtcbiAgICB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5hID0gYUQ7XG4gICAgLy8gVE9ET19FUklOIG5vdCBpbXBsZW1lbnRlZFxuICAgIHJldHVybiBsaW5lYXJFcnJvciA8IFNldHRpbmdzLmxpbmVhclNsb3A7XG59O1xuXG5cbn0se1wiLi4vSm9pbnRcIjo1LFwiLi4vU2V0dGluZ3NcIjo3LFwiLi4vY29tbW9uL01hdDIyXCI6MTYsXCIuLi9jb21tb24vTWF0MzNcIjoxNyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUG9zaXRpb25cIjoxOSxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9Td2VlcFwiOjIxLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL2NvbW1vbi9WZWMzXCI6MjQsXCIuLi9jb21tb24vVmVsb2NpdHlcIjoyNSxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuLi91dGlsL2NyZWF0ZVwiOjUxLFwiLi4vdXRpbC9vcHRpb25zXCI6NTIsXCIuL1ByaXNtYXRpY0pvaW50XCI6MzIsXCIuL1Jldm9sdXRlSm9pbnRcIjozNH1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3RvckpvaW50O1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgb3B0aW9ucyA9IHJlcXVpcmUoXCIuLi91dGlsL29wdGlvbnNcIik7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjM1wiKTtcblxudmFyIE1hdDIyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQyMlwiKTtcblxudmFyIE1hdDMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQzM1wiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi4vY29tbW9uL1N3ZWVwXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWxvY2l0eSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vUG9zaXRpb25cIik7XG5cbnZhciBKb2ludCA9IHJlcXVpcmUoXCIuLi9Kb2ludFwiKTtcblxuTW90b3JKb2ludC5UWVBFID0gXCJtb3Rvci1qb2ludFwiO1xuXG5Nb3RvckpvaW50Ll9zdXBlciA9IEpvaW50O1xuXG5Nb3RvckpvaW50LnByb3RvdHlwZSA9IGNyZWF0ZShNb3RvckpvaW50Ll9zdXBlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1vdG9ySm9pbnREZWZcbiAqXG4gKiBNb3RvciBqb2ludCBkZWZpbml0aW9uLlxuICogXG4gKiBAcHJvcCB7ZmxvYXR9IGFuZ3VsYXJPZmZzZXQgVGhlIGJvZHlCIGFuZ2xlIG1pbnVzIGJvZHlBIGFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcHJvcCB7ZmxvYXR9IG1heEZvcmNlIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE4uXG4gKiBAcHJvcCB7ZmxvYXR9IG1heFRvcnF1ZSBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTi1tLlxuICogQHByb3Age2Zsb2F0fSBjb3JyZWN0aW9uRmFjdG9yIFBvc2l0aW9uIGNvcnJlY3Rpb24gZmFjdG9yIGluIHRoZSByYW5nZSBbMCwxXS5cbiAqIEBwcm9wIHtWZWMyfSBsaW5lYXJPZmZzZXQgUG9zaXRpb24gb2YgYm9keUIgbWludXMgdGhlIHBvc2l0aW9uIG9mIGJvZHlBLCBpblxuICogICAgICAgYm9keUEncyBmcmFtZSwgaW4gbWV0ZXJzLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gICAgbWF4Rm9yY2U6IDEsXG4gICAgbWF4VG9ycXVlOiAxLFxuICAgIGNvcnJlY3Rpb25GYWN0b3I6IC4zXG59O1xuXG4vKipcbiAqIEEgbW90b3Igam9pbnQgaXMgdXNlZCB0byBjb250cm9sIHRoZSByZWxhdGl2ZSBtb3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzLiBBXG4gKiB0eXBpY2FsIHVzYWdlIGlzIHRvIGNvbnRyb2wgdGhlIG1vdmVtZW50IG9mIGEgZHluYW1pYyBib2R5IHdpdGggcmVzcGVjdCB0b1xuICogdGhlIGdyb3VuZC5cbiAqXG4gKiBAcGFyYW0ge01vdG9ySm9pbnREZWZ9IGRlZlxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBNb3RvckpvaW50KGRlZiwgYm9keUEsIGJvZHlCKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdG9ySm9pbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW90b3JKb2ludChkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgfVxuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgSm9pbnQuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgYm9keUEgPSB0aGlzLm1fYm9keUE7XG4gICAgYm9keUIgPSB0aGlzLm1fYm9keUI7XG4gICAgdGhpcy5tX3R5cGUgPSBNb3RvckpvaW50LlRZUEU7XG4gICAgdGhpcy5tX2xpbmVhck9mZnNldCA9IGRlZi5saW5lYXJPZmZzZXQgPyBkZWYubGluZWFyT2Zmc2V0IDogYm9keUEuZ2V0TG9jYWxQb2ludChib2R5Qi5nZXRQb3NpdGlvbigpKTtcbiAgICB2YXIgYW5nbGVBID0gYm9keUEuZ2V0QW5nbGUoKTtcbiAgICB2YXIgYW5nbGVCID0gYm9keUIuZ2V0QW5nbGUoKTtcbiAgICB0aGlzLm1fYW5ndWxhck9mZnNldCA9IGFuZ2xlQiAtIGFuZ2xlQTtcbiAgICB0aGlzLm1fbGluZWFySW1wdWxzZSA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IDA7XG4gICAgdGhpcy5tX21heEZvcmNlID0gZGVmLm1heEZvcmNlO1xuICAgIHRoaXMubV9tYXhUb3JxdWUgPSBkZWYubWF4VG9ycXVlO1xuICAgIHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yID0gZGVmLmNvcnJlY3Rpb25GYWN0b3I7XG4gICAgLy8gU29sdmVyIHRlbXBcbiAgICB0aGlzLm1fckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9yQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xpbmVhckVycm9yO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fYW5ndWxhckVycm9yO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludk1hc3NBO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludk1hc3NCO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludklBO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludklCO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2xpbmVhck1hc3M7XG4gICAgLy8gTWF0MjJcbiAgICB0aGlzLm1fYW5ndWxhck1hc3M7XG59XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIGZvcmNlIGluIE4uXG4gKi9cbk1vdG9ySm9pbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoTWF0aC5pc0Zpbml0ZShmb3JjZSkgJiYgZm9yY2UgPj0gMCk7XG4gICAgdGhpcy5tX21heEZvcmNlID0gZm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4aW11bSBmcmljdGlvbiBmb3JjZSBpbiBOLlxuICovXG5Nb3RvckpvaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBmcmljdGlvbiB0b3JxdWUgaW4gTiptLlxuICovXG5Nb3RvckpvaW50LnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoTWF0aC5pc0Zpbml0ZSh0b3JxdWUpICYmIHRvcnF1ZSA+PSAwKTtcbiAgICB0aGlzLm1fbWF4VG9ycXVlID0gdG9ycXVlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gdG9ycXVlIGluIE4qbS5cbiAqL1xuTW90b3JKb2ludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tYXhUb3JxdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcG9zaXRpb24gY29ycmVjdGlvbiBmYWN0b3IgaW4gdGhlIHJhbmdlIFswLDFdLlxuICovXG5Nb3RvckpvaW50LnByb3RvdHlwZS5zZXRDb3JyZWN0aW9uRmFjdG9yID0gZnVuY3Rpb24oZmFjdG9yKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUoZmFjdG9yKSAmJiAwIDw9IGZhY3RvciAmJiBmYWN0b3IgPD0gMSk7XG4gICAgdGhpcy5tX2NvcnJlY3Rpb25GYWN0b3IgPSBmYWN0b3I7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gY29ycmVjdGlvbiBmYWN0b3IgaW4gdGhlIHJhbmdlIFswLDFdLlxuICovXG5Nb3RvckpvaW50LnByb3RvdHlwZS5nZXRDb3JyZWN0aW9uRmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yO1xufTtcblxuLyoqXG4gKiBTZXQvZ2V0IHRoZSB0YXJnZXQgbGluZWFyIG9mZnNldCwgaW4gZnJhbWUgQSwgaW4gbWV0ZXJzLlxuICovXG5Nb3RvckpvaW50LnByb3RvdHlwZS5zZXRMaW5lYXJPZmZzZXQgPSBmdW5jdGlvbihsaW5lYXJPZmZzZXQpIHtcbiAgICBpZiAobGluZWFyT2Zmc2V0LnggIT0gdGhpcy5tX2xpbmVhck9mZnNldC54IHx8IGxpbmVhck9mZnNldC55ICE9IHRoaXMubV9saW5lYXJPZmZzZXQueSkge1xuICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgdGhpcy5tX2xpbmVhck9mZnNldCA9IGxpbmVhck9mZnNldDtcbiAgICB9XG59O1xuXG5Nb3RvckpvaW50LnByb3RvdHlwZS5nZXRMaW5lYXJPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xpbmVhck9mZnNldDtcbn07XG5cbi8qKlxuICogU2V0L2dldCB0aGUgdGFyZ2V0IGFuZ3VsYXIgb2Zmc2V0LCBpbiByYWRpYW5zLlxuICovXG5Nb3RvckpvaW50LnByb3RvdHlwZS5zZXRBbmd1bGFyT2Zmc2V0ID0gZnVuY3Rpb24oYW5ndWxhck9mZnNldCkge1xuICAgIGlmIChhbmd1bGFyT2Zmc2V0ICE9IHRoaXMubV9hbmd1bGFyT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICB0aGlzLm1fYW5ndWxhck9mZnNldCA9IGFuZ3VsYXJPZmZzZXQ7XG4gICAgfVxufTtcblxuTW90b3JKb2ludC5wcm90b3R5cGUuZ2V0QW5ndWxhck9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYW5ndWxhck9mZnNldDtcbn07XG5cbk1vdG9ySm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFBvc2l0aW9uKCk7XG59O1xuXG5Nb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRQb3NpdGlvbigpO1xufTtcblxuTW90b3JKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBWZWMyLm11bChpbnZfZHQsIHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbn07XG5cbk1vdG9ySm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9hbmd1bGFySW1wdWxzZTtcbn07XG5cbk1vdG9ySm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHFBID0gUm90Lm5lbyhhQSksIHFCID0gUm90Lm5lbyhhQik7XG4gICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxuICAgIHRoaXMubV9yQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLm5lZyh0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgdGhpcy5tX3JCID0gUm90Lm11bFZlYzIocUIsIFZlYzIubmVnKHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cbiAgICAvLyBbIDAgLTEgMCAxXVxuICAgIC8vIHJfc2tldyA9IFstcnk7IHJ4XVxuICAgIC8vIE1hdGxhYlxuICAgIC8vIEsgPSBbIG1BK3IxeV4yKmlBK21CK3IyeV4yKmlCLCAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCAtcjF5KmlBLXIyeSppQl1cbiAgICAvLyBbIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIG1BK3IxeF4yKmlBK21CK3IyeF4yKmlCLCByMXgqaUErcjJ4KmlCXVxuICAgIC8vIFsgLXIxeSppQS1yMnkqaUIsIHIxeCppQStyMngqaUIsIGlBK2lCXVxuICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgIEsuZXgueCA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9yQS55ICogdGhpcy5tX3JBLnkgKyBpQiAqIHRoaXMubV9yQi55ICogdGhpcy5tX3JCLnk7XG4gICAgSy5leC55ID0gLWlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueSAtIGlCICogdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueTtcbiAgICBLLmV5LnggPSBLLmV4Lnk7XG4gICAgSy5leS55ID0gbUEgKyBtQiArIGlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueCArIGlCICogdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueDtcbiAgICB0aGlzLm1fbGluZWFyTWFzcyA9IEsuZ2V0SW52ZXJzZSgpO1xuICAgIHRoaXMubV9hbmd1bGFyTWFzcyA9IGlBICsgaUI7XG4gICAgaWYgKHRoaXMubV9hbmd1bGFyTWFzcyA+IDApIHtcbiAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gMSAvIHRoaXMubV9hbmd1bGFyTWFzcztcbiAgICB9XG4gICAgdGhpcy5tX2xpbmVhckVycm9yID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xpbmVhckVycm9yLmFkZENvbWJpbmUoMSwgY0IsIDEsIHRoaXMubV9yQik7XG4gICAgdGhpcy5tX2xpbmVhckVycm9yLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHRoaXMubV9yQSk7XG4gICAgdGhpcy5tX2xpbmVhckVycm9yLnN1YihSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xpbmVhck9mZnNldCkpO1xuICAgIHRoaXMubV9hbmd1bGFyRXJyb3IgPSBhQiAtIGFBIC0gdGhpcy5tX2FuZ3VsYXJPZmZzZXQ7XG4gICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9saW5lYXJJbXB1bHNlLngsIHRoaXMubV9saW5lYXJJbXB1bHNlLnkpO1xuICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLnNldFplcm8oKTtcbiAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMDtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuTW90b3JKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBLCBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICB2YXIgaUEgPSB0aGlzLm1faW52SUEsIGlCID0gdGhpcy5tX2ludklCO1xuICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICB2YXIgaW52X2ggPSBzdGVwLmludl9kdDtcbiAgICAvLyBTb2x2ZSBhbmd1bGFyIGZyaWN0aW9uXG4gICAge1xuICAgICAgICB2YXIgQ2RvdCA9IHdCIC0gd0EgKyBpbnZfaCAqIHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yICogdGhpcy5tX2FuZ3VsYXJFcnJvcjtcbiAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX2FuZ3VsYXJNYXNzICogQ2RvdDtcbiAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fYW5ndWxhckltcHVsc2U7XG4gICAgICAgIHZhciBtYXhJbXB1bHNlID0gaCAqIHRoaXMubV9tYXhUb3JxdWU7XG4gICAgICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IE1hdGguY2xhbXAodGhpcy5tX2FuZ3VsYXJJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xuICAgICAgICBpbXB1bHNlID0gdGhpcy5tX2FuZ3VsYXJJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgfVxuICAgIC8vIFNvbHZlIGxpbmVhciBmcmljdGlvblxuICAgIHtcbiAgICAgICAgdmFyIENkb3QgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgQ2RvdC5hZGRDb21iaW5lKDEsIHZCLCAxLCBWZWMyLmNyb3NzKHdCLCB0aGlzLm1fckIpKTtcbiAgICAgICAgQ2RvdC5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzKHdBLCB0aGlzLm1fckEpKTtcbiAgICAgICAgQ2RvdC5hZGRNdWwoaW52X2ggKiB0aGlzLm1fY29ycmVjdGlvbkZhY3RvciwgdGhpcy5tX2xpbmVhckVycm9yKTtcbiAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMyLm5lZyhNYXQyMi5tdWxWZWMyKHRoaXMubV9saW5lYXJNYXNzLCBDZG90KSk7XG4gICAgICAgIHZhciBvbGRJbXB1bHNlID0gVmVjMi5jbG9uZSh0aGlzLm1fbGluZWFySW1wdWxzZSk7XG4gICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heEZvcmNlO1xuICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5jbGFtcChtYXhJbXB1bHNlKTtcbiAgICAgICAgaW1wdWxzZSA9IFZlYzIuc3ViKHRoaXMubV9saW5lYXJJbXB1bHNlLCBvbGRJbXB1bHNlKTtcbiAgICAgICAgdkEuc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzKHRoaXMubV9yQSwgaW1wdWxzZSk7XG4gICAgICAgIHZCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zcyh0aGlzLm1fckIsIGltcHVsc2UpO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5Nb3RvckpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbn0se1wiLi4vSm9pbnRcIjo1LFwiLi4vU2V0dGluZ3NcIjo3LFwiLi4vY29tbW9uL01hdDIyXCI6MTYsXCIuLi9jb21tb24vTWF0MzNcIjoxNyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUG9zaXRpb25cIjoxOSxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9Td2VlcFwiOjIxLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL2NvbW1vbi9WZWMzXCI6MjQsXCIuLi9jb21tb24vVmVsb2NpdHlcIjoyNSxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuLi91dGlsL2NyZWF0ZVwiOjUxLFwiLi4vdXRpbC9vcHRpb25zXCI6NTJ9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTW91c2VKb2ludDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIG9wdGlvbnMgPSByZXF1aXJlKFwiLi4vdXRpbC9vcHRpb25zXCIpO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZShcIi4uL3V0aWwvY3JlYXRlXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBWZWMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMzXCIpO1xuXG52YXIgTWF0MjIgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDIyXCIpO1xuXG52YXIgTWF0MzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDMzXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBTd2VlcCA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3dlZXBcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFZlbG9jaXR5ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWxvY2l0eVwiKTtcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Qb3NpdGlvblwiKTtcblxudmFyIEpvaW50ID0gcmVxdWlyZShcIi4uL0pvaW50XCIpO1xuXG5Nb3VzZUpvaW50LlRZUEUgPSBcIm1vdXNlLWpvaW50XCI7XG5cbk1vdXNlSm9pbnQuX3N1cGVyID0gSm9pbnQ7XG5cbk1vdXNlSm9pbnQucHJvdG90eXBlID0gY3JlYXRlKE1vdXNlSm9pbnQuX3N1cGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTW91c2VKb2ludERlZlxuICpcbiAqIE1vdXNlIGpvaW50IGRlZmluaXRpb24uIFRoaXMgcmVxdWlyZXMgYSB3b3JsZCB0YXJnZXQgcG9pbnQsIHR1bmluZ1xuICogcGFyYW1ldGVycywgYW5kIHRoZSB0aW1lIHN0ZXAuXG4gKiBcbiAqIEBwcm9wIFttYXhGb3JjZSA9IDAuMF0gVGhlIG1heGltdW0gY29uc3RyYWludCBmb3JjZSB0aGF0IGNhbiBiZSBleGVydGVkIHRvXG4gKiAgICAgICBtb3ZlIHRoZSBjYW5kaWRhdGUgYm9keS4gVXN1YWxseSB5b3Ugd2lsbCBleHByZXNzIGFzIHNvbWUgbXVsdGlwbGUgb2ZcbiAqICAgICAgIHRoZSB3ZWlnaHQgKG11bHRpcGxpZXIgKiBtYXNzICogZ3Jhdml0eSkuXG4gKiBAcHJvcCBbZnJlcXVlbmN5SHogPSA1LjBdIFRoZSByZXNwb25zZSBzcGVlZC5cbiAqIEBwcm9wIFtkYW1waW5nUmF0aW8gPSAwLjddIFRoZSBkYW1waW5nIHJhdGlvLiAwID0gbm8gZGFtcGluZywgMSA9IGNyaXRpY2FsXG4gKiAgICAgICBkYW1waW5nLlxuICpcbiAqIEBwcm9wIHtWZWMyfSB0YXJnZXQgVGhlIGluaXRpYWwgd29ybGQgdGFyZ2V0IHBvaW50LiBUaGlzIGlzIGFzc3VtZWQgdG9cbiAqICAgICAgIGNvaW5jaWRlIHdpdGggdGhlIGJvZHkgYW5jaG9yIGluaXRpYWxseS5cbiAqL1xudmFyIERFRkFVTFRTID0ge1xuICAgIG1heEZvcmNlOiAwLFxuICAgIGZyZXF1ZW5jeUh6OiA1LFxuICAgIGRhbXBpbmdSYXRpbzogLjdcbn07XG5cbi8qKlxuICogQSBtb3VzZSBqb2ludCBpcyB1c2VkIHRvIG1ha2UgYSBwb2ludCBvbiBhIGJvZHkgdHJhY2sgYSBzcGVjaWZpZWQgd29ybGRcbiAqIHBvaW50LiBUaGlzIGEgc29mdCBjb25zdHJhaW50IHdpdGggYSBtYXhpbXVtIGZvcmNlLiBUaGlzIGFsbG93cyB0aGVcbiAqIGNvbnN0cmFpbnQgdG8gc3RyZXRjaCBhbmQgd2l0aG91dCBhcHBseWluZyBodWdlIGZvcmNlcy5cbiAqIFxuICogTk9URTogdGhpcyBqb2ludCBpcyBub3QgZG9jdW1lbnRlZCBpbiB0aGUgbWFudWFsIGJlY2F1c2UgaXQgd2FzIGRldmVsb3BlZCB0b1xuICogYmUgdXNlZCBpbiB0aGUgdGVzdGJlZC4gSWYgeW91IHdhbnQgdG8gbGVhcm4gaG93IHRvIHVzZSB0aGUgbW91c2Ugam9pbnQsIGxvb2tcbiAqIGF0IHRoZSB0ZXN0YmVkLlxuICpcbiAqIEBwYXJhbSB7TW91c2VKb2ludERlZn0gZGVmXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIE1vdXNlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIHRhcmdldCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb3VzZUpvaW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vdXNlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIHRhcmdldCk7XG4gICAgfVxuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgSm9pbnQuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgYm9keUEgPSB0aGlzLm1fYm9keUE7XG4gICAgYm9keUIgPSB0aGlzLm1fYm9keUI7XG4gICAgdGhpcy5tX3R5cGUgPSBNb3VzZUpvaW50LlRZUEU7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUoZGVmLm1heEZvcmNlKSAmJiBkZWYubWF4Rm9yY2UgPj0gMCk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUoZGVmLmZyZXF1ZW5jeUh6KSAmJiBkZWYuZnJlcXVlbmN5SHogPj0gMCk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KE1hdGguaXNGaW5pdGUoZGVmLmRhbXBpbmdSYXRpbykgJiYgZGVmLmRhbXBpbmdSYXRpbyA+PSAwKTtcbiAgICB0aGlzLm1fdGFyZ2V0QSA9IHRhcmdldCA/IFZlYzIuY2xvbmUodGFyZ2V0KSA6IGRlZi50YXJnZXQgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFRyYW5zZm9ybS5tdWxUVmVjMihib2R5Qi5nZXRUcmFuc2Zvcm0oKSwgdGhpcy5tX3RhcmdldEEpO1xuICAgIHRoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcbiAgICB0aGlzLm1faW1wdWxzZSA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGRlZi5mcmVxdWVuY3lIejtcbiAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcbiAgICB0aGlzLm1fYmV0YSA9IDA7XG4gICAgdGhpcy5tX2dhbW1hID0gMDtcbiAgICAvLyBTb2x2ZXIgdGVtcFxuICAgIHRoaXMubV9yQiA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLm1faW52TWFzc0IgPSAwO1xuICAgIHRoaXMubV9pbnZJQiA9IDA7XG4gICAgdGhpcy5tYXNzID0gbmV3IE1hdDIyKCk7XG4gICAgdGhpcy5tX0MgPSBWZWMyLnplcm8oKTtcbn1cblxuLyoqXG4gKiBVc2UgdGhpcyB0byB1cGRhdGUgdGhlIHRhcmdldCBwb2ludC5cbiAqL1xuTW91c2VKb2ludC5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMubV9ib2R5Qi5pc0F3YWtlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIH1cbiAgICB0aGlzLm1fdGFyZ2V0QSA9IFZlYzIuY2xvbmUodGFyZ2V0KTtcbn07XG5cbk1vdXNlSm9pbnQucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdGFyZ2V0QTtcbn07XG5cbi8qKlxuICogU2V0L2dldCB0aGUgbWF4aW11bSBmb3JjZSBpbiBOZXd0b25zLlxuICovXG5Nb3VzZUpvaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgdGhpcy5tX21heEZvcmNlID0gZm9yY2U7XG59O1xuXG5Nb3VzZUpvaW50LmdldE1heEZvcmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tYXhGb3JjZTtcbn07XG5cbi8qKlxuICogU2V0L2dldCB0aGUgZnJlcXVlbmN5IGluIEhlcnR6LlxuICovXG5Nb3VzZUpvaW50LnByb3RvdHlwZS5zZXRGcmVxdWVuY3kgPSBmdW5jdGlvbihoeikge1xuICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xufTtcblxuTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0RnJlcXVlbmN5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9mcmVxdWVuY3lIejtcbn07XG5cbi8qKlxuICogU2V0L2dldCB0aGUgZGFtcGluZyByYXRpbyAoZGltZW5zaW9ubGVzcykuXG4gKi9cbk1vdXNlSm9pbnQucHJvdG90eXBlLnNldERhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xufTtcblxuTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9kYW1waW5nUmF0aW87XG59O1xuXG5Nb3VzZUpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFZlYzIuY2xvbmUodGhpcy5tX3RhcmdldEEpO1xufTtcblxuTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbn07XG5cbk1vdXNlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbihpbnZfZHQpIHtcbiAgICByZXR1cm4gVmVjMi5tdWwoaW52X2R0LCB0aGlzLm1faW1wdWxzZSk7XG59O1xuXG5Nb3VzZUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBpbnZfZHQgKiAwO1xufTtcblxuTW91c2VKb2ludC5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbihuZXdPcmlnaW4pIHtcbiAgICB0aGlzLm1fdGFyZ2V0QS5zdWIobmV3T3JpZ2luKTtcbn07XG5cbk1vdXNlSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb247XG4gICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHk7XG4gICAgdmFyIGNCID0gcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSBwb3NpdGlvbi5hO1xuICAgIHZhciB2QiA9IHZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdmVsb2NpdHkudztcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICB2YXIgbWFzcyA9IHRoaXMubV9ib2R5Qi5nZXRNYXNzKCk7XG4gICAgLy8gRnJlcXVlbmN5XG4gICAgdmFyIG9tZWdhID0gMiAqIE1hdGguUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxuICAgIHZhciBkID0gMiAqIG1hc3MgKiB0aGlzLm1fZGFtcGluZ1JhdGlvICogb21lZ2E7XG4gICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xuICAgIHZhciBrID0gbWFzcyAqIChvbWVnYSAqIG9tZWdhKTtcbiAgICAvLyBtYWdpYyBmb3JtdWxhc1xuICAgIC8vIGdhbW1hIGhhcyB1bml0cyBvZiBpbnZlcnNlIG1hc3MuXG4gICAgLy8gYmV0YSBoYXMgdW5pdHMgb2YgaW52ZXJzZSB0aW1lLlxuICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZCArIGggKiBrID4gTWF0aC5FUFNJTE9OKTtcbiAgICB0aGlzLm1fZ2FtbWEgPSBoICogKGQgKyBoICogayk7XG4gICAgaWYgKHRoaXMubV9nYW1tYSAhPSAwKSB7XG4gICAgICAgIHRoaXMubV9nYW1tYSA9IDEgLyB0aGlzLm1fZ2FtbWE7XG4gICAgfVxuICAgIHRoaXMubV9iZXRhID0gaCAqIGsgKiB0aGlzLm1fZ2FtbWE7XG4gICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxuICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgLy8gSyA9IFsoMS9tMSArIDEvbTIpICogZXllKDIpIC0gc2tldyhyMSkgKiBpbnZJMSAqIHNrZXcocjEpIC0gc2tldyhyMikgKlxuICAgIC8vIGludkkyICogc2tldyhyMildXG4gICAgLy8gPSBbMS9tMSsxL20yIDAgXSArIGludkkxICogW3IxLnkqcjEueSAtcjEueCpyMS55XSArIGludkkyICogW3IxLnkqcjEueVxuICAgIC8vIC1yMS54KnIxLnldXG4gICAgLy8gWyAwIDEvbTErMS9tMl0gWy1yMS54KnIxLnkgcjEueCpyMS54XSBbLXIxLngqcjEueSByMS54KnIxLnhdXG4gICAgdmFyIEsgPSBuZXcgTWF0MjIoKTtcbiAgICBLLmV4LnggPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiB0aGlzLm1fckIueSAqIHRoaXMubV9yQi55ICsgdGhpcy5tX2dhbW1hO1xuICAgIEsuZXgueSA9IC10aGlzLm1faW52SUIgKiB0aGlzLm1fckIueCAqIHRoaXMubV9yQi55O1xuICAgIEsuZXkueCA9IEsuZXgueTtcbiAgICBLLmV5LnkgPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiB0aGlzLm1fckIueCAqIHRoaXMubV9yQi54ICsgdGhpcy5tX2dhbW1hO1xuICAgIHRoaXMubV9tYXNzID0gSy5nZXRJbnZlcnNlKCk7XG4gICAgdGhpcy5tX0Muc2V0KGNCKTtcbiAgICB0aGlzLm1fQy5hZGRDb21iaW5lKDEsIHRoaXMubV9yQiwgLTEsIHRoaXMubV90YXJnZXRBKTtcbiAgICB0aGlzLm1fQy5tdWwodGhpcy5tX2JldGEpO1xuICAgIC8vIENoZWF0IHdpdGggc29tZSBkYW1waW5nXG4gICAgd0IgKj0gLjk4O1xuICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICB0aGlzLm1faW1wdWxzZS5tdWwoc3RlcC5kdFJhdGlvKTtcbiAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgdGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzKHRoaXMubV9yQiwgdGhpcy5tX2ltcHVsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9pbXB1bHNlLnNldFplcm8oKTtcbiAgICB9XG4gICAgdmVsb2NpdHkudi5zZXQodkIpO1xuICAgIHZlbG9jaXR5LncgPSB3Qjtcbn07XG5cbk1vdXNlSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eTtcbiAgICB2YXIgdkIgPSBWZWMyLmNsb25lKHZlbG9jaXR5LnYpO1xuICAgIHZhciB3QiA9IHZlbG9jaXR5Lnc7XG4gICAgLy8gQ2RvdCA9IHYgKyBjcm9zcyh3LCByKVxuICAgIHZhciBDZG90ID0gVmVjMi5jcm9zcyh3QiwgdGhpcy5tX3JCKTtcbiAgICBDZG90LmFkZCh2Qik7XG4gICAgQ2RvdC5hZGRDb21iaW5lKDEsIHRoaXMubV9DLCB0aGlzLm1fZ2FtbWEsIHRoaXMubV9pbXB1bHNlKTtcbiAgICBDZG90Lm5lZygpO1xuICAgIHZhciBpbXB1bHNlID0gTWF0MjIubXVsVmVjMih0aGlzLm1fbWFzcywgQ2RvdCk7XG4gICAgdmFyIG9sZEltcHVsc2UgPSBWZWMyLmNsb25lKHRoaXMubV9pbXB1bHNlKTtcbiAgICB0aGlzLm1faW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heEZvcmNlO1xuICAgIHRoaXMubV9pbXB1bHNlLmNsYW1wKG1heEltcHVsc2UpO1xuICAgIGltcHVsc2UgPSBWZWMyLnN1Yih0aGlzLm1faW1wdWxzZSwgb2xkSW1wdWxzZSk7XG4gICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgaW1wdWxzZSk7XG4gICAgd0IgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zcyh0aGlzLm1fckIsIGltcHVsc2UpO1xuICAgIHZlbG9jaXR5LnYuc2V0KHZCKTtcbiAgICB2ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5Nb3VzZUpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbn0se1wiLi4vSm9pbnRcIjo1LFwiLi4vY29tbW9uL01hdDIyXCI6MTYsXCIuLi9jb21tb24vTWF0MzNcIjoxNyxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUG9zaXRpb25cIjoxOSxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9Td2VlcFwiOjIxLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL2NvbW1vbi9WZWMzXCI6MjQsXCIuLi9jb21tb24vVmVsb2NpdHlcIjoyNSxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuLi91dGlsL2NyZWF0ZVwiOjUxLFwiLi4vdXRpbC9vcHRpb25zXCI6NTJ9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpc21hdGljSm9pbnQ7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL2NyZWF0ZVwiKTtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBWZWMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMzXCIpO1xuXG52YXIgTWF0MjIgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDIyXCIpO1xuXG52YXIgTWF0MzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDMzXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBTd2VlcCA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3dlZXBcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFZlbG9jaXR5ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWxvY2l0eVwiKTtcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Qb3NpdGlvblwiKTtcblxudmFyIEpvaW50ID0gcmVxdWlyZShcIi4uL0pvaW50XCIpO1xuXG52YXIgaW5hY3RpdmVMaW1pdCA9IDA7XG5cbnZhciBhdExvd2VyTGltaXQgPSAxO1xuXG52YXIgYXRVcHBlckxpbWl0ID0gMjtcblxudmFyIGVxdWFsTGltaXRzID0gMztcblxuUHJpc21hdGljSm9pbnQuVFlQRSA9IFwicHJpc21hdGljLWpvaW50XCI7XG5cblByaXNtYXRpY0pvaW50Ll9zdXBlciA9IEpvaW50O1xuXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUgPSBjcmVhdGUoUHJpc21hdGljSm9pbnQuX3N1cGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJpc21hdGljSm9pbnREZWZcbiAqXG4gKiBQcmlzbWF0aWMgam9pbnQgZGVmaW5pdGlvbi4gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhIGxpbmUgb2YgbW90aW9uIHVzaW5nIGFuXG4gKiBheGlzIGFuZCBhbiBhbmNob3IgcG9pbnQuIFRoZSBkZWZpbml0aW9uIHVzZXMgbG9jYWwgYW5jaG9yIHBvaW50cyBhbmQgYSBsb2NhbFxuICogYXhpcyBzbyB0aGF0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gY2FuIHZpb2xhdGUgdGhlIGNvbnN0cmFpbnQgc2xpZ2h0bHkuXG4gKiBUaGUgam9pbnQgdHJhbnNsYXRpb24gaXMgemVybyB3aGVuIHRoZSBsb2NhbCBhbmNob3IgcG9pbnRzIGNvaW5jaWRlIGluIHdvcmxkXG4gKiBzcGFjZS4gVXNpbmcgbG9jYWwgYW5jaG9ycyBhbmQgYSBsb2NhbCBheGlzIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGFcbiAqIGdhbWUuXG4gKiBcbiAqIEBwcm9wIHtib29sZWFufSBlbmFibGVMaW1pdCBFbmFibGUvZGlzYWJsZSB0aGUgam9pbnQgbGltaXQuXG4gKiBAcHJvcCB7ZmxvYXR9IGxvd2VyVHJhbnNsYXRpb24gVGhlIGxvd2VyIHRyYW5zbGF0aW9uIGxpbWl0LCB1c3VhbGx5IGluXG4gKiAgICAgICBtZXRlcnMuXG4gKiBAcHJvcCB7ZmxvYXR9IHVwcGVyVHJhbnNsYXRpb24gVGhlIHVwcGVyIHRyYW5zbGF0aW9uIGxpbWl0LCB1c3VhbGx5IGluXG4gKiAgICAgICBtZXRlcnMuXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZW5hYmxlTW90b3IgRW5hYmxlL2Rpc2FibGUgdGhlIGpvaW50IG1vdG9yLlxuICogQHByb3Age2Zsb2F0fSBtYXhNb3RvckZvcmNlIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXG4gKiBAcHJvcCB7ZmxvYXR9IG1vdG9yU3BlZWQgVGhlIGRlc2lyZWQgbW90b3Igc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICpcbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckEgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckIgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEF4aXNBIFRoZSBsb2NhbCB0cmFuc2xhdGlvbiB1bml0IGF4aXMgaW4gYm9keUEuXG4gKiBAcHJvcCB7ZmxvYXR9IHJlZmVyZW5jZUFuZ2xlIFRoZSBjb25zdHJhaW5lZCBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXM6XG4gKiAgICAgICBib2R5Ql9hbmdsZSAtIGJvZHlBX2FuZ2xlLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gICAgZW5hYmxlTGltaXQ6IGZhbHNlLFxuICAgIGxvd2VyVHJhbnNsYXRpb246IDAsXG4gICAgdXBwZXJUcmFuc2xhdGlvbjogMCxcbiAgICBlbmFibGVNb3RvcjogZmFsc2UsXG4gICAgbWF4TW90b3JGb3JjZTogMCxcbiAgICBtb3RvclNwZWVkOiAwXG59O1xuXG4vKipcbiAqIEEgcHJpc21hdGljIGpvaW50LiBUaGlzIGpvaW50IHByb3ZpZGVzIG9uZSBkZWdyZWUgb2YgZnJlZWRvbTogdHJhbnNsYXRpb25cbiAqIGFsb25nIGFuIGF4aXMgZml4ZWQgaW4gYm9keUEuIFJlbGF0aXZlIHJvdGF0aW9uIGlzIHByZXZlbnRlZC4gWW91IGNhbiB1c2UgYVxuICogam9pbnQgbGltaXQgdG8gcmVzdHJpY3QgdGhlIHJhbmdlIG9mIG1vdGlvbiBhbmQgYSBqb2ludCBtb3RvciB0byBkcml2ZSB0aGVcbiAqIG1vdGlvbiBvciB0byBtb2RlbCBqb2ludCBmcmljdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1ByaXNtYXRpY0pvaW50RGVmfSBkZWZcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuZnVuY3Rpb24gUHJpc21hdGljSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvciwgYXhpcykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcmlzbWF0aWNKb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmlzbWF0aWNKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yLCBheGlzKTtcbiAgICB9XG4gICAgZGVmID0gb3B0aW9ucyhkZWYsIERFRkFVTFRTKTtcbiAgICBKb2ludC5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKTtcbiAgICBib2R5QSA9IHRoaXMubV9ib2R5QTtcbiAgICBib2R5QiA9IHRoaXMubV9ib2R5QjtcbiAgICB0aGlzLm1fdHlwZSA9IFByaXNtYXRpY0pvaW50LlRZUEU7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xvY2FsWEF4aXNBID0gYXhpcyA/IGJvZHlBLmdldExvY2FsVmVjdG9yKGF4aXMpIDogZGVmLmxvY2FsQXhpc0EgfHwgVmVjMi5uZW8oMSwgMCk7XG4gICAgdGhpcy5tX2xvY2FsWEF4aXNBLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMubV9sb2NhbFlBeGlzQSA9IFZlYzIuY3Jvc3MoMSwgdGhpcy5tX2xvY2FsWEF4aXNBKTtcbiAgICB0aGlzLm1fcmVmZXJlbmNlQW5nbGUgPSBNYXRoLmlzRmluaXRlKGRlZi5yZWZlcmVuY2VBbmdsZSkgPyBkZWYucmVmZXJlbmNlQW5nbGUgOiBib2R5Qi5nZXRBbmdsZSgpIC0gYm9keUEuZ2V0QW5nbGUoKTtcbiAgICB0aGlzLm1faW1wdWxzZSA9IFZlYzMoKTtcbiAgICB0aGlzLm1fbW90b3JNYXNzID0gMDtcbiAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMDtcbiAgICB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGRlZi5sb3dlclRyYW5zbGF0aW9uO1xuICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gZGVmLnVwcGVyVHJhbnNsYXRpb247XG4gICAgdGhpcy5tX21heE1vdG9yRm9yY2UgPSBkZWYubWF4TW90b3JGb3JjZTtcbiAgICB0aGlzLm1fbW90b3JTcGVlZCA9IGRlZi5tb3RvclNwZWVkO1xuICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBkZWYuZW5hYmxlTW90b3I7XG4gICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBpbmFjdGl2ZUxpbWl0O1xuICAgIHRoaXMubV9heGlzID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX3BlcnAgPSBWZWMyLnplcm8oKTtcbiAgICAvLyBTb2x2ZXIgdGVtcFxuICAgIHRoaXMubV9sb2NhbENlbnRlckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9sb2NhbENlbnRlckI7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9pbnZNYXNzQTtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZJQTtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZJQjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9heGlzLCB0aGlzLm1fcGVycDtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX3MxLCB0aGlzLm1fczI7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fYTEsIHRoaXMubV9hMjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9LID0gbmV3IE1hdDMzKCk7XG4gICAgdGhpcy5tX21vdG9yTWFzcztcbn1cblxuLyoqXG4gKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICovXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG59O1xuXG4vKipcbiAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbn07XG5cbi8qKlxuICogVGhlIGxvY2FsIGpvaW50IGF4aXMgcmVsYXRpdmUgdG8gYm9keUEuXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRMb2NhbEF4aXNBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sb2NhbFhBeGlzQTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZWZlcmVuY2UgYW5nbGUuXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRSZWZlcmVuY2VBbmdsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBqb2ludCB0cmFuc2xhdGlvbiwgdXN1YWxseSBpbiBtZXRlcnMuXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRKb2ludFRyYW5zbGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBBID0gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgdmFyIHBCID0gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgdmFyIGQgPSBWZWMyLnN1YihwQiwgcEEpO1xuICAgIHZhciBheGlzID0gdGhpcy5tX2JvZHlBLmdldFdvcmxkVmVjdG9yKHRoaXMubV9sb2NhbFhBeGlzQSk7XG4gICAgdmFyIHRyYW5zbGF0aW9uID0gVmVjMi5kb3QoZCwgYXhpcyk7XG4gICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24gc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRKb2ludFNwZWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICB2YXIgckEgPSBSb3QubXVsVmVjMihiQS5tX3hmLnEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIpKTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIHJCID0gUm90Lm11bFZlYzIoYkIubV94Zi5xLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyKSk7XG4gICAgLy8gVmVjMlxuICAgIHZhciBwMSA9IFZlYzIuYWRkKGJBLm1fc3dlZXAuYywgckEpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgcDIgPSBWZWMyLmFkZChiQi5tX3N3ZWVwLmMsIHJCKTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIGQgPSBWZWMyLnN1YihwMiwgcDEpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgYXhpcyA9IFJvdC5tdWxWZWMyKGJBLm1feGYucSwgdGhpcy5tX2xvY2FsWEF4aXNBKTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIHZBID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIHdBID0gYkEubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgd0IgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBzcGVlZCA9IFZlYzIuZG90KGQsIFZlYzIuY3Jvc3Mod0EsIGF4aXMpKSArIFZlYzIuZG90KGF4aXMsIFZlYzIuc3ViKFZlYzIuYWRkQ3Jvc3ModkIsIHdCLCByQiksIFZlYzIuYWRkQ3Jvc3ModkEsIHdBLCByQSkpKTtcbiAgICAvLyBmbG9hdFxuICAgIHJldHVybiBzcGVlZDtcbn07XG5cbi8qKlxuICogSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5pc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG59O1xuXG4vKipcbiAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBsaW1pdC5cbiAqL1xuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmVuYWJsZUxpbWl0ID0gZnVuY3Rpb24oZmxhZykge1xuICAgIGlmIChmbGFnICE9IHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcbiAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxvd2VyIGpvaW50IGxpbWl0LCB1c3VhbGx5IGluIG1ldGVycy5cbiAqL1xuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldExvd2VyTGltaXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb247XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdXBwZXIgam9pbnQgbGltaXQsIHVzdWFsbHkgaW4gbWV0ZXJzLlxuICovXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0VXBwZXJMaW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqb2ludCBsaW1pdHMsIHVzdWFsbHkgaW4gbWV0ZXJzLlxuICovXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24obG93ZXIsIHVwcGVyKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGxvd2VyIDw9IHVwcGVyKTtcbiAgICBpZiAobG93ZXIgIT0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gfHwgdXBwZXIgIT0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gbG93ZXI7XG4gICAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gdXBwZXI7XG4gICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGpvaW50IG1vdG9yIGVuYWJsZWQ/XG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5pc01vdG9yRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTW90b3I7XG59O1xuXG4vKipcbiAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBtb3Rvci5cbiAqL1xuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oZmxhZykge1xuICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtb3RvciBzcGVlZCwgdXN1YWxseSBpbiBtZXRlcnMgcGVyIHNlY29uZC5cbiAqL1xuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCkge1xuICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX21vdG9yU3BlZWQgPSBzcGVlZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlLCB1c3VhbGx5IGluIE4uXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5zZXRNYXhNb3RvckZvcmNlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbW90b3Igc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbW90b3IgZm9yY2UgZ2l2ZW4gdGhlIGludmVyc2UgdGltZSBzdGVwLCB1c3VhbGx5IGluIE4uXG4gKi9cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRNb3RvckZvcmNlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG59O1xuXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbn07XG5cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xufTtcblxuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbihpbnZfZHQpIHtcbiAgICByZXR1cm4gVmVjMi5jb21iaW5lKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9wZXJwLCB0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueiwgdGhpcy5tX2F4aXMpLm11bChpbnZfZHQpO1xufTtcblxuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9pbXB1bHNlLnk7XG59O1xuXG5QcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzc2VzLlxuICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICB2YXIgZCA9IFZlYzIuemVybygpO1xuICAgIGQuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgIGQuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQSwgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgdmFyIGlBID0gdGhpcy5tX2ludklBLCBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAvLyBDb21wdXRlIG1vdG9yIEphY29iaWFuIGFuZCBlZmZlY3RpdmUgbWFzcy5cbiAgICB7XG4gICAgICAgIHRoaXMubV9heGlzID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFhBeGlzQSk7XG4gICAgICAgIHRoaXMubV9hMSA9IFZlYzIuY3Jvc3MoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgIHRoaXMubV9hMiA9IFZlYzIuY3Jvc3MockIsIHRoaXMubV9heGlzKTtcbiAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGlCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICBpZiAodGhpcy5tX21vdG9yTWFzcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxIC8gdGhpcy5tX21vdG9yTWFzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQcmlzbWF0aWMgY29uc3RyYWludC5cbiAgICB7XG4gICAgICAgIHRoaXMubV9wZXJwID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFlBeGlzQSk7XG4gICAgICAgIHRoaXMubV9zMSA9IFZlYzIuY3Jvc3MoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fcGVycCk7XG4gICAgICAgIHRoaXMubV9zMiA9IFZlYzIuY3Jvc3MockIsIHRoaXMubV9wZXJwKTtcbiAgICAgICAgdmFyIHMxdGVzdCA9IFZlYzIuY3Jvc3MockEsIHRoaXMubV9wZXJwKTtcbiAgICAgICAgdmFyIGsxMSA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGlCICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xuICAgICAgICB2YXIgazEyID0gaUEgKiB0aGlzLm1fczEgKyBpQiAqIHRoaXMubV9zMjtcbiAgICAgICAgdmFyIGsxMyA9IGlBICogdGhpcy5tX3MxICogdGhpcy5tX2ExICsgaUIgKiB0aGlzLm1fczIgKiB0aGlzLm1fYTI7XG4gICAgICAgIHZhciBrMjIgPSBpQSArIGlCO1xuICAgICAgICBpZiAoazIyID09IDApIHtcbiAgICAgICAgICAgIC8vIEZvciBib2RpZXMgd2l0aCBmaXhlZCByb3RhdGlvbi5cbiAgICAgICAgICAgIGsyMiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGsyMyA9IGlBICogdGhpcy5tX2ExICsgaUIgKiB0aGlzLm1fYTI7XG4gICAgICAgIHZhciBrMzMgPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fYTEgKiB0aGlzLm1fYTEgKyBpQiAqIHRoaXMubV9hMiAqIHRoaXMubV9hMjtcbiAgICAgICAgdGhpcy5tX0suZXguc2V0KGsxMSwgazEyLCBrMTMpO1xuICAgICAgICB0aGlzLm1fSy5leS5zZXQoazEyLCBrMjIsIGsyMyk7XG4gICAgICAgIHRoaXMubV9LLmV6LnNldChrMTMsIGsyMywgazMzKTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBtb3RvciBhbmQgbGltaXQgdGVybXMuXG4gICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICB2YXIgam9pbnRUcmFuc2xhdGlvbiA9IFZlYzIuZG90KHRoaXMubV9heGlzLCBkKTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMubV91cHBlclRyYW5zbGF0aW9uIC0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIDwgMiAqIFNldHRpbmdzLmxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gZXF1YWxMaW1pdHM7XG4gICAgICAgIH0gZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA8PSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGF0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYXRMb3dlckxpbWl0O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGpvaW50VHJhbnNsYXRpb24gPj0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSAhPSBhdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGF0VXBwZXJMaW1pdDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBpbmFjdGl2ZUxpbWl0O1xuICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMDtcbiAgICB9XG4gICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgdGhpcy5tX2ltcHVsc2UubXVsKHN0ZXAuZHRSYXRpbyk7XG4gICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICB2YXIgUCA9IFZlYzIuY29tYmluZSh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1fcGVycCwgdGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnosIHRoaXMubV9heGlzKTtcbiAgICAgICAgdmFyIExBID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9zMSArIHRoaXMubV9pbXB1bHNlLnkgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2ExO1xuICAgICAgICB2YXIgTEIgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MyICsgdGhpcy5tX2ltcHVsc2UueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTI7XG4gICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2ltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMDtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXQodkEpO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldCh2Qik7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuUHJpc21hdGljSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAvLyBTb2x2ZSBsaW5lYXIgbW90b3IgY29uc3RyYWludC5cbiAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGVxdWFsTGltaXRzKSB7XG4gICAgICAgIHZhciBDZG90ID0gVmVjMi5kb3QodGhpcy5tX2F4aXMsIFZlYzIuc3ViKHZCLCB2QSkpICsgdGhpcy5tX2EyICogd0IgLSB0aGlzLm1fYTEgKiB3QTtcbiAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLm1fbW90b3JNYXNzICogKHRoaXMubV9tb3RvclNwZWVkIC0gQ2RvdCk7XG4gICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTtcbiAgICAgICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heE1vdG9yRm9yY2U7XG4gICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBNYXRoLmNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgdmFyIFAgPSBWZWMyLm11bChpbXB1bHNlLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgIHZhciBMQSA9IGltcHVsc2UgKiB0aGlzLm1fYTE7XG4gICAgICAgIHZhciBMQiA9IGltcHVsc2UgKiB0aGlzLm1fYTI7XG4gICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgfVxuICAgIHZhciBDZG90MSA9IFZlYzIuemVybygpO1xuICAgIENkb3QxLnggKz0gVmVjMi5kb3QodGhpcy5tX3BlcnAsIHZCKSArIHRoaXMubV9zMiAqIHdCO1xuICAgIENkb3QxLnggLT0gVmVjMi5kb3QodGhpcy5tX3BlcnAsIHZBKSArIHRoaXMubV9zMSAqIHdBO1xuICAgIENkb3QxLnkgPSB3QiAtIHdBO1xuICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gaW5hY3RpdmVMaW1pdCkge1xuICAgICAgICAvLyBTb2x2ZSBwcmlzbWF0aWMgYW5kIGxpbWl0IGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cbiAgICAgICAgdmFyIENkb3QyID0gMDtcbiAgICAgICAgQ2RvdDIgKz0gVmVjMi5kb3QodGhpcy5tX2F4aXMsIHZCKSArIHRoaXMubV9hMiAqIHdCO1xuICAgICAgICBDZG90MiAtPSBWZWMyLmRvdCh0aGlzLm1fYXhpcywgdkEpICsgdGhpcy5tX2ExICogd0E7XG4gICAgICAgIHZhciBDZG90ID0gVmVjMyhDZG90MS54LCBDZG90MS55LCBDZG90Mik7XG4gICAgICAgIHZhciBmMSA9IFZlYzModGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICB2YXIgZGYgPSB0aGlzLm1fSy5zb2x2ZTMzKFZlYzMubmVnKENkb3QpKTtcbiAgICAgICAgLy8gVmVjM1xuICAgICAgICB0aGlzLm1faW1wdWxzZS5hZGQoZGYpO1xuICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYXRMb3dlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gTWF0aC5tYXgodGhpcy5tX2ltcHVsc2UueiwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gTWF0aC5taW4odGhpcy5tX2ltcHVsc2UueiwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArXG4gICAgICAgIC8vIGYxKDE6MilcbiAgICAgICAgdmFyIGIgPSBWZWMyLmNvbWJpbmUoLTEsIENkb3QxLCAtKHRoaXMubV9pbXB1bHNlLnogLSBmMS56KSwgVmVjMi5uZW8odGhpcy5tX0suZXoueCwgdGhpcy5tX0suZXoueSkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciBmMnIgPSBWZWMyLmFkZCh0aGlzLm1fSy5zb2x2ZTIyKGIpLCBWZWMyLm5lbyhmMS54LCBmMS55KSk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdGhpcy5tX2ltcHVsc2UueCA9IGYyci54O1xuICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gZjJyLnk7XG4gICAgICAgIGRmID0gVmVjMy5zdWIodGhpcy5tX2ltcHVsc2UsIGYxKTtcbiAgICAgICAgdmFyIFAgPSBWZWMyLmNvbWJpbmUoZGYueCwgdGhpcy5tX3BlcnAsIGRmLnosIHRoaXMubV9heGlzKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgTEEgPSBkZi54ICogdGhpcy5tX3MxICsgZGYueSArIGRmLnogKiB0aGlzLm1fYTE7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBMQiA9IGRmLnggKiB0aGlzLm1fczIgKyBkZi55ICsgZGYueiAqIHRoaXMubV9hMjtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgd0EgLT0gaUEgKiBMQTtcbiAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgd0IgKz0gaUIgKiBMQjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMaW1pdCBpcyBpbmFjdGl2ZSwganVzdCBzb2x2ZSB0aGUgcHJpc21hdGljIGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cbiAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suc29sdmUyMihWZWMyLm5lZyhDZG90MSkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gZGYueDtcbiAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSBkZi55O1xuICAgICAgICB2YXIgUCA9IFZlYzIubXVsKGRmLngsIHRoaXMubV9wZXJwKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgTEEgPSBkZi54ICogdGhpcy5tX3MxICsgZGYueTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIExCID0gZGYueCAqIHRoaXMubV9zMiArIGRmLnk7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgfVxuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3Qjtcbn07XG5cblByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgLy8gQ29tcHV0ZSBmcmVzaCBKYWNvYmlhbnNcbiAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgZCA9IFZlYzIuc3ViKFZlYzIuYWRkKGNCLCByQiksIFZlYzIuYWRkKGNBLCByQSkpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgYXhpcyA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgYTEgPSBWZWMyLmNyb3NzKFZlYzIuYWRkKGQsIHJBKSwgYXhpcyk7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgYTIgPSBWZWMyLmNyb3NzKHJCLCBheGlzKTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBwZXJwID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFlBeGlzQSk7XG4gICAgLy8gVmVjMlxuICAgIHZhciBzMSA9IFZlYzIuY3Jvc3MoVmVjMi5hZGQoZCwgckEpLCBwZXJwKTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBzMiA9IFZlYzIuY3Jvc3MockIsIHBlcnApO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGltcHVsc2UgPSBWZWMzKCk7XG4gICAgdmFyIEMxID0gVmVjMi56ZXJvKCk7XG4gICAgLy8gVmVjMlxuICAgIEMxLnggPSBWZWMyLmRvdChwZXJwLCBkKTtcbiAgICBDMS55ID0gYUIgLSBhQSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICB2YXIgbGluZWFyRXJyb3IgPSBNYXRoLmFicyhDMS54KTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBhbmd1bGFyRXJyb3IgPSBNYXRoLmFicyhDMS55KTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBsaW5lYXJTbG9wID0gU2V0dGluZ3MubGluZWFyU2xvcDtcbiAgICB2YXIgbWF4TGluZWFyQ29ycmVjdGlvbiA9IFNldHRpbmdzLm1heExpbmVhckNvcnJlY3Rpb247XG4gICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xuICAgIC8vIGJvb2xcbiAgICB2YXIgQzIgPSAwO1xuICAgIC8vIGZsb2F0XG4gICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSBWZWMyLmRvdChheGlzLCBkKTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMubV91cHBlclRyYW5zbGF0aW9uIC0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIDwgMiAqIGxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9uc1xuICAgICAgICAgICAgQzIgPSBNYXRoLmNsYW1wKHRyYW5zbGF0aW9uLCAtbWF4TGluZWFyQ29ycmVjdGlvbiwgbWF4TGluZWFyQ29ycmVjdGlvbik7XG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IE1hdGgubWF4KGxpbmVhckVycm9yLCBNYXRoLmFicyh0cmFuc2xhdGlvbikpO1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGlvbiA8PSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBsaW5lYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cbiAgICAgICAgICAgIEMyID0gTWF0aC5jbGFtcCh0cmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uICsgbGluZWFyU2xvcCwgLW1heExpbmVhckNvcnJlY3Rpb24sIDApO1xuICAgICAgICAgICAgbGluZWFyRXJyb3IgPSBNYXRoLm1heChsaW5lYXJFcnJvciwgdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gLSB0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0aW9uID49IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGxpbmVhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxuICAgICAgICAgICAgQzIgPSBNYXRoLmNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSBsaW5lYXJTbG9wLCAwLCBtYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gTWF0aC5tYXgobGluZWFyRXJyb3IsIHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pO1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIHZhciBrMTEgPSBtQSArIG1CICsgaUEgKiBzMSAqIHMxICsgaUIgKiBzMiAqIHMyO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgazEyID0gaUEgKiBzMSArIGlCICogczI7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBrMTMgPSBpQSAqIHMxICogYTEgKyBpQiAqIHMyICogYTI7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBrMjIgPSBpQSArIGlCO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICBpZiAoazIyID09IDApIHtcbiAgICAgICAgICAgIC8vIEZvciBmaXhlZCByb3RhdGlvblxuICAgICAgICAgICAgazIyID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgazIzID0gaUEgKiBhMSArIGlCICogYTI7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBrMzMgPSBtQSArIG1CICsgaUEgKiBhMSAqIGExICsgaUIgKiBhMiAqIGEyO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgSyA9IG5ldyBNYXQzMygpO1xuICAgICAgICBLLmV4LnNldChrMTEsIGsxMiwgazEzKTtcbiAgICAgICAgSy5leS5zZXQoazEyLCBrMjIsIGsyMyk7XG4gICAgICAgIEsuZXouc2V0KGsxMywgazIzLCBrMzMpO1xuICAgICAgICB2YXIgQyA9IFZlYzMoKTtcbiAgICAgICAgQy54ID0gQzEueDtcbiAgICAgICAgQy55ID0gQzEueTtcbiAgICAgICAgQy56ID0gQzI7XG4gICAgICAgIGltcHVsc2UgPSBLLnNvbHZlMzMoVmVjMy5uZWcoQykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrMTEgPSBtQSArIG1CICsgaUEgKiBzMSAqIHMxICsgaUIgKiBzMiAqIHMyO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgazEyID0gaUEgKiBzMSArIGlCICogczI7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBrMjIgPSBpQSArIGlCO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICBpZiAoazIyID09IDApIHtcbiAgICAgICAgICAgIGsyMiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEsgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgSy5leC5zZXQoazExLCBrMTIpO1xuICAgICAgICBLLmV5LnNldChrMTIsIGsyMik7XG4gICAgICAgIHZhciBpbXB1bHNlMSA9IEsuc29sdmUoVmVjMi5uZWcoQzEpKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICBpbXB1bHNlLnggPSBpbXB1bHNlMS54O1xuICAgICAgICBpbXB1bHNlLnkgPSBpbXB1bHNlMS55O1xuICAgICAgICBpbXB1bHNlLnogPSAwO1xuICAgIH1cbiAgICB2YXIgUCA9IFZlYzIuY29tYmluZShpbXB1bHNlLngsIHBlcnAsIGltcHVsc2UueiwgYXhpcyk7XG4gICAgLy8gVmVjMlxuICAgIHZhciBMQSA9IGltcHVsc2UueCAqIHMxICsgaW1wdWxzZS55ICsgaW1wdWxzZS56ICogYTE7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgTEIgPSBpbXB1bHNlLnggKiBzMiArIGltcHVsc2UueSArIGltcHVsc2UueiAqIGEyO1xuICAgIC8vIGZsb2F0XG4gICAgY0Euc3ViTXVsKG1BLCBQKTtcbiAgICBhQSAtPSBpQSAqIExBO1xuICAgIGNCLmFkZE11bChtQiwgUCk7XG4gICAgYUIgKz0gaUIgKiBMQjtcbiAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jID0gY0E7XG4gICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMgPSBjQjtcbiAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgcmV0dXJuIGxpbmVhckVycm9yIDw9IFNldHRpbmdzLmxpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzLmFuZ3VsYXJTbG9wO1xufTtcblxuXG59LHtcIi4uL0pvaW50XCI6NSxcIi4uL1NldHRpbmdzXCI6NyxcIi4uL2NvbW1vbi9NYXQyMlwiOjE2LFwiLi4vY29tbW9uL01hdDMzXCI6MTcsXCIuLi9jb21tb24vTWF0aFwiOjE4LFwiLi4vY29tbW9uL1Bvc2l0aW9uXCI6MTksXCIuLi9jb21tb24vUm90XCI6MjAsXCIuLi9jb21tb24vU3dlZXBcIjoyMSxcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIjoyMixcIi4uL2NvbW1vbi9WZWMyXCI6MjMsXCIuLi9jb21tb24vVmVjM1wiOjI0LFwiLi4vY29tbW9uL1ZlbG9jaXR5XCI6MjUsXCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi4vdXRpbC9jcmVhdGVcIjo1MSxcIi4uL3V0aWwvb3B0aW9uc1wiOjUyfV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFB1bGxleUpvaW50O1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgb3B0aW9ucyA9IHJlcXVpcmUoXCIuLi91dGlsL29wdGlvbnNcIik7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjM1wiKTtcblxudmFyIE1hdDIyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQyMlwiKTtcblxudmFyIE1hdDMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQzM1wiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi4vY29tbW9uL1N3ZWVwXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWxvY2l0eSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vUG9zaXRpb25cIik7XG5cbnZhciBKb2ludCA9IHJlcXVpcmUoXCIuLi9Kb2ludFwiKTtcblxuUHVsbGV5Sm9pbnQuVFlQRSA9IFwicHVsbGV5LWpvaW50XCI7XG5cblB1bGxleUpvaW50Lk1JTl9QVUxMRVlfTEVOR1RIID0gMjtcblxuLy8gbWluUHVsbGV5TGVuZ3RoXG5QdWxsZXlKb2ludC5fc3VwZXIgPSBKb2ludDtcblxuUHVsbGV5Sm9pbnQucHJvdG90eXBlID0gY3JlYXRlKFB1bGxleUpvaW50Ll9zdXBlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1bGxleUpvaW50RGVmXG4gKlxuICogUHVsbGV5IGpvaW50IGRlZmluaXRpb24uIFRoaXMgcmVxdWlyZXMgdHdvIGdyb3VuZCBhbmNob3JzLCB0d28gZHluYW1pYyBib2R5XG4gKiBhbmNob3IgcG9pbnRzLCBhbmQgYSBwdWxsZXkgcmF0aW8uXG4gKlxuICogQHByb3Age1ZlYzJ9IGdyb3VuZEFuY2hvckEgVGhlIGZpcnN0IGdyb3VuZCBhbmNob3IgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiAgICAgICAgICBUaGlzIHBvaW50IG5ldmVyIG1vdmVzLlxuICogQHByb3Age1ZlYzJ9IGdyb3VuZEFuY2hvckIgVGhlIHNlY29uZCBncm91bmQgYW5jaG9yIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogICAgICAgICAgVGhpcyBwb2ludCBuZXZlciBtb3Zlcy5cbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckEgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckIgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAqIEBwcm9wIHtmbG9hdH0gcmF0aW8gVGhlIHB1bGxleSByYXRpbywgdXNlZCB0byBzaW11bGF0ZSBhIGJsb2NrLWFuZC10YWNrbGUuXG4gKiBAcHJvcCB7ZmxvYXR9IGxlbmd0aEEgVGhlIHJlZmVyZW5jZSBsZW5ndGggZm9yIHRoZSBzZWdtZW50IGF0dGFjaGVkIHRvIGJvZHlBLlxuICogQHByb3Age2Zsb2F0fSBsZW5ndGhCIFRoZSByZWZlcmVuY2UgbGVuZ3RoIGZvciB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5Qi5cbiAqL1xudmFyIFB1bGxleUpvaW50RGVmID0ge1xuICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRydWVcbn07XG5cbi8qKlxuICogVGhlIHB1bGxleSBqb2ludCBpcyBjb25uZWN0ZWQgdG8gdHdvIGJvZGllcyBhbmQgdHdvIGZpeGVkIGdyb3VuZCBwb2ludHMuIFRoZVxuICogcHVsbGV5IHN1cHBvcnRzIGEgcmF0aW8gc3VjaCB0aGF0OiBsZW5ndGgxICsgcmF0aW8gKiBsZW5ndGgyIDw9IGNvbnN0YW50XG4gKiBcbiAqIFllcywgdGhlIGZvcmNlIHRyYW5zbWl0dGVkIGlzIHNjYWxlZCBieSB0aGUgcmF0aW8uXG4gKiBcbiAqIFdhcm5pbmc6IHRoZSBwdWxsZXkgam9pbnQgY2FuIGdldCBhIGJpdCBzcXVpcnJlbGx5IGJ5IGl0c2VsZi4gVGhleSBvZnRlbiB3b3JrXG4gKiBiZXR0ZXIgd2hlbiBjb21iaW5lZCB3aXRoIHByaXNtYXRpYyBqb2ludHMuIFlvdSBzaG91bGQgYWxzbyBjb3ZlciB0aGUgdGhlXG4gKiBhbmNob3IgcG9pbnRzIHdpdGggc3RhdGljIHNoYXBlcyB0byBwcmV2ZW50IG9uZSBzaWRlIGZyb20gZ29pbmcgdG8gemVyb1xuICogbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7UHVsbGV5Sm9pbnREZWZ9IGRlZlxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBQdWxsZXlKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgZ3JvdW5kQSwgZ3JvdW5kQiwgYW5jaG9yQSwgYW5jaG9yQiwgcmF0aW8pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHVsbGV5Sm9pbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHVsbGV5Sm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGdyb3VuZEEsIGdyb3VuZEIsIGFuY2hvckEsIGFuY2hvckIsIHJhdGlvKTtcbiAgICB9XG4gICAgZGVmID0gb3B0aW9ucyhkZWYsIFB1bGxleUpvaW50RGVmKTtcbiAgICBKb2ludC5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKTtcbiAgICBib2R5QSA9IHRoaXMubV9ib2R5QTtcbiAgICBib2R5QiA9IHRoaXMubV9ib2R5QjtcbiAgICB0aGlzLm1fdHlwZSA9IFB1bGxleUpvaW50LlRZUEU7XG4gICAgdGhpcy5tX2dyb3VuZEFuY2hvckEgPSBncm91bmRBID8gZ3JvdW5kQSA6IGRlZi5ncm91bmRBbmNob3JBIHx8IFZlYzIubmVvKC0xLCAxKTtcbiAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yQiA9IGdyb3VuZEIgPyBncm91bmRCIDogZGVmLmdyb3VuZEFuY2hvckIgfHwgVmVjMi5uZW8oMSwgMSk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvckEgPyBib2R5QS5nZXRMb2NhbFBvaW50KGFuY2hvckEpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLm5lbygtMSwgMCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IGFuY2hvckIgPyBib2R5Qi5nZXRMb2NhbFBvaW50KGFuY2hvckIpIDogZGVmLmxvY2FsQW5jaG9yQiB8fCBWZWMyLm5lbygxLCAwKTtcbiAgICB0aGlzLm1fbGVuZ3RoQSA9IE1hdGguaXNGaW5pdGUoZGVmLmxlbmd0aEEpID8gZGVmLmxlbmd0aEEgOiBWZWMyLmRpc3RhbmNlKGFuY2hvckEsIGdyb3VuZEEpO1xuICAgIHRoaXMubV9sZW5ndGhCID0gTWF0aC5pc0Zpbml0ZShkZWYubGVuZ3RoQikgPyBkZWYubGVuZ3RoQiA6IFZlYzIuZGlzdGFuY2UoYW5jaG9yQiwgZ3JvdW5kQik7XG4gICAgdGhpcy5tX3JhdGlvID0gTWF0aC5pc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IGRlZi5yYXRpbztcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQocmF0aW8gPiBNYXRoLkVQU0lMT04pO1xuICAgIHRoaXMubV9jb25zdGFudCA9IHRoaXMubV9sZW5ndGhBICsgdGhpcy5tX3JhdGlvICogdGhpcy5tX2xlbmd0aEI7XG4gICAgdGhpcy5tX2ltcHVsc2UgPSAwO1xuICAgIC8vIFNvbHZlciB0ZW1wXG4gICAgdGhpcy5tX3VBO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fdUI7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9yQTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX3JCO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJBO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1faW52TWFzc0E7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW52TWFzc0I7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW52SUE7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fbWFzcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGdyb3VuZCBhbmNob3IuXG4gKi9cblB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRHcm91bmRBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ncm91bmRBbmNob3JBO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlY29uZCBncm91bmQgYW5jaG9yLlxuICovXG5QdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0R3JvdW5kQW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZ3JvdW5kQW5jaG9yQjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5QS5cbiAqL1xuUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldExlbmd0aEEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xlbmd0aEE7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHNlZ21lbnQgYXR0YWNoZWQgdG8gYm9keUIuXG4gKi9cblB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRMZW5ndGhCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sZW5ndGhCO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHB1bGxleSByYXRpby5cbiAqL1xuUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldFJhdGlvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9yYXRpbztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5QS5cbiAqL1xuUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldEN1cnJlbnRMZW5ndGhBID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICB2YXIgcyA9IHRoaXMubV9ncm91bmRBbmNob3JBO1xuICAgIHJldHVybiBWZWMyLmRpc3RhbmNlKHAsIHMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBzZWdtZW50IGF0dGFjaGVkIHRvIGJvZHlCLlxuICovXG5QdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0Q3VycmVudExlbmd0aEIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xuICAgIHZhciBzID0gdGhpcy5tX2dyb3VuZEFuY2hvckI7XG4gICAgcmV0dXJuIFZlYzIuZGlzdGFuY2UocCwgcyk7XG59O1xuXG5QdWxsZXlKb2ludC5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbihuZXdPcmlnaW4pIHtcbiAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yQS5zdWIobmV3T3JpZ2luKTtcbiAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yQi5zdWIobmV3T3JpZ2luKTtcbn07XG5cblB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xufTtcblxuUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG59O1xuXG5QdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBWZWMyLm11bCh0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3VCKS5tdWwoaW52X2R0KTtcbn07XG5cblB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiAwO1xufTtcblxuUHVsbGV5Sm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgIC8vIEdldCB0aGUgcHVsbGV5IGF4ZXMuXG4gICAgdGhpcy5tX3VBID0gVmVjMi5zdWIoVmVjMi5hZGQoY0EsIHRoaXMubV9yQSksIHRoaXMubV9ncm91bmRBbmNob3JBKTtcbiAgICB0aGlzLm1fdUIgPSBWZWMyLnN1YihWZWMyLmFkZChjQiwgdGhpcy5tX3JCKSwgdGhpcy5tX2dyb3VuZEFuY2hvckIpO1xuICAgIHZhciBsZW5ndGhBID0gdGhpcy5tX3VBLmxlbmd0aCgpO1xuICAgIHZhciBsZW5ndGhCID0gdGhpcy5tX3VCLmxlbmd0aCgpO1xuICAgIGlmIChsZW5ndGhBID4gMTAgKiBTZXR0aW5ncy5saW5lYXJTbG9wKSB7XG4gICAgICAgIHRoaXMubV91QS5tdWwoMSAvIGxlbmd0aEEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV91QS5zZXRaZXJvKCk7XG4gICAgfVxuICAgIGlmIChsZW5ndGhCID4gMTAgKiBTZXR0aW5ncy5saW5lYXJTbG9wKSB7XG4gICAgICAgIHRoaXMubV91Qi5tdWwoMSAvIGxlbmd0aEIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV91Qi5zZXRaZXJvKCk7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgdmFyIHJ1QSA9IFZlYzIuY3Jvc3ModGhpcy5tX3JBLCB0aGlzLm1fdUEpO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIHJ1QiA9IFZlYzIuY3Jvc3ModGhpcy5tX3JCLCB0aGlzLm1fdUIpO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludklBICogcnVBICogcnVBO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklCICogcnVCICogcnVCO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX21hc3MgPSBtQSArIHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqIG1CO1xuICAgIGlmICh0aGlzLm1fbWFzcyA+IDApIHtcbiAgICAgICAgdGhpcy5tX21hc3MgPSAxIC8gdGhpcy5tX21hc3M7XG4gICAgfVxuICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IHZhcmlhYmxlIHRpbWUgc3RlcHMuXG4gICAgICAgIHRoaXMubV9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgLy8gV2FybSBzdGFydGluZy5cbiAgICAgICAgdmFyIFBBID0gVmVjMi5tdWwoLXRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdUEpO1xuICAgICAgICB2YXIgUEIgPSBWZWMyLm11bCgtdGhpcy5tX3JhdGlvICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV91Qik7XG4gICAgICAgIHZBLmFkZE11bCh0aGlzLm1faW52TWFzc0EsIFBBKTtcbiAgICAgICAgd0EgKz0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zcyh0aGlzLm1fckEsIFBBKTtcbiAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUEIpO1xuICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzKHRoaXMubV9yQiwgUEIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9pbXB1bHNlID0gMDtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuUHVsbGV5Sm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgIHZhciB2cEEgPSBWZWMyLmFkZCh2QSwgVmVjMi5jcm9zcyh3QSwgdGhpcy5tX3JBKSk7XG4gICAgdmFyIHZwQiA9IFZlYzIuYWRkKHZCLCBWZWMyLmNyb3NzKHdCLCB0aGlzLm1fckIpKTtcbiAgICB2YXIgQ2RvdCA9IC1WZWMyLmRvdCh0aGlzLm1fdUEsIHZwQSkgLSB0aGlzLm1fcmF0aW8gKiBWZWMyLmRvdCh0aGlzLm1fdUIsIHZwQik7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzcyAqIENkb3Q7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgIHZhciBQQSA9IFZlYzIubXVsKC1pbXB1bHNlLCB0aGlzLm1fdUEpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgUEIgPSBWZWMyLm11bCgtdGhpcy5tX3JhdGlvICogaW1wdWxzZSwgdGhpcy5tX3VCKTtcbiAgICAvLyBWZWMyXG4gICAgdkEuYWRkTXVsKHRoaXMubV9pbnZNYXNzQSwgUEEpO1xuICAgIHdBICs9IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3ModGhpcy5tX3JBLCBQQSk7XG4gICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUEIpO1xuICAgIHdCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3ModGhpcy5tX3JCLCBQQik7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuUHVsbGV5Sm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpLCBxQiA9IFJvdC5uZW8oYUIpO1xuICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAvLyBHZXQgdGhlIHB1bGxleSBheGVzLlxuICAgIHZhciB1QSA9IFZlYzIuc3ViKFZlYzIuYWRkKGNBLCB0aGlzLm1fckEpLCB0aGlzLm1fZ3JvdW5kQW5jaG9yQSk7XG4gICAgdmFyIHVCID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHRoaXMubV9yQiksIHRoaXMubV9ncm91bmRBbmNob3JCKTtcbiAgICB2YXIgbGVuZ3RoQSA9IHVBLmxlbmd0aCgpO1xuICAgIHZhciBsZW5ndGhCID0gdUIubGVuZ3RoKCk7XG4gICAgaWYgKGxlbmd0aEEgPiAxMCAqIFNldHRpbmdzLmxpbmVhclNsb3ApIHtcbiAgICAgICAgdUEubXVsKDEgLyBsZW5ndGhBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1QS5zZXRaZXJvKCk7XG4gICAgfVxuICAgIGlmIChsZW5ndGhCID4gMTAgKiBTZXR0aW5ncy5saW5lYXJTbG9wKSB7XG4gICAgICAgIHVCLm11bCgxIC8gbGVuZ3RoQik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdUIuc2V0WmVybygpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIGVmZmVjdGl2ZSBtYXNzLlxuICAgIHZhciBydUEgPSBWZWMyLmNyb3NzKHJBLCB1QSk7XG4gICAgdmFyIHJ1QiA9IFZlYzIuY3Jvc3MockIsIHVCKTtcbiAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBydUEgKiBydUE7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiBydUIgKiBydUI7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgbWFzcyA9IG1BICsgdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogbUI7XG4gICAgLy8gZmxvYXRcbiAgICBpZiAobWFzcyA+IDApIHtcbiAgICAgICAgbWFzcyA9IDEgLyBtYXNzO1xuICAgIH1cbiAgICB2YXIgQyA9IHRoaXMubV9jb25zdGFudCAtIGxlbmd0aEEgLSB0aGlzLm1fcmF0aW8gKiBsZW5ndGhCO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGxpbmVhckVycm9yID0gTWF0aC5hYnMoQyk7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgaW1wdWxzZSA9IC1tYXNzICogQztcbiAgICAvLyBmbG9hdFxuICAgIHZhciBQQSA9IFZlYzIubXVsKC1pbXB1bHNlLCB1QSk7XG4gICAgLy8gVmVjMlxuICAgIHZhciBQQiA9IFZlYzIubXVsKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlLCB1Qik7XG4gICAgLy8gVmVjMlxuICAgIGNBLmFkZE11bCh0aGlzLm1faW52TWFzc0EsIFBBKTtcbiAgICBhQSArPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzKHJBLCBQQSk7XG4gICAgY0IuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUEIpO1xuICAgIGFCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3MockIsIFBCKTtcbiAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jID0gY0E7XG4gICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMgPSBjQjtcbiAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgcmV0dXJuIGxpbmVhckVycm9yIDwgU2V0dGluZ3MubGluZWFyU2xvcDtcbn07XG5cblxufSx7XCIuLi9Kb2ludFwiOjUsXCIuLi9TZXR0aW5nc1wiOjcsXCIuLi9jb21tb24vTWF0MjJcIjoxNixcIi4uL2NvbW1vbi9NYXQzM1wiOjE3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4uL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4uL3V0aWwvY3JlYXRlXCI6NTEsXCIuLi91dGlsL29wdGlvbnNcIjo1Mn1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXZvbHV0ZUpvaW50O1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgb3B0aW9ucyA9IHJlcXVpcmUoXCIuLi91dGlsL29wdGlvbnNcIik7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjM1wiKTtcblxudmFyIE1hdDIyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQyMlwiKTtcblxudmFyIE1hdDMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXQzM1wiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgU3dlZXAgPSByZXF1aXJlKFwiLi4vY29tbW9uL1N3ZWVwXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWxvY2l0eSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVsb2NpdHlcIik7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vUG9zaXRpb25cIik7XG5cbnZhciBKb2ludCA9IHJlcXVpcmUoXCIuLi9Kb2ludFwiKTtcblxudmFyIGluYWN0aXZlTGltaXQgPSAwO1xuXG52YXIgYXRMb3dlckxpbWl0ID0gMTtcblxudmFyIGF0VXBwZXJMaW1pdCA9IDI7XG5cbnZhciBlcXVhbExpbWl0cyA9IDM7XG5cblJldm9sdXRlSm9pbnQuVFlQRSA9IFwicmV2b2x1dGUtam9pbnRcIjtcblxuUmV2b2x1dGVKb2ludC5fc3VwZXIgPSBKb2ludDtcblxuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUgPSBjcmVhdGUoUmV2b2x1dGVKb2ludC5fc3VwZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXZvbHV0ZUpvaW50RGVmXG4gKlxuICogUmV2b2x1dGUgam9pbnQgZGVmaW5pdGlvbi4gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhbiBhbmNob3IgcG9pbnQgd2hlcmUgdGhlXG4gKiBib2RpZXMgYXJlIGpvaW5lZC4gVGhlIGRlZmluaXRpb24gdXNlcyBsb2NhbCBhbmNob3IgcG9pbnRzIHNvIHRoYXQgdGhlXG4gKiBpbml0aWFsIGNvbmZpZ3VyYXRpb24gY2FuIHZpb2xhdGUgdGhlIGNvbnN0cmFpbnQgc2xpZ2h0bHkuIFlvdSBhbHNvIG5lZWQgdG9cbiAqIHNwZWNpZnkgdGhlIGluaXRpYWwgcmVsYXRpdmUgYW5nbGUgZm9yIGpvaW50IGxpbWl0cy4gVGhpcyBoZWxwcyB3aGVuIHNhdmluZ1xuICogYW5kIGxvYWRpbmcgYSBnYW1lLlxuICogXG4gKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50cyBhcmUgbWVhc3VyZWQgZnJvbSB0aGUgYm9keSdzIG9yaWdpbiByYXRoZXIgdGhhbiB0aGVcbiAqIGNlbnRlciBvZiBtYXNzIGJlY2F1c2U6IDEuIHlvdSBtaWdodCBub3Qga25vdyB3aGVyZSB0aGUgY2VudGVyIG9mIG1hc3Mgd2lsbFxuICogYmUuIDIuIGlmIHlvdSBhZGQvcmVtb3ZlIHNoYXBlcyBmcm9tIGEgYm9keSBhbmQgcmVjb21wdXRlIHRoZSBtYXNzLCB0aGVcbiAqIGpvaW50cyB3aWxsIGJlIGJyb2tlbi5cbiAqIFxuICogQHByb3Age2Jvb2x9IGVuYWJsZUxpbWl0IEEgZmxhZyB0byBlbmFibGUgam9pbnQgbGltaXRzLlxuICogQHByb3Age2Jvb2x9IGVuYWJsZU1vdG9yIEEgZmxhZyB0byBlbmFibGUgdGhlIGpvaW50IG1vdG9yLlxuICogQHByb3Age2Zsb2F0fSBsb3dlckFuZ2xlIFRoZSBsb3dlciBhbmdsZSBmb3IgdGhlIGpvaW50IGxpbWl0IChyYWRpYW5zKS5cbiAqIEBwcm9wIHtmbG9hdH0gdXBwZXJBbmdsZSBUaGUgdXBwZXIgYW5nbGUgZm9yIHRoZSBqb2ludCBsaW1pdCAocmFkaWFucykuXG4gKiBAcHJvcCB7ZmxvYXR9IG1vdG9yU3BlZWQgVGhlIGRlc2lyZWQgbW90b3Igc3BlZWQuIFVzdWFsbHkgaW4gcmFkaWFucyBwZXJcbiAqICAgICAgIHNlY29uZC5cbiAqIEBwcm9wIHtmbG9hdH0gbWF4TW90b3JUb3JxdWUgVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIHVzZWQgdG8gYWNoaWV2ZSB0aGVcbiAqICAgICAgIGRlc2lyZWQgbW90b3Igc3BlZWQuIFVzdWFsbHkgaW4gTi1tLlxuICpcbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckEgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckIgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAqIEBwcm9wIHtmbG9hdH0gcmVmZXJlbmNlQW5nbGUgVGhlIGJvZHlCIGFuZ2xlIG1pbnVzIGJvZHlBIGFuZ2xlIGluIHRoZVxuICogICAgICAgcmVmZXJlbmNlIHN0YXRlIChyYWRpYW5zKS5cbiAqL1xudmFyIERFRkFVTFRTID0ge1xuICAgIGxvd2VyQW5nbGU6IDAsXG4gICAgdXBwZXJBbmdsZTogMCxcbiAgICBtYXhNb3RvclRvcnF1ZTogMCxcbiAgICBtb3RvclNwZWVkOiAwLFxuICAgIGVuYWJsZUxpbWl0OiBmYWxzZSxcbiAgICBlbmFibGVNb3RvcjogZmFsc2Vcbn07XG5cbi8qKlxuICogQSByZXZvbHV0ZSBqb2ludCBjb25zdHJhaW5zIHR3byBib2RpZXMgdG8gc2hhcmUgYSBjb21tb24gcG9pbnQgd2hpbGUgdGhleSBhcmVcbiAqIGZyZWUgdG8gcm90YXRlIGFib3V0IHRoZSBwb2ludC4gVGhlIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWQgcG9pbnRcbiAqIGlzIHRoZSBqb2ludCBhbmdsZS4gWW91IGNhbiBsaW1pdCB0aGUgcmVsYXRpdmUgcm90YXRpb24gd2l0aCBhIGpvaW50IGxpbWl0XG4gKiB0aGF0IHNwZWNpZmllcyBhIGxvd2VyIGFuZCB1cHBlciBhbmdsZS4gWW91IGNhbiB1c2UgYSBtb3RvciB0byBkcml2ZSB0aGVcbiAqIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWQgcG9pbnQuIEEgbWF4aW11bSBtb3RvciB0b3JxdWUgaXMgcHJvdmlkZWRcbiAqIHNvIHRoYXQgaW5maW5pdGUgZm9yY2VzIGFyZSBub3QgZ2VuZXJhdGVkLlxuICpcbiAqIEBwYXJhbSB7UmV2b2x1dGVKb2ludERlZn0gZGVmXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIFJldm9sdXRlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXZvbHV0ZUpvaW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IFJldm9sdXRlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgfVxuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgSm9pbnQuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgYm9keUEgPSB0aGlzLm1fYm9keUE7XG4gICAgYm9keUIgPSB0aGlzLm1fYm9keUI7XG4gICAgdGhpcy5tX3R5cGUgPSBSZXZvbHV0ZUpvaW50LlRZUEU7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gTWF0aC5pc0Zpbml0ZShkZWYucmVmZXJlbmNlQW5nbGUpID8gZGVmLnJlZmVyZW5jZUFuZ2xlIDogYm9keUIuZ2V0QW5nbGUoKSAtIGJvZHlBLmdldEFuZ2xlKCk7XG4gICAgdGhpcy5tX2ltcHVsc2UgPSBWZWMzKCk7XG4gICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDA7XG4gICAgdGhpcy5tX2xvd2VyQW5nbGUgPSBkZWYubG93ZXJBbmdsZTtcbiAgICB0aGlzLm1fdXBwZXJBbmdsZSA9IGRlZi51cHBlckFuZ2xlO1xuICAgIHRoaXMubV9tYXhNb3RvclRvcnF1ZSA9IGRlZi5tYXhNb3RvclRvcnF1ZTtcbiAgICB0aGlzLm1fbW90b3JTcGVlZCA9IGRlZi5tb3RvclNwZWVkO1xuICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBkZWYuZW5hYmxlTW90b3I7XG4gICAgLy8gU29sdmVyIHRlbXBcbiAgICB0aGlzLm1fckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9yQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQjtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2ludk1hc3NBO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludk1hc3NCO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludklBO1xuICAgIC8vIGZsb2F0XG4gICAgdGhpcy5tX2ludklCO1xuICAgIC8vIGZsb2F0XG4gICAgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQuXG4gICAgdGhpcy5tX21hc3MgPSBuZXcgTWF0MzMoKTtcbiAgICAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgbW90b3IvbGltaXQgYW5ndWxhciBjb25zdHJhaW50LlxuICAgIHRoaXMubV9tb3Rvck1hc3M7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGluYWN0aXZlTGltaXQ7XG59XG5cbi8qKlxuICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG59O1xuXG4vKipcbiAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gKi9cblJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHJlZmVyZW5jZSBhbmdsZS5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlQW5nbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRBbmdsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgcmV0dXJuIGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGpvaW50IGFuZ2xlIHNwZWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRTcGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgcmV0dXJuIGJCLm1fYW5ndWxhclZlbG9jaXR5IC0gYkEubV9hbmd1bGFyVmVsb2NpdHk7XG59O1xuXG4vKipcbiAqIElzIHRoZSBqb2ludCBtb3RvciBlbmFibGVkP1xuICovXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5pc01vdG9yRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTW90b3I7XG59O1xuXG4vKipcbiAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBtb3Rvci5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBmbGFnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbW90b3IgdG9ycXVlIGdpdmVuIHRoZSBpbnZlcnNlIHRpbWUgc3RlcC4gVW5pdCBpcyBOKm0uXG4gKi9cblJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldE1vdG9yVG9ycXVlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbW90b3Igc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICovXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbW90b3Igc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICovXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gbW90b3IgdG9ycXVlLCB1c3VhbGx5IGluIE4tbS5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuc2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpIHtcbiAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9tYXhNb3RvclRvcnF1ZSA9IHRvcnF1ZTtcbn07XG5cbi8qKlxuICogSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XG4gKi9cblJldm9sdXRlSm9pbnQucHJvdG90eXBlLmlzTGltaXRFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9lbmFibGVMaW1pdDtcbn07XG5cbi8qKlxuICogRW5hYmxlL2Rpc2FibGUgdGhlIGpvaW50IGxpbWl0LlxuICovXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5lbmFibGVMaW1pdCA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICBpZiAoZmxhZyAhPSB0aGlzLm1fZW5hYmxlTGltaXQpIHtcbiAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGZsYWc7XG4gICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBsb3dlciBqb2ludCBsaW1pdCBpbiByYWRpYW5zLlxuICovXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRMb3dlckxpbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sb3dlckFuZ2xlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXG4gKi9cblJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldFVwcGVyTGltaXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3VwcGVyQW5nbGU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgam9pbnQgbGltaXRzIGluIHJhZGlhbnMuXG4gKi9cblJldm9sdXRlSm9pbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uKGxvd2VyLCB1cHBlcikge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChsb3dlciA8PSB1cHBlcik7XG4gICAgaWYgKGxvd2VyICE9IHRoaXMubV9sb3dlckFuZ2xlIHx8IHVwcGVyICE9IHRoaXMubV91cHBlckFuZ2xlKSB7XG4gICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMDtcbiAgICAgICAgdGhpcy5tX2xvd2VyQW5nbGUgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5tX3VwcGVyQW5nbGUgPSB1cHBlcjtcbiAgICB9XG59O1xuXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xufTtcblxuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBnaXZlbiB0aGUgaW52ZXJzZSB0aW1lIHN0ZXAuIFVuaXQgaXMgTi5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBWZWMyLm5lbyh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1faW1wdWxzZS55KS5tdWwoaW52X2R0KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgZHVlIHRvIHRoZSBqb2ludCBsaW1pdCBnaXZlbiB0aGUgaW52ZXJzZSB0aW1lIHN0ZXAuXG4gKiBVbml0IGlzIE4qbS5cbiAqL1xuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbihpbnZfZHQpIHtcbiAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2Uuejtcbn07XG5cblJldm9sdXRlSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICB0aGlzLm1fckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXG4gICAgLy8gWyAwIC0xIDAgMV1cbiAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cbiAgICAvLyBNYXRsYWJcbiAgICAvLyBLID0gWyBtQStyMXleMippQSttQityMnleMippQiwgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgLXIxeSppQS1yMnkqaUJdXG4gICAgLy8gWyAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgcjF4KmlBK3IyeCppQl1cbiAgICAvLyBbIC1yMXkqaUEtcjJ5KmlCLCByMXgqaUErcjJ4KmlCLCBpQStpQl1cbiAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBmaXhlZFJvdGF0aW9uID0gaUEgKyBpQiA9PT0gMDtcbiAgICAvLyBib29sXG4gICAgdGhpcy5tX21hc3MuZXgueCA9IG1BICsgbUIgKyB0aGlzLm1fckEueSAqIHRoaXMubV9yQS55ICogaUEgKyB0aGlzLm1fckIueSAqIHRoaXMubV9yQi55ICogaUI7XG4gICAgdGhpcy5tX21hc3MuZXkueCA9IC10aGlzLm1fckEueSAqIHRoaXMubV9yQS54ICogaUEgLSB0aGlzLm1fckIueSAqIHRoaXMubV9yQi54ICogaUI7XG4gICAgdGhpcy5tX21hc3MuZXoueCA9IC10aGlzLm1fckEueSAqIGlBIC0gdGhpcy5tX3JCLnkgKiBpQjtcbiAgICB0aGlzLm1fbWFzcy5leC55ID0gdGhpcy5tX21hc3MuZXkueDtcbiAgICB0aGlzLm1fbWFzcy5leS55ID0gbUEgKyBtQiArIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLnggKiBpQjtcbiAgICB0aGlzLm1fbWFzcy5lei55ID0gdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54ICogaUI7XG4gICAgdGhpcy5tX21hc3MuZXgueiA9IHRoaXMubV9tYXNzLmV6Lng7XG4gICAgdGhpcy5tX21hc3MuZXkueiA9IHRoaXMubV9tYXNzLmV6Lnk7XG4gICAgdGhpcy5tX21hc3MuZXoueiA9IGlBICsgaUI7XG4gICAgdGhpcy5tX21vdG9yTWFzcyA9IGlBICsgaUI7XG4gICAgaWYgKHRoaXMubV9tb3Rvck1hc3MgPiAwKSB7XG4gICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxIC8gdGhpcy5tX21vdG9yTWFzcztcbiAgICB9XG4gICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSB8fCBmaXhlZFJvdGF0aW9uKSB7XG4gICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0ICYmIGZpeGVkUm90YXRpb24gPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGpvaW50QW5nbGUgPSBhQiAtIGFBIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5tX3VwcGVyQW5nbGUgLSB0aGlzLm1fbG93ZXJBbmdsZSkgPCAyICogU2V0dGluZ3MuYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gZXF1YWxMaW1pdHM7XG4gICAgICAgIH0gZWxzZSBpZiAoam9pbnRBbmdsZSA8PSB0aGlzLm1fbG93ZXJBbmdsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGF0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBhdExvd2VyTGltaXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoam9pbnRBbmdsZSA+PSB0aGlzLm1fdXBwZXJBbmdsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGF0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBhdFVwcGVyTGltaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGluYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gaW5hY3RpdmVMaW1pdDtcbiAgICB9XG4gICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgIHRoaXMubV9pbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgdmFyIFAgPSBWZWMyLm5lbyh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1faW1wdWxzZS55KTtcbiAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgd0EgLT0gaUEgKiAoVmVjMi5jcm9zcyh0aGlzLm1fckEsIFApICsgdGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCkgKyB0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2ltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMDtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xufTtcblxuUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgZml4ZWRSb3RhdGlvbiA9IGlBICsgaUIgPT09IDA7XG4gICAgLy8gYm9vbFxuICAgIC8vIFNvbHZlIG1vdG9yIGNvbnN0cmFpbnQuXG4gICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBlcXVhbExpbWl0cyAmJiBmaXhlZFJvdGF0aW9uID09IGZhbHNlKSB7XG4gICAgICAgIHZhciBDZG90ID0gd0IgLSB3QSAtIHRoaXMubV9tb3RvclNwZWVkO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbW90b3JNYXNzICogQ2RvdDtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JUb3JxdWU7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBNYXRoLmNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgfVxuICAgIC8vIFNvbHZlIGxpbWl0IGNvbnN0cmFpbnQuXG4gICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBpbmFjdGl2ZUxpbWl0ICYmIGZpeGVkUm90YXRpb24gPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIENkb3QxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIENkb3QxLmFkZENvbWJpbmUoMSwgdkIsIDEsIFZlYzIuY3Jvc3Mod0IsIHRoaXMubV9yQikpO1xuICAgICAgICBDZG90MS5zdWJDb21iaW5lKDEsIHZBLCAxLCBWZWMyLmNyb3NzKHdBLCB0aGlzLm1fckEpKTtcbiAgICAgICAgdmFyIENkb3QyID0gd0IgLSB3QTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIENkb3QgPSBWZWMzKENkb3QxLngsIENkb3QxLnksIENkb3QyKTtcbiAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMzLm5lZyh0aGlzLm1fbWFzcy5zb2x2ZTMzKENkb3QpKTtcbiAgICAgICAgLy8gVmVjM1xuICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gZXF1YWxMaW1pdHMpIHtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBhdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgIHZhciBuZXdJbXB1bHNlID0gdGhpcy5tX2ltcHVsc2UueiArIGltcHVsc2UuejtcbiAgICAgICAgICAgIC8vIGZsb2F0XG4gICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA8IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmhzID0gVmVjMi5jb21iaW5lKC0xLCBDZG90MSwgdGhpcy5tX2ltcHVsc2UueiwgVmVjMi5uZW8odGhpcy5tX21hc3MuZXoueCwgdGhpcy5tX21hc3MuZXoueSkpO1xuICAgICAgICAgICAgICAgIC8vIFZlYzJcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZCA9IHRoaXMubV9tYXNzLnNvbHZlMjIocmhzKTtcbiAgICAgICAgICAgICAgICAvLyBWZWMyXG4gICAgICAgICAgICAgICAgaW1wdWxzZS54ID0gcmVkdWNlZC54O1xuICAgICAgICAgICAgICAgIGltcHVsc2UueSA9IHJlZHVjZWQueTtcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnogPSAtdGhpcy5tX2ltcHVsc2UuejtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IHJlZHVjZWQueDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ICs9IHJlZHVjZWQueTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGF0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgdmFyIG5ld0ltcHVsc2UgPSB0aGlzLm1faW1wdWxzZS56ICsgaW1wdWxzZS56O1xuICAgICAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciByaHMgPSBWZWMyLmNvbWJpbmUoLTEsIENkb3QxLCB0aGlzLm1faW1wdWxzZS56LCBWZWMyLm5lbyh0aGlzLm1fbWFzcy5lei54LCB0aGlzLm1fbWFzcy5lei55KSk7XG4gICAgICAgICAgICAgICAgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkID0gdGhpcy5tX21hc3Muc29sdmUyMihyaHMpO1xuICAgICAgICAgICAgICAgIC8vIFZlYzJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSByZWR1Y2VkLng7XG4gICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gcmVkdWNlZC55O1xuICAgICAgICAgICAgICAgIGltcHVsc2UueiA9IC10aGlzLm1faW1wdWxzZS56O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gcmVkdWNlZC54O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gcmVkdWNlZC55O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFAgPSBWZWMyLm5lbyhpbXB1bHNlLngsIGltcHVsc2UueSk7XG4gICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3ModGhpcy5tX3JBLCBQKSArIGltcHVsc2Uueik7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogKFZlYzIuY3Jvc3ModGhpcy5tX3JCLCBQKSArIGltcHVsc2Uueik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxuICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuemVybygpO1xuICAgICAgICBDZG90LmFkZENvbWJpbmUoMSwgdkIsIDEsIFZlYzIuY3Jvc3Mod0IsIHRoaXMubV9yQikpO1xuICAgICAgICBDZG90LnN1YkNvbWJpbmUoMSwgdkEsIDEsIFZlYzIuY3Jvc3Mod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICB2YXIgaW1wdWxzZSA9IHRoaXMubV9tYXNzLnNvbHZlMjIoVmVjMi5uZWcoQ2RvdCkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gaW1wdWxzZS54O1xuICAgICAgICB0aGlzLm1faW1wdWxzZS55ICs9IGltcHVsc2UueTtcbiAgICAgICAgdkEuc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzKHRoaXMubV9yQSwgaW1wdWxzZSk7XG4gICAgICAgIHZCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zcyh0aGlzLm1fckIsIGltcHVsc2UpO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5SZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICB2YXIgYW5ndWxhckVycm9yID0gMDtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBwb3NpdGlvbkVycm9yID0gMDtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBmaXhlZFJvdGF0aW9uID0gdGhpcy5tX2ludklBICsgdGhpcy5tX2ludklCID09IDA7XG4gICAgLy8gYm9vbFxuICAgIC8vIFNvbHZlIGFuZ3VsYXIgbGltaXQgY29uc3RyYWludC5cbiAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0ICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGluYWN0aXZlTGltaXQgJiYgZml4ZWRSb3RhdGlvbiA9PSBmYWxzZSkge1xuICAgICAgICB2YXIgYW5nbGUgPSBhQiAtIGFBIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgbGltaXRJbXB1bHNlID0gMDtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGVxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnNcbiAgICAgICAgICAgIHZhciBDID0gTWF0aC5jbGFtcChhbmdsZSAtIHRoaXMubV9sb3dlckFuZ2xlLCAtU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24sIFNldHRpbmdzLm1heEFuZ3VsYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIGZsb2F0XG4gICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIEM7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBNYXRoLmFicyhDKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBhdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgIHZhciBDID0gYW5nbGUgLSB0aGlzLm1fbG93ZXJBbmdsZTtcbiAgICAgICAgICAgIC8vIGZsb2F0XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAtQztcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxuICAgICAgICAgICAgQyA9IE1hdGguY2xhbXAoQyArIFNldHRpbmdzLmFuZ3VsYXJTbG9wLCAtU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24sIDApO1xuICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLXRoaXMubV9tb3Rvck1hc3MgKiBDO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGF0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgdmFyIEMgPSBhbmdsZSAtIHRoaXMubV91cHBlckFuZ2xlO1xuICAgICAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IEM7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cbiAgICAgICAgICAgIEMgPSBNYXRoLmNsYW1wKEMgLSBTZXR0aW5ncy5hbmd1bGFyU2xvcCwgMCwgU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLXRoaXMubV9tb3Rvck1hc3MgKiBDO1xuICAgICAgICB9XG4gICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIGxpbWl0SW1wdWxzZTtcbiAgICAgICAgYUIgKz0gdGhpcy5tX2ludklCICogbGltaXRJbXB1bHNlO1xuICAgIH1cbiAgICAvLyBTb2x2ZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50LlxuICAgIHtcbiAgICAgICAgcUEuc2V0KGFBKTtcbiAgICAgICAgcUIuc2V0KGFCKTtcbiAgICAgICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciBDID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIEMuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgICAgICBDLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHJBKTtcbiAgICAgICAgcG9zaXRpb25FcnJvciA9IEMubGVuZ3RoKCk7XG4gICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIEsgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgSy5leC54ID0gbUEgKyBtQiArIGlBICogckEueSAqIHJBLnkgKyBpQiAqIHJCLnkgKiByQi55O1xuICAgICAgICBLLmV4LnkgPSAtaUEgKiByQS54ICogckEueSAtIGlCICogckIueCAqIHJCLnk7XG4gICAgICAgIEsuZXkueCA9IEsuZXgueTtcbiAgICAgICAgSy5leS55ID0gbUEgKyBtQiArIGlBICogckEueCAqIHJBLnggKyBpQiAqIHJCLnggKiByQi54O1xuICAgICAgICB2YXIgaW1wdWxzZSA9IFZlYzIubmVnKEsuc29sdmUoQykpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIGNBLnN1Yk11bChtQSwgaW1wdWxzZSk7XG4gICAgICAgIGFBIC09IGlBICogVmVjMi5jcm9zcyhyQSwgaW1wdWxzZSk7XG4gICAgICAgIGNCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgIGFCICs9IGlCICogVmVjMi5jcm9zcyhyQiwgaW1wdWxzZSk7XG4gICAgfVxuICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmMuc2V0KGNBKTtcbiAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXQoY0IpO1xuICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICByZXR1cm4gcG9zaXRpb25FcnJvciA8PSBTZXR0aW5ncy5saW5lYXJTbG9wICYmIGFuZ3VsYXJFcnJvciA8PSBTZXR0aW5ncy5hbmd1bGFyU2xvcDtcbn07XG5cblxufSx7XCIuLi9Kb2ludFwiOjUsXCIuLi9TZXR0aW5nc1wiOjcsXCIuLi9jb21tb24vTWF0MjJcIjoxNixcIi4uL2NvbW1vbi9NYXQzM1wiOjE3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4uL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4uL3V0aWwvY3JlYXRlXCI6NTEsXCIuLi91dGlsL29wdGlvbnNcIjo1Mn1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3BlSm9pbnQ7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL2NyZWF0ZVwiKTtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBWZWMzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMzXCIpO1xuXG52YXIgTWF0MjIgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDIyXCIpO1xuXG52YXIgTWF0MzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdDMzXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBTd2VlcCA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3dlZXBcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFZlbG9jaXR5ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWxvY2l0eVwiKTtcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Qb3NpdGlvblwiKTtcblxudmFyIEpvaW50ID0gcmVxdWlyZShcIi4uL0pvaW50XCIpO1xuXG52YXIgaW5hY3RpdmVMaW1pdCA9IDA7XG5cbnZhciBhdExvd2VyTGltaXQgPSAxO1xuXG52YXIgYXRVcHBlckxpbWl0ID0gMjtcblxudmFyIGVxdWFsTGltaXRzID0gMztcblxuUm9wZUpvaW50LlRZUEUgPSBcInJvcGUtam9pbnRcIjtcblxuUm9wZUpvaW50Ll9zdXBlciA9IEpvaW50O1xuXG5Sb3BlSm9pbnQucHJvdG90eXBlID0gY3JlYXRlKFJvcGVKb2ludC5fc3VwZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSb3BlSm9pbnREZWZcbiAqXG4gKiBSb3BlIGpvaW50IGRlZmluaXRpb24uIFRoaXMgcmVxdWlyZXMgdHdvIGJvZHkgYW5jaG9yIHBvaW50cyBhbmQgYSBtYXhpbXVtXG4gKiBsZW5ndGhzLiBOb3RlOiBieSBkZWZhdWx0IHRoZSBjb25uZWN0ZWQgb2JqZWN0cyB3aWxsIG5vdCBjb2xsaWRlLiBzZWVcbiAqIGNvbGxpZGVDb25uZWN0ZWQgaW4gSm9pbnREZWYuXG4gKlxuICogQHByb3Age2Zsb2F0fSBtYXhMZW5ndGggVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSByb3BlLiBXYXJuaW5nOiB0aGlzIG11c3QgYmVcbiAqICAgICAgIGxhcmdlciB0aGFuIGxpbmVhclNsb3Agb3IgdGhlIGpvaW50IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQHByb3Age1ZlYzJ9IGRlZi5sb2NhbEFuY2hvckEgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqIEBwcm9wIHtWZWMyfSBkZWYubG9jYWxBbmNob3JCIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gKi9cbnZhciBERUZBVUxUUyA9IHtcbiAgICBtYXhMZW5ndGg6IDBcbn07XG5cbi8qKlxuICogQSByb3BlIGpvaW50IGVuZm9yY2VzIGEgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgb24gdHdvIGJvZGllcy4gSXRcbiAqIGhhcyBubyBvdGhlciBlZmZlY3QuXG4gKiBcbiAqIFdhcm5pbmc6IGlmIHlvdSBhdHRlbXB0IHRvIGNoYW5nZSB0aGUgbWF4aW11bSBsZW5ndGggZHVyaW5nIHRoZSBzaW11bGF0aW9uXG4gKiB5b3Ugd2lsbCBnZXQgc29tZSBub24tcGh5c2ljYWwgYmVoYXZpb3IuXG4gKiBcbiAqIEEgbW9kZWwgdGhhdCB3b3VsZCBhbGxvdyB5b3UgdG8gZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSBsZW5ndGggd291bGQgaGF2ZSBzb21lXG4gKiBzcG9uZ2luZXNzLCBzbyBJIGNob3NlIG5vdCB0byBpbXBsZW1lbnQgaXQgdGhhdCB3YXkuIFNlZSBEaXN0YW5jZUpvaW50IGlmIHlvdVxuICogd2FudCB0byBkeW5hbWljYWxseSBjb250cm9sIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge1JvcGVKb2ludERlZn0gZGVmXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIFJvcGVKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJvcGVKb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3BlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgfVxuICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgSm9pbnQuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgYm9keUEgPSB0aGlzLm1fYm9keUE7XG4gICAgYm9keUIgPSB0aGlzLm1fYm9keUI7XG4gICAgdGhpcy5tX3R5cGUgPSBSb3BlSm9pbnQuVFlQRTtcbiAgICB0aGlzLm1fbG9jYWxBbmNob3JBID0gYW5jaG9yID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLm5lbygtMSwgMCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi5uZW8oMSwgMCk7XG4gICAgdGhpcy5tX21heExlbmd0aCA9IGRlZi5tYXhMZW5ndGg7XG4gICAgdGhpcy5tX21hc3MgPSAwO1xuICAgIHRoaXMubV9pbXB1bHNlID0gMDtcbiAgICB0aGlzLm1fbGVuZ3RoID0gMDtcbiAgICB0aGlzLm1fc3RhdGUgPSBpbmFjdGl2ZUxpbWl0O1xuICAgIC8vIFNvbHZlciB0ZW1wXG4gICAgdGhpcy5tX3U7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9yQTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX3JCO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJBO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJCO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1faW52TWFzc0E7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW52TWFzc0I7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW52SUE7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fbWFzcztcbn1cblxuLyoqXG4gKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICovXG5Sb3BlSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JBO1xufTtcblxuLyoqXG4gKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICovXG5Sb3BlSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xufTtcblxuLyoqXG4gKiBTZXQvR2V0IHRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcm9wZS5cbiAqL1xuUm9wZUpvaW50LnByb3RvdHlwZS5zZXRNYXhMZW5ndGggPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB0aGlzLm1fbWF4TGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUm9wZUpvaW50LnByb3RvdHlwZS5nZXRNYXhMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX21heExlbmd0aDtcbn07XG5cblJvcGVKb2ludC5wcm90b3R5cGUuZ2V0TGltaXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE8gTGltaXRTdGF0ZVxuICAgIHJldHVybiB0aGlzLm1fc3RhdGU7XG59O1xuXG5Sb3BlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG59O1xuXG5Sb3BlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG59O1xuXG5Sb3BlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbihpbnZfZHQpIHtcbiAgICByZXR1cm4gVmVjMi5tdWwodGhpcy5tX2ltcHVsc2UsIHRoaXMubV91KS5tdWwoaW52X2R0KTtcbn07XG5cblJvcGVKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbihpbnZfZHQpIHtcbiAgICByZXR1cm4gMDtcbn07XG5cblJvcGVKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICB0aGlzLm1fckEgPSBSb3QubXVsU3ViKHFBLCB0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKTtcbiAgICB0aGlzLm1fckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKTtcbiAgICB0aGlzLm1fdSA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV91LmFkZENvbWJpbmUoMSwgY0IsIDEsIHRoaXMubV9yQik7XG4gICAgdGhpcy5tX3Uuc3ViQ29tYmluZSgxLCBjQSwgMSwgdGhpcy5tX3JBKTtcbiAgICAvLyBWZWMyXG4gICAgdGhpcy5tX2xlbmd0aCA9IHRoaXMubV91Lmxlbmd0aCgpO1xuICAgIHZhciBDID0gdGhpcy5tX2xlbmd0aCAtIHRoaXMubV9tYXhMZW5ndGg7XG4gICAgLy8gZmxvYXRcbiAgICBpZiAoQyA+IDApIHtcbiAgICAgICAgdGhpcy5tX3N0YXRlID0gYXRVcHBlckxpbWl0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9zdGF0ZSA9IGluYWN0aXZlTGltaXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm1fbGVuZ3RoID4gU2V0dGluZ3MubGluZWFyU2xvcCkge1xuICAgICAgICB0aGlzLm1fdS5tdWwoMSAvIHRoaXMubV9sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV91LnNldFplcm8oKTtcbiAgICAgICAgdGhpcy5tX21hc3MgPSAwO1xuICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cbiAgICB2YXIgY3JBID0gVmVjMi5jcm9zcyh0aGlzLm1fckEsIHRoaXMubV91KTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBjckIgPSBWZWMyLmNyb3NzKHRoaXMubV9yQiwgdGhpcy5tX3UpO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGludk1hc3MgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBjckEgKiBjckEgKyB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiBjckIgKiBjckI7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMCA/IDEgLyBpbnZNYXNzIDogMDtcbiAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgLy8gU2NhbGUgdGhlIGltcHVsc2UgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICB2YXIgUCA9IFZlYzIubXVsKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdSk7XG4gICAgICAgIHZBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgICAgICB3QSAtPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCk7XG4gICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldCh2QSk7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0KHZCKTtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5Sb3BlSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgIC8vIENkb3QgPSBkb3QodSwgdiArIGNyb3NzKHcsIHIpKVxuICAgIHZhciB2cEEgPSBWZWMyLmFkZENyb3NzKHZBLCB3QSwgdGhpcy5tX3JBKTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIHZwQiA9IFZlYzIuYWRkQ3Jvc3ModkIsIHdCLCB0aGlzLm1fckIpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgQyA9IHRoaXMubV9sZW5ndGggLSB0aGlzLm1fbWF4TGVuZ3RoO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fdSwgVmVjMi5zdWIodnBCLCB2cEEpKTtcbiAgICAvLyBmbG9hdFxuICAgIC8vIFByZWRpY3RpdmUgY29uc3RyYWludC5cbiAgICBpZiAoQyA8IDApIHtcbiAgICAgICAgQ2RvdCArPSBzdGVwLmludl9kdCAqIEM7XG4gICAgfVxuICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQ2RvdDtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2ltcHVsc2U7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1faW1wdWxzZSA9IE1hdGgubWluKDAsIHRoaXMubV9pbXB1bHNlICsgaW1wdWxzZSk7XG4gICAgaW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICB2YXIgUCA9IFZlYzIubXVsKGltcHVsc2UsIHRoaXMubV91KTtcbiAgICAvLyBWZWMyXG4gICAgdkEuc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgd0EgLT0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zcyh0aGlzLm1fckEsIFApO1xuICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgIHdCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3ModGhpcy5tX3JCLCBQKTtcbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5Sb3BlSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAvLyBWZWMyXG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgIHZhciByQSA9IFJvdC5tdWxTdWIocUEsIHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpO1xuICAgIHZhciByQiA9IFJvdC5tdWxTdWIocUIsIHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpO1xuICAgIHZhciB1ID0gVmVjMi56ZXJvKCk7XG4gICAgdS5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgdS5zdWJDb21iaW5lKDEsIGNBLCAxLCByQSk7XG4gICAgLy8gVmVjMlxuICAgIHZhciBsZW5ndGggPSB1Lm5vcm1hbGl6ZSgpO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIEMgPSBsZW5ndGggLSB0aGlzLm1fbWF4TGVuZ3RoO1xuICAgIC8vIGZsb2F0XG4gICAgQyA9IE1hdGguY2xhbXAoQywgMCwgU2V0dGluZ3MubWF4TGluZWFyQ29ycmVjdGlvbik7XG4gICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21hc3MgKiBDO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIFAgPSBWZWMyLm11bChpbXB1bHNlLCB1KTtcbiAgICAvLyBWZWMyXG4gICAgY0Euc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgYUEgLT0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zcyhyQSwgUCk7XG4gICAgY0IuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgYUIgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zcyhyQiwgUCk7XG4gICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYy5zZXQoY0EpO1xuICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jLnNldChjQik7XG4gICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYSA9IGFCO1xuICAgIHJldHVybiBsZW5ndGggLSB0aGlzLm1fbWF4TGVuZ3RoIDwgU2V0dGluZ3MubGluZWFyU2xvcDtcbn07XG5cblxufSx7XCIuLi9Kb2ludFwiOjUsXCIuLi9TZXR0aW5nc1wiOjcsXCIuLi9jb21tb24vTWF0MjJcIjoxNixcIi4uL2NvbW1vbi9NYXQzM1wiOjE3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4uL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi4vdXRpbC9jcmVhdGVcIjo1MSxcIi4uL3V0aWwvb3B0aW9uc1wiOjUyfV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlbGRKb2ludDtcblxudmFyIG9wdGlvbnMgPSByZXF1aXJlKFwiLi4vdXRpbC9vcHRpb25zXCIpO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZShcIi4uL3V0aWwvY3JlYXRlXCIpO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vU2V0dGluZ3NcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjMlwiKTtcblxudmFyIFZlYzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzNcIik7XG5cbnZhciBNYXQyMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0MjJcIik7XG5cbnZhciBNYXQzMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0MzNcIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL1JvdFwiKTtcblxudmFyIFN3ZWVwID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Td2VlcFwiKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgVmVsb2NpdHkgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlbG9jaXR5XCIpO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKFwiLi4vY29tbW9uL1Bvc2l0aW9uXCIpO1xuXG52YXIgSm9pbnQgPSByZXF1aXJlKFwiLi4vSm9pbnRcIik7XG5cbldlbGRKb2ludC5UWVBFID0gXCJ3ZWxkLWpvaW50XCI7XG5cbldlbGRKb2ludC5fc3VwZXIgPSBKb2ludDtcblxuV2VsZEpvaW50LnByb3RvdHlwZSA9IGNyZWF0ZShXZWxkSm9pbnQuX3N1cGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV2VsZEpvaW50RGVmXG4gKlxuICogV2VsZCBqb2ludCBkZWZpbml0aW9uLiBZb3UgbmVlZCB0byBzcGVjaWZ5IGxvY2FsIGFuY2hvciBwb2ludHMgd2hlcmUgdGhleSBhcmVcbiAqIGF0dGFjaGVkIGFuZCB0aGUgcmVsYXRpdmUgYm9keSBhbmdsZS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBhbmNob3IgcG9pbnRzIGlzXG4gKiBpbXBvcnRhbnQgZm9yIGNvbXB1dGluZyB0aGUgcmVhY3Rpb24gdG9ycXVlLlxuICogXG4gKiBAcHJvcCB7ZmxvYXR9IGZyZXF1ZW5jeUh6IFRoZSBtYXNzLXNwcmluZy1kYW1wZXIgZnJlcXVlbmN5IGluIEhlcnR6LiBSb3RhdGlvblxuICogICAgICAgb25seS4gRGlzYWJsZSBzb2Z0bmVzcyB3aXRoIGEgdmFsdWUgb2YgMC5cbiAqIEBwcm9wIHtmbG9hdH0gZGFtcGluZ1JhdGlvIFRoZSBkYW1waW5nIHJhdGlvLiAwID0gbm8gZGFtcGluZywgMSA9IGNyaXRpY2FsXG4gKiAgICAgICBkYW1waW5nLlxuICpcbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckEgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqIEBwcm9wIHtWZWMyfSBsb2NhbEFuY2hvckIgVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAqIEBwcm9wIHtmbG9hdH0gcmVmZXJlbmNlQW5nbGUgVGhlIGJvZHlCIGFuZ2xlIG1pbnVzIGJvZHlBIGFuZ2xlIGluIHRoZVxuICogICAgICAgcmVmZXJlbmNlIHN0YXRlIChyYWRpYW5zKS5cbiAqL1xudmFyIERFRkFVTFRTID0ge1xuICAgIGZyZXF1ZW5jeUh6OiAwLFxuICAgIGRhbXBpbmdSYXRpbzogMFxufTtcblxuLyoqXG4gKiBBIHdlbGQgam9pbnQgZXNzZW50aWFsbHkgZ2x1ZXMgdHdvIGJvZGllcyB0b2dldGhlci4gQSB3ZWxkIGpvaW50IG1heSBkaXN0b3J0XG4gKiBzb21ld2hhdCBiZWNhdXNlIHRoZSBpc2xhbmQgY29uc3RyYWludCBzb2x2ZXIgaXMgYXBwcm94aW1hdGUuXG4gKlxuICogQHBhcmFtIHtXZWxkSm9pbnREZWZ9IGRlZlxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBXZWxkSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXZWxkSm9pbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2VsZEpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IpO1xuICAgIH1cbiAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMpO1xuICAgIEpvaW50LmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpO1xuICAgIGJvZHlBID0gdGhpcy5tX2JvZHlBO1xuICAgIGJvZHlCID0gdGhpcy5tX2JvZHlCO1xuICAgIHRoaXMubV90eXBlID0gV2VsZEpvaW50LlRZUEU7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX2xvY2FsQW5jaG9yQiA9IGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gTWF0aC5pc0Zpbml0ZShkZWYucmVmZXJlbmNlQW5nbGUpID8gZGVmLnJlZmVyZW5jZUFuZ2xlIDogYm9keUIuZ2V0QW5nbGUoKSAtIGJvZHlBLmdldEFuZ2xlKCk7XG4gICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gZGVmLmZyZXF1ZW5jeUh6O1xuICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgIHRoaXMubV9pbXB1bHNlID0gVmVjMygpO1xuICAgIHRoaXMubV9iaWFzID0gMDtcbiAgICB0aGlzLm1fZ2FtbWEgPSAwO1xuICAgIC8vIFNvbHZlciB0ZW1wXG4gICAgdGhpcy5tX3JBO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fckI7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9sb2NhbENlbnRlckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9sb2NhbENlbnRlckI7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9pbnZNYXNzQTtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZJQTtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZJQjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9tYXNzID0gbmV3IE1hdDMzKCk7XG59XG5cbi8qKlxuICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqL1xuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbn07XG5cbi8qKlxuICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cbiAqL1xuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZWZlcmVuY2UgYW5nbGUuXG4gKi9cbldlbGRKb2ludC5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlQW5nbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQvZ2V0IGZyZXF1ZW5jeSBpbiBIei5cbiAqL1xuV2VsZEpvaW50LnByb3RvdHlwZS5zZXRGcmVxdWVuY3kgPSBmdW5jdGlvbihoeikge1xuICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xufTtcblxuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRGcmVxdWVuY3kgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xufTtcblxuLyoqXG4gKiBTZXQvZ2V0IGRhbXBpbmcgcmF0aW8uXG4gKi9cbldlbGRKb2ludC5wcm90b3R5cGUuc2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24ocmF0aW8pIHtcbiAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gcmF0aW87XG59O1xuXG5XZWxkSm9pbnQucHJvdG90eXBlLmdldERhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZGFtcGluZ1JhdGlvO1xufTtcblxuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xufTtcblxuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xufTtcblxuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIFZlYzIubmVvKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9pbXB1bHNlLnkpLm11bChpbnZfZHQpO1xufTtcblxuV2VsZEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS56O1xufTtcblxuV2VsZEpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHFBID0gUm90Lm5lbyhhQSksIHFCID0gUm90Lm5lbyhhQik7XG4gICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3XVxuICAgIC8vIFsgMCAtMSAwIDFdXG4gICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXG4gICAgLy8gTWF0bGFiXG4gICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIC1yMXkqaUEtcjJ5KmlCXVxuICAgIC8vIFsgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsIHIxeCppQStyMngqaUJdXG4gICAgLy8gWyAtcjF5KmlBLXIyeSppQiwgcjF4KmlBK3IyeCppQiwgaUEraUJdXG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgSyA9IG5ldyBNYXQzMygpO1xuICAgIEsuZXgueCA9IG1BICsgbUIgKyB0aGlzLm1fckEueSAqIHRoaXMubV9yQS55ICogaUEgKyB0aGlzLm1fckIueSAqIHRoaXMubV9yQi55ICogaUI7XG4gICAgSy5leS54ID0gLXRoaXMubV9yQS55ICogdGhpcy5tX3JBLnggKiBpQSAtIHRoaXMubV9yQi55ICogdGhpcy5tX3JCLnggKiBpQjtcbiAgICBLLmV6LnggPSAtdGhpcy5tX3JBLnkgKiBpQSAtIHRoaXMubV9yQi55ICogaUI7XG4gICAgSy5leC55ID0gSy5leS54O1xuICAgIEsuZXkueSA9IG1BICsgbUIgKyB0aGlzLm1fckEueCAqIHRoaXMubV9yQS54ICogaUEgKyB0aGlzLm1fckIueCAqIHRoaXMubV9yQi54ICogaUI7XG4gICAgSy5lei55ID0gdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54ICogaUI7XG4gICAgSy5leC56ID0gSy5lei54O1xuICAgIEsuZXkueiA9IEsuZXoueTtcbiAgICBLLmV6LnogPSBpQSArIGlCO1xuICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwKSB7XG4gICAgICAgIEsuZ2V0SW52ZXJzZTIyKHRoaXMubV9tYXNzKTtcbiAgICAgICAgdmFyIGludk0gPSBpQSArIGlCO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgbSA9IGludk0gPiAwID8gMSAvIGludk0gOiAwO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgQyA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIC8vIEZyZXF1ZW5jeVxuICAgICAgICB2YXIgb21lZ2EgPSAyICogTWF0aC5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxuICAgICAgICB2YXIgZCA9IDIgKiBtICogdGhpcy5tX2RhbXBpbmdSYXRpbyAqIG9tZWdhO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXG4gICAgICAgIHZhciBrID0gbSAqIG9tZWdhICogb21lZ2E7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIC8vIG1hZ2ljIGZvcm11bGFzXG4gICAgICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdGhpcy5tX2dhbW1hID0gaCAqIChkICsgaCAqIGspO1xuICAgICAgICB0aGlzLm1fZ2FtbWEgPSB0aGlzLm1fZ2FtbWEgIT0gMCA/IDEgLyB0aGlzLm1fZ2FtbWEgOiAwO1xuICAgICAgICB0aGlzLm1fYmlhcyA9IEMgKiBoICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgICAgaW52TSArPSB0aGlzLm1fZ2FtbWE7XG4gICAgICAgIHRoaXMubV9tYXNzLmV6LnogPSBpbnZNICE9IDAgPyAxIC8gaW52TSA6IDA7XG4gICAgfSBlbHNlIGlmIChLLmV6LnogPT0gMCkge1xuICAgICAgICBLLmdldEludmVyc2UyMih0aGlzLm1fbWFzcyk7XG4gICAgICAgIHRoaXMubV9nYW1tYSA9IDA7XG4gICAgICAgIHRoaXMubV9iaWFzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBLLmdldFN5bUludmVyc2UzMyh0aGlzLm1fbWFzcyk7XG4gICAgICAgIHRoaXMubV9nYW1tYSA9IDA7XG4gICAgICAgIHRoaXMubV9iaWFzID0gMDtcbiAgICB9XG4gICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgIHRoaXMubV9pbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9pbXB1bHNlLnkpO1xuICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1faW1wdWxzZS56KTtcbiAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zcyh0aGlzLm1fckIsIFApICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX2ltcHVsc2Uuc2V0WmVybygpO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5XZWxkSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgIC8vIGZsb2F0XG4gICAgaWYgKHRoaXMubV9mcmVxdWVuY3lIeiA+IDApIHtcbiAgICAgICAgdmFyIENkb3QyID0gd0IgLSB3QTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIGltcHVsc2UyID0gLXRoaXMubV9tYXNzLmV6LnogKiAoQ2RvdDIgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB0aGlzLm1faW1wdWxzZS56ICs9IGltcHVsc2UyO1xuICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2UyO1xuICAgICAgICB3QiArPSBpQiAqIGltcHVsc2UyO1xuICAgICAgICB2YXIgQ2RvdDEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgQ2RvdDEuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zcyh3QiwgdGhpcy5tX3JCKSk7XG4gICAgICAgIENkb3QxLnN1YkNvbWJpbmUoMSwgdkEsIDEsIFZlYzIuY3Jvc3Mod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHZhciBpbXB1bHNlMSA9IFZlYzIubmVnKE1hdDMzLm11bFZlYzIodGhpcy5tX21hc3MsIENkb3QxKSk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSBpbXB1bHNlMS54O1xuICAgICAgICB0aGlzLm1faW1wdWxzZS55ICs9IGltcHVsc2UxLnk7XG4gICAgICAgIHZhciBQID0gVmVjMi5jbG9uZShpbXB1bHNlMSk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCk7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zcyh0aGlzLm1fckIsIFApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBDZG90MSA9IFZlYzIuemVybygpO1xuICAgICAgICBDZG90MS5hZGRDb21iaW5lKDEsIHZCLCAxLCBWZWMyLmNyb3NzKHdCLCB0aGlzLm1fckIpKTtcbiAgICAgICAgQ2RvdDEuc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zcyh3QSwgdGhpcy5tX3JBKSk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdmFyIENkb3QyID0gd0IgLSB3QTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIENkb3QgPSBWZWMzKENkb3QxLngsIENkb3QxLnksIENkb3QyKTtcbiAgICAgICAgLy8gVmVjM1xuICAgICAgICB2YXIgaW1wdWxzZSA9IFZlYzMubmVnKE1hdDMzLm11bFZlYzModGhpcy5tX21hc3MsIENkb3QpKTtcbiAgICAgICAgLy8gVmVjM1xuICAgICAgICB0aGlzLm1faW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgIHZhciBQID0gVmVjMi5uZW8oaW1wdWxzZS54LCBpbXB1bHNlLnkpO1xuICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzKHRoaXMubV9yQSwgUCkgKyBpbXB1bHNlLnopO1xuICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICB3QiArPSBpQiAqIChWZWMyLmNyb3NzKHRoaXMubV9yQiwgUCkgKyBpbXB1bHNlLnopO1xuICAgIH1cbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG59O1xuXG5XZWxkSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpLCBxQiA9IFJvdC5uZW8oYUIpO1xuICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQSwgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgaUEgPSB0aGlzLm1faW52SUEsIGlCID0gdGhpcy5tX2ludklCO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgIHZhciBwb3NpdGlvbkVycm9yLCBhbmd1bGFyRXJyb3I7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgSyA9IG5ldyBNYXQzMygpO1xuICAgIEsuZXgueCA9IG1BICsgbUIgKyByQS55ICogckEueSAqIGlBICsgckIueSAqIHJCLnkgKiBpQjtcbiAgICBLLmV5LnggPSAtckEueSAqIHJBLnggKiBpQSAtIHJCLnkgKiByQi54ICogaUI7XG4gICAgSy5lei54ID0gLXJBLnkgKiBpQSAtIHJCLnkgKiBpQjtcbiAgICBLLmV4LnkgPSBLLmV5Lng7XG4gICAgSy5leS55ID0gbUEgKyBtQiArIHJBLnggKiByQS54ICogaUEgKyByQi54ICogckIueCAqIGlCO1xuICAgIEsuZXoueSA9IHJBLnggKiBpQSArIHJCLnggKiBpQjtcbiAgICBLLmV4LnogPSBLLmV6Lng7XG4gICAgSy5leS56ID0gSy5lei55O1xuICAgIEsuZXoueiA9IGlBICsgaUI7XG4gICAgaWYgKHRoaXMubV9mcmVxdWVuY3lIeiA+IDApIHtcbiAgICAgICAgdmFyIEMxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIEMxLmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICAgICAgQzEuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgICAgICAvLyBWZWMyXG4gICAgICAgIHBvc2l0aW9uRXJyb3IgPSBDMS5sZW5ndGgoKTtcbiAgICAgICAgYW5ndWxhckVycm9yID0gMDtcbiAgICAgICAgdmFyIFAgPSBWZWMyLm5lZyhLLnNvbHZlMjIoQzEpKTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICBjQS5zdWJNdWwobUEsIFApO1xuICAgICAgICBhQSAtPSBpQSAqIFZlYzIuY3Jvc3MockEsIFApO1xuICAgICAgICBjQi5hZGRNdWwobUIsIFApO1xuICAgICAgICBhQiArPSBpQiAqIFZlYzIuY3Jvc3MockIsIFApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBDMSA9IFZlYzIuemVybygpO1xuICAgICAgICBDMS5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgICAgIEMxLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHJBKTtcbiAgICAgICAgdmFyIEMyID0gYUIgLSBhQSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgcG9zaXRpb25FcnJvciA9IEMxLmxlbmd0aCgpO1xuICAgICAgICBhbmd1bGFyRXJyb3IgPSBNYXRoLmFicyhDMik7XG4gICAgICAgIHZhciBDID0gVmVjMyhDMS54LCBDMS55LCBDMik7XG4gICAgICAgIHZhciBpbXB1bHNlID0gVmVjMygpO1xuICAgICAgICBpZiAoSy5lei56ID4gMCkge1xuICAgICAgICAgICAgaW1wdWxzZSA9IFZlYzMubmVnKEsuc29sdmUzMyhDKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW1wdWxzZTIgPSBWZWMyLm5lZyhLLnNvbHZlMjIoQzEpKTtcbiAgICAgICAgICAgIGltcHVsc2Uuc2V0KGltcHVsc2UyLngsIGltcHVsc2UyLnksIDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBQID0gVmVjMi5uZW8oaW1wdWxzZS54LCBpbXB1bHNlLnkpO1xuICAgICAgICBjQS5zdWJNdWwobUEsIFApO1xuICAgICAgICBhQSAtPSBpQSAqIChWZWMyLmNyb3NzKHJBLCBQKSArIGltcHVsc2Uueik7XG4gICAgICAgIGNCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIGFCICs9IGlCICogKFZlYzIuY3Jvc3MockIsIFApICsgaW1wdWxzZS56KTtcbiAgICB9XG4gICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYyA9IGNBO1xuICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jID0gY0I7XG4gICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYSA9IGFCO1xuICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IFNldHRpbmdzLmxpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzLmFuZ3VsYXJTbG9wO1xufTtcblxuXG59LHtcIi4uL0pvaW50XCI6NSxcIi4uL1NldHRpbmdzXCI6NyxcIi4uL2NvbW1vbi9NYXQyMlwiOjE2LFwiLi4vY29tbW9uL01hdDMzXCI6MTcsXCIuLi9jb21tb24vTWF0aFwiOjE4LFwiLi4vY29tbW9uL1Bvc2l0aW9uXCI6MTksXCIuLi9jb21tb24vUm90XCI6MjAsXCIuLi9jb21tb24vU3dlZXBcIjoyMSxcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIjoyMixcIi4uL2NvbW1vbi9WZWMyXCI6MjMsXCIuLi9jb21tb24vVmVjM1wiOjI0LFwiLi4vY29tbW9uL1ZlbG9jaXR5XCI6MjUsXCIuLi91dGlsL2NyZWF0ZVwiOjUxLFwiLi4vdXRpbC9vcHRpb25zXCI6NTJ9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gV2hlZWxKb2ludDtcblxudmFyIG9wdGlvbnMgPSByZXF1aXJlKFwiLi4vdXRpbC9vcHRpb25zXCIpO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZShcIi4uL3V0aWwvY3JlYXRlXCIpO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vU2V0dGluZ3NcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjMlwiKTtcblxudmFyIFZlYzMgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzNcIik7XG5cbnZhciBNYXQyMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0MjJcIik7XG5cbnZhciBNYXQzMyA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0MzNcIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL1JvdFwiKTtcblxudmFyIFN3ZWVwID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Td2VlcFwiKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgVmVsb2NpdHkgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlbG9jaXR5XCIpO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKFwiLi4vY29tbW9uL1Bvc2l0aW9uXCIpO1xuXG52YXIgSm9pbnQgPSByZXF1aXJlKFwiLi4vSm9pbnRcIik7XG5cbldoZWVsSm9pbnQuVFlQRSA9IFwid2hlZWwtam9pbnRcIjtcblxuV2hlZWxKb2ludC5fc3VwZXIgPSBKb2ludDtcblxuV2hlZWxKb2ludC5wcm90b3R5cGUgPSBjcmVhdGUoV2hlZWxKb2ludC5fc3VwZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXaGVlbEpvaW50RGVmXG4gKlxuICogV2hlZWwgam9pbnQgZGVmaW5pdGlvbi4gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhIGxpbmUgb2YgbW90aW9uIHVzaW5nIGFuIGF4aXNcbiAqIGFuZCBhbiBhbmNob3IgcG9pbnQuIFRoZSBkZWZpbml0aW9uIHVzZXMgbG9jYWwgYW5jaG9yIHBvaW50cyBhbmQgYSBsb2NhbCBheGlzXG4gKiBzbyB0aGF0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gY2FuIHZpb2xhdGUgdGhlIGNvbnN0cmFpbnQgc2xpZ2h0bHkuIFRoZVxuICogam9pbnQgdHJhbnNsYXRpb24gaXMgemVybyB3aGVuIHRoZSBsb2NhbCBhbmNob3IgcG9pbnRzIGNvaW5jaWRlIGluIHdvcmxkXG4gKiBzcGFjZS4gVXNpbmcgbG9jYWwgYW5jaG9ycyBhbmQgYSBsb2NhbCBheGlzIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGFcbiAqIGdhbWUuXG4gKiBcbiAqIEBwcm9wIHtib29sZWFufSBlbmFibGVNb3RvciBFbmFibGUvZGlzYWJsZSB0aGUgam9pbnQgbW90b3IuXG4gKiBAcHJvcCB7ZmxvYXR9IG1heE1vdG9yVG9ycXVlIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXG4gKiBAcHJvcCB7ZmxvYXR9IG1vdG9yU3BlZWQgVGhlIGRlc2lyZWQgbW90b3Igc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICogQHByb3Age2Zsb2F0fSBmcmVxdWVuY3lIeiBTdXNwZW5zaW9uIGZyZXF1ZW5jeSwgemVybyBpbmRpY2F0ZXMgbm8gc3VzcGVuc2lvbi5cbiAqIEBwcm9wIHtmbG9hdH0gZGFtcGluZ1JhdGlvIFN1c3BlbnNpb24gZGFtcGluZyByYXRpbywgb25lIGluZGljYXRlcyBjcml0aWNhbFxuICogICAgICAgZGFtcGluZy5cbiAqXG4gKiBAcHJvcCB7VmVjMn0gbG9jYWxBbmNob3JBIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gKiBAcHJvcCB7VmVjMn0gbG9jYWxBbmNob3JCIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gKiBAcHJvcCB7VmVjMn0gbG9jYWxBeGlzQSBUaGUgbG9jYWwgdHJhbnNsYXRpb24gYXhpcyBpbiBib2R5QS5cbiAqL1xudmFyIERFRkFVTFRTID0ge1xuICAgIGVuYWJsZU1vdG9yOiBmYWxzZSxcbiAgICBtYXhNb3RvclRvcnF1ZTogMCxcbiAgICBtb3RvclNwZWVkOiAwLFxuICAgIGZyZXF1ZW5jeUh6OiAyLFxuICAgIGRhbXBpbmdSYXRpbzogLjdcbn07XG5cbi8qKlxuICogQSB3aGVlbCBqb2ludC4gVGhpcyBqb2ludCBwcm92aWRlcyB0d28gZGVncmVlcyBvZiBmcmVlZG9tOiB0cmFuc2xhdGlvbiBhbG9uZ1xuICogYW4gYXhpcyBmaXhlZCBpbiBib2R5QSBhbmQgcm90YXRpb24gaW4gdGhlIHBsYW5lLiBJbiBvdGhlciB3b3JkcywgaXQgaXMgYVxuICogcG9pbnQgdG8gbGluZSBjb25zdHJhaW50IHdpdGggYSByb3RhdGlvbmFsIG1vdG9yIGFuZCBhIGxpbmVhciBzcHJpbmcvZGFtcGVyLlxuICogVGhpcyBqb2ludCBpcyBkZXNpZ25lZCBmb3IgdmVoaWNsZSBzdXNwZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1doZWVsSm9pbnREZWZ9IGRlZlxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBXaGVlbEpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IsIGF4aXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2hlZWxKb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXaGVlbEpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IsIGF4aXMpO1xuICAgIH1cbiAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMpO1xuICAgIEpvaW50LmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpO1xuICAgIGJvZHlBID0gdGhpcy5tX2JvZHlBO1xuICAgIGJvZHlCID0gdGhpcy5tX2JvZHlCO1xuICAgIHRoaXMubV90eXBlID0gV2hlZWxKb2ludC5UWVBFO1xuICAgIHRoaXMubV9sb2NhbEFuY2hvckEgPSBhbmNob3IgPyBib2R5QS5nZXRMb2NhbFBvaW50KGFuY2hvcikgOiBkZWYubG9jYWxBbmNob3JBIHx8IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9sb2NhbEFuY2hvckIgPSBhbmNob3IgPyBib2R5Qi5nZXRMb2NhbFBvaW50KGFuY2hvcikgOiBkZWYubG9jYWxBbmNob3JCIHx8IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9sb2NhbEF4aXMgPSBheGlzID8gYm9keUEuZ2V0TG9jYWxWZWN0b3IoYXhpcykgOiBkZWYubG9jYWxBeGlzQSB8fCBWZWMyLm5lbygxLCAwKTtcbiAgICB0aGlzLm1fbG9jYWxYQXhpc0EgPSB0aGlzLm1fbG9jYWxBeGlzO1xuICAgIHRoaXMubV9sb2NhbFlBeGlzQSA9IFZlYzIuY3Jvc3MoMSwgdGhpcy5tX2xvY2FsWEF4aXNBKTtcbiAgICB0aGlzLm1fbWFzcyA9IDA7XG4gICAgdGhpcy5tX2ltcHVsc2UgPSAwO1xuICAgIHRoaXMubV9tb3Rvck1hc3MgPSAwO1xuICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwO1xuICAgIHRoaXMubV9zcHJpbmdNYXNzID0gMDtcbiAgICB0aGlzLm1fc3ByaW5nSW1wdWxzZSA9IDA7XG4gICAgdGhpcy5tX21heE1vdG9yVG9ycXVlID0gZGVmLm1heE1vdG9yVG9ycXVlO1xuICAgIHRoaXMubV9tb3RvclNwZWVkID0gZGVmLm1vdG9yU3BlZWQ7XG4gICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZGVmLmVuYWJsZU1vdG9yO1xuICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGRlZi5mcmVxdWVuY3lIejtcbiAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcbiAgICB0aGlzLm1fYmlhcyA9IDA7XG4gICAgdGhpcy5tX2dhbW1hID0gMDtcbiAgICAvLyBTb2x2ZXIgdGVtcFxuICAgIHRoaXMubV9sb2NhbENlbnRlckE7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9sb2NhbENlbnRlckI7XG4gICAgLy8gVmVjMlxuICAgIHRoaXMubV9pbnZNYXNzQTtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZJQTtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9pbnZJQjtcbiAgICAvLyBmbG9hdFxuICAgIHRoaXMubV9heCA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV9heSA9IFZlYzIuemVybygpO1xuICAgIC8vIFZlYzJcbiAgICB0aGlzLm1fc0F4O1xuICAgIHRoaXMubV9zQng7XG4gICAgLy8gZmxvYXRcbiAgICB0aGlzLm1fc0F5O1xuICAgIHRoaXMubV9zQnk7XG59XG5cbi8qKlxuICogVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QSdzIG9yaWdpbi5cbiAqL1xuV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG59O1xuXG4vKipcbiAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gKi9cbldoZWVsSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xufTtcblxuLyoqXG4gKiBUaGUgbG9jYWwgam9pbnQgYXhpcyByZWxhdGl2ZSB0byBib2R5QS5cbiAqL1xuV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBeGlzQSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fbG9jYWxYQXhpc0E7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBqb2ludCB0cmFuc2xhdGlvbiwgdXN1YWxseSBpbiBtZXRlcnMuXG4gKi9cbldoZWVsSm9pbnQucHJvdG90eXBlLmdldEpvaW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgIHZhciBwQSA9IGJBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgLy8gVmVjMlxuICAgIHZhciBwQiA9IGJCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgLy8gVmVjMlxuICAgIHZhciBkID0gVmVjMi5zdWIocEIsIHBBKTtcbiAgICAvLyBWZWMyXG4gICAgdmFyIGF4aXMgPSBiQS5nZXRXb3JsZFZlY3Rvcih0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgdHJhbnNsYXRpb24gPSBWZWMyLmRvdChkLCBheGlzKTtcbiAgICAvLyBmbG9hdFxuICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGpvaW50IHRyYW5zbGF0aW9uIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxuICovXG5XaGVlbEpvaW50LnByb3RvdHlwZS5nZXRKb2ludFNwZWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gd0IgLSB3QTtcbn07XG5cbi8qKlxuICogSXMgdGhlIGpvaW50IG1vdG9yIGVuYWJsZWQ/XG4gKi9cbldoZWVsSm9pbnQucHJvdG90eXBlLmlzTW90b3JFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3Rvcjtcbn07XG5cbi8qKlxuICogRW5hYmxlL2Rpc2FibGUgdGhlIGpvaW50IG1vdG9yLlxuICovXG5XaGVlbEpvaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGZsYWc7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbW90b3Igc3BlZWQsIHVzdWFsbHkgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICovXG5XaGVlbEpvaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oc3BlZWQpIHtcbiAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbW90b3Igc3BlZWQsIHVzdWFsbHkgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICovXG5XaGVlbEpvaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xufTtcblxuLyoqXG4gKiBTZXQvR2V0IHRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlLCB1c3VhbGx5IGluIE4tbS5cbiAqL1xuV2hlZWxKb2ludC5wcm90b3R5cGUuc2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpIHtcbiAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgIHRoaXMubV9tYXhNb3RvclRvcnF1ZSA9IHRvcnF1ZTtcbn07XG5cbldoZWVsSm9pbnQucHJvdG90eXBlLmdldE1heE1vdG9yVG9ycXVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IG1vdG9yIHRvcnF1ZSBnaXZlbiB0aGUgaW52ZXJzZSB0aW1lIHN0ZXAsIHVzdWFsbHkgaW4gTi1tLlxuICovXG5XaGVlbEpvaW50LnByb3RvdHlwZS5nZXRNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uKGludl9kdCkge1xuICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1fbW90b3JJbXB1bHNlO1xufTtcblxuLyoqXG4gKiBTZXQvR2V0IHRoZSBzcHJpbmcgZnJlcXVlbmN5IGluIGhlcnR6LiBTZXR0aW5nIHRoZSBmcmVxdWVuY3kgdG8gemVybyBkaXNhYmxlc1xuICogdGhlIHNwcmluZy5cbiAqL1xuV2hlZWxKb2ludC5wcm90b3R5cGUuc2V0U3ByaW5nRnJlcXVlbmN5SHogPSBmdW5jdGlvbihoeikge1xuICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xufTtcblxuV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0U3ByaW5nRnJlcXVlbmN5SHogPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xufTtcblxuLyoqXG4gKiBTZXQvR2V0IHRoZSBzcHJpbmcgZGFtcGluZyByYXRpb1xuICovXG5XaGVlbEpvaW50LnByb3RvdHlwZS5zZXRTcHJpbmdEYW1waW5nUmF0aW8gPSBmdW5jdGlvbihyYXRpbykge1xuICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSByYXRpbztcbn07XG5cbldoZWVsSm9pbnQucHJvdG90eXBlLmdldFNwcmluZ0RhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fZGFtcGluZ1JhdGlvO1xufTtcblxuV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbn07XG5cbldoZWVsSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG59O1xuXG5XaGVlbEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIFZlYzIuY29tYmluZSh0aGlzLm1faW1wdWxzZSwgdGhpcy5tX2F5LCB0aGlzLm1fc3ByaW5nSW1wdWxzZSwgdGhpcy5tX2F4KS5tdWwoaW52X2R0KTtcbn07XG5cbldoZWVsSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24oaW52X2R0KSB7XG4gICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG59O1xuXG5XaGVlbEpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgLy8gZmxvYXRcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3Nlcy5cbiAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgIHZhciByQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgdmFyIGQgPSBWZWMyLnplcm8oKTtcbiAgICBkLmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICBkLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHJBKTtcbiAgICAvLyBWZWMyXG4gICAgLy8gUG9pbnQgdG8gbGluZSBjb25zdHJhaW50XG4gICAge1xuICAgICAgICB0aGlzLm1fYXkgPSBSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xvY2FsWUF4aXNBKTtcbiAgICAgICAgdGhpcy5tX3NBeSA9IFZlYzIuY3Jvc3MoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fYXkpO1xuICAgICAgICB0aGlzLm1fc0J5ID0gVmVjMi5jcm9zcyhyQiwgdGhpcy5tX2F5KTtcbiAgICAgICAgdGhpcy5tX21hc3MgPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fc0F5ICogdGhpcy5tX3NBeSArIGlCICogdGhpcy5tX3NCeSAqIHRoaXMubV9zQnk7XG4gICAgICAgIGlmICh0aGlzLm1fbWFzcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMSAvIHRoaXMubV9tYXNzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNwcmluZyBjb25zdHJhaW50XG4gICAgdGhpcy5tX3NwcmluZ01hc3MgPSAwO1xuICAgIHRoaXMubV9iaWFzID0gMDtcbiAgICB0aGlzLm1fZ2FtbWEgPSAwO1xuICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwKSB7XG4gICAgICAgIHRoaXMubV9heCA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICB0aGlzLm1fc0F4ID0gVmVjMi5jcm9zcyhWZWMyLmFkZChkLCByQSksIHRoaXMubV9heCk7XG4gICAgICAgIHRoaXMubV9zQnggPSBWZWMyLmNyb3NzKHJCLCB0aGlzLm1fYXgpO1xuICAgICAgICB2YXIgaW52TWFzcyA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9zQXggKiB0aGlzLm1fc0F4ICsgaUIgKiB0aGlzLm1fc0J4ICogdGhpcy5tX3NCeDtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgaWYgKGludk1hc3MgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm1fc3ByaW5nTWFzcyA9IDEgLyBpbnZNYXNzO1xuICAgICAgICAgICAgdmFyIEMgPSBWZWMyLmRvdChkLCB0aGlzLm1fYXgpO1xuICAgICAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgICAgIC8vIEZyZXF1ZW5jeVxuICAgICAgICAgICAgdmFyIG9tZWdhID0gMiAqIE1hdGguUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgICAgICAvLyBmbG9hdFxuICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxuICAgICAgICAgICAgdmFyIGQgPSAyICogdGhpcy5tX3NwcmluZ01hc3MgKiB0aGlzLm1fZGFtcGluZ1JhdGlvICogb21lZ2E7XG4gICAgICAgICAgICAvLyBmbG9hdFxuICAgICAgICAgICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xuICAgICAgICAgICAgdmFyIGsgPSB0aGlzLm1fc3ByaW5nTWFzcyAqIG9tZWdhICogb21lZ2E7XG4gICAgICAgICAgICAvLyBmbG9hdFxuICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcbiAgICAgICAgICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAgICAgICAgIC8vIGZsb2F0XG4gICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSBoICogKGQgKyBoICogayk7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2dhbW1hID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IDEgLyB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYmlhcyA9IEMgKiBoICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgIHRoaXMubV9zcHJpbmdNYXNzID0gaW52TWFzcyArIHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fc3ByaW5nTWFzcyA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3ByaW5nTWFzcyA9IDEgLyB0aGlzLm1fc3ByaW5nTWFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlID0gMDtcbiAgICB9XG4gICAgLy8gUm90YXRpb25hbCBtb3RvclxuICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IpIHtcbiAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IGlBICsgaUI7XG4gICAgICAgIGlmICh0aGlzLm1fbW90b3JNYXNzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IDEgLyB0aGlzLm1fbW90b3JNYXNzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IDA7XG4gICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwO1xuICAgIH1cbiAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgdmFyaWFibGUgdGltZSBzdGVwLlxuICAgICAgICB0aGlzLm1faW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgIHZhciBQID0gVmVjMi5jb21iaW5lKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fYXksIHRoaXMubV9zcHJpbmdJbXB1bHNlLCB0aGlzLm1fYXgpO1xuICAgICAgICB2YXIgTEEgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9zQXkgKyB0aGlzLm1fc3ByaW5nSW1wdWxzZSAqIHRoaXMubV9zQXggKyB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICB2YXIgTEIgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9zQnkgKyB0aGlzLm1fc3ByaW5nSW1wdWxzZSAqIHRoaXMubV9zQnggKyB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICB2QS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgd0EgLT0gdGhpcy5tX2ludklBICogTEE7XG4gICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBMQjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDA7XG4gICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlID0gMDtcbiAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDA7XG4gICAgfVxuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0KHZBKTtcbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXQodkIpO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3Qjtcbn07XG5cbldoZWVsSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAvLyBmbG9hdFxuICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgLy8gU29sdmUgc3ByaW5nIGNvbnN0cmFpbnRcbiAgICB7XG4gICAgICAgIHZhciBDZG90ID0gVmVjMi5kb3QodGhpcy5tX2F4LCB2QikgLSBWZWMyLmRvdCh0aGlzLm1fYXgsIHZBKSArIHRoaXMubV9zQnggKiB3QiAtIHRoaXMubV9zQXggKiB3QTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX3NwcmluZ01hc3MgKiAoQ2RvdCArIHRoaXMubV9iaWFzICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX3NwcmluZ0ltcHVsc2UpO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB0aGlzLm1fc3ByaW5nSW1wdWxzZSArPSBpbXB1bHNlO1xuICAgICAgICB2YXIgUCA9IFZlYzIubXVsKGltcHVsc2UsIHRoaXMubV9heCk7XG4gICAgICAgIC8vIFZlYzJcbiAgICAgICAgdmFyIExBID0gaW1wdWxzZSAqIHRoaXMubV9zQXg7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZhciBMQiA9IGltcHVsc2UgKiB0aGlzLm1fc0J4O1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICB3QSAtPSBpQSAqIExBO1xuICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgIH1cbiAgICAvLyBTb2x2ZSByb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnRcbiAgICB7XG4gICAgICAgIHZhciBDZG90ID0gd0IgLSB3QSAtIHRoaXMubV9tb3RvclNwZWVkO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbW90b3JNYXNzICogQ2RvdDtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JUb3JxdWU7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBNYXRoLmNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgfVxuICAgIC8vIFNvbHZlIHBvaW50IHRvIGxpbmUgY29uc3RyYWludFxuICAgIHtcbiAgICAgICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fYXksIHZCKSAtIFZlYzIuZG90KHRoaXMubV9heSwgdkEpICsgdGhpcy5tX3NCeSAqIHdCIC0gdGhpcy5tX3NBeSAqIHdBO1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzcyAqIENkb3Q7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICAgIHZhciBQID0gVmVjMi5tdWwoaW1wdWxzZSwgdGhpcy5tX2F5KTtcbiAgICAgICAgLy8gVmVjMlxuICAgICAgICB2YXIgTEEgPSBpbXB1bHNlICogdGhpcy5tX3NBeTtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgdmFyIExCID0gaW1wdWxzZSAqIHRoaXMubV9zQnk7XG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgfVxuICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0KHZBKTtcbiAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXQodkIpO1xuICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3Qjtcbn07XG5cbldoZWVsSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICB2YXIgZCA9IFZlYzIuemVybygpO1xuICAgIGQuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgIGQuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgIHZhciBheSA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxZQXhpc0EpO1xuICAgIHZhciBzQXkgPSBWZWMyLmNyb3NzKFZlYzIuYWRkKGQsIHJBKSwgYXkpO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIHNCeSA9IFZlYzIuY3Jvc3MockIsIGF5KTtcbiAgICAvLyBmbG9hdFxuICAgIHZhciBDID0gVmVjMi5kb3QoZCwgYXkpO1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGsgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUEgKiB0aGlzLm1fc0F5ICogdGhpcy5tX3NBeSArIHRoaXMubV9pbnZJQiAqIHRoaXMubV9zQnkgKiB0aGlzLm1fc0J5O1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIGltcHVsc2U7XG4gICAgLy8gZmxvYXRcbiAgICBpZiAoayAhPSAwKSB7XG4gICAgICAgIGltcHVsc2UgPSAtQyAvIGs7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW1wdWxzZSA9IDA7XG4gICAgfVxuICAgIHZhciBQID0gVmVjMi5tdWwoaW1wdWxzZSwgYXkpO1xuICAgIC8vIFZlYzJcbiAgICB2YXIgTEEgPSBpbXB1bHNlICogc0F5O1xuICAgIC8vIGZsb2F0XG4gICAgdmFyIExCID0gaW1wdWxzZSAqIHNCeTtcbiAgICAvLyBmbG9hdFxuICAgIGNBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIExBO1xuICAgIGNCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIFApO1xuICAgIGFCICs9IHRoaXMubV9pbnZJQiAqIExCO1xuICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmMuc2V0KGNBKTtcbiAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXQoY0IpO1xuICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICByZXR1cm4gTWF0aC5hYnMoQykgPD0gU2V0dGluZ3MubGluZWFyU2xvcDtcbn07XG5cblxufSx7XCIuLi9Kb2ludFwiOjUsXCIuLi9TZXR0aW5nc1wiOjcsXCIuLi9jb21tb24vTWF0MjJcIjoxNixcIi4uL2NvbW1vbi9NYXQzM1wiOjE3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Qb3NpdGlvblwiOjE5LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1N3ZWVwXCI6MjEsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vY29tbW9uL1ZlYzNcIjoyNCxcIi4uL2NvbW1vbi9WZWxvY2l0eVwiOjI1LFwiLi4vdXRpbC9jcmVhdGVcIjo1MSxcIi4uL3V0aWwvb3B0aW9uc1wiOjUyfV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveFNoYXBlO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZShcIi4uL3V0aWwvY3JlYXRlXCIpO1xuXG52YXIgUG9seWdvblNoYXBlID0gcmVxdWlyZShcIi4vUG9seWdvblNoYXBlXCIpO1xuXG5Cb3hTaGFwZS5fc3VwZXIgPSBQb2x5Z29uU2hhcGU7XG5cbkJveFNoYXBlLnByb3RvdHlwZSA9IGNyZWF0ZShCb3hTaGFwZS5fc3VwZXIucHJvdG90eXBlKTtcblxuQm94U2hhcGUuVFlQRSA9IFwicG9seWdvblwiO1xuXG4vKipcbiAqIEEgcmVjdGFuZ2xlIHBvbHlnb24gd2hpY2ggZXh0ZW5kIFBvbHlnb25TaGFwZS5cbiAqL1xuZnVuY3Rpb24gQm94U2hhcGUoaHgsIGh5LCBjZW50ZXIsIGFuZ2xlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJveFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJveFNoYXBlKGh4LCBoeSwgY2VudGVyLCBhbmdsZSk7XG4gICAgfVxuICAgIEJveFNoYXBlLl9zdXBlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NldEFzQm94KGh4LCBoeSwgY2VudGVyLCBhbmdsZSk7XG59XG5cblxufSx7XCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi4vdXRpbC9jcmVhdGVcIjo1MSxcIi4vUG9seWdvblNoYXBlXCI6NDd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhaW5TaGFwZTtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL2NyZWF0ZVwiKTtcblxudmFyIG9wdGlvbnMgPSByZXF1aXJlKFwiLi4vdXRpbC9vcHRpb25zXCIpO1xuXG52YXIgTWF0aCA9IHJlcXVpcmUoXCIuLi9jb21tb24vTWF0aFwiKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgQUFCQiA9IHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vQUFCQlwiKTtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKFwiLi4vU2hhcGVcIik7XG5cbnZhciBFZGdlU2hhcGUgPSByZXF1aXJlKFwiLi9FZGdlU2hhcGVcIik7XG5cbkNoYWluU2hhcGUuX3N1cGVyID0gU2hhcGU7XG5cbkNoYWluU2hhcGUucHJvdG90eXBlID0gY3JlYXRlKENoYWluU2hhcGUuX3N1cGVyLnByb3RvdHlwZSk7XG5cbkNoYWluU2hhcGUuVFlQRSA9IFwiY2hhaW5cIjtcblxuLyoqXG4gKiBBIGNoYWluIHNoYXBlIGlzIGEgZnJlZSBmb3JtIHNlcXVlbmNlIG9mIGxpbmUgc2VnbWVudHMuIFRoZSBjaGFpbiBoYXNcbiAqIHR3by1zaWRlZCBjb2xsaXNpb24sIHNvIHlvdSBjYW4gdXNlIGluc2lkZSBhbmQgb3V0c2lkZSBjb2xsaXNpb24uIFRoZXJlZm9yZSxcbiAqIHlvdSBtYXkgdXNlIGFueSB3aW5kaW5nIG9yZGVyLiBDb25uZWN0aXZpdHkgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBjcmVhdGVcbiAqIHNtb290aCBjb2xsaXNpb25zLlxuICogXG4gKiBXQVJOSU5HOiBUaGUgY2hhaW4gd2lsbCBub3QgY29sbGlkZSBwcm9wZXJseSBpZiB0aGVyZSBhcmUgc2VsZi1pbnRlcnNlY3Rpb25zLlxuICovXG5mdW5jdGlvbiBDaGFpblNoYXBlKHZlcnRpY2VzLCBsb29wKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENoYWluU2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW5TaGFwZSh2ZXJ0aWNlcywgbG9vcCk7XG4gICAgfVxuICAgIENoYWluU2hhcGUuX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tX3R5cGUgPSBDaGFpblNoYXBlLlRZUEU7XG4gICAgdGhpcy5tX3JhZGl1cyA9IFNldHRpbmdzLnBvbHlnb25SYWRpdXM7XG4gICAgdGhpcy5tX3ZlcnRpY2VzID0gW107XG4gICAgdGhpcy5tX2NvdW50ID0gMDtcbiAgICB0aGlzLm1fcHJldlZlcnRleCA9IG51bGw7XG4gICAgdGhpcy5tX25leHRWZXJ0ZXggPSBudWxsO1xuICAgIHRoaXMubV9oYXNQcmV2VmVydGV4ID0gZmFsc2U7XG4gICAgdGhpcy5tX2hhc05leHRWZXJ0ZXggPSBmYWxzZTtcbiAgICBpZiAodmVydGljZXMgJiYgdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVMb29wKHZlcnRpY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNoYWluKHZlcnRpY2VzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ2hhaW5TaGFwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuLy8gdGhpcy5tX3ZlcnRpY2VzLmxlbmd0aCA9IDA7XG4vLyB0aGlzLm1fY291bnQgPSAwO1xuLy8gfVxuLyoqXG4gKiBDcmVhdGUgYSBsb29wLiBUaGlzIGF1dG9tYXRpY2FsbHkgYWRqdXN0cyBjb25uZWN0aXZpdHkuXG4gKiBcbiAqIEBwYXJhbSB2ZXJ0aWNlcyBhbiBhcnJheSBvZiB2ZXJ0aWNlcywgdGhlc2UgYXJlIGNvcGllZFxuICogQHBhcmFtIGNvdW50IHRoZSB2ZXJ0ZXggY291bnRcbiAqL1xuQ2hhaW5TaGFwZS5wcm90b3R5cGUuX2NyZWF0ZUxvb3AgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh0aGlzLm1fdmVydGljZXMubGVuZ3RoID09IDAgJiYgdGhpcy5tX2NvdW50ID09IDApO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCh2ZXJ0aWNlcy5sZW5ndGggPj0gMyk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1tpIC0gMV07XG4gICAgICAgIHZhciB2MiA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAvLyBJZiB0aGUgY29kZSBjcmFzaGVzIGhlcmUsIGl0IG1lYW5zIHlvdXIgdmVydGljZXMgYXJlIHRvbyBjbG9zZSB0b2dldGhlci5cbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KFZlYzIuZGlzdGFuY2VTcXVhcmVkKHYxLCB2MikgPiBTZXR0aW5ncy5saW5lYXJTbG9wU3F1YXJlZCk7XG4gICAgfVxuICAgIHRoaXMubV92ZXJ0aWNlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMubV9jb3VudCA9IHZlcnRpY2VzLmxlbmd0aCArIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSB2ZXJ0aWNlc1tpXS5jbG9uZSgpO1xuICAgIH1cbiAgICB0aGlzLm1fdmVydGljZXNbdmVydGljZXMubGVuZ3RoXSA9IHZlcnRpY2VzWzBdLmNsb25lKCk7XG4gICAgdGhpcy5tX3ByZXZWZXJ0ZXggPSB0aGlzLm1fdmVydGljZXNbdGhpcy5tX2NvdW50IC0gMl07XG4gICAgdGhpcy5tX25leHRWZXJ0ZXggPSB0aGlzLm1fdmVydGljZXNbMV07XG4gICAgdGhpcy5tX2hhc1ByZXZWZXJ0ZXggPSB0cnVlO1xuICAgIHRoaXMubV9oYXNOZXh0VmVydGV4ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY2hhaW4gd2l0aCBpc29sYXRlZCBlbmQgdmVydGljZXMuXG4gKiBcbiAqIEBwYXJhbSB2ZXJ0aWNlcyBhbiBhcnJheSBvZiB2ZXJ0aWNlcywgdGhlc2UgYXJlIGNvcGllZFxuICogQHBhcmFtIGNvdW50IHRoZSB2ZXJ0ZXggY291bnRcbiAqL1xuQ2hhaW5TaGFwZS5wcm90b3R5cGUuX2NyZWF0ZUNoYWluID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodGhpcy5tX3ZlcnRpY2VzLmxlbmd0aCA9PSAwICYmIHRoaXMubV9jb3VudCA9PSAwKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQodmVydGljZXMubGVuZ3RoID49IDIpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNvZGUgY3Jhc2hlcyBoZXJlLCBpdCBtZWFucyB5b3VyIHZlcnRpY2VzIGFyZSB0b28gY2xvc2UgdG9nZXRoZXIuXG4gICAgICAgIHZhciB2MSA9IHZlcnRpY2VzW2kgLSAxXTtcbiAgICAgICAgdmFyIHYyID0gdmVydGljZXNbaV07XG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChWZWMyLmRpc3RhbmNlU3F1YXJlZCh2MSwgdjIpID4gU2V0dGluZ3MubGluZWFyU2xvcFNxdWFyZWQpO1xuICAgIH1cbiAgICB0aGlzLm1fY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSB2ZXJ0aWNlc1tpXS5jbG9uZSgpO1xuICAgIH1cbiAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IGZhbHNlO1xuICAgIHRoaXMubV9oYXNOZXh0VmVydGV4ID0gZmFsc2U7XG4gICAgdGhpcy5tX3ByZXZWZXJ0ZXggPSBudWxsO1xuICAgIHRoaXMubV9uZXh0VmVydGV4ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXN0YWJsaXNoIGNvbm5lY3Rpdml0eSB0byBhIHZlcnRleCB0aGF0IHByZWNlZGVzIHRoZSBmaXJzdCB2ZXJ0ZXguIERvbid0IGNhbGxcbiAqIHRoaXMgZm9yIGxvb3BzLlxuICovXG5DaGFpblNoYXBlLnByb3RvdHlwZS5fc2V0UHJldlZlcnRleCA9IGZ1bmN0aW9uKHByZXZWZXJ0ZXgpIHtcbiAgICB0aGlzLm1fcHJldlZlcnRleCA9IHByZXZWZXJ0ZXg7XG4gICAgdGhpcy5tX2hhc1ByZXZWZXJ0ZXggPSB0cnVlO1xufTtcblxuLyoqXG4gKiBFc3RhYmxpc2ggY29ubmVjdGl2aXR5IHRvIGEgdmVydGV4IHRoYXQgZm9sbG93cyB0aGUgbGFzdCB2ZXJ0ZXguIERvbid0IGNhbGxcbiAqIHRoaXMgZm9yIGxvb3BzLlxuICovXG5DaGFpblNoYXBlLnByb3RvdHlwZS5fc2V0TmV4dFZlcnRleCA9IGZ1bmN0aW9uKG5leHRWZXJ0ZXgpIHtcbiAgICB0aGlzLm1fbmV4dFZlcnRleCA9IG5leHRWZXJ0ZXg7XG4gICAgdGhpcy5tX2hhc05leHRWZXJ0ZXggPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5DaGFpblNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgQ2hhaW5TaGFwZSgpO1xuICAgIGNsb25lLmNyZWF0ZUNoYWluKHRoaXMubV92ZXJ0aWNlcyk7XG4gICAgY2xvbmUubV90eXBlID0gdGhpcy5tX3R5cGU7XG4gICAgY2xvbmUubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgIGNsb25lLm1fcHJldlZlcnRleCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgIGNsb25lLm1fbmV4dFZlcnRleCA9IHRoaXMubV9uZXh0VmVydGV4O1xuICAgIGNsb25lLm1faGFzUHJldlZlcnRleCA9IHRoaXMubV9oYXNQcmV2VmVydGV4O1xuICAgIGNsb25lLm1faGFzTmV4dFZlcnRleCA9IHRoaXMubV9oYXNOZXh0VmVydGV4O1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbkNoYWluU2hhcGUucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBlZGdlIGNvdW50ID0gdmVydGV4IGNvdW50IC0gMVxuICAgIHJldHVybiB0aGlzLm1fY291bnQgLSAxO1xufTtcblxuLy8gR2V0IGEgY2hpbGQgZWRnZS5cbkNoYWluU2hhcGUucHJvdG90eXBlLmdldENoaWxkRWRnZSA9IGZ1bmN0aW9uKGVkZ2UsIGNoaWxkSW5kZXgpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoMCA8PSBjaGlsZEluZGV4ICYmIGNoaWxkSW5kZXggPCB0aGlzLm1fY291bnQgLSAxKTtcbiAgICBlZGdlLm1fdHlwZSA9IEVkZ2VTaGFwZS5UWVBFO1xuICAgIGVkZ2UubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgIGVkZ2UubV92ZXJ0ZXgxID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXhdO1xuICAgIGVkZ2UubV92ZXJ0ZXgyID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXggKyAxXTtcbiAgICBpZiAoY2hpbGRJbmRleCA+IDApIHtcbiAgICAgICAgZWRnZS5tX3ZlcnRleDAgPSB0aGlzLm1fdmVydGljZXNbY2hpbGRJbmRleCAtIDFdO1xuICAgICAgICBlZGdlLm1faGFzVmVydGV4MCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS5tX3ZlcnRleDAgPSB0aGlzLm1fcHJldlZlcnRleDtcbiAgICAgICAgZWRnZS5tX2hhc1ZlcnRleDAgPSB0aGlzLm1faGFzUHJldlZlcnRleDtcbiAgICB9XG4gICAgaWYgKGNoaWxkSW5kZXggPCB0aGlzLm1fY291bnQgLSAyKSB7XG4gICAgICAgIGVkZ2UubV92ZXJ0ZXgzID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXggKyAyXTtcbiAgICAgICAgZWRnZS5tX2hhc1ZlcnRleDMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UubV92ZXJ0ZXgzID0gdGhpcy5tX25leHRWZXJ0ZXg7XG4gICAgICAgIGVkZ2UubV9oYXNWZXJ0ZXgzID0gdGhpcy5tX2hhc05leHRWZXJ0ZXg7XG4gICAgfVxufTtcblxuQ2hhaW5TaGFwZS5wcm90b3R5cGUuZ2V0VmVydGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoMCA8PSBpbmRleCAmJiBpbmRleCA8PSB0aGlzLm1fY291bnQpO1xuICAgIGlmIChpbmRleCA8IHRoaXMubV9jb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzWzBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG5DaGFpblNoYXBlLnByb3RvdHlwZS50ZXN0UG9pbnQgPSBmdW5jdGlvbih4ZiwgcCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkNoYWluU2hhcGUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbihvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCgwIDw9IGNoaWxkSW5kZXggJiYgY2hpbGRJbmRleCA8IHRoaXMubV9jb3VudCk7XG4gICAgdmFyIGVkZ2VTaGFwZSA9IG5ldyBFZGdlU2hhcGUodGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCksIHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXggKyAxKSk7XG4gICAgcmV0dXJuIGVkZ2VTaGFwZS5yYXlDYXN0KG91dHB1dCwgaW5wdXQsIHhmLCAwKTtcbn07XG5cbkNoYWluU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24oYWFiYiwgeGYsIGNoaWxkSW5kZXgpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoMCA8PSBjaGlsZEluZGV4ICYmIGNoaWxkSW5kZXggPCB0aGlzLm1fY291bnQpO1xuICAgIHZhciB2MSA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmLCB0aGlzLmdldFZlcnRleChjaGlsZEluZGV4KSk7XG4gICAgdmFyIHYyID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXggKyAxKSk7XG4gICAgYWFiYi5jb21iaW5lUG9pbnRzKHYxLCB2Mik7XG59O1xuXG4vKipcbiAqIENoYWlucyBoYXZlIHplcm8gbWFzcy5cbiAqL1xuQ2hhaW5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbihtYXNzRGF0YSwgZGVuc2l0eSkge1xuICAgIG1hc3NEYXRhLm1hc3MgPSAwO1xuICAgIG1hc3NEYXRhLmNlbnRlciA9IFZlYzIubmVvKCk7XG4gICAgbWFzc0RhdGEuSSA9IDA7XG59O1xuXG5DaGFpblNoYXBlLnByb3RvdHlwZS5jb21wdXRlRGlzdGFuY2VQcm94eSA9IGZ1bmN0aW9uKHByb3h5LCBjaGlsZEluZGV4KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gY2hpbGRJbmRleCAmJiBjaGlsZEluZGV4IDwgdGhpcy5tX2NvdW50KTtcbiAgICBwcm94eS5tX2J1ZmZlclswXSA9IHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXgpO1xuICAgIHByb3h5Lm1fYnVmZmVyWzFdID0gdGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCArIDEpO1xuICAgIHByb3h5Lm1fdmVydGljZXMgPSBwcm94eS5tX2J1ZmZlcjtcbiAgICBwcm94eS5tX2NvdW50ID0gMjtcbiAgICBwcm94eS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG59O1xuXG5cbn0se1wiLi4vU2V0dGluZ3NcIjo3LFwiLi4vU2hhcGVcIjo4LFwiLi4vY29sbGlzaW9uL0FBQkJcIjoxMSxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUm90XCI6MjAsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4uL3V0aWwvY3JlYXRlXCI6NTEsXCIuLi91dGlsL29wdGlvbnNcIjo1MixcIi4vRWRnZVNoYXBlXCI6NDZ9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlU2hhcGU7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjMlwiKTtcblxudmFyIEFBQkIgPSByZXF1aXJlKFwiLi4vY29sbGlzaW9uL0FBQkJcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIFNoYXBlID0gcmVxdWlyZShcIi4uL1NoYXBlXCIpO1xuXG5DaXJjbGVTaGFwZS5fc3VwZXIgPSBTaGFwZTtcblxuQ2lyY2xlU2hhcGUucHJvdG90eXBlID0gY3JlYXRlKENpcmNsZVNoYXBlLl9zdXBlci5wcm90b3R5cGUpO1xuXG5DaXJjbGVTaGFwZS5UWVBFID0gXCJjaXJjbGVcIjtcblxuZnVuY3Rpb24gQ2lyY2xlU2hhcGUoYSwgYikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaXJjbGVTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVTaGFwZShhLCBiKTtcbiAgICB9XG4gICAgQ2lyY2xlU2hhcGUuX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tX3R5cGUgPSBDaXJjbGVTaGFwZS5UWVBFO1xuICAgIHRoaXMubV9wID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX3JhZGl1cyA9IDE7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIFZlYzIuaXNWYWxpZChhKSkge1xuICAgICAgICB0aGlzLm1fcC5zZXQoYSk7XG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IGI7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMubV9yYWRpdXMgPSBhO1xuICAgIH1cbn1cblxuQ2lyY2xlU2hhcGUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fcmFkaXVzO1xufTtcblxuQ2lyY2xlU2hhcGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1fcDtcbn07XG5cbkNpcmNsZVNoYXBlLnByb3RvdHlwZS5nZXRWZXJ0ZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChpbmRleCA9PSAwKTtcbiAgICByZXR1cm4gdGhpcy5tX3A7XG59O1xuXG5DaXJjbGVTaGFwZS5wcm90b3R5cGUuZ2V0VmVydGV4Q291bnQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5DaXJjbGVTaGFwZS5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IENpcmNsZVNoYXBlKCk7XG4gICAgY2xvbmUubV90eXBlID0gdGhpcy5tX3R5cGU7XG4gICAgY2xvbmUubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgIGNsb25lLm1fcCA9IHRoaXMubV9wLmNsb25lKCk7XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxuQ2lyY2xlU2hhcGUucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTtcbn07XG5cbkNpcmNsZVNoYXBlLnByb3RvdHlwZS50ZXN0UG9pbnQgPSBmdW5jdGlvbih4ZiwgcCkge1xuICAgIHZhciBjZW50ZXIgPSBWZWMyLmFkZCh4Zi5wLCBSb3QubXVsVmVjMih4Zi5xLCB0aGlzLm1fcCkpO1xuICAgIHZhciBkID0gVmVjMi5zdWIocCwgY2VudGVyKTtcbiAgICByZXR1cm4gVmVjMi5kb3QoZCwgZCkgPD0gdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG59O1xuXG4vLyBDb2xsaXNpb24gRGV0ZWN0aW9uIGluIEludGVyYWN0aXZlIDNEIEVudmlyb25tZW50cyBieSBHaW5vIHZhbiBkZW4gQmVyZ2VuXG4vLyBGcm9tIFNlY3Rpb24gMy4xLjJcbi8vIHggPSBzICsgYSAqIHJcbi8vIG5vcm0oeCkgPSByYWRpdXNcbkNpcmNsZVNoYXBlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24ob3V0cHV0LCBpbnB1dCwgeGYsIGNoaWxkSW5kZXgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBWZWMyLmFkZCh4Zi5wLCBSb3QubXVsVmVjMih4Zi5xLCB0aGlzLm1fcCkpO1xuICAgIHZhciBzID0gVmVjMi5zdWIoaW5wdXQucDEsIHBvc2l0aW9uKTtcbiAgICB2YXIgYiA9IFZlYzIuZG90KHMsIHMpIC0gdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICAgLy8gU29sdmUgcXVhZHJhdGljIGVxdWF0aW9uLlxuICAgIHZhciByID0gVmVjMi5zdWIoaW5wdXQucDIsIGlucHV0LnAxKTtcbiAgICB2YXIgYyA9IFZlYzIuZG90KHMsIHIpO1xuICAgIHZhciByciA9IFZlYzIuZG90KHIsIHIpO1xuICAgIHZhciBzaWdtYSA9IGMgKiBjIC0gcnIgKiBiO1xuICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSBkaXNjcmltaW5hbnQgYW5kIHNob3J0IHNlZ21lbnQuXG4gICAgaWYgKHNpZ21hIDwgMCB8fCByciA8IE1hdGguRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGUgbGluZSB3aXRoIHRoZSBjaXJjbGUuXG4gICAgdmFyIGEgPSAtKGMgKyBNYXRoLnNxcnQoc2lnbWEpKTtcbiAgICAvLyBJcyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSBzZWdtZW50P1xuICAgIGlmICgwIDw9IGEgJiYgYSA8PSBpbnB1dC5tYXhGcmFjdGlvbiAqIHJyKSB7XG4gICAgICAgIGEgLz0gcnI7XG4gICAgICAgIG91dHB1dC5mcmFjdGlvbiA9IGE7XG4gICAgICAgIG91dHB1dC5ub3JtYWwgPSBWZWMyLmFkZChzLCBWZWMyLm11bChhLCByKSk7XG4gICAgICAgIG91dHB1dC5ub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5DaXJjbGVTaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihhYWJiLCB4ZiwgY2hpbGRJbmRleCkge1xuICAgIHZhciBwID0gVmVjMi5hZGQoeGYucCwgUm90Lm11bFZlYzIoeGYucSwgdGhpcy5tX3ApKTtcbiAgICBhYWJiLmxvd2VyQm91bmQuc2V0KHAueCAtIHRoaXMubV9yYWRpdXMsIHAueSAtIHRoaXMubV9yYWRpdXMpO1xuICAgIGFhYmIudXBwZXJCb3VuZC5zZXQocC54ICsgdGhpcy5tX3JhZGl1cywgcC55ICsgdGhpcy5tX3JhZGl1cyk7XG59O1xuXG5DaXJjbGVTaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbihtYXNzRGF0YSwgZGVuc2l0eSkge1xuICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogTWF0aC5QSSAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgIG1hc3NEYXRhLmNlbnRlciA9IHRoaXMubV9wO1xuICAgIC8vIGluZXJ0aWEgYWJvdXQgdGhlIGxvY2FsIG9yaWdpblxuICAgIG1hc3NEYXRhLkkgPSBtYXNzRGF0YS5tYXNzICogKC41ICogdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXMgKyBWZWMyLmRvdCh0aGlzLm1fcCwgdGhpcy5tX3ApKTtcbn07XG5cbkNpcmNsZVNoYXBlLnByb3RvdHlwZS5jb21wdXRlRGlzdGFuY2VQcm94eSA9IGZ1bmN0aW9uKHByb3h5KSB7XG4gICAgcHJveHkubV92ZXJ0aWNlcy5wdXNoKHRoaXMubV9wKTtcbiAgICBwcm94eS5tX2NvdW50ID0gMTtcbiAgICBwcm94eS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG59O1xuXG5cbn0se1wiLi4vU2V0dGluZ3NcIjo3LFwiLi4vU2hhcGVcIjo4LFwiLi4vY29sbGlzaW9uL0FBQkJcIjoxMSxcIi4uL2NvbW1vbi9NYXRoXCI6MTgsXCIuLi9jb21tb24vUm90XCI6MjAsXCIuLi9jb21tb24vVHJhbnNmb3JtXCI6MjIsXCIuLi9jb21tb24vVmVjMlwiOjIzLFwiLi4vdXRpbC9jb21tb25cIjo1MCxcIi4uL3V0aWwvY3JlYXRlXCI6NTEsXCIuLi91dGlsL29wdGlvbnNcIjo1Mn1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjMlwiKTtcblxudmFyIENvbnRhY3QgPSByZXF1aXJlKFwiLi4vQ29udGFjdFwiKTtcblxudmFyIE1hbmlmb2xkID0gcmVxdWlyZShcIi4uL01hbmlmb2xkXCIpO1xuXG52YXIgQ2lyY2xlU2hhcGUgPSByZXF1aXJlKFwiLi9DaXJjbGVTaGFwZVwiKTtcblxuQ29udGFjdC5hZGRUeXBlKENpcmNsZVNoYXBlLlRZUEUsIENpcmNsZVNoYXBlLlRZUEUsIENpcmNsZUNpcmNsZUNvbnRhY3QpO1xuXG5mdW5jdGlvbiBDaXJjbGVDaXJjbGVDb250YWN0KG1hbmlmb2xkLCB4ZkEsIGZpeHR1cmVBLCBpbmRleEEsIHhmQiwgZml4dHVyZUIsIGluZGV4Qikge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmaXh0dXJlQS5nZXRUeXBlKCkgPT0gQ2lyY2xlU2hhcGUuVFlQRSk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZpeHR1cmVCLmdldFR5cGUoKSA9PSBDaXJjbGVTaGFwZS5UWVBFKTtcbiAgICBDb2xsaWRlQ2lyY2xlcyhtYW5pZm9sZCwgZml4dHVyZUEuZ2V0U2hhcGUoKSwgeGZBLCBmaXh0dXJlQi5nZXRTaGFwZSgpLCB4ZkIpO1xufVxuXG52YXIgY2NfcEEgPSBWZWMyLnplcm8oKTtcblxudmFyIGNjX3BCID0gVmVjMi56ZXJvKCk7XG5cbmZ1bmN0aW9uIENvbGxpZGVDaXJjbGVzKG1hbmlmb2xkLCBjaXJjbGVBLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAwO1xuICAgIHZhciBwQSA9IFRyYW5zZm9ybS5tdWxWZWMyXyh4ZkEsIGNpcmNsZUEubV9wLCBjY19wQSk7XG4gICAgdmFyIHBCID0gVHJhbnNmb3JtLm11bFZlYzJfKHhmQiwgY2lyY2xlQi5tX3AsIGNjX3BCKTtcbiAgICB2YXIgZGlzdFNxciA9IFZlYzIuZGlzdGFuY2VTcXVhcmVkKHBCLCBwQSk7XG4gICAgdmFyIHJBID0gY2lyY2xlQS5tX3JhZGl1cztcbiAgICB2YXIgckIgPSBjaXJjbGVCLm1fcmFkaXVzO1xuICAgIHZhciByYWRpdXMgPSByQSArIHJCO1xuICAgIGlmIChkaXN0U3FyID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkLmVfY2lyY2xlcztcbiAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldChjaXJjbGVBLm1fcCk7XG4gICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0WmVybygpO1xuICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LnNldChjaXJjbGVCLm1fcCk7XG4gICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QSA9IDA7XG4gICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QiA9IDA7XG4gICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVCID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG59XG5cbmV4cG9ydHMuQ29sbGlkZUNpcmNsZXMgPSBDb2xsaWRlQ2lyY2xlcztcblxuXG59LHtcIi4uL0NvbnRhY3RcIjozLFwiLi4vTWFuaWZvbGRcIjo2LFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuL0NpcmNsZVNoYXBlXCI6NDB9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgTWFuaWZvbGQgPSByZXF1aXJlKFwiLi4vTWFuaWZvbGRcIik7XG5cbnZhciBDb250YWN0ID0gcmVxdWlyZShcIi4uL0NvbnRhY3RcIik7XG5cbnZhciBDaXJjbGVTaGFwZSA9IHJlcXVpcmUoXCIuL0NpcmNsZVNoYXBlXCIpO1xuXG52YXIgUG9seWdvblNoYXBlID0gcmVxdWlyZShcIi4vUG9seWdvblNoYXBlXCIpO1xuXG5Db250YWN0LmFkZFR5cGUoUG9seWdvblNoYXBlLlRZUEUsIENpcmNsZVNoYXBlLlRZUEUsIFBvbHlnb25DaXJjbGVDb250YWN0KTtcblxuZnVuY3Rpb24gUG9seWdvbkNpcmNsZUNvbnRhY3QobWFuaWZvbGQsIHhmQSwgZml4dHVyZUEsIGluZGV4QSwgeGZCLCBmaXh0dXJlQiwgaW5kZXhCKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZpeHR1cmVBLmdldFR5cGUoKSA9PT0gUG9seWdvblNoYXBlLlRZUEUpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmaXh0dXJlQi5nZXRUeXBlKCkgPT09IENpcmNsZVNoYXBlLlRZUEUpO1xuICAgIENvbGxpZGVQb2x5Z29uQ2lyY2xlKG1hbmlmb2xkLCBmaXh0dXJlQS5nZXRTaGFwZSgpLCB4ZkEsIGZpeHR1cmVCLmdldFNoYXBlKCksIHhmQik7XG59XG5cbnZhciBjcGNfYyA9IFZlYzIuemVybygpO1xuXG52YXIgY3BjX2NMb2NhbCA9IFZlYzIuemVybygpO1xuXG52YXIgY3BjX3QxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjcGNfdDIgPSBWZWMyLnplcm8oKTtcblxuZnVuY3Rpb24gQ29sbGlkZVBvbHlnb25DaXJjbGUobWFuaWZvbGQsIHBvbHlnb25BLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAwO1xuICAgIC8vIENvbXB1dGUgY2lyY2xlIHBvc2l0aW9uIGluIHRoZSBmcmFtZSBvZiB0aGUgcG9seWdvbi5cbiAgICB2YXIgYyA9IFRyYW5zZm9ybS5tdWxWZWMyXyh4ZkIsIGNpcmNsZUIubV9wLCBjcGNfYyk7XG4gICAgdmFyIGNMb2NhbCA9IFRyYW5zZm9ybS5tdWxUVmVjMl8oeGZBLCBjLCBjcGNfY0xvY2FsKTtcbiAgICAvLyBGaW5kIHRoZSBtaW4gc2VwYXJhdGluZyBlZGdlLlxuICAgIHZhciBub3JtYWxJbmRleCA9IDA7XG4gICAgdmFyIHNlcGFyYXRpb24gPSAtSW5maW5pdHk7XG4gICAgdmFyIHJhZGl1cyA9IHBvbHlnb25BLm1fcmFkaXVzICsgY2lyY2xlQi5tX3JhZGl1cztcbiAgICB2YXIgdmVydGV4Q291bnQgPSBwb2x5Z29uQS5tX2NvdW50O1xuICAgIHZhciB2ZXJ0aWNlcyA9IHBvbHlnb25BLm1fdmVydGljZXM7XG4gICAgdmFyIG5vcm1hbHMgPSBwb2x5Z29uQS5tX25vcm1hbHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gVmVjMi5kb3Qobm9ybWFsc1tpXSwgVmVjMi5zdWJfKGNMb2NhbCwgdmVydGljZXNbaV0sIGNwY190MSkpO1xuICAgICAgICBpZiAocyA+IHJhZGl1cykge1xuICAgICAgICAgICAgLy8gRWFybHkgb3V0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzID4gc2VwYXJhdGlvbikge1xuICAgICAgICAgICAgc2VwYXJhdGlvbiA9IHM7XG4gICAgICAgICAgICBub3JtYWxJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmVydGljZXMgdGhhdCBzdWJ0ZW5kIHRoZSBpbmNpZGVudCBmYWNlLlxuICAgIHZhciB2ZXJ0SW5kZXgxID0gbm9ybWFsSW5kZXg7XG4gICAgdmFyIHZlcnRJbmRleDIgPSB2ZXJ0SW5kZXgxICsgMSA8IHZlcnRleENvdW50ID8gdmVydEluZGV4MSArIDEgOiAwO1xuICAgIHZhciB2MSA9IHZlcnRpY2VzW3ZlcnRJbmRleDFdO1xuICAgIHZhciB2MiA9IHZlcnRpY2VzW3ZlcnRJbmRleDJdO1xuICAgIC8vIElmIHRoZSBjZW50ZXIgaXMgaW5zaWRlIHRoZSBwb2x5Z29uIC4uLlxuICAgIGlmIChzZXBhcmF0aW9uIDwgTWF0aC5FUFNJTE9OKSB7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0KG5vcm1hbHNbbm9ybWFsSW5kZXhdKTtcbiAgICAgICAgbWFuaWZvbGQubG9jYWxQb2ludC5zZXRDb21iaW5lKC41LCB2MSwgLjUsIHYyKTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmxvY2FsUG9pbnQuc2V0KGNpcmNsZUIubV9wKTtcbiAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUEgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QiA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQiA9IE1hbmlmb2xkLmVfdmVydGV4O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENvbXB1dGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcbiAgICB2YXIgdTEgPSBWZWMyLmRvdChWZWMyLnN1Yl8oY0xvY2FsLCB2MSwgY3BjX3QxKSwgVmVjMi5zdWJfKHYyLCB2MSwgY3BjX3QyKSk7XG4gICAgdmFyIHUyID0gVmVjMi5kb3QoVmVjMi5zdWJfKGNMb2NhbCwgdjIsIGNwY190MSksIFZlYzIuc3ViXyh2MSwgdjIsIGNwY190MikpO1xuICAgIGlmICh1MSA8PSAwKSB7XG4gICAgICAgIGlmIChWZWMyLmRpc3RhbmNlU3F1YXJlZChjTG9jYWwsIHYxKSA+IHJhZGl1cyAqIHJhZGl1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0Q29tYmluZSgxLCBjTG9jYWwsIC0xLCB2MSk7XG4gICAgICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldCh2MSk7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LnNldChjaXJjbGVCLm1fcCk7XG4gICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEIgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbiAgICB9IGVsc2UgaWYgKHUyIDw9IDApIHtcbiAgICAgICAgaWYgKFZlYzIuZGlzdGFuY2VTcXVhcmVkKGNMb2NhbCwgdjIpID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZC5lX2ZhY2VBO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbC5zZXRDb21iaW5lKDEsIGNMb2NhbCwgLTEsIHYyKTtcbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0KHYyKTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmxvY2FsUG9pbnQuc2V0KGNpcmNsZUIubV9wKTtcbiAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUEgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QiA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQiA9IE1hbmlmb2xkLmVfdmVydGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmYWNlQ2VudGVyID0gVmVjMi5taWQodjEsIHYyKTtcbiAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBWZWMyLmRvdChjTG9jYWwsIG5vcm1hbHNbdmVydEluZGV4MV0pIC0gVmVjMi5kb3QoZmFjZUNlbnRlciwgbm9ybWFsc1t2ZXJ0SW5kZXgxXSk7XG4gICAgICAgIGlmIChzZXBhcmF0aW9uID4gcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZC5lX2ZhY2VBO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbC5zZXQobm9ybWFsc1t2ZXJ0SW5kZXgxXSk7XG4gICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0KGZhY2VDZW50ZXIpO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludC5zZXQoY2lyY2xlQi5tX3ApO1xuICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLmluZGV4QSA9IDA7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQSA9IE1hbmlmb2xkLmVfdmVydGV4O1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhCID0gMDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVCID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgfVxufVxuXG5cbn0se1wiLi4vQ29udGFjdFwiOjMsXCIuLi9NYW5pZm9sZFwiOjYsXCIuLi9jb21tb24vTWF0aFwiOjE4LFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuL0NpcmNsZVNoYXBlXCI6NDAsXCIuL1BvbHlnb25TaGFwZVwiOjQ3fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZShcIi4uL3V0aWwvY29tbW9uXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgQ29udGFjdCA9IHJlcXVpcmUoXCIuLi9Db250YWN0XCIpO1xuXG52YXIgTWFuaWZvbGQgPSByZXF1aXJlKFwiLi4vTWFuaWZvbGRcIik7XG5cbnZhciBFZGdlU2hhcGUgPSByZXF1aXJlKFwiLi9FZGdlU2hhcGVcIik7XG5cbnZhciBDaGFpblNoYXBlID0gcmVxdWlyZShcIi4vQ2hhaW5TaGFwZVwiKTtcblxudmFyIENpcmNsZVNoYXBlID0gcmVxdWlyZShcIi4vQ2lyY2xlU2hhcGVcIik7XG5cbkNvbnRhY3QuYWRkVHlwZShFZGdlU2hhcGUuVFlQRSwgQ2lyY2xlU2hhcGUuVFlQRSwgRWRnZUNpcmNsZUNvbnRhY3QpO1xuXG5Db250YWN0LmFkZFR5cGUoQ2hhaW5TaGFwZS5UWVBFLCBDaXJjbGVTaGFwZS5UWVBFLCBDaGFpbkNpcmNsZUNvbnRhY3QpO1xuXG5mdW5jdGlvbiBFZGdlQ2lyY2xlQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZml4dHVyZUEuZ2V0VHlwZSgpID09IEVkZ2VTaGFwZS5UWVBFKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZml4dHVyZUIuZ2V0VHlwZSgpID09IENpcmNsZVNoYXBlLlRZUEUpO1xuICAgIHZhciBzaGFwZUEgPSBmaXh0dXJlQS5nZXRTaGFwZSgpO1xuICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgIENvbGxpZGVFZGdlQ2lyY2xlKG1hbmlmb2xkLCBzaGFwZUEsIHhmQSwgc2hhcGVCLCB4ZkIpO1xufVxuXG52YXIgY2NjX2VkZ2UgPSBuZXcgRWRnZVNoYXBlKCk7XG5cbmZ1bmN0aW9uIENoYWluQ2lyY2xlQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZml4dHVyZUEuZ2V0VHlwZSgpID09PSBDaGFpblNoYXBlLlRZUEUpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmaXh0dXJlQi5nZXRUeXBlKCkgPT09IENpcmNsZVNoYXBlLlRZUEUpO1xuICAgIHZhciBjaGFpbiA9IGZpeHR1cmVBLmdldFNoYXBlKCk7XG4gICAgdmFyIGVkZ2UgPSBjY2NfZWRnZTtcbiAgICBjaGFpbi5nZXRDaGlsZEVkZ2UoY2NjX2VkZ2UsIGluZGV4QSk7XG4gICAgdmFyIHNoYXBlQSA9IGNjY19lZGdlO1xuICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgIENvbGxpZGVFZGdlQ2lyY2xlKG1hbmlmb2xkLCBzaGFwZUEsIHhmQSwgc2hhcGVCLCB4ZkIpO1xufVxuXG52YXIgY2VjX2UgPSBWZWMyLnplcm8oKTtcblxudmFyIGNlY19RID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZWNfUCA9IFZlYzIuemVybygpO1xuXG52YXIgY2VjX2QgPSBWZWMyLnplcm8oKTtcblxudmFyIGNlY19uID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZWNfZTEgPSBWZWMyLnplcm8oKTtcblxudmFyIGNlY19lMiA9IFZlYzIuemVybygpO1xuXG52YXIgY2VjX3QxID0gVmVjMi56ZXJvKCk7XG5cbi8vIENvbXB1dGUgY29udGFjdCBwb2ludHMgZm9yIGVkZ2UgdmVyc3VzIGNpcmNsZS5cbi8vIFRoaXMgYWNjb3VudHMgZm9yIGVkZ2UgY29ubmVjdGl2aXR5LlxuZnVuY3Rpb24gQ29sbGlkZUVkZ2VDaXJjbGUobWFuaWZvbGQsIGVkZ2VBLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAwO1xuICAgIC8vIENvbXB1dGUgY2lyY2xlIGluIGZyYW1lIG9mIGVkZ2VcbiAgICB2YXIgUSA9IFRyYW5zZm9ybS5tdWxUVmVjMl8oeGZBLCBUcmFuc2Zvcm0ubXVsVmVjMl8oeGZCLCBjaXJjbGVCLm1fcCwgY2VjX3QxKSwgY2VjX1EpO1xuICAgIHZhciBBID0gZWRnZUEubV92ZXJ0ZXgxO1xuICAgIHZhciBCID0gZWRnZUEubV92ZXJ0ZXgyO1xuICAgIHZhciBlID0gVmVjMi5zdWJfKEIsIEEsIGNlY19lKTtcbiAgICAvLyBCYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuICAgIHZhciB1ID0gVmVjMi5kb3QoZSwgVmVjMi5zdWJfKEIsIFEsIGNlY190MSkpO1xuICAgIHZhciB2ID0gVmVjMi5kb3QoZSwgVmVjMi5zdWJfKFEsIEEsIGNlY190MSkpO1xuICAgIHZhciByYWRpdXMgPSBlZGdlQS5tX3JhZGl1cyArIGNpcmNsZUIubV9yYWRpdXM7XG4gICAgLy8gUmVnaW9uIEFcbiAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgIHZhciBQID0gY2VjX1Auc2V0VmVjMihBKTtcbiAgICAgICAgdmFyIGQgPSBWZWMyLnN1YihRLCBQLCBjZWNfZCk7XG4gICAgICAgIHZhciBkZCA9IFZlYzIuZG90KGQsIGQpO1xuICAgICAgICBpZiAoZGQgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJcyB0aGVyZSBhbiBlZGdlIGNvbm5lY3RlZCB0byBBP1xuICAgICAgICBpZiAoZWRnZUEubV9oYXNWZXJ0ZXgwKSB7XG4gICAgICAgICAgICB2YXIgQTEgPSBlZGdlQS5tX3ZlcnRleDA7XG4gICAgICAgICAgICB2YXIgQjEgPSBBO1xuICAgICAgICAgICAgdmFyIGUxID0gVmVjMi5zdWJfKEIxLCBBMSwgY2VjX2UxKTtcbiAgICAgICAgICAgIHZhciB1MSA9IFZlYzIuZG90KGUxLCBWZWMyLnN1YihCMSwgUSwgY2VjX3QxKSk7XG4gICAgICAgICAgICAvLyBJcyB0aGUgY2lyY2xlIGluIFJlZ2lvbiBBQiBvZiB0aGUgcHJldmlvdXMgZWRnZT9cbiAgICAgICAgICAgIGlmICh1MSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkLmVfY2lyY2xlcztcbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0WmVybygpO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldChQKTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LnNldChjaXJjbGVCLm1fcCk7XG4gICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEIgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZWdpb24gQlxuICAgIGlmICh1IDw9IDApIHtcbiAgICAgICAgdmFyIFAgPSBjZWNfUC5zZXRWZWMyKEIpO1xuICAgICAgICB2YXIgZCA9IFZlYzIuc3ViXyhRLCBQLCBjZWNfZCk7XG4gICAgICAgIHZhciBkZCA9IFZlYzIuZG90KGQsIGQpO1xuICAgICAgICBpZiAoZGQgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJcyB0aGVyZSBhbiBlZGdlIGNvbm5lY3RlZCB0byBCP1xuICAgICAgICBpZiAoZWRnZUEubV9oYXNWZXJ0ZXgzKSB7XG4gICAgICAgICAgICB2YXIgQjIgPSBlZGdlQS5tX3ZlcnRleDM7XG4gICAgICAgICAgICB2YXIgQTIgPSBCO1xuICAgICAgICAgICAgdmFyIGUyID0gVmVjMi5zdWJfKEIyLCBBMiwgY2VjX2UyKTtcbiAgICAgICAgICAgIHZhciB2MiA9IFZlYzIuZG90KGUyLCBWZWMyLnN1Yl8oUSwgQTIsIGNlY190MSkpO1xuICAgICAgICAgICAgLy8gSXMgdGhlIGNpcmNsZSBpbiBSZWdpb24gQUIgb2YgdGhlIG5leHQgZWRnZT9cbiAgICAgICAgICAgIGlmICh2MiA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkLmVfY2lyY2xlcztcbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0WmVybygpO1xuICAgICAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldChQKTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LnNldChjaXJjbGVCLm1fcCk7XG4gICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhBID0gMTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEIgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZWdpb24gQUJcbiAgICB2YXIgZGVuID0gVmVjMi5kb3QoZSwgZSk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGRlbiA+IDApO1xuICAgIHZhciBQID0gY2VjX1Auc2V0Q29tYmluZSh1IC8gZGVuLCBBLCB2IC8gZGVuLCBCKTtcbiAgICB2YXIgZCA9IFZlYzIuc3ViXyhRLCBQLCBjZWNfZCk7XG4gICAgdmFyIGRkID0gVmVjMi5kb3QoZCwgZCk7XG4gICAgaWYgKGRkID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG4gPSBjZWNfbi5zZXRYWSgtZS55LCBlLngpO1xuICAgIGlmIChWZWMyLmRvdChuLCBWZWMyLnN1Yl8oUSwgQSwgY2VjX3QxKSkgPCAwKSB7XG4gICAgICAgIG4uc2V0KC1uLngsIC1uLnkpO1xuICAgIH1cbiAgICBuLm5vcm1hbGl6ZSgpO1xuICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZC5lX2ZhY2VBO1xuICAgIG1hbmlmb2xkLmxvY2FsTm9ybWFsLnNldChuKTtcbiAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldChBKTtcbiAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMTtcbiAgICBtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludC5zZXQoY2lyY2xlQi5tX3ApO1xuICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5jZi50eXBlQSA9IE1hbmlmb2xkLmVfZmFjZTtcbiAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YuaW5kZXhCID0gMDtcbiAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuY2YudHlwZUIgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbn1cblxuXG59LHtcIi4uL0NvbnRhY3RcIjozLFwiLi4vTWFuaWZvbGRcIjo2LFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuL0NoYWluU2hhcGVcIjozOSxcIi4vQ2lyY2xlU2hhcGVcIjo0MCxcIi4vRWRnZVNoYXBlXCI6NDZ9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIENvbnRhY3QgPSByZXF1aXJlKFwiLi4vQ29udGFjdFwiKTtcblxudmFyIE1hbmlmb2xkID0gcmVxdWlyZShcIi4uL01hbmlmb2xkXCIpO1xuXG52YXIgRWRnZVNoYXBlID0gcmVxdWlyZShcIi4vRWRnZVNoYXBlXCIpO1xuXG52YXIgQ2hhaW5TaGFwZSA9IHJlcXVpcmUoXCIuL0NoYWluU2hhcGVcIik7XG5cbnZhciBQb2x5Z29uU2hhcGUgPSByZXF1aXJlKFwiLi9Qb2x5Z29uU2hhcGVcIik7XG5cbkNvbnRhY3QuYWRkVHlwZShFZGdlU2hhcGUuVFlQRSwgUG9seWdvblNoYXBlLlRZUEUsIEVkZ2VQb2x5Z29uQ29udGFjdCk7XG5cbkNvbnRhY3QuYWRkVHlwZShDaGFpblNoYXBlLlRZUEUsIFBvbHlnb25TaGFwZS5UWVBFLCBDaGFpblBvbHlnb25Db250YWN0KTtcblxuZnVuY3Rpb24gRWRnZVBvbHlnb25Db250YWN0KG1hbmlmb2xkLCB4ZkEsIGZBLCBpbmRleEEsIHhmQiwgZkIsIGluZGV4Qikge1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmQS5nZXRUeXBlKCkgPT09IEVkZ2VTaGFwZS5UWVBFKTtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZkIuZ2V0VHlwZSgpID09PSBQb2x5Z29uU2hhcGUuVFlQRSk7XG4gICAgQ29sbGlkZUVkZ2VQb2x5Z29uKG1hbmlmb2xkLCBmQS5nZXRTaGFwZSgpLCB4ZkEsIGZCLmdldFNoYXBlKCksIHhmQik7XG59XG5cbnZhciBjcGNfZWRnZSA9IG5ldyBFZGdlU2hhcGUoKTtcblxuZnVuY3Rpb24gQ2hhaW5Qb2x5Z29uQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmQSwgaW5kZXhBLCB4ZkIsIGZCLCBpbmRleEIpIHtcbiAgICBfQVNTRVJUICYmIGNvbW1vbi5hc3NlcnQoZkEuZ2V0VHlwZSgpID09PSBDaGFpblNoYXBlLlRZUEUpO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmQi5nZXRUeXBlKCkgPT09IFBvbHlnb25TaGFwZS5UWVBFKTtcbiAgICB2YXIgY2hhaW4gPSBmQS5nZXRTaGFwZSgpO1xuICAgIHZhciBlZGdlID0gY3BjX2VkZ2U7XG4gICAgY2hhaW4uZ2V0Q2hpbGRFZGdlKGVkZ2UsIGluZGV4QSk7XG4gICAgQ29sbGlkZUVkZ2VQb2x5Z29uKG1hbmlmb2xkLCBlZGdlLCB4ZkEsIGZCLmdldFNoYXBlKCksIHhmQik7XG59XG5cbi8vIEVQQXhpcyBUeXBlXG52YXIgZV91bmtub3duID0gLTE7XG5cbnZhciBlX2VkZ2VBID0gMTtcblxudmFyIGVfZWRnZUIgPSAyO1xuXG4vLyBWZXJ0ZXhUeXBlIHVudXNlZD9cbnZhciBlX2lzb2xhdGVkID0gMDtcblxudmFyIGVfY29uY2F2ZSA9IDE7XG5cbnZhciBlX2NvbnZleCA9IDI7XG5cbi8vIFRoaXMgc3RydWN0dXJlIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgYmVzdCBzZXBhcmF0aW5nIGF4aXMuXG5mdW5jdGlvbiBFUEF4aXMoKSB7XG4gICAgdGhpcy50eXBlO1xuICAgIC8vIFR5cGVcbiAgICB0aGlzLmluZGV4O1xuICAgIHRoaXMuc2VwYXJhdGlvbjtcbn1cblxuLy8gVGhpcyBob2xkcyBwb2x5Z29uIEIgZXhwcmVzc2VkIGluIGZyYW1lIEEuXG5mdW5jdGlvbiBUZW1wUG9seWdvbigpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG4gICAgLy8gVmVjMltTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXNdXG4gICAgdGhpcy5ub3JtYWxzID0gW107XG4gICAgLy8gVmVjMltTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXNdO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzOyBpKyspIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKFZlYzIuemVybygpKTtcbiAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goVmVjMi56ZXJvKCkpO1xuICAgIH1cbn1cblxuLy8gUmVmZXJlbmNlIGZhY2UgdXNlZCBmb3IgY2xpcHBpbmdcbmZ1bmN0aW9uIFJlZmVyZW5jZUZhY2UoKSB7XG4gICAgdGhpcy5pMSA9IC0xO1xuICAgIHRoaXMuaTIgPSAtMTtcbiAgICB0aGlzLnYxID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy52MiA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubm9ybWFsID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5zaWRlTm9ybWFsMSA9IFZlYzIuemVybygpO1xuICAgIHRoaXMuc2lkZU9mZnNldDEgPSAwO1xuICAgIHRoaXMuc2lkZU5vcm1hbDIgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLnNpZGVPZmZzZXQyID0gMDtcbn1cblxuLy8gcmV1c2VkXG52YXIgZWRnZUF4aXMgPSBuZXcgRVBBeGlzKCk7XG5cbnZhciBwb2x5Z29uQXhpcyA9IG5ldyBFUEF4aXMoKTtcblxudmFyIHBvbHlnb25CQSA9IG5ldyBUZW1wUG9seWdvbigpO1xuXG52YXIgcmYgPSBuZXcgUmVmZXJlbmNlRmFjZSgpO1xuXG52YXIgY2VwX3QxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZXBfdDIgPSBWZWMyLnplcm8oKTtcblxudmFyIGNlcF9uID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZXBfcGVycCA9IFZlYzIuemVybygpO1xuXG52YXIgY2VwX2NlbnRyb2lkQiA9IFZlYzIuemVybygpO1xuXG52YXIgY2VwX2VkZ2UxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZXBfbm9ybWFsMSA9IFZlYzIuemVybygpO1xuXG52YXIgY2VwX2VkZ2UwID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZXBfbm9ybWFsMCA9IFZlYzIuemVybygpO1xuXG52YXIgY2VwX2VkZ2UyID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZXBfbm9ybWFsMiA9IFZlYzIuemVybygpO1xuXG52YXIgY2VwX25vcm1hbCA9IFZlYzIuemVybygpO1xuXG52YXIgY2VwX2xvd2VyTGltaXQgPSBWZWMyLnplcm8oKTtcblxudmFyIGNlcF91cHBlckxpbWl0ID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjZXBfeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcblxudmFyIGNlcF9jbGlwUG9pbnRzMSA9IFsgbmV3IE1hbmlmb2xkLmNsaXBWZXJ0ZXgoKSwgbmV3IE1hbmlmb2xkLmNsaXBWZXJ0ZXgoKSBdO1xuXG52YXIgY2VwX2NsaXBQb2ludHMyID0gWyBuZXcgTWFuaWZvbGQuY2xpcFZlcnRleCgpLCBuZXcgTWFuaWZvbGQuY2xpcFZlcnRleCgpIF07XG5cbnZhciBjZXBfaWUgPSBbIG5ldyBNYW5pZm9sZC5jbGlwVmVydGV4KCksIG5ldyBNYW5pZm9sZC5jbGlwVmVydGV4KCkgXTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbGxpZGVzIGFuZCBlZGdlIGFuZCBhIHBvbHlnb24sIHRha2luZyBpbnRvIGFjY291bnQgZWRnZVxuICogYWRqYWNlbmN5LlxuICovXG5mdW5jdGlvbiBDb2xsaWRlRWRnZVBvbHlnb24obWFuaWZvbGQsIGVkZ2VBLCB4ZkEsIHBvbHlnb25CLCB4ZkIpIHtcbiAgICAvLyBBbGdvcml0aG06XG4gICAgLy8gMS4gQ2xhc3NpZnkgdjEgYW5kIHYyXG4gICAgLy8gMi4gQ2xhc3NpZnkgcG9seWdvbiBjZW50cm9pZCBhcyBmcm9udCBvciBiYWNrXG4gICAgLy8gMy4gRmxpcCBub3JtYWwgaWYgbmVjZXNzYXJ5XG4gICAgLy8gNC4gSW5pdGlhbGl6ZSBub3JtYWwgcmFuZ2UgdG8gWy1waSwgcGldIGFib3V0IGZhY2Ugbm9ybWFsXG4gICAgLy8gNS4gQWRqdXN0IG5vcm1hbCByYW5nZSBhY2NvcmRpbmcgdG8gYWRqYWNlbnQgZWRnZXNcbiAgICAvLyA2LiBWaXNpdCBlYWNoIHNlcGFyYXRpbmcgYXhlcywgb25seSBhY2NlcHQgYXhlcyB3aXRoaW4gdGhlIHJhbmdlXG4gICAgLy8gNy4gUmV0dXJuIGlmIF9hbnlfIGF4aXMgaW5kaWNhdGVzIHNlcGFyYXRpb25cbiAgICAvLyA4LiBDbGlwXG4gICAgdmFyIG1fdHlwZTEsIG1fdHlwZTI7XG4gICAgLy8gVmVydGV4VHlwZSB1bnVzZWQ/XG4gICAgdmFyIHhmID0gVHJhbnNmb3JtLm11bFRYZl8oeGZBLCB4ZkIsIGNlcF94Zik7XG4gICAgdmFyIGNlbnRyb2lkQiA9IFRyYW5zZm9ybS5tdWxWZWMyXyh4ZiwgcG9seWdvbkIubV9jZW50cm9pZCwgY2VwX2NlbnRyb2lkQik7XG4gICAgdmFyIHYwID0gZWRnZUEubV92ZXJ0ZXgwO1xuICAgIHZhciB2MSA9IGVkZ2VBLm1fdmVydGV4MTtcbiAgICB2YXIgdjIgPSBlZGdlQS5tX3ZlcnRleDI7XG4gICAgdmFyIHYzID0gZWRnZUEubV92ZXJ0ZXgzO1xuICAgIHZhciBoYXNWZXJ0ZXgwID0gZWRnZUEubV9oYXNWZXJ0ZXgwO1xuICAgIHZhciBoYXNWZXJ0ZXgzID0gZWRnZUEubV9oYXNWZXJ0ZXgzO1xuICAgIHZhciBlZGdlMSA9IFZlYzIuc3ViXyh2MiwgdjEsIGNlcF9lZGdlMSk7XG4gICAgZWRnZTEubm9ybWFsaXplKCk7XG4gICAgdmFyIG5vcm1hbDEgPSBjZXBfbm9ybWFsMS5zZXRYWShlZGdlMS55LCAtZWRnZTEueCk7XG4gICAgdmFyIG9mZnNldDEgPSBWZWMyLmRvdChub3JtYWwxLCBWZWMyLnN1Yl8oY2VudHJvaWRCLCB2MSwgY2VwX3QxKSk7XG4gICAgdmFyIG9mZnNldDAgPSAwO1xuICAgIHZhciBvZmZzZXQyID0gMDtcbiAgICB2YXIgY29udmV4MSA9IGZhbHNlO1xuICAgIHZhciBjb252ZXgyID0gZmFsc2U7XG4gICAgLy8gSXMgdGhlcmUgYSBwcmVjZWRpbmcgZWRnZT9cbiAgICBpZiAoaGFzVmVydGV4MCkge1xuICAgICAgICB2YXIgZWRnZTAgPSBWZWMyLnN1Yl8odjEsIHYwLCBjZXBfZWRnZTApO1xuICAgICAgICBlZGdlMC5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIG5vcm1hbDAgPSBjZXBfbm9ybWFsMC5zZXRYWShlZGdlMC55LCAtZWRnZTAueCk7XG4gICAgICAgIGNvbnZleDEgPSBWZWMyLmNyb3NzKGVkZ2UwLCBlZGdlMSkgPj0gMDtcbiAgICAgICAgb2Zmc2V0MCA9IFZlYzIuZG90KG5vcm1hbDAsIGNlbnRyb2lkQikgLSBWZWMyLmRvdChub3JtYWwwLCB2MCk7XG4gICAgfVxuICAgIC8vIElzIHRoZXJlIGEgZm9sbG93aW5nIGVkZ2U/XG4gICAgaWYgKGhhc1ZlcnRleDMpIHtcbiAgICAgICAgdmFyIGVkZ2UyID0gVmVjMi5zdWJfKHYzLCB2MiwgY2VwX2VkZ2UyKTtcbiAgICAgICAgZWRnZTIubm9ybWFsaXplKCk7XG4gICAgICAgIHZhciBub3JtYWwyID0gY2VwX25vcm1hbDIuc2V0KGVkZ2UyLnksIC1lZGdlMi54KTtcbiAgICAgICAgY29udmV4MiA9IFZlYzIuY3Jvc3MoZWRnZTEsIGVkZ2UyKSA+IDA7XG4gICAgICAgIG9mZnNldDIgPSBWZWMyLmRvdChub3JtYWwyLCBjZW50cm9pZEIpIC0gVmVjMi5kb3Qobm9ybWFsMiwgdjIpO1xuICAgIH1cbiAgICB2YXIgZnJvbnQgPSAwO1xuICAgIHZhciBub3JtYWwgPSBjZXBfbm9ybWFsLnNldFplcm8oKTtcbiAgICB2YXIgbG93ZXJMaW1pdCA9IGNlcF9sb3dlckxpbWl0LnNldFplcm8oKTtcbiAgICB2YXIgdXBwZXJMaW1pdCA9IGNlcF91cHBlckxpbWl0LnNldFplcm8oKTtcbiAgICAvLyBEZXRlcm1pbmUgZnJvbnQgb3IgYmFjayBjb2xsaXNpb24uIERldGVybWluZSBjb2xsaXNpb24gbm9ybWFsIGxpbWl0cy5cbiAgICBpZiAoaGFzVmVydGV4MCAmJiBoYXNWZXJ0ZXgzKSB7XG4gICAgICAgIGlmIChjb252ZXgxICYmIGNvbnZleDIpIHtcbiAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwIHx8IG9mZnNldDEgPj0gMCB8fCBvZmZzZXQyID49IDA7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0KG5vcm1hbDApO1xuICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0KG5vcm1hbDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbnZleDEpIHtcbiAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwIHx8IG9mZnNldDEgPj0gMCAmJiBvZmZzZXQyID49IDA7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0KG5vcm1hbDApO1xuICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMik7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbnZleDIpIHtcbiAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MiA+PSAwIHx8IG9mZnNldDAgPj0gMCAmJiBvZmZzZXQxID49IDA7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0KG5vcm1hbDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQwID49IDAgJiYgb2Zmc2V0MSA+PSAwICYmIG9mZnNldDIgPj0gMDtcbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc1ZlcnRleDApIHtcbiAgICAgICAgaWYgKGNvbnZleDEpIHtcbiAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwIHx8IG9mZnNldDEgPj0gMDtcbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXQobm9ybWFsMCk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldChub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9udCA9IG9mZnNldDAgPj0gMCAmJiBvZmZzZXQxID49IDA7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsLnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNWZXJ0ZXgzKSB7XG4gICAgICAgIGlmIChjb252ZXgyKSB7XG4gICAgICAgICAgICBmcm9udCA9IG9mZnNldDEgPj0gMCB8fCBvZmZzZXQyID49IDA7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldChub3JtYWwyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsLnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgbG93ZXJMaW1pdC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIHVwcGVyTGltaXQuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQxID49IDAgJiYgb2Zmc2V0MiA+PSAwO1xuICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsLnNldChub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbC5zZXRNdWwoLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0TXVsKC0xLCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICB1cHBlckxpbWl0LnNldChub3JtYWwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb250ID0gb2Zmc2V0MSA+PSAwO1xuICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgIG5vcm1hbC5zZXQobm9ybWFsMSk7XG4gICAgICAgICAgICBsb3dlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICB1cHBlckxpbWl0LnNldE11bCgtMSwgbm9ybWFsMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWwuc2V0TXVsKC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgIGxvd2VyTGltaXQuc2V0KG5vcm1hbDEpO1xuICAgICAgICAgICAgdXBwZXJMaW1pdC5zZXQobm9ybWFsMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHBvbHlnb25CIGluIGZyYW1lQVxuICAgIHBvbHlnb25CQS5jb3VudCA9IHBvbHlnb25CLm1fY291bnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQi5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgcG9seWdvbkJBLnZlcnRpY2VzW2ldID0gVHJhbnNmb3JtLm11bFZlYzJfKHhmLCBwb2x5Z29uQi5tX3ZlcnRpY2VzW2ldLCBwb2x5Z29uQkEudmVydGljZXNbaV0pO1xuICAgICAgICBwb2x5Z29uQkEubm9ybWFsc1tpXSA9IFJvdC5tdWxWZWMyXyh4Zi5xLCBwb2x5Z29uQi5tX25vcm1hbHNbaV0sIHBvbHlnb25CQS5ub3JtYWxzW2ldKTtcbiAgICB9XG4gICAgdmFyIHJhZGl1cyA9IDIgKiBTZXR0aW5ncy5wb2x5Z29uUmFkaXVzO1xuICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAwO1xuICAgIHtcbiAgICAgICAgLy8gQ29tcHV0ZUVkZ2VTZXBhcmF0aW9uXG4gICAgICAgIGVkZ2VBeGlzLnR5cGUgPSBlX2VkZ2VBO1xuICAgICAgICBlZGdlQXhpcy5pbmRleCA9IGZyb250ID8gMCA6IDE7XG4gICAgICAgIGVkZ2VBeGlzLnNlcGFyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQkEuY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHMgPSBWZWMyLmRvdChub3JtYWwsIFZlYzIuc3ViKHBvbHlnb25CQS52ZXJ0aWNlc1tpXSwgdjEsIGNlcF90MSkpO1xuICAgICAgICAgICAgaWYgKHMgPCBlZGdlQXhpcy5zZXBhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWRnZUF4aXMuc2VwYXJhdGlvbiA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgbm8gdmFsaWQgbm9ybWFsIGNhbiBiZSBmb3VuZCB0aGFuIHRoaXMgZWRnZSBzaG91bGQgbm90IGNvbGxpZGUuXG4gICAgaWYgKGVkZ2VBeGlzLnR5cGUgPT09IGVfdW5rbm93bikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGdlQXhpcy5zZXBhcmF0aW9uID4gcmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAge1xuICAgICAgICAvLyBDb21wdXRlUG9seWdvblNlcGFyYXRpb25cbiAgICAgICAgcG9seWdvbkF4aXMudHlwZSA9IGVfdW5rbm93bjtcbiAgICAgICAgcG9seWdvbkF4aXMuaW5kZXggPSAtMTtcbiAgICAgICAgcG9seWdvbkF4aXMuc2VwYXJhdGlvbiA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIHBlcnAgPSBjZXBfcGVycC5zZXQoLW5vcm1hbC55LCBub3JtYWwueCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbkJBLmNvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuID0gY2VwX24uc2V0KHBvbHlnb25CQS5ub3JtYWxzW2ldKS5uZWcoKTtcbiAgICAgICAgICAgIHZhciBzMSA9IFZlYzIuZG90KG4sIFZlYzIuc3ViXyhwb2x5Z29uQkEudmVydGljZXNbaV0sIHYxLCBjZXBfdDEpKTtcbiAgICAgICAgICAgIHZhciBzMiA9IFZlYzIuZG90KG4sIFZlYzIuc3ViXyhwb2x5Z29uQkEudmVydGljZXNbaV0sIHYyLCBjZXBfdDEpKTtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5taW4oczEsIHMyKTtcbiAgICAgICAgICAgIGlmIChzID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgcG9seWdvbkF4aXMudHlwZSA9IGVfZWRnZUI7XG4gICAgICAgICAgICAgICAgcG9seWdvbkF4aXMuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHBvbHlnb25BeGlzLnNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRqYWNlbmN5XG4gICAgICAgICAgICBpZiAoVmVjMi5kb3QobiwgcGVycCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChWZWMyLmRvdChWZWMyLnN1Yl8obiwgdXBwZXJMaW1pdCwgY2VwX3QxKSwgbm9ybWFsKSA8IC1TZXR0aW5ncy5hbmd1bGFyU2xvcCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChWZWMyLmRvdChWZWMyLnN1Yl8obiwgbG93ZXJMaW1pdCwgY2VwX3QxKSwgbm9ybWFsKSA8IC1TZXR0aW5ncy5hbmd1bGFyU2xvcCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocyA+IHBvbHlnb25BeGlzLnNlcGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy50eXBlID0gZV9lZGdlQjtcbiAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcG9seWdvbkF4aXMuc2VwYXJhdGlvbiA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25BeGlzLnR5cGUgIT09IGVfdW5rbm93biAmJiBwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID4gcmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXNlIGh5c3RlcmVzaXMgZm9yIGppdHRlciByZWR1Y3Rpb24uXG4gICAgdmFyIGtfcmVsYXRpdmVUb2wgPSAuOTg7XG4gICAgdmFyIGtfYWJzb2x1dGVUb2wgPSAuMDAxO1xuICAgIHZhciBwcmltYXJ5QXhpcztcbiAgICBpZiAocG9seWdvbkF4aXMudHlwZSA9PT0gZV91bmtub3duKSB7XG4gICAgICAgIHByaW1hcnlBeGlzID0gZWRnZUF4aXM7XG4gICAgfSBlbHNlIGlmIChwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID4ga19yZWxhdGl2ZVRvbCAqIGVkZ2VBeGlzLnNlcGFyYXRpb24gKyBrX2Fic29sdXRlVG9sKSB7XG4gICAgICAgIHByaW1hcnlBeGlzID0gcG9seWdvbkF4aXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJpbWFyeUF4aXMgPSBlZGdlQXhpcztcbiAgICB9XG4gICAgY2VwX2llWzBdLmluaXQoKTtcbiAgICBjZXBfaWVbMV0uaW5pdCgpO1xuICAgIHZhciBpZSA9IGNlcF9pZTtcbiAgICBpZiAocHJpbWFyeUF4aXMudHlwZSA9PT0gZV9lZGdlQSkge1xuICAgICAgICBtYW5pZm9sZC50eXBlID0gTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgcG9seWdvbiBub3JtYWwgdGhhdCBpcyBtb3N0IGFudGktcGFyYWxsZWwgdG8gdGhlIGVkZ2VcbiAgICAgICAgLy8gbm9ybWFsLlxuICAgICAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IFZlYzIuZG90KG5vcm1hbCwgcG9seWdvbkJBLm5vcm1hbHNbMF0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvbHlnb25CQS5jb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBWZWMyLmRvdChub3JtYWwsIHBvbHlnb25CQS5ub3JtYWxzW2ldKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkxID0gYmVzdEluZGV4O1xuICAgICAgICB2YXIgaTIgPSBpMSArIDEgPCBwb2x5Z29uQkEuY291bnQgPyBpMSArIDEgOiAwO1xuICAgICAgICBpZVswXS52LnNldChwb2x5Z29uQkEudmVydGljZXNbaTFdKTtcbiAgICAgICAgaWVbMF0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgaWVbMF0uaWQuY2YuaW5kZXhCID0gaTE7XG4gICAgICAgIGllWzBdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV9mYWNlO1xuICAgICAgICBpZVswXS5pZC5jZi50eXBlQiA9IE1hbmlmb2xkLmVfdmVydGV4O1xuICAgICAgICBpZVsxXS52LnNldChwb2x5Z29uQkEudmVydGljZXNbaTJdKTtcbiAgICAgICAgaWVbMV0uaWQuY2YuaW5kZXhBID0gMDtcbiAgICAgICAgaWVbMV0uaWQuY2YuaW5kZXhCID0gaTI7XG4gICAgICAgIGllWzFdLmlkLmNmLnR5cGVBID0gTWFuaWZvbGQuZV9mYWNlO1xuICAgICAgICBpZVsxXS5pZC5jZi50eXBlQiA9IE1hbmlmb2xkLmVfdmVydGV4O1xuICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgIHJmLmkxID0gMDtcbiAgICAgICAgICAgIHJmLmkyID0gMTtcbiAgICAgICAgICAgIHJmLnYxLnNldCh2MSk7XG4gICAgICAgICAgICByZi52Mi5zZXQodjIpO1xuICAgICAgICAgICAgcmYubm9ybWFsLnNldChub3JtYWwxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJmLmkxID0gMTtcbiAgICAgICAgICAgIHJmLmkyID0gMDtcbiAgICAgICAgICAgIHJmLnYxLnNldCh2Mik7XG4gICAgICAgICAgICByZi52Mi5zZXQodjEpO1xuICAgICAgICAgICAgcmYubm9ybWFsLnNldChub3JtYWwxKS5uZWcoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZC5lX2ZhY2VCO1xuICAgICAgICBpZVswXS52LnNldCh2MSk7XG4gICAgICAgIGllWzBdLmlkLmNmLmluZGV4QSA9IDA7XG4gICAgICAgIGllWzBdLmlkLmNmLmluZGV4QiA9IHByaW1hcnlBeGlzLmluZGV4O1xuICAgICAgICBpZVswXS5pZC5jZi50eXBlQSA9IE1hbmlmb2xkLmVfdmVydGV4O1xuICAgICAgICBpZVswXS5pZC5jZi50eXBlQiA9IE1hbmlmb2xkLmVfZmFjZTtcbiAgICAgICAgaWVbMV0udi5zZXQodjIpO1xuICAgICAgICBpZVsxXS5pZC5jZi5pbmRleEEgPSAwO1xuICAgICAgICBpZVsxXS5pZC5jZi5pbmRleEIgPSBwcmltYXJ5QXhpcy5pbmRleDtcbiAgICAgICAgaWVbMV0uaWQuY2YudHlwZUEgPSBNYW5pZm9sZC5lX3ZlcnRleDtcbiAgICAgICAgaWVbMV0uaWQuY2YudHlwZUIgPSBNYW5pZm9sZC5lX2ZhY2U7XG4gICAgICAgIHJmLmkxID0gcHJpbWFyeUF4aXMuaW5kZXg7XG4gICAgICAgIHJmLmkyID0gcmYuaTEgKyAxIDwgcG9seWdvbkJBLmNvdW50ID8gcmYuaTEgKyAxIDogMDtcbiAgICAgICAgcmYudjEuc2V0KHBvbHlnb25CQS52ZXJ0aWNlc1tyZi5pMV0pO1xuICAgICAgICByZi52Mi5zZXQocG9seWdvbkJBLnZlcnRpY2VzW3JmLmkyXSk7XG4gICAgICAgIHJmLm5vcm1hbC5zZXQocG9seWdvbkJBLm5vcm1hbHNbcmYuaTFdKTtcbiAgICB9XG4gICAgcmYuc2lkZU5vcm1hbDEuc2V0KHJmLm5vcm1hbC55LCAtcmYubm9ybWFsLngpO1xuICAgIHJmLnNpZGVOb3JtYWwyLnNldE11bCgtMSwgcmYuc2lkZU5vcm1hbDEpO1xuICAgIHJmLnNpZGVPZmZzZXQxID0gVmVjMi5kb3QocmYuc2lkZU5vcm1hbDEsIHJmLnYxKTtcbiAgICByZi5zaWRlT2Zmc2V0MiA9IFZlYzIuZG90KHJmLnNpZGVOb3JtYWwyLCByZi52Mik7XG4gICAgLy8gQ2xpcCBpbmNpZGVudCBlZGdlIGFnYWluc3QgZXh0cnVkZWQgZWRnZTEgc2lkZSBlZGdlcy5cbiAgICBjZXBfY2xpcFBvaW50czFbMF0uaW5pdCgpO1xuICAgIGNlcF9jbGlwUG9pbnRzMVsxXS5pbml0KCk7XG4gICAgY2VwX2NsaXBQb2ludHMyWzBdLmluaXQoKTtcbiAgICBjZXBfY2xpcFBvaW50czJbMV0uaW5pdCgpO1xuICAgIHZhciBjbGlwUG9pbnRzMSA9IGNlcF9jbGlwUG9pbnRzMTtcbiAgICB2YXIgY2xpcFBvaW50czIgPSBjZXBfY2xpcFBvaW50czI7XG4gICAgdmFyIG5wO1xuICAgIC8vIENsaXAgdG8gYm94IHNpZGUgMVxuICAgIG5wID0gTWFuaWZvbGQuY2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czEsIGllLCByZi5zaWRlTm9ybWFsMSwgcmYuc2lkZU9mZnNldDEsIHJmLmkxKTtcbiAgICBpZiAobnAgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENsaXAgdG8gbmVnYXRpdmUgYm94IHNpZGUgMVxuICAgIG5wID0gTWFuaWZvbGQuY2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czIsIGNsaXBQb2ludHMxLCByZi5zaWRlTm9ybWFsMiwgcmYuc2lkZU9mZnNldDIsIHJmLmkyKTtcbiAgICBpZiAobnAgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5vdyBjbGlwUG9pbnRzMiBjb250YWlucyB0aGUgY2xpcHBlZCBwb2ludHMuXG4gICAgaWYgKHByaW1hcnlBeGlzLnR5cGUgPT09IGVfZWRnZUEpIHtcbiAgICAgICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0KHJmLm5vcm1hbCk7XG4gICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0KHJmLnYxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYW5pZm9sZC5sb2NhbE5vcm1hbC5zZXQocG9seWdvbkIubV9ub3JtYWxzW3JmLmkxXSk7XG4gICAgICAgIG1hbmlmb2xkLmxvY2FsUG9pbnQuc2V0KHBvbHlnb25CLm1fdmVydGljZXNbcmYuaTFdKTtcbiAgICB9XG4gICAgdmFyIHBvaW50Q291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xuICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IFZlYzIuZG90KHJmLm5vcm1hbCwgVmVjMi5zdWJfKGNsaXBQb2ludHMyW2ldLnYsIHJmLnYxLCBjZXBfdDEpKTtcbiAgICAgICAgaWYgKHNlcGFyYXRpb24gPD0gcmFkaXVzKSB7XG4gICAgICAgICAgICB2YXIgY3AgPSBtYW5pZm9sZC5wb2ludHNbcG9pbnRDb3VudF07XG4gICAgICAgICAgICAvLyBNYW5pZm9sZFBvaW50XG4gICAgICAgICAgICBpZiAocHJpbWFyeUF4aXMudHlwZSA9PT0gZV9lZGdlQSkge1xuICAgICAgICAgICAgICAgIGNwLmxvY2FsUG9pbnQgPSBUcmFuc2Zvcm0ubXVsVFZlYzJfKHhmLCBjbGlwUG9pbnRzMltpXS52LCBjcC5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICBjcC5pZC5zZXQoY2xpcFBvaW50czJbaV0uaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcC5sb2NhbFBvaW50LnNldChjbGlwUG9pbnRzMltpXS52KTtcbiAgICAgICAgICAgICAgICBjcC5pZC5jZi50eXBlQSA9IGNsaXBQb2ludHMyW2ldLmlkLmNmLnR5cGVCO1xuICAgICAgICAgICAgICAgIGNwLmlkLmNmLnR5cGVCID0gY2xpcFBvaW50czJbaV0uaWQuY2YudHlwZUE7XG4gICAgICAgICAgICAgICAgY3AuaWQuY2YuaW5kZXhBID0gY2xpcFBvaW50czJbaV0uaWQuY2YuaW5kZXhCO1xuICAgICAgICAgICAgICAgIGNwLmlkLmNmLmluZGV4QiA9IGNsaXBQb2ludHMyW2ldLmlkLmNmLmluZGV4QTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrcG9pbnRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gcG9pbnRDb3VudDtcbn1cblxuXG59LHtcIi4uL0NvbnRhY3RcIjozLFwiLi4vTWFuaWZvbGRcIjo2LFwiLi4vU2V0dGluZ3NcIjo3LFwiLi4vY29tbW9uL01hdGhcIjoxOCxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIjoyMixcIi4uL2NvbW1vbi9WZWMyXCI6MjMsXCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9DaGFpblNoYXBlXCI6MzksXCIuL0VkZ2VTaGFwZVwiOjQ2LFwiLi9Qb2x5Z29uU2hhcGVcIjo0N31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbW1vblwiKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuLi9jb21tb24vVHJhbnNmb3JtXCIpO1xuXG52YXIgUm90ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Sb3RcIik7XG5cbnZhciBWZWMyID0gcmVxdWlyZShcIi4uL2NvbW1vbi9WZWMyXCIpO1xuXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vU2V0dGluZ3NcIik7XG5cbnZhciBNYW5pZm9sZCA9IHJlcXVpcmUoXCIuLi9NYW5pZm9sZFwiKTtcblxudmFyIENvbnRhY3QgPSByZXF1aXJlKFwiLi4vQ29udGFjdFwiKTtcblxudmFyIFBvbHlnb25TaGFwZSA9IHJlcXVpcmUoXCIuL1BvbHlnb25TaGFwZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaWRlUG9seWdvbnM7XG5cbkNvbnRhY3QuYWRkVHlwZShQb2x5Z29uU2hhcGUuVFlQRSwgUG9seWdvblNoYXBlLlRZUEUsIFBvbHlnb25Db250YWN0KTtcblxuZnVuY3Rpb24gUG9seWdvbkNvbnRhY3QobWFuaWZvbGQsIHhmQSwgZml4dHVyZUEsIGluZGV4QSwgeGZCLCBmaXh0dXJlQiwgaW5kZXhCKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZpeHR1cmVBLmdldFR5cGUoKSA9PSBQb2x5Z29uU2hhcGUuVFlQRSk7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGZpeHR1cmVCLmdldFR5cGUoKSA9PSBQb2x5Z29uU2hhcGUuVFlQRSk7XG4gICAgQ29sbGlkZVBvbHlnb25zKG1hbmlmb2xkLCBmaXh0dXJlQS5nZXRTaGFwZSgpLCB4ZkEsIGZpeHR1cmVCLmdldFNoYXBlKCksIHhmQik7XG59XG5cbnZhciBmbXNfdjEgPSBWZWMyLnplcm8oKTtcblxudmFyIGZtc19uID0gVmVjMi56ZXJvKCk7XG5cbnZhciBmbXNfeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcblxudmFyIGZtc19tYXhTZXBhcmF0aW9uO1xuXG52YXIgZm1zX2Jlc3RJbmRleDtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXggc2VwYXJhdGlvbiBiZXR3ZWVuIHBvbHkxIGFuZCBwb2x5MiB1c2luZyBlZGdlIG5vcm1hbHMgZnJvbVxuICogcG9seTEuXG4gKi9cbmZ1bmN0aW9uIEZpbmRNYXhTZXBhcmF0aW9uKHBvbHkxLCB4ZjEsIHBvbHkyLCB4ZjIpIHtcbiAgICB2YXIgY291bnQxID0gcG9seTEubV9jb3VudDtcbiAgICB2YXIgY291bnQyID0gcG9seTIubV9jb3VudDtcbiAgICB2YXIgbjFzID0gcG9seTEubV9ub3JtYWxzO1xuICAgIHZhciB2MXMgPSBwb2x5MS5tX3ZlcnRpY2VzO1xuICAgIHZhciB2MnMgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xuICAgIHZhciB4ZiA9IFRyYW5zZm9ybS5tdWxUWGZfKHhmMiwgeGYxLCBmbXNfeGYpO1xuICAgIHZhciBiZXN0SW5kZXggPSAwO1xuICAgIHZhciBtYXhTZXBhcmF0aW9uID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQxOyArK2kpIHtcbiAgICAgICAgLy8gR2V0IHBvbHkxIG5vcm1hbCBpbiBmcmFtZTIuXG4gICAgICAgIHZhciBuID0gUm90Lm11bFZlYzJfKHhmLnEsIG4xc1tpXSwgZm1zX24pO1xuICAgICAgICB2YXIgdjEgPSBUcmFuc2Zvcm0ubXVsVmVjMl8oeGYsIHYxc1tpXSwgZm1zX3YxKTtcbiAgICAgICAgLy8gRmluZCBkZWVwZXN0IHBvaW50IGZvciBub3JtYWwgaS5cbiAgICAgICAgdmFyIHNpID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQyOyArK2opIHtcbiAgICAgICAgICAgIHZhciBzaWogPSBWZWMyLmRvdChuLCB2MnNbal0pIC0gVmVjMi5kb3QobiwgdjEpO1xuICAgICAgICAgICAgaWYgKHNpaiA8IHNpKSB7XG4gICAgICAgICAgICAgICAgc2kgPSBzaWo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpID4gbWF4U2VwYXJhdGlvbikge1xuICAgICAgICAgICAgbWF4U2VwYXJhdGlvbiA9IHNpO1xuICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIHRvIGtlZXAgbGFzdCBGaW5kTWF4U2VwYXJhdGlvbiBjYWxsIHZhbHVlc1xuICAgIGZtc19tYXhTZXBhcmF0aW9uID0gbWF4U2VwYXJhdGlvbjtcbiAgICBmbXNfYmVzdEluZGV4ID0gYmVzdEluZGV4O1xufVxuXG52YXIgZmllX3QxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBmaWVfbm9ybWFsMSA9IFZlYzIuemVybygpO1xuXG4vKipcbiAqIEBwYXJhbSB7Q2xpcFZlcnRleFsyXX0gY1xuICogQHBhcmFtIHtpbnR9IGVkZ2UxXG4gKi9cbmZ1bmN0aW9uIEZpbmRJbmNpZGVudEVkZ2UoYywgcG9seTEsIHhmMSwgZWRnZTEsIHBvbHkyLCB4ZjIpIHtcbiAgICB2YXIgbm9ybWFsczEgPSBwb2x5MS5tX25vcm1hbHM7XG4gICAgdmFyIGNvdW50MiA9IHBvbHkyLm1fY291bnQ7XG4gICAgdmFyIHZlcnRpY2VzMiA9IHBvbHkyLm1fdmVydGljZXM7XG4gICAgdmFyIG5vcm1hbHMyID0gcG9seTIubV9ub3JtYWxzO1xuICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydCgwIDw9IGVkZ2UxICYmIGVkZ2UxIDwgcG9seTEubV9jb3VudCk7XG4gICAgLy8gR2V0IHRoZSBub3JtYWwgb2YgdGhlIHJlZmVyZW5jZSBlZGdlIGluIHBvbHkyJ3MgZnJhbWUuXG4gICAgdmFyIG5vcm1hbDEgPSBSb3QubXVsVFZlYzJfKHhmMi5xLCBSb3QubXVsVmVjMl8oeGYxLnEsIG5vcm1hbHMxW2VkZ2UxXSwgZmllX3QxKSwgZmllX25vcm1hbDEpO1xuICAgIC8vIEZpbmQgdGhlIGluY2lkZW50IGVkZ2Ugb24gcG9seTIuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbWluRG90ID0gSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDI7ICsraSkge1xuICAgICAgICB2YXIgZG90ID0gVmVjMi5kb3Qobm9ybWFsMSwgbm9ybWFsczJbaV0pO1xuICAgICAgICBpZiAoZG90IDwgbWluRG90KSB7XG4gICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQnVpbGQgdGhlIGNsaXAgdmVydGljZXMgZm9yIHRoZSBpbmNpZGVudCBlZGdlLlxuICAgIHZhciBpMSA9IGluZGV4O1xuICAgIHZhciBpMiA9IGkxICsgMSA8IGNvdW50MiA/IGkxICsgMSA6IDA7XG4gICAgY1swXS52ID0gVHJhbnNmb3JtLm11bFZlYzIoeGYyLCB2ZXJ0aWNlczJbaTFdKTtcbiAgICBjWzBdLmlkLmNmLmluZGV4QSA9IGVkZ2UxO1xuICAgIGNbMF0uaWQuY2YuaW5kZXhCID0gaTE7XG4gICAgY1swXS5pZC5jZi50eXBlQSA9IE1hbmlmb2xkLmVfZmFjZTtcbiAgICBjWzBdLmlkLmNmLnR5cGVCID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG4gICAgY1sxXS52ID0gVHJhbnNmb3JtLm11bFZlYzIoeGYyLCB2ZXJ0aWNlczJbaTJdKTtcbiAgICBjWzFdLmlkLmNmLmluZGV4QSA9IGVkZ2UxO1xuICAgIGNbMV0uaWQuY2YuaW5kZXhCID0gaTI7XG4gICAgY1sxXS5pZC5jZi50eXBlQSA9IE1hbmlmb2xkLmVfZmFjZTtcbiAgICBjWzFdLmlkLmNmLnR5cGVCID0gTWFuaWZvbGQuZV92ZXJ0ZXg7XG59XG5cbnZhciBjcGdfcGxhbmVQb2ludCA9IFZlYzIuemVybygpO1xuXG52YXIgY3BnX3RhbmdlbnQgPSBWZWMyLnplcm8oKTtcblxudmFyIGNwZ19ub3JtYWwgPSBWZWMyLnplcm8oKTtcblxudmFyIGNwZ19sb2NhbFRhbmdlbnQgPSBWZWMyLnplcm8oKTtcblxudmFyIGNwZ19sb2NhbE5vcm1hbCA9IFZlYzIuemVybygpO1xuXG52YXIgY3BnX3YxMSA9IFZlYzIuemVybygpO1xuXG52YXIgY3BnX3YxMiA9IFZlYzIuemVybygpO1xuXG52YXIgY3BnX3QxID0gVmVjMi56ZXJvKCk7XG5cbnZhciBjcGdfY2xpcFBvaW50czEgPSBbIG5ldyBNYW5pZm9sZC5jbGlwVmVydGV4KCksIG5ldyBNYW5pZm9sZC5jbGlwVmVydGV4KCkgXTtcblxudmFyIGNwZ19jbGlwUG9pbnRzMiA9IFsgbmV3IE1hbmlmb2xkLmNsaXBWZXJ0ZXgoKSwgbmV3IE1hbmlmb2xkLmNsaXBWZXJ0ZXgoKSBdO1xuXG52YXIgY3BnX2luY2lkZW50RWRnZSA9IFsgbmV3IE1hbmlmb2xkLmNsaXBWZXJ0ZXgoKSwgbmV3IE1hbmlmb2xkLmNsaXBWZXJ0ZXgoKSBdO1xuXG4vKipcbiAqIFxuICogRmluZCBlZGdlIG5vcm1hbCBvZiBtYXggc2VwYXJhdGlvbiBvbiBBIC0gcmV0dXJuIGlmIHNlcGFyYXRpbmcgYXhpcyBpcyBmb3VuZDxicj5cbiAqIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQiAtIHJldHVybiBpZiBzZXBhcmF0aW9uIGF4aXMgaXMgZm91bmQ8YnI+XG4gKiBDaG9vc2UgcmVmZXJlbmNlIGVkZ2UgYXMgbWluKG1pbkEsIG1pbkIpPGJyPlxuICogRmluZCBpbmNpZGVudCBlZGdlPGJyPlxuICogQ2xpcFxuICogXG4gKiBUaGUgbm9ybWFsIHBvaW50cyBmcm9tIDEgdG8gMlxuICovXG5mdW5jdGlvbiBDb2xsaWRlUG9seWdvbnMobWFuaWZvbGQsIHBvbHlBLCB4ZkEsIHBvbHlCLCB4ZkIpIHtcbiAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMDtcbiAgICB2YXIgdG90YWxSYWRpdXMgPSBwb2x5QS5tX3JhZGl1cyArIHBvbHlCLm1fcmFkaXVzO1xuICAgIEZpbmRNYXhTZXBhcmF0aW9uKHBvbHlBLCB4ZkEsIHBvbHlCLCB4ZkIpO1xuICAgIHZhciBlZGdlQSA9IGZtc19iZXN0SW5kZXg7XG4gICAgdmFyIHNlcGFyYXRpb25BID0gZm1zX21heFNlcGFyYXRpb247XG4gICAgaWYgKHNlcGFyYXRpb25BID4gdG90YWxSYWRpdXMpIHJldHVybjtcbiAgICBGaW5kTWF4U2VwYXJhdGlvbihwb2x5QiwgeGZCLCBwb2x5QSwgeGZBKTtcbiAgICB2YXIgZWRnZUIgPSBmbXNfYmVzdEluZGV4O1xuICAgIHZhciBzZXBhcmF0aW9uQiA9IGZtc19tYXhTZXBhcmF0aW9uO1xuICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKSByZXR1cm47XG4gICAgdmFyIHBvbHkxO1xuICAgIC8vIHJlZmVyZW5jZSBwb2x5Z29uXG4gICAgdmFyIHBvbHkyO1xuICAgIC8vIGluY2lkZW50IHBvbHlnb25cbiAgICB2YXIgeGYxO1xuICAgIHZhciB4ZjI7XG4gICAgdmFyIGVkZ2UxO1xuICAgIC8vIHJlZmVyZW5jZSBlZGdlXG4gICAgdmFyIGZsaXA7XG4gICAgdmFyIGtfdG9sID0gLjEgKiBTZXR0aW5ncy5saW5lYXJTbG9wO1xuICAgIGlmIChzZXBhcmF0aW9uQiA+IHNlcGFyYXRpb25BICsga190b2wpIHtcbiAgICAgICAgcG9seTEgPSBwb2x5QjtcbiAgICAgICAgcG9seTIgPSBwb2x5QTtcbiAgICAgICAgeGYxID0geGZCO1xuICAgICAgICB4ZjIgPSB4ZkE7XG4gICAgICAgIGVkZ2UxID0gZWRnZUI7XG4gICAgICAgIG1hbmlmb2xkLnR5cGUgPSBNYW5pZm9sZC5lX2ZhY2VCO1xuICAgICAgICBmbGlwID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwb2x5MSA9IHBvbHlBO1xuICAgICAgICBwb2x5MiA9IHBvbHlCO1xuICAgICAgICB4ZjEgPSB4ZkE7XG4gICAgICAgIHhmMiA9IHhmQjtcbiAgICAgICAgZWRnZTEgPSBlZGdlQTtcbiAgICAgICAgbWFuaWZvbGQudHlwZSA9IE1hbmlmb2xkLmVfZmFjZUE7XG4gICAgICAgIGZsaXAgPSAwO1xuICAgIH1cbiAgICB2YXIgaW5jaWRlbnRFZGdlID0gY3BnX2luY2lkZW50RWRnZTtcbiAgICBjcGdfaW5jaWRlbnRFZGdlWzBdLmluaXQoKTtcbiAgICBjcGdfaW5jaWRlbnRFZGdlWzFdLmluaXQoKTtcbiAgICBGaW5kSW5jaWRlbnRFZGdlKGluY2lkZW50RWRnZSwgcG9seTEsIHhmMSwgZWRnZTEsIHBvbHkyLCB4ZjIpO1xuICAgIHZhciBjb3VudDEgPSBwb2x5MS5tX2NvdW50O1xuICAgIHZhciB2ZXJ0aWNlczEgPSBwb2x5MS5tX3ZlcnRpY2VzO1xuICAgIHZhciBpdjEgPSBlZGdlMTtcbiAgICB2YXIgaXYyID0gZWRnZTEgKyAxIDwgY291bnQxID8gZWRnZTEgKyAxIDogMDtcbiAgICB2YXIgdjExID0gY3BnX3YxMS5zZXQodmVydGljZXMxW2l2MV0pO1xuICAgIHZhciB2MTIgPSBjcGdfdjEyLnNldCh2ZXJ0aWNlczFbaXYyXSk7XG4gICAgdmFyIGxvY2FsVGFuZ2VudCA9IFZlYzIuc3ViXyh2MTIsIHYxMSwgY3BnX2xvY2FsVGFuZ2VudCk7XG4gICAgbG9jYWxUYW5nZW50Lm5vcm1hbGl6ZSgpO1xuICAgIHZhciBsb2NhbE5vcm1hbCA9IFZlYzIuY3Jvc3NWZWMyTnVtXyhsb2NhbFRhbmdlbnQsIDEsIGNwZ19sb2NhbE5vcm1hbCk7XG4gICAgdmFyIHBsYW5lUG9pbnQgPSBWZWMyLmNvbWJpbmVfKC41LCB2MTEsIC41LCB2MTIsIGNwZ19wbGFuZVBvaW50KTtcbiAgICB2YXIgdGFuZ2VudCA9IFJvdC5tdWxWZWMyXyh4ZjEucSwgbG9jYWxUYW5nZW50LCBjcGdfdGFuZ2VudCk7XG4gICAgdmFyIG5vcm1hbCA9IFZlYzIuY3Jvc3NWZWMyTnVtXyh0YW5nZW50LCAxLCBjcGdfbm9ybWFsKTtcbiAgICB2MTEgPSBUcmFuc2Zvcm0ubXVsVmVjMl8oeGYxLCB2MTEsIHYxMSk7XG4gICAgdjEyID0gVHJhbnNmb3JtLm11bFZlYzJfKHhmMSwgdjEyLCB2MTIpO1xuICAgIC8vIEZhY2Ugb2Zmc2V0LlxuICAgIHZhciBmcm9udE9mZnNldCA9IFZlYzIuZG90KG5vcm1hbCwgdjExKTtcbiAgICAvLyBTaWRlIG9mZnNldHMsIGV4dGVuZGVkIGJ5IHBvbHl0b3BlIHNraW4gdGhpY2tuZXNzLlxuICAgIHZhciBzaWRlT2Zmc2V0MSA9IC1WZWMyLmRvdCh0YW5nZW50LCB2MTEpICsgdG90YWxSYWRpdXM7XG4gICAgdmFyIHNpZGVPZmZzZXQyID0gVmVjMi5kb3QodGFuZ2VudCwgdjEyKSArIHRvdGFsUmFkaXVzO1xuICAgIC8vIENsaXAgaW5jaWRlbnQgZWRnZSBhZ2FpbnN0IGV4dHJ1ZGVkIGVkZ2UxIHNpZGUgZWRnZXMuXG4gICAgY3BnX2NsaXBQb2ludHMxWzBdLmluaXQoKTtcbiAgICBjcGdfY2xpcFBvaW50czFbMV0uaW5pdCgpO1xuICAgIGNwZ19jbGlwUG9pbnRzMlswXS5pbml0KCk7XG4gICAgY3BnX2NsaXBQb2ludHMyWzFdLmluaXQoKTtcbiAgICB2YXIgY2xpcFBvaW50czEgPSBjcGdfY2xpcFBvaW50czE7XG4gICAgdmFyIGNsaXBQb2ludHMyID0gY3BnX2NsaXBQb2ludHMyO1xuICAgIHZhciBucDtcbiAgICAvLyBDbGlwIHRvIGJveCBzaWRlIDFcbiAgICBucCA9IE1hbmlmb2xkLmNsaXBTZWdtZW50VG9MaW5lKGNsaXBQb2ludHMxLCBpbmNpZGVudEVkZ2UsIFZlYzIubmVnXyh0YW5nZW50LCBjcGdfdDEpLCBzaWRlT2Zmc2V0MSwgaXYxKTtcbiAgICBpZiAobnAgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENsaXAgdG8gbmVnYXRpdmUgYm94IHNpZGUgMVxuICAgIG5wID0gTWFuaWZvbGQuY2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czIsIGNsaXBQb2ludHMxLCB0YW5nZW50LCBzaWRlT2Zmc2V0MiwgaXYyKTtcbiAgICBpZiAobnAgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5vdyBjbGlwUG9pbnRzMiBjb250YWlucyB0aGUgY2xpcHBlZCBwb2ludHMuXG4gICAgbWFuaWZvbGQubG9jYWxOb3JtYWwuc2V0KGxvY2FsTm9ybWFsKTtcbiAgICBtYW5pZm9sZC5sb2NhbFBvaW50LnNldChwbGFuZVBvaW50KTtcbiAgICB2YXIgcG9pbnRDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTZXR0aW5ncy5tYXhNYW5pZm9sZFBvaW50czsgKytpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0aW9uID0gVmVjMi5kb3Qobm9ybWFsLCBjbGlwUG9pbnRzMltpXS52KSAtIGZyb250T2Zmc2V0O1xuICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cykge1xuICAgICAgICAgICAgdmFyIGNwID0gbWFuaWZvbGQucG9pbnRzW2ldO1xuICAgICAgICAgICAgLy8gTWFuaWZvbGRQb2ludFxuICAgICAgICAgICAgY3AuaW5pdCgpO1xuICAgICAgICAgICAgY3AubG9jYWxQb2ludC5zZXQoVHJhbnNmb3JtLm11bFRWZWMyKHhmMiwgY2xpcFBvaW50czJbaV0udiwgY3BnX3QxKSk7XG4gICAgICAgICAgICBjcC5pZC5zZXQoY2xpcFBvaW50czJbaV0uaWQpO1xuICAgICAgICAgICAgaWYgKGZsaXApIHtcbiAgICAgICAgICAgICAgICAvLyBTd2FwIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgdmFyIGNmID0gY3AuaWQuY2Y7XG4gICAgICAgICAgICAgICAgLy8gQ29udGFjdEZlYXR1cmVcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBID0gY2YuaW5kZXhBO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEIgPSBjZi5pbmRleEI7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVBID0gY2YudHlwZUE7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVCID0gY2YudHlwZUI7XG4gICAgICAgICAgICAgICAgY2YuaW5kZXhBID0gaW5kZXhCO1xuICAgICAgICAgICAgICAgIGNmLmluZGV4QiA9IGluZGV4QTtcbiAgICAgICAgICAgICAgICBjZi50eXBlQSA9IHR5cGVCO1xuICAgICAgICAgICAgICAgIGNmLnR5cGVCID0gdHlwZUE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3BvaW50Q291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG59XG5cblxufSx7XCIuLi9Db250YWN0XCI6MyxcIi4uL01hbmlmb2xkXCI6NixcIi4uL1NldHRpbmdzXCI6NyxcIi4uL2NvbW1vbi9Sb3RcIjoyMCxcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIjoyMixcIi4uL2NvbW1vbi9WZWMyXCI6MjMsXCIuLi91dGlsL2NvbW1vblwiOjUwLFwiLi9Qb2x5Z29uU2hhcGVcIjo0N31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBFZGdlU2hhcGU7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4uL1NldHRpbmdzXCIpO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKFwiLi4vU2hhcGVcIik7XG5cbnZhciBNYXRoID0gcmVxdWlyZShcIi4uL2NvbW1vbi9NYXRoXCIpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcIi4uL2NvbW1vbi9UcmFuc2Zvcm1cIik7XG5cbnZhciBSb3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL1JvdFwiKTtcblxudmFyIFZlYzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL1ZlYzJcIik7XG5cbnZhciBBQUJCID0gcmVxdWlyZShcIi4uL2NvbGxpc2lvbi9BQUJCXCIpO1xuXG5FZGdlU2hhcGUuX3N1cGVyID0gU2hhcGU7XG5cbkVkZ2VTaGFwZS5wcm90b3R5cGUgPSBjcmVhdGUoRWRnZVNoYXBlLl9zdXBlci5wcm90b3R5cGUpO1xuXG5FZGdlU2hhcGUuVFlQRSA9IFwiZWRnZVwiO1xuXG4vKipcbiAqIEEgbGluZSBzZWdtZW50IChlZGdlKSBzaGFwZS4gVGhlc2UgY2FuIGJlIGNvbm5lY3RlZCBpbiBjaGFpbnMgb3IgbG9vcHMgdG9cbiAqIG90aGVyIGVkZ2Ugc2hhcGVzLiBUaGUgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5zdXJlIGNvcnJlY3RcbiAqIGNvbnRhY3Qgbm9ybWFscy5cbiAqL1xuZnVuY3Rpb24gRWRnZVNoYXBlKHYxLCB2Mikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFZGdlU2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWRnZVNoYXBlKHYxLCB2Mik7XG4gICAgfVxuICAgIEVkZ2VTaGFwZS5fc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1fdHlwZSA9IEVkZ2VTaGFwZS5UWVBFO1xuICAgIHRoaXMubV9yYWRpdXMgPSBTZXR0aW5ncy5wb2x5Z29uUmFkaXVzO1xuICAgIC8vIFRoZXNlIGFyZSB0aGUgZWRnZSB2ZXJ0aWNlc1xuICAgIHRoaXMubV92ZXJ0ZXgxID0gdjEgPyBWZWMyLmNsb25lKHYxKSA6IFZlYzIuemVybygpO1xuICAgIHRoaXMubV92ZXJ0ZXgyID0gdjIgPyBWZWMyLmNsb25lKHYyKSA6IFZlYzIuemVybygpO1xuICAgIC8vIE9wdGlvbmFsIGFkamFjZW50IHZlcnRpY2VzLiBUaGVzZSBhcmUgdXNlZCBmb3Igc21vb3RoIGNvbGxpc2lvbi5cbiAgICAvLyBVc2VkIGJ5IGNoYWluIHNoYXBlLlxuICAgIHRoaXMubV92ZXJ0ZXgwID0gVmVjMi56ZXJvKCk7XG4gICAgdGhpcy5tX3ZlcnRleDMgPSBWZWMyLnplcm8oKTtcbiAgICB0aGlzLm1faGFzVmVydGV4MCA9IGZhbHNlO1xuICAgIHRoaXMubV9oYXNWZXJ0ZXgzID0gZmFsc2U7XG59XG5cbkVkZ2VTaGFwZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uKHYzKSB7XG4gICAgaWYgKHYzKSB7XG4gICAgICAgIHRoaXMubV92ZXJ0ZXgzLnNldCh2Myk7XG4gICAgICAgIHRoaXMubV9oYXNWZXJ0ZXgzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1fdmVydGV4My5zZXRaZXJvKCk7XG4gICAgICAgIHRoaXMubV9oYXNWZXJ0ZXgzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuRWRnZVNoYXBlLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24odjApIHtcbiAgICBpZiAodjApIHtcbiAgICAgICAgdGhpcy5tX3ZlcnRleDAuc2V0KHYwKTtcbiAgICAgICAgdGhpcy5tX2hhc1ZlcnRleDAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubV92ZXJ0ZXgwLnNldFplcm8oKTtcbiAgICAgICAgdGhpcy5tX2hhc1ZlcnRleDAgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGlzIGFzIGFuIGlzb2xhdGVkIGVkZ2UuXG4gKi9cbkVkZ2VTaGFwZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgIHRoaXMubV92ZXJ0ZXgxLnNldCh2MSk7XG4gICAgdGhpcy5tX3ZlcnRleDIuc2V0KHYyKTtcbiAgICB0aGlzLm1faGFzVmVydGV4MCA9IGZhbHNlO1xuICAgIHRoaXMubV9oYXNWZXJ0ZXgzID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbkVkZ2VTaGFwZS5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IEVkZ2VTaGFwZSgpO1xuICAgIGNsb25lLm1fdHlwZSA9IHRoaXMubV90eXBlO1xuICAgIGNsb25lLm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICBjbG9uZS5tX3ZlcnRleDEuc2V0KHRoaXMubV92ZXJ0ZXgxKTtcbiAgICBjbG9uZS5tX3ZlcnRleDIuc2V0KHRoaXMubV92ZXJ0ZXgyKTtcbiAgICBjbG9uZS5tX3ZlcnRleDAuc2V0KHRoaXMubV92ZXJ0ZXgwKTtcbiAgICBjbG9uZS5tX3ZlcnRleDMuc2V0KHRoaXMubV92ZXJ0ZXgzKTtcbiAgICBjbG9uZS5tX2hhc1ZlcnRleDAgPSB0aGlzLm1faGFzVmVydGV4MDtcbiAgICBjbG9uZS5tX2hhc1ZlcnRleDMgPSB0aGlzLm1faGFzVmVydGV4MztcbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG5FZGdlU2hhcGUucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTtcbn07XG5cbkVkZ2VTaGFwZS5wcm90b3R5cGUudGVzdFBvaW50ID0gZnVuY3Rpb24oeGYsIHApIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBwID0gcDEgKyB0ICogZFxuLy8gdiA9IHYxICsgcyAqIGVcbi8vIHAxICsgdCAqIGQgPSB2MSArIHMgKiBlXG4vLyBzICogZSAtIHQgKiBkID0gcDEgLSB2MVxuRWRnZVNoYXBlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24ob3V0cHV0LCBpbnB1dCwgeGYsIGNoaWxkSW5kZXgpIHtcbiAgICAvLyBOT1RfVVNFRChjaGlsZEluZGV4KTtcbiAgICAvLyBQdXQgdGhlIHJheSBpbnRvIHRoZSBlZGdlJ3MgZnJhbWUgb2YgcmVmZXJlbmNlLlxuICAgIHZhciBwMSA9IFJvdC5tdWxUVmVjMih4Zi5xLCBWZWMyLnN1YihpbnB1dC5wMSwgeGYucCkpO1xuICAgIHZhciBwMiA9IFJvdC5tdWxUVmVjMih4Zi5xLCBWZWMyLnN1YihpbnB1dC5wMiwgeGYucCkpO1xuICAgIHZhciBkID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICB2YXIgdjEgPSB0aGlzLm1fdmVydGV4MTtcbiAgICB2YXIgdjIgPSB0aGlzLm1fdmVydGV4MjtcbiAgICB2YXIgZSA9IFZlYzIuc3ViKHYyLCB2MSk7XG4gICAgdmFyIG5vcm1hbCA9IFZlYzIubmVvKGUueSwgLWUueCk7XG4gICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgIC8vIHEgPSBwMSArIHQgKiBkXG4gICAgLy8gZG90KG5vcm1hbCwgcSAtIHYxKSA9IDBcbiAgICAvLyBkb3Qobm9ybWFsLCBwMSAtIHYxKSArIHQgKiBkb3Qobm9ybWFsLCBkKSA9IDBcbiAgICB2YXIgbnVtZXJhdG9yID0gVmVjMi5kb3Qobm9ybWFsLCBWZWMyLnN1Yih2MSwgcDEpKTtcbiAgICB2YXIgZGVub21pbmF0b3IgPSBWZWMyLmRvdChub3JtYWwsIGQpO1xuICAgIGlmIChkZW5vbWluYXRvciA9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHQgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICBpZiAodCA8IDAgfHwgaW5wdXQubWF4RnJhY3Rpb24gPCB0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHEgPSBWZWMyLmFkZChwMSwgVmVjMi5tdWwodCwgZCkpO1xuICAgIC8vIHEgPSB2MSArIHMgKiByXG4gICAgLy8gcyA9IGRvdChxIC0gdjEsIHIpIC8gZG90KHIsIHIpXG4gICAgdmFyIHIgPSBWZWMyLnN1Yih2MiwgdjEpO1xuICAgIHZhciByciA9IFZlYzIuZG90KHIsIHIpO1xuICAgIGlmIChyciA9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHMgPSBWZWMyLmRvdChWZWMyLnN1YihxLCB2MSksIHIpIC8gcnI7XG4gICAgaWYgKHMgPCAwIHx8IDEgPCBzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb3V0cHV0LmZyYWN0aW9uID0gdDtcbiAgICBpZiAobnVtZXJhdG9yID4gMCkge1xuICAgICAgICBvdXRwdXQubm9ybWFsID0gUm90Lm11bFZlYzIoeGYucSwgbm9ybWFsKS5uZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQubm9ybWFsID0gUm90Lm11bFZlYzIoeGYucSwgbm9ybWFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5FZGdlU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24oYWFiYiwgeGYsIGNoaWxkSW5kZXgpIHtcbiAgICB2YXIgdjEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5tX3ZlcnRleDEpO1xuICAgIHZhciB2MiA9IFRyYW5zZm9ybS5tdWxWZWMyKHhmLCB0aGlzLm1fdmVydGV4Mik7XG4gICAgYWFiYi5jb21iaW5lUG9pbnRzKHYxLCB2Mik7XG4gICAgYWFiYi5leHRlbmQodGhpcy5tX3JhZGl1cyk7XG59O1xuXG5FZGdlU2hhcGUucHJvdG90eXBlLmNvbXB1dGVNYXNzID0gZnVuY3Rpb24obWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICBtYXNzRGF0YS5tYXNzID0gMDtcbiAgICBtYXNzRGF0YS5jZW50ZXIuc2V0Q29tYmluZSguNSwgdGhpcy5tX3ZlcnRleDEsIC41LCB0aGlzLm1fdmVydGV4Mik7XG4gICAgbWFzc0RhdGEuSSA9IDA7XG59O1xuXG5FZGdlU2hhcGUucHJvdG90eXBlLmNvbXB1dGVEaXN0YW5jZVByb3h5ID0gZnVuY3Rpb24ocHJveHkpIHtcbiAgICBwcm94eS5tX3ZlcnRpY2VzLnB1c2godGhpcy5tX3ZlcnRleDEpO1xuICAgIHByb3h5Lm1fdmVydGljZXMucHVzaCh0aGlzLm1fdmVydGV4Mik7XG4gICAgcHJveHkubV9jb3VudCA9IDI7XG4gICAgcHJveHkubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xufTtcblxuXG59LHtcIi4uL1NldHRpbmdzXCI6NyxcIi4uL1NoYXBlXCI6OCxcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MTEsXCIuLi9jb21tb24vTWF0aFwiOjE4LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL3V0aWwvY3JlYXRlXCI6NTEsXCIuLi91dGlsL29wdGlvbnNcIjo1Mn1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBfREVCVUcgPSB0eXBlb2YgREVCVUcgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IERFQlVHO1xuXG52YXIgX0FTU0VSVCA9IHR5cGVvZiBBU1NFUlQgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IEFTU0VSVDtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uU2hhcGU7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vdXRpbC9jb21tb25cIik7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi4vdXRpbC9jcmVhdGVcIik7XG5cbnZhciBvcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvb3B0aW9uc1wiKTtcblxudmFyIE1hdGggPSByZXF1aXJlKFwiLi4vY29tbW9uL01hdGhcIik7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiKTtcblxudmFyIFJvdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vUm90XCIpO1xuXG52YXIgVmVjMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVmVjMlwiKTtcblxudmFyIEFBQkIgPSByZXF1aXJlKFwiLi4vY29sbGlzaW9uL0FBQkJcIik7XG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9TZXR0aW5nc1wiKTtcblxudmFyIFNoYXBlID0gcmVxdWlyZShcIi4uL1NoYXBlXCIpO1xuXG5Qb2x5Z29uU2hhcGUuX3N1cGVyID0gU2hhcGU7XG5cblBvbHlnb25TaGFwZS5wcm90b3R5cGUgPSBjcmVhdGUoUG9seWdvblNoYXBlLl9zdXBlci5wcm90b3R5cGUpO1xuXG5Qb2x5Z29uU2hhcGUuVFlQRSA9IFwicG9seWdvblwiO1xuXG4vKipcbiAqIEEgY29udmV4IHBvbHlnb24uIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgaW50ZXJpb3Igb2YgdGhlIHBvbHlnb24gaXMgdG8gdGhlXG4gKiBsZWZ0IG9mIGVhY2ggZWRnZS4gUG9seWdvbnMgaGF2ZSBhIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIGVxdWFsIHRvXG4gKiBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMuIEluIG1vc3QgY2FzZXMgeW91IHNob3VsZCBub3QgbmVlZCBtYW55IHZlcnRpY2VzXG4gKiBmb3IgYSBjb252ZXggcG9seWdvbi4gZXh0ZW5kcyBTaGFwZVxuICovXG5mdW5jdGlvbiBQb2x5Z29uU2hhcGUodmVydGljZXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9seWdvblNoYXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25TaGFwZSh2ZXJ0aWNlcyk7XG4gICAgfVxuICAgIFBvbHlnb25TaGFwZS5fc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1fdHlwZSA9IFBvbHlnb25TaGFwZS5UWVBFO1xuICAgIHRoaXMubV9yYWRpdXMgPSBTZXR0aW5ncy5wb2x5Z29uUmFkaXVzO1xuICAgIHRoaXMubV9jZW50cm9pZCA9IFZlYzIuemVybygpO1xuICAgIHRoaXMubV92ZXJ0aWNlcyA9IFtdO1xuICAgIC8vIFZlYzJbU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXVxuICAgIHRoaXMubV9ub3JtYWxzID0gW107XG4gICAgLy8gVmVjMltTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXNdXG4gICAgdGhpcy5tX2NvdW50ID0gMDtcbiAgICBpZiAodmVydGljZXMgJiYgdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3NldCh2ZXJ0aWNlcyk7XG4gICAgfVxufVxuXG5Qb2x5Z29uU2hhcGUucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gaW5kZXggJiYgaW5kZXggPCB0aGlzLm1fY291bnQpO1xuICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbaW5kZXhdO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5Qb2x5Z29uU2hhcGUucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBQb2x5Z29uU2hhcGUoKTtcbiAgICBjbG9uZS5tX3R5cGUgPSB0aGlzLm1fdHlwZTtcbiAgICBjbG9uZS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgY2xvbmUubV9jb3VudCA9IHRoaXMubV9jb3VudDtcbiAgICBjbG9uZS5tX2NlbnRyb2lkLnNldCh0aGlzLm1fY2VudHJvaWQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyBpKyspIHtcbiAgICAgICAgY2xvbmUubV92ZXJ0aWNlcy5wdXNoKHRoaXMubV92ZXJ0aWNlc1tpXS5jbG9uZSgpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fbm9ybWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZS5tX25vcm1hbHMucHVzaCh0aGlzLm1fbm9ybWFsc1tpXS5jbG9uZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxuUG9seWdvblNoYXBlLnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDE7XG59O1xuXG5mdW5jdGlvbiBDb21wdXRlQ2VudHJvaWQodnMsIGNvdW50KSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGNvdW50ID49IDMpO1xuICAgIHZhciBjID0gVmVjMi56ZXJvKCk7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIC8vIHBSZWYgaXMgdGhlIHJlZmVyZW5jZSBwb2ludCBmb3IgZm9ybWluZyB0cmlhbmdsZXMuXG4gICAgLy8gSXQncyBsb2NhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGUgcmVzdWx0IChleGNlcHQgZm9yIHJvdW5kaW5nIGVycm9yKS5cbiAgICB2YXIgcFJlZiA9IFZlYzIuemVybygpO1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgICAvLyBUaGlzIGNvZGUgd291bGQgcHV0IHRoZSByZWZlcmVuY2UgcG9pbnQgaW5zaWRlIHRoZSBwb2x5Z29uLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHBSZWYuYWRkKHZzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBwUmVmLm11bCgxIC8gY291bnQpO1xuICAgIH1cbiAgICB2YXIgaW52MyA9IDEgLyAzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAvLyBUcmlhbmdsZSB2ZXJ0aWNlcy5cbiAgICAgICAgdmFyIHAxID0gcFJlZjtcbiAgICAgICAgdmFyIHAyID0gdnNbaV07XG4gICAgICAgIHZhciBwMyA9IGkgKyAxIDwgY291bnQgPyB2c1tpICsgMV0gOiB2c1swXTtcbiAgICAgICAgdmFyIGUxID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICAgICAgdmFyIGUyID0gVmVjMi5zdWIocDMsIHAxKTtcbiAgICAgICAgdmFyIEQgPSBWZWMyLmNyb3NzKGUxLCBlMik7XG4gICAgICAgIHZhciB0cmlhbmdsZUFyZWEgPSAuNSAqIEQ7XG4gICAgICAgIGFyZWEgKz0gdHJpYW5nbGVBcmVhO1xuICAgICAgICAvLyBBcmVhIHdlaWdodGVkIGNlbnRyb2lkXG4gICAgICAgIGMuYWRkTXVsKHRyaWFuZ2xlQXJlYSAqIGludjMsIHAxKTtcbiAgICAgICAgYy5hZGRNdWwodHJpYW5nbGVBcmVhICogaW52MywgcDIpO1xuICAgICAgICBjLmFkZE11bCh0cmlhbmdsZUFyZWEgKiBpbnYzLCBwMyk7XG4gICAgfVxuICAgIC8vIENlbnRyb2lkXG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGFyZWEgPiBNYXRoLkVQU0lMT04pO1xuICAgIGMubXVsKDEgLyBhcmVhKTtcbiAgICByZXR1cm4gYztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIENyZWF0ZSBhIGNvbnZleCBodWxsIGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIGxvY2FsIHBvaW50cy4gVGhlIGNvdW50IG11c3QgYmVcbiAqIGluIHRoZSByYW5nZSBbMywgU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXS5cbiAqIFxuICogV2FybmluZzogdGhlIHBvaW50cyBtYXkgYmUgcmUtb3JkZXJlZCwgZXZlbiBpZiB0aGV5IGZvcm0gYSBjb252ZXggcG9seWdvblxuICogV2FybmluZzogY29sbGluZWFyIHBvaW50cyBhcmUgaGFuZGxlZCBidXQgbm90IHJlbW92ZWQuIENvbGxpbmVhciBwb2ludHMgbWF5XG4gKiBsZWFkIHRvIHBvb3Igc3RhY2tpbmcgYmVoYXZpb3IuXG4gKi9cblBvbHlnb25TaGFwZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDMgPD0gdmVydGljZXMubGVuZ3RoICYmIHZlcnRpY2VzLmxlbmd0aCA8PSBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMpO1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIHRoaXMuX3NldEFzQm94KDEsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuID0gTWF0aC5taW4odmVydGljZXMubGVuZ3RoLCBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMpO1xuICAgIC8vIFBlcmZvcm0gd2VsZGluZyBhbmQgY29weSB2ZXJ0aWNlcyBpbnRvIGxvY2FsIGJ1ZmZlci5cbiAgICB2YXIgcHMgPSBbXTtcbiAgICAvLyBbU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXTtcbiAgICB2YXIgdGVtcENvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xuICAgICAgICB2YXIgdW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZW1wQ291bnQ7ICsraikge1xuICAgICAgICAgICAgaWYgKFZlYzIuZGlzdGFuY2VTcXVhcmVkKHYsIHBzW2pdKSA8IC4yNSAqIFNldHRpbmdzLmxpbmVhclNsb3BTcXVhcmVkKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICAgICAgcHNbdGVtcENvdW50KytdID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuID0gdGVtcENvdW50O1xuICAgIGlmIChuIDwgMykge1xuICAgICAgICAvLyBQb2x5Z29uIGlzIGRlZ2VuZXJhdGUuXG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEFzQm94KDEsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSB0aGUgY29udmV4IGh1bGwgdXNpbmcgdGhlIEdpZnQgd3JhcHBpbmcgYWxnb3JpdGhtXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HaWZ0X3dyYXBwaW5nX2FsZ29yaXRobVxuICAgIC8vIEZpbmQgdGhlIHJpZ2h0IG1vc3QgcG9pbnQgb24gdGhlIGh1bGxcbiAgICB2YXIgaTAgPSAwO1xuICAgIHZhciB4MCA9IHBzWzBdLng7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIHggPSBwc1tpXS54O1xuICAgICAgICBpZiAoeCA+IHgwIHx8IHggPT0geDAgJiYgcHNbaV0ueSA8IHBzW2kwXS55KSB7XG4gICAgICAgICAgICBpMCA9IGk7XG4gICAgICAgICAgICB4MCA9IHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGh1bGwgPSBbXTtcbiAgICAvLyBbU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXTtcbiAgICB2YXIgbSA9IDA7XG4gICAgdmFyIGloID0gaTA7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBodWxsW21dID0gaWg7XG4gICAgICAgIHZhciBpZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBpZiAoaWUgPT0gaWgpIHtcbiAgICAgICAgICAgICAgICBpZSA9IGo7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IFZlYzIuc3ViKHBzW2llXSwgcHNbaHVsbFttXV0pO1xuICAgICAgICAgICAgdmFyIHYgPSBWZWMyLnN1Yihwc1tqXSwgcHNbaHVsbFttXV0pO1xuICAgICAgICAgICAgdmFyIGMgPSBWZWMyLmNyb3NzKHIsIHYpO1xuICAgICAgICAgICAgaWYgKGMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29sbGluZWFyaXR5IGNoZWNrXG4gICAgICAgICAgICBpZiAoYyA9PSAwICYmIHYubGVuZ3RoU3F1YXJlZCgpID4gci5sZW5ndGhTcXVhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKyttO1xuICAgICAgICBpaCA9IGllO1xuICAgICAgICBpZiAoaWUgPT0gaTApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtIDwgMykge1xuICAgICAgICAvLyBQb2x5Z29uIGlzIGRlZ2VuZXJhdGUuXG4gICAgICAgIF9BU1NFUlQgJiYgY29tbW9uLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEFzQm94KDEsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubV9jb3VudCA9IG07XG4gICAgLy8gQ29weSB2ZXJ0aWNlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSBwc1todWxsW2ldXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBub3JtYWxzLiBFbnN1cmUgdGhlIGVkZ2VzIGhhdmUgbm9uLXplcm8gbGVuZ3RoLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIHZhciBpMSA9IGk7XG4gICAgICAgIHZhciBpMiA9IGkgKyAxIDwgbSA/IGkgKyAxIDogMDtcbiAgICAgICAgdmFyIGVkZ2UgPSBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaTJdLCB0aGlzLm1fdmVydGljZXNbaTFdKTtcbiAgICAgICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGVkZ2UubGVuZ3RoU3F1YXJlZCgpID4gTWF0aC5FUFNJTE9OICogTWF0aC5FUFNJTE9OKTtcbiAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0gPSBWZWMyLmNyb3NzKGVkZ2UsIDEpO1xuICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXS5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgcG9seWdvbiBjZW50cm9pZC5cbiAgICB0aGlzLm1fY2VudHJvaWQgPSBDb21wdXRlQ2VudHJvaWQodGhpcy5tX3ZlcnRpY2VzLCBtKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuUG9seWdvblNoYXBlLnByb3RvdHlwZS5fc2V0QXNCb3ggPSBmdW5jdGlvbihoeCwgaHksIGNlbnRlciwgYW5nbGUpIHtcbiAgICB0aGlzLm1fdmVydGljZXNbMF0gPSBWZWMyLm5lbygtaHgsIC1oeSk7XG4gICAgdGhpcy5tX3ZlcnRpY2VzWzFdID0gVmVjMi5uZW8oaHgsIC1oeSk7XG4gICAgdGhpcy5tX3ZlcnRpY2VzWzJdID0gVmVjMi5uZW8oaHgsIGh5KTtcbiAgICB0aGlzLm1fdmVydGljZXNbM10gPSBWZWMyLm5lbygtaHgsIGh5KTtcbiAgICB0aGlzLm1fbm9ybWFsc1swXSA9IFZlYzIubmVvKDAsIC0xKTtcbiAgICB0aGlzLm1fbm9ybWFsc1sxXSA9IFZlYzIubmVvKDEsIDApO1xuICAgIHRoaXMubV9ub3JtYWxzWzJdID0gVmVjMi5uZW8oMCwgMSk7XG4gICAgdGhpcy5tX25vcm1hbHNbM10gPSBWZWMyLm5lbygtMSwgMCk7XG4gICAgdGhpcy5tX2NvdW50ID0gNDtcbiAgICBpZiAoVmVjMi5pc1ZhbGlkKGNlbnRlcikpIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICB0aGlzLm1fY2VudHJvaWQuc2V0KGNlbnRlcik7XG4gICAgICAgIHZhciB4ZiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICB4Zi5wLnNldChjZW50ZXIpO1xuICAgICAgICB4Zi5xLnNldChhbmdsZSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSB2ZXJ0aWNlcyBhbmQgbm9ybWFscy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXSA9IFJvdC5tdWxWZWMyKHhmLnEsIHRoaXMubV9ub3JtYWxzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBvbHlnb25TaGFwZS5wcm90b3R5cGUudGVzdFBvaW50ID0gZnVuY3Rpb24oeGYsIHApIHtcbiAgICB2YXIgcExvY2FsID0gUm90Lm11bFRWZWMyKHhmLnEsIFZlYzIuc3ViKHAsIHhmLnApKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBkb3QgPSBWZWMyLmRvdCh0aGlzLm1fbm9ybWFsc1tpXSwgVmVjMi5zdWIocExvY2FsLCB0aGlzLm1fdmVydGljZXNbaV0pKTtcbiAgICAgICAgaWYgKGRvdCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblBvbHlnb25TaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uKG91dHB1dCwgaW5wdXQsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgLy8gUHV0IHRoZSByYXkgaW50byB0aGUgcG9seWdvbidzIGZyYW1lIG9mIHJlZmVyZW5jZS5cbiAgICB2YXIgcDEgPSBSb3QubXVsVFZlYzIoeGYucSwgVmVjMi5zdWIoaW5wdXQucDEsIHhmLnApKTtcbiAgICB2YXIgcDIgPSBSb3QubXVsVFZlYzIoeGYucSwgVmVjMi5zdWIoaW5wdXQucDIsIHhmLnApKTtcbiAgICB2YXIgZCA9IFZlYzIuc3ViKHAyLCBwMSk7XG4gICAgdmFyIGxvd2VyID0gMDtcbiAgICB2YXIgdXBwZXIgPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgIC8vIHAgPSBwMSArIGEgKiBkXG4gICAgICAgIC8vIGRvdChub3JtYWwsIHAgLSB2KSA9IDBcbiAgICAgICAgLy8gZG90KG5vcm1hbCwgcDEgLSB2KSArIGEgKiBkb3Qobm9ybWFsLCBkKSA9IDBcbiAgICAgICAgdmFyIG51bWVyYXRvciA9IFZlYzIuZG90KHRoaXMubV9ub3JtYWxzW2ldLCBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaV0sIHAxKSk7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IFZlYzIuZG90KHRoaXMubV9ub3JtYWxzW2ldLCBkKTtcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID09IDApIHtcbiAgICAgICAgICAgIGlmIChudW1lcmF0b3IgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm90ZTogd2Ugd2FudCB0aGlzIHByZWRpY2F0ZSB3aXRob3V0IGRpdmlzaW9uOlxuICAgICAgICAgICAgLy8gbG93ZXIgPCBudW1lcmF0b3IgLyBkZW5vbWluYXRvciwgd2hlcmUgZGVub21pbmF0b3IgPCAwXG4gICAgICAgICAgICAvLyBTaW5jZSBkZW5vbWluYXRvciA8IDAsIHdlIGhhdmUgdG8gZmxpcCB0aGUgaW5lcXVhbGl0eTpcbiAgICAgICAgICAgIC8vIGxvd2VyIDwgbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgPD09PiBkZW5vbWluYXRvciAqIGxvd2VyID4gbnVtZXJhdG9yLlxuICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yIDwgMCAmJiBudW1lcmF0b3IgPCBsb3dlciAqIGRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgbG93ZXIuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgZW50ZXJzIHRoaXMgaGFsZi1zcGFjZS5cbiAgICAgICAgICAgICAgICBsb3dlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVub21pbmF0b3IgPiAwICYmIG51bWVyYXRvciA8IHVwcGVyICogZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWNyZWFzZSB1cHBlci5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBleGl0cyB0aGlzIGhhbGYtc3BhY2UuXG4gICAgICAgICAgICAgICAgdXBwZXIgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdXNlIG9mIGVwc2lsb24gaGVyZSBjYXVzZXMgdGhlIGFzc2VydCBvbiBsb3dlciB0byB0cmlwXG4gICAgICAgIC8vIGluIHNvbWUgY2FzZXMuIEFwcGFyZW50bHkgdGhlIHVzZSBvZiBlcHNpbG9uIHdhcyB0byBtYWtlIGVkZ2VcbiAgICAgICAgLy8gc2hhcGVzIHdvcmssIGJ1dCBub3cgdGhvc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseS5cbiAgICAgICAgLy8gaWYgKHVwcGVyIDwgbG93ZXIgLSBNYXRoLkVQU0lMT04pXG4gICAgICAgIGlmICh1cHBlciA8IGxvd2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KDAgPD0gbG93ZXIgJiYgbG93ZXIgPD0gaW5wdXQubWF4RnJhY3Rpb24pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIG91dHB1dC5mcmFjdGlvbiA9IGxvd2VyO1xuICAgICAgICBvdXRwdXQubm9ybWFsID0gUm90Lm11bFZlYzIoeGYucSwgdGhpcy5tX25vcm1hbHNbaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblBvbHlnb25TaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihhYWJiLCB4ZiwgY2hpbGRJbmRleCkge1xuICAgIHZhciBtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgIHZhciB2ID0gVHJhbnNmb3JtLm11bFZlYzIoeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB2LngpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgdi54KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHYueSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB2LnkpO1xuICAgIH1cbiAgICBhYWJiLmxvd2VyQm91bmQuc2V0KG1pblgsIG1pblkpO1xuICAgIGFhYmIudXBwZXJCb3VuZC5zZXQobWF4WCwgbWF4WSk7XG4gICAgYWFiYi5leHRlbmQodGhpcy5tX3JhZGl1cyk7XG59O1xuXG5Qb2x5Z29uU2hhcGUucHJvdG90eXBlLmNvbXB1dGVNYXNzID0gZnVuY3Rpb24obWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAvLyBQb2x5Z29uIG1hc3MsIGNlbnRyb2lkLCBhbmQgaW5lcnRpYS5cbiAgICAvLyBMZXQgcmhvIGJlIHRoZSBwb2x5Z29uIGRlbnNpdHkgaW4gbWFzcyBwZXIgdW5pdCBhcmVhLlxuICAgIC8vIFRoZW46XG4gICAgLy8gbWFzcyA9IHJobyAqIGludChkQSlcbiAgICAvLyBjZW50cm9pZC54ID0gKDEvbWFzcykgKiByaG8gKiBpbnQoeCAqIGRBKVxuICAgIC8vIGNlbnRyb2lkLnkgPSAoMS9tYXNzKSAqIHJobyAqIGludCh5ICogZEEpXG4gICAgLy8gSSA9IHJobyAqIGludCgoeCp4ICsgeSp5KSAqIGRBKVxuICAgIC8vXG4gICAgLy8gV2UgY2FuIGNvbXB1dGUgdGhlc2UgaW50ZWdyYWxzIGJ5IHN1bW1pbmcgYWxsIHRoZSBpbnRlZ3JhbHNcbiAgICAvLyBmb3IgZWFjaCB0cmlhbmdsZSBvZiB0aGUgcG9seWdvbi4gVG8gZXZhbHVhdGUgdGhlIGludGVncmFsXG4gICAgLy8gZm9yIGEgc2luZ2xlIHRyaWFuZ2xlLCB3ZSBtYWtlIGEgY2hhbmdlIG9mIHZhcmlhYmxlcyB0b1xuICAgIC8vIHRoZSAodSx2KSBjb29yZGluYXRlcyBvZiB0aGUgdHJpYW5nbGU6XG4gICAgLy8geCA9IHgwICsgZTF4ICogdSArIGUyeCAqIHZcbiAgICAvLyB5ID0geTAgKyBlMXkgKiB1ICsgZTJ5ICogdlxuICAgIC8vIHdoZXJlIDAgPD0gdSAmJiAwIDw9IHYgJiYgdSArIHYgPD0gMS5cbiAgICAvL1xuICAgIC8vIFdlIGludGVncmF0ZSB1IGZyb20gWzAsMS12XSBhbmQgdGhlbiB2IGZyb20gWzAsMV0uXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHVzZSB0aGUgSmFjb2JpYW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uOlxuICAgIC8vIEQgPSBjcm9zcyhlMSwgZTIpXG4gICAgLy9cbiAgICAvLyBTaW1wbGlmaWNhdGlvbjogdHJpYW5nbGUgY2VudHJvaWQgPSAoMS8zKSAqIChwMSArIHAyICsgcDMpXG4gICAgLy9cbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgZGVyaXZhdGlvbiBpcyBoYW5kbGVkIGJ5IGNvbXB1dGVyIGFsZ2VicmEuXG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KHRoaXMubV9jb3VudCA+PSAzKTtcbiAgICB2YXIgY2VudGVyID0gVmVjMi56ZXJvKCk7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIHZhciBJID0gMDtcbiAgICAvLyBzIGlzIHRoZSByZWZlcmVuY2UgcG9pbnQgZm9yIGZvcm1pbmcgdHJpYW5nbGVzLlxuICAgIC8vIEl0J3MgbG9jYXRpb24gZG9lc24ndCBjaGFuZ2UgdGhlIHJlc3VsdCAoZXhjZXB0IGZvciByb3VuZGluZyBlcnJvcikuXG4gICAgdmFyIHMgPSBWZWMyLnplcm8oKTtcbiAgICAvLyBUaGlzIGNvZGUgd291bGQgcHV0IHRoZSByZWZlcmVuY2UgcG9pbnQgaW5zaWRlIHRoZSBwb2x5Z29uLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgcy5hZGQodGhpcy5tX3ZlcnRpY2VzW2ldKTtcbiAgICB9XG4gICAgcy5tdWwoMSAvIHRoaXMubV9jb3VudCk7XG4gICAgdmFyIGtfaW52MyA9IDEgLyAzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgLy8gVHJpYW5nbGUgdmVydGljZXMuXG4gICAgICAgIHZhciBlMSA9IFZlYzIuc3ViKHRoaXMubV92ZXJ0aWNlc1tpXSwgcyk7XG4gICAgICAgIHZhciBlMiA9IGkgKyAxIDwgdGhpcy5tX2NvdW50ID8gVmVjMi5zdWIodGhpcy5tX3ZlcnRpY2VzW2kgKyAxXSwgcykgOiBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbMF0sIHMpO1xuICAgICAgICB2YXIgRCA9IFZlYzIuY3Jvc3MoZTEsIGUyKTtcbiAgICAgICAgdmFyIHRyaWFuZ2xlQXJlYSA9IC41ICogRDtcbiAgICAgICAgYXJlYSArPSB0cmlhbmdsZUFyZWE7XG4gICAgICAgIC8vIEFyZWEgd2VpZ2h0ZWQgY2VudHJvaWRcbiAgICAgICAgY2VudGVyLmFkZENvbWJpbmUodHJpYW5nbGVBcmVhICoga19pbnYzLCBlMSwgdHJpYW5nbGVBcmVhICoga19pbnYzLCBlMik7XG4gICAgICAgIHZhciBleDEgPSBlMS54O1xuICAgICAgICB2YXIgZXkxID0gZTEueTtcbiAgICAgICAgdmFyIGV4MiA9IGUyLng7XG4gICAgICAgIHZhciBleTIgPSBlMi55O1xuICAgICAgICB2YXIgaW50eDIgPSBleDEgKiBleDEgKyBleDIgKiBleDEgKyBleDIgKiBleDI7XG4gICAgICAgIHZhciBpbnR5MiA9IGV5MSAqIGV5MSArIGV5MiAqIGV5MSArIGV5MiAqIGV5MjtcbiAgICAgICAgSSArPSAuMjUgKiBrX2ludjMgKiBEICogKGludHgyICsgaW50eTIpO1xuICAgIH1cbiAgICAvLyBUb3RhbCBtYXNzXG4gICAgbWFzc0RhdGEubWFzcyA9IGRlbnNpdHkgKiBhcmVhO1xuICAgIC8vIENlbnRlciBvZiBtYXNzXG4gICAgX0FTU0VSVCAmJiBjb21tb24uYXNzZXJ0KGFyZWEgPiBNYXRoLkVQU0lMT04pO1xuICAgIGNlbnRlci5tdWwoMSAvIGFyZWEpO1xuICAgIG1hc3NEYXRhLmNlbnRlci5zZXRDb21iaW5lKDEsIGNlbnRlciwgMSwgcyk7XG4gICAgLy8gSW5lcnRpYSB0ZW5zb3IgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIG9yaWdpbiAocG9pbnQgcykuXG4gICAgbWFzc0RhdGEuSSA9IGRlbnNpdHkgKiBJO1xuICAgIC8vIFNoaWZ0IHRvIGNlbnRlciBvZiBtYXNzIHRoZW4gdG8gb3JpZ2luYWwgYm9keSBvcmlnaW4uXG4gICAgbWFzc0RhdGEuSSArPSBtYXNzRGF0YS5tYXNzICogKFZlYzIuZG90KG1hc3NEYXRhLmNlbnRlciwgbWFzc0RhdGEuY2VudGVyKSAtIFZlYzIuZG90KGNlbnRlciwgY2VudGVyKSk7XG59O1xuXG4vLyBWYWxpZGF0ZSBjb252ZXhpdHkuIFRoaXMgaXMgYSB2ZXJ5IHRpbWUgY29uc3VtaW5nIG9wZXJhdGlvbi5cbi8vIEByZXR1cm5zIHRydWUgaWYgdmFsaWRcblBvbHlnb25TaGFwZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBpMSA9IGk7XG4gICAgICAgIHZhciBpMiA9IGkgPCB0aGlzLm1fY291bnQgLSAxID8gaTEgKyAxIDogMDtcbiAgICAgICAgdmFyIHAgPSB0aGlzLm1fdmVydGljZXNbaTFdO1xuICAgICAgICB2YXIgZSA9IFZlYzIuc3ViKHRoaXMubV92ZXJ0aWNlc1tpMl0sIHApO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb3VudDsgKytqKSB7XG4gICAgICAgICAgICBpZiAoaiA9PSBpMSB8fCBqID09IGkyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdiA9IFZlYzIuc3ViKHRoaXMubV92ZXJ0aWNlc1tqXSwgcCk7XG4gICAgICAgICAgICB2YXIgYyA9IFZlYzIuY3Jvc3MoZSwgdik7XG4gICAgICAgICAgICBpZiAoYyA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qb2x5Z29uU2hhcGUucHJvdG90eXBlLmNvbXB1dGVEaXN0YW5jZVByb3h5ID0gZnVuY3Rpb24ocHJveHkpIHtcbiAgICBwcm94eS5tX3ZlcnRpY2VzID0gdGhpcy5tX3ZlcnRpY2VzO1xuICAgIHByb3h5Lm1fY291bnQgPSB0aGlzLm1fY291bnQ7XG4gICAgcHJveHkubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xufTtcblxuXG59LHtcIi4uL1NldHRpbmdzXCI6NyxcIi4uL1NoYXBlXCI6OCxcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MTEsXCIuLi9jb21tb24vTWF0aFwiOjE4LFwiLi4vY29tbW9uL1JvdFwiOjIwLFwiLi4vY29tbW9uL1RyYW5zZm9ybVwiOjIyLFwiLi4vY29tbW9uL1ZlYzJcIjoyMyxcIi4uL3V0aWwvY29tbW9uXCI6NTAsXCIuLi91dGlsL2NyZWF0ZVwiOjUxLFwiLi4vdXRpbC9vcHRpb25zXCI6NTJ9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbDtcblxuZnVuY3Rpb24gUG9vbChvcHRzKSB7XG4gICAgdmFyIF9xdWV1ZSA9IFtdO1xuICAgIHZhciBfbWF4ID0gb3B0cy5tYXggfHwgSW5maW5pdHk7XG4gICAgdmFyIF9jcmVhdGVGbiA9IG9wdHMuY3JlYXRlIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfTtcbiAgICB2YXIgX291dEZuID0gb3B0cy5hbGxvY2F0ZSB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHZhciBfaW5GbiA9IG9wdHMucmVsZWFzZSB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHZhciBfZGlzY2FyZEZuID0gb3B0cy5kaXNjYXJkIHx8IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIF9jcmVhdGVDb3VudCA9IDA7XG4gICAgdmFyIF9vdXRDb3VudCA9IDA7XG4gICAgdmFyIF9pbkNvdW50ID0gMDtcbiAgICB2YXIgX2Rpc2NhcmRDb3VudCA9IDA7XG4gICAgdGhpcy5tYXggPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgX21heCA9IG47XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX21heDtcbiAgICB9O1xuICAgIHRoaXMuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3F1ZXVlLmxlbmd0aDtcbiAgICB9O1xuICAgIHRoaXMuYWxsb2NhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgaWYgKF9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvYmogPSBfcXVldWUuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9jcmVhdGVDb3VudCsrO1xuICAgICAgICAgICAgb2JqID0gX2NyZWF0ZUZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgX291dENvdW50Kys7XG4gICAgICAgIF9vdXRGbihvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdGhpcy5yZWxlYXNlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChfcXVldWUubGVuZ3RoIDwgX21heCkge1xuICAgICAgICAgICAgX2luQ291bnQrKztcbiAgICAgICAgICAgIF9pbkZuKG9iaik7XG4gICAgICAgICAgICBfcXVldWUucHVzaChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2Rpc2NhcmRDb3VudCsrO1xuICAgICAgICAgICAgX2Rpc2NhcmRGbihvYmopO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIiArXCIgKyBfY3JlYXRlQ291bnQgKyBcIiA+XCIgKyBfb3V0Q291bnQgKyBcIiA8XCIgKyBfaW5Db3VudCArIFwiIC1cIiArIF9kaXNjYXJkQ291bnQgKyBcIiA9XCIgKyBfcXVldWUubGVuZ3RoICsgXCIvXCIgKyBfbWF4O1xuICAgIH07XG59XG5cblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIF9ERUJVRyA9IHR5cGVvZiBERUJVRyA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogREVCVUc7XG5cbnZhciBfQVNTRVJUID0gdHlwZW9mIEFTU0VSVCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogQVNTRVJUO1xuXG5tb2R1bGUuZXhwb3J0cy5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRpZmYgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aW1lO1xufTtcblxuXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbmV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIV9ERUJVRykgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59O1xuXG5leHBvcnRzLmFzc2VydCA9IGZ1bmN0aW9uKHN0YXRlbWVudCwgZXJyLCBsb2cpIHtcbiAgICBpZiAoIV9BU1NFUlQpIHJldHVybjtcbiAgICBpZiAoc3RhdGVtZW50KSByZXR1cm47XG4gICAgbG9nICYmIGNvbnNvbGUubG9nKGxvZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG59O1xuXG5cbn0se31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvLCBwcm9wcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZS5jYWxsKE9iamVjdCwgcHJvdG8sIHByb3BzKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvLCBwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHRocm93IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQhXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvICE9PSBcIm9iamVjdFwiIHx8IHByb3RvID09PSBudWxsKSB0aHJvdyBFcnJvcihcIkludmFsaWQgcHJvdG90eXBlIVwiKTtcbiAgICAgICAgbm9vcC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgcmV0dXJuIG5ldyBub29wKCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBub29wKCkge31cbn1cblxuXG59LHt9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgX0RFQlVHID0gdHlwZW9mIERFQlVHID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBERUJVRztcblxudmFyIF9BU1NFUlQgPSB0eXBlb2YgQVNTRVJUID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBBU1NFUlQ7XG5cbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0bywgZnJvbSkge1xuICAgIGlmICh0byA9PT0gbnVsbCB8fCB0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdG8gPSB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgdG9ba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgICAgICBpZiAoZnJvbS5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpICYmIHR5cGVvZiB0b1trZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdG9bc3ltYm9sXSA9IGZyb21bc3ltYm9sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG59O1xuXG5cbn0se31dfSx7fSxbMV0pKDEpXG59KTsiXSwibmFtZXMiOlsiZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJmIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsInBsYW5jayIsInQiLCJuIiwiciIsInMiLCJvIiwidSIsImEiLCJyZXF1aXJlIiwiaSIsIkVycm9yIiwiY29kZSIsImwiLCJjYWxsIiwibGVuZ3RoIiwiaW50ZXJuYWwiLCJNYXRoIiwiVmVjMiIsIlZlYzMiLCJNYXQyMiIsIk1hdDMzIiwiVHJhbnNmb3JtIiwiUm90IiwiQUFCQiIsIlNoYXBlIiwiRml4dHVyZSIsIkJvZHkiLCJDb250YWN0IiwiSm9pbnQiLCJXb3JsZCIsIkNpcmNsZSIsIkVkZ2UiLCJQb2x5Z29uIiwiQ2hhaW4iLCJCb3giLCJDb2xsaWRlUG9seWdvbnMiLCJEaXN0YW5jZUpvaW50IiwiRnJpY3Rpb25Kb2ludCIsIkdlYXJKb2ludCIsIk1vdG9ySm9pbnQiLCJNb3VzZUpvaW50IiwiUHJpc21hdGljSm9pbnQiLCJQdWxsZXlKb2ludCIsIlJldm9sdXRlSm9pbnQiLCJSb3BlSm9pbnQiLCJXZWxkSm9pbnQiLCJXaGVlbEpvaW50IiwiU3dlZXAiLCJzdGF0cyIsIk1hbmlmb2xkIiwiRGlzdGFuY2UiLCJUaW1lT2ZJbXBhY3QiLCJEeW5hbWljVHJlZSIsIlNldHRpbmdzIiwiX0RFQlVHIiwiREVCVUciLCJfQVNTRVJUIiwiQVNTRVJUIiwiY29tbW9uIiwib3B0aW9ucyIsIlZlbG9jaXR5IiwiUG9zaXRpb24iLCJzdGF0aWNCb2R5IiwiU1RBVElDIiwia2luZW1hdGljQm9keSIsIktJTkVNQVRJQyIsImR5bmFtaWNCb2R5IiwiRFlOQU1JQyIsIkJvZHlEZWYiLCJ0eXBlIiwicG9zaXRpb24iLCJ6ZXJvIiwiYW5nbGUiLCJsaW5lYXJWZWxvY2l0eSIsImFuZ3VsYXJWZWxvY2l0eSIsImxpbmVhckRhbXBpbmciLCJhbmd1bGFyRGFtcGluZyIsImZpeGVkUm90YXRpb24iLCJidWxsZXQiLCJncmF2aXR5U2NhbGUiLCJhbGxvd1NsZWVwIiwiYXdha2UiLCJhY3RpdmUiLCJ1c2VyRGF0YSIsIndvcmxkIiwiZGVmIiwiYXNzZXJ0IiwiaXNWYWxpZCIsImlzRmluaXRlIiwibV93b3JsZCIsIm1fYXdha2VGbGFnIiwibV9hdXRvU2xlZXBGbGFnIiwibV9idWxsZXRGbGFnIiwibV9maXhlZFJvdGF0aW9uRmxhZyIsIm1fYWN0aXZlRmxhZyIsIm1faXNsYW5kRmxhZyIsIm1fdG9pRmxhZyIsIm1fdXNlckRhdGEiLCJtX3R5cGUiLCJtX21hc3MiLCJtX2ludk1hc3MiLCJtX0kiLCJtX2ludkkiLCJtX3hmIiwiaWRlbnRpdHkiLCJwIiwiY2xvbmUiLCJxIiwic2V0QW5nbGUiLCJtX3N3ZWVwIiwic2V0VHJhbnNmb3JtIiwiY192ZWxvY2l0eSIsImNfcG9zaXRpb24iLCJtX2ZvcmNlIiwibV90b3JxdWUiLCJtX2xpbmVhclZlbG9jaXR5IiwibV9hbmd1bGFyVmVsb2NpdHkiLCJtX2xpbmVhckRhbXBpbmciLCJtX2FuZ3VsYXJEYW1waW5nIiwibV9ncmF2aXR5U2NhbGUiLCJtX3NsZWVwVGltZSIsIm1fam9pbnRMaXN0IiwibV9jb250YWN0TGlzdCIsIm1fZml4dHVyZUxpc3QiLCJtX3ByZXYiLCJtX25leHQiLCJtX2Rlc3Ryb3llZCIsInByb3RvdHlwZSIsImlzV29ybGRMb2NrZWQiLCJpc0xvY2tlZCIsImdldFdvcmxkIiwiZ2V0TmV4dCIsInNldFVzZXJEYXRhIiwiZGF0YSIsImdldFVzZXJEYXRhIiwiZ2V0Rml4dHVyZUxpc3QiLCJnZXRKb2ludExpc3QiLCJnZXRDb250YWN0TGlzdCIsImlzU3RhdGljIiwiaXNEeW5hbWljIiwiaXNLaW5lbWF0aWMiLCJzZXRTdGF0aWMiLCJzZXRUeXBlIiwic2V0RHluYW1pYyIsInNldEtpbmVtYXRpYyIsImdldFR5cGUiLCJyZXNldE1hc3NEYXRhIiwic2V0WmVybyIsImZvcndhcmQiLCJzeW5jaHJvbml6ZUZpeHR1cmVzIiwic2V0QXdha2UiLCJjZSIsImNlMCIsIm5leHQiLCJkZXN0cm95Q29udGFjdCIsImNvbnRhY3QiLCJicm9hZFBoYXNlIiwibV9icm9hZFBoYXNlIiwicHJveHlDb3VudCIsIm1fcHJveHlDb3VudCIsInRvdWNoUHJveHkiLCJtX3Byb3hpZXMiLCJwcm94eUlkIiwiaXNCdWxsZXQiLCJzZXRCdWxsZXQiLCJmbGFnIiwiaXNTbGVlcGluZ0FsbG93ZWQiLCJzZXRTbGVlcGluZ0FsbG93ZWQiLCJpc0F3YWtlIiwiaXNBY3RpdmUiLCJzZXRBY3RpdmUiLCJjcmVhdGVQcm94aWVzIiwiZGVzdHJveVByb3hpZXMiLCJpc0ZpeGVkUm90YXRpb24iLCJzZXRGaXhlZFJvdGF0aW9uIiwiZ2V0VHJhbnNmb3JtIiwic2V0Iiwic3luY2hyb25pemUiLCJzeW5jaHJvbml6ZVRyYW5zZm9ybSIsInhmIiwiYWR2YW5jZSIsImFscGhhIiwiYyIsImMwIiwiYTAiLCJnZXRQb3NpdGlvbiIsInNldFBvc2l0aW9uIiwiZ2V0QW5nbGUiLCJnZXRXb3JsZENlbnRlciIsImdldExvY2FsQ2VudGVyIiwibG9jYWxDZW50ZXIiLCJnZXRMaW5lYXJWZWxvY2l0eSIsImdldExpbmVhclZlbG9jaXR5RnJvbVdvcmxkUG9pbnQiLCJ3b3JsZFBvaW50Iiwic3ViIiwiYWRkIiwiY3Jvc3MiLCJnZXRMaW5lYXJWZWxvY2l0eUZyb21Mb2NhbFBvaW50IiwibG9jYWxQb2ludCIsImdldFdvcmxkUG9pbnQiLCJzZXRMaW5lYXJWZWxvY2l0eSIsInYiLCJkb3QiLCJnZXRBbmd1bGFyVmVsb2NpdHkiLCJzZXRBbmd1bGFyVmVsb2NpdHkiLCJ3IiwiZ2V0TGluZWFyRGFtcGluZyIsInNldExpbmVhckRhbXBpbmciLCJnZXRBbmd1bGFyRGFtcGluZyIsInNldEFuZ3VsYXJEYW1waW5nIiwiZ2V0R3Jhdml0eVNjYWxlIiwic2V0R3Jhdml0eVNjYWxlIiwic2NhbGUiLCJnZXRNYXNzIiwiZ2V0SW5lcnRpYSIsIk1hc3NEYXRhIiwibWFzcyIsImNlbnRlciIsIkkiLCJnZXRNYXNzRGF0YSIsIm1fZGVuc2l0eSIsIm1hc3NEYXRhIiwiYWRkTXVsIiwibXVsIiwib2xkQ2VudGVyIiwic2V0TG9jYWxDZW50ZXIiLCJzZXRNYXNzRGF0YSIsImFwcGx5Rm9yY2UiLCJmb3JjZSIsInBvaW50Iiwid2FrZSIsImFwcGx5Rm9yY2VUb0NlbnRlciIsImFwcGx5VG9ycXVlIiwidG9ycXVlIiwiYXBwbHlMaW5lYXJJbXB1bHNlIiwiaW1wdWxzZSIsImFwcGx5QW5ndWxhckltcHVsc2UiLCJzaG91bGRDb2xsaWRlIiwidGhhdCIsImpuIiwib3RoZXIiLCJqb2ludCIsIm1fY29sbGlkZUNvbm5lY3RlZCIsImNyZWF0ZUZpeHR1cmUiLCJzaGFwZSIsImZpeGRlZiIsImZpeHR1cmUiLCJtX25ld0ZpeHR1cmUiLCJkZXN0cm95Rml4dHVyZSIsIm1fYm9keSIsImZvdW5kIiwibm9kZSIsImVkZ2UiLCJmaXh0dXJlQSIsImdldEZpeHR1cmVBIiwiZml4dHVyZUIiLCJnZXRGaXh0dXJlQiIsInB1Ymxpc2giLCJtdWxWZWMyIiwiZ2V0V29ybGRWZWN0b3IiLCJsb2NhbFZlY3RvciIsImdldExvY2FsUG9pbnQiLCJtdWxUVmVjMiIsImdldExvY2FsVmVjdG9yIiwid29ybGRWZWN0b3IiLCJERUJVR19TT0xWRVIiLCJQb29sIiwiQ29udGFjdEVkZ2UiLCJwcmV2IiwibV9ub2RlQSIsIm1fbm9kZUIiLCJtX21hbmlmb2xkIiwidl9wb2ludHNfY2FjaGUiLCJWZWxvY2l0eUNvbnN0cmFpbnRQb2ludCIsInZfcG9pbnRzIiwidl9ub3JtYWwiLCJ2X25vcm1hbE1hc3MiLCJ2X0siLCJwX2xvY2FsUG9pbnRzX2NhY2hlIiwicF9sb2NhbFBvaW50cyIsInBfbG9jYWxOb3JtYWwiLCJwX2xvY2FsUG9pbnQiLCJwX2xvY2FsQ2VudGVyQSIsInBfbG9jYWxDZW50ZXJCIiwiaW5pdCIsImZBIiwiaW5kZXhBIiwiZkIiLCJpbmRleEIiLCJldmFsdWF0ZUZjbiIsIm1fZml4dHVyZUEiLCJtX2ZpeHR1cmVCIiwibV9pbmRleEEiLCJtX2luZGV4QiIsIm1fZXZhbHVhdGVGY24iLCJtX3RvaSIsIm1fdG9pQ291bnQiLCJtX2ZyaWN0aW9uIiwibWl4RnJpY3Rpb24iLCJtX3Jlc3RpdHV0aW9uIiwibWl4UmVzdGl0dXRpb24iLCJtX3RhbmdlbnRTcGVlZCIsIm1fZW5hYmxlZEZsYWciLCJtX3RvdWNoaW5nRmxhZyIsIm1fZmlsdGVyRmxhZyIsIm1fYnVsbGV0SGl0RmxhZyIsInZfcG9pbnRDb3VudCIsInZfdGFuZ2VudFNwZWVkIiwidl9mcmljdGlvbiIsInZfcmVzdGl0dXRpb24iLCJ2X2ludk1hc3NBIiwidl9pbnZNYXNzQiIsInZfaW52SUEiLCJ2X2ludklCIiwicF90eXBlIiwicF9yYWRpdXNBIiwicF9yYWRpdXNCIiwicF9wb2ludENvdW50IiwicF9pbnZNYXNzQSIsInBfaW52TWFzc0IiLCJwX2ludklBIiwicF9pbnZJQiIsImluaXRDb25zdHJhaW50Iiwic3RlcCIsInNoYXBlQSIsImdldFNoYXBlIiwic2hhcGVCIiwiYm9keUEiLCJnZXRCb2R5IiwiYm9keUIiLCJtYW5pZm9sZCIsInBvaW50Q291bnQiLCJzZXRWZWMyIiwibV9yYWRpdXMiLCJsb2NhbE5vcm1hbCIsImoiLCJjcCIsInBvaW50cyIsInZjcCIsIndhcm1TdGFydGluZyIsIm5vcm1hbEltcHVsc2UiLCJkdFJhdGlvIiwidGFuZ2VudEltcHVsc2UiLCJyQSIsInJCIiwibm9ybWFsTWFzcyIsInRhbmdlbnRNYXNzIiwidmVsb2NpdHlCaWFzIiwiZ2V0TWFuaWZvbGQiLCJnZXRXb3JsZE1hbmlmb2xkIiwid29ybGRNYW5pZm9sZCIsInNldEVuYWJsZWQiLCJpc0VuYWJsZWQiLCJpc1RvdWNoaW5nIiwiZ2V0Q2hpbGRJbmRleEEiLCJnZXRDaGlsZEluZGV4QiIsImZsYWdGb3JGaWx0ZXJpbmciLCJzZXRGcmljdGlvbiIsImZyaWN0aW9uIiwiZ2V0RnJpY3Rpb24iLCJyZXNldEZyaWN0aW9uIiwic2V0UmVzdGl0dXRpb24iLCJyZXN0aXR1dGlvbiIsImdldFJlc3RpdHV0aW9uIiwicmVzZXRSZXN0aXR1dGlvbiIsInNldFRhbmdlbnRTcGVlZCIsInNwZWVkIiwiZ2V0VGFuZ2VudFNwZWVkIiwiZXZhbHVhdGUiLCJ4ZkEiLCJ4ZkIiLCJjdXBfbWFuaWZvbGQiLCJ1cGRhdGUiLCJsaXN0ZW5lciIsInRvdWNoaW5nIiwid2FzVG91Y2hpbmciLCJzZW5zb3JBIiwiaXNTZW5zb3IiLCJzZW5zb3JCIiwic2Vuc29yIiwidGVzdE92ZXJsYXAiLCJvbGRNYW5pZm9sZCIsIm5tcCIsIm9tcCIsImlkIiwia2V5IiwiYmVnaW5Db250YWN0IiwiZW5kQ29udGFjdCIsInByZVNvbHZlIiwic29sdmVQb3NpdGlvbkNvbnN0cmFpbnQiLCJfc29sdmVQb3NpdGlvbkNvbnN0cmFpbnQiLCJzb2x2ZVBvc2l0aW9uQ29uc3RyYWludFRPSSIsInRvaUEiLCJ0b2lCIiwic3BjX2xvY2FsQ2VudGVyQSIsInNwY19sb2NhbENlbnRlckIiLCJzcGNfY0EiLCJzcGNfY0IiLCJzcGNfeGZBIiwic3BjX3hmQiIsInNwY190MSIsInNwY190MiIsInNwY19ub3JtYWwiLCJzcGNfcG9pbnQiLCJzcGNfcG9pbnRBIiwic3BjX3BvaW50QiIsInNwY19wbGFuZVBvaW50Iiwic3BjX2NsaXBQb2ludCIsInNwY19yQSIsInNwY19yQiIsInNwY19QIiwidG9pIiwidmVsb2NpdHlBIiwidmVsb2NpdHlCIiwicG9zaXRpb25BIiwicG9zaXRpb25CIiwibG9jYWxDZW50ZXJBIiwibG9jYWxDZW50ZXJCIiwibUEiLCJpQSIsIm1CIiwiaUIiLCJjQSIsImFBIiwiY0IiLCJhQiIsIm1pblNlcGFyYXRpb24iLCJzZXRJZGVudGl0eSIsInN1Yl8iLCJtdWxWZWMyXyIsIm5vcm1hbCIsInNlcGFyYXRpb24iLCJlX2NpcmNsZXMiLCJwb2ludEEiLCJwb2ludEIiLCJub3JtYWxpemUiLCJjb21iaW5lXyIsImVfZmFjZUEiLCJwbGFuZVBvaW50IiwiY2xpcFBvaW50IiwiZV9mYWNlQiIsIm1pbiIsImJhdW1nYXJ0ZSIsInRvaUJhdWdhcnRlIiwibGluZWFyU2xvcCIsIm1heExpbmVhckNvcnJlY3Rpb24iLCJDIiwiY2xhbXAiLCJybkEiLCJjcm9zc1ZlYzJWZWMyIiwicm5CIiwiSyIsIlAiLCJtdWxOdW1WZWMyXyIsInN1Yk11bCIsIml2Y19sb2NhbENlbnRlckEiLCJpdmNfbG9jYWxDZW50ZXJCIiwiaXZjX25vcm1hbCIsIml2Y19jQSIsIml2Y19jQiIsIml2Y192QSIsIml2Y192QiIsIml2Y190MSIsIml2Y190MiIsIml2Y194ZkEiLCJpdmNfeGZCIiwiaW5pdFZlbG9jaXR5Q29uc3RyYWludCIsInJhZGl1c0EiLCJyYWRpdXNCIiwidkEiLCJ3QSIsInZCIiwid0IiLCJzZXRDb21iaW5lIiwia05vcm1hbCIsInRhbmdlbnQiLCJjcm9zc1ZlYzJOdW1fIiwicnRBIiwicnRCIiwia1RhbmdlbnQiLCJ2UmVsIiwiY3Jvc3NOdW1WZWMyXyIsInZlbG9jaXR5VGhyZXNob2xkIiwiYmxvY2tTb2x2ZSIsInZjcDEiLCJ2Y3AyIiwicm4xQSIsInJuMUIiLCJybjJBIiwicm4yQiIsImsxMSIsImsyMiIsImsxMiIsImtfbWF4Q29uZGl0aW9uTnVtYmVyIiwiZXgiLCJleSIsImdldEludmVyc2UiLCJ3c2NfdkEiLCJ3c2NfdkIiLCJ3c2Nfbm9ybWFsIiwid3NjX1AiLCJ3YXJtU3RhcnRDb25zdHJhaW50Iiwic3RvcmVDb25zdHJhaW50SW1wdWxzZXMiLCJzdmNfdkEiLCJzdmNfdkIiLCJzdmNfZHYiLCJzdmNfUCIsInN2Y190YW5nZW50Iiwic3ZjX2EiLCJzdmNfYiIsInN2Y19kIiwic3ZjX3giLCJzdmNfZHYxIiwic3ZjX2R2MiIsInN2Y19QMSIsInN2Y19QMiIsInN2Y190MSIsInN2Y190MiIsInNvbHZlVmVsb2NpdHlDb25zdHJhaW50IiwidkFYIiwieCIsInZBWSIsInkiLCJ2QlgiLCJ2QlkiLCJkdlgiLCJkdlkiLCJ2dCIsImxhbWJkYSIsIm1heEZyaWN0aW9uIiwibmV3SW1wdWxzZSIsIlBYIiwiUFkiLCJ2biIsIm1heCIsImFYIiwiYVkiLCJkdjFYIiwiZHYxWSIsImR2MlgiLCJkdjJZIiwidm4xIiwidm4yIiwiYlgiLCJiWSIsImtfZXJyb3JUb2wiLCJ4WCIsInhZIiwiZFgiLCJkWSIsIlAxWCIsIlAxWSIsIlAyWCIsIlAyWSIsImFicyIsImZyaWN0aW9uMSIsImZyaWN0aW9uMiIsInNxcnQiLCJyZXN0aXR1dGlvbjEiLCJyZXN0aXR1dGlvbjIiLCJzX3JlZ2lzdGVycyIsImNvbnRhY3RQb29sIiwiY3JlYXRlIiwiYWRkVHlwZSIsInR5cGUxIiwidHlwZTIiLCJjYWxsYmFjayIsInR5cGVBIiwidHlwZUIiLCJhbGxvY2F0ZSIsImRlc3Ryb3kiLCJkZXN0cm95RmNuIiwicmVsZWFzZSIsIkZpeHR1cmVEZWYiLCJkZW5zaXR5IiwiZmlsdGVyR3JvdXBJbmRleCIsImZpbHRlckNhdGVnb3J5Qml0cyIsImZpbHRlck1hc2tCaXRzIiwiRml4dHVyZVByb3h5IiwiY2hpbGRJbmRleCIsImFhYmIiLCJib2R5IiwibV9pc1NlbnNvciIsIm1fZmlsdGVyR3JvdXBJbmRleCIsIm1fZmlsdGVyQ2F0ZWdvcnlCaXRzIiwibV9maWx0ZXJNYXNrQml0cyIsIm1fc2hhcGUiLCJjaGlsZENvdW50IiwiZ2V0Q2hpbGRDb3VudCIsInNldFNlbnNvciIsImdldERlbnNpdHkiLCJzZXREZW5zaXR5IiwidGVzdFBvaW50IiwicmF5Q2FzdCIsIm91dHB1dCIsImlucHV0IiwiY29tcHV0ZU1hc3MiLCJnZXRBQUJCIiwicHJveHkiLCJjb21wdXRlQUFCQiIsImNyZWF0ZVByb3h5IiwiZGVzdHJveVByb3h5IiwieGYxIiwieGYyIiwiYWFiYjEiLCJhYWJiMiIsImNvbWJpbmUiLCJkaXNwbGFjZW1lbnQiLCJtb3ZlUHJveHkiLCJzZXRGaWx0ZXJEYXRhIiwiZmlsdGVyIiwiZ3JvdXBJbmRleCIsImNhdGVnb3J5Qml0cyIsIm1hc2tCaXRzIiwicmVmaWx0ZXIiLCJnZXRGaWx0ZXJHcm91cEluZGV4IiwiZ2V0RmlsdGVyQ2F0ZWdvcnlCaXRzIiwiZ2V0RmlsdGVyTWFza0JpdHMiLCJjb2xsaWRlIiwiSm9pbnRFZGdlIiwiREVGQVVMVFMiLCJjb2xsaWRlQ29ubmVjdGVkIiwibV9ib2R5QSIsIm1fYm9keUIiLCJtX2luZGV4IiwibV9lZGdlQSIsIm1fZWRnZUIiLCJnZXRCb2R5QSIsImdldEJvZHlCIiwiZ2V0Q29sbGlkZUNvbm5lY3RlZCIsImdldEFuY2hvckEiLCJnZXRBbmNob3JCIiwiZ2V0UmVhY3Rpb25Gb3JjZSIsImludl9kdCIsImdldFJlYWN0aW9uVG9ycXVlIiwic2hpZnRPcmlnaW4iLCJuZXdPcmlnaW4iLCJpbml0VmVsb2NpdHlDb25zdHJhaW50cyIsInNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyIsInNvbHZlUG9zaXRpb25Db25zdHJhaW50cyIsImNsaXBTZWdtZW50VG9MaW5lIiwiY2xpcFZlcnRleCIsIkNsaXBWZXJ0ZXgiLCJnZXRQb2ludFN0YXRlcyIsIlBvaW50U3RhdGUiLCJlX3ZlcnRleCIsImVfZmFjZSIsIk1hbmlmb2xkUG9pbnQiLCJDb250YWN0SUQiLCJjZiIsIkNvbnRhY3RGZWF0dXJlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiV29ybGRNYW5pZm9sZCIsInNlcGFyYXRpb25zIiwid20iLCJuZW8iLCJkaXN0IiwibGVuZ3RoU3F1YXJlZCIsIkVQU0lMT04iLCJtaWQiLCJudWxsU3RhdGUiLCJhZGRTdGF0ZSIsInBlcnNpc3RTdGF0ZSIsInJlbW92ZVN0YXRlIiwic3RhdGUxIiwic3RhdGUyIiwibWFuaWZvbGQxIiwibWFuaWZvbGQyIiwidk91dCIsInZJbiIsIm9mZnNldCIsInZlcnRleEluZGV4QSIsIm51bU91dCIsImRpc3RhbmNlMCIsImRpc3RhbmNlMSIsImludGVycCIsIm1heE1hbmlmb2xkUG9pbnRzIiwibWF4UG9seWdvblZlcnRpY2VzIiwiYWFiYkV4dGVuc2lvbiIsImFhYmJNdWx0aXBsaWVyIiwibGluZWFyU2xvcFNxdWFyZWQiLCJhbmd1bGFyU2xvcCIsIlBJIiwicG9seWdvblJhZGl1cyIsIm1heFN1YlN0ZXBzIiwibWF4VE9JQ29udGFjdHMiLCJtYXhUT0lJdGVyYXRpb25zIiwibWF4RGlzdG5jZUl0ZXJhdGlvbnMiLCJtYXhBbmd1bGFyQ29ycmVjdGlvbiIsIm1heFRyYW5zbGF0aW9uIiwibWF4VHJhbnNsYXRpb25TcXVhcmVkIiwibWF4Um90YXRpb24iLCJtYXhSb3RhdGlvblNxdWFyZWQiLCJ0aW1lVG9TbGVlcCIsImxpbmVhclNsZWVwVG9sZXJhbmNlIiwibGluZWFyU2xlZXBUb2xlcmFuY2VTcXIiLCJwb3ciLCJhbmd1bGFyU2xlZXBUb2xlcmFuY2UiLCJhbmd1bGFyU2xlZXBUb2xlcmFuY2VTcXIiLCJnZXRSYWRpdXMiLCJfY2xvbmUiLCJ0cmFuc2Zvcm0iLCJjb21wdXRlRGlzdGFuY2VQcm94eSIsIlNvbHZlciIsIlRpbWVTdGVwIiwiVE9JSW5wdXQiLCJJbnB1dCIsIlRPSU91dHB1dCIsIk91dHB1dCIsIkRpc3RhbmNlSW5wdXQiLCJEaXN0YW5jZU91dHB1dCIsIkRpc3RhbmNlUHJveHkiLCJQcm94eSIsIlNpbXBsZXhDYWNoZSIsIkNhY2hlIiwiZHQiLCJ2ZWxvY2l0eUl0ZXJhdGlvbnMiLCJwb3NpdGlvbkl0ZXJhdGlvbnMiLCJpbnZfZHQwIiwicmVzZXQiLCJtX3N0YWNrIiwibV9ib2RpZXMiLCJtX2NvbnRhY3RzIiwibV9qb2ludHMiLCJjbGVhciIsImFkZEJvZHkiLCJwdXNoIiwiYWRkQ29udGFjdCIsImFkZEpvaW50Iiwic29sdmVXb3JsZCIsImIiLCJtX2JvZHlMaXN0Iiwic3RhY2siLCJsb29wIiwic2VlZCIsInBvcCIsImplIiwic29sdmVJc2xhbmQiLCJncmF2aXR5IiwibV9ncmF2aXR5IiwibV9hbGxvd1NsZWVwIiwiaCIsInByaW50Qm9kaWVzIiwidHJhbnNsYXRpb24iLCJyYXRpbyIsInJvdGF0aW9uIiwicG9zaXRpb25Tb2x2ZWQiLCJjb250YWN0c09rYXkiLCJqb2ludHNPa2F5Iiwiam9pbnRPa2F5IiwicG9zdFNvbHZlSXNsYW5kIiwibWluU2xlZXBUaW1lIiwiSW5maW5pdHkiLCJsaW5Ub2xTcXIiLCJhbmdUb2xTcXIiLCJ0YWciLCJkZWJ1ZyIsInNfc3ViU3RlcCIsInNvbHZlV29ybGRUT0kiLCJtX3N0ZXBDb21wbGV0ZSIsImFscGhhMCIsIm1pbkNvbnRhY3QiLCJtaW5BbHBoYSIsImJBIiwiYkIiLCJhY3RpdmVBIiwiYWN0aXZlQiIsImNvbGxpZGVBIiwiY29sbGlkZUIiLCJzd2VlcEEiLCJzd2VlcEIiLCJwcm94eUEiLCJwcm94eUIiLCJ0TWF4IiwiYmV0YSIsInN0YXRlIiwiZV90b3VjaGluZyIsImJhY2t1cDEiLCJiYWNrdXAyIiwiYm9kaWVzIiwiYmFja3VwIiwic29sdmVJc2xhbmRUT0kiLCJmaW5kTmV3Q29udGFjdHMiLCJtX3N1YlN0ZXBwaW5nIiwic3ViU3RlcCIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwidXNlUmFkaWkiLCJjYWNoZSIsImRpc3RhbmNlIiwiY291bnQiLCJDb250YWN0SW1wdWxzZSIsIm5vcm1hbEltcHVsc2VzIiwidGFuZ2VudEltcHVsc2VzIiwicG9zdFNvbHZlIiwiQnJvYWRQaGFzZSIsIldvcmxkRGVmIiwiY29udGludW91c1BoeXNpY3MiLCJzdWJTdGVwcGluZyIsIm1fc29sdmVyIiwibV9jb250YWN0Q291bnQiLCJtX2JvZHlDb3VudCIsIm1fam9pbnRDb3VudCIsIm1fY2xlYXJGb3JjZXMiLCJtX2xvY2tlZCIsIm1fd2FybVN0YXJ0aW5nIiwibV9jb250aW51b3VzUGh5c2ljcyIsIm1fYmxvY2tTb2x2ZSIsIm1fdmVsb2NpdHlJdGVyYXRpb25zIiwibV9wb3NpdGlvbkl0ZXJhdGlvbnMiLCJtX3QiLCJtX3N0ZXBDb3VudCIsImFkZFBhaXIiLCJjcmVhdGVDb250YWN0IiwiYmluZCIsImdldEJvZHlMaXN0IiwiZ2V0Qm9keUNvdW50IiwiZ2V0Sm9pbnRDb3VudCIsImdldENvbnRhY3RDb3VudCIsInNldEdyYXZpdHkiLCJnZXRHcmF2aXR5Iiwic2V0QWxsb3dTbGVlcGluZyIsImdldEFsbG93U2xlZXBpbmciLCJzZXRXYXJtU3RhcnRpbmciLCJnZXRXYXJtU3RhcnRpbmciLCJzZXRDb250aW51b3VzUGh5c2ljcyIsImdldENvbnRpbnVvdXNQaHlzaWNzIiwic2V0U3ViU3RlcHBpbmciLCJnZXRTdWJTdGVwcGluZyIsInNldEF1dG9DbGVhckZvcmNlcyIsImdldEF1dG9DbGVhckZvcmNlcyIsImNsZWFyRm9yY2VzIiwicXVlcnlBQUJCIiwicXVlcnlDYWxsYmFjayIsInF1ZXJ5IiwicG9pbnQxIiwicG9pbnQyIiwicmVwb3J0Rml4dHVyZUNhbGxiYWNrIiwibWF4RnJhY3Rpb24iLCJwMSIsInAyIiwiaW5kZXgiLCJoaXQiLCJmcmFjdGlvbiIsImdldFByb3h5Q291bnQiLCJnZXRUcmVlSGVpZ2h0IiwiZ2V0VHJlZUJhbGFuY2UiLCJnZXRUcmVlUXVhbGl0eSIsImNyZWF0ZUJvZHkiLCJjcmVhdGVEeW5hbWljQm9keSIsImNyZWF0ZUtpbmVtYXRpY0JvZHkiLCJkZXN0cm95Qm9keSIsImplMCIsImRlc3Ryb3lKb2ludCIsImYwIiwiY3JlYXRlSm9pbnQiLCJzX3N0ZXAiLCJ0aW1lU3RlcCIsInVwZGF0ZUNvbnRhY3RzIiwidXBkYXRlUGFpcnMiLCJuZXh0X2MiLCJwcm94eUlkQSIsInByb3h5SWRCIiwib3ZlcmxhcCIsIl9saXN0ZW5lcnMiLCJvbiIsIm5hbWUiLCJvZmYiLCJsaXN0ZW5lcnMiLCJpbmRleE9mIiwic3BsaWNlIiwiYXJnMSIsImFyZzIiLCJhcmczIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiZCIsInZhbGlkIiwiZ2V0Q2VudGVyIiwiZ2V0RXh0ZW50cyIsImdldFBlcmltZXRlciIsImxvd2VyQSIsInVwcGVyQSIsImxvd2VyQiIsInVwcGVyQiIsImxvd2VyWCIsImxvd2VyWSIsInVwcGVyWCIsInVwcGVyWSIsImNvbWJpbmVQb2ludHMiLCJjb250YWlucyIsInJlc3VsdCIsImV4dGVuZCIsInZhbHVlIiwiZDF4IiwiZDJ4IiwiZDF5IiwiZDJ5IiwiYXJlRXF1YWwiLCJkaWZmIiwid0QiLCJoRCIsImhBIiwiaEIiLCJ0bWluIiwidG1heCIsImFic0QiLCJpbnZfZCIsInQxIiwidDIiLCJ0ZW1wIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwibV90cmVlIiwibV9tb3ZlQnVmZmVyIiwiYWFiYkEiLCJnZXRGYXRBQUJCIiwiYWFiYkIiLCJnZXRIZWlnaHQiLCJnZXRNYXhCYWxhbmNlIiwiZ2V0QXJlYVJhdGlvIiwicmF5Q2FzdENhbGxiYWNrIiwiYnVmZmVyTW92ZSIsInVuYnVmZmVyTW92ZSIsImNoYW5nZWQiLCJhZGRQYWlyQ2FsbGJhY2siLCJtX2NhbGxiYWNrIiwibV9xdWVyeVByb3h5SWQiLCJmYXRBQUJCIiwidXNlckRhdGFBIiwidXNlckRhdGFCIiwiZ2prQ2FsbHMiLCJnamtJdGVycyIsImdqa01heEl0ZXJzIiwiaXRlcmF0aW9ucyIsIm1ldHJpYyIsInNpbXBsZXgiLCJTaW1wbGV4IiwicmVhZENhY2hlIiwidmVydGljZXMiLCJtX3YiLCJrX21heEl0ZXJzIiwic2F2ZUEiLCJzYXZlQiIsInNhdmVDb3VudCIsImRpc3RhbmNlU3FyMSIsImRpc3RhbmNlU3FyMiIsIml0ZXIiLCJtX2NvdW50Iiwic29sdmUiLCJnZXRDbG9zZXN0UG9pbnQiLCJnZXRTZWFyY2hEaXJlY3Rpb24iLCJ2ZXJ0ZXgiLCJnZXRTdXBwb3J0IiwibmVnIiwiZ2V0VmVydGV4IiwiZHVwbGljYXRlIiwiZ2V0V2l0bmVzc1BvaW50cyIsIndyaXRlQ2FjaGUiLCJtX2J1ZmZlciIsIm1fdmVydGljZXMiLCJnZXRWZXJ0ZXhDb3VudCIsImJlc3RJbmRleCIsImJlc3RWYWx1ZSIsImdldFN1cHBvcnRWZXJ0ZXgiLCJTaW1wbGV4VmVydGV4IiwibV92MSIsIm1fdjIiLCJtX3YzIiwicHJpbnQiLCJ3QUxvY2FsIiwid0JMb2NhbCIsIm1ldHJpYzEiLCJtZXRyaWMyIiwiZ2V0TWV0cmljIiwiZTEyIiwic2duIiwicEEiLCJwQiIsInNvbHZlMiIsInNvbHZlMyIsIncxIiwidzIiLCJkMTJfMiIsImQxMl8xIiwiaW52X2QxMiIsInczIiwidzFlMTIiLCJ3MmUxMiIsImUxMyIsIncxZTEzIiwidzNlMTMiLCJkMTNfMSIsImQxM18yIiwiZTIzIiwidzJlMjMiLCJ3M2UyMyIsImQyM18xIiwiZDIzXzIiLCJuMTIzIiwiZDEyM18xIiwiZDEyM18yIiwiZDEyM18zIiwiaW52X2QxMyIsImludl9kMjMiLCJpbnZfZDEyMyIsImFhYmJQb29sIiwibm9kZVBvb2wiLCJUcmVlTm9kZSIsInBhcmVudCIsImNoaWxkMSIsImNoaWxkMiIsImhlaWdodCIsImlzTGVhZiIsIm1fcm9vdCIsIm1fbm9kZXMiLCJtX2xhc3RQcm94eUlkIiwiYWxsb2NhdGVOb2RlIiwiZnJlZU5vZGUiLCJpbnNlcnRMZWFmIiwicmVtb3ZlTGVhZiIsImxlYWYiLCJsZWFmQUFCQiIsImFyZWEiLCJjb21iaW5lZEFBQkIiLCJjb21iaW5lZEFyZWEiLCJjb3N0IiwiaW5oZXJpdGFuY2VDb3N0IiwiY29zdDEiLCJvbGRBcmVhIiwibmV3QXJlYSIsImNvc3QyIiwic2libGluZyIsIm9sZFBhcmVudCIsIm5ld1BhcmVudCIsImJhbGFuY2UiLCJncmFuZFBhcmVudCIsIkEiLCJCIiwiRiIsIkciLCJEIiwiRSIsInJvb3QiLCJyb290QXJlYSIsInRvdGFsQXJlYSIsIml0IiwiaXRlcmF0b3JQb29sIiwicHJlb3JkZXIiLCJjb21wdXRlSGVpZ2h0IiwiaGVpZ2h0MSIsIkNvbXB1dGVIZWlnaHQiLCJoZWlnaHQyIiwidmFsaWRhdGVTdHJ1Y3R1cmUiLCJ2YWxpZGF0ZU1ldHJpY3MiLCJ2YWxpZGF0ZSIsIlZhbGlkYXRlU3RydWN0dXJlIiwiVmFsaWRhdGVNZXRyaWNzIiwibWF4QmFsYW5jZSIsInJlYnVpbGRCb3R0b21VcCIsIm5vZGVzIiwibWluQ29zdCIsImlNaW4iLCJqTWluIiwiYWFiYmkiLCJhYWJiaiIsInN0YWNrUG9vbCIsInByb2NlZWQiLCJhYnNfdiIsInNlZ21lbnRBQUJCIiwic3ViSW5wdXQiLCJpbnB1dFBvb2wiLCJJdGVyYXRvciIsIml0ZXJhdG9yIiwiY2xvc2UiLCJwYXJlbnRzIiwic3RhdGVzIiwiVGltZXIiLCJlX3Vua25vd24iLCJlX2ZhaWxlZCIsImVfb3ZlcmxhcHBlZCIsImVfc2VwYXJhdGVkIiwidG9pVGltZSIsInRvaU1heFRpbWUiLCJ0b2lDYWxscyIsInRvaUl0ZXJzIiwidG9pTWF4SXRlcnMiLCJ0b2lSb290SXRlcnMiLCJ0b2lNYXhSb290SXRlcnMiLCJ0aW1lciIsIm5vdyIsInRvdGFsUmFkaXVzIiwidGFyZ2V0IiwidG9sZXJhbmNlIiwia19tYXhJdGVyYXRpb25zIiwiZGlzdGFuY2VJbnB1dCIsImRpc3RhbmNlT3V0cHV0IiwiZmNuIiwiU2VwYXJhdGlvbkZ1bmN0aW9uIiwiaW5pdGlhbGl6ZSIsIk4iLCJkeCIsInhzIiwiZnMiLCJwcmludGYiLCJkb25lIiwicHVzaEJhY2tJdGVyIiwiczIiLCJmaW5kTWluU2VwYXJhdGlvbiIsInMxIiwicm9vdEl0ZXJDb3VudCIsImExIiwiYTIiLCJ0aW1lIiwiZV9wb2ludHMiLCJtX3Byb3h5QSIsIm1fcHJveHlCIiwibV9zd2VlcEEiLCJtX3N3ZWVwQiIsIm1fbG9jYWxQb2ludCIsIm1fYXhpcyIsImxvY2FsUG9pbnRBIiwibG9jYWxQb2ludEIiLCJsb2NhbFBvaW50QjEiLCJsb2NhbFBvaW50QjIiLCJsb2NhbFBvaW50QTEiLCJsb2NhbFBvaW50QTIiLCJjb21wdXRlIiwiZmluZCIsImF4aXNBIiwiYXhpc0IiLCJzZXAiLCJkZXQiLCJpbXgiLCJteCIsIl8iLCJtdWxNYXQyMiIsIm11bFQiLCJjMSIsImMyIiwibXVsVE1hdDIyIiwibXgxIiwibXgyIiwiZXoiLCJzb2x2ZTMzIiwieiIsInNvbHZlMjIiLCJhMTEiLCJhMTIiLCJhMjEiLCJhMjIiLCJnZXRJbnZlcnNlMjIiLCJNIiwiZ2V0U3ltSW52ZXJzZTMzIiwiYTEzIiwiYTIzIiwiYTMzIiwibXVsVmVjMyIsIm5hdGl2ZSIsIm1hdGgiLCJpc05hTiIsImludlNxcnQiLCJuZXh0UG93ZXJPZlR3byIsImlzUG93ZXJPZlR3byIsIm1vZCIsIm51bSIsInJhbmRvbSIsIm9iaiIsInJvdCIsInNpbiIsImNvcyIsImF0YW4yIiwiZ2V0WEF4aXMiLCJnZXRZQXhpcyIsIm0iLCJxciIsIm11bFJvdCIsIm11bFN1YiIsIm11bFRSb3QiLCJtdWxUUm90XyIsIm11bFRWZWMyXyIsIkFycmF5IiwiaXNBcnJheSIsImFyciIsIm11bEFsbCIsIm11bEZuIiwibXVsWGYiLCJweCIsInB5IiwibXVsVFhmIiwiX3Z0MSIsIm11bFRYZl8iLCJzZXRYWSIsIndTZXQiLCJzZXRNdWwiLCJ3QWRkIiwiYWRkQ29tYmluZSIsIndTdWIiLCJzdWJDb21iaW5lIiwibGVuZ3RoT2YiLCJpbnZMZW5ndGgiLCJkeSIsImRpc3RhbmNlU3F1YXJlZCIsInNrZXciLCJhZGRDcm9zcyIsIm11bFZlYzJOdW1fIiwibmVnXyIsImxlbmd0aFNxciIsInNjYWxlRm4iLCJ0cmFuc2xhdGVGbiIsIm5ld2xpbmUiLCJzdHJpbmciLCJUWVBFIiwiX3N1cGVyIiwiZnJlcXVlbmN5SHoiLCJkYW1waW5nUmF0aW8iLCJhbmNob3JBIiwiYW5jaG9yQiIsIm1fbG9jYWxBbmNob3JBIiwibG9jYWxBbmNob3JBIiwibV9sb2NhbEFuY2hvckIiLCJsb2NhbEFuY2hvckIiLCJtX2xlbmd0aCIsIm1fZnJlcXVlbmN5SHoiLCJtX2RhbXBpbmdSYXRpbyIsIm1faW1wdWxzZSIsIm1fZ2FtbWEiLCJtX2JpYXMiLCJtX3UiLCJtX3JBIiwibV9yQiIsIm1fbG9jYWxDZW50ZXJBIiwibV9sb2NhbENlbnRlckIiLCJtX2ludk1hc3NBIiwibV9pbnZNYXNzQiIsIm1faW52SUEiLCJtX2ludklCIiwiZ2V0TG9jYWxBbmNob3JBIiwiZ2V0TG9jYWxBbmNob3JCIiwic2V0TGVuZ3RoIiwiZ2V0TGVuZ3RoIiwic2V0RnJlcXVlbmN5IiwiaHoiLCJnZXRGcmVxdWVuY3kiLCJzZXREYW1waW5nUmF0aW8iLCJnZXREYW1waW5nUmF0aW8iLCJxQSIsInFCIiwiY3JBdSIsImNyQnUiLCJpbnZNYXNzIiwib21lZ2EiLCJrIiwidnBBIiwidnBCIiwiQ2RvdCIsIm1heEZvcmNlIiwibWF4VG9ycXVlIiwiYW5jaG9yIiwibV9saW5lYXJJbXB1bHNlIiwibV9hbmd1bGFySW1wdWxzZSIsIm1fbWF4Rm9yY2UiLCJtX21heFRvcnF1ZSIsIm1fbGluZWFyTWFzcyIsIm1fYW5ndWxhck1hc3MiLCJzZXRNYXhGb3JjZSIsImdldE1heEZvcmNlIiwic2V0TWF4VG9ycXVlIiwiZ2V0TWF4VG9ycXVlIiwib2xkSW1wdWxzZSIsIm1heEltcHVsc2UiLCJqb2ludDEiLCJqb2ludDIiLCJtX2pvaW50MSIsIm1fam9pbnQyIiwibV9yYXRpbyIsIm1fdHlwZTEiLCJtX3R5cGUyIiwiY29vcmRpbmF0ZUEiLCJjb29yZGluYXRlQiIsIm1fYm9keUMiLCJ4ZkMiLCJhQyIsInJldm9sdXRlIiwibV9sb2NhbEFuY2hvckMiLCJtX3JlZmVyZW5jZUFuZ2xlQSIsIm1fcmVmZXJlbmNlQW5nbGUiLCJtX2xvY2FsQXhpc0MiLCJwcmlzbWF0aWMiLCJtX2xvY2FsWEF4aXNBIiwicEMiLCJtX2JvZHlEIiwieGZEIiwiYUQiLCJtX2xvY2FsQW5jaG9yRCIsIm1fcmVmZXJlbmNlQW5nbGVCIiwibV9sb2NhbEF4aXNEIiwicEQiLCJtX2NvbnN0YW50IiwibV9sY0EiLCJtX2xjQiIsIm1fbGNDIiwibV9sY0QiLCJtX21BIiwibV9tQiIsIm1fbUMiLCJtX21EIiwibV9pQSIsIm1faUIiLCJtX2lDIiwibV9pRCIsIm1fSnZBQyIsIm1fSnZCRCIsIm1fSndBIiwibV9Kd0IiLCJtX0p3QyIsIm1fSndEIiwiZ2V0Sm9pbnQxIiwiZ2V0Sm9pbnQyIiwic2V0UmF0aW8iLCJnZXRSYXRpbyIsIkwiLCJ2QyIsIndDIiwidkQiLCJxQyIsInFEIiwickMiLCJyRCIsImNDIiwiY0QiLCJsaW5lYXJFcnJvciIsIkp2QUMiLCJKdkJEIiwiSndBIiwiSndCIiwiSndDIiwiSndEIiwiY29ycmVjdGlvbkZhY3RvciIsIm1fbGluZWFyT2Zmc2V0IiwibGluZWFyT2Zmc2V0IiwiYW5nbGVBIiwiYW5nbGVCIiwibV9hbmd1bGFyT2Zmc2V0IiwibV9jb3JyZWN0aW9uRmFjdG9yIiwibV9saW5lYXJFcnJvciIsIm1fYW5ndWxhckVycm9yIiwic2V0Q29ycmVjdGlvbkZhY3RvciIsImZhY3RvciIsImdldENvcnJlY3Rpb25GYWN0b3IiLCJzZXRMaW5lYXJPZmZzZXQiLCJnZXRMaW5lYXJPZmZzZXQiLCJzZXRBbmd1bGFyT2Zmc2V0IiwiYW5ndWxhck9mZnNldCIsImdldEFuZ3VsYXJPZmZzZXQiLCJpbnZfaCIsIm1fdGFyZ2V0QSIsIm1fYmV0YSIsIm1fQyIsInNldFRhcmdldCIsImdldFRhcmdldCIsInZlbG9jaXR5IiwiaW5hY3RpdmVMaW1pdCIsImF0TG93ZXJMaW1pdCIsImF0VXBwZXJMaW1pdCIsImVxdWFsTGltaXRzIiwiZW5hYmxlTGltaXQiLCJsb3dlclRyYW5zbGF0aW9uIiwidXBwZXJUcmFuc2xhdGlvbiIsImVuYWJsZU1vdG9yIiwibWF4TW90b3JGb3JjZSIsIm1vdG9yU3BlZWQiLCJheGlzIiwibG9jYWxBeGlzQSIsIm1fbG9jYWxZQXhpc0EiLCJyZWZlcmVuY2VBbmdsZSIsIm1fbW90b3JNYXNzIiwibV9tb3RvckltcHVsc2UiLCJtX2xvd2VyVHJhbnNsYXRpb24iLCJtX3VwcGVyVHJhbnNsYXRpb24iLCJtX21heE1vdG9yRm9yY2UiLCJtX21vdG9yU3BlZWQiLCJtX2VuYWJsZUxpbWl0IiwibV9lbmFibGVNb3RvciIsIm1fbGltaXRTdGF0ZSIsIm1fcGVycCIsIm1fczEiLCJtX3MyIiwibV9hMSIsIm1fYTIiLCJtX0siLCJnZXRMb2NhbEF4aXNBIiwiZ2V0UmVmZXJlbmNlQW5nbGUiLCJnZXRKb2ludFRyYW5zbGF0aW9uIiwiZ2V0Sm9pbnRTcGVlZCIsImlzTGltaXRFbmFibGVkIiwiZ2V0TG93ZXJMaW1pdCIsImdldFVwcGVyTGltaXQiLCJzZXRMaW1pdHMiLCJpc01vdG9yRW5hYmxlZCIsInNldE1vdG9yU3BlZWQiLCJzZXRNYXhNb3RvckZvcmNlIiwiZ2V0TW90b3JTcGVlZCIsImdldE1vdG9yRm9yY2UiLCJzMXRlc3QiLCJrMTMiLCJrMjMiLCJrMzMiLCJqb2ludFRyYW5zbGF0aW9uIiwiTEEiLCJMQiIsIkNkb3QxIiwiQ2RvdDIiLCJmMSIsImRmIiwiZjJyIiwicGVycCIsIkMxIiwiYW5ndWxhckVycm9yIiwiQzIiLCJpbXB1bHNlMSIsIk1JTl9QVUxMRVlfTEVOR1RIIiwiUHVsbGV5Sm9pbnREZWYiLCJncm91bmRBIiwiZ3JvdW5kQiIsIm1fZ3JvdW5kQW5jaG9yQSIsImdyb3VuZEFuY2hvckEiLCJtX2dyb3VuZEFuY2hvckIiLCJncm91bmRBbmNob3JCIiwibV9sZW5ndGhBIiwibGVuZ3RoQSIsIm1fbGVuZ3RoQiIsImxlbmd0aEIiLCJtX3VBIiwibV91QiIsImdldEdyb3VuZEFuY2hvckEiLCJnZXRHcm91bmRBbmNob3JCIiwiZ2V0TGVuZ3RoQSIsImdldExlbmd0aEIiLCJnZXRDdXJyZW50TGVuZ3RoQSIsImdldEN1cnJlbnRMZW5ndGhCIiwicnVBIiwicnVCIiwiUEEiLCJQQiIsInVBIiwidUIiLCJsb3dlckFuZ2xlIiwidXBwZXJBbmdsZSIsIm1heE1vdG9yVG9ycXVlIiwibV9sb3dlckFuZ2xlIiwibV91cHBlckFuZ2xlIiwibV9tYXhNb3RvclRvcnF1ZSIsImdldEpvaW50QW5nbGUiLCJnZXRNb3RvclRvcnF1ZSIsInNldE1heE1vdG9yVG9ycXVlIiwiam9pbnRBbmdsZSIsInJocyIsInJlZHVjZWQiLCJwb3NpdGlvbkVycm9yIiwibGltaXRJbXB1bHNlIiwibWF4TGVuZ3RoIiwibV9tYXhMZW5ndGgiLCJtX3N0YXRlIiwic2V0TWF4TGVuZ3RoIiwiZ2V0TWF4TGVuZ3RoIiwiZ2V0TGltaXRTdGF0ZSIsImNyQSIsImNyQiIsImludk0iLCJpbXB1bHNlMiIsIm1fbG9jYWxBeGlzIiwibV9zcHJpbmdNYXNzIiwibV9zcHJpbmdJbXB1bHNlIiwibV9heCIsIm1fYXkiLCJtX3NBeCIsIm1fc0J4IiwibV9zQXkiLCJtX3NCeSIsImdldE1heE1vdG9yVG9ycXVlIiwic2V0U3ByaW5nRnJlcXVlbmN5SHoiLCJnZXRTcHJpbmdGcmVxdWVuY3lIeiIsInNldFNwcmluZ0RhbXBpbmdSYXRpbyIsImdldFNwcmluZ0RhbXBpbmdSYXRpbyIsImF5Iiwic0F5Iiwic0J5IiwiQm94U2hhcGUiLCJQb2x5Z29uU2hhcGUiLCJoeCIsImh5IiwiX3NldEFzQm94IiwiQ2hhaW5TaGFwZSIsIkVkZ2VTaGFwZSIsIm1fcHJldlZlcnRleCIsIm1fbmV4dFZlcnRleCIsIm1faGFzUHJldlZlcnRleCIsIm1faGFzTmV4dFZlcnRleCIsIl9jcmVhdGVMb29wIiwiX2NyZWF0ZUNoYWluIiwidjEiLCJ2MiIsIl9zZXRQcmV2VmVydGV4IiwicHJldlZlcnRleCIsIl9zZXROZXh0VmVydGV4IiwibmV4dFZlcnRleCIsImNyZWF0ZUNoYWluIiwiZ2V0Q2hpbGRFZGdlIiwibV92ZXJ0ZXgxIiwibV92ZXJ0ZXgyIiwibV92ZXJ0ZXgwIiwibV9oYXNWZXJ0ZXgwIiwibV92ZXJ0ZXgzIiwibV9oYXNWZXJ0ZXgzIiwiZWRnZVNoYXBlIiwiQ2lyY2xlU2hhcGUiLCJtX3AiLCJyciIsInNpZ21hIiwiQ2lyY2xlQ2lyY2xlQ29udGFjdCIsIkNvbGxpZGVDaXJjbGVzIiwiY2NfcEEiLCJjY19wQiIsImNpcmNsZUEiLCJjaXJjbGVCIiwiZGlzdFNxciIsInJhZGl1cyIsIlBvbHlnb25DaXJjbGVDb250YWN0IiwiQ29sbGlkZVBvbHlnb25DaXJjbGUiLCJjcGNfYyIsImNwY19jTG9jYWwiLCJjcGNfdDEiLCJjcGNfdDIiLCJwb2x5Z29uQSIsImNMb2NhbCIsIm5vcm1hbEluZGV4IiwidmVydGV4Q291bnQiLCJub3JtYWxzIiwibV9ub3JtYWxzIiwidmVydEluZGV4MSIsInZlcnRJbmRleDIiLCJ1MSIsInUyIiwiZmFjZUNlbnRlciIsIkVkZ2VDaXJjbGVDb250YWN0IiwiQ2hhaW5DaXJjbGVDb250YWN0IiwiQ29sbGlkZUVkZ2VDaXJjbGUiLCJjY2NfZWRnZSIsImNoYWluIiwiY2VjX2UiLCJjZWNfUSIsImNlY19QIiwiY2VjX2QiLCJjZWNfbiIsImNlY19lMSIsImNlY19lMiIsImNlY190MSIsImVkZ2VBIiwiUSIsImRkIiwiQTEiLCJCMSIsImUxIiwiQjIiLCJBMiIsImUyIiwiZGVuIiwiRWRnZVBvbHlnb25Db250YWN0IiwiQ2hhaW5Qb2x5Z29uQ29udGFjdCIsIkNvbGxpZGVFZGdlUG9seWdvbiIsImNwY19lZGdlIiwiZV9lZGdlQSIsImVfZWRnZUIiLCJlX2lzb2xhdGVkIiwiZV9jb25jYXZlIiwiZV9jb252ZXgiLCJFUEF4aXMiLCJUZW1wUG9seWdvbiIsIlJlZmVyZW5jZUZhY2UiLCJpMSIsImkyIiwic2lkZU5vcm1hbDEiLCJzaWRlT2Zmc2V0MSIsInNpZGVOb3JtYWwyIiwic2lkZU9mZnNldDIiLCJlZGdlQXhpcyIsInBvbHlnb25BeGlzIiwicG9seWdvbkJBIiwicmYiLCJjZXBfdDEiLCJjZXBfdDIiLCJjZXBfbiIsImNlcF9wZXJwIiwiY2VwX2NlbnRyb2lkQiIsImNlcF9lZGdlMSIsImNlcF9ub3JtYWwxIiwiY2VwX2VkZ2UwIiwiY2VwX25vcm1hbDAiLCJjZXBfZWRnZTIiLCJjZXBfbm9ybWFsMiIsImNlcF9ub3JtYWwiLCJjZXBfbG93ZXJMaW1pdCIsImNlcF91cHBlckxpbWl0IiwiY2VwX3hmIiwiY2VwX2NsaXBQb2ludHMxIiwiY2VwX2NsaXBQb2ludHMyIiwiY2VwX2llIiwicG9seWdvbkIiLCJjZW50cm9pZEIiLCJtX2NlbnRyb2lkIiwidjAiLCJ2MyIsImhhc1ZlcnRleDAiLCJoYXNWZXJ0ZXgzIiwiZWRnZTEiLCJub3JtYWwxIiwib2Zmc2V0MSIsIm9mZnNldDAiLCJvZmZzZXQyIiwiY29udmV4MSIsImNvbnZleDIiLCJlZGdlMCIsIm5vcm1hbDAiLCJlZGdlMiIsIm5vcm1hbDIiLCJmcm9udCIsImxvd2VyTGltaXQiLCJ1cHBlckxpbWl0Iiwia19yZWxhdGl2ZVRvbCIsImtfYWJzb2x1dGVUb2wiLCJwcmltYXJ5QXhpcyIsImllIiwiY2xpcFBvaW50czEiLCJjbGlwUG9pbnRzMiIsIm5wIiwiUG9seWdvbkNvbnRhY3QiLCJmbXNfdjEiLCJmbXNfbiIsImZtc194ZiIsImZtc19tYXhTZXBhcmF0aW9uIiwiZm1zX2Jlc3RJbmRleCIsIkZpbmRNYXhTZXBhcmF0aW9uIiwicG9seTEiLCJwb2x5MiIsImNvdW50MSIsImNvdW50MiIsIm4xcyIsInYxcyIsInYycyIsIm1heFNlcGFyYXRpb24iLCJzaSIsInNpaiIsImZpZV90MSIsImZpZV9ub3JtYWwxIiwiRmluZEluY2lkZW50RWRnZSIsIm5vcm1hbHMxIiwidmVydGljZXMyIiwibm9ybWFsczIiLCJtaW5Eb3QiLCJjcGdfcGxhbmVQb2ludCIsImNwZ190YW5nZW50IiwiY3BnX25vcm1hbCIsImNwZ19sb2NhbFRhbmdlbnQiLCJjcGdfbG9jYWxOb3JtYWwiLCJjcGdfdjExIiwiY3BnX3YxMiIsImNwZ190MSIsImNwZ19jbGlwUG9pbnRzMSIsImNwZ19jbGlwUG9pbnRzMiIsImNwZ19pbmNpZGVudEVkZ2UiLCJwb2x5QSIsInBvbHlCIiwic2VwYXJhdGlvbkEiLCJlZGdlQiIsInNlcGFyYXRpb25CIiwiZmxpcCIsImtfdG9sIiwiaW5jaWRlbnRFZGdlIiwidmVydGljZXMxIiwiaXYxIiwiaXYyIiwidjExIiwidjEyIiwibG9jYWxUYW5nZW50IiwiZnJvbnRPZmZzZXQiLCJzZXROZXh0Iiwic2V0UHJldiIsIl9zZXQiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIkNvbXB1dGVDZW50cm9pZCIsInZzIiwicFJlZiIsImludjMiLCJwMyIsInRyaWFuZ2xlQXJlYSIsInBzIiwidGVtcENvdW50IiwidW5pcXVlIiwiaTAiLCJ4MCIsImh1bGwiLCJpaCIsInBMb2NhbCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJrX2ludjMiLCJleDEiLCJleTEiLCJleDIiLCJleTIiLCJpbnR4MiIsImludHkyIiwib3B0cyIsIl9xdWV1ZSIsIl9tYXgiLCJfY3JlYXRlRm4iLCJfb3V0Rm4iLCJfaW5GbiIsIl9kaXNjYXJkRm4iLCJkaXNjYXJkIiwiX2NyZWF0ZUNvdW50IiwiX291dENvdW50IiwiX2luQ291bnQiLCJfZGlzY2FyZENvdW50Iiwic2l6ZSIsInNoaWZ0IiwiRGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJhcHBseSIsImFyZ3VtZW50cyIsInN0YXRlbWVudCIsImVyciIsInByb3RvIiwicHJvcHMiLCJub29wIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG8iLCJmcm9tIiwiaGFzT3duUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltYm9sIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0QsQ0FBQyxTQUFTQSxDQUFDO0lBQUUsSUFBRyxZQUFVLE9BQU9DLFdBQVMsZUFBYSxPQUFPQyxRQUFPQSxPQUFPRCxPQUFPLEdBQUNEO1NBQVMsSUFBRyxjQUFZLE9BQU9HLFVBQVFBLE9BQU9DLEdBQUcsRUFBQ0QsT0FBTyxFQUFFLEVBQUNIO1NBQU87UUFBQyxJQUFJSztRQUFFLGVBQWEsT0FBT0MsU0FBT0QsSUFBRUMsU0FBTyxlQUFhLE9BQU9DLFNBQU9GLElBQUVFLFNBQU8sZUFBYSxPQUFPQyxRQUFPSCxDQUFBQSxJQUFFRyxJQUFHLEdBQUdILEVBQUVJLE1BQU0sR0FBQ1Q7SUFBRztBQUFDLEVBQUU7SUFBVyxJQUFJRyxTQUFPRCxTQUFPRDtJQUFRLE9BQU8sQUFBQyxDQUFBLFNBQVNELEVBQUVVLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsU0FBU0MsRUFBRUMsQ0FBQyxFQUFDQyxDQUFDO1lBQUUsSUFBRyxDQUFDSixDQUFDLENBQUNHLEVBQUUsRUFBQztnQkFBQyxJQUFHLENBQUNKLENBQUMsQ0FBQ0ksRUFBRSxFQUFDO29CQUFDLElBQUlFLElBQUUsT0FBT0MsV0FBUyxjQUFZQTtvQkFBUSxJQUFHLENBQUNGLEtBQUdDLEdBQUUsT0FBT0EsRUFBRUYsR0FBRSxDQUFDO29CQUFHLElBQUdJLEdBQUUsT0FBT0EsRUFBRUosR0FBRSxDQUFDO29CQUFHLElBQUlULElBQUUsSUFBSWMsTUFBTSx5QkFBdUJMLElBQUU7b0JBQUssTUFBTVQsRUFBRWUsSUFBSSxHQUFDLG9CQUFtQmY7Z0JBQUM7Z0JBQUMsSUFBSWdCLElBQUVWLENBQUMsQ0FBQ0csRUFBRSxHQUFDO29CQUFDYixTQUFRLENBQUM7Z0JBQUM7Z0JBQUVTLENBQUMsQ0FBQ0ksRUFBRSxDQUFDLEVBQUUsQ0FBQ1EsSUFBSSxDQUFDRCxFQUFFcEIsT0FBTyxFQUFDLFNBQVNELENBQUM7b0JBQUUsSUFBSVcsSUFBRUQsQ0FBQyxDQUFDSSxFQUFFLENBQUMsRUFBRSxDQUFDZCxFQUFFO29CQUFDLE9BQU9hLEVBQUVGLElBQUVBLElBQUVYO2dCQUFFLEdBQUVxQixHQUFFQSxFQUFFcEIsT0FBTyxFQUFDRCxHQUFFVSxHQUFFQyxHQUFFQztZQUFFO1lBQUMsT0FBT0QsQ0FBQyxDQUFDRyxFQUFFLENBQUNiLE9BQU87UUFBQTtRQUFDLElBQUlpQixJQUFFLE9BQU9ELFdBQVMsY0FBWUE7UUFBUSxJQUFJLElBQUlILElBQUUsR0FBRUEsSUFBRUYsRUFBRVcsTUFBTSxFQUFDVCxJQUFJRCxFQUFFRCxDQUFDLENBQUNFLEVBQUU7UUFBRSxPQUFPRDtJQUFDLENBQUEsRUFBRztRQUFDLEdBQUU7WUFBQyxTQUFTSSxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDbHlCQSxTQUFRdUIsUUFBUSxHQUFHLENBQUM7Z0JBRXBCdkIsU0FBUXdCLElBQUksR0FBR1IsU0FBUTtnQkFFdkJoQixTQUFReUIsSUFBSSxHQUFHVCxTQUFRO2dCQUV2QmhCLFNBQVEwQixJQUFJLEdBQUdWLFNBQVE7Z0JBRXZCaEIsU0FBUTJCLEtBQUssR0FBR1gsU0FBUTtnQkFFeEJoQixTQUFRNEIsS0FBSyxHQUFHWixTQUFRO2dCQUV4QmhCLFNBQVE2QixTQUFTLEdBQUdiLFNBQVE7Z0JBRTVCaEIsU0FBUThCLEdBQUcsR0FBR2QsU0FBUTtnQkFFdEJoQixTQUFRK0IsSUFBSSxHQUFHZixTQUFRO2dCQUV2QmhCLFNBQVFnQyxLQUFLLEdBQUdoQixTQUFRO2dCQUV4QmhCLFNBQVFpQyxPQUFPLEdBQUdqQixTQUFRO2dCQUUxQmhCLFNBQVFrQyxJQUFJLEdBQUdsQixTQUFRO2dCQUV2QmhCLFNBQVFtQyxPQUFPLEdBQUduQixTQUFRO2dCQUUxQmhCLFNBQVFvQyxLQUFLLEdBQUdwQixTQUFRO2dCQUV4QmhCLFNBQVFxQyxLQUFLLEdBQUdyQixTQUFRO2dCQUV4QmhCLFNBQVFzQyxNQUFNLEdBQUd0QixTQUFRO2dCQUV6QmhCLFNBQVF1QyxJQUFJLEdBQUd2QixTQUFRO2dCQUV2QmhCLFNBQVF3QyxPQUFPLEdBQUd4QixTQUFRO2dCQUUxQmhCLFNBQVF5QyxLQUFLLEdBQUd6QixTQUFRO2dCQUV4QmhCLFNBQVEwQyxHQUFHLEdBQUcxQixTQUFRO2dCQUV0QkEsU0FBUTtnQkFFUkEsU0FBUTtnQkFFUmhCLFNBQVF1QixRQUFRLENBQUNvQixlQUFlLEdBQUczQixTQUFRO2dCQUUzQ0EsU0FBUTtnQkFFUkEsU0FBUTtnQkFFUmhCLFNBQVE0QyxhQUFhLEdBQUc1QixTQUFRO2dCQUVoQ2hCLFNBQVE2QyxhQUFhLEdBQUc3QixTQUFRO2dCQUVoQ2hCLFNBQVE4QyxTQUFTLEdBQUc5QixTQUFRO2dCQUU1QmhCLFNBQVErQyxVQUFVLEdBQUcvQixTQUFRO2dCQUU3QmhCLFNBQVFnRCxVQUFVLEdBQUdoQyxTQUFRO2dCQUU3QmhCLFNBQVFpRCxjQUFjLEdBQUdqQyxTQUFRO2dCQUVqQ2hCLFNBQVFrRCxXQUFXLEdBQUdsQyxTQUFRO2dCQUU5QmhCLFNBQVFtRCxhQUFhLEdBQUduQyxTQUFRO2dCQUVoQ2hCLFNBQVFvRCxTQUFTLEdBQUdwQyxTQUFRO2dCQUU1QmhCLFNBQVFxRCxTQUFTLEdBQUdyQyxTQUFRO2dCQUU1QmhCLFNBQVFzRCxVQUFVLEdBQUd0QyxTQUFRO2dCQUU3QmhCLFNBQVF1QixRQUFRLENBQUNnQyxLQUFLLEdBQUd2QyxTQUFRO2dCQUVqQ2hCLFNBQVF1QixRQUFRLENBQUNpQyxLQUFLLEdBQUd4QyxTQUFRO2dCQUVqQ2hCLFNBQVF1QixRQUFRLENBQUNrQyxRQUFRLEdBQUd6QyxTQUFRO2dCQUVwQ2hCLFNBQVF1QixRQUFRLENBQUNtQyxRQUFRLEdBQUcxQyxTQUFRO2dCQUVwQ2hCLFNBQVF1QixRQUFRLENBQUNvQyxZQUFZLEdBQUczQyxTQUFRO2dCQUV4Q2hCLFNBQVF1QixRQUFRLENBQUNxQyxXQUFXLEdBQUc1QyxTQUFRO2dCQUV2Q2hCLFNBQVF1QixRQUFRLENBQUNzQyxRQUFRLEdBQUc3QyxTQUFRO1lBQ3BDO1lBQUU7Z0JBQUMsVUFBUztnQkFBRSxhQUFZO2dCQUFFLGFBQVk7Z0JBQUUsV0FBVTtnQkFBRSxjQUFhO2dCQUFFLGNBQWE7Z0JBQUUsV0FBVTtnQkFBRSxXQUFVO2dCQUFHLG9CQUFtQjtnQkFBRyx3QkFBdUI7Z0JBQUcsMkJBQTBCO2dCQUFHLDRCQUEyQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGlCQUFnQjtnQkFBRyxnQkFBZTtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsa0JBQWlCO2dCQUFHLHlCQUF3QjtnQkFBRyx5QkFBd0I7Z0JBQUcscUJBQW9CO2dCQUFHLHNCQUFxQjtnQkFBRyxzQkFBcUI7Z0JBQUcsMEJBQXlCO2dCQUFHLHVCQUFzQjtnQkFBRyx5QkFBd0I7Z0JBQUcscUJBQW9CO2dCQUFHLHFCQUFvQjtnQkFBRyxzQkFBcUI7Z0JBQUcsb0JBQW1CO2dCQUFHLHNCQUFxQjtnQkFBRyx1QkFBc0I7Z0JBQUcseUJBQXdCO2dCQUFHLGlDQUFnQztnQkFBRyw2QkFBNEI7Z0JBQUcsOEJBQTZCO2dCQUFHLDBCQUF5QjtnQkFBRyxxQkFBb0I7Z0JBQUcsd0JBQXVCO1lBQUU7U0FBRTtRQUFDLEdBQUU7WUFBQyxTQUFTQSxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDbjlCLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHa0M7Z0JBRWpCLElBQUlnQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSW1ELFVBQVVuRCxTQUFRO2dCQUV0QixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJYyxNQUFNZCxTQUFRO2dCQUVsQixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJdUMsUUFBUXZDLFNBQVE7Z0JBRXBCLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlvRCxXQUFXcEQsU0FBUTtnQkFFdkIsSUFBSXFELFdBQVdyRCxTQUFRO2dCQUV2QixJQUFJaUIsVUFBVWpCLFNBQVE7Z0JBRXRCLElBQUlnQixRQUFRaEIsU0FBUTtnQkFFcEIsSUFBSXFCLFFBQVFyQixTQUFRO2dCQUVwQixJQUFJc0QsYUFBYXBDLEtBQUtxQyxNQUFNLEdBQUc7Z0JBRS9CLElBQUlDLGdCQUFnQnRDLEtBQUt1QyxTQUFTLEdBQUc7Z0JBRXJDLElBQUlDLGNBQWN4QyxLQUFLeUMsT0FBTyxHQUFHO2dCQUVqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQyxHQUNELElBQUlDLFVBQVU7b0JBQ1ZDLE1BQU1QO29CQUNOUSxVQUFVckQsS0FBS3NELElBQUk7b0JBQ25CQyxPQUFPO29CQUNQQyxnQkFBZ0J4RCxLQUFLc0QsSUFBSTtvQkFDekJHLGlCQUFpQjtvQkFDakJDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGVBQWU7b0JBQ2ZDLFFBQVE7b0JBQ1JDLGNBQWM7b0JBQ2RDLFlBQVk7b0JBQ1pDLE9BQU87b0JBQ1BDLFFBQVE7b0JBQ1JDLFVBQVU7Z0JBQ2Q7Z0JBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU3pELEtBQUswRCxLQUFLLEVBQUVDLEdBQUc7b0JBQ3BCQSxNQUFNMUIsUUFBUTBCLEtBQUtqQjtvQkFDbkJaLFdBQVdFLFFBQU80QixNQUFNLENBQUNyRSxLQUFLc0UsT0FBTyxDQUFDRixJQUFJZixRQUFRO29CQUNsRGQsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3JFLEtBQUtzRSxPQUFPLENBQUNGLElBQUlaLGNBQWM7b0JBQ3hEakIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUt3RSxRQUFRLENBQUNILElBQUliLEtBQUs7b0JBQ2hEaEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUt3RSxRQUFRLENBQUNILElBQUlYLGVBQWU7b0JBQzFEbEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUt3RSxRQUFRLENBQUNILElBQUlULGNBQWMsS0FBS1MsSUFBSVQsY0FBYyxJQUFJO29CQUNwRnBCLFdBQVdFLFFBQU80QixNQUFNLENBQUN0RSxNQUFLd0UsUUFBUSxDQUFDSCxJQUFJVixhQUFhLEtBQUtVLElBQUlWLGFBQWEsSUFBSTtvQkFDbEYsSUFBSSxDQUFDYyxPQUFPLEdBQUdMO29CQUNmLElBQUksQ0FBQ00sV0FBVyxHQUFHTCxJQUFJSixLQUFLO29CQUM1QixJQUFJLENBQUNVLGVBQWUsR0FBR04sSUFBSUwsVUFBVTtvQkFDckMsSUFBSSxDQUFDWSxZQUFZLEdBQUdQLElBQUlQLE1BQU07b0JBQzlCLElBQUksQ0FBQ2UsbUJBQW1CLEdBQUdSLElBQUlSLGFBQWE7b0JBQzVDLElBQUksQ0FBQ2lCLFlBQVksR0FBR1QsSUFBSUgsTUFBTTtvQkFDOUIsSUFBSSxDQUFDYSxZQUFZLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO29CQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR1osSUFBSUYsUUFBUTtvQkFDOUIsSUFBSSxDQUFDZSxNQUFNLEdBQUdiLElBQUloQixJQUFJO29CQUN0QixJQUFJLElBQUksQ0FBQzZCLE1BQU0sSUFBSWhDLGFBQWE7d0JBQzVCLElBQUksQ0FBQ2lDLE1BQU0sR0FBRzt3QkFDZCxJQUFJLENBQUNDLFNBQVMsR0FBRztvQkFDckIsT0FBTzt3QkFDSCxJQUFJLENBQUNELE1BQU0sR0FBRzt3QkFDZCxJQUFJLENBQUNDLFNBQVMsR0FBRztvQkFDckI7b0JBQ0EsK0NBQStDO29CQUMvQyxJQUFJLENBQUNDLEdBQUcsR0FBRztvQkFDWCxJQUFJLENBQUNDLE1BQU0sR0FBRztvQkFDZCw0QkFBNEI7b0JBQzVCLElBQUksQ0FBQ0MsSUFBSSxHQUFHbEYsVUFBVW1GLFFBQVE7b0JBQzlCLElBQUksQ0FBQ0QsSUFBSSxDQUFDRSxDQUFDLEdBQUd4RixLQUFLeUYsS0FBSyxDQUFDckIsSUFBSWYsUUFBUTtvQkFDckMsSUFBSSxDQUFDaUMsSUFBSSxDQUFDSSxDQUFDLENBQUNDLFFBQVEsQ0FBQ3ZCLElBQUliLEtBQUs7b0JBQzlCLDJCQUEyQjtvQkFDM0IsSUFBSSxDQUFDcUMsT0FBTyxHQUFHLElBQUk5RDtvQkFDbkIsSUFBSSxDQUFDOEQsT0FBTyxDQUFDQyxZQUFZLENBQUMsSUFBSSxDQUFDUCxJQUFJO29CQUNuQyxtQ0FBbUM7b0JBQ25DLElBQUksQ0FBQ1EsVUFBVSxHQUFHLElBQUluRDtvQkFDdEIsSUFBSSxDQUFDb0QsVUFBVSxHQUFHLElBQUluRDtvQkFDdEIsSUFBSSxDQUFDb0QsT0FBTyxHQUFHaEcsS0FBS3NELElBQUk7b0JBQ3hCLElBQUksQ0FBQzJDLFFBQVEsR0FBRztvQkFDaEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR2xHLEtBQUt5RixLQUFLLENBQUNyQixJQUFJWixjQUFjO29CQUNyRCxJQUFJLENBQUMyQyxpQkFBaUIsR0FBRy9CLElBQUlYLGVBQWU7b0JBQzVDLElBQUksQ0FBQzJDLGVBQWUsR0FBR2hDLElBQUlWLGFBQWE7b0JBQ3hDLElBQUksQ0FBQzJDLGdCQUFnQixHQUFHakMsSUFBSVQsY0FBYztvQkFDMUMsSUFBSSxDQUFDMkMsY0FBYyxHQUFHbEMsSUFBSU4sWUFBWTtvQkFDdEMsSUFBSSxDQUFDeUMsV0FBVyxHQUFHO29CQUNuQixJQUFJLENBQUNDLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7b0JBQ3JCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUNDLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNDLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNDLFdBQVcsR0FBRztnQkFDdkI7Z0JBRUFwRyxLQUFLcUcsU0FBUyxDQUFDQyxhQUFhLEdBQUc7b0JBQzNCLE9BQU8sSUFBSSxDQUFDdkMsT0FBTyxJQUFJLElBQUksQ0FBQ0EsT0FBTyxDQUFDd0MsUUFBUSxLQUFLLE9BQU87Z0JBQzVEO2dCQUVBdkcsS0FBS3FHLFNBQVMsQ0FBQ0csUUFBUSxHQUFHO29CQUN0QixPQUFPLElBQUksQ0FBQ3pDLE9BQU87Z0JBQ3ZCO2dCQUVBL0QsS0FBS3FHLFNBQVMsQ0FBQ0ksT0FBTyxHQUFHO29CQUNyQixPQUFPLElBQUksQ0FBQ04sTUFBTTtnQkFDdEI7Z0JBRUFuRyxLQUFLcUcsU0FBUyxDQUFDSyxXQUFXLEdBQUcsU0FBU0MsSUFBSTtvQkFDdEMsSUFBSSxDQUFDcEMsVUFBVSxHQUFHb0M7Z0JBQ3RCO2dCQUVBM0csS0FBS3FHLFNBQVMsQ0FBQ08sV0FBVyxHQUFHO29CQUN6QixPQUFPLElBQUksQ0FBQ3JDLFVBQVU7Z0JBQzFCO2dCQUVBdkUsS0FBS3FHLFNBQVMsQ0FBQ1EsY0FBYyxHQUFHO29CQUM1QixPQUFPLElBQUksQ0FBQ1osYUFBYTtnQkFDN0I7Z0JBRUFqRyxLQUFLcUcsU0FBUyxDQUFDUyxZQUFZLEdBQUc7b0JBQzFCLE9BQU8sSUFBSSxDQUFDZixXQUFXO2dCQUMzQjtnQkFFQTs7O0NBR0MsR0FDRC9GLEtBQUtxRyxTQUFTLENBQUNVLGNBQWMsR0FBRztvQkFDNUIsT0FBTyxJQUFJLENBQUNmLGFBQWE7Z0JBQzdCO2dCQUVBaEcsS0FBS3FHLFNBQVMsQ0FBQ1csUUFBUSxHQUFHO29CQUN0QixPQUFPLElBQUksQ0FBQ3hDLE1BQU0sSUFBSXBDO2dCQUMxQjtnQkFFQXBDLEtBQUtxRyxTQUFTLENBQUNZLFNBQVMsR0FBRztvQkFDdkIsT0FBTyxJQUFJLENBQUN6QyxNQUFNLElBQUloQztnQkFDMUI7Z0JBRUF4QyxLQUFLcUcsU0FBUyxDQUFDYSxXQUFXLEdBQUc7b0JBQ3pCLE9BQU8sSUFBSSxDQUFDMUMsTUFBTSxJQUFJbEM7Z0JBQzFCO2dCQUVBOztDQUVDLEdBQ0R0QyxLQUFLcUcsU0FBUyxDQUFDYyxTQUFTLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQ0MsT0FBTyxDQUFDaEY7b0JBQ2IsT0FBTyxJQUFJO2dCQUNmO2dCQUVBcEMsS0FBS3FHLFNBQVMsQ0FBQ2dCLFVBQVUsR0FBRztvQkFDeEIsSUFBSSxDQUFDRCxPQUFPLENBQUM1RTtvQkFDYixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUF4QyxLQUFLcUcsU0FBUyxDQUFDaUIsWUFBWSxHQUFHO29CQUMxQixJQUFJLENBQUNGLE9BQU8sQ0FBQzlFO29CQUNiLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7Q0FFQyxHQUNEdEMsS0FBS3FHLFNBQVMsQ0FBQ2tCLE9BQU8sR0FBRztvQkFDckIsT0FBTyxJQUFJLENBQUMvQyxNQUFNO2dCQUN0QjtnQkFFQTs7O0NBR0MsR0FDRHhFLEtBQUtxRyxTQUFTLENBQUNlLE9BQU8sR0FBRyxTQUFTekUsSUFBSTtvQkFDbENiLFdBQVdFLFFBQU80QixNQUFNLENBQUNqQixTQUFTUCxjQUFjTyxTQUFTTCxpQkFBaUJLLFNBQVNIO29CQUNuRlYsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxJQUFJLENBQUMwQyxhQUFhLE1BQU07b0JBQ2pELElBQUksSUFBSSxDQUFDQSxhQUFhLE1BQU0sTUFBTTt3QkFDOUI7b0JBQ0o7b0JBQ0EsSUFBSSxJQUFJLENBQUM5QixNQUFNLElBQUk3QixNQUFNO3dCQUNyQjtvQkFDSjtvQkFDQSxJQUFJLENBQUM2QixNQUFNLEdBQUc3QjtvQkFDZCxJQUFJLENBQUM2RSxhQUFhO29CQUNsQixJQUFJLElBQUksQ0FBQ2hELE1BQU0sSUFBSXBDLFlBQVk7d0JBQzNCLElBQUksQ0FBQ3FELGdCQUFnQixDQUFDZ0MsT0FBTzt3QkFDN0IsSUFBSSxDQUFDL0IsaUJBQWlCLEdBQUc7d0JBQ3pCLElBQUksQ0FBQ1AsT0FBTyxDQUFDdUMsT0FBTzt3QkFDcEIsSUFBSSxDQUFDQyxtQkFBbUI7b0JBQzVCO29CQUNBLElBQUksQ0FBQ0MsUUFBUSxDQUFDO29CQUNkLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQ2tDLE9BQU87b0JBQ3BCLElBQUksQ0FBQ2pDLFFBQVEsR0FBRztvQkFDaEIsZ0NBQWdDO29CQUNoQyxJQUFJcUMsS0FBSyxJQUFJLENBQUM3QixhQUFhO29CQUMzQixNQUFPNkIsR0FBSTt3QkFDUCxJQUFJQyxNQUFNRDt3QkFDVkEsS0FBS0EsR0FBR0UsSUFBSTt3QkFDWixJQUFJLENBQUNoRSxPQUFPLENBQUNpRSxjQUFjLENBQUNGLElBQUlHLE9BQU87b0JBQzNDO29CQUNBLElBQUksQ0FBQ2pDLGFBQWEsR0FBRztvQkFDckIsNEVBQTRFO29CQUM1RSxJQUFJa0MsYUFBYSxJQUFJLENBQUNuRSxPQUFPLENBQUNvRSxZQUFZO29CQUMxQyxJQUFLLElBQUlqSyxJQUFJLElBQUksQ0FBQytILGFBQWEsRUFBRS9ILEdBQUdBLElBQUlBLEVBQUVpSSxNQUFNLENBQUU7d0JBQzlDLElBQUlpQyxhQUFhbEssRUFBRW1LLFlBQVk7d0JBQy9CLElBQUssSUFBSXRKLElBQUksR0FBR0EsSUFBSXFKLFlBQVksRUFBRXJKLEVBQUc7NEJBQ2pDbUosV0FBV0ksVUFBVSxDQUFDcEssRUFBRXFLLFNBQVMsQ0FBQ3hKLEVBQUUsQ0FBQ3lKLE9BQU87d0JBQ2hEO29CQUNKO2dCQUNKO2dCQUVBeEksS0FBS3FHLFNBQVMsQ0FBQ29DLFFBQVEsR0FBRztvQkFDdEIsT0FBTyxJQUFJLENBQUN2RSxZQUFZO2dCQUM1QjtnQkFFQTs7Q0FFQyxHQUNEbEUsS0FBS3FHLFNBQVMsQ0FBQ3FDLFNBQVMsR0FBRyxTQUFTQyxJQUFJO29CQUNwQyxJQUFJLENBQUN6RSxZQUFZLEdBQUcsQ0FBQyxDQUFDeUU7Z0JBQzFCO2dCQUVBM0ksS0FBS3FHLFNBQVMsQ0FBQ3VDLGlCQUFpQixHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQzNFLGVBQWU7Z0JBQy9CO2dCQUVBakUsS0FBS3FHLFNBQVMsQ0FBQ3dDLGtCQUFrQixHQUFHLFNBQVNGLElBQUk7b0JBQzdDLElBQUksQ0FBQzFFLGVBQWUsR0FBRyxDQUFDLENBQUMwRTtvQkFDekIsSUFBSSxJQUFJLENBQUMxRSxlQUFlLElBQUksT0FBTzt3QkFDL0IsSUFBSSxDQUFDMkQsUUFBUSxDQUFDO29CQUNsQjtnQkFDSjtnQkFFQTVILEtBQUtxRyxTQUFTLENBQUN5QyxPQUFPLEdBQUc7b0JBQ3JCLE9BQU8sSUFBSSxDQUFDOUUsV0FBVztnQkFDM0I7Z0JBRUE7Ozs7Q0FJQyxHQUNEaEUsS0FBS3FHLFNBQVMsQ0FBQ3VCLFFBQVEsR0FBRyxTQUFTZSxJQUFJO29CQUNuQyxJQUFJQSxNQUFNO3dCQUNOLElBQUksSUFBSSxDQUFDM0UsV0FBVyxJQUFJLE9BQU87NEJBQzNCLElBQUksQ0FBQ0EsV0FBVyxHQUFHOzRCQUNuQixJQUFJLENBQUM4QixXQUFXLEdBQUc7d0JBQ3ZCO29CQUNKLE9BQU87d0JBQ0gsSUFBSSxDQUFDOUIsV0FBVyxHQUFHO3dCQUNuQixJQUFJLENBQUM4QixXQUFXLEdBQUc7d0JBQ25CLElBQUksQ0FBQ0wsZ0JBQWdCLENBQUNnQyxPQUFPO3dCQUM3QixJQUFJLENBQUMvQixpQkFBaUIsR0FBRzt3QkFDekIsSUFBSSxDQUFDSCxPQUFPLENBQUNrQyxPQUFPO3dCQUNwQixJQUFJLENBQUNqQyxRQUFRLEdBQUc7b0JBQ3BCO2dCQUNKO2dCQUVBeEYsS0FBS3FHLFNBQVMsQ0FBQzBDLFFBQVEsR0FBRztvQkFDdEIsT0FBTyxJQUFJLENBQUMzRSxZQUFZO2dCQUM1QjtnQkFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRHBFLEtBQUtxRyxTQUFTLENBQUMyQyxTQUFTLEdBQUcsU0FBU0wsSUFBSTtvQkFDcEM3RyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQzBDLGFBQWEsTUFBTTtvQkFDakQsSUFBSXFDLFFBQVEsSUFBSSxDQUFDdkUsWUFBWSxFQUFFO3dCQUMzQjtvQkFDSjtvQkFDQSxJQUFJLENBQUNBLFlBQVksR0FBRyxDQUFDLENBQUN1RTtvQkFDdEIsSUFBSSxJQUFJLENBQUN2RSxZQUFZLEVBQUU7d0JBQ25CLHNCQUFzQjt3QkFDdEIsSUFBSThELGFBQWEsSUFBSSxDQUFDbkUsT0FBTyxDQUFDb0UsWUFBWTt3QkFDMUMsSUFBSyxJQUFJakssSUFBSSxJQUFJLENBQUMrSCxhQUFhLEVBQUUvSCxHQUFHQSxJQUFJQSxFQUFFaUksTUFBTSxDQUFFOzRCQUM5Q2pJLEVBQUUrSyxhQUFhLENBQUNmLFlBQVksSUFBSSxDQUFDckQsSUFBSTt3QkFDekM7b0JBQ0osT0FBTzt3QkFDSCx1QkFBdUI7d0JBQ3ZCLElBQUlxRCxhQUFhLElBQUksQ0FBQ25FLE9BQU8sQ0FBQ29FLFlBQVk7d0JBQzFDLElBQUssSUFBSWpLLElBQUksSUFBSSxDQUFDK0gsYUFBYSxFQUFFL0gsR0FBR0EsSUFBSUEsRUFBRWlJLE1BQU0sQ0FBRTs0QkFDOUNqSSxFQUFFZ0wsY0FBYyxDQUFDaEI7d0JBQ3JCO3dCQUNBLGlDQUFpQzt3QkFDakMsSUFBSUwsS0FBSyxJQUFJLENBQUM3QixhQUFhO3dCQUMzQixNQUFPNkIsR0FBSTs0QkFDUCxJQUFJQyxNQUFNRDs0QkFDVkEsS0FBS0EsR0FBR0UsSUFBSTs0QkFDWixJQUFJLENBQUNoRSxPQUFPLENBQUNpRSxjQUFjLENBQUNGLElBQUlHLE9BQU87d0JBQzNDO3dCQUNBLElBQUksQ0FBQ2pDLGFBQWEsR0FBRztvQkFDekI7Z0JBQ0o7Z0JBRUFoRyxLQUFLcUcsU0FBUyxDQUFDOEMsZUFBZSxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQ2hGLG1CQUFtQjtnQkFDbkM7Z0JBRUE7O0NBRUMsR0FDRG5FLEtBQUtxRyxTQUFTLENBQUMrQyxnQkFBZ0IsR0FBRyxTQUFTVCxJQUFJO29CQUMzQyxJQUFJLElBQUksQ0FBQ3hFLG1CQUFtQixJQUFJd0UsTUFBTTt3QkFDbEM7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDeEUsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDd0U7b0JBQzdCLElBQUksQ0FBQ2pELGlCQUFpQixHQUFHO29CQUN6QixJQUFJLENBQUM4QixhQUFhO2dCQUN0QjtnQkFFQTs7Q0FFQyxHQUNEeEgsS0FBS3FHLFNBQVMsQ0FBQ2dELFlBQVksR0FBRztvQkFDMUIsT0FBTyxJQUFJLENBQUN4RSxJQUFJO2dCQUNwQjtnQkFFQTs7Ozs7OztDQU9DLEdBQ0Q3RSxLQUFLcUcsU0FBUyxDQUFDakIsWUFBWSxHQUFHLFNBQVN4QyxRQUFRLEVBQUVFLEtBQUs7b0JBQ2xEaEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxJQUFJLENBQUMwQyxhQUFhLE1BQU07b0JBQ2pELElBQUksSUFBSSxDQUFDQSxhQUFhLE1BQU0sTUFBTTt3QkFDOUI7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDekIsSUFBSSxDQUFDeUUsR0FBRyxDQUFDMUcsVUFBVUU7b0JBQ3hCLElBQUksQ0FBQ3FDLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDLElBQUksQ0FBQ1AsSUFBSTtvQkFDbkMsSUFBSXFELGFBQWEsSUFBSSxDQUFDbkUsT0FBTyxDQUFDb0UsWUFBWTtvQkFDMUMsSUFBSyxJQUFJakssSUFBSSxJQUFJLENBQUMrSCxhQUFhLEVBQUUvSCxHQUFHQSxJQUFJQSxFQUFFaUksTUFBTSxDQUFFO3dCQUM5Q2pJLEVBQUVxTCxXQUFXLENBQUNyQixZQUFZLElBQUksQ0FBQ3JELElBQUksRUFBRSxJQUFJLENBQUNBLElBQUk7b0JBQ2xEO2dCQUNKO2dCQUVBN0UsS0FBS3FHLFNBQVMsQ0FBQ21ELG9CQUFvQixHQUFHO29CQUNsQyxJQUFJLENBQUNyRSxPQUFPLENBQUNrRSxZQUFZLENBQUMsSUFBSSxDQUFDeEUsSUFBSSxFQUFFO2dCQUN6QztnQkFFQTs7Q0FFQyxHQUNEN0UsS0FBS3FHLFNBQVMsQ0FBQ3NCLG1CQUFtQixHQUFHO29CQUNqQyxJQUFJOEIsS0FBSzlKLFVBQVVtRixRQUFRO29CQUMzQixJQUFJLENBQUNLLE9BQU8sQ0FBQ2tFLFlBQVksQ0FBQ0ksSUFBSTtvQkFDOUIsSUFBSXZCLGFBQWEsSUFBSSxDQUFDbkUsT0FBTyxDQUFDb0UsWUFBWTtvQkFDMUMsSUFBSyxJQUFJakssSUFBSSxJQUFJLENBQUMrSCxhQUFhLEVBQUUvSCxHQUFHQSxJQUFJQSxFQUFFaUksTUFBTSxDQUFFO3dCQUM5Q2pJLEVBQUVxTCxXQUFXLENBQUNyQixZQUFZdUIsSUFBSSxJQUFJLENBQUM1RSxJQUFJO29CQUMzQztnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEN0UsS0FBS3FHLFNBQVMsQ0FBQ3FELE9BQU8sR0FBRyxTQUFTQyxLQUFLO29CQUNuQyxtRUFBbUU7b0JBQ25FLElBQUksQ0FBQ3hFLE9BQU8sQ0FBQ3VFLE9BQU8sQ0FBQ0M7b0JBQ3JCLElBQUksQ0FBQ3hFLE9BQU8sQ0FBQ3lFLENBQUMsQ0FBQ04sR0FBRyxDQUFDLElBQUksQ0FBQ25FLE9BQU8sQ0FBQzBFLEVBQUU7b0JBQ2xDLElBQUksQ0FBQzFFLE9BQU8sQ0FBQ3RHLENBQUMsR0FBRyxJQUFJLENBQUNzRyxPQUFPLENBQUMyRSxFQUFFO29CQUNoQyxJQUFJLENBQUMzRSxPQUFPLENBQUNrRSxZQUFZLENBQUMsSUFBSSxDQUFDeEUsSUFBSSxFQUFFO2dCQUN6QztnQkFFQTs7Q0FFQyxHQUNEN0UsS0FBS3FHLFNBQVMsQ0FBQzBELFdBQVcsR0FBRztvQkFDekIsT0FBTyxJQUFJLENBQUNsRixJQUFJLENBQUNFLENBQUM7Z0JBQ3RCO2dCQUVBL0UsS0FBS3FHLFNBQVMsQ0FBQzJELFdBQVcsR0FBRyxTQUFTakYsQ0FBQztvQkFDbkMsSUFBSSxDQUFDSyxZQUFZLENBQUNMLEdBQUcsSUFBSSxDQUFDSSxPQUFPLENBQUN0RyxDQUFDO2dCQUN2QztnQkFFQTs7Q0FFQyxHQUNEbUIsS0FBS3FHLFNBQVMsQ0FBQzRELFFBQVEsR0FBRztvQkFDdEIsT0FBTyxJQUFJLENBQUM5RSxPQUFPLENBQUN0RyxDQUFDO2dCQUN6QjtnQkFFQW1CLEtBQUtxRyxTQUFTLENBQUNuQixRQUFRLEdBQUcsU0FBU3BDLEtBQUs7b0JBQ3BDLElBQUksQ0FBQ3NDLFlBQVksQ0FBQyxJQUFJLENBQUNQLElBQUksQ0FBQ0UsQ0FBQyxFQUFFakM7Z0JBQ25DO2dCQUVBOztDQUVDLEdBQ0Q5QyxLQUFLcUcsU0FBUyxDQUFDNkQsY0FBYyxHQUFHO29CQUM1QixPQUFPLElBQUksQ0FBQy9FLE9BQU8sQ0FBQ3lFLENBQUM7Z0JBQ3pCO2dCQUVBOztDQUVDLEdBQ0Q1SixLQUFLcUcsU0FBUyxDQUFDOEQsY0FBYyxHQUFHO29CQUM1QixPQUFPLElBQUksQ0FBQ2hGLE9BQU8sQ0FBQ2lGLFdBQVc7Z0JBQ25DO2dCQUVBOzs7O0NBSUMsR0FDRHBLLEtBQUtxRyxTQUFTLENBQUNnRSxpQkFBaUIsR0FBRztvQkFDL0IsT0FBTyxJQUFJLENBQUM1RSxnQkFBZ0I7Z0JBQ2hDO2dCQUVBOzs7O0NBSUMsR0FDRHpGLEtBQUtxRyxTQUFTLENBQUNpRSwrQkFBK0IsR0FBRyxTQUFTQyxVQUFVO29CQUNoRSxJQUFJSCxjQUFjN0ssS0FBS2lMLEdBQUcsQ0FBQ0QsWUFBWSxJQUFJLENBQUNwRixPQUFPLENBQUN5RSxDQUFDO29CQUNyRCxPQUFPckssS0FBS2tMLEdBQUcsQ0FBQyxJQUFJLENBQUNoRixnQkFBZ0IsRUFBRWxHLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaEYsaUJBQWlCLEVBQUUwRTtnQkFDOUU7Z0JBRUE7Ozs7Q0FJQyxHQUNEcEssS0FBS3FHLFNBQVMsQ0FBQ3NFLCtCQUErQixHQUFHLFNBQVNDLFVBQVU7b0JBQ2hFLE9BQU8sSUFBSSxDQUFDTiwrQkFBK0IsQ0FBQyxJQUFJLENBQUNPLGFBQWEsQ0FBQ0Q7Z0JBQ25FO2dCQUVBOzs7O0NBSUMsR0FDRDVLLEtBQUtxRyxTQUFTLENBQUN5RSxpQkFBaUIsR0FBRyxTQUFTQyxDQUFDO29CQUN6QyxJQUFJLElBQUksQ0FBQ3ZHLE1BQU0sSUFBSXBDLFlBQVk7d0JBQzNCO29CQUNKO29CQUNBLElBQUk3QyxLQUFLeUwsR0FBRyxDQUFDRCxHQUFHQSxLQUFLLEdBQUc7d0JBQ3BCLElBQUksQ0FBQ25ELFFBQVEsQ0FBQztvQkFDbEI7b0JBQ0EsSUFBSSxDQUFDbkMsZ0JBQWdCLENBQUM2RCxHQUFHLENBQUN5QjtnQkFDOUI7Z0JBRUE7Ozs7Q0FJQyxHQUNEL0ssS0FBS3FHLFNBQVMsQ0FBQzRFLGtCQUFrQixHQUFHO29CQUNoQyxPQUFPLElBQUksQ0FBQ3ZGLGlCQUFpQjtnQkFDakM7Z0JBRUE7Ozs7Q0FJQyxHQUNEMUYsS0FBS3FHLFNBQVMsQ0FBQzZFLGtCQUFrQixHQUFHLFNBQVNDLENBQUM7b0JBQzFDLElBQUksSUFBSSxDQUFDM0csTUFBTSxJQUFJcEMsWUFBWTt3QkFDM0I7b0JBQ0o7b0JBQ0EsSUFBSStJLElBQUlBLElBQUksR0FBRzt3QkFDWCxJQUFJLENBQUN2RCxRQUFRLENBQUM7b0JBQ2xCO29CQUNBLElBQUksQ0FBQ2xDLGlCQUFpQixHQUFHeUY7Z0JBQzdCO2dCQUVBbkwsS0FBS3FHLFNBQVMsQ0FBQytFLGdCQUFnQixHQUFHO29CQUM5QixPQUFPLElBQUksQ0FBQ3pGLGVBQWU7Z0JBQy9CO2dCQUVBM0YsS0FBS3FHLFNBQVMsQ0FBQ2dGLGdCQUFnQixHQUFHLFNBQVNwSSxhQUFhO29CQUNwRCxJQUFJLENBQUMwQyxlQUFlLEdBQUcxQztnQkFDM0I7Z0JBRUFqRCxLQUFLcUcsU0FBUyxDQUFDaUYsaUJBQWlCLEdBQUc7b0JBQy9CLE9BQU8sSUFBSSxDQUFDMUYsZ0JBQWdCO2dCQUNoQztnQkFFQTVGLEtBQUtxRyxTQUFTLENBQUNrRixpQkFBaUIsR0FBRyxTQUFTckksY0FBYztvQkFDdEQsSUFBSSxDQUFDMEMsZ0JBQWdCLEdBQUcxQztnQkFDNUI7Z0JBRUFsRCxLQUFLcUcsU0FBUyxDQUFDbUYsZUFBZSxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQzNGLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0Q3RixLQUFLcUcsU0FBUyxDQUFDb0YsZUFBZSxHQUFHLFNBQVNDLEtBQUs7b0JBQzNDLElBQUksQ0FBQzdGLGNBQWMsR0FBRzZGO2dCQUMxQjtnQkFFQTs7OztDQUlDLEdBQ0QxTCxLQUFLcUcsU0FBUyxDQUFDc0YsT0FBTyxHQUFHO29CQUNyQixPQUFPLElBQUksQ0FBQ2xILE1BQU07Z0JBQ3RCO2dCQUVBOzs7O0NBSUMsR0FDRHpFLEtBQUtxRyxTQUFTLENBQUN1RixVQUFVLEdBQUc7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDakgsR0FBRyxHQUFHLElBQUksQ0FBQ0YsTUFBTSxHQUFHbEYsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUM3RixPQUFPLENBQUNpRixXQUFXLEVBQUUsSUFBSSxDQUFDakYsT0FBTyxDQUFDaUYsV0FBVztnQkFDL0Y7Z0JBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVN5QjtvQkFDTCxJQUFJLENBQUNDLElBQUksR0FBRztvQkFDWixJQUFJLENBQUNDLE1BQU0sR0FBR3hNLEtBQUtzRCxJQUFJO29CQUN2QixJQUFJLENBQUNtSixDQUFDLEdBQUc7Z0JBQ2I7Z0JBRUE7O0NBRUMsR0FDRGhNLEtBQUtxRyxTQUFTLENBQUM0RixXQUFXLEdBQUcsU0FBU3RGLElBQUk7b0JBQ3RDQSxLQUFLbUYsSUFBSSxHQUFHLElBQUksQ0FBQ3JILE1BQU07b0JBQ3ZCa0MsS0FBS3FGLENBQUMsR0FBRyxJQUFJLENBQUNKLFVBQVU7b0JBQ3hCakYsS0FBS29GLE1BQU0sQ0FBQ3pDLEdBQUcsQ0FBQyxJQUFJLENBQUNuRSxPQUFPLENBQUNpRixXQUFXO2dCQUM1QztnQkFFQTs7OztDQUlDLEdBQ0RwSyxLQUFLcUcsU0FBUyxDQUFDbUIsYUFBYSxHQUFHO29CQUMzQixpRUFBaUU7b0JBQ2pFLElBQUksQ0FBQy9DLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNDLFNBQVMsR0FBRztvQkFDakIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7b0JBQ1gsSUFBSSxDQUFDQyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDTyxPQUFPLENBQUNpRixXQUFXLENBQUMzQyxPQUFPO29CQUNoQyw4Q0FBOEM7b0JBQzlDLElBQUksSUFBSSxDQUFDVCxRQUFRLE1BQU0sSUFBSSxDQUFDRSxXQUFXLElBQUk7d0JBQ3ZDLElBQUksQ0FBQy9CLE9BQU8sQ0FBQzBFLEVBQUUsQ0FBQ1AsR0FBRyxDQUFDLElBQUksQ0FBQ3pFLElBQUksQ0FBQ0UsQ0FBQzt3QkFDL0IsSUFBSSxDQUFDSSxPQUFPLENBQUN5RSxDQUFDLENBQUNOLEdBQUcsQ0FBQyxJQUFJLENBQUN6RSxJQUFJLENBQUNFLENBQUM7d0JBQzlCLElBQUksQ0FBQ0ksT0FBTyxDQUFDMkUsRUFBRSxHQUFHLElBQUksQ0FBQzNFLE9BQU8sQ0FBQ3RHLENBQUM7d0JBQ2hDO29CQUNKO29CQUNBaUQsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxJQUFJLENBQUNxRCxTQUFTO29CQUN2QyxxQ0FBcUM7b0JBQ3JDLElBQUltRCxjQUFjN0ssS0FBS3NELElBQUk7b0JBQzNCLElBQUssSUFBSTNFLElBQUksSUFBSSxDQUFDK0gsYUFBYSxFQUFFL0gsR0FBR0EsSUFBSUEsRUFBRWlJLE1BQU0sQ0FBRTt3QkFDOUMsSUFBSWpJLEVBQUVnTyxTQUFTLElBQUksR0FBRzs0QkFDbEI7d0JBQ0o7d0JBQ0EsSUFBSUMsV0FBVyxJQUFJTjt3QkFDbkIzTixFQUFFK04sV0FBVyxDQUFDRTt3QkFDZCxJQUFJLENBQUMxSCxNQUFNLElBQUkwSCxTQUFTTCxJQUFJO3dCQUM1QjFCLFlBQVlnQyxNQUFNLENBQUNELFNBQVNMLElBQUksRUFBRUssU0FBU0osTUFBTTt3QkFDakQsSUFBSSxDQUFDcEgsR0FBRyxJQUFJd0gsU0FBU0gsQ0FBQztvQkFDMUI7b0JBQ0EsMEJBQTBCO29CQUMxQixJQUFJLElBQUksQ0FBQ3ZILE1BQU0sR0FBRyxHQUFHO3dCQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBQ0QsTUFBTTt3QkFDaEMyRixZQUFZaUMsR0FBRyxDQUFDLElBQUksQ0FBQzNILFNBQVM7b0JBQ2xDLE9BQU87d0JBQ0gsb0RBQW9EO3dCQUNwRCxJQUFJLENBQUNELE1BQU0sR0FBRzt3QkFDZCxJQUFJLENBQUNDLFNBQVMsR0FBRztvQkFDckI7b0JBQ0EsSUFBSSxJQUFJLENBQUNDLEdBQUcsR0FBRyxLQUFLLElBQUksQ0FBQ1IsbUJBQW1CLElBQUksT0FBTzt3QkFDbkQsK0NBQStDO3dCQUMvQyxJQUFJLENBQUNRLEdBQUcsSUFBSSxJQUFJLENBQUNGLE1BQU0sR0FBR2xGLEtBQUt5TCxHQUFHLENBQUNaLGFBQWFBO3dCQUNoRHRJLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDZSxHQUFHLEdBQUc7d0JBQ3BDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDRCxHQUFHO29CQUM5QixPQUFPO3dCQUNILElBQUksQ0FBQ0EsR0FBRyxHQUFHO3dCQUNYLElBQUksQ0FBQ0MsTUFBTSxHQUFHO29CQUNsQjtvQkFDQSx1QkFBdUI7b0JBQ3ZCLElBQUkwSCxZQUFZL00sS0FBS3lGLEtBQUssQ0FBQyxJQUFJLENBQUNHLE9BQU8sQ0FBQ3lFLENBQUM7b0JBQ3pDLElBQUksQ0FBQ3pFLE9BQU8sQ0FBQ29ILGNBQWMsQ0FBQ25DLGFBQWEsSUFBSSxDQUFDdkYsSUFBSTtvQkFDbEQsa0NBQWtDO29CQUNsQyxJQUFJLENBQUNZLGdCQUFnQixDQUFDZ0YsR0FBRyxDQUFDbEwsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNoRixpQkFBaUIsRUFBRW5HLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDckYsT0FBTyxDQUFDeUUsQ0FBQyxFQUFFMEM7Z0JBQzFGO2dCQUVBOzs7Ozs7O0NBT0MsR0FDRHRNLEtBQUtxRyxTQUFTLENBQUNtRyxXQUFXLEdBQUcsU0FBU0wsUUFBUTtvQkFDMUNySyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQzBDLGFBQWEsTUFBTTtvQkFDakQsSUFBSSxJQUFJLENBQUNBLGFBQWEsTUFBTSxNQUFNO3dCQUM5QjtvQkFDSjtvQkFDQSxJQUFJLElBQUksQ0FBQzlCLE1BQU0sSUFBSWhDLGFBQWE7d0JBQzVCO29CQUNKO29CQUNBLElBQUksQ0FBQ2tDLFNBQVMsR0FBRztvQkFDakIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7b0JBQ1gsSUFBSSxDQUFDQyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDSCxNQUFNLEdBQUcwSCxTQUFTTCxJQUFJO29CQUMzQixJQUFJLElBQUksQ0FBQ3JILE1BQU0sSUFBSSxHQUFHO3dCQUNsQixJQUFJLENBQUNBLE1BQU0sR0FBRztvQkFDbEI7b0JBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUNELE1BQU07b0JBQ2hDLElBQUkwSCxTQUFTSCxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUM3SCxtQkFBbUIsSUFBSSxPQUFPO3dCQUNyRCxJQUFJLENBQUNRLEdBQUcsR0FBR3dILFNBQVNILENBQUMsR0FBRyxJQUFJLENBQUN2SCxNQUFNLEdBQUdsRixLQUFLeUwsR0FBRyxDQUFDbUIsU0FBU0osTUFBTSxFQUFFSSxTQUFTSixNQUFNO3dCQUMvRWpLLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDZSxHQUFHLEdBQUc7d0JBQ3BDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDRCxHQUFHO29CQUM5QjtvQkFDQSx1QkFBdUI7b0JBQ3ZCLElBQUkySCxZQUFZL00sS0FBS3lGLEtBQUssQ0FBQyxJQUFJLENBQUNHLE9BQU8sQ0FBQ3lFLENBQUM7b0JBQ3pDLElBQUksQ0FBQ3pFLE9BQU8sQ0FBQ29ILGNBQWMsQ0FBQ0osU0FBU0osTUFBTSxFQUFFLElBQUksQ0FBQ2xILElBQUk7b0JBQ3RELGtDQUFrQztvQkFDbEMsSUFBSSxDQUFDWSxnQkFBZ0IsQ0FBQ2dGLEdBQUcsQ0FBQ2xMLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaEYsaUJBQWlCLEVBQUVuRyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3JGLE9BQU8sQ0FBQ3lFLENBQUMsRUFBRTBDO2dCQUMxRjtnQkFFQTs7Ozs7Ozs7Q0FRQyxHQUNEdE0sS0FBS3FHLFNBQVMsQ0FBQ29HLFVBQVUsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtvQkFDbkQsSUFBSSxJQUFJLENBQUNwSSxNQUFNLElBQUloQyxhQUFhO3dCQUM1QjtvQkFDSjtvQkFDQSxJQUFJb0ssUUFBUSxJQUFJLENBQUM1SSxXQUFXLElBQUksT0FBTzt3QkFDbkMsSUFBSSxDQUFDNEQsUUFBUSxDQUFDO29CQUNsQjtvQkFDQSxvREFBb0Q7b0JBQ3BELElBQUksSUFBSSxDQUFDNUQsV0FBVyxFQUFFO3dCQUNsQixJQUFJLENBQUN1QixPQUFPLENBQUNrRixHQUFHLENBQUNpQzt3QkFDakIsSUFBSSxDQUFDbEgsUUFBUSxJQUFJakcsS0FBS21MLEtBQUssQ0FBQ25MLEtBQUtpTCxHQUFHLENBQUNtQyxPQUFPLElBQUksQ0FBQ3hILE9BQU8sQ0FBQ3lFLENBQUMsR0FBRzhDO29CQUNqRTtnQkFDSjtnQkFFQTs7Ozs7Q0FLQyxHQUNEMU0sS0FBS3FHLFNBQVMsQ0FBQ3dHLGtCQUFrQixHQUFHLFNBQVNILEtBQUssRUFBRUUsSUFBSTtvQkFDcEQsSUFBSSxJQUFJLENBQUNwSSxNQUFNLElBQUloQyxhQUFhO3dCQUM1QjtvQkFDSjtvQkFDQSxJQUFJb0ssUUFBUSxJQUFJLENBQUM1SSxXQUFXLElBQUksT0FBTzt3QkFDbkMsSUFBSSxDQUFDNEQsUUFBUSxDQUFDO29CQUNsQjtvQkFDQSxtREFBbUQ7b0JBQ25ELElBQUksSUFBSSxDQUFDNUQsV0FBVyxFQUFFO3dCQUNsQixJQUFJLENBQUN1QixPQUFPLENBQUNrRixHQUFHLENBQUNpQztvQkFDckI7Z0JBQ0o7Z0JBRUE7Ozs7OztDQU1DLEdBQ0QxTSxLQUFLcUcsU0FBUyxDQUFDeUcsV0FBVyxHQUFHLFNBQVNDLE1BQU0sRUFBRUgsSUFBSTtvQkFDOUMsSUFBSSxJQUFJLENBQUNwSSxNQUFNLElBQUloQyxhQUFhO3dCQUM1QjtvQkFDSjtvQkFDQSxJQUFJb0ssUUFBUSxJQUFJLENBQUM1SSxXQUFXLElBQUksT0FBTzt3QkFDbkMsSUFBSSxDQUFDNEQsUUFBUSxDQUFDO29CQUNsQjtvQkFDQSxtREFBbUQ7b0JBQ25ELElBQUksSUFBSSxDQUFDNUQsV0FBVyxFQUFFO3dCQUNsQixJQUFJLENBQUN3QixRQUFRLElBQUl1SDtvQkFDckI7Z0JBQ0o7Z0JBRUE7Ozs7Ozs7O0NBUUMsR0FDRC9NLEtBQUtxRyxTQUFTLENBQUMyRyxrQkFBa0IsR0FBRyxTQUFTQyxPQUFPLEVBQUVOLEtBQUssRUFBRUMsSUFBSTtvQkFDN0QsSUFBSSxJQUFJLENBQUNwSSxNQUFNLElBQUloQyxhQUFhO3dCQUM1QjtvQkFDSjtvQkFDQSxJQUFJb0ssUUFBUSxJQUFJLENBQUM1SSxXQUFXLElBQUksT0FBTzt3QkFDbkMsSUFBSSxDQUFDNEQsUUFBUSxDQUFDO29CQUNsQjtvQkFDQSxvREFBb0Q7b0JBQ3BELElBQUksSUFBSSxDQUFDNUQsV0FBVyxFQUFFO3dCQUNsQixJQUFJLENBQUN5QixnQkFBZ0IsQ0FBQzJHLE1BQU0sQ0FBQyxJQUFJLENBQUMxSCxTQUFTLEVBQUV1STt3QkFDN0MsSUFBSSxDQUFDdkgsaUJBQWlCLElBQUksSUFBSSxDQUFDZCxNQUFNLEdBQUdyRixLQUFLbUwsS0FBSyxDQUFDbkwsS0FBS2lMLEdBQUcsQ0FBQ21DLE9BQU8sSUFBSSxDQUFDeEgsT0FBTyxDQUFDeUUsQ0FBQyxHQUFHcUQ7b0JBQ3hGO2dCQUNKO2dCQUVBOzs7OztDQUtDLEdBQ0RqTixLQUFLcUcsU0FBUyxDQUFDNkcsbUJBQW1CLEdBQUcsU0FBU0QsT0FBTyxFQUFFTCxJQUFJO29CQUN2RCxJQUFJLElBQUksQ0FBQ3BJLE1BQU0sSUFBSWhDLGFBQWE7d0JBQzVCO29CQUNKO29CQUNBLElBQUlvSyxRQUFRLElBQUksQ0FBQzVJLFdBQVcsSUFBSSxPQUFPO3dCQUNuQyxJQUFJLENBQUM0RCxRQUFRLENBQUM7b0JBQ2xCO29CQUNBLG9EQUFvRDtvQkFDcEQsSUFBSSxJQUFJLENBQUM1RCxXQUFXLEVBQUU7d0JBQ2xCLElBQUksQ0FBQzBCLGlCQUFpQixJQUFJLElBQUksQ0FBQ2QsTUFBTSxHQUFHcUk7b0JBQzVDO2dCQUNKO2dCQUVBOzs7Q0FHQyxHQUNEak4sS0FBS3FHLFNBQVMsQ0FBQzhHLGFBQWEsR0FBRyxTQUFTQyxJQUFJO29CQUN4Qyx1Q0FBdUM7b0JBQ3ZDLElBQUksSUFBSSxDQUFDNUksTUFBTSxJQUFJaEMsZUFBZTRLLEtBQUs1SSxNQUFNLElBQUloQyxhQUFhO3dCQUMxRCxPQUFPO29CQUNYO29CQUNBLGtDQUFrQztvQkFDbEMsSUFBSyxJQUFJNkssS0FBSyxJQUFJLENBQUN0SCxXQUFXLEVBQUVzSCxJQUFJQSxLQUFLQSxHQUFHdEYsSUFBSSxDQUFFO3dCQUM5QyxJQUFJc0YsR0FBR0MsS0FBSyxJQUFJRixNQUFNOzRCQUNsQixJQUFJQyxHQUFHRSxLQUFLLENBQUNDLGtCQUFrQixJQUFJLE9BQU87Z0NBQ3RDLE9BQU87NEJBQ1g7d0JBQ0o7b0JBQ0o7b0JBQ0EsT0FBTztnQkFDWDtnQkFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRHhOLEtBQUtxRyxTQUFTLENBQUNvSCxhQUFhLEdBQUcsU0FBU0MsS0FBSyxFQUFFQyxNQUFNO29CQUNqRDdMLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDMEMsYUFBYSxNQUFNO29CQUNqRCxJQUFJLElBQUksQ0FBQ0EsYUFBYSxNQUFNLE1BQU07d0JBQzlCLE9BQU87b0JBQ1g7b0JBQ0EsSUFBSXNILFVBQVUsSUFBSTdOLFFBQVEsSUFBSSxFQUFFMk4sT0FBT0M7b0JBQ3ZDLElBQUksSUFBSSxDQUFDdkosWUFBWSxFQUFFO3dCQUNuQixJQUFJOEQsYUFBYSxJQUFJLENBQUNuRSxPQUFPLENBQUNvRSxZQUFZO3dCQUMxQ3lGLFFBQVEzRSxhQUFhLENBQUNmLFlBQVksSUFBSSxDQUFDckQsSUFBSTtvQkFDL0M7b0JBQ0ErSSxRQUFRekgsTUFBTSxHQUFHLElBQUksQ0FBQ0YsYUFBYTtvQkFDbkMsSUFBSSxDQUFDQSxhQUFhLEdBQUcySDtvQkFDckIsb0NBQW9DO29CQUNwQyxJQUFJQSxRQUFRMUIsU0FBUyxHQUFHLEdBQUc7d0JBQ3ZCLElBQUksQ0FBQzFFLGFBQWE7b0JBQ3RCO29CQUNBLHlFQUF5RTtvQkFDekUsd0RBQXdEO29CQUN4RCxJQUFJLENBQUN6RCxPQUFPLENBQUM4SixZQUFZLEdBQUc7b0JBQzVCLE9BQU9EO2dCQUNYO2dCQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRDVOLEtBQUtxRyxTQUFTLENBQUN5SCxjQUFjLEdBQUcsU0FBU0YsT0FBTztvQkFDNUM5TCxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQzBDLGFBQWEsTUFBTTtvQkFDakQsSUFBSSxJQUFJLENBQUNBLGFBQWEsTUFBTSxNQUFNO3dCQUM5QjtvQkFDSjtvQkFDQXhFLFdBQVdFLFFBQU80QixNQUFNLENBQUNnSyxRQUFRRyxNQUFNLElBQUksSUFBSTtvQkFDL0MsMERBQTBEO29CQUMxRCxJQUFJQyxRQUFRO29CQUNaLElBQUksSUFBSSxDQUFDL0gsYUFBYSxLQUFLMkgsU0FBUzt3QkFDaEMsSUFBSSxDQUFDM0gsYUFBYSxHQUFHMkgsUUFBUXpILE1BQU07d0JBQ25DNkgsUUFBUTtvQkFDWixPQUFPO3dCQUNILElBQUlDLE9BQU8sSUFBSSxDQUFDaEksYUFBYTt3QkFDN0IsTUFBT2dJLFFBQVEsS0FBTTs0QkFDakIsSUFBSUEsS0FBSzlILE1BQU0sS0FBS3lILFNBQVM7Z0NBQ3pCSyxLQUFLOUgsTUFBTSxHQUFHeUgsUUFBUXpILE1BQU07Z0NBQzVCNkgsUUFBUTtnQ0FDUjs0QkFDSjs0QkFDQUMsT0FBT0EsS0FBSzlILE1BQU07d0JBQ3RCO29CQUNKO29CQUNBLGlFQUFpRTtvQkFDakVyRSxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDb0s7b0JBQ3pCLG9EQUFvRDtvQkFDcEQsSUFBSUUsT0FBTyxJQUFJLENBQUNsSSxhQUFhO29CQUM3QixNQUFPa0ksS0FBTTt3QkFDVCxJQUFJdEUsSUFBSXNFLEtBQUtqRyxPQUFPO3dCQUNwQmlHLE9BQU9BLEtBQUtuRyxJQUFJO3dCQUNoQixJQUFJb0csV0FBV3ZFLEVBQUV3RSxXQUFXO3dCQUM1QixJQUFJQyxXQUFXekUsRUFBRTBFLFdBQVc7d0JBQzVCLElBQUlWLFdBQVdPLFlBQVlQLFdBQVdTLFVBQVU7NEJBQzVDLGdEQUFnRDs0QkFDaEQsNEJBQTRCOzRCQUM1QixJQUFJLENBQUN0SyxPQUFPLENBQUNpRSxjQUFjLENBQUM0Qjt3QkFDaEM7b0JBQ0o7b0JBQ0EsSUFBSSxJQUFJLENBQUN4RixZQUFZLEVBQUU7d0JBQ25CLElBQUk4RCxhQUFhLElBQUksQ0FBQ25FLE9BQU8sQ0FBQ29FLFlBQVk7d0JBQzFDeUYsUUFBUTFFLGNBQWMsQ0FBQ2hCO29CQUMzQjtvQkFDQTBGLFFBQVFHLE1BQU0sR0FBRztvQkFDakJILFFBQVF6SCxNQUFNLEdBQUc7b0JBQ2pCLElBQUksQ0FBQ3BDLE9BQU8sQ0FBQ3dLLE9BQU8sQ0FBQyxrQkFBa0JYO29CQUN2Qyx1QkFBdUI7b0JBQ3ZCLElBQUksQ0FBQ3BHLGFBQWE7Z0JBQ3RCO2dCQUVBOztDQUVDLEdBQ0R4SCxLQUFLcUcsU0FBUyxDQUFDd0UsYUFBYSxHQUFHLFNBQVNELFVBQVU7b0JBQzlDLE9BQU9qTCxVQUFVNk8sT0FBTyxDQUFDLElBQUksQ0FBQzNKLElBQUksRUFBRStGO2dCQUN4QztnQkFFQTs7Q0FFQyxHQUNENUssS0FBS3FHLFNBQVMsQ0FBQ29JLGNBQWMsR0FBRyxTQUFTQyxXQUFXO29CQUNoRCxPQUFPOU8sSUFBSTRPLE9BQU8sQ0FBQyxJQUFJLENBQUMzSixJQUFJLENBQUNJLENBQUMsRUFBRXlKO2dCQUNwQztnQkFFQTs7Q0FFQyxHQUNEMU8sS0FBS3FHLFNBQVMsQ0FBQ3NJLGFBQWEsR0FBRyxTQUFTcEUsVUFBVTtvQkFDOUMsT0FBTzVLLFVBQVVpUCxRQUFRLENBQUMsSUFBSSxDQUFDL0osSUFBSSxFQUFFMEY7Z0JBQ3pDO2dCQUVBOzs7Q0FHQyxHQUNEdkssS0FBS3FHLFNBQVMsQ0FBQ3dJLGNBQWMsR0FBRyxTQUFTQyxXQUFXO29CQUNoRCxPQUFPbFAsSUFBSWdQLFFBQVEsQ0FBQyxJQUFJLENBQUMvSixJQUFJLENBQUNJLENBQUMsRUFBRTZKO2dCQUNyQztZQUdBO1lBQUU7Z0JBQUMsYUFBWTtnQkFBRSxXQUFVO2dCQUFFLFdBQVU7Z0JBQUcsaUJBQWdCO2dCQUFHLHFCQUFvQjtnQkFBRyxnQkFBZTtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxxQkFBb0I7Z0JBQUcsaUJBQWdCO2dCQUFHLGtCQUFpQjtZQUFFO1NBQUU7UUFBQyxHQUFFO1lBQUMsU0FBU2hRLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN2USxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJZ04sZUFBZTtnQkFFbkIsSUFBSS9NLFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJa1EsT0FBT2xRLFNBQVE7Z0JBRW5CLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlXLFFBQVFYLFNBQVE7Z0JBRXBCLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSXlDLFdBQVd6QyxTQUFRO2dCQUV2QixJQUFJMEMsV0FBVzFDLFNBQVE7Z0JBRXZCZixRQUFPRCxPQUFPLEdBQUdtQztnQkFFakI7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNnUCxZQUFZaEgsT0FBTztvQkFDeEIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO29CQUNmLElBQUksQ0FBQ2lILElBQUksR0FBRztvQkFDWixJQUFJLENBQUNuSCxJQUFJLEdBQUc7b0JBQ1osSUFBSSxDQUFDdUYsS0FBSyxHQUFHO2dCQUNqQjtnQkFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0Q7Ozs7Q0FJQyxHQUNELFNBQVNyTjtvQkFDTCwrQkFBK0I7b0JBQy9CLElBQUksQ0FBQ2tQLE9BQU8sR0FBRyxJQUFJRixZQUFZLElBQUk7b0JBQ25DLElBQUksQ0FBQ0csT0FBTyxHQUFHLElBQUlILFlBQVksSUFBSTtvQkFDbkMsSUFBSSxDQUFDSSxVQUFVLEdBQUcsSUFBSTlOO29CQUN0QixJQUFJLENBQUMrTixjQUFjLEdBQUc7d0JBQUUsSUFBSUM7d0JBQTJCLElBQUlBO3FCQUEyQjtvQkFDdEYsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtvQkFDbEIsNkNBQTZDO29CQUM3QyxJQUFJLENBQUNDLFFBQVEsR0FBR2xRLEtBQUtzRCxJQUFJO29CQUN6QixJQUFJLENBQUM2TSxZQUFZLEdBQUcsSUFBSWpRO29CQUN4QixJQUFJLENBQUNrUSxHQUFHLEdBQUcsSUFBSWxRO29CQUNmLElBQUksQ0FBQ21RLG1CQUFtQixHQUFHO3dCQUFFclEsS0FBS3NELElBQUk7d0JBQUl0RCxLQUFLc0QsSUFBSTtxQkFBSTtvQkFDdkQsSUFBSSxDQUFDZ04sYUFBYSxHQUFHLEVBQUU7b0JBQ3ZCLDJCQUEyQjtvQkFDM0IsSUFBSSxDQUFDQyxhQUFhLEdBQUd2USxLQUFLc0QsSUFBSTtvQkFDOUIsSUFBSSxDQUFDa04sWUFBWSxHQUFHeFEsS0FBS3NELElBQUk7b0JBQzdCLElBQUksQ0FBQ21OLGNBQWMsR0FBR3pRLEtBQUtzRCxJQUFJO29CQUMvQixJQUFJLENBQUNvTixjQUFjLEdBQUcxUSxLQUFLc0QsSUFBSTtnQkFDbkM7Z0JBRUE7Ozs7Ozs7O0NBUUMsR0FDRDVDLFFBQVFvRyxTQUFTLENBQUM2SixJQUFJLEdBQUcsU0FBU0MsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxXQUFXO29CQUNqRSxJQUFJLENBQUNDLFVBQVUsR0FBR0w7b0JBQ2xCLElBQUksQ0FBQ00sVUFBVSxHQUFHSjtvQkFDbEIsSUFBSSxDQUFDSyxRQUFRLEdBQUdOO29CQUNoQixJQUFJLENBQUNPLFFBQVEsR0FBR0w7b0JBQ2hCLElBQUksQ0FBQ00sYUFBYSxHQUFHTDtvQkFDckIsSUFBSSxDQUFDbEIsVUFBVSxDQUFDYSxJQUFJO29CQUNwQixJQUFJLENBQUNoSyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDMEssS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ0MsVUFBVSxHQUFHO29CQUNsQix3Q0FBd0M7b0JBQ3hDLElBQUksQ0FBQ3hNLFNBQVMsR0FBRztvQkFDakIsSUFBSSxDQUFDeU0sVUFBVSxHQUFHQyxZQUFZLElBQUksQ0FBQ1IsVUFBVSxDQUFDTyxVQUFVLEVBQUUsSUFBSSxDQUFDTixVQUFVLENBQUNNLFVBQVU7b0JBQ3BGLElBQUksQ0FBQ0UsYUFBYSxHQUFHQyxlQUFlLElBQUksQ0FBQ1YsVUFBVSxDQUFDUyxhQUFhLEVBQUUsSUFBSSxDQUFDUixVQUFVLENBQUNRLGFBQWE7b0JBQ2hHLElBQUksQ0FBQ0UsY0FBYyxHQUFHO29CQUN0Qix5Q0FBeUM7b0JBQ3pDLElBQUksQ0FBQ0MsYUFBYSxHQUFHO29CQUNyQix5REFBeUQ7b0JBQ3pELElBQUksQ0FBQy9NLFlBQVksR0FBRztvQkFDcEIsb0NBQW9DO29CQUNwQyxJQUFJLENBQUNnTixjQUFjLEdBQUc7b0JBQ3RCLHFFQUFxRTtvQkFDckUsSUFBSSxDQUFDQyxZQUFZLEdBQUc7b0JBQ3BCLHNDQUFzQztvQkFDdEMsSUFBSSxDQUFDQyxlQUFlLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQy9CLFFBQVEsQ0FBQ3BRLE1BQU0sR0FBRztvQkFDdkIsSUFBSSxDQUFDcVEsUUFBUSxDQUFDaEksT0FBTztvQkFDckIsSUFBSSxDQUFDaUksWUFBWSxDQUFDakksT0FBTztvQkFDekIsSUFBSSxDQUFDa0ksR0FBRyxDQUFDbEksT0FBTztvQkFDaEIsSUFBSSxDQUFDK0osWUFBWSxHQUFHO29CQUNwQixJQUFJLENBQUNDLGNBQWMsR0FBRztvQkFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7b0JBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUNDLFVBQVUsR0FBRztvQkFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7b0JBQ2xCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO29CQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHO29CQUNmLElBQUksQ0FBQ2xDLGFBQWEsQ0FBQ3pRLE1BQU0sR0FBRztvQkFDNUIsSUFBSSxDQUFDMFEsYUFBYSxDQUFDckksT0FBTztvQkFDMUIsSUFBSSxDQUFDc0ksWUFBWSxDQUFDdEksT0FBTztvQkFDekIsSUFBSSxDQUFDdUksY0FBYyxDQUFDdkksT0FBTztvQkFDM0IsSUFBSSxDQUFDd0ksY0FBYyxDQUFDeEksT0FBTztvQkFDM0IsSUFBSSxDQUFDdUssTUFBTSxHQUFHO29CQUNkLGdCQUFnQjtvQkFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7b0JBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO29CQUNqQixJQUFJLENBQUNDLFlBQVksR0FBRztvQkFDcEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7b0JBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO29CQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBRztvQkFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztnQkFDbkI7Z0JBRUF0UyxRQUFRb0csU0FBUyxDQUFDbU0sY0FBYyxHQUFHLFNBQVNDLElBQUk7b0JBQzVDLElBQUl0RSxXQUFXLElBQUksQ0FBQ3FDLFVBQVU7b0JBQzlCLElBQUluQyxXQUFXLElBQUksQ0FBQ29DLFVBQVU7b0JBQzlCLElBQUlpQyxTQUFTdkUsU0FBU3dFLFFBQVE7b0JBQzlCLElBQUlDLFNBQVN2RSxTQUFTc0UsUUFBUTtvQkFDOUIsSUFBSUUsUUFBUTFFLFNBQVMyRSxPQUFPO29CQUM1QixJQUFJQyxRQUFRMUUsU0FBU3lFLE9BQU87b0JBQzVCLElBQUlFLFdBQVcsSUFBSSxDQUFDM0QsVUFBVTtvQkFDOUIsSUFBSTRELGFBQWFELFNBQVNDLFVBQVU7b0JBQ3BDblIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3FQLGFBQWE7b0JBQ3RDLElBQUksQ0FBQ3JCLFVBQVUsR0FBR2lCLE1BQU1uTyxTQUFTO29CQUNqQyxJQUFJLENBQUNtTixVQUFVLEdBQUdrQixNQUFNck8sU0FBUztvQkFDakMsSUFBSSxDQUFDb04sT0FBTyxHQUFHZSxNQUFNak8sTUFBTTtvQkFDM0IsSUFBSSxDQUFDbU4sT0FBTyxHQUFHZ0IsTUFBTW5PLE1BQU07b0JBQzNCLElBQUksQ0FBQzhNLFVBQVUsR0FBRyxJQUFJLENBQUNYLFVBQVU7b0JBQ2pDLElBQUksQ0FBQ1ksYUFBYSxHQUFHLElBQUksQ0FBQ1YsYUFBYTtvQkFDdkMsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSSxDQUFDTixjQUFjO29CQUN6QyxJQUFJLENBQUNLLFlBQVksR0FBR3lCO29CQUNwQixJQUFJLENBQUN0RCxHQUFHLENBQUNsSSxPQUFPO29CQUNoQixJQUFJLENBQUNpSSxZQUFZLENBQUNqSSxPQUFPO29CQUN6QixJQUFJLENBQUMySyxVQUFVLEdBQUdTLE1BQU1uTyxTQUFTO29CQUNqQyxJQUFJLENBQUMyTixVQUFVLEdBQUdVLE1BQU1yTyxTQUFTO29CQUNqQyxJQUFJLENBQUM0TixPQUFPLEdBQUdPLE1BQU1qTyxNQUFNO29CQUMzQixJQUFJLENBQUMyTixPQUFPLEdBQUdRLE1BQU1uTyxNQUFNO29CQUMzQixJQUFJLENBQUNvTCxjQUFjLENBQUNrRCxPQUFPLENBQUNMLE1BQU0xTixPQUFPLENBQUNpRixXQUFXO29CQUNyRCxJQUFJLENBQUM2RixjQUFjLENBQUNpRCxPQUFPLENBQUNILE1BQU01TixPQUFPLENBQUNpRixXQUFXO29CQUNyRCxJQUFJLENBQUM2SCxTQUFTLEdBQUdTLE9BQU9TLFFBQVE7b0JBQ2hDLElBQUksQ0FBQ2pCLFNBQVMsR0FBR1UsT0FBT08sUUFBUTtvQkFDaEMsSUFBSSxDQUFDbkIsTUFBTSxHQUFHZ0IsU0FBU3JRLElBQUk7b0JBQzNCLElBQUksQ0FBQ21OLGFBQWEsQ0FBQ29ELE9BQU8sQ0FBQ0YsU0FBU0ksV0FBVztvQkFDL0MsSUFBSSxDQUFDckQsWUFBWSxDQUFDbUQsT0FBTyxDQUFDRixTQUFTcEksVUFBVTtvQkFDN0MsSUFBSSxDQUFDdUgsWUFBWSxHQUFHYztvQkFDcEIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlKLFlBQVksRUFBRUksRUFBRzt3QkFDakMsSUFBSUMsS0FBS04sU0FBU08sTUFBTSxDQUFDRixFQUFFO3dCQUMzQixnQkFBZ0I7d0JBQ2hCLElBQUlHLE1BQU0sSUFBSSxDQUFDaEUsUUFBUSxDQUFDNkQsRUFBRSxHQUFHLElBQUksQ0FBQy9ELGNBQWMsQ0FBQytELEVBQUUsQ0FBQ25ELElBQUk7d0JBQ3hELElBQUl1QyxLQUFLZ0IsWUFBWSxFQUFFOzRCQUNuQkQsSUFBSUUsYUFBYSxHQUFHakIsS0FBS2tCLE9BQU8sR0FBR0wsR0FBR0ksYUFBYTs0QkFDbkRGLElBQUlJLGNBQWMsR0FBR25CLEtBQUtrQixPQUFPLEdBQUdMLEdBQUdNLGNBQWM7d0JBQ3pELE9BQU87NEJBQ0hKLElBQUlFLGFBQWEsR0FBRzs0QkFDcEJGLElBQUlJLGNBQWMsR0FBRzt3QkFDekI7d0JBQ0FKLElBQUlLLEVBQUUsQ0FBQ3BNLE9BQU87d0JBQ2QrTCxJQUFJTSxFQUFFLENBQUNyTSxPQUFPO3dCQUNkK0wsSUFBSU8sVUFBVSxHQUFHO3dCQUNqQlAsSUFBSVEsV0FBVyxHQUFHO3dCQUNsQlIsSUFBSVMsWUFBWSxHQUFHO3dCQUNuQixJQUFJLENBQUNwRSxhQUFhLENBQUN3RCxFQUFFLEdBQUcsSUFBSSxDQUFDekQsbUJBQW1CLENBQUN5RCxFQUFFLENBQUNILE9BQU8sQ0FBQ0ksR0FBRzFJLFVBQVU7b0JBQzdFO2dCQUNKO2dCQUVBOzs7Q0FHQyxHQUNEM0ssUUFBUW9HLFNBQVMsQ0FBQzZOLFdBQVcsR0FBRztvQkFDNUIsT0FBTyxJQUFJLENBQUM3RSxVQUFVO2dCQUMxQjtnQkFFQTs7OztDQUlDLEdBQ0RwUCxRQUFRb0csU0FBUyxDQUFDOE4sZ0JBQWdCLEdBQUcsU0FBU0MsYUFBYTtvQkFDdkQsSUFBSXZCLFFBQVEsSUFBSSxDQUFDckMsVUFBVSxDQUFDc0MsT0FBTztvQkFDbkMsSUFBSUMsUUFBUSxJQUFJLENBQUN0QyxVQUFVLENBQUNxQyxPQUFPO29CQUNuQyxJQUFJSixTQUFTLElBQUksQ0FBQ2xDLFVBQVUsQ0FBQ21DLFFBQVE7b0JBQ3JDLElBQUlDLFNBQVMsSUFBSSxDQUFDbkMsVUFBVSxDQUFDa0MsUUFBUTtvQkFDckMsSUFBSUssV0FBVyxJQUFJLENBQUMzRCxVQUFVLENBQUM4RSxnQkFBZ0IsQ0FBQ0MsZUFBZXZCLE1BQU14SixZQUFZLElBQUlxSixPQUFPUyxRQUFRLEVBQUVKLE1BQU0xSixZQUFZLElBQUl1SixPQUFPTyxRQUFRO29CQUMzSSxPQUFPSDtnQkFDWDtnQkFFQTs7OztDQUlDLEdBQ0QvUyxRQUFRb0csU0FBUyxDQUFDZ08sVUFBVSxHQUFHLFNBQVMxTCxJQUFJO29CQUN4QyxJQUFJLENBQUN5SSxhQUFhLEdBQUcsQ0FBQyxDQUFDekk7Z0JBQzNCO2dCQUVBOztDQUVDLEdBQ0QxSSxRQUFRb0csU0FBUyxDQUFDaU8sU0FBUyxHQUFHO29CQUMxQixPQUFPLElBQUksQ0FBQ2xELGFBQWE7Z0JBQzdCO2dCQUVBOztDQUVDLEdBQ0RuUixRQUFRb0csU0FBUyxDQUFDa08sVUFBVSxHQUFHO29CQUMzQixPQUFPLElBQUksQ0FBQ2xELGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0RwUixRQUFRb0csU0FBUyxDQUFDSSxPQUFPLEdBQUc7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDTixNQUFNO2dCQUN0QjtnQkFFQTs7Q0FFQyxHQUNEbEcsUUFBUW9HLFNBQVMsQ0FBQytILFdBQVcsR0FBRztvQkFDNUIsT0FBTyxJQUFJLENBQUNvQyxVQUFVO2dCQUMxQjtnQkFFQTs7Q0FFQyxHQUNEdlEsUUFBUW9HLFNBQVMsQ0FBQ2lJLFdBQVcsR0FBRztvQkFDNUIsT0FBTyxJQUFJLENBQUNtQyxVQUFVO2dCQUMxQjtnQkFFQTs7Q0FFQyxHQUNEeFEsUUFBUW9HLFNBQVMsQ0FBQ21PLGNBQWMsR0FBRztvQkFDL0IsT0FBTyxJQUFJLENBQUM5RCxRQUFRO2dCQUN4QjtnQkFFQTs7Q0FFQyxHQUNEelEsUUFBUW9HLFNBQVMsQ0FBQ29PLGNBQWMsR0FBRztvQkFDL0IsT0FBTyxJQUFJLENBQUM5RCxRQUFRO2dCQUN4QjtnQkFFQTs7Q0FFQyxHQUNEMVEsUUFBUW9HLFNBQVMsQ0FBQ3FPLGdCQUFnQixHQUFHO29CQUNqQyxJQUFJLENBQUNwRCxZQUFZLEdBQUc7Z0JBQ3hCO2dCQUVBOzs7Q0FHQyxHQUNEclIsUUFBUW9HLFNBQVMsQ0FBQ3NPLFdBQVcsR0FBRyxTQUFTQyxRQUFRO29CQUM3QyxJQUFJLENBQUM3RCxVQUFVLEdBQUc2RDtnQkFDdEI7Z0JBRUE7O0NBRUMsR0FDRDNVLFFBQVFvRyxTQUFTLENBQUN3TyxXQUFXLEdBQUc7b0JBQzVCLE9BQU8sSUFBSSxDQUFDOUQsVUFBVTtnQkFDMUI7Z0JBRUE7O0NBRUMsR0FDRDlRLFFBQVFvRyxTQUFTLENBQUN5TyxhQUFhLEdBQUc7b0JBQzlCLElBQUksQ0FBQy9ELFVBQVUsR0FBR0MsWUFBWSxJQUFJLENBQUNSLFVBQVUsQ0FBQ08sVUFBVSxFQUFFLElBQUksQ0FBQ04sVUFBVSxDQUFDTSxVQUFVO2dCQUN4RjtnQkFFQTs7O0NBR0MsR0FDRDlRLFFBQVFvRyxTQUFTLENBQUMwTyxjQUFjLEdBQUcsU0FBU0MsV0FBVztvQkFDbkQsSUFBSSxDQUFDL0QsYUFBYSxHQUFHK0Q7Z0JBQ3pCO2dCQUVBOztDQUVDLEdBQ0QvVSxRQUFRb0csU0FBUyxDQUFDNE8sY0FBYyxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ2hFLGFBQWE7Z0JBQzdCO2dCQUVBOztDQUVDLEdBQ0RoUixRQUFRb0csU0FBUyxDQUFDNk8sZ0JBQWdCLEdBQUc7b0JBQ2pDLElBQUksQ0FBQ2pFLGFBQWEsR0FBR0MsZUFBZSxJQUFJLENBQUNWLFVBQVUsQ0FBQ1MsYUFBYSxFQUFFLElBQUksQ0FBQ1IsVUFBVSxDQUFDUSxhQUFhO2dCQUNwRztnQkFFQTs7O0NBR0MsR0FDRGhSLFFBQVFvRyxTQUFTLENBQUM4TyxlQUFlLEdBQUcsU0FBU0MsS0FBSztvQkFDOUMsSUFBSSxDQUFDakUsY0FBYyxHQUFHaUU7Z0JBQzFCO2dCQUVBOztDQUVDLEdBQ0RuVixRQUFRb0csU0FBUyxDQUFDZ1AsZUFBZSxHQUFHO29CQUNoQyxPQUFPLElBQUksQ0FBQ2xFLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0RsUixRQUFRb0csU0FBUyxDQUFDaVAsUUFBUSxHQUFHLFNBQVN0QyxRQUFRLEVBQUV1QyxHQUFHLEVBQUVDLEdBQUc7b0JBQ3BELElBQUksQ0FBQzVFLGFBQWEsQ0FBQ29DLFVBQVV1QyxLQUFLLElBQUksQ0FBQy9FLFVBQVUsRUFBRSxJQUFJLENBQUNFLFFBQVEsRUFBRThFLEtBQUssSUFBSSxDQUFDL0UsVUFBVSxFQUFFLElBQUksQ0FBQ0UsUUFBUTtnQkFDekc7Z0JBRUEsSUFBSThFLGVBQWUsSUFBSWxVO2dCQUV2Qjs7Ozs7Ozs7Q0FRQyxHQUNEdEIsUUFBUW9HLFNBQVMsQ0FBQ3FQLE1BQU0sR0FBRyxTQUFTQyxRQUFRO29CQUN4QywwQkFBMEI7b0JBQzFCLElBQUksQ0FBQ3ZFLGFBQWEsR0FBRztvQkFDckIsSUFBSXdFLFdBQVc7b0JBQ2YsSUFBSUMsY0FBYyxJQUFJLENBQUN4RSxjQUFjO29CQUNyQyxJQUFJeUUsVUFBVSxJQUFJLENBQUN0RixVQUFVLENBQUN1RixRQUFRO29CQUN0QyxJQUFJQyxVQUFVLElBQUksQ0FBQ3ZGLFVBQVUsQ0FBQ3NGLFFBQVE7b0JBQ3RDLElBQUlFLFNBQVNILFdBQVdFO29CQUN4QixJQUFJbkQsUUFBUSxJQUFJLENBQUNyQyxVQUFVLENBQUNzQyxPQUFPO29CQUNuQyxJQUFJQyxRQUFRLElBQUksQ0FBQ3RDLFVBQVUsQ0FBQ3FDLE9BQU87b0JBQ25DLElBQUl5QyxNQUFNMUMsTUFBTXhKLFlBQVk7b0JBQzVCLElBQUltTSxNQUFNekMsTUFBTTFKLFlBQVk7b0JBQzVCLDRCQUE0QjtvQkFDNUIsSUFBSTRNLFFBQVE7d0JBQ1IsSUFBSXZELFNBQVMsSUFBSSxDQUFDbEMsVUFBVSxDQUFDbUMsUUFBUTt3QkFDckMsSUFBSUMsU0FBUyxJQUFJLENBQUNuQyxVQUFVLENBQUNrQyxRQUFRO3dCQUNyQ2lELFdBQVdwVSxTQUFTMFUsV0FBVyxDQUFDeEQsUUFBUSxJQUFJLENBQUNoQyxRQUFRLEVBQUVrQyxRQUFRLElBQUksQ0FBQ2pDLFFBQVEsRUFBRTRFLEtBQUtDO3dCQUNuRixvQ0FBb0M7d0JBQ3BDLElBQUksQ0FBQ25HLFVBQVUsQ0FBQzRELFVBQVUsR0FBRztvQkFDakMsT0FBTzt3QkFDSCxJQUFJa0QsY0FBYyxJQUFJLENBQUM5RyxVQUFVO3dCQUNqQyxJQUFJLENBQUNBLFVBQVUsR0FBR29HLGFBQWF2RixJQUFJO3dCQUNuQ3VGLGVBQWVVO3dCQUNmLElBQUksQ0FBQ2IsUUFBUSxDQUFDLElBQUksQ0FBQ2pHLFVBQVUsRUFBRWtHLEtBQUtDO3dCQUNwQ0ksV0FBVyxJQUFJLENBQUN2RyxVQUFVLENBQUM0RCxVQUFVLEdBQUc7d0JBQ3hDLElBQUssSUFBSWxVLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNzUSxVQUFVLENBQUM0RCxVQUFVLEVBQUUsRUFBRWxVLEVBQUc7NEJBQ2pELElBQUlxWCxNQUFNLElBQUksQ0FBQy9HLFVBQVUsQ0FBQ2tFLE1BQU0sQ0FBQ3hVLEVBQUU7NEJBQ25DcVgsSUFBSTFDLGFBQWEsR0FBRzs0QkFDcEIwQyxJQUFJeEMsY0FBYyxHQUFHOzRCQUNyQix3REFBd0Q7NEJBQ3hELDRDQUE0Qzs0QkFDNUMsSUFBSyxJQUFJUCxJQUFJLEdBQUdBLElBQUk4QyxZQUFZbEQsVUFBVSxFQUFFLEVBQUVJLEVBQUc7Z0NBQzdDLElBQUlnRCxNQUFNRixZQUFZNUMsTUFBTSxDQUFDRixFQUFFO2dDQUMvQixJQUFJZ0QsSUFBSUMsRUFBRSxDQUFDQyxHQUFHLElBQUlILElBQUlFLEVBQUUsQ0FBQ0MsR0FBRyxFQUFFO29DQUMxQixnQkFBZ0I7b0NBQ2hCSCxJQUFJMUMsYUFBYSxHQUFHMkMsSUFBSTNDLGFBQWE7b0NBQ3JDMEMsSUFBSXhDLGNBQWMsR0FBR3lDLElBQUl6QyxjQUFjO29DQUN2QztnQ0FDSjs0QkFDSjt3QkFDSjt3QkFDQSxJQUFJZ0MsYUFBYUMsYUFBYTs0QkFDMUJoRCxNQUFNakwsUUFBUSxDQUFDOzRCQUNmbUwsTUFBTW5MLFFBQVEsQ0FBQzt3QkFDbkI7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDeUosY0FBYyxHQUFHdUU7b0JBQ3RCLElBQUksQ0FBQ0MsZUFBZUQsWUFBWUQsVUFBVTt3QkFDdENBLFNBQVNhLFlBQVksQ0FBQyxJQUFJO29CQUM5QjtvQkFDQSxJQUFJWCxlQUFlLENBQUNELFlBQVlELFVBQVU7d0JBQ3RDQSxTQUFTYyxVQUFVLENBQUMsSUFBSTtvQkFDNUI7b0JBQ0EsSUFBSSxDQUFDUixVQUFVTCxZQUFZRCxVQUFVO3dCQUNqQ0EsU0FBU2UsUUFBUSxDQUFDLElBQUksRUFBRVA7b0JBQzVCO2dCQUNKO2dCQUVBbFcsUUFBUW9HLFNBQVMsQ0FBQ3NRLHVCQUF1QixHQUFHLFNBQVNsRSxJQUFJO29CQUNyRCxPQUFPLElBQUksQ0FBQ21FLHdCQUF3QixDQUFDbkUsTUFBTTtnQkFDL0M7Z0JBRUF4UyxRQUFRb0csU0FBUyxDQUFDd1EsMEJBQTBCLEdBQUcsU0FBU3BFLElBQUksRUFBRXFFLElBQUksRUFBRUMsSUFBSTtvQkFDcEUsT0FBTyxJQUFJLENBQUNILHdCQUF3QixDQUFDbkUsTUFBTSxNQUFNcUUsTUFBTUM7Z0JBQzNEO2dCQUVBLElBQUlDLG1CQUFtQnpYLEtBQUtzRCxJQUFJO2dCQUVoQyxJQUFJb1UsbUJBQW1CMVgsS0FBS3NELElBQUk7Z0JBRWhDLElBQUlxVSxTQUFTM1gsS0FBS3NELElBQUk7Z0JBRXRCLElBQUlzVSxTQUFTNVgsS0FBS3NELElBQUk7Z0JBRXRCLElBQUl1VSxVQUFVelgsVUFBVW1GLFFBQVE7Z0JBRWhDLElBQUl1UyxVQUFVMVgsVUFBVW1GLFFBQVE7Z0JBRWhDLElBQUl3UyxTQUFTL1gsS0FBS3NELElBQUk7Z0JBRXRCLElBQUkwVSxTQUFTaFksS0FBS3NELElBQUk7Z0JBRXRCLElBQUkyVSxhQUFhalksS0FBS3NELElBQUk7Z0JBRTFCLElBQUk0VSxZQUFZbFksS0FBS3NELElBQUk7Z0JBRXpCLElBQUk2VSxhQUFhblksS0FBS3NELElBQUk7Z0JBRTFCLElBQUk4VSxhQUFhcFksS0FBS3NELElBQUk7Z0JBRTFCLElBQUkrVSxpQkFBaUJyWSxLQUFLc0QsSUFBSTtnQkFFOUIsSUFBSWdWLGdCQUFnQnRZLEtBQUtzRCxJQUFJO2dCQUU3QixJQUFJaVYsU0FBU3ZZLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJa1YsU0FBU3hZLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJbVYsUUFBUXpZLEtBQUtzRCxJQUFJO2dCQUVyQjVDLFFBQVFvRyxTQUFTLENBQUN1USx3QkFBd0IsR0FBRyxTQUFTbkUsSUFBSSxFQUFFd0YsR0FBRyxFQUFFbkIsSUFBSSxFQUFFQyxJQUFJO29CQUN2RSxJQUFJNUksV0FBVyxJQUFJLENBQUNxQyxVQUFVO29CQUM5QixJQUFJbkMsV0FBVyxJQUFJLENBQUNvQyxVQUFVO29CQUM5QixJQUFJb0MsUUFBUTFFLFNBQVMyRSxPQUFPO29CQUM1QixJQUFJQyxRQUFRMUUsU0FBU3lFLE9BQU87b0JBQzVCLElBQUlvRixZQUFZckYsTUFBTXhOLFVBQVU7b0JBQ2hDLElBQUk4UyxZQUFZcEYsTUFBTTFOLFVBQVU7b0JBQ2hDLElBQUkrUyxZQUFZdkYsTUFBTXZOLFVBQVU7b0JBQ2hDLElBQUkrUyxZQUFZdEYsTUFBTXpOLFVBQVU7b0JBQ2hDLElBQUlnVCxlQUFldEIsaUJBQWlCOUQsT0FBTyxDQUFDLElBQUksQ0FBQ2xELGNBQWM7b0JBQy9ELElBQUl1SSxlQUFldEIsaUJBQWlCL0QsT0FBTyxDQUFDLElBQUksQ0FBQ2pELGNBQWM7b0JBQy9ELElBQUl1SSxLQUFLO29CQUNULElBQUlDLEtBQUs7b0JBQ1QsSUFBSSxDQUFDUixPQUFRcEYsVUFBVWlFLFFBQVFqRSxVQUFVa0UsTUFBTzt3QkFDNUN5QixLQUFLLElBQUksQ0FBQ3BHLFVBQVU7d0JBQ3BCcUcsS0FBSyxJQUFJLENBQUNuRyxPQUFPO29CQUNyQjtvQkFDQSxJQUFJb0csS0FBSztvQkFDVCxJQUFJQyxLQUFLO29CQUNULElBQUksQ0FBQ1YsT0FBUWxGLFVBQVUrRCxRQUFRL0QsVUFBVWdFLE1BQU87d0JBQzVDMkIsS0FBSyxJQUFJLENBQUNyRyxVQUFVO3dCQUNwQnNHLEtBQUssSUFBSSxDQUFDcEcsT0FBTztvQkFDckI7b0JBQ0EsSUFBSXFHLEtBQUsxQixPQUFPaEUsT0FBTyxDQUFDa0YsVUFBVXhPLENBQUM7b0JBQ25DLElBQUlpUCxLQUFLVCxVQUFVdlosQ0FBQztvQkFDcEIsSUFBSWlhLEtBQUszQixPQUFPakUsT0FBTyxDQUFDbUYsVUFBVXpPLENBQUM7b0JBQ25DLElBQUltUCxLQUFLVixVQUFVeFosQ0FBQztvQkFDcEIsSUFBSW1hLGdCQUFnQjtvQkFDcEIsMkJBQTJCO29CQUMzQixJQUFLLElBQUkzRixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDbEIsWUFBWSxFQUFFLEVBQUVrQixFQUFHO3dCQUN4QyxJQUFJa0MsTUFBTTZCLFFBQVE2QixXQUFXO3dCQUM3QixJQUFJekQsTUFBTTZCLFFBQVE0QixXQUFXO3dCQUM3QjFELElBQUl0USxDQUFDLENBQUNxRSxHQUFHLENBQUN1UDt3QkFDVnJELElBQUl2USxDQUFDLENBQUNxRSxHQUFHLENBQUN5UDt3QkFDVnhELElBQUl4USxDQUFDLENBQUNtTyxPQUFPLENBQUMzVCxLQUFLMlosSUFBSSxDQUFDTixJQUFJaFosSUFBSXVaLFFBQVEsQ0FBQzVELElBQUl0USxDQUFDLEVBQUVxVCxjQUFjaEIsU0FBU0M7d0JBQ3ZFL0IsSUFBSXpRLENBQUMsQ0FBQ21PLE9BQU8sQ0FBQzNULEtBQUsyWixJQUFJLENBQUNKLElBQUlsWixJQUFJdVosUUFBUSxDQUFDM0QsSUFBSXZRLENBQUMsRUFBRXNULGNBQWNqQixTQUFTQzt3QkFDdkUseUJBQXlCO3dCQUN6QixJQUFJNkIsUUFBUXpNLE9BQU8wTTt3QkFDbkIsT0FBUSxJQUFJLENBQUNySCxNQUFNOzRCQUNqQixLQUFLelEsU0FBUytYLFNBQVM7Z0NBQ3JCLElBQUlDLFNBQVM1WixVQUFVd1osUUFBUSxDQUFDNUQsS0FBSyxJQUFJLENBQUN4RixZQUFZLEVBQUUySDtnQ0FDeEQsSUFBSThCLFNBQVM3WixVQUFVd1osUUFBUSxDQUFDM0QsS0FBSyxJQUFJLENBQUMzRixhQUFhLENBQUMsRUFBRSxFQUFFOEg7Z0NBQzVEeUIsU0FBUzdaLEtBQUsyWixJQUFJLENBQUNNLFFBQVFELFFBQVEvQjtnQ0FDbkM0QixPQUFPSyxTQUFTO2dDQUNoQjlNLFFBQVFwTixLQUFLbWEsUUFBUSxDQUFDLElBQUlILFFBQVEsSUFBSUMsUUFBUS9CO2dDQUM5QzRCLGFBQWE5WixLQUFLeUwsR0FBRyxDQUFDekwsS0FBS2lMLEdBQUcsQ0FBQ2dQLFFBQVFELFNBQVNILFVBQVUsSUFBSSxDQUFDbkgsU0FBUyxHQUFHLElBQUksQ0FBQ0MsU0FBUztnQ0FDekY7NEJBRUYsS0FBSzNRLFNBQVNvWSxPQUFPO2dDQUNuQlAsU0FBU3haLElBQUl1WixRQUFRLENBQUM1RCxJQUFJdFEsQ0FBQyxFQUFFLElBQUksQ0FBQzZLLGFBQWEsRUFBRTBIO2dDQUNqRCxJQUFJb0MsYUFBYWphLFVBQVV3WixRQUFRLENBQUM1RCxLQUFLLElBQUksQ0FBQ3hGLFlBQVksRUFBRTZIO2dDQUM1RCxJQUFJaUMsWUFBWWxhLFVBQVV3WixRQUFRLENBQUMzRCxLQUFLLElBQUksQ0FBQzNGLGFBQWEsQ0FBQ3dELEVBQUUsRUFBRXdFO2dDQUMvRHdCLGFBQWE5WixLQUFLeUwsR0FBRyxDQUFDekwsS0FBSzJaLElBQUksQ0FBQ1csV0FBV0QsWUFBWXRDLFNBQVM4QixVQUFVLElBQUksQ0FBQ25ILFNBQVMsR0FBRyxJQUFJLENBQUNDLFNBQVM7Z0NBQ3pHdkYsUUFBUThLLFVBQVV2RSxPQUFPLENBQUMyRztnQ0FDMUI7NEJBRUYsS0FBS3RZLFNBQVN1WSxPQUFPO2dDQUNuQlYsU0FBU3haLElBQUl1WixRQUFRLENBQUMzRCxJQUFJdlEsQ0FBQyxFQUFFLElBQUksQ0FBQzZLLGFBQWEsRUFBRTBIO2dDQUNqRCxJQUFJb0MsYUFBYWphLFVBQVV3WixRQUFRLENBQUMzRCxLQUFLLElBQUksQ0FBQ3pGLFlBQVksRUFBRTZIO2dDQUM1RCxJQUFJaUMsWUFBWWxhLFVBQVV3WixRQUFRLENBQUM1RCxLQUFLLElBQUksQ0FBQzFGLGFBQWEsQ0FBQ3dELEVBQUUsRUFBRXdFO2dDQUMvRHdCLGFBQWE5WixLQUFLeUwsR0FBRyxDQUFDekwsS0FBSzJaLElBQUksQ0FBQ1csV0FBV0QsWUFBWXRDLFNBQVM4QixVQUFVLElBQUksQ0FBQ25ILFNBQVMsR0FBRyxJQUFJLENBQUNDLFNBQVM7Z0NBQ3pHdkYsUUFBUThLLFVBQVV2RSxPQUFPLENBQUMyRztnQ0FDMUIsbUNBQW1DO2dDQUNuQ1QsT0FBTy9NLEdBQUcsQ0FBQyxDQUFDO2dDQUNaO3dCQUNKO3dCQUNBLElBQUl3SCxLQUFLdFUsS0FBSzJaLElBQUksQ0FBQ3ZNLE9BQU9pTSxJQUFJZDt3QkFDOUIsSUFBSWhFLEtBQUt2VSxLQUFLMlosSUFBSSxDQUFDdk0sT0FBT21NLElBQUlmO3dCQUM5Qiw4QkFBOEI7d0JBQzlCaUIsZ0JBQWdCMVosTUFBS3lhLEdBQUcsQ0FBQ2YsZUFBZUs7d0JBQ3hDLElBQUlXLFlBQVkvQixNQUFNdFcsU0FBU3NZLFdBQVcsR0FBR3RZLFNBQVNxWSxTQUFTO3dCQUMvRCxJQUFJRSxhQUFhdlksU0FBU3VZLFVBQVU7d0JBQ3BDLElBQUlDLHNCQUFzQnhZLFNBQVN3WSxtQkFBbUI7d0JBQ3RELDRDQUE0Qzt3QkFDNUMsSUFBSUMsSUFBSTlhLE1BQUsrYSxLQUFLLENBQUNMLFlBQWFYLENBQUFBLGFBQWFhLFVBQVMsR0FBSSxDQUFDQyxxQkFBcUI7d0JBQ2hGLDhCQUE4Qjt3QkFDOUIsSUFBSUcsTUFBTS9hLEtBQUtnYixhQUFhLENBQUMxRyxJQUFJdUY7d0JBQ2pDLElBQUlvQixNQUFNamIsS0FBS2diLGFBQWEsQ0FBQ3pHLElBQUlzRjt3QkFDakMsSUFBSXFCLElBQUlqQyxLQUFLRSxLQUFLRCxLQUFLNkIsTUFBTUEsTUFBTTNCLEtBQUs2QixNQUFNQTt3QkFDOUMseUJBQXlCO3dCQUN6QixJQUFJdk4sVUFBVXdOLElBQUksSUFBSSxDQUFDTCxJQUFJSyxJQUFJO3dCQUMvQixJQUFJQyxJQUFJbmIsS0FBS29iLFdBQVcsQ0FBQzFOLFNBQVNtTSxRQUFRcEI7d0JBQzFDWSxHQUFHZ0MsTUFBTSxDQUFDcEMsSUFBSWtDO3dCQUNkN0IsTUFBTUosS0FBS2xaLEtBQUtnYixhQUFhLENBQUMxRyxJQUFJNkc7d0JBQ2xDNUIsR0FBRzFNLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZDNCLE1BQU1KLEtBQUtwWixLQUFLZ2IsYUFBYSxDQUFDekcsSUFBSTRHO29CQUN0QztvQkFDQXRDLFVBQVV4TyxDQUFDLENBQUNzSixPQUFPLENBQUMwRjtvQkFDcEJSLFVBQVV2WixDQUFDLEdBQUdnYTtvQkFDZFIsVUFBVXpPLENBQUMsQ0FBQ3NKLE9BQU8sQ0FBQzRGO29CQUNwQlQsVUFBVXhaLENBQUMsR0FBR2thO29CQUNkLE9BQU9DO2dCQUNYO2dCQUVBLFNBQVN6SjtvQkFDTCxJQUFJLENBQUNzRSxFQUFFLEdBQUd0VSxLQUFLc0QsSUFBSTtvQkFDbkIsSUFBSSxDQUFDaVIsRUFBRSxHQUFHdlUsS0FBS3NELElBQUk7b0JBQ25CLElBQUksQ0FBQzZRLGFBQWEsR0FBRztvQkFDckIsSUFBSSxDQUFDRSxjQUFjLEdBQUc7b0JBQ3RCLElBQUksQ0FBQ0csVUFBVSxHQUFHO29CQUNsQixJQUFJLENBQUNDLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7Z0JBQ3hCO2dCQUVBMUUsd0JBQXdCbEosU0FBUyxDQUFDNkosSUFBSSxHQUFHO29CQUNyQyxJQUFJLENBQUMyRCxFQUFFLENBQUNwTSxPQUFPO29CQUNmLElBQUksQ0FBQ3FNLEVBQUUsQ0FBQ3JNLE9BQU87b0JBQ2YsSUFBSSxDQUFDaU0sYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUNFLGNBQWMsR0FBRztvQkFDdEIsSUFBSSxDQUFDRyxVQUFVLEdBQUc7b0JBQ2xCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO29CQUNuQixJQUFJLENBQUNDLFlBQVksR0FBRztvQkFDcEIsT0FBTyxJQUFJO2dCQUNmO2dCQUVBLElBQUk0RyxtQkFBbUJ0YixLQUFLc0QsSUFBSTtnQkFFaEMsSUFBSWlZLG1CQUFtQnZiLEtBQUtzRCxJQUFJO2dCQUVoQyxJQUFJa1ksYUFBYXhiLEtBQUtzRCxJQUFJO2dCQUUxQixJQUFJbVksU0FBU3piLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJb1ksU0FBUzFiLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJcVksU0FBUzNiLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJc1ksU0FBUzViLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJdVksU0FBUzdiLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJd1ksU0FBUzliLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJeVksVUFBVTNiLFVBQVVtRixRQUFRO2dCQUVoQyxJQUFJeVcsVUFBVTViLFVBQVVtRixRQUFRO2dCQUVoQzdFLFFBQVFvRyxTQUFTLENBQUNtVixzQkFBc0IsR0FBRyxTQUFTL0ksSUFBSTtvQkFDcEQsSUFBSXRFLFdBQVcsSUFBSSxDQUFDcUMsVUFBVTtvQkFDOUIsSUFBSW5DLFdBQVcsSUFBSSxDQUFDb0MsVUFBVTtvQkFDOUIsSUFBSW9DLFFBQVExRSxTQUFTMkUsT0FBTztvQkFDNUIsSUFBSUMsUUFBUTFFLFNBQVN5RSxPQUFPO29CQUM1QixJQUFJb0YsWUFBWXJGLE1BQU14TixVQUFVO29CQUNoQyxJQUFJOFMsWUFBWXBGLE1BQU0xTixVQUFVO29CQUNoQyxJQUFJK1MsWUFBWXZGLE1BQU12TixVQUFVO29CQUNoQyxJQUFJK1MsWUFBWXRGLE1BQU16TixVQUFVO29CQUNoQyxJQUFJbVcsVUFBVSxJQUFJLENBQUN4SixTQUFTO29CQUM1QixJQUFJeUosVUFBVSxJQUFJLENBQUN4SixTQUFTO29CQUM1QixJQUFJYyxXQUFXLElBQUksQ0FBQzNELFVBQVU7b0JBQzlCLElBQUltSixLQUFLLElBQUksQ0FBQzVHLFVBQVU7b0JBQ3hCLElBQUk4RyxLQUFLLElBQUksQ0FBQzdHLFVBQVU7b0JBQ3hCLElBQUk0RyxLQUFLLElBQUksQ0FBQzNHLE9BQU87b0JBQ3JCLElBQUk2RyxLQUFLLElBQUksQ0FBQzVHLE9BQU87b0JBQ3JCLElBQUl1RyxlQUFldUMsaUJBQWlCM0gsT0FBTyxDQUFDLElBQUksQ0FBQ2xELGNBQWM7b0JBQy9ELElBQUl1SSxlQUFldUMsaUJBQWlCNUgsT0FBTyxDQUFDLElBQUksQ0FBQ2pELGNBQWM7b0JBQy9ELElBQUkySSxLQUFLb0MsT0FBTzlILE9BQU8sQ0FBQ2tGLFVBQVV4TyxDQUFDO29CQUNuQyxJQUFJaVAsS0FBS1QsVUFBVXZaLENBQUM7b0JBQ3BCLElBQUk4YyxLQUFLVCxPQUFPaEksT0FBTyxDQUFDZ0YsVUFBVW5OLENBQUM7b0JBQ25DLElBQUk2USxLQUFLMUQsVUFBVS9NLENBQUM7b0JBQ3BCLElBQUkyTixLQUFLbUMsT0FBTzNSLEdBQUcsQ0FBQytPLFVBQVV6TyxDQUFDO29CQUMvQixJQUFJbVAsS0FBS1YsVUFBVXhaLENBQUM7b0JBQ3BCLElBQUlnZCxLQUFLVixPQUFPN1IsR0FBRyxDQUFDNk8sVUFBVXBOLENBQUM7b0JBQy9CLElBQUkrUSxLQUFLM0QsVUFBVWhOLENBQUM7b0JBQ3BCckosV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ29QLFNBQVNDLFVBQVUsR0FBRztvQkFDL0MsSUFBSXNDLE1BQU0rRixRQUFRckMsV0FBVztvQkFDN0IsSUFBSXpELE1BQU0rRixRQUFRdEMsV0FBVztvQkFDN0IxRCxJQUFJdFEsQ0FBQyxDQUFDcUUsR0FBRyxDQUFDdVA7b0JBQ1ZyRCxJQUFJdlEsQ0FBQyxDQUFDcUUsR0FBRyxDQUFDeVA7b0JBQ1Z4RCxJQUFJeFEsQ0FBQyxDQUFDZ1gsVUFBVSxDQUFDLEdBQUduRCxJQUFJLENBQUMsR0FBR2haLElBQUk0TyxPQUFPLENBQUMrRyxJQUFJdFEsQ0FBQyxFQUFFcVQ7b0JBQy9DOUMsSUFBSXpRLENBQUMsQ0FBQ2dYLFVBQVUsQ0FBQyxHQUFHakQsSUFBSSxDQUFDLEdBQUdsWixJQUFJNE8sT0FBTyxDQUFDZ0gsSUFBSXZRLENBQUMsRUFBRXNUO29CQUMvQyxJQUFJbkUsZ0JBQWdCcEIsU0FBU21CLGdCQUFnQixDQUFDLE1BQU1vQixLQUFLa0csU0FBU2pHLEtBQUtrRztvQkFDdkUsSUFBSSxDQUFDak0sUUFBUSxDQUFDbkcsR0FBRyxDQUFDOEssY0FBY2dGLE1BQU07b0JBQ3RDLElBQUssSUFBSS9GLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM3QixZQUFZLEVBQUUsRUFBRTZCLEVBQUc7d0JBQ3hDLElBQUlHLE1BQU0sSUFBSSxDQUFDaEUsUUFBUSxDQUFDNkQsRUFBRTt3QkFDMUIsMEJBQTBCO3dCQUMxQkcsSUFBSUssRUFBRSxDQUFDa0ksVUFBVSxDQUFDLEdBQUczSCxjQUFjYixNQUFNLENBQUNGLEVBQUUsRUFBRSxDQUFDLEdBQUd1Rjt3QkFDbERwRixJQUFJTSxFQUFFLENBQUNpSSxVQUFVLENBQUMsR0FBRzNILGNBQWNiLE1BQU0sQ0FBQ0YsRUFBRSxFQUFFLENBQUMsR0FBR3lGO3dCQUNsRCxJQUFJd0IsTUFBTS9hLEtBQUtnYixhQUFhLENBQUMvRyxJQUFJSyxFQUFFLEVBQUUsSUFBSSxDQUFDcEUsUUFBUTt3QkFDbEQsSUFBSStLLE1BQU1qYixLQUFLZ2IsYUFBYSxDQUFDL0csSUFBSU0sRUFBRSxFQUFFLElBQUksQ0FBQ3JFLFFBQVE7d0JBQ2xELElBQUl1TSxVQUFVeEQsS0FBS0UsS0FBS0QsS0FBSzZCLE1BQU1BLE1BQU0zQixLQUFLNkIsTUFBTUE7d0JBQ3BEaEgsSUFBSU8sVUFBVSxHQUFHaUksVUFBVSxJQUFJLElBQUlBLFVBQVU7d0JBQzdDLElBQUlDLFVBQVUxYyxLQUFLMmMsYUFBYSxDQUFDLElBQUksQ0FBQ3pNLFFBQVEsRUFBRSxHQUFHc0w7d0JBQ25ELElBQUlvQixNQUFNNWMsS0FBS2diLGFBQWEsQ0FBQy9HLElBQUlLLEVBQUUsRUFBRW9JO3dCQUNyQyxJQUFJRyxNQUFNN2MsS0FBS2diLGFBQWEsQ0FBQy9HLElBQUlNLEVBQUUsRUFBRW1JO3dCQUNyQyxJQUFJSSxXQUFXN0QsS0FBS0UsS0FBS0QsS0FBSzBELE1BQU1BLE1BQU14RCxLQUFLeUQsTUFBTUE7d0JBQ3JENUksSUFBSVEsV0FBVyxHQUFHcUksV0FBVyxJQUFJLElBQUlBLFdBQVc7d0JBQ2hELHlDQUF5Qzt3QkFDekM3SSxJQUFJUyxZQUFZLEdBQUc7d0JBQ25CLElBQUlxSSxPQUFPL2MsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5RSxRQUFRLEVBQUVvTSxNQUFNdGMsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5RSxRQUFRLEVBQUVsUSxLQUFLZ2QsYUFBYSxDQUFDVCxJQUFJdEksSUFBSU0sRUFBRSxFQUFFc0gsV0FBVzdiLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDeUUsUUFBUSxFQUFFa00sTUFBTXBjLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDeUUsUUFBUSxFQUFFbFEsS0FBS2dkLGFBQWEsQ0FBQ1gsSUFBSXBJLElBQUlLLEVBQUUsRUFBRXdIO3dCQUNoTSxJQUFJaUIsT0FBTyxDQUFDM2EsU0FBUzZhLGlCQUFpQixFQUFFOzRCQUNwQ2hKLElBQUlTLFlBQVksR0FBRyxDQUFDLElBQUksQ0FBQ3RDLGFBQWEsR0FBRzJLO3dCQUM3QztvQkFDSjtvQkFDQSx3REFBd0Q7b0JBQ3hELElBQUksSUFBSSxDQUFDOUssWUFBWSxLQUFLLEtBQUtpQixLQUFLZ0ssVUFBVSxFQUFFO3dCQUM1QyxJQUFJQyxPQUFPLElBQUksQ0FBQ2xOLFFBQVEsQ0FBQyxFQUFFO3dCQUMzQiwwQkFBMEI7d0JBQzFCLElBQUltTixPQUFPLElBQUksQ0FBQ25OLFFBQVEsQ0FBQyxFQUFFO3dCQUMzQiwwQkFBMEI7d0JBQzFCLElBQUlvTixPQUFPcmQsS0FBS2diLGFBQWEsQ0FBQ21DLEtBQUs3SSxFQUFFLEVBQUUsSUFBSSxDQUFDcEUsUUFBUTt3QkFDcEQsSUFBSW9OLE9BQU90ZCxLQUFLZ2IsYUFBYSxDQUFDbUMsS0FBSzVJLEVBQUUsRUFBRSxJQUFJLENBQUNyRSxRQUFRO3dCQUNwRCxJQUFJcU4sT0FBT3ZkLEtBQUtnYixhQUFhLENBQUNvQyxLQUFLOUksRUFBRSxFQUFFLElBQUksQ0FBQ3BFLFFBQVE7d0JBQ3BELElBQUlzTixPQUFPeGQsS0FBS2diLGFBQWEsQ0FBQ29DLEtBQUs3SSxFQUFFLEVBQUUsSUFBSSxDQUFDckUsUUFBUTt3QkFDcEQsSUFBSXVOLE1BQU14RSxLQUFLRSxLQUFLRCxLQUFLbUUsT0FBT0EsT0FBT2pFLEtBQUtrRSxPQUFPQTt3QkFDbkQsSUFBSUksTUFBTXpFLEtBQUtFLEtBQUtELEtBQUtxRSxPQUFPQSxPQUFPbkUsS0FBS29FLE9BQU9BO3dCQUNuRCxJQUFJRyxNQUFNMUUsS0FBS0UsS0FBS0QsS0FBS21FLE9BQU9FLE9BQU9uRSxLQUFLa0UsT0FBT0U7d0JBQ25ELHdDQUF3Qzt3QkFDeEMsSUFBSUksdUJBQXVCO3dCQUMzQixJQUFJSCxNQUFNQSxNQUFNRyx1QkFBd0JILENBQUFBLE1BQU1DLE1BQU1DLE1BQU1BLEdBQUUsR0FBSTs0QkFDNUQsdUJBQXVCOzRCQUN2QixJQUFJLENBQUN2TixHQUFHLENBQUN5TixFQUFFLENBQUM5VCxHQUFHLENBQUMwVCxLQUFLRTs0QkFDckIsSUFBSSxDQUFDdk4sR0FBRyxDQUFDME4sRUFBRSxDQUFDL1QsR0FBRyxDQUFDNFQsS0FBS0Q7NEJBQ3JCLElBQUksQ0FBQ3ZOLFlBQVksQ0FBQ3BHLEdBQUcsQ0FBQyxJQUFJLENBQUNxRyxHQUFHLENBQUMyTixVQUFVO3dCQUM3QyxPQUFPOzRCQUNILCtDQUErQzs0QkFDL0MseUJBQXlCOzRCQUN6QixJQUFJLENBQUM5TCxZQUFZLEdBQUc7d0JBQ3hCO29CQUNKO29CQUNBNEcsVUFBVXhPLENBQUMsQ0FBQ04sR0FBRyxDQUFDc1A7b0JBQ2hCUixVQUFVdlosQ0FBQyxHQUFHZ2E7b0JBQ2RYLFVBQVVuTixDQUFDLENBQUN6QixHQUFHLENBQUNxUztvQkFDaEJ6RCxVQUFVL00sQ0FBQyxHQUFHeVE7b0JBQ2R2RCxVQUFVek8sQ0FBQyxDQUFDTixHQUFHLENBQUN3UDtvQkFDaEJULFVBQVV4WixDQUFDLEdBQUdrYTtvQkFDZFosVUFBVXBOLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3VTO29CQUNoQjFELFVBQVVoTixDQUFDLEdBQUcyUTtnQkFDbEI7Z0JBRUEsSUFBSXlCLFNBQVNoZSxLQUFLc0QsSUFBSTtnQkFFdEIsSUFBSTJhLFNBQVNqZSxLQUFLc0QsSUFBSTtnQkFFdEIsSUFBSTRhLGFBQWFsZSxLQUFLc0QsSUFBSTtnQkFFMUIsSUFBSTZhLFFBQVFuZSxLQUFLc0QsSUFBSTtnQkFFckI1QyxRQUFRb0csU0FBUyxDQUFDc1gsbUJBQW1CLEdBQUcsU0FBU2xMLElBQUk7b0JBQ2pELElBQUl0RSxXQUFXLElBQUksQ0FBQ3FDLFVBQVU7b0JBQzlCLElBQUluQyxXQUFXLElBQUksQ0FBQ29DLFVBQVU7b0JBQzlCLElBQUlvQyxRQUFRMUUsU0FBUzJFLE9BQU87b0JBQzVCLElBQUlDLFFBQVExRSxTQUFTeUUsT0FBTztvQkFDNUIsSUFBSW9GLFlBQVlyRixNQUFNeE4sVUFBVTtvQkFDaEMsSUFBSThTLFlBQVlwRixNQUFNMU4sVUFBVTtvQkFDaEMsSUFBSStTLFlBQVl2RixNQUFNdk4sVUFBVTtvQkFDaEMsSUFBSStTLFlBQVl0RixNQUFNek4sVUFBVTtvQkFDaEMsSUFBSWtULEtBQUssSUFBSSxDQUFDNUcsVUFBVTtvQkFDeEIsSUFBSTZHLEtBQUssSUFBSSxDQUFDM0csT0FBTztvQkFDckIsSUFBSTRHLEtBQUssSUFBSSxDQUFDN0csVUFBVTtvQkFDeEIsSUFBSThHLEtBQUssSUFBSSxDQUFDNUcsT0FBTztvQkFDckIsSUFBSTRKLEtBQUs0QixPQUFPalUsR0FBRyxDQUFDNE8sVUFBVW5OLENBQUM7b0JBQy9CLElBQUk2USxLQUFLMUQsVUFBVS9NLENBQUM7b0JBQ3BCLElBQUkwUSxLQUFLMkIsT0FBT2xVLEdBQUcsQ0FBQzZPLFVBQVVwTixDQUFDO29CQUMvQixJQUFJK1EsS0FBSzNELFVBQVVoTixDQUFDO29CQUNwQixJQUFJaU8sU0FBUyxJQUFJLENBQUMzSixRQUFRO29CQUMxQixJQUFJd00sVUFBVTFjLEtBQUsyYyxhQUFhLENBQUM5QyxRQUFRLEdBQUdxRTtvQkFDNUMsSUFBSyxJQUFJcEssSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzdCLFlBQVksRUFBRSxFQUFFNkIsRUFBRzt3QkFDeEMsSUFBSUcsTUFBTSxJQUFJLENBQUNoRSxRQUFRLENBQUM2RCxFQUFFO3dCQUMxQiwwQkFBMEI7d0JBQzFCLElBQUlxSCxJQUFJZ0QsTUFBTTNCLFVBQVUsQ0FBQ3ZJLElBQUlFLGFBQWEsRUFBRTBGLFFBQVE1RixJQUFJSSxjQUFjLEVBQUVxSTt3QkFDeEVMLE1BQU1uRCxLQUFLbFosS0FBS2diLGFBQWEsQ0FBQy9HLElBQUlLLEVBQUUsRUFBRTZHO3dCQUN0Q2lCLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZG9CLE1BQU1uRCxLQUFLcFosS0FBS2diLGFBQWEsQ0FBQy9HLElBQUlNLEVBQUUsRUFBRTRHO3dCQUN0Q21CLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7b0JBQ2xCO29CQUNBeEMsVUFBVW5OLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3FTO29CQUNoQnpELFVBQVUvTSxDQUFDLEdBQUd5UTtvQkFDZHpELFVBQVVwTixDQUFDLENBQUN6QixHQUFHLENBQUN1UztvQkFDaEIxRCxVQUFVaE4sQ0FBQyxHQUFHMlE7Z0JBQ2xCO2dCQUVBN2IsUUFBUW9HLFNBQVMsQ0FBQ3VYLHVCQUF1QixHQUFHLFNBQVNuTCxJQUFJO29CQUNyRCxJQUFJTyxXQUFXLElBQUksQ0FBQzNELFVBQVU7b0JBQzlCLElBQUssSUFBSWdFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM3QixZQUFZLEVBQUUsRUFBRTZCLEVBQUc7d0JBQ3hDTCxTQUFTTyxNQUFNLENBQUNGLEVBQUUsQ0FBQ0ssYUFBYSxHQUFHLElBQUksQ0FBQ2xFLFFBQVEsQ0FBQzZELEVBQUUsQ0FBQ0ssYUFBYTt3QkFDakVWLFNBQVNPLE1BQU0sQ0FBQ0YsRUFBRSxDQUFDTyxjQUFjLEdBQUcsSUFBSSxDQUFDcEUsUUFBUSxDQUFDNkQsRUFBRSxDQUFDTyxjQUFjO29CQUN2RTtnQkFDSjtnQkFFQSxJQUFJaUssU0FBU3RlLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJaWIsU0FBU3ZlLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJa2IsU0FBU3hlLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJbWIsUUFBUXplLEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJb2IsY0FBYzFlLEtBQUtzRCxJQUFJO2dCQUUzQixJQUFJcWIsUUFBUTNlLEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJc2IsUUFBUTVlLEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJdWIsUUFBUTdlLEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJd2IsUUFBUTllLEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJeWIsVUFBVS9lLEtBQUtzRCxJQUFJO2dCQUV2QixJQUFJMGIsVUFBVWhmLEtBQUtzRCxJQUFJO2dCQUV2QixJQUFJMmIsU0FBU2pmLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJNGIsU0FBU2xmLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJNmIsU0FBU25mLEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJOGIsU0FBU3BmLEtBQUtzRCxJQUFJO2dCQUV0QjVDLFFBQVFvRyxTQUFTLENBQUN1WSx1QkFBdUIsR0FBRyxTQUFTbk0sSUFBSTtvQkFDckQsSUFBSUksUUFBUSxJQUFJLENBQUNyQyxVQUFVLENBQUN6QyxNQUFNO29CQUNsQyxJQUFJZ0YsUUFBUSxJQUFJLENBQUN0QyxVQUFVLENBQUMxQyxNQUFNO29CQUNsQyxJQUFJbUssWUFBWXJGLE1BQU14TixVQUFVO29CQUNoQyxJQUFJK1MsWUFBWXZGLE1BQU12TixVQUFVO29CQUNoQyxJQUFJNlMsWUFBWXBGLE1BQU0xTixVQUFVO29CQUNoQyxJQUFJZ1QsWUFBWXRGLE1BQU16TixVQUFVO29CQUNoQyxJQUFJa1QsS0FBSyxJQUFJLENBQUM1RyxVQUFVO29CQUN4QixJQUFJNkcsS0FBSyxJQUFJLENBQUMzRyxPQUFPO29CQUNyQixJQUFJNEcsS0FBSyxJQUFJLENBQUM3RyxVQUFVO29CQUN4QixJQUFJOEcsS0FBSyxJQUFJLENBQUM1RyxPQUFPO29CQUNyQix3Q0FBd0M7b0JBQ3hDLElBQUk4TSxNQUFNM0csVUFBVW5OLENBQUMsQ0FBQytULENBQUM7b0JBQ3ZCLElBQUlDLE1BQU03RyxVQUFVbk4sQ0FBQyxDQUFDaVUsQ0FBQztvQkFDdkIsSUFBSXBELEtBQUsxRCxVQUFVL00sQ0FBQztvQkFDcEIsd0NBQXdDO29CQUN4QyxJQUFJOFQsTUFBTTlHLFVBQVVwTixDQUFDLENBQUMrVCxDQUFDO29CQUN2QixJQUFJSSxNQUFNL0csVUFBVXBOLENBQUMsQ0FBQ2lVLENBQUM7b0JBQ3ZCLElBQUlsRCxLQUFLM0QsVUFBVWhOLENBQUM7b0JBQ3BCLElBQUlpTyxTQUFTLElBQUksQ0FBQzNKLFFBQVE7b0JBQzFCLElBQUl3TSxVQUFVMWMsS0FBSzJjLGFBQWEsQ0FBQzlDLFFBQVEsR0FBRzZFO29CQUM1QyxJQUFJckosV0FBVyxJQUFJLENBQUNsRCxVQUFVO29CQUM5QjVQLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDNE4sWUFBWSxLQUFLLEtBQUssSUFBSSxDQUFDQSxZQUFZLEtBQUs7b0JBQzFFLDRFQUE0RTtvQkFDNUUsaUJBQWlCO29CQUNqQixJQUFLLElBQUk2QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDN0IsWUFBWSxFQUFFLEVBQUU2QixFQUFHO3dCQUN4QyxJQUFJRyxNQUFNLElBQUksQ0FBQ2hFLFFBQVEsQ0FBQzZELEVBQUU7d0JBQzFCLDBCQUEwQjt3QkFDMUIsK0JBQStCO3dCQUMvQix3QkFBd0I7d0JBQ3hCLElBQUk4TCxNQUFNO3dCQUNWLElBQUlDLE1BQU07d0JBQ1YsbURBQW1EO3dCQUNuREQsT0FBT0YsTUFBTSxDQUFDbkQsS0FBS3RJLElBQUlNLEVBQUUsQ0FBQ2tMLENBQUM7d0JBQzNCSSxPQUFPRixNQUFNcEQsS0FBS3RJLElBQUlNLEVBQUUsQ0FBQ2dMLENBQUM7d0JBQzFCLG1EQUFtRDt3QkFDbkRLLE9BQU9OLE1BQU0sQ0FBQ2pELEtBQUtwSSxJQUFJSyxFQUFFLENBQUNtTCxDQUFDO3dCQUMzQkksT0FBT0wsTUFBTW5ELEtBQUtwSSxJQUFJSyxFQUFFLENBQUNpTCxDQUFDO3dCQUMxQix3QkFBd0I7d0JBQ3hCLHdEQUF3RDt3QkFDeEQsSUFBSU8sS0FBS0YsTUFBTWxELFFBQVE2QyxDQUFDLEdBQUdNLE1BQU1uRCxRQUFRK0MsQ0FBQyxHQUFHLElBQUksQ0FBQ3ZOLGNBQWM7d0JBQ2hFLElBQUk2TixTQUFTOUwsSUFBSVEsV0FBVyxHQUFHLENBQUNxTDt3QkFDaEMsOEJBQThCO3dCQUM5QixJQUFJRSxjQUFjM0ssV0FBV3BCLElBQUlFLGFBQWE7d0JBQzlDLElBQUk4TCxhQUFhbGdCLE1BQUsrYSxLQUFLLENBQUM3RyxJQUFJSSxjQUFjLEdBQUcwTCxRQUFRLENBQUNDLGFBQWFBO3dCQUN2RUQsU0FBU0UsYUFBYWhNLElBQUlJLGNBQWM7d0JBQ3hDSixJQUFJSSxjQUFjLEdBQUc0TDt3QkFDckIsd0JBQXdCO3dCQUN4QixxQ0FBcUM7d0JBQ3JDLElBQUlDLEtBQUtILFNBQVNyRCxRQUFRNkMsQ0FBQzt3QkFDM0IsSUFBSVksS0FBS0osU0FBU3JELFFBQVErQyxDQUFDO3dCQUMzQixvQkFBb0I7d0JBQ3BCSCxPQUFPckcsS0FBS2lIO3dCQUNaWixPQUFPckcsS0FBS2tIO3dCQUNaLG9DQUFvQzt3QkFDcEM5RCxNQUFNbkQsS0FBTWpGLENBQUFBLElBQUlLLEVBQUUsQ0FBQ2lMLENBQUMsR0FBR1ksS0FBS2xNLElBQUlLLEVBQUUsQ0FBQ21MLENBQUMsR0FBR1MsRUFBQzt3QkFDeEMsb0JBQW9CO3dCQUNwQlIsT0FBT3ZHLEtBQUsrRzt3QkFDWlAsT0FBT3hHLEtBQUtnSDt3QkFDWixvQ0FBb0M7d0JBQ3BDNUQsTUFBTW5ELEtBQU1uRixDQUFBQSxJQUFJTSxFQUFFLENBQUNnTCxDQUFDLEdBQUdZLEtBQUtsTSxJQUFJTSxFQUFFLENBQUNrTCxDQUFDLEdBQUdTLEVBQUM7b0JBQzVDO29CQUNBLDJCQUEyQjtvQkFDM0IsSUFBSSxJQUFJLENBQUNqTyxZQUFZLEtBQUssS0FBS2lCLEtBQUtnSyxVQUFVLEtBQUssT0FBTzt3QkFDdEQsSUFBSyxJQUFJMWQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3lTLFlBQVksRUFBRSxFQUFFelMsRUFBRzs0QkFDeEMsSUFBSXlVLE1BQU0sSUFBSSxDQUFDaEUsUUFBUSxDQUFDelEsRUFBRTs0QkFDMUIsMEJBQTBCOzRCQUMxQiwrQkFBK0I7NEJBQy9CLHdCQUF3Qjs0QkFDeEIsSUFBSW9nQixNQUFNOzRCQUNWLElBQUlDLE1BQU07NEJBQ1YsbURBQW1EOzRCQUNuREQsT0FBT0YsTUFBTSxDQUFDbkQsS0FBS3RJLElBQUlNLEVBQUUsQ0FBQ2tMLENBQUM7NEJBQzNCSSxPQUFPRixNQUFNcEQsS0FBS3RJLElBQUlNLEVBQUUsQ0FBQ2dMLENBQUM7NEJBQzFCLG1EQUFtRDs0QkFDbkRLLE9BQU9OLE1BQU0sQ0FBQ2pELEtBQUtwSSxJQUFJSyxFQUFFLENBQUNtTCxDQUFDOzRCQUMzQkksT0FBT0wsTUFBTW5ELEtBQUtwSSxJQUFJSyxFQUFFLENBQUNpTCxDQUFDOzRCQUMxQix5QkFBeUI7NEJBQ3pCLGlDQUFpQzs0QkFDakMsSUFBSWEsS0FBS1IsTUFBTS9GLE9BQU8wRixDQUFDLEdBQUdNLE1BQU1oRyxPQUFPNEYsQ0FBQzs0QkFDeEMsSUFBSU0sU0FBUyxDQUFDOUwsSUFBSU8sVUFBVSxHQUFJNEwsQ0FBQUEsS0FBS25NLElBQUlTLFlBQVksQUFBRDs0QkFDcEQsZ0NBQWdDOzRCQUNoQyxJQUFJdUwsYUFBYWxnQixNQUFLc2dCLEdBQUcsQ0FBQ3BNLElBQUlFLGFBQWEsR0FBRzRMLFFBQVE7NEJBQ3REQSxTQUFTRSxhQUFhaE0sSUFBSUUsYUFBYTs0QkFDdkNGLElBQUlFLGFBQWEsR0FBRzhMOzRCQUNwQix3QkFBd0I7NEJBQ3hCLG9DQUFvQzs0QkFDcEMsSUFBSUMsS0FBS0gsU0FBU2xHLE9BQU8wRixDQUFDOzRCQUMxQixJQUFJWSxLQUFLSixTQUFTbEcsT0FBTzRGLENBQUM7NEJBQzFCLG9CQUFvQjs0QkFDcEJILE9BQU9yRyxLQUFLaUg7NEJBQ1pWLE9BQU92RyxLQUFLa0g7NEJBQ1osb0NBQW9DOzRCQUNwQzlELE1BQU1uRCxLQUFNakYsQ0FBQUEsSUFBSUssRUFBRSxDQUFDaUwsQ0FBQyxHQUFHWSxLQUFLbE0sSUFBSUssRUFBRSxDQUFDbUwsQ0FBQyxHQUFHUyxFQUFDOzRCQUN4QyxvQkFBb0I7NEJBQ3BCUixPQUFPdkcsS0FBSytHOzRCQUNaUCxPQUFPeEcsS0FBS2dIOzRCQUNaLG9DQUFvQzs0QkFDcEM1RCxNQUFNbkQsS0FBTW5GLENBQUFBLElBQUlNLEVBQUUsQ0FBQ2dMLENBQUMsR0FBR1ksS0FBS2xNLElBQUlNLEVBQUUsQ0FBQ2tMLENBQUMsR0FBR1MsRUFBQzt3QkFDNUM7b0JBQ0osT0FBTzt3QkFDSCx1RUFBdUU7d0JBQ3ZFLHdCQUF3Qjt3QkFDeEIsNENBQTRDO3dCQUM1QyxFQUFFO3dCQUNGLHlFQUF5RTt3QkFDekUsT0FBTzt3QkFDUCxFQUFFO3dCQUNGLG9EQUFvRDt3QkFDcEQseUJBQXlCO3dCQUN6QixFQUFFO3dCQUNGLHdFQUF3RTt3QkFDeEUsMENBQTBDO3dCQUMxQyx3RUFBd0U7d0JBQ3hFLDBDQUEwQzt3QkFDMUMseUVBQXlFO3dCQUN6RSw2Q0FBNkM7d0JBQzdDLGlEQUFpRDt3QkFDakQsR0FBRzt3QkFDSCxxRUFBcUU7d0JBQ3JFLHFEQUFxRDt3QkFDckQsa0VBQWtFO3dCQUNsRSxpREFBaUQ7d0JBQ2pELEVBQUU7d0JBQ0YsY0FBYzt3QkFDZCxHQUFHO3dCQUNILFlBQVk7d0JBQ1osR0FBRzt3QkFDSCx5QkFBeUI7d0JBQ3pCLHlCQUF5Qjt3QkFDekIsMkJBQTJCO3dCQUMzQixFQUFFO3dCQUNGLHNFQUFzRTt3QkFDdEUsVUFBVTt3QkFDVixvQ0FBb0M7d0JBQ3BDLEVBQUU7d0JBQ0YsaUJBQWlCO3dCQUNqQixvQkFBb0I7d0JBQ3BCLHNCQUFzQjt3QkFDdEIsZUFBZTt3QkFDZixrQkFBa0I7d0JBQ2xCLElBQUkvQyxPQUFPLElBQUksQ0FBQ2xOLFFBQVEsQ0FBQyxFQUFFO3dCQUMzQiwwQkFBMEI7d0JBQzFCLElBQUltTixPQUFPLElBQUksQ0FBQ25OLFFBQVEsQ0FBQyxFQUFFO3dCQUMzQiwwQkFBMEI7d0JBQzFCLDREQUE0RDt3QkFDNUQsSUFBSXFRLEtBQUtuRCxLQUFLaEosYUFBYTt3QkFDM0IsSUFBSW9NLEtBQUtuRCxLQUFLakosYUFBYTt3QkFDM0I1UixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDaWMsTUFBTSxLQUFLQyxNQUFNO3dCQUMxQywrQkFBK0I7d0JBQy9CLHlJQUF5STt3QkFDekksSUFBSUMsT0FBT2QsTUFBTSxDQUFDbkQsS0FBS1ksS0FBSzVJLEVBQUUsQ0FBQ2tMLENBQUMsR0FBSUgsQ0FBQUEsTUFBTSxDQUFDakQsS0FBS2MsS0FBSzdJLEVBQUUsQ0FBQ21MLENBQUMsQUFBREE7d0JBQ3hELElBQUlnQixPQUFPZCxNQUFNcEQsS0FBS1ksS0FBSzVJLEVBQUUsQ0FBQ2dMLENBQUMsR0FBSUMsQ0FBQUEsTUFBTW5ELEtBQUtjLEtBQUs3SSxFQUFFLENBQUNpTCxDQUFDLEFBQURBO3dCQUN0RCx5SUFBeUk7d0JBQ3pJLElBQUltQixPQUFPaEIsTUFBTSxDQUFDbkQsS0FBS2EsS0FBSzdJLEVBQUUsQ0FBQ2tMLENBQUMsR0FBSUgsQ0FBQUEsTUFBTSxDQUFDakQsS0FBS2UsS0FBSzlJLEVBQUUsQ0FBQ21MLENBQUMsQUFBREE7d0JBQ3hELElBQUlrQixPQUFPaEIsTUFBTXBELEtBQUthLEtBQUs3SSxFQUFFLENBQUNnTCxDQUFDLEdBQUlDLENBQUFBLE1BQU1uRCxLQUFLZSxLQUFLOUksRUFBRSxDQUFDaUwsQ0FBQyxBQUFEQTt3QkFDdEQsMEJBQTBCO3dCQUMxQixJQUFJcUIsTUFBTUosT0FBTzNHLE9BQU8wRixDQUFDLEdBQUdrQixPQUFPNUcsT0FBTzRGLENBQUM7d0JBQzNDLElBQUlvQixNQUFNSCxPQUFPN0csT0FBTzBGLENBQUMsR0FBR29CLE9BQU85RyxPQUFPNEYsQ0FBQzt3QkFDM0Msc0VBQXNFO3dCQUN0RSxJQUFJcUIsS0FBS0YsTUFBTXpELEtBQUt6SSxZQUFZO3dCQUNoQyxJQUFJcU0sS0FBS0YsTUFBTXpELEtBQUsxSSxZQUFZO3dCQUNoQyxhQUFhO3dCQUNiLHFDQUFxQzt3QkFDckNvTSxNQUFNLElBQUksQ0FBQzFRLEdBQUcsQ0FBQ3lOLEVBQUUsQ0FBQzBCLENBQUMsR0FBR2UsS0FBSyxJQUFJLENBQUNsUSxHQUFHLENBQUMwTixFQUFFLENBQUN5QixDQUFDLEdBQUdnQjt3QkFDM0NRLE1BQU0sSUFBSSxDQUFDM1EsR0FBRyxDQUFDeU4sRUFBRSxDQUFDNEIsQ0FBQyxHQUFHYSxLQUFLLElBQUksQ0FBQ2xRLEdBQUcsQ0FBQzBOLEVBQUUsQ0FBQzJCLENBQUMsR0FBR2M7d0JBQzNDLElBQUlTLGFBQWE7d0JBQ2pCLHdCQUF3Qjt3QkFDeEIsT0FBUzs0QkFDTCxFQUFFOzRCQUNGLGlCQUFpQjs0QkFDakIsRUFBRTs0QkFDRixpQkFBaUI7NEJBQ2pCLEVBQUU7NEJBQ0YsZUFBZTs0QkFDZixFQUFFOzRCQUNGLG9CQUFvQjs0QkFDcEIsRUFBRTs0QkFDRixxREFBcUQ7NEJBQ3JELElBQUlDLEtBQUssQ0FBRSxDQUFBLElBQUksQ0FBQzlRLFlBQVksQ0FBQzBOLEVBQUUsQ0FBQzBCLENBQUMsR0FBR3VCLEtBQUssSUFBSSxDQUFDM1EsWUFBWSxDQUFDMk4sRUFBRSxDQUFDeUIsQ0FBQyxHQUFHd0IsRUFBQzs0QkFDbkUsSUFBSUcsS0FBSyxDQUFFLENBQUEsSUFBSSxDQUFDL1EsWUFBWSxDQUFDME4sRUFBRSxDQUFDNEIsQ0FBQyxHQUFHcUIsS0FBSyxJQUFJLENBQUMzUSxZQUFZLENBQUMyTixFQUFFLENBQUMyQixDQUFDLEdBQUdzQixFQUFDOzRCQUNuRSxJQUFJRSxNQUFNLEtBQUtDLE1BQU0sR0FBRztnQ0FDcEIsOEJBQThCO2dDQUM5QixJQUFJQyxLQUFLRixLQUFLWDtnQ0FDZCxJQUFJYyxLQUFLRixLQUFLWDtnQ0FDZCw0QkFBNEI7Z0NBQzVCLGtDQUFrQztnQ0FDbEMsSUFBSWMsTUFBTUYsS0FBS3RILE9BQU8wRixDQUFDO2dDQUN2QixJQUFJK0IsTUFBTUgsS0FBS3RILE9BQU80RixDQUFDO2dDQUN2QixrQ0FBa0M7Z0NBQ2xDLElBQUk4QixNQUFNSCxLQUFLdkgsT0FBTzBGLENBQUM7Z0NBQ3ZCLElBQUlpQyxNQUFNSixLQUFLdkgsT0FBTzRGLENBQUM7Z0NBQ3ZCLGlDQUFpQztnQ0FDakNILE9BQU9yRyxLQUFLb0ksTUFBTXBJLEtBQUtzSTtnQ0FDdkIvQixPQUFPdkcsS0FBS3FJLE1BQU1ySSxLQUFLdUk7Z0NBQ3ZCLGtFQUFrRTtnQ0FDbEVuRixNQUFNbkQsS0FBTWlFLENBQUFBLEtBQUs3SSxFQUFFLENBQUNpTCxDQUFDLEdBQUcrQixNQUFNbkUsS0FBSzdJLEVBQUUsQ0FBQ21MLENBQUMsR0FBRzRCLE1BQU1qRSxLQUFLOUksRUFBRSxDQUFDaUwsQ0FBQyxHQUFHaUMsTUFBTXBFLEtBQUs5SSxFQUFFLENBQUNtTCxDQUFDLEdBQUc4QixHQUFFO2dDQUNoRixpQ0FBaUM7Z0NBQ2pDN0IsT0FBT3ZHLEtBQUtrSSxNQUFNbEksS0FBS29JO2dDQUN2QjVCLE9BQU94RyxLQUFLbUksTUFBTW5JLEtBQUtxSTtnQ0FDdkIsa0VBQWtFO2dDQUNsRWpGLE1BQU1uRCxLQUFNK0QsQ0FBQUEsS0FBSzVJLEVBQUUsQ0FBQ2dMLENBQUMsR0FBRytCLE1BQU1uRSxLQUFLNUksRUFBRSxDQUFDa0wsQ0FBQyxHQUFHNEIsTUFBTWpFLEtBQUs3SSxFQUFFLENBQUNnTCxDQUFDLEdBQUdpQyxNQUFNcEUsS0FBSzdJLEVBQUUsQ0FBQ2tMLENBQUMsR0FBRzhCLEdBQUU7Z0NBQ2hGLGFBQWE7Z0NBQ2JwRSxLQUFLaEosYUFBYSxHQUFHOE07Z0NBQ3JCN0QsS0FBS2pKLGFBQWEsR0FBRytNO2dDQUNyQixJQUFJMVIsY0FBYztvQ0FDZCxvQkFBb0I7b0NBQ3BCLHFFQUFxRTtvQ0FDckUscUVBQXFFO29DQUNyRSxFQUFFO29DQUNGLDZCQUE2QjtvQ0FDN0IsK0JBQStCO29DQUMvQiwrQkFBK0I7b0NBQy9CLEVBQUU7b0NBQ0ZqTixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdEUsTUFBSzBoQixHQUFHLENBQUNiLE1BQU16RCxLQUFLekksWUFBWSxJQUFJc007b0NBQzdEemUsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUswaEIsR0FBRyxDQUFDWixNQUFNekQsS0FBSzFJLFlBQVksSUFBSXNNO2dDQUNqRTtnQ0FDQTs0QkFDSjs0QkFDQSxFQUFFOzRCQUNGLDZCQUE2Qjs0QkFDN0IsRUFBRTs0QkFDRiwrQkFBK0I7NEJBQy9CLGlDQUFpQzs0QkFDakMsRUFBRTs0QkFDRkMsS0FBSyxDQUFDOUQsS0FBSzNJLFVBQVUsR0FBR3NNOzRCQUN4QkksS0FBSzs0QkFDTE4sTUFBTTs0QkFDTkMsTUFBTSxJQUFJLENBQUN6USxHQUFHLENBQUN5TixFQUFFLENBQUM0QixDQUFDLEdBQUd3QixLQUFLRjs0QkFDM0IsSUFBSUUsTUFBTSxLQUFLSixPQUFPLEdBQUc7Z0NBQ3JCLDhCQUE4QjtnQ0FDOUIsSUFBSU0sS0FBS0YsS0FBS1g7Z0NBQ2QsSUFBSWMsS0FBS0YsS0FBS1g7Z0NBQ2QsNEJBQTRCO2dDQUM1QixrQ0FBa0M7Z0NBQ2xDLElBQUljLE1BQU1GLEtBQUt0SCxPQUFPMEYsQ0FBQztnQ0FDdkIsSUFBSStCLE1BQU1ILEtBQUt0SCxPQUFPNEYsQ0FBQztnQ0FDdkIsa0NBQWtDO2dDQUNsQyxJQUFJOEIsTUFBTUgsS0FBS3ZILE9BQU8wRixDQUFDO2dDQUN2QixJQUFJaUMsTUFBTUosS0FBS3ZILE9BQU80RixDQUFDO2dDQUN2QixpQ0FBaUM7Z0NBQ2pDSCxPQUFPckcsS0FBS29JLE1BQU1wSSxLQUFLc0k7Z0NBQ3ZCL0IsT0FBT3ZHLEtBQUtxSSxNQUFNckksS0FBS3VJO2dDQUN2QixrRUFBa0U7Z0NBQ2xFbkYsTUFBTW5ELEtBQU1pRSxDQUFBQSxLQUFLN0ksRUFBRSxDQUFDaUwsQ0FBQyxHQUFHK0IsTUFBTW5FLEtBQUs3SSxFQUFFLENBQUNtTCxDQUFDLEdBQUc0QixNQUFNakUsS0FBSzlJLEVBQUUsQ0FBQ2lMLENBQUMsR0FBR2lDLE1BQU1wRSxLQUFLOUksRUFBRSxDQUFDbUwsQ0FBQyxHQUFHOEIsR0FBRTtnQ0FDaEYsaUNBQWlDO2dDQUNqQzdCLE9BQU92RyxLQUFLa0ksTUFBTWxJLEtBQUtvSTtnQ0FDdkI1QixPQUFPeEcsS0FBS21JLE1BQU1uSSxLQUFLcUk7Z0NBQ3ZCLGtFQUFrRTtnQ0FDbEVqRixNQUFNbkQsS0FBTStELENBQUFBLEtBQUs1SSxFQUFFLENBQUNnTCxDQUFDLEdBQUcrQixNQUFNbkUsS0FBSzVJLEVBQUUsQ0FBQ2tMLENBQUMsR0FBRzRCLE1BQU1qRSxLQUFLN0ksRUFBRSxDQUFDZ0wsQ0FBQyxHQUFHaUMsTUFBTXBFLEtBQUs3SSxFQUFFLENBQUNrTCxDQUFDLEdBQUc4QixHQUFFO2dDQUNoRixhQUFhO2dDQUNicEUsS0FBS2hKLGFBQWEsR0FBRzhNO2dDQUNyQjdELEtBQUtqSixhQUFhLEdBQUcrTTtnQ0FDckIsSUFBSTFSLGNBQWM7b0NBQ2Qsb0JBQW9CO29DQUNwQixvREFBb0Q7b0NBQ3BELG9EQUFvRDtvQ0FDcEQscUNBQXFDO29DQUNyQyw4QkFBOEI7b0NBQzlCLDhCQUE4QjtvQ0FDOUIsRUFBRTtvQ0FDRiw2QkFBNkI7b0NBQzdCLGtDQUFrQztvQ0FDbEMsMkNBQTJDO29DQUMzQyxFQUFFO29DQUNGak4sV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUswaEIsR0FBRyxDQUFDYixNQUFNekQsS0FBS3pJLFlBQVksSUFBSXNNO2dDQUNqRTtnQ0FDQTs0QkFDSjs0QkFDQSxFQUFFOzRCQUNGLDZCQUE2Qjs0QkFDN0IsRUFBRTs0QkFDRixpQ0FBaUM7NEJBQ2pDLCtCQUErQjs0QkFDL0IsRUFBRTs0QkFDRkMsS0FBSzs0QkFDTEMsS0FBSyxDQUFDOUQsS0FBSzVJLFVBQVUsR0FBR3VNOzRCQUN4QkgsTUFBTSxJQUFJLENBQUN4USxHQUFHLENBQUMwTixFQUFFLENBQUN5QixDQUFDLEdBQUcyQixLQUFLSjs0QkFDM0JELE1BQU07NEJBQ04sSUFBSUssTUFBTSxLQUFLTixPQUFPLEdBQUc7Z0NBQ3JCLDJDQUEyQztnQ0FDM0MsMEJBQTBCO2dDQUMxQixJQUFJTyxLQUFLRixLQUFLWDtnQ0FDZCxJQUFJYyxLQUFLRixLQUFLWDtnQ0FDZCw0QkFBNEI7Z0NBQzVCLGtDQUFrQztnQ0FDbEMsSUFBSWMsTUFBTUYsS0FBS3RILE9BQU8wRixDQUFDO2dDQUN2QixJQUFJK0IsTUFBTUgsS0FBS3RILE9BQU80RixDQUFDO2dDQUN2QixrQ0FBa0M7Z0NBQ2xDLElBQUk4QixNQUFNSCxLQUFLdkgsT0FBTzBGLENBQUM7Z0NBQ3ZCLElBQUlpQyxNQUFNSixLQUFLdkgsT0FBTzRGLENBQUM7Z0NBQ3ZCLGlDQUFpQztnQ0FDakNILE9BQU9yRyxLQUFLb0ksTUFBTXBJLEtBQUtzSTtnQ0FDdkIvQixPQUFPdkcsS0FBS3FJLE1BQU1ySSxLQUFLdUk7Z0NBQ3ZCLGtFQUFrRTtnQ0FDbEVuRixNQUFNbkQsS0FBTWlFLENBQUFBLEtBQUs3SSxFQUFFLENBQUNpTCxDQUFDLEdBQUcrQixNQUFNbkUsS0FBSzdJLEVBQUUsQ0FBQ21MLENBQUMsR0FBRzRCLE1BQU1qRSxLQUFLOUksRUFBRSxDQUFDaUwsQ0FBQyxHQUFHaUMsTUFBTXBFLEtBQUs5SSxFQUFFLENBQUNtTCxDQUFDLEdBQUc4QixHQUFFO2dDQUNoRixpQ0FBaUM7Z0NBQ2pDN0IsT0FBT3ZHLEtBQUtrSSxNQUFNbEksS0FBS29JO2dDQUN2QjVCLE9BQU94RyxLQUFLbUksTUFBTW5JLEtBQUtxSTtnQ0FDdkIsa0VBQWtFO2dDQUNsRWpGLE1BQU1uRCxLQUFNK0QsQ0FBQUEsS0FBSzVJLEVBQUUsQ0FBQ2dMLENBQUMsR0FBRytCLE1BQU1uRSxLQUFLNUksRUFBRSxDQUFDa0wsQ0FBQyxHQUFHNEIsTUFBTWpFLEtBQUs3SSxFQUFFLENBQUNnTCxDQUFDLEdBQUdpQyxNQUFNcEUsS0FBSzdJLEVBQUUsQ0FBQ2tMLENBQUMsR0FBRzhCLEdBQUU7Z0NBQ2hGLGFBQWE7Z0NBQ2JwRSxLQUFLaEosYUFBYSxHQUFHOE07Z0NBQ3JCN0QsS0FBS2pKLGFBQWEsR0FBRytNO2dDQUNyQixJQUFJMVIsY0FBYztvQ0FDZCxvQkFBb0I7b0NBQ3BCLG9EQUFvRDtvQ0FDcEQsb0RBQW9EO29DQUNwRCxrQ0FBa0M7b0NBQ2xDLEVBQUU7b0NBQ0YsNkJBQTZCO29DQUM3QiwrQkFBK0I7b0NBQy9CLEVBQUU7b0NBQ0ZqTixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdEUsTUFBSzBoQixHQUFHLENBQUNaLE1BQU16RCxLQUFLMUksWUFBWSxJQUFJc007Z0NBQ2pFO2dDQUNBOzRCQUNKOzRCQUNBLEVBQUU7NEJBQ0YsNEJBQTRCOzRCQUM1QixHQUFHOzRCQUNILFdBQVc7NEJBQ1gsWUFBWTs0QkFDWixFQUFFOzRCQUNGQyxLQUFLOzRCQUNMQyxLQUFLOzRCQUNMTixNQUFNRTs0QkFDTkQsTUFBTUU7NEJBQ04sSUFBSUgsT0FBTyxLQUFLQyxPQUFPLEdBQUc7Z0NBQ3RCLDJDQUEyQztnQ0FDM0MsMEJBQTBCO2dDQUMxQixJQUFJTSxLQUFLRixLQUFLWDtnQ0FDZCxJQUFJYyxLQUFLRixLQUFLWDtnQ0FDZCw0QkFBNEI7Z0NBQzVCLGtDQUFrQztnQ0FDbEMsSUFBSWMsTUFBTUYsS0FBS3RILE9BQU8wRixDQUFDO2dDQUN2QixJQUFJK0IsTUFBTUgsS0FBS3RILE9BQU80RixDQUFDO2dDQUN2QixrQ0FBa0M7Z0NBQ2xDLElBQUk4QixNQUFNSCxLQUFLdkgsT0FBTzBGLENBQUM7Z0NBQ3ZCLElBQUlpQyxNQUFNSixLQUFLdkgsT0FBTzRGLENBQUM7Z0NBQ3ZCLGlDQUFpQztnQ0FDakNILE9BQU9yRyxLQUFLb0ksTUFBTXBJLEtBQUtzSTtnQ0FDdkIvQixPQUFPdkcsS0FBS3FJLE1BQU1ySSxLQUFLdUk7Z0NBQ3ZCLGtFQUFrRTtnQ0FDbEVuRixNQUFNbkQsS0FBTWlFLENBQUFBLEtBQUs3SSxFQUFFLENBQUNpTCxDQUFDLEdBQUcrQixNQUFNbkUsS0FBSzdJLEVBQUUsQ0FBQ21MLENBQUMsR0FBRzRCLE1BQU1qRSxLQUFLOUksRUFBRSxDQUFDaUwsQ0FBQyxHQUFHaUMsTUFBTXBFLEtBQUs5SSxFQUFFLENBQUNtTCxDQUFDLEdBQUc4QixHQUFFO2dDQUNoRixpQ0FBaUM7Z0NBQ2pDN0IsT0FBT3ZHLEtBQUtrSSxNQUFNbEksS0FBS29JO2dDQUN2QjVCLE9BQU94RyxLQUFLbUksTUFBTW5JLEtBQUtxSTtnQ0FDdkIsa0VBQWtFO2dDQUNsRWpGLE1BQU1uRCxLQUFNK0QsQ0FBQUEsS0FBSzVJLEVBQUUsQ0FBQ2dMLENBQUMsR0FBRytCLE1BQU1uRSxLQUFLNUksRUFBRSxDQUFDa0wsQ0FBQyxHQUFHNEIsTUFBTWpFLEtBQUs3SSxFQUFFLENBQUNnTCxDQUFDLEdBQUdpQyxNQUFNcEUsS0FBSzdJLEVBQUUsQ0FBQ2tMLENBQUMsR0FBRzhCLEdBQUU7Z0NBQ2hGLGFBQWE7Z0NBQ2JwRSxLQUFLaEosYUFBYSxHQUFHOE07Z0NBQ3JCN0QsS0FBS2pKLGFBQWEsR0FBRytNO2dDQUNyQjs0QkFDSjs0QkFHQTt3QkFDSjtvQkFDSjtvQkFDQSx1QkFBdUI7b0JBQ3ZCdkksVUFBVW5OLENBQUMsQ0FBQytULENBQUMsR0FBR0Q7b0JBQ2hCM0csVUFBVW5OLENBQUMsQ0FBQ2lVLENBQUMsR0FBR0Q7b0JBQ2hCN0csVUFBVS9NLENBQUMsR0FBR3lRO29CQUNkLHVCQUF1QjtvQkFDdkJ6RCxVQUFVcE4sQ0FBQyxDQUFDK1QsQ0FBQyxHQUFHRztvQkFDaEI5RyxVQUFVcE4sQ0FBQyxDQUFDaVUsQ0FBQyxHQUFHRTtvQkFDaEIvRyxVQUFVaE4sQ0FBQyxHQUFHMlE7Z0JBQ2xCO2dCQUVBOzs7Q0FHQyxHQUNELFNBQVM5SyxZQUFZaVEsU0FBUyxFQUFFQyxTQUFTO29CQUNyQyxPQUFPNWhCLE1BQUs2aEIsSUFBSSxDQUFDRixZQUFZQztnQkFDakM7Z0JBRUE7OztDQUdDLEdBQ0QsU0FBU2hRLGVBQWVrUSxZQUFZLEVBQUVDLFlBQVk7b0JBQzlDLE9BQU9ELGVBQWVDLGVBQWVELGVBQWVDO2dCQUN4RDtnQkFFQSxJQUFJQyxjQUFjLEVBQUU7Z0JBRXBCLElBQUlDLGNBQWMsSUFBSXZTLEtBQUs7b0JBQ3ZCd1MsUUFBUTt3QkFDSixPQUFPLElBQUl2aEI7b0JBQ2Y7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDREEsUUFBUXdoQixPQUFPLEdBQUcsU0FBU0MsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFFBQVE7b0JBQzdDTixXQUFXLENBQUNJLE1BQU0sR0FBR0osV0FBVyxDQUFDSSxNQUFNLElBQUksQ0FBQztvQkFDNUNKLFdBQVcsQ0FBQ0ksTUFBTSxDQUFDQyxNQUFNLEdBQUdDO2dCQUNoQztnQkFFQTNoQixRQUFRdWhCLE1BQU0sR0FBRyxTQUFTclQsUUFBUSxFQUFFaUMsTUFBTSxFQUFFL0IsUUFBUSxFQUFFaUMsTUFBTTtvQkFDeEQsSUFBSXVSLFFBQVExVCxTQUFTNUcsT0FBTztvQkFDNUIsYUFBYTtvQkFDYixJQUFJdWEsUUFBUXpULFNBQVM5RyxPQUFPO29CQUM1QixhQUFhO29CQUNiLHNCQUFzQjtvQkFDdEIsSUFBSVUsU0FBU3NJO29CQUNiLElBQUlBLGNBQWMrUSxXQUFXLENBQUNPLE1BQU0sSUFBSVAsV0FBVyxDQUFDTyxNQUFNLENBQUNDLE1BQU0sRUFBRTt3QkFDL0Q3WixVQUFVc1osWUFBWVEsUUFBUTt3QkFDOUI5WixRQUFRaUksSUFBSSxDQUFDL0IsVUFBVWlDLFFBQVEvQixVQUFVaUMsUUFBUUM7b0JBQ3JELE9BQU8sSUFBSUEsY0FBYytRLFdBQVcsQ0FBQ1EsTUFBTSxJQUFJUixXQUFXLENBQUNRLE1BQU0sQ0FBQ0QsTUFBTSxFQUFFO3dCQUN0RTVaLFVBQVVzWixZQUFZUSxRQUFRO3dCQUM5QjlaLFFBQVFpSSxJQUFJLENBQUM3QixVQUFVaUMsUUFBUW5DLFVBQVVpQyxRQUFRRztvQkFDckQsT0FBTzt3QkFDSCxPQUFPO29CQUNYO29CQUNBLHNDQUFzQztvQkFDdENwQyxXQUFXbEcsUUFBUW1HLFdBQVc7b0JBQzlCQyxXQUFXcEcsUUFBUXFHLFdBQVc7b0JBQzlCOEIsU0FBU25JLFFBQVF1TSxjQUFjO29CQUMvQmxFLFNBQVNySSxRQUFRd00sY0FBYztvQkFDL0IsSUFBSTVCLFFBQVExRSxTQUFTMkUsT0FBTztvQkFDNUIsSUFBSUMsUUFBUTFFLFNBQVN5RSxPQUFPO29CQUM1QixvQkFBb0I7b0JBQ3BCN0ssUUFBUWtILE9BQU8sQ0FBQ2xILE9BQU8sR0FBR0E7b0JBQzFCQSxRQUFRa0gsT0FBTyxDQUFDN0IsS0FBSyxHQUFHeUY7b0JBQ3hCOUssUUFBUWtILE9BQU8sQ0FBQ0QsSUFBSSxHQUFHO29CQUN2QmpILFFBQVFrSCxPQUFPLENBQUNwSCxJQUFJLEdBQUc4SyxNQUFNN00sYUFBYTtvQkFDMUMsSUFBSTZNLE1BQU03TSxhQUFhLElBQUksTUFBTTt3QkFDN0I2TSxNQUFNN00sYUFBYSxDQUFDa0osSUFBSSxHQUFHakgsUUFBUWtILE9BQU87b0JBQzlDO29CQUNBMEQsTUFBTTdNLGFBQWEsR0FBR2lDLFFBQVFrSCxPQUFPO29CQUNyQyxvQkFBb0I7b0JBQ3BCbEgsUUFBUW1ILE9BQU8sQ0FBQ25ILE9BQU8sR0FBR0E7b0JBQzFCQSxRQUFRbUgsT0FBTyxDQUFDOUIsS0FBSyxHQUFHdUY7b0JBQ3hCNUssUUFBUW1ILE9BQU8sQ0FBQ0YsSUFBSSxHQUFHO29CQUN2QmpILFFBQVFtSCxPQUFPLENBQUNySCxJQUFJLEdBQUdnTCxNQUFNL00sYUFBYTtvQkFDMUMsSUFBSStNLE1BQU0vTSxhQUFhLElBQUksTUFBTTt3QkFDN0IrTSxNQUFNL00sYUFBYSxDQUFDa0osSUFBSSxHQUFHakgsUUFBUW1ILE9BQU87b0JBQzlDO29CQUNBMkQsTUFBTS9NLGFBQWEsR0FBR2lDLFFBQVFtSCxPQUFPO29CQUNyQyxxQkFBcUI7b0JBQ3JCLElBQUksQ0FBQ2pCLFNBQVM0SCxRQUFRLE1BQU0sQ0FBQzFILFNBQVMwSCxRQUFRLElBQUk7d0JBQzlDbEQsTUFBTWpMLFFBQVEsQ0FBQzt3QkFDZm1MLE1BQU1uTCxRQUFRLENBQUM7b0JBQ25CO29CQUNBLE9BQU9LO2dCQUNYO2dCQUVBaEksUUFBUStoQixPQUFPLEdBQUcsU0FBUy9aLE9BQU8sRUFBRTBOLFFBQVE7b0JBQ3hDLElBQUl4SCxXQUFXbEcsUUFBUXVJLFVBQVU7b0JBQ2pDLElBQUluQyxXQUFXcEcsUUFBUXdJLFVBQVU7b0JBQ2pDLElBQUlvQyxRQUFRMUUsU0FBUzJFLE9BQU87b0JBQzVCLElBQUlDLFFBQVExRSxTQUFTeUUsT0FBTztvQkFDNUIsSUFBSTdLLFFBQVFzTSxVQUFVLElBQUk7d0JBQ3RCb0IsU0FBU2MsVUFBVSxDQUFDeE87b0JBQ3hCO29CQUNBLHFCQUFxQjtvQkFDckIsSUFBSUEsUUFBUWtILE9BQU8sQ0FBQ0QsSUFBSSxFQUFFO3dCQUN0QmpILFFBQVFrSCxPQUFPLENBQUNELElBQUksQ0FBQ25ILElBQUksR0FBR0UsUUFBUWtILE9BQU8sQ0FBQ3BILElBQUk7b0JBQ3BEO29CQUNBLElBQUlFLFFBQVFrSCxPQUFPLENBQUNwSCxJQUFJLEVBQUU7d0JBQ3RCRSxRQUFRa0gsT0FBTyxDQUFDcEgsSUFBSSxDQUFDbUgsSUFBSSxHQUFHakgsUUFBUWtILE9BQU8sQ0FBQ0QsSUFBSTtvQkFDcEQ7b0JBQ0EsSUFBSWpILFFBQVFrSCxPQUFPLEtBQUswRCxNQUFNN00sYUFBYSxFQUFFO3dCQUN6QzZNLE1BQU03TSxhQUFhLEdBQUdpQyxRQUFRa0gsT0FBTyxDQUFDcEgsSUFBSTtvQkFDOUM7b0JBQ0EscUJBQXFCO29CQUNyQixJQUFJRSxRQUFRbUgsT0FBTyxDQUFDRixJQUFJLEVBQUU7d0JBQ3RCakgsUUFBUW1ILE9BQU8sQ0FBQ0YsSUFBSSxDQUFDbkgsSUFBSSxHQUFHRSxRQUFRbUgsT0FBTyxDQUFDckgsSUFBSTtvQkFDcEQ7b0JBQ0EsSUFBSUUsUUFBUW1ILE9BQU8sQ0FBQ3JILElBQUksRUFBRTt3QkFDdEJFLFFBQVFtSCxPQUFPLENBQUNySCxJQUFJLENBQUNtSCxJQUFJLEdBQUdqSCxRQUFRbUgsT0FBTyxDQUFDRixJQUFJO29CQUNwRDtvQkFDQSxJQUFJakgsUUFBUW1ILE9BQU8sS0FBSzJELE1BQU0vTSxhQUFhLEVBQUU7d0JBQ3pDK00sTUFBTS9NLGFBQWEsR0FBR2lDLFFBQVFtSCxPQUFPLENBQUNySCxJQUFJO29CQUM5QztvQkFDQSxJQUFJRSxRQUFRb0gsVUFBVSxDQUFDNEQsVUFBVSxHQUFHLEtBQUssQ0FBQzlFLFNBQVM0SCxRQUFRLE1BQU0sQ0FBQzFILFNBQVMwSCxRQUFRLElBQUk7d0JBQ25GbEQsTUFBTWpMLFFBQVEsQ0FBQzt3QkFDZm1MLE1BQU1uTCxRQUFRLENBQUM7b0JBQ25CO29CQUNBLElBQUlpYSxRQUFRMVQsU0FBUzVHLE9BQU87b0JBQzVCLGFBQWE7b0JBQ2IsSUFBSXVhLFFBQVF6VCxTQUFTOUcsT0FBTztvQkFDNUIsYUFBYTtvQkFDYixJQUFJMGEsYUFBYVgsV0FBVyxDQUFDTyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0csVUFBVTtvQkFDckQsSUFBSSxPQUFPQSxlQUFlLFlBQVk7d0JBQ2xDQSxXQUFXaGE7b0JBQ2Y7b0JBQ0FzWixZQUFZVyxPQUFPLENBQUNqYTtnQkFDeEI7WUFHQTtZQUFFO2dCQUFDLGNBQWE7Z0JBQUUsY0FBYTtnQkFBRSx3QkFBdUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGlCQUFnQjtnQkFBRyxnQkFBZTtnQkFBRyxzQkFBcUI7Z0JBQUcsaUJBQWdCO2dCQUFHLGVBQWM7Z0JBQUcsaUJBQWdCO1lBQUU7U0FBRTtRQUFDLEdBQUU7WUFBQyxTQUFTbkosUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3ZPLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHaUM7Z0JBRWpCLElBQUlpQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSW1ELFVBQVVuRCxTQUFRO2dCQUV0QixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJZSxPQUFPZixTQUFRO2dCQUVuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELElBQUlxakIsYUFBYTtvQkFDYjFlLFVBQVU7b0JBQ1ZtUixVQUFVO29CQUNWSSxhQUFhO29CQUNib04sU0FBUztvQkFDVHJNLFVBQVU7b0JBQ1ZzTSxrQkFBa0I7b0JBQ2xCQyxvQkFBb0I7b0JBQ3BCQyxnQkFBZ0I7Z0JBQ3BCO2dCQUVBOztDQUVDLEdBQ0QsU0FBU0MsYUFBYTVVLE9BQU8sRUFBRTZVLFVBQVU7b0JBQ3JDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUk3aUI7b0JBQ2hCLElBQUksQ0FBQytOLE9BQU8sR0FBR0E7b0JBQ2YsSUFBSSxDQUFDNlUsVUFBVSxHQUFHQTtvQkFDbEIsSUFBSSxDQUFDamEsT0FBTztnQkFDaEI7Z0JBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTekksUUFBUTRpQixJQUFJLEVBQUVqVixLQUFLLEVBQUUvSixHQUFHO29CQUM3QixJQUFJK0osTUFBTUEsS0FBSyxFQUFFO3dCQUNiL0osTUFBTStKO3dCQUNOQSxRQUFRQSxNQUFNQSxLQUFLO29CQUN2QixPQUFPLElBQUksT0FBTy9KLFFBQVEsVUFBVTt3QkFDaENBLE1BQU07NEJBQ0Z5ZSxTQUFTemU7d0JBQ2I7b0JBQ0o7b0JBQ0FBLE1BQU0xQixRQUFRMEIsS0FBS3dlO29CQUNuQixJQUFJLENBQUNwVSxNQUFNLEdBQUc0VTtvQkFDZCxJQUFJLENBQUM1UixVQUFVLEdBQUdwTixJQUFJaVIsUUFBUTtvQkFDOUIsSUFBSSxDQUFDM0QsYUFBYSxHQUFHdE4sSUFBSXFSLFdBQVc7b0JBQ3BDLElBQUksQ0FBQzlJLFNBQVMsR0FBR3ZJLElBQUl5ZSxPQUFPO29CQUM1QixJQUFJLENBQUNRLFVBQVUsR0FBR2pmLElBQUlvUyxRQUFRO29CQUM5QixJQUFJLENBQUM4TSxrQkFBa0IsR0FBR2xmLElBQUkwZSxnQkFBZ0I7b0JBQzlDLElBQUksQ0FBQ1Msb0JBQW9CLEdBQUduZixJQUFJMmUsa0JBQWtCO29CQUNsRCxJQUFJLENBQUNTLGdCQUFnQixHQUFHcGYsSUFBSTRlLGNBQWM7b0JBQzFDLHNCQUFzQjtvQkFDdEIsSUFBSSxDQUFDUyxPQUFPLEdBQUd0VjtvQkFDZixXQUFXO29CQUNYLElBQUksQ0FBQ3ZILE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNvQyxTQUFTLEdBQUcsRUFBRTtvQkFDbkIsSUFBSSxDQUFDRixZQUFZLEdBQUc7b0JBQ3BCLElBQUk0YSxhQUFhLElBQUksQ0FBQ0QsT0FBTyxDQUFDRSxhQUFhO29CQUMzQyxJQUFLLElBQUlua0IsSUFBSSxHQUFHQSxJQUFJa2tCLFlBQVksRUFBRWxrQixFQUFHO3dCQUNqQyxJQUFJLENBQUN3SixTQUFTLENBQUN4SixFQUFFLEdBQUcsSUFBSXlqQixhQUFhLElBQUksRUFBRXpqQjtvQkFDL0M7b0JBQ0EsSUFBSSxDQUFDd0YsVUFBVSxHQUFHWixJQUFJRixRQUFRO2dCQUNsQztnQkFFQTs7O0NBR0MsR0FDRDFELFFBQVFzRyxTQUFTLENBQUNrQixPQUFPLEdBQUc7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDeWIsT0FBTyxDQUFDemIsT0FBTztnQkFDL0I7Z0JBRUE7Ozs7Q0FJQyxHQUNEeEgsUUFBUXNHLFNBQVMsQ0FBQ3NNLFFBQVEsR0FBRztvQkFDekIsT0FBTyxJQUFJLENBQUNxUSxPQUFPO2dCQUN2QjtnQkFFQTs7O0NBR0MsR0FDRGpqQixRQUFRc0csU0FBUyxDQUFDMFAsUUFBUSxHQUFHO29CQUN6QixPQUFPLElBQUksQ0FBQzZNLFVBQVU7Z0JBQzFCO2dCQUVBOztDQUVDLEdBQ0Q3aUIsUUFBUXNHLFNBQVMsQ0FBQzhjLFNBQVMsR0FBRyxTQUFTbE4sTUFBTTtvQkFDekMsSUFBSUEsVUFBVSxJQUFJLENBQUMyTSxVQUFVLEVBQUU7d0JBQzNCLElBQUksQ0FBQzdVLE1BQU0sQ0FBQ25HLFFBQVEsQ0FBQzt3QkFDckIsSUFBSSxDQUFDZ2IsVUFBVSxHQUFHM007b0JBQ3RCO2dCQUNKO2dCQUVBOztDQUVDLEdBQ0QsaURBQWlEO2dCQUNqRCwwQkFBMEI7Z0JBQzFCLElBQUk7Z0JBQ0o7OztDQUdDLEdBQ0RsVyxRQUFRc0csU0FBUyxDQUFDTyxXQUFXLEdBQUc7b0JBQzVCLE9BQU8sSUFBSSxDQUFDckMsVUFBVTtnQkFDMUI7Z0JBRUE7O0NBRUMsR0FDRHhFLFFBQVFzRyxTQUFTLENBQUNLLFdBQVcsR0FBRyxTQUFTQyxJQUFJO29CQUN6QyxJQUFJLENBQUNwQyxVQUFVLEdBQUdvQztnQkFDdEI7Z0JBRUE7OztDQUdDLEdBQ0Q1RyxRQUFRc0csU0FBUyxDQUFDeU0sT0FBTyxHQUFHO29CQUN4QixPQUFPLElBQUksQ0FBQy9FLE1BQU07Z0JBQ3RCO2dCQUVBOztDQUVDLEdBQ0RoTyxRQUFRc0csU0FBUyxDQUFDSSxPQUFPLEdBQUc7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDTixNQUFNO2dCQUN0QjtnQkFFQTs7Q0FFQyxHQUNEcEcsUUFBUXNHLFNBQVMsQ0FBQytjLFVBQVUsR0FBRztvQkFDM0IsT0FBTyxJQUFJLENBQUNsWCxTQUFTO2dCQUN6QjtnQkFFQTs7O0NBR0MsR0FDRG5NLFFBQVFzRyxTQUFTLENBQUNnZCxVQUFVLEdBQUcsU0FBU2pCLE9BQU87b0JBQzNDdGdCLFdBQVdFLFFBQU80QixNQUFNLENBQUN0RSxNQUFLd0UsUUFBUSxDQUFDc2UsWUFBWUEsV0FBVztvQkFDOUQsSUFBSSxDQUFDbFcsU0FBUyxHQUFHa1c7Z0JBQ3JCO2dCQUVBOztDQUVDLEdBQ0RyaUIsUUFBUXNHLFNBQVMsQ0FBQ3dPLFdBQVcsR0FBRztvQkFDNUIsT0FBTyxJQUFJLENBQUM5RCxVQUFVO2dCQUMxQjtnQkFFQTs7O0NBR0MsR0FDRGhSLFFBQVFzRyxTQUFTLENBQUNzTyxXQUFXLEdBQUcsU0FBU0MsUUFBUTtvQkFDN0MsSUFBSSxDQUFDN0QsVUFBVSxHQUFHNkQ7Z0JBQ3RCO2dCQUVBOztDQUVDLEdBQ0Q3VSxRQUFRc0csU0FBUyxDQUFDNE8sY0FBYyxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ2hFLGFBQWE7Z0JBQzdCO2dCQUVBOzs7Q0FHQyxHQUNEbFIsUUFBUXNHLFNBQVMsQ0FBQzBPLGNBQWMsR0FBRyxTQUFTQyxXQUFXO29CQUNuRCxJQUFJLENBQUMvRCxhQUFhLEdBQUcrRDtnQkFDekI7Z0JBRUE7O0NBRUMsR0FDRGpWLFFBQVFzRyxTQUFTLENBQUNpZCxTQUFTLEdBQUcsU0FBU3ZlLENBQUM7b0JBQ3BDLE9BQU8sSUFBSSxDQUFDaWUsT0FBTyxDQUFDTSxTQUFTLENBQUMsSUFBSSxDQUFDdlYsTUFBTSxDQUFDMUUsWUFBWSxJQUFJdEU7Z0JBQzlEO2dCQUVBOztDQUVDLEdBQ0RoRixRQUFRc0csU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFaEIsVUFBVTtvQkFDMUQsT0FBTyxJQUFJLENBQUNPLE9BQU8sQ0FBQ08sT0FBTyxDQUFDQyxRQUFRQyxPQUFPLElBQUksQ0FBQzFWLE1BQU0sQ0FBQzFFLFlBQVksSUFBSW9aO2dCQUMzRTtnQkFFQTs7OztDQUlDLEdBQ0QxaUIsUUFBUXNHLFNBQVMsQ0FBQzRGLFdBQVcsR0FBRyxTQUFTRSxRQUFRO29CQUM3QyxJQUFJLENBQUM2VyxPQUFPLENBQUNVLFdBQVcsQ0FBQ3ZYLFVBQVUsSUFBSSxDQUFDRCxTQUFTO2dCQUNyRDtnQkFFQTs7O0NBR0MsR0FDRG5NLFFBQVFzRyxTQUFTLENBQUNzZCxPQUFPLEdBQUcsU0FBU2xCLFVBQVU7b0JBQzNDM2dCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsS0FBSzZlLGNBQWNBLGFBQWEsSUFBSSxDQUFDcGEsWUFBWTtvQkFDMUUsT0FBTyxJQUFJLENBQUNFLFNBQVMsQ0FBQ2thLFdBQVcsQ0FBQ0MsSUFBSTtnQkFDMUM7Z0JBRUE7O0NBRUMsR0FDRDNpQixRQUFRc0csU0FBUyxDQUFDNEMsYUFBYSxHQUFHLFNBQVNmLFVBQVUsRUFBRXVCLEVBQUU7b0JBQ3JEM0gsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxJQUFJLENBQUN5RSxZQUFZLElBQUk7b0JBQzlDLHFDQUFxQztvQkFDckMsSUFBSSxDQUFDQSxZQUFZLEdBQUcsSUFBSSxDQUFDMmEsT0FBTyxDQUFDRSxhQUFhO29CQUM5QyxJQUFLLElBQUlua0IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3NKLFlBQVksRUFBRSxFQUFFdEosRUFBRzt3QkFDeEMsSUFBSTZrQixRQUFRLElBQUksQ0FBQ3JiLFNBQVMsQ0FBQ3hKLEVBQUU7d0JBQzdCLElBQUksQ0FBQ2lrQixPQUFPLENBQUNhLFdBQVcsQ0FBQ0QsTUFBTWxCLElBQUksRUFBRWpaLElBQUkxSzt3QkFDekM2a0IsTUFBTXBiLE9BQU8sR0FBR04sV0FBVzRiLFdBQVcsQ0FBQ0YsTUFBTWxCLElBQUksRUFBRWtCO29CQUN2RDtnQkFDSjtnQkFFQTdqQixRQUFRc0csU0FBUyxDQUFDNkMsY0FBYyxHQUFHLFNBQVNoQixVQUFVO29CQUNsRCxzQ0FBc0M7b0JBQ3RDLElBQUssSUFBSW5KLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNzSixZQUFZLEVBQUUsRUFBRXRKLEVBQUc7d0JBQ3hDLElBQUk2a0IsUUFBUSxJQUFJLENBQUNyYixTQUFTLENBQUN4SixFQUFFO3dCQUM3Qm1KLFdBQVc2YixZQUFZLENBQUNILE1BQU1wYixPQUFPO3dCQUNyQ29iLE1BQU1wYixPQUFPLEdBQUc7b0JBQ3BCO29CQUNBLElBQUksQ0FBQ0gsWUFBWSxHQUFHO2dCQUN4QjtnQkFFQTs7O0NBR0MsR0FDRHRJLFFBQVFzRyxTQUFTLENBQUNrRCxXQUFXLEdBQUcsU0FBU3JCLFVBQVUsRUFBRThiLEdBQUcsRUFBRUMsR0FBRztvQkFDekQsSUFBSyxJQUFJbGxCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNzSixZQUFZLEVBQUUsRUFBRXRKLEVBQUc7d0JBQ3hDLElBQUk2a0IsUUFBUSxJQUFJLENBQUNyYixTQUFTLENBQUN4SixFQUFFO3dCQUM3QixzRUFBc0U7d0JBQ3RFLFdBQVc7d0JBQ1gsSUFBSW1sQixRQUFRLElBQUlya0I7d0JBQ2hCLElBQUlza0IsUUFBUSxJQUFJdGtCO3dCQUNoQixJQUFJLENBQUNtakIsT0FBTyxDQUFDYSxXQUFXLENBQUNLLE9BQU9GLEtBQUtKLE1BQU1uQixVQUFVO3dCQUNyRCxJQUFJLENBQUNPLE9BQU8sQ0FBQ2EsV0FBVyxDQUFDTSxPQUFPRixLQUFLTCxNQUFNbkIsVUFBVTt3QkFDckRtQixNQUFNbEIsSUFBSSxDQUFDMEIsT0FBTyxDQUFDRixPQUFPQzt3QkFDMUIsSUFBSUUsZUFBZTlrQixLQUFLaUwsR0FBRyxDQUFDeVosSUFBSWxmLENBQUMsRUFBRWlmLElBQUlqZixDQUFDO3dCQUN4Q21ELFdBQVdvYyxTQUFTLENBQUNWLE1BQU1wYixPQUFPLEVBQUVvYixNQUFNbEIsSUFBSSxFQUFFMkI7b0JBQ3BEO2dCQUNKO2dCQUVBOzs7O0NBSUMsR0FDRHRrQixRQUFRc0csU0FBUyxDQUFDa2UsYUFBYSxHQUFHLFNBQVNDLE1BQU07b0JBQzdDLElBQUksQ0FBQzNCLGtCQUFrQixHQUFHMkIsT0FBT0MsVUFBVTtvQkFDM0MsSUFBSSxDQUFDM0Isb0JBQW9CLEdBQUcwQixPQUFPRSxZQUFZO29CQUMvQyxJQUFJLENBQUMzQixnQkFBZ0IsR0FBR3lCLE9BQU9HLFFBQVE7b0JBQ3ZDLElBQUksQ0FBQ0MsUUFBUTtnQkFDakI7Z0JBRUE3a0IsUUFBUXNHLFNBQVMsQ0FBQ3dlLG1CQUFtQixHQUFHO29CQUNwQyxPQUFPLElBQUksQ0FBQ2hDLGtCQUFrQjtnQkFDbEM7Z0JBRUE5aUIsUUFBUXNHLFNBQVMsQ0FBQ3llLHFCQUFxQixHQUFHO29CQUN0QyxPQUFPLElBQUksQ0FBQ2hDLG9CQUFvQjtnQkFDcEM7Z0JBRUEvaUIsUUFBUXNHLFNBQVMsQ0FBQzBlLGlCQUFpQixHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ2hDLGdCQUFnQjtnQkFDaEM7Z0JBRUE7OztDQUdDLEdBQ0RoakIsUUFBUXNHLFNBQVMsQ0FBQ3VlLFFBQVEsR0FBRztvQkFDekIsSUFBSSxJQUFJLENBQUM3VyxNQUFNLElBQUksTUFBTTt3QkFDckI7b0JBQ0o7b0JBQ0EsMENBQTBDO29CQUMxQyxJQUFJRyxPQUFPLElBQUksQ0FBQ0gsTUFBTSxDQUFDaEgsY0FBYztvQkFDckMsTUFBT21ILEtBQU07d0JBQ1QsSUFBSWpHLFVBQVVpRyxLQUFLakcsT0FBTzt3QkFDMUIsSUFBSWtHLFdBQVdsRyxRQUFRbUcsV0FBVzt3QkFDbEMsSUFBSUMsV0FBV3BHLFFBQVFxRyxXQUFXO3dCQUNsQyxJQUFJSCxZQUFZLElBQUksSUFBSUUsWUFBWSxJQUFJLEVBQUU7NEJBQ3RDcEcsUUFBUXlNLGdCQUFnQjt3QkFDNUI7d0JBQ0F4RyxPQUFPQSxLQUFLbkcsSUFBSTtvQkFDcEI7b0JBQ0EsSUFBSXJFLFFBQVEsSUFBSSxDQUFDcUssTUFBTSxDQUFDdkgsUUFBUTtvQkFDaEMsSUFBSTlDLFNBQVMsTUFBTTt3QkFDZjtvQkFDSjtvQkFDQSxvREFBb0Q7b0JBQ3BELElBQUl3RSxhQUFheEUsTUFBTXlFLFlBQVk7b0JBQ25DLElBQUssSUFBSXBKLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNzSixZQUFZLEVBQUUsRUFBRXRKLEVBQUc7d0JBQ3hDbUosV0FBV0ksVUFBVSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxDQUFDeEosRUFBRSxDQUFDeUosT0FBTztvQkFDbkQ7Z0JBQ0o7Z0JBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0R6SSxRQUFRc0csU0FBUyxDQUFDOEcsYUFBYSxHQUFHLFNBQVNDLElBQUk7b0JBQzNDLElBQUlBLEtBQUt5VixrQkFBa0IsSUFBSSxJQUFJLENBQUNBLGtCQUFrQixJQUFJelYsS0FBS3lWLGtCQUFrQixJQUFJLEdBQUc7d0JBQ3BGLE9BQU96VixLQUFLeVYsa0JBQWtCLEdBQUc7b0JBQ3JDO29CQUNBLElBQUltQyxVQUFVLEFBQUM1WCxDQUFBQSxLQUFLMlYsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDRCxvQkFBb0IsQUFBRCxLQUFNLEtBQUssQUFBQzFWLENBQUFBLEtBQUswVixvQkFBb0IsR0FBRyxJQUFJLENBQUNDLGdCQUFnQixBQUFELEtBQU07b0JBQ2pJLE9BQU9pQztnQkFDWDtZQUdBO1lBQUU7Z0JBQUMsb0JBQW1CO2dCQUFHLGlCQUFnQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsaUJBQWdCO2dCQUFHLGtCQUFpQjtZQUFFO1NBQUU7UUFBQyxHQUFFO1lBQUMsU0FBU2xtQixRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDMUksSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERoRSxRQUFPRCxPQUFPLEdBQUdvQztnQkFFakIsSUFBSThCLFVBQVNsRCxTQUFRO2dCQUVyQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU21tQjtvQkFDTCxJQUFJLENBQUMzWCxLQUFLLEdBQUc7b0JBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7b0JBQ2IsSUFBSSxDQUFDMkIsSUFBSSxHQUFHO29CQUNaLElBQUksQ0FBQ25ILElBQUksR0FBRztnQkFDaEI7Z0JBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsSUFBSW1kLFdBQVc7b0JBQ1h6aEIsVUFBVTtvQkFDVjBoQixrQkFBa0I7Z0JBQ3RCO2dCQUVBOzs7OztDQUtDLEdBQ0QsU0FBU2psQixNQUFNeUQsR0FBRyxFQUFFa1AsS0FBSyxFQUFFRSxLQUFLO29CQUM1QkYsUUFBUWxQLElBQUlrUCxLQUFLLElBQUlBO29CQUNyQkUsUUFBUXBQLElBQUlvUCxLQUFLLElBQUlBO29CQUNyQmpSLFdBQVdFLFFBQU80QixNQUFNLENBQUNpUDtvQkFDekIvUSxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDbVA7b0JBQ3pCalIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ2lQLFNBQVNFO29CQUNsQyxJQUFJLENBQUN2TyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDNGdCLE9BQU8sR0FBR3ZTO29CQUNmLElBQUksQ0FBQ3dTLE9BQU8sR0FBR3RTO29CQUNmLElBQUksQ0FBQ3VTLE9BQU8sR0FBRztvQkFDZixJQUFJLENBQUM5WCxrQkFBa0IsR0FBRyxDQUFDLENBQUM3SixJQUFJd2hCLGdCQUFnQjtvQkFDaEQsSUFBSSxDQUFDamYsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQ29mLE9BQU8sR0FBRyxJQUFJTjtvQkFDbkIsSUFBSSxDQUFDTyxPQUFPLEdBQUcsSUFBSVA7b0JBQ25CLElBQUksQ0FBQzVnQixZQUFZLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ0UsVUFBVSxHQUFHWixJQUFJRixRQUFRO2dCQUNsQztnQkFFQTs7OztDQUlDLEdBQ0R2RCxNQUFNbUcsU0FBUyxDQUFDMEMsUUFBUSxHQUFHO29CQUN2QixPQUFPLElBQUksQ0FBQ3FjLE9BQU8sQ0FBQ3JjLFFBQVEsTUFBTSxJQUFJLENBQUNzYyxPQUFPLENBQUN0YyxRQUFRO2dCQUMzRDtnQkFFQTs7OztDQUlDLEdBQ0Q3SSxNQUFNbUcsU0FBUyxDQUFDa0IsT0FBTyxHQUFHO29CQUN0QixPQUFPLElBQUksQ0FBQy9DLE1BQU07Z0JBQ3RCO2dCQUVBOzs7O0NBSUMsR0FDRHRFLE1BQU1tRyxTQUFTLENBQUNvZixRQUFRLEdBQUc7b0JBQ3ZCLE9BQU8sSUFBSSxDQUFDTCxPQUFPO2dCQUN2QjtnQkFFQTs7OztDQUlDLEdBQ0RsbEIsTUFBTW1HLFNBQVMsQ0FBQ3FmLFFBQVEsR0FBRztvQkFDdkIsT0FBTyxJQUFJLENBQUNMLE9BQU87Z0JBQ3ZCO2dCQUVBOzs7O0NBSUMsR0FDRG5sQixNQUFNbUcsU0FBUyxDQUFDSSxPQUFPLEdBQUc7b0JBQ3RCLE9BQU8sSUFBSSxDQUFDTixNQUFNO2dCQUN0QjtnQkFFQWpHLE1BQU1tRyxTQUFTLENBQUNPLFdBQVcsR0FBRztvQkFDMUIsT0FBTyxJQUFJLENBQUNyQyxVQUFVO2dCQUMxQjtnQkFFQXJFLE1BQU1tRyxTQUFTLENBQUNLLFdBQVcsR0FBRyxTQUFTQyxJQUFJO29CQUN2QyxJQUFJLENBQUNwQyxVQUFVLEdBQUdvQztnQkFDdEI7Z0JBRUE7Ozs7OztDQU1DLEdBQ0R6RyxNQUFNbUcsU0FBUyxDQUFDc2YsbUJBQW1CLEdBQUc7b0JBQ2xDLE9BQU8sSUFBSSxDQUFDblksa0JBQWtCO2dCQUNsQztnQkFFQTs7OztDQUlDLEdBQ0R0TixNQUFNbUcsU0FBUyxDQUFDdWYsVUFBVSxHQUFHLFlBQVk7Z0JBRXpDOzs7O0NBSUMsR0FDRDFsQixNQUFNbUcsU0FBUyxDQUFDd2YsVUFBVSxHQUFHLFlBQVk7Z0JBRXpDOzs7OztDQUtDLEdBQ0QzbEIsTUFBTW1HLFNBQVMsQ0FBQ3lmLGdCQUFnQixHQUFHLFNBQVNDLE1BQU0sR0FBRztnQkFFckQ7Ozs7O0NBS0MsR0FDRDdsQixNQUFNbUcsU0FBUyxDQUFDMmYsaUJBQWlCLEdBQUcsU0FBU0QsTUFBTSxHQUFHO2dCQUV0RDs7OztDQUlDLEdBQ0Q3bEIsTUFBTW1HLFNBQVMsQ0FBQzRmLFdBQVcsR0FBRyxTQUFTQyxTQUFTLEdBQUc7Z0JBRW5EO0NBQ0MsR0FDRGhtQixNQUFNbUcsU0FBUyxDQUFDOGYsdUJBQXVCLEdBQUcsU0FBUzFULElBQUksR0FBRztnQkFFMUQ7Q0FDQyxHQUNEdlMsTUFBTW1HLFNBQVMsQ0FBQytmLHdCQUF3QixHQUFHLFNBQVMzVCxJQUFJLEdBQUc7Z0JBRTNEOztDQUVDLEdBQ0R2UyxNQUFNbUcsU0FBUyxDQUFDZ2dCLHdCQUF3QixHQUFHLFNBQVM1VCxJQUFJLEdBQUc7WUFHM0Q7WUFBRTtnQkFBQyxpQkFBZ0I7WUFBRTtTQUFFO1FBQUMsR0FBRTtZQUFDLFNBQVMzVCxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDMUQsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdEQsSUFBSUMsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCZixRQUFPRCxPQUFPLEdBQUd5RDtnQkFFakJ4RCxRQUFPRCxPQUFPLENBQUN3b0IsaUJBQWlCLEdBQUdBO2dCQUVuQ3ZvQixRQUFPRCxPQUFPLENBQUN5b0IsVUFBVSxHQUFHQztnQkFFNUJ6b0IsUUFBT0QsT0FBTyxDQUFDMm9CLGNBQWMsR0FBR0E7Z0JBRWhDMW9CLFFBQU9ELE9BQU8sQ0FBQzRvQixVQUFVLEdBQUdBO2dCQUU1QixnQkFBZ0I7Z0JBQ2hCbmxCLFNBQVMrWCxTQUFTLEdBQUc7Z0JBRXJCL1gsU0FBU29ZLE9BQU8sR0FBRztnQkFFbkJwWSxTQUFTdVksT0FBTyxHQUFHO2dCQUVuQixzQkFBc0I7Z0JBQ3RCdlksU0FBU29sQixRQUFRLEdBQUc7Z0JBRXBCcGxCLFNBQVNxbEIsTUFBTSxHQUFHO2dCQUVsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTcmxCO29CQUNMLElBQUksQ0FBQ29CLElBQUksR0FBRyxDQUFDO29CQUNiLElBQUksQ0FBQ3lRLFdBQVcsR0FBRzdULEtBQUtzRCxJQUFJO29CQUM1QixJQUFJLENBQUMrSCxVQUFVLEdBQUdyTCxLQUFLc0QsSUFBSTtvQkFDM0IsSUFBSSxDQUFDMFEsTUFBTSxHQUFHO3dCQUFFLElBQUlzVDt3QkFBaUIsSUFBSUE7cUJBQWlCO29CQUMxRCxJQUFJLENBQUM1VCxVQUFVLEdBQUc7Z0JBQ3RCO2dCQUVBMVIsU0FBUzhFLFNBQVMsQ0FBQzZKLElBQUksR0FBRztvQkFDdEIsSUFBSSxDQUFDdk4sSUFBSSxHQUFHLENBQUM7b0JBQ2IsSUFBSSxDQUFDeVEsV0FBVyxDQUFDM0wsT0FBTztvQkFDeEIsSUFBSSxDQUFDbUQsVUFBVSxDQUFDbkQsT0FBTztvQkFDdkIsSUFBSSxDQUFDOEwsTUFBTSxDQUFDLEVBQUUsQ0FBQ3JELElBQUk7b0JBQ25CLElBQUksQ0FBQ3FELE1BQU0sQ0FBQyxFQUFFLENBQUNyRCxJQUFJO29CQUNuQixJQUFJLENBQUMrQyxVQUFVLEdBQUc7b0JBQ2xCLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTNFQ7b0JBQ0wsSUFBSSxDQUFDamMsVUFBVSxHQUFHckwsS0FBS3NELElBQUk7b0JBQzNCLElBQUksQ0FBQzZRLGFBQWEsR0FBRztvQkFDckIsSUFBSSxDQUFDRSxjQUFjLEdBQUc7b0JBQ3RCLElBQUksQ0FBQzBDLEVBQUUsR0FBRyxJQUFJd1E7Z0JBQ2xCO2dCQUVBRCxjQUFjeGdCLFNBQVMsQ0FBQzZKLElBQUksR0FBRztvQkFDM0IsSUFBSSxDQUFDdEYsVUFBVSxDQUFDbkQsT0FBTztvQkFDdkIsSUFBSSxDQUFDaU0sYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUNFLGNBQWMsR0FBRztvQkFDdEIsSUFBSSxDQUFDMEMsRUFBRSxDQUFDcEcsSUFBSTtnQkFDaEI7Z0JBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBUzRXO29CQUNMLElBQUksQ0FBQ0MsRUFBRSxHQUFHLElBQUlDO2dCQUNsQjtnQkFFQUYsVUFBVXpnQixTQUFTLENBQUM2SixJQUFJLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQzZXLEVBQUUsQ0FBQzdXLElBQUk7Z0JBQ2hCO2dCQUVBK1csT0FBT0MsY0FBYyxDQUFDSixVQUFVemdCLFNBQVMsRUFBRSxPQUFPO29CQUM5QzhnQixLQUFLO3dCQUNELE9BQU8sSUFBSSxDQUFDSixFQUFFLENBQUMzVyxNQUFNLEdBQUcsSUFBSSxDQUFDMlcsRUFBRSxDQUFDelcsTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDeVcsRUFBRSxDQUFDbEYsS0FBSyxHQUFHLEtBQUssSUFBSSxDQUFDa0YsRUFBRSxDQUFDakYsS0FBSyxHQUFHO29CQUN0RjtvQkFDQXNGLFlBQVk7b0JBQ1pDLGNBQWM7Z0JBQ2xCO2dCQUVBUCxVQUFVemdCLFNBQVMsQ0FBQ2lELEdBQUcsR0FBRyxTQUFTM0ssQ0FBQztvQkFDaEMsb0JBQW9CO29CQUNwQixJQUFJLENBQUNvb0IsRUFBRSxDQUFDemQsR0FBRyxDQUFDM0ssRUFBRW9vQixFQUFFO2dCQUNwQjtnQkFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0M7b0JBQ0wsSUFBSSxDQUFDNVcsTUFBTTtvQkFDWCxJQUFJLENBQUNFLE1BQU07b0JBQ1gsSUFBSSxDQUFDdVIsS0FBSztvQkFDVixJQUFJLENBQUNDLEtBQUs7Z0JBQ2Q7Z0JBRUFrRixlQUFlM2dCLFNBQVMsQ0FBQzZKLElBQUksR0FBRztvQkFDNUIsSUFBSSxDQUFDRSxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDRSxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDdVIsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO2dCQUNqQjtnQkFFQWtGLGVBQWUzZ0IsU0FBUyxDQUFDaUQsR0FBRyxHQUFHLFNBQVMzSyxDQUFDO29CQUNyQyxJQUFJLENBQUN5UixNQUFNLEdBQUd6UixFQUFFeVIsTUFBTTtvQkFDdEIsSUFBSSxDQUFDRSxNQUFNLEdBQUczUixFQUFFMlIsTUFBTTtvQkFDdEIsSUFBSSxDQUFDdVIsS0FBSyxHQUFHbGpCLEVBQUVrakIsS0FBSztvQkFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQUduakIsRUFBRW1qQixLQUFLO2dCQUN4QjtnQkFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTd0Y7b0JBQ0wsSUFBSSxDQUFDbE8sTUFBTTtvQkFDWCxJQUFJLENBQUM3RixNQUFNLEdBQUcsRUFBRTtvQkFDaEIsc0JBQXNCO29CQUN0QixJQUFJLENBQUNnVSxXQUFXLEdBQUcsRUFBRTtnQkFDekI7Z0JBRUE7Ozs7OztDQU1DLEdBQ0RobUIsU0FBUzhFLFNBQVMsQ0FBQzhOLGdCQUFnQixHQUFHLFNBQVNxVCxFQUFFLEVBQUVqUyxHQUFHLEVBQUVrRyxPQUFPLEVBQUVqRyxHQUFHLEVBQUVrRyxPQUFPO29CQUN6RSxJQUFJLElBQUksQ0FBQ3pJLFVBQVUsSUFBSSxHQUFHO3dCQUN0QjtvQkFDSjtvQkFDQXVVLEtBQUtBLE1BQU0sSUFBSUY7b0JBQ2YsSUFBSWxPLFNBQVNvTyxHQUFHcE8sTUFBTTtvQkFDdEIsSUFBSTdGLFNBQVNpVSxHQUFHalUsTUFBTTtvQkFDdEIsSUFBSWdVLGNBQWNDLEdBQUdELFdBQVc7b0JBQ2hDLGdCQUFnQjtvQkFDaEIsT0FBUSxJQUFJLENBQUM1a0IsSUFBSTt3QkFDZixLQUFLcEIsU0FBUytYLFNBQVM7NEJBQ3JCRixTQUFTN1osS0FBS2tvQixHQUFHLENBQUMsR0FBRzs0QkFDckIsSUFBSWxPLFNBQVM1WixVQUFVNk8sT0FBTyxDQUFDK0csS0FBSyxJQUFJLENBQUMzSyxVQUFVOzRCQUNuRCxJQUFJNE8sU0FBUzdaLFVBQVU2TyxPQUFPLENBQUNnSCxLQUFLLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQyxFQUFFLENBQUMzSSxVQUFVOzRCQUM3RCxJQUFJOGMsT0FBT25vQixLQUFLaUwsR0FBRyxDQUFDZ1AsUUFBUUQ7NEJBQzVCLElBQUloYSxLQUFLb29CLGFBQWEsQ0FBQ0QsUUFBUXBvQixNQUFLc29CLE9BQU8sR0FBR3RvQixNQUFLc29CLE9BQU8sRUFBRTtnQ0FDeER4TyxPQUFPOVAsR0FBRyxDQUFDb2U7Z0NBQ1h0TyxPQUFPSyxTQUFTOzRCQUNwQjs0QkFDQWxHLE1BQU0sQ0FBQyxFQUFFLEdBQUdoVSxLQUFLc29CLEdBQUcsQ0FBQ3RPLFFBQVFDOzRCQUM3QitOLFdBQVcsQ0FBQyxFQUFFLEdBQUcsQ0FBQzdMLFVBQVVEOzRCQUM1QmxJLE9BQU9uVSxNQUFNLEdBQUc7NEJBQ2hCbW9CLFlBQVlub0IsTUFBTSxHQUFHOzRCQUNyQjt3QkFFRixLQUFLbUMsU0FBU29ZLE9BQU87NEJBQ25CUCxTQUFTeFosSUFBSTRPLE9BQU8sQ0FBQytHLElBQUl0USxDQUFDLEVBQUUsSUFBSSxDQUFDbU8sV0FBVzs0QkFDNUMsSUFBSXdHLGFBQWFqYSxVQUFVNk8sT0FBTyxDQUFDK0csS0FBSyxJQUFJLENBQUMzSyxVQUFVOzRCQUN2RCxJQUFLLElBQUk3TCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDa1UsVUFBVSxFQUFFLEVBQUVsVSxFQUFHO2dDQUN0QyxJQUFJOGEsWUFBWWxhLFVBQVU2TyxPQUFPLENBQUNnSCxLQUFLLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ3hVLEVBQUUsQ0FBQzZMLFVBQVU7Z0NBQ2hFLElBQUlnTyxLQUFLclosS0FBS3lGLEtBQUssQ0FBQzZVLFdBQVd6TixNQUFNLENBQUNxUCxVQUFVbGMsS0FBS3lMLEdBQUcsQ0FBQ3pMLEtBQUtpTCxHQUFHLENBQUNxUCxXQUFXRCxhQUFhUixTQUFTQTtnQ0FDbkcsSUFBSU4sS0FBS3ZaLEtBQUt5RixLQUFLLENBQUM2VSxXQUFXZSxNQUFNLENBQUNjLFNBQVN0QztnQ0FDL0M3RixNQUFNLENBQUN4VSxFQUFFLEdBQUdRLEtBQUtzb0IsR0FBRyxDQUFDalAsSUFBSUU7Z0NBQ3pCeU8sV0FBVyxDQUFDeG9CLEVBQUUsR0FBR1EsS0FBS3lMLEdBQUcsQ0FBQ3pMLEtBQUtpTCxHQUFHLENBQUNzTyxJQUFJRixLQUFLUTs0QkFDaEQ7NEJBQ0E3RixPQUFPblUsTUFBTSxHQUFHLElBQUksQ0FBQzZULFVBQVU7NEJBQy9Cc1UsWUFBWW5vQixNQUFNLEdBQUcsSUFBSSxDQUFDNlQsVUFBVTs0QkFDcEM7d0JBRUYsS0FBSzFSLFNBQVN1WSxPQUFPOzRCQUNuQlYsU0FBU3haLElBQUk0TyxPQUFPLENBQUNnSCxJQUFJdlEsQ0FBQyxFQUFFLElBQUksQ0FBQ21PLFdBQVc7NEJBQzVDLElBQUl3RyxhQUFhamEsVUFBVTZPLE9BQU8sQ0FBQ2dILEtBQUssSUFBSSxDQUFDNUssVUFBVTs0QkFDdkQsSUFBSyxJQUFJN0wsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2tVLFVBQVUsRUFBRSxFQUFFbFUsRUFBRztnQ0FDdEMsSUFBSThhLFlBQVlsYSxVQUFVNk8sT0FBTyxDQUFDK0csS0FBSyxJQUFJLENBQUNoQyxNQUFNLENBQUN4VSxFQUFFLENBQUM2TCxVQUFVO2dDQUNoRSxJQUFJa08sS0FBS3ZaLEtBQUs2a0IsT0FBTyxDQUFDLEdBQUd2SyxXQUFXNkIsVUFBVW5jLEtBQUt5TCxHQUFHLENBQUN6TCxLQUFLaUwsR0FBRyxDQUFDcVAsV0FBV0QsYUFBYVIsU0FBU0E7Z0NBQ2pHLElBQUlSLEtBQUtyWixLQUFLNmtCLE9BQU8sQ0FBQyxHQUFHdkssV0FBVyxDQUFDNEIsU0FBU3JDO2dDQUM5QzdGLE1BQU0sQ0FBQ3hVLEVBQUUsR0FBR1EsS0FBS3NvQixHQUFHLENBQUNqUCxJQUFJRTtnQ0FDekJ5TyxXQUFXLENBQUN4b0IsRUFBRSxHQUFHUSxLQUFLeUwsR0FBRyxDQUFDekwsS0FBS2lMLEdBQUcsQ0FBQ29PLElBQUlFLEtBQUtNOzRCQUNoRDs0QkFDQTdGLE9BQU9uVSxNQUFNLEdBQUcsSUFBSSxDQUFDNlQsVUFBVTs0QkFDL0JzVSxZQUFZbm9CLE1BQU0sR0FBRyxJQUFJLENBQUM2VCxVQUFVOzRCQUNwQyxvQ0FBb0M7NEJBQ3BDbUcsT0FBTy9NLEdBQUcsQ0FBQyxDQUFDOzRCQUNaO29CQUNKO29CQUNBbWIsR0FBR3BPLE1BQU0sR0FBR0E7b0JBQ1pvTyxHQUFHalUsTUFBTSxHQUFHQTtvQkFDWmlVLEdBQUdELFdBQVcsR0FBR0E7b0JBQ2pCLE9BQU9DO2dCQUNYO2dCQUVBOzs7Ozs7O0NBT0MsR0FDRCxJQUFJZCxhQUFhO29CQUNiLHNCQUFzQjtvQkFDdEJvQixXQUFXO29CQUNYQyxVQUFVO29CQUNWQyxjQUFjO29CQUNkQyxhQUFhO2dCQUNqQjtnQkFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3hCLGVBQWV5QixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxTQUFTO29CQUN4RCx5REFBeUQ7b0JBQ3pELG9DQUFvQztvQkFDcEMsb0NBQW9DO29CQUNwQyxJQUFJO29CQUNKLCtCQUErQjtvQkFDL0IsSUFBSyxJQUFJdHBCLElBQUksR0FBR0EsSUFBSXFwQixVQUFVblYsVUFBVSxFQUFFLEVBQUVsVSxFQUFHO3dCQUMzQyxJQUFJdVgsS0FBSzhSLFVBQVU3VSxNQUFNLENBQUN4VSxFQUFFLENBQUN1WCxFQUFFO3dCQUMvQixZQUFZO3dCQUNaNFIsTUFBTSxDQUFDbnBCLEVBQUUsR0FBRzJuQixXQUFXdUIsV0FBVzt3QkFDbEMsSUFBSyxJQUFJNVUsSUFBSSxHQUFHQSxJQUFJZ1YsVUFBVXBWLFVBQVUsRUFBRSxFQUFFSSxFQUFHOzRCQUMzQyxJQUFJZ1YsVUFBVTlVLE1BQU0sQ0FBQ0YsRUFBRSxDQUFDaUQsRUFBRSxDQUFDQyxHQUFHLElBQUlELEdBQUdDLEdBQUcsRUFBRTtnQ0FDdEMyUixNQUFNLENBQUNucEIsRUFBRSxHQUFHMm5CLFdBQVdzQixZQUFZO2dDQUNuQzs0QkFDSjt3QkFDSjtvQkFDSjtvQkFDQSw0QkFBNEI7b0JBQzVCLElBQUssSUFBSWpwQixJQUFJLEdBQUdBLElBQUlzcEIsVUFBVXBWLFVBQVUsRUFBRSxFQUFFbFUsRUFBRzt3QkFDM0MsSUFBSXVYLEtBQUsrUixVQUFVOVUsTUFBTSxDQUFDeFUsRUFBRSxDQUFDdVgsRUFBRTt3QkFDL0IsWUFBWTt3QkFDWjZSLE1BQU0sQ0FBQ3BwQixFQUFFLEdBQUcybkIsV0FBV3FCLFFBQVE7d0JBQy9CLElBQUssSUFBSTFVLElBQUksR0FBR0EsSUFBSStVLFVBQVVuVixVQUFVLEVBQUUsRUFBRUksRUFBRzs0QkFDM0MsSUFBSStVLFVBQVU3VSxNQUFNLENBQUNGLEVBQUUsQ0FBQ2lELEVBQUUsQ0FBQ0MsR0FBRyxJQUFJRCxHQUFHQyxHQUFHLEVBQUU7Z0NBQ3RDNFIsTUFBTSxDQUFDcHBCLEVBQUUsR0FBRzJuQixXQUFXc0IsWUFBWTtnQ0FDbkM7NEJBQ0o7d0JBQ0o7b0JBQ0o7Z0JBQ0o7Z0JBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTeEI7b0JBQ0wsSUFBSSxDQUFDemIsQ0FBQyxHQUFHeEwsS0FBS3NELElBQUk7b0JBQ2xCLElBQUksQ0FBQ3lULEVBQUUsR0FBRyxJQUFJd1E7Z0JBQ2xCO2dCQUVBTixXQUFXbmdCLFNBQVMsQ0FBQ2lELEdBQUcsR0FBRyxTQUFTM0ssQ0FBQztvQkFDakMsSUFBSSxDQUFDb00sQ0FBQyxDQUFDekIsR0FBRyxDQUFDM0ssRUFBRW9NLENBQUM7b0JBQ2QsSUFBSSxDQUFDdUwsRUFBRSxDQUFDaE4sR0FBRyxDQUFDM0ssRUFBRTJYLEVBQUU7Z0JBQ3BCO2dCQUVBa1EsV0FBV25nQixTQUFTLENBQUM2SixJQUFJLEdBQUc7b0JBQ3hCLElBQUksQ0FBQ25GLENBQUMsQ0FBQ3RELE9BQU87b0JBQ2QsSUFBSSxDQUFDNk8sRUFBRSxDQUFDcEcsSUFBSTtnQkFDaEI7Z0JBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTb1csa0JBQWtCZ0MsSUFBSSxFQUFFQyxHQUFHLEVBQUVuUCxNQUFNLEVBQUVvUCxNQUFNLEVBQUVDLFlBQVk7b0JBQzlELDhCQUE4QjtvQkFDOUIsSUFBSUMsU0FBUztvQkFDYixtREFBbUQ7b0JBQ25ELElBQUlDLFlBQVlwcEIsS0FBS3lMLEdBQUcsQ0FBQ29PLFFBQVFtUCxHQUFHLENBQUMsRUFBRSxDQUFDeGQsQ0FBQyxJQUFJeWQ7b0JBQzdDLElBQUlJLFlBQVlycEIsS0FBS3lMLEdBQUcsQ0FBQ29PLFFBQVFtUCxHQUFHLENBQUMsRUFBRSxDQUFDeGQsQ0FBQyxJQUFJeWQ7b0JBQzdDLHFDQUFxQztvQkFDckMsSUFBSUcsYUFBYSxHQUFHTCxJQUFJLENBQUNJLFNBQVMsQ0FBQ3BmLEdBQUcsQ0FBQ2lmLEdBQUcsQ0FBQyxFQUFFO29CQUM3QyxJQUFJSyxhQUFhLEdBQUdOLElBQUksQ0FBQ0ksU0FBUyxDQUFDcGYsR0FBRyxDQUFDaWYsR0FBRyxDQUFDLEVBQUU7b0JBQzdDLG9EQUFvRDtvQkFDcEQsSUFBSUksWUFBWUMsWUFBWSxHQUFHO3dCQUMzQiw0Q0FBNEM7d0JBQzVDLElBQUlDLFNBQVNGLFlBQWFBLENBQUFBLFlBQVlDLFNBQVE7d0JBQzlDTixJQUFJLENBQUNJLE9BQU8sQ0FBQzNkLENBQUMsQ0FBQ2dSLFVBQVUsQ0FBQyxJQUFJOE0sUUFBUU4sR0FBRyxDQUFDLEVBQUUsQ0FBQ3hkLENBQUMsRUFBRThkLFFBQVFOLEdBQUcsQ0FBQyxFQUFFLENBQUN4ZCxDQUFDO3dCQUNoRSw0QkFBNEI7d0JBQzVCdWQsSUFBSSxDQUFDSSxPQUFPLENBQUNwUyxFQUFFLENBQUN5USxFQUFFLENBQUMzVyxNQUFNLEdBQUdxWTt3QkFDNUJILElBQUksQ0FBQ0ksT0FBTyxDQUFDcFMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHaVksR0FBRyxDQUFDLEVBQUUsQ0FBQ2pTLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU07d0JBQy9DZ1ksSUFBSSxDQUFDSSxPQUFPLENBQUNwUyxFQUFFLENBQUN5USxFQUFFLENBQUNsRixLQUFLLEdBQUd0Z0IsU0FBU29sQixRQUFRO3dCQUM1QzJCLElBQUksQ0FBQ0ksT0FBTyxDQUFDcFMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHdmdCLFNBQVNxbEIsTUFBTTt3QkFDMUMsRUFBRThCO29CQUNOO29CQUNBLE9BQU9BO2dCQUNYO1lBR0E7WUFBRTtnQkFBQyxpQkFBZ0I7Z0JBQUcsZ0JBQWU7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxpQkFBZ0I7WUFBRTtTQUFFO1FBQUMsR0FBRTtZQUFDLFNBQVM1cEIsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQzFJLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXRELGlDQUFpQztnQkFDakMsSUFBSUosV0FBVzdEO2dCQUVmOztDQUVDLEdBQ0QsWUFBWTtnQkFDWjs7O0NBR0MsR0FDRDZELFNBQVNtbkIsaUJBQWlCLEdBQUc7Z0JBRTdCOzs7Q0FHQyxHQUNEbm5CLFNBQVNvbkIsa0JBQWtCLEdBQUc7Z0JBRTlCOzs7Q0FHQyxHQUNEcG5CLFNBQVNxbkIsYUFBYSxHQUFHO2dCQUV6Qjs7OztDQUlDLEdBQ0RybkIsU0FBU3NuQixjQUFjLEdBQUc7Z0JBRTFCOzs7Q0FHQyxHQUNEdG5CLFNBQVN1WSxVQUFVLEdBQUc7Z0JBRXRCdlksU0FBU3VuQixpQkFBaUIsR0FBR3ZuQixTQUFTdVksVUFBVSxHQUFHdlksU0FBU3VZLFVBQVU7Z0JBRXRFOzs7Q0FHQyxHQUNEdlksU0FBU3duQixXQUFXLEdBQUcsSUFBSSxNQUFNN3BCLEtBQUs4cEIsRUFBRTtnQkFFeEM7Ozs7O0NBS0MsR0FDRHpuQixTQUFTMG5CLGFBQWEsR0FBRyxJQUFJMW5CLFNBQVN1WSxVQUFVO2dCQUVoRDs7Q0FFQyxHQUNEdlksU0FBUzJuQixXQUFXLEdBQUc7Z0JBRXZCLFdBQVc7Z0JBQ1g7O0NBRUMsR0FDRDNuQixTQUFTNG5CLGNBQWMsR0FBRztnQkFFMUI7O0NBRUMsR0FDRDVuQixTQUFTNm5CLGdCQUFnQixHQUFHO2dCQUU1Qjs7Q0FFQyxHQUNEN25CLFNBQVM4bkIsb0JBQW9CLEdBQUc7Z0JBRWhDOzs7Q0FHQyxHQUNEOW5CLFNBQVM2YSxpQkFBaUIsR0FBRztnQkFFN0I7OztDQUdDLEdBQ0Q3YSxTQUFTd1ksbUJBQW1CLEdBQUc7Z0JBRS9COzs7Q0FHQyxHQUNEeFksU0FBUytuQixvQkFBb0IsR0FBRyxJQUFJLE1BQU1wcUIsS0FBSzhwQixFQUFFO2dCQUVqRDs7O0NBR0MsR0FDRHpuQixTQUFTZ29CLGNBQWMsR0FBRztnQkFFMUJob0IsU0FBU2lvQixxQkFBcUIsR0FBR2pvQixTQUFTZ29CLGNBQWMsR0FBR2hvQixTQUFTZ29CLGNBQWM7Z0JBRWxGOzs7Q0FHQyxHQUNEaG9CLFNBQVNrb0IsV0FBVyxHQUFHLEtBQUt2cUIsS0FBSzhwQixFQUFFO2dCQUVuQ3puQixTQUFTbW9CLGtCQUFrQixHQUFHbm9CLFNBQVNrb0IsV0FBVyxHQUFHbG9CLFNBQVNrb0IsV0FBVztnQkFFekU7Ozs7Q0FJQyxHQUNEbG9CLFNBQVNxWSxTQUFTLEdBQUc7Z0JBRXJCclksU0FBU3NZLFdBQVcsR0FBRztnQkFFdkIsUUFBUTtnQkFDUjs7Q0FFQyxHQUNEdFksU0FBU29vQixXQUFXLEdBQUc7Z0JBRXZCOztDQUVDLEdBQ0Rwb0IsU0FBU3FvQixvQkFBb0IsR0FBRztnQkFFaENyb0IsU0FBU3NvQix1QkFBdUIsR0FBRzNxQixLQUFLNHFCLEdBQUcsQ0FBQ3ZvQixTQUFTcW9CLG9CQUFvQixFQUFFO2dCQUUzRTs7Q0FFQyxHQUNEcm9CLFNBQVN3b0IscUJBQXFCLEdBQUcsSUFBSSxNQUFNN3FCLEtBQUs4cEIsRUFBRTtnQkFFbER6bkIsU0FBU3lvQix3QkFBd0IsR0FBRzlxQixLQUFLNHFCLEdBQUcsQ0FBQ3ZvQixTQUFTd29CLHFCQUFxQixFQUFFO1lBRzdFO1lBQUUsQ0FBQztTQUFFO1FBQUMsR0FBRTtZQUFDLFNBQVNyckIsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3hDLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHZ0M7Z0JBRWpCLElBQUlSLFFBQU9SLFNBQVE7Z0JBRW5COzs7O0NBSUMsR0FDRCxTQUFTZ0I7b0JBQ0wsSUFBSSxDQUFDMEUsTUFBTTtvQkFDWCxJQUFJLENBQUMyTyxRQUFRO2dCQUNqQjtnQkFFQXJULE1BQU0rRCxPQUFPLEdBQUcsU0FBUzZKLEtBQUs7b0JBQzFCLE9BQU8sQ0FBQyxDQUFDQTtnQkFDYjtnQkFFQTVOLE1BQU11RyxTQUFTLENBQUNna0IsU0FBUyxHQUFHO29CQUN4QixPQUFPLElBQUksQ0FBQ2xYLFFBQVE7Z0JBQ3hCO2dCQUVBOzs7OztDQUtDLEdBQ0RyVCxNQUFNdUcsU0FBUyxDQUFDa0IsT0FBTyxHQUFHO29CQUN0QixPQUFPLElBQUksQ0FBQy9DLE1BQU07Z0JBQ3RCO2dCQUVBOzs7O0NBSUMsR0FDRDFFLE1BQU11RyxTQUFTLENBQUNpa0IsTUFBTSxHQUFHLFlBQVk7Z0JBRXJDOztDQUVDLEdBQ0R4cUIsTUFBTXVHLFNBQVMsQ0FBQzZjLGFBQWEsR0FBRyxZQUFZO2dCQUU1Qzs7Ozs7O0NBTUMsR0FDRHBqQixNQUFNdUcsU0FBUyxDQUFDaWQsU0FBUyxHQUFHLFNBQVM3WixFQUFFLEVBQUUxRSxDQUFDLEdBQUc7Z0JBRTdDOzs7Ozs7O0NBT0MsR0FDRGpGLE1BQU11RyxTQUFTLENBQUNrZCxPQUFPLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU4RyxTQUFTLEVBQUU5SCxVQUFVLEdBQUc7Z0JBRTFFOzs7Ozs7O0NBT0MsR0FDRDNpQixNQUFNdUcsU0FBUyxDQUFDd2QsV0FBVyxHQUFHLFNBQVNuQixJQUFJLEVBQUVqWixFQUFFLEVBQUVnWixVQUFVLEdBQUc7Z0JBRTlEOzs7Ozs7Q0FNQyxHQUNEM2lCLE1BQU11RyxTQUFTLENBQUNxZCxXQUFXLEdBQUcsU0FBU3ZYLFFBQVEsRUFBRWlXLE9BQU8sR0FBRztnQkFFM0Q7O0NBRUMsR0FDRHRpQixNQUFNdUcsU0FBUyxDQUFDbWtCLG9CQUFvQixHQUFHLFNBQVM1RyxLQUFLLEdBQUc7WUFHeEQ7WUFBRTtnQkFBQyxpQkFBZ0I7WUFBRTtTQUFFO1FBQUMsR0FBRTtZQUFDLFNBQVM5a0IsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQzFELElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHMnNCO2dCQUVqQjFzQixRQUFPRCxPQUFPLENBQUM0c0IsUUFBUSxHQUFHQTtnQkFFMUIsSUFBSS9vQixXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSWtELFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJa0IsT0FBT2xCLFNBQVE7Z0JBRW5CLElBQUltQixVQUFVbkIsU0FBUTtnQkFFdEIsSUFBSW9CLFFBQVFwQixTQUFRO2dCQUVwQixJQUFJMkMsZUFBZTNDLFNBQVE7Z0JBRTNCLElBQUk2ckIsV0FBV2xwQixhQUFhbXBCLEtBQUs7Z0JBRWpDLElBQUlDLFlBQVlwcEIsYUFBYXFwQixNQUFNO2dCQUVuQyxJQUFJdHBCLFdBQVcxQyxTQUFRO2dCQUV2QixJQUFJaXNCLGdCQUFnQnZwQixTQUFTb3BCLEtBQUs7Z0JBRWxDLElBQUlJLGlCQUFpQnhwQixTQUFTc3BCLE1BQU07Z0JBRXBDLElBQUlHLGdCQUFnQnpwQixTQUFTMHBCLEtBQUs7Z0JBRWxDLElBQUlDLGVBQWUzcEIsU0FBUzRwQixLQUFLO2dCQUVqQyxTQUFTVixTQUFTVyxFQUFFO29CQUNoQixJQUFJLENBQUNBLEVBQUUsR0FBRztvQkFDVixZQUFZO29CQUNaLElBQUksQ0FBQ3RGLE1BQU0sR0FBRztvQkFDZCxtQ0FBbUM7b0JBQ25DLElBQUksQ0FBQ3VGLGtCQUFrQixHQUFHO29CQUMxQixJQUFJLENBQUNDLGtCQUFrQixHQUFHO29CQUMxQixJQUFJLENBQUM5WCxZQUFZLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ2dKLFVBQVUsR0FBRztvQkFDbEIsdUNBQXVDO29CQUN2QyxJQUFJLENBQUMrTyxPQUFPLEdBQUc7b0JBQ2YsSUFBSSxDQUFDN1gsT0FBTyxHQUFHO2dCQUNuQjtnQkFFQStXLFNBQVNya0IsU0FBUyxDQUFDb2xCLEtBQUssR0FBRyxTQUFTSixFQUFFO29CQUNsQyxJQUFJLElBQUksQ0FBQ0EsRUFBRSxHQUFHLEdBQUc7d0JBQ2IsSUFBSSxDQUFDRyxPQUFPLEdBQUcsSUFBSSxDQUFDekYsTUFBTTtvQkFDOUI7b0JBQ0EsSUFBSSxDQUFDc0YsRUFBRSxHQUFHQTtvQkFDVixJQUFJLENBQUN0RixNQUFNLEdBQUdzRixNQUFNLElBQUksSUFBSSxJQUFJQTtvQkFDaEMsSUFBSSxDQUFDMVgsT0FBTyxHQUFHMFgsS0FBSyxJQUFJLENBQUNHLE9BQU87Z0JBQ3BDO2dCQUVBOzs7O0NBSUMsR0FDRCxTQUFTZixPQUFPL21CLEtBQUs7b0JBQ2pCLElBQUksQ0FBQ0ssT0FBTyxHQUFHTDtvQkFDZixJQUFJLENBQUNnb0IsT0FBTyxHQUFHLEVBQUU7b0JBQ2pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7b0JBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEVBQUU7b0JBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7Z0JBQ3RCO2dCQUVBcEIsT0FBT3BrQixTQUFTLENBQUN5bEIsS0FBSyxHQUFHO29CQUNyQixJQUFJLENBQUNKLE9BQU8sQ0FBQ3RzQixNQUFNLEdBQUc7b0JBQ3RCLElBQUksQ0FBQ3VzQixRQUFRLENBQUN2c0IsTUFBTSxHQUFHO29CQUN2QixJQUFJLENBQUN3c0IsVUFBVSxDQUFDeHNCLE1BQU0sR0FBRztvQkFDekIsSUFBSSxDQUFDeXNCLFFBQVEsQ0FBQ3pzQixNQUFNLEdBQUc7Z0JBQzNCO2dCQUVBcXJCLE9BQU9wa0IsU0FBUyxDQUFDMGxCLE9BQU8sR0FBRyxTQUFTcEosSUFBSTtvQkFDcEM3Z0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQytlLGdCQUFnQjNpQixNQUFNLGVBQWUyaUI7b0JBQzlELElBQUksQ0FBQ2dKLFFBQVEsQ0FBQ0ssSUFBSSxDQUFDcko7Z0JBQ3ZCO2dCQUVBOEgsT0FBT3BrQixTQUFTLENBQUM0bEIsVUFBVSxHQUFHLFNBQVNoa0IsT0FBTztvQkFDMUNuRyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDcUUsbUJBQW1CaEksU0FBUyxrQkFBa0JnSTtvQkFDdkUsSUFBSSxDQUFDMmpCLFVBQVUsQ0FBQ0ksSUFBSSxDQUFDL2pCO2dCQUN6QjtnQkFFQXdpQixPQUFPcGtCLFNBQVMsQ0FBQzZsQixRQUFRLEdBQUcsU0FBUzNlLEtBQUs7b0JBQ3RDekwsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzJKLGlCQUFpQnJOLE9BQU8sZ0JBQWdCcU47b0JBQ2pFLElBQUksQ0FBQ3NlLFFBQVEsQ0FBQ0csSUFBSSxDQUFDemU7Z0JBQ3ZCO2dCQUVBOztDQUVDLEdBQ0RrZCxPQUFPcGtCLFNBQVMsQ0FBQzhsQixVQUFVLEdBQUcsU0FBUzFaLElBQUk7b0JBQ3ZDLElBQUkvTyxRQUFRLElBQUksQ0FBQ0ssT0FBTztvQkFDeEIsOEJBQThCO29CQUM5QixJQUFLLElBQUlxb0IsSUFBSTFvQixNQUFNMm9CLFVBQVUsRUFBRUQsR0FBR0EsSUFBSUEsRUFBRWptQixNQUFNLENBQUU7d0JBQzVDaW1CLEVBQUUvbkIsWUFBWSxHQUFHO29CQUNyQjtvQkFDQSxJQUFLLElBQUl1RixJQUFJbEcsTUFBTXNDLGFBQWEsRUFBRTRELEdBQUdBLElBQUlBLEVBQUV6RCxNQUFNLENBQUU7d0JBQy9DeUQsRUFBRXZGLFlBQVksR0FBRztvQkFDckI7b0JBQ0EsSUFBSyxJQUFJZ1AsSUFBSTNQLE1BQU1xQyxXQUFXLEVBQUVzTixHQUFHQSxJQUFJQSxFQUFFbE4sTUFBTSxDQUFFO3dCQUM3Q2tOLEVBQUVoUCxZQUFZLEdBQUc7b0JBQ3JCO29CQUNBLHdDQUF3QztvQkFDeEMsSUFBSWlvQixRQUFRLElBQUksQ0FBQ1osT0FBTztvQkFDeEIsSUFBSWEsT0FBTyxDQUFDO29CQUNaLElBQUssSUFBSUMsT0FBTzlvQixNQUFNMm9CLFVBQVUsRUFBRUcsTUFBTUEsT0FBT0EsS0FBS3JtQixNQUFNLENBQUU7d0JBQ3hEb21CO3dCQUNBLElBQUlDLEtBQUtub0IsWUFBWSxFQUFFOzRCQUNuQjt3QkFDSjt3QkFDQSxJQUFJbW9CLEtBQUsxakIsT0FBTyxNQUFNLFNBQVMwakIsS0FBS3pqQixRQUFRLE1BQU0sT0FBTzs0QkFDckQ7d0JBQ0o7d0JBQ0Esd0NBQXdDO3dCQUN4QyxJQUFJeWpCLEtBQUt4bEIsUUFBUSxJQUFJOzRCQUNqQjt3QkFDSjt3QkFDQSwwQkFBMEI7d0JBQzFCLElBQUksQ0FBQzhrQixLQUFLO3dCQUNWUSxNQUFNTixJQUFJLENBQUNRO3dCQUNYQSxLQUFLbm9CLFlBQVksR0FBRzt3QkFDcEIsOERBQThEO3dCQUM5RCxNQUFPaW9CLE1BQU1sdEIsTUFBTSxHQUFHLEVBQUc7NEJBQ3JCLDZEQUE2RDs0QkFDN0QsSUFBSWd0QixJQUFJRSxNQUFNRyxHQUFHOzRCQUNqQjNxQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDd29CLEVBQUVyakIsUUFBUSxNQUFNOzRCQUN6QyxJQUFJLENBQUNnakIsT0FBTyxDQUFDSzs0QkFDYiwrQkFBK0I7NEJBQy9CQSxFQUFFeGtCLFFBQVEsQ0FBQzs0QkFDWCxpREFBaUQ7NEJBQ2pELDBDQUEwQzs0QkFDMUMsSUFBSXdrQixFQUFFcGxCLFFBQVEsSUFBSTtnQ0FDZDs0QkFDSjs0QkFDQSw4Q0FBOEM7NEJBQzlDLElBQUssSUFBSWEsS0FBS3VrQixFQUFFcG1CLGFBQWEsRUFBRTZCLElBQUlBLEtBQUtBLEdBQUdFLElBQUksQ0FBRTtnQ0FDN0MsSUFBSUUsVUFBVUosR0FBR0ksT0FBTztnQ0FDeEIsb0RBQW9EO2dDQUNwRCxJQUFJQSxRQUFRNUQsWUFBWSxFQUFFO29DQUN0QjtnQ0FDSjtnQ0FDQSxzQ0FBc0M7Z0NBQ3RDLElBQUk0RCxRQUFRcU0sU0FBUyxNQUFNLFNBQVNyTSxRQUFRc00sVUFBVSxNQUFNLE9BQU87b0NBQy9EO2dDQUNKO2dDQUNBLGdCQUFnQjtnQ0FDaEIsSUFBSXVCLFVBQVU3TixRQUFRdUksVUFBVSxDQUFDb1MsVUFBVTtnQ0FDM0MsSUFBSTVNLFVBQVUvTixRQUFRd0ksVUFBVSxDQUFDbVMsVUFBVTtnQ0FDM0MsSUFBSTlNLFdBQVdFLFNBQVM7b0NBQ3BCO2dDQUNKO2dDQUNBLElBQUksQ0FBQ2lXLFVBQVUsQ0FBQ2hrQjtnQ0FDaEJBLFFBQVE1RCxZQUFZLEdBQUc7Z0NBQ3ZCLElBQUlpSixRQUFRekYsR0FBR3lGLEtBQUs7Z0NBQ3BCLG1EQUFtRDtnQ0FDbkQsSUFBSUEsTUFBTWpKLFlBQVksRUFBRTtvQ0FDcEI7Z0NBQ0o7Z0NBQ0EsOERBQThEO2dDQUM5RGlvQixNQUFNTixJQUFJLENBQUMxZTtnQ0FDWEEsTUFBTWpKLFlBQVksR0FBRzs0QkFDekI7NEJBQ0EsMENBQTBDOzRCQUMxQyxJQUFLLElBQUlxb0IsS0FBS04sRUFBRXJtQixXQUFXLEVBQUUybUIsSUFBSUEsS0FBS0EsR0FBRzNrQixJQUFJLENBQUU7Z0NBQzNDLElBQUkya0IsR0FBR25mLEtBQUssQ0FBQ2xKLFlBQVksSUFBSSxNQUFNO29DQUMvQjtnQ0FDSjtnQ0FDQSxJQUFJaUosUUFBUW9mLEdBQUdwZixLQUFLO2dDQUNwQixzREFBc0Q7Z0NBQ3RELElBQUlBLE1BQU12RSxRQUFRLE1BQU0sT0FBTztvQ0FDM0I7Z0NBQ0o7Z0NBQ0EsSUFBSSxDQUFDbWpCLFFBQVEsQ0FBQ1EsR0FBR25mLEtBQUs7Z0NBQ3RCbWYsR0FBR25mLEtBQUssQ0FBQ2xKLFlBQVksR0FBRztnQ0FDeEIsSUFBSWlKLE1BQU1qSixZQUFZLEVBQUU7b0NBQ3BCO2dDQUNKO2dDQUNBLDhEQUE4RDtnQ0FDOURpb0IsTUFBTU4sSUFBSSxDQUFDMWU7Z0NBQ1hBLE1BQU1qSixZQUFZLEdBQUc7NEJBQ3pCO3dCQUNKO3dCQUNBLElBQUksQ0FBQ3NvQixXQUFXLENBQUNsYTt3QkFDakIsc0JBQXNCO3dCQUN0QixJQUFLLElBQUkxVCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNHNCLFFBQVEsQ0FBQ3ZzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzs0QkFDM0MsdURBQXVEOzRCQUN2RCwrQkFBK0I7NEJBQy9CLElBQUlxdEIsSUFBSSxJQUFJLENBQUNULFFBQVEsQ0FBQzVzQixFQUFFOzRCQUN4QixJQUFJcXRCLEVBQUVwbEIsUUFBUSxJQUFJO2dDQUNkb2xCLEVBQUUvbkIsWUFBWSxHQUFHOzRCQUNyQjt3QkFDSjtvQkFDSjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEb21CLE9BQU9wa0IsU0FBUyxDQUFDc21CLFdBQVcsR0FBRyxTQUFTbGEsSUFBSTtvQkFDeEMsbUJBQW1CO29CQUNuQixJQUFJL08sUUFBUSxJQUFJLENBQUNLLE9BQU87b0JBQ3hCLElBQUk2b0IsVUFBVWxwQixNQUFNbXBCLFNBQVM7b0JBQzdCLElBQUl2cEIsYUFBYUksTUFBTW9wQixZQUFZO29CQUNuQyxJQUFJQyxJQUFJdGEsS0FBSzRZLEVBQUU7b0JBQ2YscUVBQXFFO29CQUNyRSxJQUFLLElBQUl0c0IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzRzQixRQUFRLENBQUN2c0IsTUFBTSxFQUFFLEVBQUVMLEVBQUc7d0JBQzNDLElBQUk0akIsT0FBTyxJQUFJLENBQUNnSixRQUFRLENBQUM1c0IsRUFBRTt3QkFDM0IsSUFBSTZLLElBQUlySyxLQUFLeUYsS0FBSyxDQUFDMmQsS0FBS3hkLE9BQU8sQ0FBQ3lFLENBQUM7d0JBQ2pDLElBQUkvSyxJQUFJOGpCLEtBQUt4ZCxPQUFPLENBQUN0RyxDQUFDO3dCQUN0QixJQUFJa00sSUFBSXhMLEtBQUt5RixLQUFLLENBQUMyZCxLQUFLbGQsZ0JBQWdCO3dCQUN4QyxJQUFJMEYsSUFBSXdYLEtBQUtqZCxpQkFBaUI7d0JBQzlCLDRDQUE0Qzt3QkFDNUNpZCxLQUFLeGQsT0FBTyxDQUFDMEUsRUFBRSxDQUFDUCxHQUFHLENBQUNxWixLQUFLeGQsT0FBTyxDQUFDeUUsQ0FBQzt3QkFDbEMrWSxLQUFLeGQsT0FBTyxDQUFDMkUsRUFBRSxHQUFHNlksS0FBS3hkLE9BQU8sQ0FBQ3RHLENBQUM7d0JBQ2hDLElBQUk4akIsS0FBSzFiLFNBQVMsSUFBSTs0QkFDbEIsd0JBQXdCOzRCQUN4QjhELEVBQUVxQixNQUFNLENBQUMyZ0IsSUFBSXBLLEtBQUs5YyxjQUFjLEVBQUUrbUI7NEJBQ2xDN2hCLEVBQUVxQixNQUFNLENBQUMyZ0IsSUFBSXBLLEtBQUtqZSxTQUFTLEVBQUVpZSxLQUFLcGQsT0FBTzs0QkFDekM0RixLQUFLNGhCLElBQUlwSyxLQUFLL2QsTUFBTSxHQUFHK2QsS0FBS25kLFFBQVE7NEJBQ3BDOzs7Ozs7Ozs7O09BVUwsR0FDS3VGLEVBQUVzQixHQUFHLENBQUMsSUFBSyxDQUFBLElBQUkwZ0IsSUFBSXBLLEtBQUtoZCxlQUFlLEFBQUQ7NEJBQ3RDd0YsS0FBSyxJQUFLLENBQUEsSUFBSTRoQixJQUFJcEssS0FBSy9jLGdCQUFnQixBQUFEO3dCQUMxQzt3QkFDQStjLEtBQUtyZCxVQUFVLENBQUNzRSxDQUFDLEdBQUdBO3dCQUNwQitZLEtBQUtyZCxVQUFVLENBQUN6RyxDQUFDLEdBQUdBO3dCQUNwQjhqQixLQUFLdGQsVUFBVSxDQUFDMEYsQ0FBQyxHQUFHQTt3QkFDcEI0WCxLQUFLdGQsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHQTtvQkFDeEI7b0JBQ0EsSUFBSyxJQUFJcE0sSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzZzQixVQUFVLENBQUN4c0IsTUFBTSxFQUFFLEVBQUVMLEVBQUc7d0JBQzdDLElBQUlrSixVQUFVLElBQUksQ0FBQzJqQixVQUFVLENBQUM3c0IsRUFBRTt3QkFDaENrSixRQUFRdUssY0FBYyxDQUFDQztvQkFDM0I7b0JBQ0E3USxVQUFVLElBQUksQ0FBQ29yQixXQUFXLENBQUM7b0JBQzNCLElBQUssSUFBSWp1QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNnNCLFVBQVUsQ0FBQ3hzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDN0MsSUFBSWtKLFVBQVUsSUFBSSxDQUFDMmpCLFVBQVUsQ0FBQzdzQixFQUFFO3dCQUNoQ2tKLFFBQVF1VCxzQkFBc0IsQ0FBQy9JO29CQUNuQztvQkFDQTdRLFVBQVUsSUFBSSxDQUFDb3JCLFdBQVcsQ0FBQztvQkFDM0IsSUFBSXZhLEtBQUtnQixZQUFZLEVBQUU7d0JBQ25CLGNBQWM7d0JBQ2QsSUFBSyxJQUFJMVUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzZzQixVQUFVLENBQUN4c0IsTUFBTSxFQUFFLEVBQUVMLEVBQUc7NEJBQzdDLElBQUlrSixVQUFVLElBQUksQ0FBQzJqQixVQUFVLENBQUM3c0IsRUFBRTs0QkFDaENrSixRQUFRMFYsbUJBQW1CLENBQUNsTDt3QkFDaEM7b0JBQ0o7b0JBQ0E3USxVQUFVLElBQUksQ0FBQ29yQixXQUFXLENBQUM7b0JBQzNCLElBQUssSUFBSWp1QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOHNCLFFBQVEsQ0FBQ3pzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDM0MsSUFBSXdPLFFBQVEsSUFBSSxDQUFDc2UsUUFBUSxDQUFDOXNCLEVBQUU7d0JBQzVCd08sTUFBTTRZLHVCQUF1QixDQUFDMVQ7b0JBQ2xDO29CQUNBN1EsVUFBVSxJQUFJLENBQUNvckIsV0FBVyxDQUFDO29CQUMzQiw2QkFBNkI7b0JBQzdCLElBQUssSUFBSWp1QixJQUFJLEdBQUdBLElBQUkwVCxLQUFLNlksa0JBQWtCLEVBQUUsRUFBRXZzQixFQUFHO3dCQUM5QyxJQUFLLElBQUlzVSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDd1ksUUFBUSxDQUFDenNCLE1BQU0sRUFBRSxFQUFFaVUsRUFBRzs0QkFDM0MsSUFBSTlGLFFBQVEsSUFBSSxDQUFDc2UsUUFBUSxDQUFDeFksRUFBRTs0QkFDNUI5RixNQUFNNlksd0JBQXdCLENBQUMzVDt3QkFDbkM7d0JBQ0EsSUFBSyxJQUFJWSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdVksVUFBVSxDQUFDeHNCLE1BQU0sRUFBRSxFQUFFaVUsRUFBRzs0QkFDN0MsSUFBSXBMLFVBQVUsSUFBSSxDQUFDMmpCLFVBQVUsQ0FBQ3ZZLEVBQUU7NEJBQ2hDcEwsUUFBUTJXLHVCQUF1QixDQUFDbk07d0JBQ3BDO29CQUNKO29CQUNBN1EsVUFBVSxJQUFJLENBQUNvckIsV0FBVyxDQUFDO29CQUMzQixtQ0FBbUM7b0JBQ25DLElBQUssSUFBSWp1QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNnNCLFVBQVUsQ0FBQ3hzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDN0MsSUFBSWtKLFVBQVUsSUFBSSxDQUFDMmpCLFVBQVUsQ0FBQzdzQixFQUFFO3dCQUNoQ2tKLFFBQVEyVix1QkFBdUIsQ0FBQ25MO29CQUNwQztvQkFDQTdRLFVBQVUsSUFBSSxDQUFDb3JCLFdBQVcsQ0FBQztvQkFDM0Isc0JBQXNCO29CQUN0QixJQUFLLElBQUlqdUIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzRzQixRQUFRLENBQUN2c0IsTUFBTSxFQUFFLEVBQUVMLEVBQUc7d0JBQzNDLElBQUk0akIsT0FBTyxJQUFJLENBQUNnSixRQUFRLENBQUM1c0IsRUFBRTt3QkFDM0IsSUFBSTZLLElBQUlySyxLQUFLeUYsS0FBSyxDQUFDMmQsS0FBS3JkLFVBQVUsQ0FBQ3NFLENBQUM7d0JBQ3BDLElBQUkvSyxJQUFJOGpCLEtBQUtyZCxVQUFVLENBQUN6RyxDQUFDO3dCQUN6QixJQUFJa00sSUFBSXhMLEtBQUt5RixLQUFLLENBQUMyZCxLQUFLdGQsVUFBVSxDQUFDMEYsQ0FBQzt3QkFDcEMsSUFBSUksSUFBSXdYLEtBQUt0ZCxVQUFVLENBQUM4RixDQUFDO3dCQUN6Qiw2QkFBNkI7d0JBQzdCLElBQUk4aEIsY0FBYzF0QixLQUFLOE0sR0FBRyxDQUFDMGdCLEdBQUdoaUI7d0JBQzlCLElBQUl4TCxLQUFLb29CLGFBQWEsQ0FBQ3NGLGVBQWV0ckIsU0FBU2lvQixxQkFBcUIsRUFBRTs0QkFDbEUsSUFBSXNELFFBQVF2ckIsU0FBU2dvQixjQUFjLEdBQUdzRCxZQUFZN3RCLE1BQU07NEJBQ3hEMkwsRUFBRXNCLEdBQUcsQ0FBQzZnQjt3QkFDVjt3QkFDQSxJQUFJQyxXQUFXSixJQUFJNWhCO3dCQUNuQixJQUFJZ2lCLFdBQVdBLFdBQVd4ckIsU0FBU21vQixrQkFBa0IsRUFBRTs0QkFDbkQsSUFBSW9ELFFBQVF2ckIsU0FBU2tvQixXQUFXLEdBQUd2cUIsTUFBSzBoQixHQUFHLENBQUNtTTs0QkFDNUNoaUIsS0FBSytoQjt3QkFDVDt3QkFDQSxZQUFZO3dCQUNadGpCLEVBQUV3QyxNQUFNLENBQUMyZ0IsR0FBR2hpQjt3QkFDWmxNLEtBQUtrdUIsSUFBSTVoQjt3QkFDVHdYLEtBQUtyZCxVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ007d0JBQ3RCK1ksS0FBS3JkLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR0E7d0JBQ3BCOGpCLEtBQUt0ZCxVQUFVLENBQUMwRixDQUFDLENBQUN6QixHQUFHLENBQUN5Qjt3QkFDdEI0WCxLQUFLdGQsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHQTtvQkFDeEI7b0JBQ0F2SixVQUFVLElBQUksQ0FBQ29yQixXQUFXLENBQUM7b0JBQzNCLDZCQUE2QjtvQkFDN0IsSUFBSUksaUJBQWlCO29CQUNyQixJQUFLLElBQUlydUIsSUFBSSxHQUFHQSxJQUFJMFQsS0FBSzhZLGtCQUFrQixFQUFFLEVBQUV4c0IsRUFBRzt3QkFDOUMsSUFBSWlhLGdCQUFnQjt3QkFDcEIsSUFBSyxJQUFJM0YsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3VZLFVBQVUsQ0FBQ3hzQixNQUFNLEVBQUUsRUFBRWlVLEVBQUc7NEJBQzdDLElBQUlwTCxVQUFVLElBQUksQ0FBQzJqQixVQUFVLENBQUN2WSxFQUFFOzRCQUNoQyxJQUFJZ0csYUFBYXBSLFFBQVEwTyx1QkFBdUIsQ0FBQ2xFOzRCQUNqRHVHLGdCQUFnQjFaLE1BQUt5YSxHQUFHLENBQUNmLGVBQWVLO3dCQUM1Qzt3QkFDQSwwRUFBMEU7d0JBQzFFLGtEQUFrRDt3QkFDbEQsSUFBSWdVLGVBQWVyVSxpQkFBaUIsQ0FBQyxJQUFJclgsU0FBU3VZLFVBQVU7d0JBQzVELElBQUlvVCxhQUFhO3dCQUNqQixJQUFLLElBQUlqYSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDd1ksUUFBUSxDQUFDenNCLE1BQU0sRUFBRSxFQUFFaVUsRUFBRzs0QkFDM0MsSUFBSTlGLFFBQVEsSUFBSSxDQUFDc2UsUUFBUSxDQUFDeFksRUFBRTs0QkFDNUIsSUFBSWthLFlBQVloZ0IsTUFBTThZLHdCQUF3QixDQUFDNVQ7NEJBQy9DNmEsYUFBYUEsY0FBY0M7d0JBQy9CO3dCQUNBLElBQUlGLGdCQUFnQkMsWUFBWTs0QkFDNUIsK0NBQStDOzRCQUMvQ0YsaUJBQWlCOzRCQUNqQjt3QkFDSjtvQkFDSjtvQkFDQXhyQixVQUFVLElBQUksQ0FBQ29yQixXQUFXLENBQUM7b0JBQzNCLHdDQUF3QztvQkFDeEMsSUFBSyxJQUFJanVCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM0c0IsUUFBUSxDQUFDdnNCLE1BQU0sRUFBRSxFQUFFTCxFQUFHO3dCQUMzQyxJQUFJNGpCLE9BQU8sSUFBSSxDQUFDZ0osUUFBUSxDQUFDNXNCLEVBQUU7d0JBQzNCNGpCLEtBQUt4ZCxPQUFPLENBQUN5RSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3FaLEtBQUtyZCxVQUFVLENBQUNzRSxDQUFDO3dCQUNwQytZLEtBQUt4ZCxPQUFPLENBQUN0RyxDQUFDLEdBQUc4akIsS0FBS3JkLFVBQVUsQ0FBQ3pHLENBQUM7d0JBQ2xDOGpCLEtBQUtsZCxnQkFBZ0IsQ0FBQzZELEdBQUcsQ0FBQ3FaLEtBQUt0ZCxVQUFVLENBQUMwRixDQUFDO3dCQUMzQzRYLEtBQUtqZCxpQkFBaUIsR0FBR2lkLEtBQUt0ZCxVQUFVLENBQUM4RixDQUFDO3dCQUMxQ3dYLEtBQUtuWixvQkFBb0I7b0JBQzdCO29CQUNBLElBQUksQ0FBQ2drQixlQUFlO29CQUNwQixJQUFJbHFCLFlBQVk7d0JBQ1osSUFBSW1xQixlQUFlQzt3QkFDbkIsSUFBSUMsWUFBWWhzQixTQUFTc29CLHVCQUF1Qjt3QkFDaEQsSUFBSTJELFlBQVlqc0IsU0FBU3lvQix3QkFBd0I7d0JBQ2pELElBQUssSUFBSXJyQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNHNCLFFBQVEsQ0FBQ3ZzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzs0QkFDM0MsSUFBSTRqQixPQUFPLElBQUksQ0FBQ2dKLFFBQVEsQ0FBQzVzQixFQUFFOzRCQUMzQixJQUFJNGpCLEtBQUszYixRQUFRLElBQUk7Z0NBQ2pCOzRCQUNKOzRCQUNBLElBQUkyYixLQUFLMWUsZUFBZSxJQUFJLFNBQVMwZSxLQUFLamQsaUJBQWlCLEdBQUdpZCxLQUFLamQsaUJBQWlCLEdBQUdrb0IsYUFBYXJ1QixLQUFLb29CLGFBQWEsQ0FBQ2hGLEtBQUtsZCxnQkFBZ0IsSUFBSWtvQixXQUFXO2dDQUN2SmhMLEtBQUs3YyxXQUFXLEdBQUc7Z0NBQ25CMm5CLGVBQWU7NEJBQ25CLE9BQU87Z0NBQ0g5SyxLQUFLN2MsV0FBVyxJQUFJaW5CO2dDQUNwQlUsZUFBZW51QixNQUFLeWEsR0FBRyxDQUFDMFQsY0FBYzlLLEtBQUs3YyxXQUFXOzRCQUMxRDt3QkFDSjt3QkFDQSxJQUFJMm5CLGdCQUFnQjlyQixTQUFTb29CLFdBQVcsSUFBSXFELGdCQUFnQjs0QkFDeEQsSUFBSyxJQUFJcnVCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM0c0IsUUFBUSxDQUFDdnNCLE1BQU0sRUFBRSxFQUFFTCxFQUFHO2dDQUMzQyxJQUFJNGpCLE9BQU8sSUFBSSxDQUFDZ0osUUFBUSxDQUFDNXNCLEVBQUU7Z0NBQzNCNGpCLEtBQUsvYSxRQUFRLENBQUM7NEJBQ2xCO3dCQUNKO29CQUNKO2dCQUNKO2dCQUVBNmlCLE9BQU9wa0IsU0FBUyxDQUFDMm1CLFdBQVcsR0FBRyxTQUFTYSxHQUFHO29CQUN2QyxJQUFLLElBQUk5dUIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzRzQixRQUFRLENBQUN2c0IsTUFBTSxFQUFFLEVBQUVMLEVBQUc7d0JBQzNDLElBQUlxdEIsSUFBSSxJQUFJLENBQUNULFFBQVEsQ0FBQzVzQixFQUFFO3dCQUN4QmlELFFBQU84ckIsS0FBSyxDQUFDRCxLQUFLekIsRUFBRTltQixVQUFVLENBQUN6RyxDQUFDLEVBQUV1dEIsRUFBRTltQixVQUFVLENBQUNzRSxDQUFDLENBQUNrVixDQUFDLEVBQUVzTixFQUFFOW1CLFVBQVUsQ0FBQ3NFLENBQUMsQ0FBQ29WLENBQUMsRUFBRW9OLEVBQUUvbUIsVUFBVSxDQUFDOEYsQ0FBQyxFQUFFaWhCLEVBQUUvbUIsVUFBVSxDQUFDMEYsQ0FBQyxDQUFDK1QsQ0FBQyxFQUFFc04sRUFBRS9tQixVQUFVLENBQUMwRixDQUFDLENBQUNpVSxDQUFDO29CQUM1SDtnQkFDSjtnQkFFQSxJQUFJK08sWUFBWSxJQUFJckQ7Z0JBRXBCLFFBQVE7Z0JBQ1I7Ozs7Q0FJQyxHQUNERCxPQUFPcGtCLFNBQVMsQ0FBQzJuQixhQUFhLEdBQUcsU0FBU3ZiLElBQUk7b0JBQzFDLElBQUkvTyxRQUFRLElBQUksQ0FBQ0ssT0FBTztvQkFDeEIsSUFBSUwsTUFBTXVxQixjQUFjLEVBQUU7d0JBQ3RCLElBQUssSUFBSTdCLElBQUkxb0IsTUFBTTJvQixVQUFVLEVBQUVELEdBQUdBLElBQUlBLEVBQUVqbUIsTUFBTSxDQUFFOzRCQUM1Q2ltQixFQUFFL25CLFlBQVksR0FBRzs0QkFDakIrbkIsRUFBRWpuQixPQUFPLENBQUMrb0IsTUFBTSxHQUFHO3dCQUN2Qjt3QkFDQSxJQUFLLElBQUl0a0IsSUFBSWxHLE1BQU1zQyxhQUFhLEVBQUU0RCxHQUFHQSxJQUFJQSxFQUFFekQsTUFBTSxDQUFFOzRCQUMvQyxpQkFBaUI7NEJBQ2pCeUQsRUFBRXRGLFNBQVMsR0FBRzs0QkFDZHNGLEVBQUV2RixZQUFZLEdBQUc7NEJBQ2pCdUYsRUFBRWtILFVBQVUsR0FBRzs0QkFDZmxILEVBQUVpSCxLQUFLLEdBQUc7d0JBQ2Q7b0JBQ0o7b0JBQ0Esa0NBQWtDO29CQUNsQyxPQUFTO3dCQUNMLHNCQUFzQjt3QkFDdEIsSUFBSXNkLGFBQWE7d0JBQ2pCLFVBQVU7d0JBQ1YsSUFBSUMsV0FBVzt3QkFDZixJQUFLLElBQUl4a0IsSUFBSWxHLE1BQU1zQyxhQUFhLEVBQUU0RCxHQUFHQSxJQUFJQSxFQUFFekQsTUFBTSxDQUFFOzRCQUMvQyw0QkFBNEI7NEJBQzVCLElBQUl5RCxFQUFFMEssU0FBUyxNQUFNLE9BQU87Z0NBQ3hCOzRCQUNKOzRCQUNBLGtDQUFrQzs0QkFDbEMsSUFBSTFLLEVBQUVrSCxVQUFVLEdBQUduUCxTQUFTMm5CLFdBQVcsRUFBRTtnQ0FDckM7NEJBQ0o7NEJBQ0EsSUFBSTNmLFFBQVE7NEJBQ1osSUFBSUMsRUFBRXRGLFNBQVMsRUFBRTtnQ0FDYix1Q0FBdUM7Z0NBQ3ZDcUYsUUFBUUMsRUFBRWlILEtBQUs7NEJBQ25CLE9BQU87Z0NBQ0gsSUFBSVYsS0FBS3ZHLEVBQUV3RSxXQUFXO2dDQUN0QixJQUFJaUMsS0FBS3pHLEVBQUUwRSxXQUFXO2dDQUN0QixxQkFBcUI7Z0NBQ3JCLElBQUk2QixHQUFHNEYsUUFBUSxNQUFNMUYsR0FBRzBGLFFBQVEsSUFBSTtvQ0FDaEM7Z0NBQ0o7Z0NBQ0EsSUFBSXNZLEtBQUtsZSxHQUFHMkMsT0FBTztnQ0FDbkIsSUFBSXdiLEtBQUtqZSxHQUFHeUMsT0FBTztnQ0FDbkJoUixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDeXFCLEdBQUdwbkIsU0FBUyxNQUFNcW5CLEdBQUdybkIsU0FBUztnQ0FDdkQsSUFBSXNuQixVQUFVRixHQUFHdmxCLE9BQU8sTUFBTSxDQUFDdWxCLEdBQUdybkIsUUFBUTtnQ0FDMUMsSUFBSXduQixVQUFVRixHQUFHeGxCLE9BQU8sTUFBTSxDQUFDd2xCLEdBQUd0bkIsUUFBUTtnQ0FDMUMsZ0VBQWdFO2dDQUNoRSxJQUFJdW5CLFdBQVcsU0FBU0MsV0FBVyxPQUFPO29DQUN0QztnQ0FDSjtnQ0FDQSxJQUFJQyxXQUFXSixHQUFHNWxCLFFBQVEsTUFBTSxDQUFDNGxCLEdBQUdwbkIsU0FBUztnQ0FDN0MsSUFBSXluQixXQUFXSixHQUFHN2xCLFFBQVEsTUFBTSxDQUFDNmxCLEdBQUdybkIsU0FBUztnQ0FDN0MsMkNBQTJDO2dDQUMzQyxJQUFJd25CLFlBQVksU0FBU0MsWUFBWSxPQUFPO29DQUN4QztnQ0FDSjtnQ0FDQSxvQ0FBb0M7Z0NBQ3BDLDhDQUE4QztnQ0FDOUMsSUFBSVIsU0FBU0csR0FBR2xwQixPQUFPLENBQUMrb0IsTUFBTTtnQ0FDOUIsSUFBSUcsR0FBR2xwQixPQUFPLENBQUMrb0IsTUFBTSxHQUFHSSxHQUFHbnBCLE9BQU8sQ0FBQytvQixNQUFNLEVBQUU7b0NBQ3ZDQSxTQUFTSSxHQUFHbnBCLE9BQU8sQ0FBQytvQixNQUFNO29DQUMxQkcsR0FBR2xwQixPQUFPLENBQUN1RSxPQUFPLENBQUN3a0I7Z0NBQ3ZCLE9BQU8sSUFBSUksR0FBR25wQixPQUFPLENBQUMrb0IsTUFBTSxHQUFHRyxHQUFHbHBCLE9BQU8sQ0FBQytvQixNQUFNLEVBQUU7b0NBQzlDQSxTQUFTRyxHQUFHbHBCLE9BQU8sQ0FBQytvQixNQUFNO29DQUMxQkksR0FBR25wQixPQUFPLENBQUN1RSxPQUFPLENBQUN3a0I7Z0NBQ3ZCO2dDQUNBcHNCLFdBQVdFLFFBQU80QixNQUFNLENBQUNzcUIsU0FBUztnQ0FDbEMsSUFBSTlkLFNBQVN4RyxFQUFFNEssY0FBYztnQ0FDN0IsSUFBSWxFLFNBQVMxRyxFQUFFNkssY0FBYztnQ0FDN0IsSUFBSWthLFNBQVNOLEdBQUdscEIsT0FBTztnQ0FDdkIsSUFBSXlwQixTQUFTTixHQUFHbnBCLE9BQU87Z0NBQ3ZCLHFEQUFxRDtnQ0FDckQsSUFBSXNlLFFBQVEsSUFBSWtIO2dDQUNoQixjQUFjO2dDQUNkbEgsTUFBTW9MLE1BQU0sQ0FBQ3ZsQixHQUFHLENBQUM2RyxHQUFHd0MsUUFBUSxJQUFJdkM7Z0NBQ2hDcVQsTUFBTXFMLE1BQU0sQ0FBQ3hsQixHQUFHLENBQUMrRyxHQUFHc0MsUUFBUSxJQUFJckM7Z0NBQ2hDbVQsTUFBTWtMLE1BQU0sQ0FBQ3JsQixHQUFHLENBQUMra0IsR0FBR2xwQixPQUFPO2dDQUMzQnNlLE1BQU1tTCxNQUFNLENBQUN0bEIsR0FBRyxDQUFDZ2xCLEdBQUducEIsT0FBTztnQ0FDM0JzZSxNQUFNc0wsSUFBSSxHQUFHO2dDQUNiLElBQUl2TCxTQUFTLElBQUlxSDtnQ0FDakIsY0FBYztnQ0FDZHBwQixhQUFhK2hCLFFBQVFDO2dDQUNyQixnRUFBZ0U7Z0NBQ2hFLElBQUl1TCxPQUFPeEwsT0FBT2psQixDQUFDO2dDQUNuQixJQUFJaWxCLE9BQU95TCxLQUFLLElBQUlwRSxVQUFVcUUsVUFBVSxFQUFFO29DQUN0Q3ZsQixRQUFRckssTUFBS3lhLEdBQUcsQ0FBQ21VLFNBQVMsQUFBQyxDQUFBLElBQUlBLE1BQUssSUFBS2MsTUFBTTtnQ0FDbkQsT0FBTztvQ0FDSHJsQixRQUFRO2dDQUNaO2dDQUNBQyxFQUFFaUgsS0FBSyxHQUFHbEg7Z0NBQ1ZDLEVBQUV0RixTQUFTLEdBQUc7NEJBQ2xCOzRCQUNBLElBQUlxRixRQUFReWtCLFVBQVU7Z0NBQ2xCLHdDQUF3QztnQ0FDeENELGFBQWF2a0I7Z0NBQ2J3a0IsV0FBV3prQjs0QkFDZjt3QkFDSjt3QkFDQSxJQUFJd2tCLGNBQWMsUUFBUSxJQUFJLEtBQUs3dUIsTUFBS3NvQixPQUFPLEdBQUd3RyxVQUFVOzRCQUN4RCw0QkFBNEI7NEJBQzVCMXFCLE1BQU11cUIsY0FBYyxHQUFHOzRCQUN2Qjt3QkFDSjt3QkFDQSxpQ0FBaUM7d0JBQ2pDLElBQUk5ZCxLQUFLZ2UsV0FBVy9mLFdBQVc7d0JBQy9CLElBQUlpQyxLQUFLOGQsV0FBVzdmLFdBQVc7d0JBQy9CLElBQUkrZixLQUFLbGUsR0FBRzJDLE9BQU87d0JBQ25CLElBQUl3YixLQUFLamUsR0FBR3lDLE9BQU87d0JBQ25CLElBQUlxYyxVQUFVZCxHQUFHbHBCLE9BQU8sQ0FBQ0gsS0FBSzt3QkFDOUIsSUFBSW9xQixVQUFVZCxHQUFHbnBCLE9BQU8sQ0FBQ0gsS0FBSzt3QkFDOUJxcEIsR0FBRzNrQixPQUFPLENBQUMwa0I7d0JBQ1hFLEdBQUc1a0IsT0FBTyxDQUFDMGtCO3dCQUNYLHNEQUFzRDt3QkFDdERELFdBQVd6WSxNQUFNLENBQUNoUzt3QkFDbEJ5cUIsV0FBVzdwQixTQUFTLEdBQUc7d0JBQ3ZCLEVBQUU2cEIsV0FBV3JkLFVBQVU7d0JBQ3ZCLHdCQUF3Qjt3QkFDeEIsSUFBSXFkLFdBQVc3WixTQUFTLE1BQU0sU0FBUzZaLFdBQVc1WixVQUFVLE1BQU0sT0FBTzs0QkFDckUsc0JBQXNCOzRCQUN0QjRaLFdBQVc5WixVQUFVLENBQUM7NEJBQ3RCZ2EsR0FBR2xwQixPQUFPLENBQUNtRSxHQUFHLENBQUM2bEI7NEJBQ2ZiLEdBQUducEIsT0FBTyxDQUFDbUUsR0FBRyxDQUFDOGxCOzRCQUNmZixHQUFHN2tCLG9CQUFvQjs0QkFDdkI4a0IsR0FBRzlrQixvQkFBb0I7NEJBQ3ZCO3dCQUNKO3dCQUNBNmtCLEdBQUd6bUIsUUFBUSxDQUFDO3dCQUNaMG1CLEdBQUcxbUIsUUFBUSxDQUFDO3dCQUNaLG1CQUFtQjt3QkFDbkIsSUFBSSxDQUFDa2tCLEtBQUs7d0JBQ1YsSUFBSSxDQUFDQyxPQUFPLENBQUNzQzt3QkFDYixJQUFJLENBQUN0QyxPQUFPLENBQUN1Qzt3QkFDYixJQUFJLENBQUNyQyxVQUFVLENBQUNrQzt3QkFDaEJFLEdBQUdocUIsWUFBWSxHQUFHO3dCQUNsQmlxQixHQUFHanFCLFlBQVksR0FBRzt3QkFDbEI4cEIsV0FBVzlwQixZQUFZLEdBQUc7d0JBQzFCLG1DQUFtQzt3QkFDbkMsSUFBSWdyQixTQUFTOzRCQUFFaEI7NEJBQUlDO3lCQUFJO3dCQUN2QixJQUFLLElBQUl2dkIsSUFBSSxHQUFHQSxJQUFJc3dCLE9BQU9qd0IsTUFBTSxFQUFFLEVBQUVMLEVBQUc7NEJBQ3BDLElBQUk0akIsT0FBTzBNLE1BQU0sQ0FBQ3R3QixFQUFFOzRCQUNwQixJQUFJNGpCLEtBQUsxYixTQUFTLElBQUk7Z0NBQ2xCLElBQUssSUFBSVksS0FBSzhhLEtBQUszYyxhQUFhLEVBQUU2QixJQUFJQSxLQUFLQSxHQUFHRSxJQUFJLENBQUU7b0NBQ2hELDBEQUEwRDtvQ0FDMUQsZ0VBQWdFO29DQUNoRSxJQUFJRSxVQUFVSixHQUFHSSxPQUFPO29DQUN4QixxREFBcUQ7b0NBQ3JELElBQUlBLFFBQVE1RCxZQUFZLEVBQUU7d0NBQ3RCO29DQUNKO29DQUNBLHFEQUFxRDtvQ0FDckQsSUFBSWlKLFFBQVF6RixHQUFHeUYsS0FBSztvQ0FDcEIsSUFBSUEsTUFBTXJHLFNBQVMsTUFBTSxDQUFDMGIsS0FBS2xhLFFBQVEsTUFBTSxDQUFDNkUsTUFBTTdFLFFBQVEsSUFBSTt3Q0FDNUQ7b0NBQ0o7b0NBQ0EsZ0JBQWdCO29DQUNoQixJQUFJcU4sVUFBVTdOLFFBQVF1SSxVQUFVLENBQUNvUyxVQUFVO29DQUMzQyxJQUFJNU0sVUFBVS9OLFFBQVF3SSxVQUFVLENBQUNtUyxVQUFVO29DQUMzQyxJQUFJOU0sV0FBV0UsU0FBUzt3Q0FDcEI7b0NBQ0o7b0NBQ0EsMkNBQTJDO29DQUMzQyxJQUFJc1osU0FBU2hpQixNQUFNbkksT0FBTyxDQUFDSCxLQUFLO29DQUNoQyxJQUFJc0ksTUFBTWpKLFlBQVksSUFBSSxPQUFPO3dDQUM3QmlKLE1BQU01RCxPQUFPLENBQUMwa0I7b0NBQ2xCO29DQUNBLDRCQUE0QjtvQ0FDNUJubUIsUUFBUXlOLE1BQU0sQ0FBQ2hTO29DQUNmLHdDQUF3QztvQ0FDeEMsNEJBQTRCO29DQUM1QixJQUFJdUUsUUFBUXFNLFNBQVMsTUFBTSxTQUFTck0sUUFBUXNNLFVBQVUsTUFBTSxPQUFPO3dDQUMvRGpILE1BQU1uSSxPQUFPLENBQUNtRSxHQUFHLENBQUNnbUI7d0NBQ2xCaGlCLE1BQU05RCxvQkFBb0I7d0NBQzFCO29DQUNKO29DQUNBLGdDQUFnQztvQ0FDaEN2QixRQUFRNUQsWUFBWSxHQUFHO29DQUN2QixJQUFJLENBQUM0bkIsVUFBVSxDQUFDaGtCO29DQUNoQix1REFBdUQ7b0NBQ3ZELElBQUlxRixNQUFNakosWUFBWSxFQUFFO3dDQUNwQjtvQ0FDSjtvQ0FDQSxvQ0FBb0M7b0NBQ3BDaUosTUFBTWpKLFlBQVksR0FBRztvQ0FDckIsSUFBSSxDQUFDaUosTUFBTXRHLFFBQVEsSUFBSTt3Q0FDbkJzRyxNQUFNMUYsUUFBUSxDQUFDO29DQUNuQjtvQ0FDQSxJQUFJLENBQUNta0IsT0FBTyxDQUFDemU7Z0NBQ2pCOzRCQUNKO3dCQUNKO3dCQUNBeWdCLFVBQVV0QyxLQUFLLENBQUMsQUFBQyxDQUFBLElBQUkyQyxRQUFPLElBQUszYixLQUFLNFksRUFBRTt3QkFDeEMwQyxVQUFVcGEsT0FBTyxHQUFHO3dCQUNwQm9hLFVBQVV4QyxrQkFBa0IsR0FBRzt3QkFDL0J3QyxVQUFVekMsa0JBQWtCLEdBQUc3WSxLQUFLNlksa0JBQWtCO3dCQUN0RHlDLFVBQVV0YSxZQUFZLEdBQUc7d0JBQ3pCLElBQUksQ0FBQzhiLGNBQWMsQ0FBQ3hCLFdBQVdNLElBQUlDO3dCQUNuQywwREFBMEQ7d0JBQzFELElBQUssSUFBSXZ2QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNHNCLFFBQVEsQ0FBQ3ZzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzs0QkFDM0MsSUFBSTRqQixPQUFPLElBQUksQ0FBQ2dKLFFBQVEsQ0FBQzVzQixFQUFFOzRCQUMzQjRqQixLQUFLdGUsWUFBWSxHQUFHOzRCQUNwQixJQUFJLENBQUNzZSxLQUFLMWIsU0FBUyxJQUFJO2dDQUNuQjs0QkFDSjs0QkFDQTBiLEtBQUtoYixtQkFBbUI7NEJBQ3hCLHNEQUFzRDs0QkFDdEQsSUFBSyxJQUFJRSxLQUFLOGEsS0FBSzNjLGFBQWEsRUFBRTZCLElBQUlBLEtBQUtBLEdBQUdFLElBQUksQ0FBRTtnQ0FDaERGLEdBQUdJLE9BQU8sQ0FBQzNELFNBQVMsR0FBRztnQ0FDdkJ1RCxHQUFHSSxPQUFPLENBQUM1RCxZQUFZLEdBQUc7NEJBQzlCO3dCQUNKO3dCQUNBLHlFQUF5RTt3QkFDekUsZUFBZTt3QkFDZix3Q0FBd0M7d0JBQ3hDWCxNQUFNOHJCLGVBQWU7d0JBQ3JCLElBQUk5ckIsTUFBTStyQixhQUFhLEVBQUU7NEJBQ3JCL3JCLE1BQU11cUIsY0FBYyxHQUFHOzRCQUN2Qjt3QkFDSjtvQkFDSjtvQkFDQSxJQUFJcnNCLFFBQVEsSUFBSyxJQUFJd3FCLElBQUkxb0IsTUFBTTJvQixVQUFVLEVBQUVELEdBQUdBLElBQUlBLEVBQUVqbUIsTUFBTSxDQUFFO3dCQUN4RCxJQUFJeUQsSUFBSXdpQixFQUFFam5CLE9BQU8sQ0FBQ3lFLENBQUM7d0JBQ25CLElBQUkvSyxJQUFJdXRCLEVBQUVqbkIsT0FBTyxDQUFDdEcsQ0FBQzt3QkFDbkIsSUFBSWtNLElBQUlxaEIsRUFBRTNtQixnQkFBZ0I7d0JBQzFCLElBQUkwRixJQUFJaWhCLEVBQUUxbUIsaUJBQWlCO29CQUMvQjtnQkFDSjtnQkFFQTs7OztDQUlDLEdBQ0Qra0IsT0FBT3BrQixTQUFTLENBQUNrcEIsY0FBYyxHQUFHLFNBQVNHLE9BQU8sRUFBRTVZLElBQUksRUFBRUMsSUFBSTtvQkFDMUQsSUFBSXJULFFBQVEsSUFBSSxDQUFDSyxPQUFPO29CQUN4Qiw2QkFBNkI7b0JBQzdCLElBQUssSUFBSWhGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM0c0IsUUFBUSxDQUFDdnNCLE1BQU0sRUFBRSxFQUFFTCxFQUFHO3dCQUMzQyxJQUFJNGpCLE9BQU8sSUFBSSxDQUFDZ0osUUFBUSxDQUFDNXNCLEVBQUU7d0JBQzNCNGpCLEtBQUtyZCxVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3FaLEtBQUt4ZCxPQUFPLENBQUN5RSxDQUFDO3dCQUNwQytZLEtBQUtyZCxVQUFVLENBQUN6RyxDQUFDLEdBQUc4akIsS0FBS3hkLE9BQU8sQ0FBQ3RHLENBQUM7d0JBQ2xDOGpCLEtBQUt0ZCxVQUFVLENBQUMwRixDQUFDLENBQUN6QixHQUFHLENBQUNxWixLQUFLbGQsZ0JBQWdCO3dCQUMzQ2tkLEtBQUt0ZCxVQUFVLENBQUM4RixDQUFDLEdBQUd3WCxLQUFLamQsaUJBQWlCO29CQUM5QztvQkFDQSxJQUFLLElBQUkzRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNnNCLFVBQVUsQ0FBQ3hzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDN0MsSUFBSWtKLFVBQVUsSUFBSSxDQUFDMmpCLFVBQVUsQ0FBQzdzQixFQUFFO3dCQUNoQ2tKLFFBQVF1SyxjQUFjLENBQUNrZDtvQkFDM0I7b0JBQ0EsOEJBQThCO29CQUM5QixJQUFLLElBQUkzd0IsSUFBSSxHQUFHQSxJQUFJMndCLFFBQVFuRSxrQkFBa0IsRUFBRSxFQUFFeHNCLEVBQUc7d0JBQ2pELElBQUlpYSxnQkFBZ0I7d0JBQ3BCLElBQUssSUFBSTNGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN1WSxVQUFVLENBQUN4c0IsTUFBTSxFQUFFLEVBQUVpVSxFQUFHOzRCQUM3QyxJQUFJcEwsVUFBVSxJQUFJLENBQUMyakIsVUFBVSxDQUFDdlksRUFBRTs0QkFDaEMsSUFBSWdHLGFBQWFwUixRQUFRNE8sMEJBQTBCLENBQUM2WSxTQUFTNVksTUFBTUM7NEJBQ25FaUMsZ0JBQWdCMVosTUFBS3lhLEdBQUcsQ0FBQ2YsZUFBZUs7d0JBQzVDO3dCQUNBLDBFQUEwRTt3QkFDMUUsa0RBQWtEO3dCQUNsRCxJQUFJZ1UsZUFBZXJVLGlCQUFpQixDQUFDLE1BQU1yWCxTQUFTdVksVUFBVTt3QkFDOUQsSUFBSW1ULGNBQWM7NEJBQ2Q7d0JBQ0o7b0JBQ0o7b0JBQ0EsSUFBSSxPQUFPO3dCQUNQLG1DQUFtQzt3QkFDbkMsSUFBSyxJQUFJdHVCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2c0IsVUFBVSxDQUFDeHNCLE1BQU0sRUFBRSxFQUFFTCxFQUFHOzRCQUM3QyxJQUFJNkssSUFBSSxJQUFJLENBQUNnaUIsVUFBVSxDQUFDN3NCLEVBQUU7NEJBQzFCLElBQUlvUixLQUFLdkcsRUFBRXdFLFdBQVc7NEJBQ3RCLElBQUlpQyxLQUFLekcsRUFBRTBFLFdBQVc7NEJBQ3RCLElBQUkrZixLQUFLbGUsR0FBRzJDLE9BQU87NEJBQ25CLElBQUl3YixLQUFLamUsR0FBR3lDLE9BQU87NEJBQ25CLElBQUkxQyxTQUFTeEcsRUFBRTRLLGNBQWM7NEJBQzdCLElBQUlsRSxTQUFTMUcsRUFBRTZLLGNBQWM7NEJBQzdCLElBQUlnUCxRQUFRLElBQUlzSDs0QkFDaEJ0SCxNQUFNb0wsTUFBTSxDQUFDdmxCLEdBQUcsQ0FBQzZHLEdBQUd3QyxRQUFRLElBQUl2Qzs0QkFDaENxVCxNQUFNcUwsTUFBTSxDQUFDeGxCLEdBQUcsQ0FBQytHLEdBQUdzQyxRQUFRLElBQUlyQzs0QkFDaENtVCxNQUFNa00sVUFBVSxHQUFHdEIsR0FBR2hsQixZQUFZOzRCQUNsQ29hLE1BQU1tTSxVQUFVLEdBQUd0QixHQUFHamxCLFlBQVk7NEJBQ2xDb2EsTUFBTW9NLFFBQVEsR0FBRzs0QkFDakIsSUFBSXJNLFNBQVMsSUFBSXdIOzRCQUNqQixJQUFJOEUsUUFBUSxJQUFJM0U7NEJBQ2hCM3BCLFNBQVNnaUIsUUFBUXNNLE9BQU9yTTs0QkFDeEIsSUFBSUQsT0FBT3VNLFFBQVEsSUFBSSxLQUFLRCxNQUFNRSxLQUFLLElBQUksR0FBRztnQ0FDMUNGLE1BQU1FLEtBQUssSUFBSTs0QkFDbkI7d0JBQ0o7b0JBQ0o7b0JBQ0EsbUNBQW1DO29CQUNuQ2xaLEtBQUszUixPQUFPLENBQUMwRSxFQUFFLENBQUNQLEdBQUcsQ0FBQ3dOLEtBQUt4UixVQUFVLENBQUNzRSxDQUFDO29CQUNyQ2tOLEtBQUszUixPQUFPLENBQUMyRSxFQUFFLEdBQUdnTixLQUFLeFIsVUFBVSxDQUFDekcsQ0FBQztvQkFDbkNrWSxLQUFLNVIsT0FBTyxDQUFDMEUsRUFBRSxDQUFDUCxHQUFHLENBQUN5TixLQUFLelIsVUFBVSxDQUFDc0UsQ0FBQztvQkFDckNtTixLQUFLNVIsT0FBTyxDQUFDMkUsRUFBRSxHQUFHaU4sS0FBS3pSLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ25DLHlEQUF5RDtvQkFDekQseURBQXlEO29CQUN6RCxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2c0IsVUFBVSxDQUFDeHNCLE1BQU0sRUFBRSxFQUFFTCxFQUFHO3dCQUM3QyxJQUFJa0osVUFBVSxJQUFJLENBQUMyakIsVUFBVSxDQUFDN3NCLEVBQUU7d0JBQ2hDa0osUUFBUXVULHNCQUFzQixDQUFDa1U7b0JBQ25DO29CQUNBLDhCQUE4QjtvQkFDOUIsSUFBSyxJQUFJM3dCLElBQUksR0FBR0EsSUFBSTJ3QixRQUFRcEUsa0JBQWtCLEVBQUUsRUFBRXZzQixFQUFHO3dCQUNqRCxJQUFLLElBQUlzVSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdVksVUFBVSxDQUFDeHNCLE1BQU0sRUFBRSxFQUFFaVUsRUFBRzs0QkFDN0MsSUFBSXBMLFVBQVUsSUFBSSxDQUFDMmpCLFVBQVUsQ0FBQ3ZZLEVBQUU7NEJBQ2hDcEwsUUFBUTJXLHVCQUF1QixDQUFDOFE7d0JBQ3BDO29CQUNKO29CQUNBLHVEQUF1RDtvQkFDdkQsbUNBQW1DO29CQUNuQyxJQUFJM0MsSUFBSTJDLFFBQVFyRSxFQUFFO29CQUNsQixzQkFBc0I7b0JBQ3RCLElBQUssSUFBSXRzQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNHNCLFFBQVEsQ0FBQ3ZzQixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDM0MsSUFBSTRqQixPQUFPLElBQUksQ0FBQ2dKLFFBQVEsQ0FBQzVzQixFQUFFO3dCQUMzQixJQUFJNkssSUFBSXJLLEtBQUt5RixLQUFLLENBQUMyZCxLQUFLcmQsVUFBVSxDQUFDc0UsQ0FBQzt3QkFDcEMsSUFBSS9LLElBQUk4akIsS0FBS3JkLFVBQVUsQ0FBQ3pHLENBQUM7d0JBQ3pCLElBQUlrTSxJQUFJeEwsS0FBS3lGLEtBQUssQ0FBQzJkLEtBQUt0ZCxVQUFVLENBQUMwRixDQUFDO3dCQUNwQyxJQUFJSSxJQUFJd1gsS0FBS3RkLFVBQVUsQ0FBQzhGLENBQUM7d0JBQ3pCLDZCQUE2Qjt3QkFDN0IsSUFBSThoQixjQUFjMXRCLEtBQUs4TSxHQUFHLENBQUMwZ0IsR0FBR2hpQjt3QkFDOUIsSUFBSXhMLEtBQUt5TCxHQUFHLENBQUNpaUIsYUFBYUEsZUFBZXRyQixTQUFTaW9CLHFCQUFxQixFQUFFOzRCQUNyRSxJQUFJc0QsUUFBUXZyQixTQUFTZ29CLGNBQWMsR0FBR3NELFlBQVk3dEIsTUFBTTs0QkFDeEQyTCxFQUFFc0IsR0FBRyxDQUFDNmdCO3dCQUNWO3dCQUNBLElBQUlDLFdBQVdKLElBQUk1aEI7d0JBQ25CLElBQUlnaUIsV0FBV0EsV0FBV3hyQixTQUFTbW9CLGtCQUFrQixFQUFFOzRCQUNuRCxJQUFJb0QsUUFBUXZyQixTQUFTa29CLFdBQVcsR0FBR3ZxQixNQUFLMGhCLEdBQUcsQ0FBQ21NOzRCQUM1Q2hpQixLQUFLK2hCO3dCQUNUO3dCQUNBLFlBQVk7d0JBQ1p0akIsRUFBRXdDLE1BQU0sQ0FBQzJnQixHQUFHaGlCO3dCQUNabE0sS0FBS2t1QixJQUFJNWhCO3dCQUNUd1gsS0FBS3JkLFVBQVUsQ0FBQ3NFLENBQUMsR0FBR0E7d0JBQ3BCK1ksS0FBS3JkLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR0E7d0JBQ3BCOGpCLEtBQUt0ZCxVQUFVLENBQUMwRixDQUFDLEdBQUdBO3dCQUNwQjRYLEtBQUt0ZCxVQUFVLENBQUM4RixDQUFDLEdBQUdBO3dCQUNwQixjQUFjO3dCQUNkd1gsS0FBS3hkLE9BQU8sQ0FBQ3lFLENBQUMsR0FBR0E7d0JBQ2pCK1ksS0FBS3hkLE9BQU8sQ0FBQ3RHLENBQUMsR0FBR0E7d0JBQ2pCOGpCLEtBQUtsZCxnQkFBZ0IsR0FBR3NGO3dCQUN4QjRYLEtBQUtqZCxpQkFBaUIsR0FBR3lGO3dCQUN6QndYLEtBQUtuWixvQkFBb0I7b0JBQzdCO29CQUNBLElBQUksQ0FBQ2drQixlQUFlO2dCQUN4QjtnQkFFQTs7OztDQUlDLEdBQ0QsU0FBU3lDO29CQUNMLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEVBQUU7b0JBQ3hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEVBQUU7Z0JBQzdCO2dCQUVBMUYsT0FBT3BrQixTQUFTLENBQUNtbkIsZUFBZSxHQUFHO29CQUMvQix1REFBdUQ7b0JBQ3ZELElBQUl2Z0IsVUFBVSxJQUFJZ2pCO29CQUNsQixJQUFLLElBQUlybUIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2dpQixVQUFVLENBQUN4c0IsTUFBTSxFQUFFLEVBQUV3SyxFQUFHO3dCQUM3QyxJQUFJM0IsVUFBVSxJQUFJLENBQUMyakIsVUFBVSxDQUFDaGlCLEVBQUU7d0JBQ2hDLElBQUssSUFBSTdFLElBQUksR0FBR0EsSUFBSWtELFFBQVF1SCxRQUFRLENBQUNwUSxNQUFNLEVBQUUsRUFBRTJGLEVBQUc7NEJBQzlDa0ksUUFBUWlqQixjQUFjLENBQUNsRSxJQUFJLENBQUMvakIsUUFBUXVILFFBQVEsQ0FBQ3pLLEVBQUUsQ0FBQzJPLGFBQWE7NEJBQzdEekcsUUFBUWtqQixlQUFlLENBQUNuRSxJQUFJLENBQUMvakIsUUFBUXVILFFBQVEsQ0FBQ3pLLEVBQUUsQ0FBQzZPLGNBQWM7d0JBQ25FO3dCQUNBLElBQUksQ0FBQzdQLE9BQU8sQ0FBQ3FzQixTQUFTLENBQUNub0IsU0FBU2dGO29CQUNwQztnQkFDSjtZQUdBO1lBQUU7Z0JBQUMsVUFBUztnQkFBRSxhQUFZO2dCQUFFLFdBQVU7Z0JBQUUsY0FBYTtnQkFBRSx3QkFBdUI7Z0JBQUcsNEJBQTJCO2dCQUFHLGlCQUFnQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsaUJBQWdCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTbk8sUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQzdNLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHcUM7Z0JBRWpCLElBQUk4QixVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSWtELFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJdXhCLGFBQWF2eEIsU0FBUTtnQkFFekIsSUFBSTJyQixTQUFTM3JCLFNBQVE7Z0JBRXJCLElBQUlrQixPQUFPbEIsU0FBUTtnQkFFbkIsSUFBSW1CLFVBQVVuQixTQUFRO2dCQUV0Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELElBQUl3eEIsV0FBVztvQkFDWDFELFNBQVNydEIsS0FBS3NELElBQUk7b0JBQ2xCUyxZQUFZO29CQUNabVEsY0FBYztvQkFDZDhjLG1CQUFtQjtvQkFDbkJDLGFBQWE7b0JBQ2IvVCxZQUFZO29CQUNaNk8sb0JBQW9CO29CQUNwQkMsb0JBQW9CO2dCQUN4QjtnQkFFQTs7Q0FFQyxHQUNELFNBQVNwckIsTUFBTXdELEdBQUc7b0JBQ2QsSUFBSSxDQUFFLENBQUEsSUFBSSxZQUFZeEQsS0FBSSxHQUFJO3dCQUMxQixPQUFPLElBQUlBLE1BQU13RDtvQkFDckI7b0JBQ0EsSUFBSUEsT0FBT3BFLEtBQUtzRSxPQUFPLENBQUNGLE1BQU07d0JBQzFCQSxNQUFNOzRCQUNGaXBCLFNBQVNqcEI7d0JBQ2I7b0JBQ0o7b0JBQ0FBLE1BQU0xQixRQUFRMEIsS0FBSzJzQjtvQkFDbkIsSUFBSSxDQUFDRyxRQUFRLEdBQUcsSUFBSWhHLE9BQU8sSUFBSTtvQkFDL0IsSUFBSSxDQUFDdGlCLFlBQVksR0FBRyxJQUFJa29CO29CQUN4QixJQUFJLENBQUNycUIsYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUMwcUIsY0FBYyxHQUFHO29CQUN0QixJQUFJLENBQUNyRSxVQUFVLEdBQUc7b0JBQ2xCLElBQUksQ0FBQ3NFLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxDQUFDNXFCLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxDQUFDNnFCLFlBQVksR0FBRztvQkFDcEIsSUFBSSxDQUFDM0MsY0FBYyxHQUFHO29CQUN0QixJQUFJLENBQUNuQixZQUFZLEdBQUducEIsSUFBSUwsVUFBVTtvQkFDbEMsSUFBSSxDQUFDdXBCLFNBQVMsR0FBR3R0QixLQUFLeUYsS0FBSyxDQUFDckIsSUFBSWlwQixPQUFPO29CQUN2QyxJQUFJLENBQUNpRSxhQUFhLEdBQUc7b0JBQ3JCLElBQUksQ0FBQ2hqQixZQUFZLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ2lqQixRQUFRLEdBQUc7b0JBQ2hCLHNDQUFzQztvQkFDdEMsSUFBSSxDQUFDQyxjQUFjLEdBQUdwdEIsSUFBSThQLFlBQVk7b0JBQ3RDLElBQUksQ0FBQ3VkLG1CQUFtQixHQUFHcnRCLElBQUk0c0IsaUJBQWlCO29CQUNoRCxJQUFJLENBQUNkLGFBQWEsR0FBRzlyQixJQUFJNnNCLFdBQVc7b0JBQ3BDLElBQUksQ0FBQ1MsWUFBWSxHQUFHdHRCLElBQUk4WSxVQUFVO29CQUNsQyxJQUFJLENBQUN5VSxvQkFBb0IsR0FBR3Z0QixJQUFJMm5CLGtCQUFrQjtvQkFDbEQsSUFBSSxDQUFDNkYsb0JBQW9CLEdBQUd4dEIsSUFBSTRuQixrQkFBa0I7b0JBQ2xELElBQUksQ0FBQzZGLEdBQUcsR0FBRztvQkFDWCxJQUFJLENBQUNDLFdBQVcsR0FBRztvQkFDbkIsd0JBQXdCO29CQUN4QixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7Z0JBQy9DO2dCQUVBOzs7OztDQUtDLEdBQ0RyeEIsTUFBTWtHLFNBQVMsQ0FBQ29yQixXQUFXLEdBQUc7b0JBQzFCLE9BQU8sSUFBSSxDQUFDcEYsVUFBVTtnQkFDMUI7Z0JBRUE7Ozs7O0NBS0MsR0FDRGxzQixNQUFNa0csU0FBUyxDQUFDUyxZQUFZLEdBQUc7b0JBQzNCLE9BQU8sSUFBSSxDQUFDZixXQUFXO2dCQUMzQjtnQkFFQTs7Ozs7Ozs7Q0FRQyxHQUNENUYsTUFBTWtHLFNBQVMsQ0FBQ1UsY0FBYyxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQ2YsYUFBYTtnQkFDN0I7Z0JBRUE3RixNQUFNa0csU0FBUyxDQUFDcXJCLFlBQVksR0FBRztvQkFDM0IsT0FBTyxJQUFJLENBQUNmLFdBQVc7Z0JBQzNCO2dCQUVBeHdCLE1BQU1rRyxTQUFTLENBQUNzckIsYUFBYSxHQUFHO29CQUM1QixPQUFPLElBQUksQ0FBQ2YsWUFBWTtnQkFDNUI7Z0JBRUE7O0NBRUMsR0FDRHp3QixNQUFNa0csU0FBUyxDQUFDdXJCLGVBQWUsR0FBRztvQkFDOUIsT0FBTyxJQUFJLENBQUNsQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEdndCLE1BQU1rRyxTQUFTLENBQUN3ckIsVUFBVSxHQUFHLFNBQVNqRixPQUFPO29CQUN6QyxJQUFJLENBQUNDLFNBQVMsR0FBR0Q7Z0JBQ3JCO2dCQUVBOztDQUVDLEdBQ0R6c0IsTUFBTWtHLFNBQVMsQ0FBQ3lyQixVQUFVLEdBQUc7b0JBQ3pCLE9BQU8sSUFBSSxDQUFDakYsU0FBUztnQkFDekI7Z0JBRUE7O0NBRUMsR0FDRDFzQixNQUFNa0csU0FBUyxDQUFDRSxRQUFRLEdBQUc7b0JBQ3ZCLE9BQU8sSUFBSSxDQUFDdXFCLFFBQVE7Z0JBQ3hCO2dCQUVBOztDQUVDLEdBQ0Qzd0IsTUFBTWtHLFNBQVMsQ0FBQzByQixnQkFBZ0IsR0FBRyxTQUFTcHBCLElBQUk7b0JBQzVDLElBQUlBLFFBQVEsSUFBSSxDQUFDbWtCLFlBQVksRUFBRTt3QkFDM0I7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDQSxZQUFZLEdBQUdua0I7b0JBQ3BCLElBQUksSUFBSSxDQUFDbWtCLFlBQVksSUFBSSxPQUFPO3dCQUM1QixJQUFLLElBQUlWLElBQUksSUFBSSxDQUFDQyxVQUFVLEVBQUVELEdBQUdBLElBQUlBLEVBQUVqbUIsTUFBTSxDQUFFOzRCQUMzQ2ltQixFQUFFeGtCLFFBQVEsQ0FBQzt3QkFDZjtvQkFDSjtnQkFDSjtnQkFFQXpILE1BQU1rRyxTQUFTLENBQUMyckIsZ0JBQWdCLEdBQUc7b0JBQy9CLE9BQU8sSUFBSSxDQUFDbEYsWUFBWTtnQkFDNUI7Z0JBRUE7O0NBRUMsR0FDRDNzQixNQUFNa0csU0FBUyxDQUFDNHJCLGVBQWUsR0FBRyxTQUFTdHBCLElBQUk7b0JBQzNDLElBQUksQ0FBQ29vQixjQUFjLEdBQUdwb0I7Z0JBQzFCO2dCQUVBeEksTUFBTWtHLFNBQVMsQ0FBQzZyQixlQUFlLEdBQUc7b0JBQzlCLE9BQU8sSUFBSSxDQUFDbkIsY0FBYztnQkFDOUI7Z0JBRUE7O0NBRUMsR0FDRDV3QixNQUFNa0csU0FBUyxDQUFDOHJCLG9CQUFvQixHQUFHLFNBQVN4cEIsSUFBSTtvQkFDaEQsSUFBSSxDQUFDcW9CLG1CQUFtQixHQUFHcm9CO2dCQUMvQjtnQkFFQXhJLE1BQU1rRyxTQUFTLENBQUMrckIsb0JBQW9CLEdBQUc7b0JBQ25DLE9BQU8sSUFBSSxDQUFDcEIsbUJBQW1CO2dCQUNuQztnQkFFQTs7Q0FFQyxHQUNEN3dCLE1BQU1rRyxTQUFTLENBQUNnc0IsY0FBYyxHQUFHLFNBQVMxcEIsSUFBSTtvQkFDMUMsSUFBSSxDQUFDOG1CLGFBQWEsR0FBRzltQjtnQkFDekI7Z0JBRUF4SSxNQUFNa0csU0FBUyxDQUFDaXNCLGNBQWMsR0FBRztvQkFDN0IsT0FBTyxJQUFJLENBQUM3QyxhQUFhO2dCQUM3QjtnQkFFQTs7Q0FFQyxHQUNEdHZCLE1BQU1rRyxTQUFTLENBQUNrc0Isa0JBQWtCLEdBQUcsU0FBUzVwQixJQUFJO29CQUM5QyxJQUFJLENBQUNrb0IsYUFBYSxHQUFHbG9CO2dCQUN6QjtnQkFFQTs7Q0FFQyxHQUNEeEksTUFBTWtHLFNBQVMsQ0FBQ21zQixrQkFBa0IsR0FBRztvQkFDakMsT0FBTyxJQUFJLENBQUMzQixhQUFhO2dCQUM3QjtnQkFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0Qxd0IsTUFBTWtHLFNBQVMsQ0FBQ29zQixXQUFXLEdBQUc7b0JBQzFCLElBQUssSUFBSTlQLE9BQU8sSUFBSSxDQUFDMEosVUFBVSxFQUFFMUosTUFBTUEsT0FBT0EsS0FBS2xjLE9BQU8sR0FBSTt3QkFDMURrYyxLQUFLcGQsT0FBTyxDQUFDa0MsT0FBTzt3QkFDcEJrYixLQUFLbmQsUUFBUSxHQUFHO29CQUNwQjtnQkFDSjtnQkFFQTs7OztDQUlDLEdBQ0Q7Ozs7Ozs7O0NBUUMsR0FDRHJGLE1BQU1rRyxTQUFTLENBQUNxc0IsU0FBUyxHQUFHLFNBQVNoUSxJQUFJLEVBQUVpUSxhQUFhO29CQUNwRDd3QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLE9BQU8rdUIsa0JBQWtCO29CQUNsRCxJQUFJenFCLGFBQWEsSUFBSSxDQUFDQyxZQUFZO29CQUNsQyxJQUFJLENBQUNBLFlBQVksQ0FBQ3lxQixLQUFLLENBQUNsUSxNQUFNLFNBQVNsYSxPQUFPO3dCQUMxQyxTQUFTO3dCQUNULElBQUlvYixRQUFRMWIsV0FBV3RCLFdBQVcsQ0FBQzRCO3dCQUNuQyxlQUFlO3dCQUNmLE9BQU9tcUIsY0FBYy9PLE1BQU1oVyxPQUFPO29CQUN0QztnQkFDSjtnQkFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQ0R6TixNQUFNa0csU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNzUCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMscUJBQXFCO29CQUNwRWp4QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLE9BQU9tdkIsMEJBQTBCO29CQUMxRCxJQUFJN3FCLGFBQWEsSUFBSSxDQUFDQyxZQUFZO29CQUNsQyxJQUFJLENBQUNBLFlBQVksQ0FBQ29iLE9BQU8sQ0FBQzt3QkFDdEJ5UCxhQUFhO3dCQUNiQyxJQUFJSjt3QkFDSkssSUFBSUo7b0JBQ1IsR0FBRyxTQUFTclAsS0FBSyxFQUFFamIsT0FBTzt3QkFDdEIsVUFBVTt3QkFDVixJQUFJb2IsUUFBUTFiLFdBQVd0QixXQUFXLENBQUM0Qjt3QkFDbkMsZUFBZTt3QkFDZixJQUFJb0YsVUFBVWdXLE1BQU1oVyxPQUFPO3dCQUMzQixJQUFJdWxCLFFBQVF2UCxNQUFNbkIsVUFBVTt3QkFDNUIsSUFBSWUsU0FBUyxDQUFDO3dCQUNkLFVBQVU7d0JBQ1YsSUFBSTRQLE1BQU14bEIsUUFBUTJWLE9BQU8sQ0FBQ0MsUUFBUUMsT0FBTzBQO3dCQUN6QyxJQUFJQyxLQUFLOzRCQUNMLElBQUlDLFdBQVc3UCxPQUFPNlAsUUFBUTs0QkFDOUIsSUFBSTFtQixRQUFRcE4sS0FBS2tMLEdBQUcsQ0FBQ2xMLEtBQUs4TSxHQUFHLENBQUMsSUFBSWduQixVQUFVNVAsTUFBTXdQLEVBQUUsR0FBRzF6QixLQUFLOE0sR0FBRyxDQUFDZ25CLFVBQVU1UCxNQUFNeVAsRUFBRTs0QkFDbEYsT0FBT0gsc0JBQXNCbmxCLFNBQVNqQixPQUFPNlcsT0FBT3BLLE1BQU0sRUFBRWlhO3dCQUNoRTt3QkFDQSxPQUFPNVAsTUFBTXVQLFdBQVc7b0JBQzVCO2dCQUNKO2dCQUVBOztDQUVDLEdBQ0Q3eUIsTUFBTWtHLFNBQVMsQ0FBQ2l0QixhQUFhLEdBQUc7b0JBQzVCLE9BQU8sSUFBSSxDQUFDbnJCLFlBQVksQ0FBQ21yQixhQUFhO2dCQUMxQztnQkFFQTs7Q0FFQyxHQUNEbnpCLE1BQU1rRyxTQUFTLENBQUNrdEIsYUFBYSxHQUFHO29CQUM1QixPQUFPLElBQUksQ0FBQ3ByQixZQUFZLENBQUNvckIsYUFBYTtnQkFDMUM7Z0JBRUE7Ozs7Q0FJQyxHQUNEcHpCLE1BQU1rRyxTQUFTLENBQUNtdEIsY0FBYyxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQ3JyQixZQUFZLENBQUNxckIsY0FBYztnQkFDM0M7Z0JBRUE7Ozs7O0NBS0MsR0FDRHJ6QixNQUFNa0csU0FBUyxDQUFDb3RCLGNBQWMsR0FBRztvQkFDN0IsT0FBTyxJQUFJLENBQUN0ckIsWUFBWSxDQUFDc3JCLGNBQWM7Z0JBQzNDO2dCQUVBOzs7OztDQUtDLEdBQ0R0ekIsTUFBTWtHLFNBQVMsQ0FBQzRmLFdBQVcsR0FBRyxTQUFTQyxTQUFTO29CQUM1Q3BrQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQ2t0QixRQUFRLElBQUk7b0JBQzFDLElBQUksSUFBSSxDQUFDQSxRQUFRLEVBQUU7d0JBQ2Y7b0JBQ0o7b0JBQ0EsSUFBSyxJQUFJMUUsSUFBSSxJQUFJLENBQUNDLFVBQVUsRUFBRUQsR0FBR0EsSUFBSUEsRUFBRWptQixNQUFNLENBQUU7d0JBQzNDaW1CLEVBQUV2bkIsSUFBSSxDQUFDRSxDQUFDLENBQUN5RixHQUFHLENBQUMwYjt3QkFDYmtHLEVBQUVqbkIsT0FBTyxDQUFDMEUsRUFBRSxDQUFDVyxHQUFHLENBQUMwYjt3QkFDakJrRyxFQUFFam5CLE9BQU8sQ0FBQ3lFLENBQUMsQ0FBQ1ksR0FBRyxDQUFDMGI7b0JBQ3BCO29CQUNBLElBQUssSUFBSTdTLElBQUksSUFBSSxDQUFDdE4sV0FBVyxFQUFFc04sR0FBR0EsSUFBSUEsRUFBRWxOLE1BQU0sQ0FBRTt3QkFDNUNrTixFQUFFNFMsV0FBVyxDQUFDQztvQkFDbEI7b0JBQ0EsSUFBSSxDQUFDL2QsWUFBWSxDQUFDOGQsV0FBVyxDQUFDQztnQkFDbEM7Z0JBRUE7Ozs7Ozs7O0NBUUMsR0FDRC9sQixNQUFNa0csU0FBUyxDQUFDcXRCLFVBQVUsR0FBRyxTQUFTL3ZCLEdBQUcsRUFBRWIsS0FBSztvQkFDNUNoQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQzJDLFFBQVEsTUFBTTtvQkFDNUMsSUFBSSxJQUFJLENBQUNBLFFBQVEsSUFBSTt3QkFDakIsT0FBTztvQkFDWDtvQkFDQSxJQUFJNUMsT0FBT3BFLEtBQUtzRSxPQUFPLENBQUNGLE1BQU07d0JBQzFCQSxNQUFNOzRCQUNGZixVQUFVZTs0QkFDVmIsT0FBT0E7d0JBQ1g7b0JBQ0o7b0JBQ0EsSUFBSTZmLE9BQU8sSUFBSTNpQixLQUFLLElBQUksRUFBRTJEO29CQUMxQixtQ0FBbUM7b0JBQ25DZ2YsS0FBS3pjLE1BQU0sR0FBRztvQkFDZHljLEtBQUt4YyxNQUFNLEdBQUcsSUFBSSxDQUFDa21CLFVBQVU7b0JBQzdCLElBQUksSUFBSSxDQUFDQSxVQUFVLEVBQUU7d0JBQ2pCLElBQUksQ0FBQ0EsVUFBVSxDQUFDbm1CLE1BQU0sR0FBR3ljO29CQUM3QjtvQkFDQSxJQUFJLENBQUMwSixVQUFVLEdBQUcxSjtvQkFDbEIsRUFBRSxJQUFJLENBQUNnTyxXQUFXO29CQUNsQixPQUFPaE87Z0JBQ1g7Z0JBRUF4aUIsTUFBTWtHLFNBQVMsQ0FBQ3N0QixpQkFBaUIsR0FBRyxTQUFTaHdCLEdBQUcsRUFBRWIsS0FBSztvQkFDbkQsSUFBSSxDQUFDYSxLQUFLO3dCQUNOQSxNQUFNLENBQUM7b0JBQ1gsT0FBTyxJQUFJcEUsS0FBS3NFLE9BQU8sQ0FBQ0YsTUFBTTt3QkFDMUJBLE1BQU07NEJBQ0ZmLFVBQVVlOzRCQUNWYixPQUFPQTt3QkFDWDtvQkFDSjtvQkFDQWEsSUFBSWhCLElBQUksR0FBRztvQkFDWCxPQUFPLElBQUksQ0FBQyt3QixVQUFVLENBQUMvdkI7Z0JBQzNCO2dCQUVBeEQsTUFBTWtHLFNBQVMsQ0FBQ3V0QixtQkFBbUIsR0FBRyxTQUFTandCLEdBQUcsRUFBRWIsS0FBSztvQkFDckQsSUFBSSxDQUFDYSxLQUFLO3dCQUNOQSxNQUFNLENBQUM7b0JBQ1gsT0FBTyxJQUFJcEUsS0FBS3NFLE9BQU8sQ0FBQ0YsTUFBTTt3QkFDMUJBLE1BQU07NEJBQ0ZmLFVBQVVlOzRCQUNWYixPQUFPQTt3QkFDWDtvQkFDSjtvQkFDQWEsSUFBSWhCLElBQUksR0FBRztvQkFDWCxPQUFPLElBQUksQ0FBQyt3QixVQUFVLENBQUMvdkI7Z0JBQzNCO2dCQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEeEQsTUFBTWtHLFNBQVMsQ0FBQ3d0QixXQUFXLEdBQUcsU0FBU3pILENBQUM7b0JBQ3BDdHFCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDK3NCLFdBQVcsR0FBRztvQkFDNUM3dUIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxJQUFJLENBQUMyQyxRQUFRLE1BQU07b0JBQzVDLElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUk7d0JBQ2pCO29CQUNKO29CQUNBLElBQUk2bEIsRUFBRWhtQixXQUFXLEVBQUU7d0JBQ2YsT0FBTztvQkFDWDtvQkFDQSw4QkFBOEI7b0JBQzlCLElBQUlzbUIsS0FBS04sRUFBRXJtQixXQUFXO29CQUN0QixNQUFPMm1CLEdBQUk7d0JBQ1AsSUFBSW9ILE1BQU1wSDt3QkFDVkEsS0FBS0EsR0FBRzNrQixJQUFJO3dCQUNaLElBQUksQ0FBQ3dHLE9BQU8sQ0FBQyxnQkFBZ0J1bEIsSUFBSXZtQixLQUFLO3dCQUN0QyxJQUFJLENBQUN3bUIsWUFBWSxDQUFDRCxJQUFJdm1CLEtBQUs7d0JBQzNCNmUsRUFBRXJtQixXQUFXLEdBQUcybUI7b0JBQ3BCO29CQUNBTixFQUFFcm1CLFdBQVcsR0FBRztvQkFDaEIsZ0NBQWdDO29CQUNoQyxJQUFJOEIsS0FBS3VrQixFQUFFcG1CLGFBQWE7b0JBQ3hCLE1BQU82QixHQUFJO3dCQUNQLElBQUlDLE1BQU1EO3dCQUNWQSxLQUFLQSxHQUFHRSxJQUFJO3dCQUNaLElBQUksQ0FBQ0MsY0FBYyxDQUFDRixJQUFJRyxPQUFPO3dCQUMvQm1rQixFQUFFcG1CLGFBQWEsR0FBRzZCO29CQUN0QjtvQkFDQXVrQixFQUFFcG1CLGFBQWEsR0FBRztvQkFDbEIsbUVBQW1FO29CQUNuRSxJQUFJOUgsSUFBSWt1QixFQUFFbm1CLGFBQWE7b0JBQ3ZCLE1BQU8vSCxFQUFHO3dCQUNOLElBQUk4MUIsS0FBSzkxQjt3QkFDVEEsSUFBSUEsRUFBRWlJLE1BQU07d0JBQ1osSUFBSSxDQUFDb0ksT0FBTyxDQUFDLGtCQUFrQnlsQjt3QkFDL0JBLEdBQUc5cUIsY0FBYyxDQUFDLElBQUksQ0FBQ2YsWUFBWTt3QkFDbkNpa0IsRUFBRW5tQixhQUFhLEdBQUcvSDtvQkFDdEI7b0JBQ0FrdUIsRUFBRW5tQixhQUFhLEdBQUc7b0JBQ2xCLDBCQUEwQjtvQkFDMUIsSUFBSW1tQixFQUFFbG1CLE1BQU0sRUFBRTt3QkFDVmttQixFQUFFbG1CLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHaW1CLEVBQUVqbUIsTUFBTTtvQkFDOUI7b0JBQ0EsSUFBSWltQixFQUFFam1CLE1BQU0sRUFBRTt3QkFDVmltQixFQUFFam1CLE1BQU0sQ0FBQ0QsTUFBTSxHQUFHa21CLEVBQUVsbUIsTUFBTTtvQkFDOUI7b0JBQ0EsSUFBSWttQixLQUFLLElBQUksQ0FBQ0MsVUFBVSxFQUFFO3dCQUN0QixJQUFJLENBQUNBLFVBQVUsR0FBR0QsRUFBRWptQixNQUFNO29CQUM5QjtvQkFDQWltQixFQUFFaG1CLFdBQVcsR0FBRztvQkFDaEIsRUFBRSxJQUFJLENBQUN1cUIsV0FBVztvQkFDbEIsSUFBSSxDQUFDcGlCLE9BQU8sQ0FBQyxlQUFlNmQ7b0JBQzVCLE9BQU87Z0JBQ1g7Z0JBRUE7Ozs7Ozs7OztDQVNDLEdBQ0Rqc0IsTUFBTWtHLFNBQVMsQ0FBQzR0QixXQUFXLEdBQUcsU0FBUzFtQixLQUFLO29CQUN4Q3pMLFdBQVdFLFFBQU80QixNQUFNLENBQUMsQ0FBQyxDQUFDMkosTUFBTTZYLE9BQU87b0JBQ3hDdGpCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsQ0FBQyxDQUFDMkosTUFBTThYLE9BQU87b0JBQ3hDdmpCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDMkMsUUFBUSxNQUFNO29CQUM1QyxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJO3dCQUNqQixPQUFPO29CQUNYO29CQUNBLDZCQUE2QjtvQkFDN0JnSCxNQUFNckgsTUFBTSxHQUFHO29CQUNmcUgsTUFBTXBILE1BQU0sR0FBRyxJQUFJLENBQUNKLFdBQVc7b0JBQy9CLElBQUksSUFBSSxDQUFDQSxXQUFXLEVBQUU7d0JBQ2xCLElBQUksQ0FBQ0EsV0FBVyxDQUFDRyxNQUFNLEdBQUdxSDtvQkFDOUI7b0JBQ0EsSUFBSSxDQUFDeEgsV0FBVyxHQUFHd0g7b0JBQ25CLEVBQUUsSUFBSSxDQUFDcWpCLFlBQVk7b0JBQ25CLDhDQUE4QztvQkFDOUNyakIsTUFBTWdZLE9BQU8sQ0FBQ2hZLEtBQUssR0FBR0E7b0JBQ3RCQSxNQUFNZ1ksT0FBTyxDQUFDalksS0FBSyxHQUFHQyxNQUFNOFgsT0FBTztvQkFDbkM5WCxNQUFNZ1ksT0FBTyxDQUFDclcsSUFBSSxHQUFHO29CQUNyQjNCLE1BQU1nWSxPQUFPLENBQUN4ZCxJQUFJLEdBQUd3RixNQUFNNlgsT0FBTyxDQUFDcmYsV0FBVztvQkFDOUMsSUFBSXdILE1BQU02WCxPQUFPLENBQUNyZixXQUFXLEVBQUV3SCxNQUFNNlgsT0FBTyxDQUFDcmYsV0FBVyxDQUFDbUosSUFBSSxHQUFHM0IsTUFBTWdZLE9BQU87b0JBQzdFaFksTUFBTTZYLE9BQU8sQ0FBQ3JmLFdBQVcsR0FBR3dILE1BQU1nWSxPQUFPO29CQUN6Q2hZLE1BQU1pWSxPQUFPLENBQUNqWSxLQUFLLEdBQUdBO29CQUN0QkEsTUFBTWlZLE9BQU8sQ0FBQ2xZLEtBQUssR0FBR0MsTUFBTTZYLE9BQU87b0JBQ25DN1gsTUFBTWlZLE9BQU8sQ0FBQ3RXLElBQUksR0FBRztvQkFDckIzQixNQUFNaVksT0FBTyxDQUFDemQsSUFBSSxHQUFHd0YsTUFBTThYLE9BQU8sQ0FBQ3RmLFdBQVc7b0JBQzlDLElBQUl3SCxNQUFNOFgsT0FBTyxDQUFDdGYsV0FBVyxFQUFFd0gsTUFBTThYLE9BQU8sQ0FBQ3RmLFdBQVcsQ0FBQ21KLElBQUksR0FBRzNCLE1BQU1pWSxPQUFPO29CQUM3RWpZLE1BQU04WCxPQUFPLENBQUN0ZixXQUFXLEdBQUd3SCxNQUFNaVksT0FBTztvQkFDekMsMEVBQTBFO29CQUMxRSxJQUFJalksTUFBTUMsa0JBQWtCLElBQUksT0FBTzt3QkFDbkMsSUFBSyxJQUFJVSxPQUFPWCxNQUFNOFgsT0FBTyxDQUFDdGUsY0FBYyxJQUFJbUgsTUFBTUEsT0FBT0EsS0FBS25HLElBQUksQ0FBRTs0QkFDcEUsSUFBSW1HLEtBQUtaLEtBQUssSUFBSUMsTUFBTTZYLE9BQU8sRUFBRTtnQ0FDN0IscUVBQXFFO2dDQUNyRSxrQkFBa0I7Z0NBQ2xCbFgsS0FBS2pHLE9BQU8sQ0FBQ3lNLGdCQUFnQjs0QkFDakM7d0JBQ0o7b0JBQ0o7b0JBQ0Esa0RBQWtEO29CQUNsRCxPQUFPbkg7Z0JBQ1g7Z0JBRUE7Ozs7O0NBS0MsR0FDRHBOLE1BQU1rRyxTQUFTLENBQUMwdEIsWUFBWSxHQUFHLFNBQVN4bUIsS0FBSztvQkFDekN6TCxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQzJDLFFBQVEsTUFBTTtvQkFDNUMsSUFBSSxJQUFJLENBQUNBLFFBQVEsSUFBSTt3QkFDakI7b0JBQ0o7b0JBQ0Esc0NBQXNDO29CQUN0QyxJQUFJZ0gsTUFBTXJILE1BQU0sRUFBRTt3QkFDZHFILE1BQU1ySCxNQUFNLENBQUNDLE1BQU0sR0FBR29ILE1BQU1wSCxNQUFNO29CQUN0QztvQkFDQSxJQUFJb0gsTUFBTXBILE1BQU0sRUFBRTt3QkFDZG9ILE1BQU1wSCxNQUFNLENBQUNELE1BQU0sR0FBR3FILE1BQU1ySCxNQUFNO29CQUN0QztvQkFDQSxJQUFJcUgsU0FBUyxJQUFJLENBQUN4SCxXQUFXLEVBQUU7d0JBQzNCLElBQUksQ0FBQ0EsV0FBVyxHQUFHd0gsTUFBTXBILE1BQU07b0JBQ25DO29CQUNBLDBCQUEwQjtvQkFDMUIsSUFBSTBNLFFBQVF0RixNQUFNNlgsT0FBTztvQkFDekIsSUFBSXJTLFFBQVF4RixNQUFNOFgsT0FBTztvQkFDekIsNEJBQTRCO29CQUM1QnhTLE1BQU1qTCxRQUFRLENBQUM7b0JBQ2ZtTCxNQUFNbkwsUUFBUSxDQUFDO29CQUNmLHNCQUFzQjtvQkFDdEIsSUFBSTJGLE1BQU1nWSxPQUFPLENBQUNyVyxJQUFJLEVBQUU7d0JBQ3BCM0IsTUFBTWdZLE9BQU8sQ0FBQ3JXLElBQUksQ0FBQ25ILElBQUksR0FBR3dGLE1BQU1nWSxPQUFPLENBQUN4ZCxJQUFJO29CQUNoRDtvQkFDQSxJQUFJd0YsTUFBTWdZLE9BQU8sQ0FBQ3hkLElBQUksRUFBRTt3QkFDcEJ3RixNQUFNZ1ksT0FBTyxDQUFDeGQsSUFBSSxDQUFDbUgsSUFBSSxHQUFHM0IsTUFBTWdZLE9BQU8sQ0FBQ3JXLElBQUk7b0JBQ2hEO29CQUNBLElBQUkzQixNQUFNZ1ksT0FBTyxJQUFJMVMsTUFBTTlNLFdBQVcsRUFBRTt3QkFDcEM4TSxNQUFNOU0sV0FBVyxHQUFHd0gsTUFBTWdZLE9BQU8sQ0FBQ3hkLElBQUk7b0JBQzFDO29CQUNBd0YsTUFBTWdZLE9BQU8sQ0FBQ3JXLElBQUksR0FBRztvQkFDckIzQixNQUFNZ1ksT0FBTyxDQUFDeGQsSUFBSSxHQUFHO29CQUNyQixxQkFBcUI7b0JBQ3JCLElBQUl3RixNQUFNaVksT0FBTyxDQUFDdFcsSUFBSSxFQUFFO3dCQUNwQjNCLE1BQU1pWSxPQUFPLENBQUN0VyxJQUFJLENBQUNuSCxJQUFJLEdBQUd3RixNQUFNaVksT0FBTyxDQUFDemQsSUFBSTtvQkFDaEQ7b0JBQ0EsSUFBSXdGLE1BQU1pWSxPQUFPLENBQUN6ZCxJQUFJLEVBQUU7d0JBQ3BCd0YsTUFBTWlZLE9BQU8sQ0FBQ3pkLElBQUksQ0FBQ21ILElBQUksR0FBRzNCLE1BQU1pWSxPQUFPLENBQUN0VyxJQUFJO29CQUNoRDtvQkFDQSxJQUFJM0IsTUFBTWlZLE9BQU8sSUFBSXpTLE1BQU1oTixXQUFXLEVBQUU7d0JBQ3BDZ04sTUFBTWhOLFdBQVcsR0FBR3dILE1BQU1pWSxPQUFPLENBQUN6ZCxJQUFJO29CQUMxQztvQkFDQXdGLE1BQU1pWSxPQUFPLENBQUN0VyxJQUFJLEdBQUc7b0JBQ3JCM0IsTUFBTWlZLE9BQU8sQ0FBQ3pkLElBQUksR0FBRztvQkFDckJqRyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQ2d0QixZQUFZLEdBQUc7b0JBQzdDLEVBQUUsSUFBSSxDQUFDQSxZQUFZO29CQUNuQiwwRUFBMEU7b0JBQzFFLElBQUlyakIsTUFBTUMsa0JBQWtCLElBQUksT0FBTzt3QkFDbkMsSUFBSVUsT0FBTzZFLE1BQU1oTSxjQUFjO3dCQUMvQixNQUFPbUgsS0FBTTs0QkFDVCxJQUFJQSxLQUFLWixLQUFLLElBQUl1RixPQUFPO2dDQUNyQixxRUFBcUU7Z0NBQ3JFLGtCQUFrQjtnQ0FDbEIzRSxLQUFLakcsT0FBTyxDQUFDeU0sZ0JBQWdCOzRCQUNqQzs0QkFDQXhHLE9BQU9BLEtBQUtuRyxJQUFJO3dCQUNwQjtvQkFDSjtvQkFDQSxJQUFJLENBQUN3RyxPQUFPLENBQUMsZ0JBQWdCaEI7Z0JBQ2pDO2dCQUVBLElBQUkybUIsU0FBUyxJQUFJekosT0FBT0MsUUFBUTtnQkFFaEMsUUFBUTtnQkFDUjs7Ozs7Ozs7O0NBU0MsR0FDRHZxQixNQUFNa0csU0FBUyxDQUFDb00sSUFBSSxHQUFHLFNBQVMwaEIsUUFBUSxFQUFFN0ksa0JBQWtCLEVBQUVDLGtCQUFrQjtvQkFDNUUsSUFBSSxBQUFDRCxDQUFBQSxxQkFBcUIsQ0FBQSxNQUFPQSxvQkFBb0I7d0JBQ2pELDhCQUE4Qjt3QkFDOUJBLHFCQUFxQjtvQkFDekI7b0JBQ0FBLHFCQUFxQkEsc0JBQXNCLElBQUksQ0FBQzRGLG9CQUFvQjtvQkFDcEUzRixxQkFBcUJBLHNCQUFzQixJQUFJLENBQUM0RixvQkFBb0I7b0JBQ3BFLDZCQUE2QjtvQkFDN0IsSUFBSSxDQUFDRSxXQUFXO29CQUNoQixnRUFBZ0U7b0JBQ2hFLElBQUksSUFBSSxDQUFDeGpCLFlBQVksRUFBRTt3QkFDbkIsSUFBSSxDQUFDMmhCLGVBQWU7d0JBQ3BCLElBQUksQ0FBQzNoQixZQUFZLEdBQUc7b0JBQ3hCO29CQUNBLElBQUksQ0FBQ2lqQixRQUFRLEdBQUc7b0JBQ2hCb0QsT0FBT3pJLEtBQUssQ0FBQzBJO29CQUNiRCxPQUFPNUksa0JBQWtCLEdBQUdBO29CQUM1QjRJLE9BQU8zSSxrQkFBa0IsR0FBR0E7b0JBQzVCMkksT0FBT3pnQixZQUFZLEdBQUcsSUFBSSxDQUFDc2QsY0FBYztvQkFDekNtRCxPQUFPelgsVUFBVSxHQUFHLElBQUksQ0FBQ3dVLFlBQVk7b0JBQ3JDLDhEQUE4RDtvQkFDOUQsSUFBSSxDQUFDbUQsY0FBYztvQkFDbkIsNkVBQTZFO29CQUM3RSxJQUFJLElBQUksQ0FBQ25HLGNBQWMsSUFBSWtHLFdBQVcsR0FBRzt3QkFDckMsSUFBSSxDQUFDMUQsUUFBUSxDQUFDdEUsVUFBVSxDQUFDK0g7d0JBQ3pCLHVEQUF1RDt3QkFDdkQsSUFBSyxJQUFJOUgsSUFBSSxJQUFJLENBQUNDLFVBQVUsRUFBRUQsR0FBR0EsSUFBSUEsRUFBRTNsQixPQUFPLEdBQUk7NEJBQzlDLHVEQUF1RDs0QkFDdkQsSUFBSTJsQixFQUFFL25CLFlBQVksSUFBSSxPQUFPO2dDQUN6Qjs0QkFDSjs0QkFDQSxJQUFJK25CLEVBQUVwbEIsUUFBUSxJQUFJO2dDQUNkOzRCQUNKOzRCQUNBLHFDQUFxQzs0QkFDckNvbEIsRUFBRXprQixtQkFBbUI7d0JBQ3pCO3dCQUNBLHlCQUF5Qjt3QkFDekIsSUFBSSxDQUFDNm5CLGVBQWU7b0JBQ3hCO29CQUNBLHFCQUFxQjtvQkFDckIsSUFBSSxJQUFJLENBQUN3QixtQkFBbUIsSUFBSW1ELFdBQVcsR0FBRzt3QkFDMUMsSUFBSSxDQUFDMUQsUUFBUSxDQUFDekMsYUFBYSxDQUFDa0c7b0JBQ2hDO29CQUNBLElBQUksSUFBSSxDQUFDckQsYUFBYSxFQUFFO3dCQUNwQixJQUFJLENBQUM0QixXQUFXO29CQUNwQjtvQkFDQSxJQUFJLENBQUMzQixRQUFRLEdBQUc7Z0JBQ3BCO2dCQUVBOztDQUVDLEdBQ0Qzd0IsTUFBTWtHLFNBQVMsQ0FBQ21wQixlQUFlLEdBQUc7b0JBQzlCLElBQUksQ0FBQ3JuQixZQUFZLENBQUNrc0IsV0FBVyxDQUFDLElBQUksQ0FBQy9DLE9BQU87Z0JBQzlDO2dCQUVBOzs7OztDQUtDLEdBQ0RueEIsTUFBTWtHLFNBQVMsQ0FBQ2tyQixhQUFhLEdBQUcsU0FBUzFDLE1BQU0sRUFBRUMsTUFBTTtvQkFDbkQsSUFBSTNnQixXQUFXMGdCLE9BQU9qaEIsT0FBTztvQkFDN0IsSUFBSVMsV0FBV3lnQixPQUFPbGhCLE9BQU87b0JBQzdCLElBQUl3QyxTQUFTeWUsT0FBT3BNLFVBQVU7b0JBQzlCLElBQUluUyxTQUFTd2UsT0FBT3JNLFVBQVU7b0JBQzlCLElBQUk1UCxRQUFRMUUsU0FBUzJFLE9BQU87b0JBQzVCLElBQUlDLFFBQVExRSxTQUFTeUUsT0FBTztvQkFDNUIscUNBQXFDO29CQUNyQyxJQUFJRCxVQUFVRSxPQUFPO3dCQUNqQjtvQkFDSjtvQkFDQSx3RUFBd0U7b0JBQ3hFLGlDQUFpQztvQkFDakMsZ0NBQWdDO29CQUNoQyxJQUFJN0UsT0FBTzZFLE1BQU1oTSxjQUFjO29CQUMvQixjQUFjO29CQUNkLE1BQU9tSCxLQUFNO3dCQUNULElBQUlBLEtBQUtaLEtBQUssS0FBS3VGLE9BQU87NEJBQ3RCLElBQUkxQyxLQUFLakMsS0FBS2pHLE9BQU8sQ0FBQ21HLFdBQVc7NEJBQ2pDLElBQUlpQyxLQUFLbkMsS0FBS2pHLE9BQU8sQ0FBQ3FHLFdBQVc7NEJBQ2pDLElBQUltSyxLQUFLdkssS0FBS2pHLE9BQU8sQ0FBQ3VNLGNBQWM7NEJBQ3BDLElBQUltRSxLQUFLekssS0FBS2pHLE9BQU8sQ0FBQ3dNLGNBQWM7NEJBQ3BDLElBQUl0RSxPQUFPaEMsWUFBWWtDLE9BQU9oQyxZQUFZb0ssT0FBT3JJLFVBQVV1SSxPQUFPckksUUFBUTtnQ0FDdEUsNEJBQTRCO2dDQUM1Qjs0QkFDSjs0QkFDQSxJQUFJSCxPQUFPOUIsWUFBWWdDLE9BQU9sQyxZQUFZc0ssT0FBT25JLFVBQVVxSSxPQUFPdkksUUFBUTtnQ0FDdEUsNEJBQTRCO2dDQUM1Qjs0QkFDSjt3QkFDSjt3QkFDQWxDLE9BQU9BLEtBQUtuRyxJQUFJO29CQUNwQjtvQkFDQSxJQUFJZ0wsTUFBTTVGLGFBQWEsQ0FBQzBGLFdBQVcsT0FBTzt3QkFDdEM7b0JBQ0o7b0JBQ0EsSUFBSXhFLFNBQVNsQixhQUFhLENBQUNnQixjQUFjLE9BQU87d0JBQzVDO29CQUNKO29CQUNBLG9CQUFvQjtvQkFDcEIsSUFBSWxHLFVBQVVoSSxRQUFRdWhCLE1BQU0sQ0FBQ3JULFVBQVVpQyxRQUFRL0IsVUFBVWlDO29CQUN6RCxJQUFJckksV0FBVyxNQUFNO3dCQUNqQjtvQkFDSjtvQkFDQSx5QkFBeUI7b0JBQ3pCQSxRQUFRL0IsTUFBTSxHQUFHO29CQUNqQixJQUFJLElBQUksQ0FBQ0YsYUFBYSxJQUFJLE1BQU07d0JBQzVCaUMsUUFBUTlCLE1BQU0sR0FBRyxJQUFJLENBQUNILGFBQWE7d0JBQ25DLElBQUksQ0FBQ0EsYUFBYSxDQUFDRSxNQUFNLEdBQUcrQjtvQkFDaEM7b0JBQ0EsSUFBSSxDQUFDakMsYUFBYSxHQUFHaUM7b0JBQ3JCLEVBQUUsSUFBSSxDQUFDeW9CLGNBQWM7Z0JBQ3pCO2dCQUVBOztDQUVDLEdBQ0R2d0IsTUFBTWtHLFNBQVMsQ0FBQyt0QixjQUFjLEdBQUc7b0JBQzdCLHlCQUF5QjtvQkFDekIsSUFBSXhxQixHQUFHMHFCLFNBQVMsSUFBSSxDQUFDdHVCLGFBQWE7b0JBQ2xDLE1BQU80RCxJQUFJMHFCLE9BQVE7d0JBQ2ZBLFNBQVMxcUIsRUFBRW5ELE9BQU87d0JBQ2xCLElBQUkwSCxXQUFXdkUsRUFBRXdFLFdBQVc7d0JBQzVCLElBQUlDLFdBQVd6RSxFQUFFMEUsV0FBVzt3QkFDNUIsSUFBSThCLFNBQVN4RyxFQUFFNEssY0FBYzt3QkFDN0IsSUFBSWxFLFNBQVMxRyxFQUFFNkssY0FBYzt3QkFDN0IsSUFBSTVCLFFBQVExRSxTQUFTMkUsT0FBTzt3QkFDNUIsSUFBSUMsUUFBUTFFLFNBQVN5RSxPQUFPO3dCQUM1Qix5Q0FBeUM7d0JBQ3pDLElBQUlsSixFQUFFMEgsWUFBWSxFQUFFOzRCQUNoQixJQUFJeUIsTUFBTTVGLGFBQWEsQ0FBQzBGLFVBQVUsT0FBTztnQ0FDckMsSUFBSSxDQUFDN0ssY0FBYyxDQUFDNEI7Z0NBQ3BCOzRCQUNKOzRCQUNBLElBQUl5RSxTQUFTbEIsYUFBYSxDQUFDZ0IsYUFBYSxPQUFPO2dDQUMzQyxJQUFJLENBQUNuRyxjQUFjLENBQUM0QjtnQ0FDcEI7NEJBQ0o7NEJBQ0EsNEJBQTRCOzRCQUM1QkEsRUFBRTBILFlBQVksR0FBRzt3QkFDckI7d0JBQ0EsSUFBSWlkLFVBQVUxYixNQUFNL0osT0FBTyxNQUFNLENBQUMrSixNQUFNN0wsUUFBUTt3QkFDaEQsSUFBSXduQixVQUFVemIsTUFBTWpLLE9BQU8sTUFBTSxDQUFDaUssTUFBTS9MLFFBQVE7d0JBQ2hELHVFQUF1RTt3QkFDdkUsSUFBSXVuQixXQUFXLFNBQVNDLFdBQVcsT0FBTzs0QkFDdEM7d0JBQ0o7d0JBQ0EsSUFBSStGLFdBQVdwbUIsU0FBUzVGLFNBQVMsQ0FBQzZILE9BQU8sQ0FBQzVILE9BQU87d0JBQ2pELElBQUlnc0IsV0FBV25tQixTQUFTOUYsU0FBUyxDQUFDK0gsT0FBTyxDQUFDOUgsT0FBTzt3QkFDakQsSUFBSWlzQixVQUFVLElBQUksQ0FBQ3RzQixZQUFZLENBQUMrTixXQUFXLENBQUNxZSxVQUFVQzt3QkFDdEQscUVBQXFFO3dCQUNyRSxJQUFJQyxXQUFXLE9BQU87NEJBQ2xCLElBQUksQ0FBQ3pzQixjQUFjLENBQUM0Qjs0QkFDcEI7d0JBQ0o7d0JBQ0Esd0JBQXdCO3dCQUN4QkEsRUFBRThMLE1BQU0sQ0FBQyxJQUFJO29CQUNqQjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEdlYsTUFBTWtHLFNBQVMsQ0FBQzJCLGNBQWMsR0FBRyxTQUFTQyxPQUFPO29CQUM3Q2hJLFFBQVEraEIsT0FBTyxDQUFDL1osU0FBUyxJQUFJO29CQUM3Qix5QkFBeUI7b0JBQ3pCLElBQUlBLFFBQVEvQixNQUFNLEVBQUU7d0JBQ2hCK0IsUUFBUS9CLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHOEIsUUFBUTlCLE1BQU07b0JBQzFDO29CQUNBLElBQUk4QixRQUFROUIsTUFBTSxFQUFFO3dCQUNoQjhCLFFBQVE5QixNQUFNLENBQUNELE1BQU0sR0FBRytCLFFBQVEvQixNQUFNO29CQUMxQztvQkFDQSxJQUFJK0IsV0FBVyxJQUFJLENBQUNqQyxhQUFhLEVBQUU7d0JBQy9CLElBQUksQ0FBQ0EsYUFBYSxHQUFHaUMsUUFBUTlCLE1BQU07b0JBQ3ZDO29CQUNBLEVBQUUsSUFBSSxDQUFDdXFCLGNBQWM7Z0JBQ3pCO2dCQUVBdndCLE1BQU1rRyxTQUFTLENBQUNxdUIsVUFBVSxHQUFHO2dCQUU3Qjs7Ozs7Q0FLQyxHQUNEdjBCLE1BQU1rRyxTQUFTLENBQUNzdUIsRUFBRSxHQUFHLFNBQVNDLElBQUksRUFBRWpmLFFBQVE7b0JBQ3hDLElBQUksT0FBT2lmLFNBQVMsWUFBWSxPQUFPamYsYUFBYSxZQUFZO3dCQUM1RCxPQUFPLElBQUk7b0JBQ2Y7b0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQytlLFVBQVUsRUFBRTt3QkFDbEIsSUFBSSxDQUFDQSxVQUFVLEdBQUcsQ0FBQztvQkFDdkI7b0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0EsVUFBVSxDQUFDRSxLQUFLLEVBQUU7d0JBQ3hCLElBQUksQ0FBQ0YsVUFBVSxDQUFDRSxLQUFLLEdBQUcsRUFBRTtvQkFDOUI7b0JBQ0EsSUFBSSxDQUFDRixVQUFVLENBQUNFLEtBQUssQ0FBQzVJLElBQUksQ0FBQ3JXO29CQUMzQixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUE7Ozs7O0NBS0MsR0FDRHhWLE1BQU1rRyxTQUFTLENBQUN3dUIsR0FBRyxHQUFHLFNBQVNELElBQUksRUFBRWpmLFFBQVE7b0JBQ3pDLElBQUksT0FBT2lmLFNBQVMsWUFBWSxPQUFPamYsYUFBYSxZQUFZO3dCQUM1RCxPQUFPLElBQUk7b0JBQ2Y7b0JBQ0EsSUFBSW1mLFlBQVksSUFBSSxDQUFDSixVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUNFLEtBQUs7b0JBQ3hELElBQUksQ0FBQ0UsYUFBYSxDQUFDQSxVQUFVMTFCLE1BQU0sRUFBRTt3QkFDakMsT0FBTyxJQUFJO29CQUNmO29CQUNBLElBQUkrekIsUUFBUTJCLFVBQVVDLE9BQU8sQ0FBQ3BmO29CQUM5QixJQUFJd2QsU0FBUyxHQUFHO3dCQUNaMkIsVUFBVUUsTUFBTSxDQUFDN0IsT0FBTztvQkFDNUI7b0JBQ0EsT0FBTyxJQUFJO2dCQUNmO2dCQUVBaHpCLE1BQU1rRyxTQUFTLENBQUNrSSxPQUFPLEdBQUcsU0FBU3FtQixJQUFJLEVBQUVLLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJO29CQUNyRCxJQUFJTCxZQUFZLElBQUksQ0FBQ0osVUFBVSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxDQUFDRSxLQUFLO29CQUN4RCxJQUFJLENBQUNFLGFBQWEsQ0FBQ0EsVUFBVTExQixNQUFNLEVBQUU7d0JBQ2pDLE9BQU87b0JBQ1g7b0JBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUk0MUIsVUFBVTExQixNQUFNLEVBQUVGLElBQUs7d0JBQ3ZDNDFCLFNBQVMsQ0FBQzUxQixFQUFFLENBQUNDLElBQUksQ0FBQyxJQUFJLEVBQUU4MUIsTUFBTUMsTUFBTUM7b0JBQ3hDO29CQUNBLE9BQU9MLFVBQVUxMUIsTUFBTTtnQkFDM0I7Z0JBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRDs7O0NBR0MsR0FDRGUsTUFBTWtHLFNBQVMsQ0FBQ21RLFlBQVksR0FBRyxTQUFTdk8sT0FBTztvQkFDM0MsSUFBSSxDQUFDc0csT0FBTyxDQUFDLGlCQUFpQnRHO2dCQUNsQztnQkFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEOzs7Q0FHQyxHQUNEOUgsTUFBTWtHLFNBQVMsQ0FBQ29RLFVBQVUsR0FBRyxTQUFTeE8sT0FBTztvQkFDekMsSUFBSSxDQUFDc0csT0FBTyxDQUFDLGVBQWV0RztnQkFDaEM7Z0JBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRDs7OztDQUlDLEdBQ0Q5SCxNQUFNa0csU0FBUyxDQUFDcVEsUUFBUSxHQUFHLFNBQVN6TyxPQUFPLEVBQUVrTyxXQUFXO29CQUNwRCxJQUFJLENBQUM1SCxPQUFPLENBQUMsYUFBYXRHLFNBQVNrTztnQkFDdkM7Z0JBRUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNEOzs7O0NBSUMsR0FDRGhXLE1BQU1rRyxTQUFTLENBQUMrcEIsU0FBUyxHQUFHLFNBQVNub0IsT0FBTyxFQUFFZ0YsT0FBTztvQkFDakQsSUFBSSxDQUFDc0IsT0FBTyxDQUFDLGNBQWN0RyxTQUFTZ0Y7Z0JBQ3hDO1lBR0E7WUFBRTtnQkFBQyxVQUFTO2dCQUFFLGFBQVk7Z0JBQUUsWUFBVztnQkFBRSwwQkFBeUI7Z0JBQUcsaUJBQWdCO2dCQUFHLGlCQUFnQjtnQkFBRyxrQkFBaUI7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNuTyxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDcEssSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdEQsSUFBSUosV0FBVzdDLFNBQVE7Z0JBRXZCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CZixRQUFPRCxPQUFPLEdBQUcrQjtnQkFFakIsU0FBU0EsS0FBS3UxQixLQUFLLEVBQUVDLEtBQUs7b0JBQ3RCLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWXgxQixJQUFHLEdBQUk7d0JBQ3pCLE9BQU8sSUFBSUEsS0FBS3UxQixPQUFPQztvQkFDM0I7b0JBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcvMUIsS0FBS3NELElBQUk7b0JBQzNCLElBQUksQ0FBQzB5QixVQUFVLEdBQUdoMkIsS0FBS3NELElBQUk7b0JBQzNCLElBQUksT0FBT3V5QixVQUFVLFVBQVU7d0JBQzNCLElBQUksQ0FBQ0UsVUFBVSxDQUFDaHNCLEdBQUcsQ0FBQzhyQjtvQkFDeEI7b0JBQ0EsSUFBSSxPQUFPQyxVQUFVLFVBQVU7d0JBQzNCLElBQUksQ0FBQ0UsVUFBVSxDQUFDanNCLEdBQUcsQ0FBQytyQjtvQkFDeEI7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRHgxQixLQUFLd0csU0FBUyxDQUFDeEMsT0FBTyxHQUFHO29CQUNyQixPQUFPaEUsS0FBS2dFLE9BQU8sQ0FBQyxJQUFJO2dCQUM1QjtnQkFFQWhFLEtBQUtnRSxPQUFPLEdBQUcsU0FBUzZlLElBQUk7b0JBQ3hCLElBQUk4UyxJQUFJajJCLEtBQUtpTCxHQUFHLENBQUNrWSxLQUFLNlMsVUFBVSxFQUFFN1MsS0FBSzRTLFVBQVU7b0JBQ2pELElBQUlHLFFBQVFELEVBQUUxVyxDQUFDLElBQUksS0FBSzBXLEVBQUV4VyxDQUFDLElBQUksS0FBS3pmLEtBQUtzRSxPQUFPLENBQUM2ZSxLQUFLNFMsVUFBVSxLQUFLLzFCLEtBQUtzRSxPQUFPLENBQUM2ZSxLQUFLNlMsVUFBVTtvQkFDakcsT0FBT0U7Z0JBQ1g7Z0JBRUE1MUIsS0FBSytELE1BQU0sR0FBRyxTQUFTakYsQ0FBQztvQkFDcEIsSUFBSSxDQUFDbUQsU0FBUztvQkFDZCxJQUFJLENBQUNqQyxLQUFLZ0UsT0FBTyxDQUFDbEYsSUFBSTt3QkFDbEJpRCxVQUFVSSxPQUFPOHJCLEtBQUssQ0FBQ252Qjt3QkFDdkIsTUFBTSxJQUFJSyxNQUFNO29CQUNwQjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEYSxLQUFLd0csU0FBUyxDQUFDcXZCLFNBQVMsR0FBRztvQkFDdkIsT0FBT24yQixLQUFLa29CLEdBQUcsQ0FBQyxBQUFDLENBQUEsSUFBSSxDQUFDNk4sVUFBVSxDQUFDeFcsQ0FBQyxHQUFHLElBQUksQ0FBQ3lXLFVBQVUsQ0FBQ3pXLENBQUMsQUFBREEsSUFBSyxJQUFJLEFBQUMsQ0FBQSxJQUFJLENBQUN3VyxVQUFVLENBQUN0VyxDQUFDLEdBQUcsSUFBSSxDQUFDdVcsVUFBVSxDQUFDdlcsQ0FBQyxBQUFEQSxJQUFLO2dCQUM1RztnQkFFQTs7Q0FFQyxHQUNEbmYsS0FBS3dHLFNBQVMsQ0FBQ3N2QixVQUFVLEdBQUc7b0JBQ3hCLE9BQU9wMkIsS0FBS2tvQixHQUFHLENBQUMsQUFBQyxDQUFBLElBQUksQ0FBQzhOLFVBQVUsQ0FBQ3pXLENBQUMsR0FBRyxJQUFJLENBQUN3VyxVQUFVLENBQUN4VyxDQUFDLEFBQURBLElBQUssSUFBSSxBQUFDLENBQUEsSUFBSSxDQUFDeVcsVUFBVSxDQUFDdlcsQ0FBQyxHQUFHLElBQUksQ0FBQ3NXLFVBQVUsQ0FBQ3RXLENBQUMsQUFBREEsSUFBSztnQkFDNUc7Z0JBRUE7O0NBRUMsR0FDRG5mLEtBQUt3RyxTQUFTLENBQUN1dkIsWUFBWSxHQUFHO29CQUMxQixPQUFPLElBQUssQ0FBQSxJQUFJLENBQUNMLFVBQVUsQ0FBQ3pXLENBQUMsR0FBRyxJQUFJLENBQUN3VyxVQUFVLENBQUN4VyxDQUFDLEdBQUcsSUFBSSxDQUFDeVcsVUFBVSxDQUFDdlcsQ0FBQyxHQUFHLElBQUksQ0FBQ3NXLFVBQVUsQ0FBQ3RXLENBQUMsQUFBREE7Z0JBQzVGO2dCQUVBOztDQUVDLEdBQ0RuZixLQUFLd0csU0FBUyxDQUFDK2QsT0FBTyxHQUFHLFNBQVN2bEIsQ0FBQyxFQUFFdXRCLENBQUM7b0JBQ2xDLElBQUl5SixTQUFTaDNCLEVBQUV5MkIsVUFBVTtvQkFDekIsSUFBSVEsU0FBU2ozQixFQUFFMDJCLFVBQVU7b0JBQ3pCLElBQUlRLFNBQVMzSixFQUFFa0osVUFBVTtvQkFDekIsSUFBSVUsU0FBUzVKLEVBQUVtSixVQUFVO29CQUN6QixJQUFJVSxTQUFTMzJCLE1BQUt5YSxHQUFHLENBQUM4YixPQUFPL1csQ0FBQyxFQUFFaVgsT0FBT2pYLENBQUM7b0JBQ3hDLElBQUlvWCxTQUFTNTJCLE1BQUt5YSxHQUFHLENBQUM4YixPQUFPN1csQ0FBQyxFQUFFK1csT0FBTy9XLENBQUM7b0JBQ3hDLElBQUltWCxTQUFTNzJCLE1BQUtzZ0IsR0FBRyxDQUFDb1csT0FBT2xYLENBQUMsRUFBRWdYLE9BQU9oWCxDQUFDO29CQUN4QyxJQUFJc1gsU0FBUzkyQixNQUFLc2dCLEdBQUcsQ0FBQ29XLE9BQU9oWCxDQUFDLEVBQUU4VyxPQUFPOVcsQ0FBQztvQkFDeEMsSUFBSSxDQUFDc1csVUFBVSxDQUFDaHNCLEdBQUcsQ0FBQzJzQixRQUFRQztvQkFDNUIsSUFBSSxDQUFDWCxVQUFVLENBQUNqc0IsR0FBRyxDQUFDNnNCLFFBQVFDO2dCQUNoQztnQkFFQXYyQixLQUFLd0csU0FBUyxDQUFDZ3dCLGFBQWEsR0FBRyxTQUFTeDNCLENBQUMsRUFBRXV0QixDQUFDO29CQUN4QyxJQUFJLENBQUNrSixVQUFVLENBQUNoc0IsR0FBRyxDQUFDaEssTUFBS3lhLEdBQUcsQ0FBQ2xiLEVBQUVpZ0IsQ0FBQyxFQUFFc04sRUFBRXROLENBQUMsR0FBR3hmLE1BQUt5YSxHQUFHLENBQUNsYixFQUFFbWdCLENBQUMsRUFBRW9OLEVBQUVwTixDQUFDO29CQUN6RCxJQUFJLENBQUN1VyxVQUFVLENBQUNqc0IsR0FBRyxDQUFDaEssTUFBS3NnQixHQUFHLENBQUMvZ0IsRUFBRWlnQixDQUFDLEVBQUVzTixFQUFFdE4sQ0FBQyxHQUFHeGYsTUFBS3NnQixHQUFHLENBQUMvZ0IsRUFBRW1nQixDQUFDLEVBQUVvTixFQUFFcE4sQ0FBQztnQkFDN0Q7Z0JBRUFuZixLQUFLd0csU0FBUyxDQUFDaUQsR0FBRyxHQUFHLFNBQVNvWixJQUFJO29CQUM5QixJQUFJLENBQUM0UyxVQUFVLENBQUNoc0IsR0FBRyxDQUFDb1osS0FBSzRTLFVBQVUsQ0FBQ3hXLENBQUMsRUFBRTRELEtBQUs0UyxVQUFVLENBQUN0VyxDQUFDO29CQUN4RCxJQUFJLENBQUN1VyxVQUFVLENBQUNqc0IsR0FBRyxDQUFDb1osS0FBSzZTLFVBQVUsQ0FBQ3pXLENBQUMsRUFBRTRELEtBQUs2UyxVQUFVLENBQUN2VyxDQUFDO2dCQUM1RDtnQkFFQW5mLEtBQUt3RyxTQUFTLENBQUNpd0IsUUFBUSxHQUFHLFNBQVM1VCxJQUFJO29CQUNuQyxJQUFJNlQsU0FBUztvQkFDYkEsU0FBU0EsVUFBVSxJQUFJLENBQUNqQixVQUFVLENBQUN4VyxDQUFDLElBQUk0RCxLQUFLNFMsVUFBVSxDQUFDeFcsQ0FBQztvQkFDekR5WCxTQUFTQSxVQUFVLElBQUksQ0FBQ2pCLFVBQVUsQ0FBQ3RXLENBQUMsSUFBSTBELEtBQUs0UyxVQUFVLENBQUN0VyxDQUFDO29CQUN6RHVYLFNBQVNBLFVBQVU3VCxLQUFLNlMsVUFBVSxDQUFDelcsQ0FBQyxJQUFJLElBQUksQ0FBQ3lXLFVBQVUsQ0FBQ3pXLENBQUM7b0JBQ3pEeVgsU0FBU0EsVUFBVTdULEtBQUs2UyxVQUFVLENBQUN2VyxDQUFDLElBQUksSUFBSSxDQUFDdVcsVUFBVSxDQUFDdlcsQ0FBQztvQkFDekQsT0FBT3VYO2dCQUNYO2dCQUVBMTJCLEtBQUt3RyxTQUFTLENBQUNtd0IsTUFBTSxHQUFHLFNBQVNDLEtBQUs7b0JBQ2xDNTJCLEtBQUsyMkIsTUFBTSxDQUFDLElBQUksRUFBRUM7Z0JBQ3RCO2dCQUVBNTJCLEtBQUsyMkIsTUFBTSxHQUFHLFNBQVM5VCxJQUFJLEVBQUUrVCxLQUFLO29CQUM5Qi9ULEtBQUs0UyxVQUFVLENBQUN4VyxDQUFDLElBQUkyWDtvQkFDckIvVCxLQUFLNFMsVUFBVSxDQUFDdFcsQ0FBQyxJQUFJeVg7b0JBQ3JCL1QsS0FBSzZTLFVBQVUsQ0FBQ3pXLENBQUMsSUFBSTJYO29CQUNyQi9ULEtBQUs2UyxVQUFVLENBQUN2VyxDQUFDLElBQUl5WDtnQkFDekI7Z0JBRUE1MkIsS0FBS3FXLFdBQVcsR0FBRyxTQUFTclgsQ0FBQyxFQUFFdXRCLENBQUM7b0JBQzVCLElBQUlzSyxNQUFNdEssRUFBRWtKLFVBQVUsQ0FBQ3hXLENBQUMsR0FBR2pnQixFQUFFMDJCLFVBQVUsQ0FBQ3pXLENBQUM7b0JBQ3pDLElBQUk2WCxNQUFNOTNCLEVBQUV5MkIsVUFBVSxDQUFDeFcsQ0FBQyxHQUFHc04sRUFBRW1KLFVBQVUsQ0FBQ3pXLENBQUM7b0JBQ3pDLElBQUk4WCxNQUFNeEssRUFBRWtKLFVBQVUsQ0FBQ3RXLENBQUMsR0FBR25nQixFQUFFMDJCLFVBQVUsQ0FBQ3ZXLENBQUM7b0JBQ3pDLElBQUk2WCxNQUFNaDRCLEVBQUV5MkIsVUFBVSxDQUFDdFcsQ0FBQyxHQUFHb04sRUFBRW1KLFVBQVUsQ0FBQ3ZXLENBQUM7b0JBQ3pDLElBQUkwWCxNQUFNLEtBQUtFLE1BQU0sS0FBS0QsTUFBTSxLQUFLRSxNQUFNLEdBQUc7d0JBQzFDLE9BQU87b0JBQ1g7b0JBQ0EsT0FBTztnQkFDWDtnQkFFQWgzQixLQUFLaTNCLFFBQVEsR0FBRyxTQUFTajRCLENBQUMsRUFBRXV0QixDQUFDO29CQUN6QixPQUFPN3NCLEtBQUt1M0IsUUFBUSxDQUFDajRCLEVBQUV5MkIsVUFBVSxFQUFFbEosRUFBRWtKLFVBQVUsS0FBSy8xQixLQUFLdTNCLFFBQVEsQ0FBQ2o0QixFQUFFMDJCLFVBQVUsRUFBRW5KLEVBQUVtSixVQUFVO2dCQUNoRztnQkFFQTExQixLQUFLazNCLElBQUksR0FBRyxTQUFTbDRCLENBQUMsRUFBRXV0QixDQUFDO29CQUNyQixJQUFJNEssS0FBSzEzQixNQUFLc2dCLEdBQUcsQ0FBQyxHQUFHdGdCLE1BQUt5YSxHQUFHLENBQUNsYixFQUFFMDJCLFVBQVUsQ0FBQ3pXLENBQUMsRUFBRXNOLEVBQUVtSixVQUFVLENBQUN6VyxDQUFDLElBQUl4ZixNQUFLc2dCLEdBQUcsQ0FBQ3dNLEVBQUVrSixVQUFVLENBQUN4VyxDQUFDLEVBQUVqZ0IsRUFBRXkyQixVQUFVLENBQUN4VyxDQUFDO29CQUN2RyxJQUFJbVksS0FBSzMzQixNQUFLc2dCLEdBQUcsQ0FBQyxHQUFHdGdCLE1BQUt5YSxHQUFHLENBQUNsYixFQUFFMDJCLFVBQVUsQ0FBQ3ZXLENBQUMsRUFBRW9OLEVBQUVtSixVQUFVLENBQUN2VyxDQUFDLElBQUkxZixNQUFLc2dCLEdBQUcsQ0FBQ3dNLEVBQUVrSixVQUFVLENBQUN0VyxDQUFDLEVBQUVuZ0IsRUFBRXkyQixVQUFVLENBQUN0VyxDQUFDO29CQUN2RyxJQUFJcEQsS0FBSy9jLEVBQUUwMkIsVUFBVSxDQUFDelcsQ0FBQyxHQUFHamdCLEVBQUV5MkIsVUFBVSxDQUFDeFcsQ0FBQztvQkFDeEMsSUFBSW9ZLEtBQUtyNEIsRUFBRTAyQixVQUFVLENBQUN2VyxDQUFDLEdBQUduZ0IsRUFBRXkyQixVQUFVLENBQUN0VyxDQUFDO29CQUN4QyxJQUFJbEQsS0FBS3NRLEVBQUVtSixVQUFVLENBQUN6VyxDQUFDLEdBQUdzTixFQUFFa0osVUFBVSxDQUFDeFcsQ0FBQztvQkFDeEMsSUFBSXFZLEtBQUsvSyxFQUFFbUosVUFBVSxDQUFDdlcsQ0FBQyxHQUFHb04sRUFBRWtKLFVBQVUsQ0FBQ3RXLENBQUM7b0JBQ3hDLE9BQU9wRCxLQUFLc2IsS0FBS3BiLEtBQUtxYixLQUFLSCxLQUFLQztnQkFDcEM7Z0JBRUE7Ozs7Ozs7O0NBUUMsR0FDRDs7Ozs7Ozs7Q0FRQyxHQUNEOzs7O0NBSUMsR0FDRHAzQixLQUFLd0csU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsS0FBSztvQkFDM0MsNENBQTRDO29CQUM1QyxJQUFJMlQsT0FBTyxDQUFDMUo7b0JBQ1osSUFBSTJKLE9BQU8zSjtvQkFDWCxJQUFJM29CLElBQUkwZSxNQUFNd1AsRUFBRTtvQkFDaEIsSUFBSXVDLElBQUlqMkIsS0FBS2lMLEdBQUcsQ0FBQ2laLE1BQU15UCxFQUFFLEVBQUV6UCxNQUFNd1AsRUFBRTtvQkFDbkMsSUFBSXFFLE9BQU8vM0IsS0FBS3loQixHQUFHLENBQUN3VTtvQkFDcEIsSUFBSXBjLFNBQVM3WixLQUFLc0QsSUFBSTtvQkFDdEIsSUFBSyxJQUFJM0UsSUFBSSxLQUFLQSxNQUFNLE1BQU1BLElBQUlBLE1BQU0sTUFBTSxNQUFNLEtBQU07d0JBQ3RELElBQUlvNUIsS0FBS3hZLENBQUMsR0FBR3hmLE1BQUtzb0IsT0FBTyxFQUFFOzRCQUN2QixZQUFZOzRCQUNaLElBQUk3aUIsQ0FBQyxDQUFDN0csRUFBRSxHQUFHLElBQUksQ0FBQ28zQixVQUFVLENBQUNwM0IsRUFBRSxJQUFJLElBQUksQ0FBQ3EzQixVQUFVLENBQUNyM0IsRUFBRSxHQUFHNkcsQ0FBQyxDQUFDN0csRUFBRSxFQUFFO2dDQUN4RCxPQUFPOzRCQUNYO3dCQUNKLE9BQU87NEJBQ0gsSUFBSXE1QixRQUFRLElBQUkvQixDQUFDLENBQUN0M0IsRUFBRTs0QkFDcEIsSUFBSXM1QixLQUFLLEFBQUMsQ0FBQSxJQUFJLENBQUNsQyxVQUFVLENBQUNwM0IsRUFBRSxHQUFHNkcsQ0FBQyxDQUFDN0csRUFBRSxBQUFELElBQUtxNUI7NEJBQ3ZDLElBQUlFLEtBQUssQUFBQyxDQUFBLElBQUksQ0FBQ2xDLFVBQVUsQ0FBQ3IzQixFQUFFLEdBQUc2RyxDQUFDLENBQUM3RyxFQUFFLEFBQUQsSUFBS3E1Qjs0QkFDdkMsNkJBQTZCOzRCQUM3QixJQUFJNzRCLElBQUksQ0FBQzs0QkFDVCxJQUFJODRCLEtBQUtDLElBQUk7Z0NBQ1QsSUFBSUMsT0FBT0Y7Z0NBQ1hBLEtBQUtDLElBQUlBLEtBQUtDO2dDQUNkaDVCLElBQUk7NEJBQ1I7NEJBQ0Esa0JBQWtCOzRCQUNsQixJQUFJODRCLEtBQUtKLE1BQU07Z0NBQ1hoZSxPQUFPM1IsT0FBTztnQ0FDZDJSLE1BQU0sQ0FBQ2xiLEVBQUUsR0FBR1E7Z0NBQ1owNEIsT0FBT0k7NEJBQ1g7NEJBQ0Esb0JBQW9COzRCQUNwQkgsT0FBTy8zQixNQUFLeWEsR0FBRyxDQUFDc2QsTUFBTUk7NEJBQ3RCLElBQUlMLE9BQU9DLE1BQU07Z0NBQ2IsT0FBTzs0QkFDWDt3QkFDSjtvQkFDSjtvQkFDQSxxQ0FBcUM7b0JBQ3JDLGtEQUFrRDtvQkFDbEQsSUFBSUQsT0FBTyxLQUFLM1QsTUFBTXVQLFdBQVcsR0FBR29FLE1BQU07d0JBQ3RDLE9BQU87b0JBQ1g7b0JBQ0EsZ0JBQWdCO29CQUNoQjVULE9BQU82UCxRQUFRLEdBQUcrRDtvQkFDbEI1VCxPQUFPcEssTUFBTSxHQUFHQTtvQkFDaEIsT0FBTztnQkFDWDtnQkFFQXZaLEtBQUt3RyxTQUFTLENBQUNzeEIsUUFBUSxHQUFHO29CQUN0QixPQUFPQyxLQUFLQyxTQUFTLENBQUMsSUFBSTtnQkFDOUI7WUFHQTtZQUFFO2dCQUFDLGVBQWM7Z0JBQUUsa0JBQWlCO2dCQUFHLGtCQUFpQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBUy80QixRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDaEcsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdEQsSUFBSUosV0FBVzdDLFNBQVE7Z0JBRXZCLElBQUlrRCxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSWUsT0FBT2YsU0FBUTtnQkFFbkIsSUFBSTRDLGNBQWM1QyxTQUFRO2dCQUUxQmYsUUFBT0QsT0FBTyxHQUFHdXlCO2dCQUVqQjs7O0NBR0MsR0FDRCxTQUFTQTtvQkFDTCxJQUFJLENBQUN5SCxNQUFNLEdBQUcsSUFBSXAyQjtvQkFDbEIsSUFBSSxDQUFDMkcsWUFBWSxHQUFHO29CQUNwQixJQUFJLENBQUMwdkIsWUFBWSxHQUFHLEVBQUU7b0JBQ3RCLElBQUksQ0FBQ3BGLGFBQWEsR0FBRyxJQUFJLENBQUNBLGFBQWEsQ0FBQ25CLElBQUksQ0FBQyxJQUFJO2dCQUNyRDtnQkFFQTs7Q0FFQyxHQUNEbkIsV0FBV2hxQixTQUFTLENBQUNPLFdBQVcsR0FBRyxTQUFTNEIsT0FBTztvQkFDL0MsT0FBTyxJQUFJLENBQUNzdkIsTUFBTSxDQUFDbHhCLFdBQVcsQ0FBQzRCO2dCQUNuQztnQkFFQTs7Q0FFQyxHQUNENm5CLFdBQVdocUIsU0FBUyxDQUFDNlAsV0FBVyxHQUFHLFNBQVNxZSxRQUFRLEVBQUVDLFFBQVE7b0JBQzFELElBQUl3RCxRQUFRLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxVQUFVLENBQUMxRDtvQkFDbkMsSUFBSTJELFFBQVEsSUFBSSxDQUFDSixNQUFNLENBQUNHLFVBQVUsQ0FBQ3pEO29CQUNuQyxPQUFPMzBCLEtBQUtxVyxXQUFXLENBQUM4aEIsT0FBT0U7Z0JBQ25DO2dCQUVBOztDQUVDLEdBQ0Q3SCxXQUFXaHFCLFNBQVMsQ0FBQzR4QixVQUFVLEdBQUcsU0FBU3p2QixPQUFPO29CQUM5QyxPQUFPLElBQUksQ0FBQ3N2QixNQUFNLENBQUNHLFVBQVUsQ0FBQ3p2QjtnQkFDbEM7Z0JBRUE7O0NBRUMsR0FDRDZuQixXQUFXaHFCLFNBQVMsQ0FBQ2l0QixhQUFhLEdBQUc7b0JBQ2pDLE9BQU8sSUFBSSxDQUFDanJCLFlBQVk7Z0JBQzVCO2dCQUVBOztDQUVDLEdBQ0Rnb0IsV0FBV2hxQixTQUFTLENBQUNrdEIsYUFBYSxHQUFHO29CQUNqQyxPQUFPLElBQUksQ0FBQ3VFLE1BQU0sQ0FBQ0ssU0FBUztnQkFDaEM7Z0JBRUE7O0NBRUMsR0FDRDlILFdBQVdocUIsU0FBUyxDQUFDbXRCLGNBQWMsR0FBRztvQkFDbEMsT0FBTyxJQUFJLENBQUNzRSxNQUFNLENBQUNNLGFBQWE7Z0JBQ3BDO2dCQUVBOztDQUVDLEdBQ0QvSCxXQUFXaHFCLFNBQVMsQ0FBQ290QixjQUFjLEdBQUc7b0JBQ2xDLE9BQU8sSUFBSSxDQUFDcUUsTUFBTSxDQUFDTyxZQUFZO2dCQUNuQztnQkFFQTs7O0NBR0MsR0FDRGhJLFdBQVdocUIsU0FBUyxDQUFDdXNCLEtBQUssR0FBRyxTQUFTbFEsSUFBSSxFQUFFaVEsYUFBYTtvQkFDckQsSUFBSSxDQUFDbUYsTUFBTSxDQUFDbEYsS0FBSyxDQUFDbFEsTUFBTWlRO2dCQUM1QjtnQkFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNEdEMsV0FBV2hxQixTQUFTLENBQUNrZCxPQUFPLEdBQUcsU0FBU0UsS0FBSyxFQUFFNlUsZUFBZTtvQkFDMUQsSUFBSSxDQUFDUixNQUFNLENBQUN2VSxPQUFPLENBQUNFLE9BQU82VTtnQkFDL0I7Z0JBRUE7Ozs7O0NBS0MsR0FDRGpJLFdBQVdocUIsU0FBUyxDQUFDNGYsV0FBVyxHQUFHLFNBQVNDLFNBQVM7b0JBQ2pELElBQUksQ0FBQzRSLE1BQU0sQ0FBQzdSLFdBQVcsQ0FBQ0M7Z0JBQzVCO2dCQUVBOzs7Q0FHQyxHQUNEbUssV0FBV2hxQixTQUFTLENBQUN5ZCxXQUFXLEdBQUcsU0FBU3BCLElBQUksRUFBRWpmLFFBQVE7b0JBQ3REM0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQy9ELEtBQUtnRSxPQUFPLENBQUM2ZTtvQkFDdEMsSUFBSWxhLFVBQVUsSUFBSSxDQUFDc3ZCLE1BQU0sQ0FBQ2hVLFdBQVcsQ0FBQ3BCLE1BQU1qZjtvQkFDNUMsSUFBSSxDQUFDNEUsWUFBWTtvQkFDakIsSUFBSSxDQUFDa3dCLFVBQVUsQ0FBQy92QjtvQkFDaEIsT0FBT0E7Z0JBQ1g7Z0JBRUE7O0NBRUMsR0FDRDZuQixXQUFXaHFCLFNBQVMsQ0FBQzBkLFlBQVksR0FBRyxTQUFTdmIsT0FBTztvQkFDaEQsSUFBSSxDQUFDZ3dCLFlBQVksQ0FBQ2h3QjtvQkFDbEIsSUFBSSxDQUFDSCxZQUFZO29CQUNqQixJQUFJLENBQUN5dkIsTUFBTSxDQUFDL1QsWUFBWSxDQUFDdmI7Z0JBQzdCO2dCQUVBOzs7Q0FHQyxHQUNENm5CLFdBQVdocUIsU0FBUyxDQUFDaWUsU0FBUyxHQUFHLFNBQVM5YixPQUFPLEVBQUVrYSxJQUFJLEVBQUUyQixZQUFZO29CQUNqRXZpQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDL0QsS0FBS2dFLE9BQU8sQ0FBQzZlO29CQUN0QyxJQUFJK1YsVUFBVSxJQUFJLENBQUNYLE1BQU0sQ0FBQ3hULFNBQVMsQ0FBQzliLFNBQVNrYSxNQUFNMkI7b0JBQ25ELElBQUlvVSxTQUFTO3dCQUNULElBQUksQ0FBQ0YsVUFBVSxDQUFDL3ZCO29CQUNwQjtnQkFDSjtnQkFFQTs7O0NBR0MsR0FDRDZuQixXQUFXaHFCLFNBQVMsQ0FBQ2lDLFVBQVUsR0FBRyxTQUFTRSxPQUFPO29CQUM5QyxJQUFJLENBQUMrdkIsVUFBVSxDQUFDL3ZCO2dCQUNwQjtnQkFFQTZuQixXQUFXaHFCLFNBQVMsQ0FBQ2t5QixVQUFVLEdBQUcsU0FBUy92QixPQUFPO29CQUM5QyxJQUFJLENBQUN1dkIsWUFBWSxDQUFDL0wsSUFBSSxDQUFDeGpCO2dCQUMzQjtnQkFFQTZuQixXQUFXaHFCLFNBQVMsQ0FBQ215QixZQUFZLEdBQUcsU0FBU2h3QixPQUFPO29CQUNoRCxJQUFLLElBQUl6SixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDZzVCLFlBQVksQ0FBQzM0QixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDL0MsSUFBSSxJQUFJLENBQUNnNUIsWUFBWSxDQUFDaDVCLEVBQUUsSUFBSXlKLFNBQVM7NEJBQ2pDLElBQUksQ0FBQ3V2QixZQUFZLENBQUNoNUIsRUFBRSxHQUFHO3dCQUMzQjtvQkFDSjtnQkFDSjtnQkFFQTs7OztDQUlDLEdBQ0Q7Ozs7Q0FJQyxHQUNEc3hCLFdBQVdocUIsU0FBUyxDQUFDZ3VCLFdBQVcsR0FBRyxTQUFTcUUsZUFBZTtvQkFDdkQ1MkIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxPQUFPODBCLG9CQUFvQjtvQkFDcEQsSUFBSSxDQUFDQyxVQUFVLEdBQUdEO29CQUNsQiwrQ0FBK0M7b0JBQy9DLE1BQU8sSUFBSSxDQUFDWCxZQUFZLENBQUMzNEIsTUFBTSxHQUFHLEVBQUc7d0JBQ2pDLElBQUksQ0FBQ3c1QixjQUFjLEdBQUcsSUFBSSxDQUFDYixZQUFZLENBQUN0TCxHQUFHO3dCQUMzQyxJQUFJLElBQUksQ0FBQ21NLGNBQWMsS0FBSyxNQUFNOzRCQUM5Qjt3QkFDSjt3QkFDQSxzREFBc0Q7d0JBQ3RELHVEQUF1RDt3QkFDdkQsSUFBSUMsVUFBVSxJQUFJLENBQUNmLE1BQU0sQ0FBQ0csVUFBVSxDQUFDLElBQUksQ0FBQ1csY0FBYzt3QkFDeEQscURBQXFEO3dCQUNyRCxJQUFJLENBQUNkLE1BQU0sQ0FBQ2xGLEtBQUssQ0FBQ2lHLFNBQVMsSUFBSSxDQUFDbEcsYUFBYTtvQkFDakQ7Z0JBQ0o7Z0JBRUF0QyxXQUFXaHFCLFNBQVMsQ0FBQ3NzQixhQUFhLEdBQUcsU0FBU25xQixPQUFPO29CQUNqRCwwQ0FBMEM7b0JBQzFDLElBQUlBLFdBQVcsSUFBSSxDQUFDb3dCLGNBQWMsRUFBRTt3QkFDaEMsT0FBTztvQkFDWDtvQkFDQSxJQUFJckUsV0FBV2oxQixNQUFLeWEsR0FBRyxDQUFDdlIsU0FBUyxJQUFJLENBQUNvd0IsY0FBYztvQkFDcEQsSUFBSXBFLFdBQVdsMUIsTUFBS3NnQixHQUFHLENBQUNwWCxTQUFTLElBQUksQ0FBQ293QixjQUFjO29CQUNwRCxrQ0FBa0M7b0JBQ2xDLElBQUlFLFlBQVksSUFBSSxDQUFDaEIsTUFBTSxDQUFDbHhCLFdBQVcsQ0FBQzJ0QjtvQkFDeEMsSUFBSXdFLFlBQVksSUFBSSxDQUFDakIsTUFBTSxDQUFDbHhCLFdBQVcsQ0FBQzR0QjtvQkFDeEMscUNBQXFDO29CQUNyQyxJQUFJLENBQUNtRSxVQUFVLENBQUNHLFdBQVdDO29CQUMzQixPQUFPO2dCQUNYO1lBR0E7WUFBRTtnQkFBQyxlQUFjO2dCQUFFLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsVUFBUztnQkFBRyxpQkFBZ0I7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNqNkIsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQy9ILElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHMEQ7Z0JBRWpCekQsUUFBT0QsT0FBTyxDQUFDOHNCLEtBQUssR0FBR0c7Z0JBRXZCaHRCLFFBQU9ELE9BQU8sQ0FBQ2d0QixNQUFNLEdBQUdFO2dCQUV4Qmp0QixRQUFPRCxPQUFPLENBQUNvdEIsS0FBSyxHQUFHRDtnQkFFdkJsdEIsUUFBT0QsT0FBTyxDQUFDc3RCLEtBQUssR0FBR0Q7Z0JBRXZCLElBQUl4cEIsV0FBVzdDLFNBQVE7Z0JBRXZCLElBQUlrRCxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSXdDLFFBQVF4QyxTQUFRO2dCQUVwQixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJVSxPQUFPVixTQUFRO2dCQUVuQixJQUFJVyxRQUFRWCxTQUFRO2dCQUVwQixJQUFJWSxRQUFRWixTQUFRO2dCQUVwQixJQUFJYyxNQUFNZCxTQUFRO2dCQUVsQixJQUFJdUMsUUFBUXZDLFNBQVE7Z0JBRXBCLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlvRCxXQUFXcEQsU0FBUTtnQkFFdkIsSUFBSXFELFdBQVdyRCxTQUFRO2dCQUV2Qjs7Q0FFQyxHQUNEd0MsTUFBTTAzQixRQUFRLEdBQUc7Z0JBRWpCMTNCLE1BQU0yM0IsUUFBUSxHQUFHO2dCQUVqQjMzQixNQUFNNDNCLFdBQVcsR0FBRztnQkFFcEI7OztDQUdDLEdBQ0QsU0FBU25PO29CQUNMLElBQUksQ0FBQzhELE1BQU0sR0FBRyxJQUFJNUQ7b0JBQ2xCLElBQUksQ0FBQzZELE1BQU0sR0FBRyxJQUFJN0Q7b0JBQ2xCLElBQUksQ0FBQzBFLFVBQVUsR0FBRztvQkFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7b0JBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO2dCQUNwQjtnQkFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBUzdFO29CQUNMLElBQUksQ0FBQ3pSLE1BQU0sR0FBR2hhLEtBQUtzRCxJQUFJO29CQUN2QixJQUFJLENBQUMyVyxNQUFNLEdBQUdqYSxLQUFLc0QsSUFBSTtvQkFDdkIsSUFBSSxDQUFDa3RCLFFBQVE7b0JBQ2IsSUFBSSxDQUFDb0osVUFBVTtnQkFDbkI7Z0JBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNoTztvQkFDTCxJQUFJLENBQUNpTyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDaHBCLE1BQU0sR0FBRyxFQUFFO29CQUNoQixJQUFJLENBQUNFLE1BQU0sR0FBRyxFQUFFO29CQUNoQixJQUFJLENBQUMwZixLQUFLLEdBQUc7Z0JBQ2pCO2dCQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU3h1QixTQUFTZ2lCLE1BQU0sRUFBRXNNLEtBQUssRUFBRXJNLEtBQUs7b0JBQ2xDLEVBQUVuaUIsTUFBTTAzQixRQUFRO29CQUNoQixJQUFJbkssU0FBU3BMLE1BQU1vTCxNQUFNO29CQUN6QixJQUFJQyxTQUFTckwsTUFBTXFMLE1BQU07b0JBQ3pCLElBQUl2WixNQUFNa08sTUFBTWtNLFVBQVU7b0JBQzFCLElBQUluYSxNQUFNaU8sTUFBTW1NLFVBQVU7b0JBQzFCLDBCQUEwQjtvQkFDMUIsSUFBSXlKLFVBQVUsSUFBSUM7b0JBQ2xCRCxRQUFRRSxTQUFTLENBQUN6SixPQUFPakIsUUFBUXRaLEtBQUt1WixRQUFRdFo7b0JBQzlDLG9DQUFvQztvQkFDcEMsSUFBSWdrQixXQUFXSCxRQUFRSSxHQUFHO29CQUMxQixnQkFBZ0I7b0JBQ2hCLElBQUlDLGFBQWEvM0IsU0FBUzhuQixvQkFBb0I7b0JBQzlDLDBEQUEwRDtvQkFDMUQsZ0RBQWdEO29CQUNoRCxJQUFJa1EsUUFBUSxFQUFFO29CQUNkLElBQUlDLFFBQVEsRUFBRTtvQkFDZCxTQUFTO29CQUNULElBQUlDLFlBQVk7b0JBQ2hCLElBQUlDLGVBQWVwTTtvQkFDbkIsSUFBSXFNLGVBQWVyTTtvQkFDbkIsdUJBQXVCO29CQUN2QixJQUFJc00sT0FBTztvQkFDWCxNQUFPQSxPQUFPTixXQUFZO3dCQUN0Qiw4Q0FBOEM7d0JBQzlDRyxZQUFZUixRQUFRWSxPQUFPO3dCQUMzQixJQUFLLElBQUlsN0IsSUFBSSxHQUFHQSxJQUFJODZCLFdBQVcsRUFBRTk2QixFQUFHOzRCQUNoQzQ2QixLQUFLLENBQUM1NkIsRUFBRSxHQUFHeTZCLFFBQVEsQ0FBQ3o2QixFQUFFLENBQUNxUixNQUFNOzRCQUM3QndwQixLQUFLLENBQUM3NkIsRUFBRSxHQUFHeTZCLFFBQVEsQ0FBQ3o2QixFQUFFLENBQUN1UixNQUFNO3dCQUNqQzt3QkFDQStvQixRQUFRYSxLQUFLO3dCQUNiLHlFQUF5RTt3QkFDekUsSUFBSWIsUUFBUVksT0FBTyxJQUFJLEdBQUc7NEJBQ3RCO3dCQUNKO3dCQUNBLHlCQUF5Qjt3QkFDekIsSUFBSWwxQixJQUFJczBCLFFBQVFjLGVBQWU7d0JBQy9CSixlQUFlaDFCLEVBQUU0aUIsYUFBYTt3QkFDOUIsa0JBQWtCO3dCQUNsQixJQUFJb1MsZ0JBQWdCRCxjQUFjLENBQUM7d0JBQ25DQSxlQUFlQzt3QkFDZix3QkFBd0I7d0JBQ3hCLElBQUl2RSxJQUFJNkQsUUFBUWUsa0JBQWtCO3dCQUNsQyxrREFBa0Q7d0JBQ2xELElBQUk1RSxFQUFFN04sYUFBYSxLQUFLcm9CLE1BQUtzb0IsT0FBTyxHQUFHdG9CLE1BQUtzb0IsT0FBTyxFQUFFOzRCQU1qRDt3QkFDSjt3QkFDQSwrREFBK0Q7d0JBQy9ELElBQUl5UyxTQUFTYixRQUFRLENBQUNILFFBQVFZLE9BQU8sQ0FBQzt3QkFDdEMsZ0JBQWdCO3dCQUNoQkksT0FBT2pxQixNQUFNLEdBQUd5ZSxPQUFPeUwsVUFBVSxDQUFDMTZCLElBQUlnUCxRQUFRLENBQUMyRyxJQUFJdFEsQ0FBQyxFQUFFMUYsS0FBS2c3QixHQUFHLENBQUMvRTt3QkFDL0Q2RSxPQUFPemUsRUFBRSxHQUFHamMsVUFBVTZPLE9BQU8sQ0FBQytHLEtBQUtzWixPQUFPMkwsU0FBUyxDQUFDSCxPQUFPanFCLE1BQU07d0JBQ2pFaXFCLE9BQU8vcEIsTUFBTSxHQUFHd2UsT0FBT3dMLFVBQVUsQ0FBQzE2QixJQUFJZ1AsUUFBUSxDQUFDNEcsSUFBSXZRLENBQUMsRUFBRXV3Qjt3QkFDdEQ2RSxPQUFPdmUsRUFBRSxHQUFHbmMsVUFBVTZPLE9BQU8sQ0FBQ2dILEtBQUtzWixPQUFPMEwsU0FBUyxDQUFDSCxPQUFPL3BCLE1BQU07d0JBQ2pFK3BCLE9BQU9sdkIsQ0FBQyxHQUFHNUwsS0FBS2lMLEdBQUcsQ0FBQzZ2QixPQUFPdmUsRUFBRSxFQUFFdWUsT0FBT3plLEVBQUU7d0JBQ3hDLG1FQUFtRTt3QkFDbkUsRUFBRW9lO3dCQUNGLEVBQUUxNEIsTUFBTTIzQixRQUFRO3dCQUNoQixtRUFBbUU7d0JBQ25FLFlBQVk7d0JBQ1osSUFBSXdCLFlBQVk7d0JBQ2hCLElBQUssSUFBSTE3QixJQUFJLEdBQUdBLElBQUk4NkIsV0FBVyxFQUFFOTZCLEVBQUc7NEJBQ2hDLElBQUlzN0IsT0FBT2pxQixNQUFNLElBQUl1cEIsS0FBSyxDQUFDNTZCLEVBQUUsSUFBSXM3QixPQUFPL3BCLE1BQU0sSUFBSXNwQixLQUFLLENBQUM3NkIsRUFBRSxFQUFFO2dDQUN4RDA3QixZQUFZO2dDQUNaOzRCQUNKO3dCQUNKO3dCQUNBLHVFQUF1RTt3QkFDdkUsSUFBSUEsV0FBVzs0QkFDWDt3QkFDSjt3QkFDQSwrQkFBK0I7d0JBQy9CLEVBQUVwQixRQUFRWSxPQUFPO29CQUNyQjtvQkFDQTM0QixNQUFNNDNCLFdBQVcsR0FBRzU1QixNQUFLc2dCLEdBQUcsQ0FBQ3RlLE1BQU00M0IsV0FBVyxFQUFFYztvQkFDaEQsa0JBQWtCO29CQUNsQlgsUUFBUXFCLGdCQUFnQixDQUFDbFgsT0FBT2pLLE1BQU0sRUFBRWlLLE9BQU9oSyxNQUFNO29CQUNyRGdLLE9BQU91TSxRQUFRLEdBQUd4d0IsS0FBS3d3QixRQUFRLENBQUN2TSxPQUFPakssTUFBTSxFQUFFaUssT0FBT2hLLE1BQU07b0JBQzVEZ0ssT0FBTzJWLFVBQVUsR0FBR2E7b0JBQ3BCLHFCQUFxQjtvQkFDckJYLFFBQVFzQixVQUFVLENBQUM3SztvQkFDbkIsNEJBQTRCO29CQUM1QixJQUFJck0sTUFBTW9NLFFBQVEsRUFBRTt3QkFDaEIsSUFBSWhjLEtBQUtnYixPQUFPMWIsUUFBUTt3QkFDeEIsSUFBSVcsS0FBS2diLE9BQU8zYixRQUFRO3dCQUN4QixJQUFJcVEsT0FBT3VNLFFBQVEsR0FBR2xjLEtBQUtDLE1BQU0wUCxPQUFPdU0sUUFBUSxHQUFHendCLE1BQUtzb0IsT0FBTyxFQUFFOzRCQUM3RCxrQ0FBa0M7NEJBQ2xDLGdEQUFnRDs0QkFDaERwRSxPQUFPdU0sUUFBUSxJQUFJbGMsS0FBS0M7NEJBQ3hCLElBQUlzRixTQUFTN1osS0FBS2lMLEdBQUcsQ0FBQ2daLE9BQU9oSyxNQUFNLEVBQUVnSyxPQUFPakssTUFBTTs0QkFDbERILE9BQU9LLFNBQVM7NEJBQ2hCK0osT0FBT2pLLE1BQU0sQ0FBQ25OLE1BQU0sQ0FBQ3lILElBQUl1Rjs0QkFDekJvSyxPQUFPaEssTUFBTSxDQUFDb0IsTUFBTSxDQUFDOUcsSUFBSXNGO3dCQUM3QixPQUFPOzRCQUNILG1EQUFtRDs0QkFDbkQseUNBQXlDOzRCQUN6QyxJQUFJclUsSUFBSXhGLEtBQUtzb0IsR0FBRyxDQUFDckUsT0FBT2pLLE1BQU0sRUFBRWlLLE9BQU9oSyxNQUFNOzRCQUM3Q2dLLE9BQU9qSyxNQUFNLENBQUNqUSxHQUFHLENBQUN2RTs0QkFDbEJ5ZSxPQUFPaEssTUFBTSxDQUFDbFEsR0FBRyxDQUFDdkU7NEJBQ2xCeWUsT0FBT3VNLFFBQVEsR0FBRzt3QkFDdEI7b0JBQ0o7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRCxTQUFTOUU7b0JBQ0wsSUFBSSxDQUFDMlAsUUFBUSxHQUFHLEVBQUU7b0JBQ2xCLFVBQVU7b0JBQ1YsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtvQkFDcEIsU0FBUztvQkFDVCxJQUFJLENBQUNaLE9BQU8sR0FBRztvQkFDZixJQUFJLENBQUM5bUIsUUFBUSxHQUFHO2dCQUNwQjtnQkFFQTs7Q0FFQyxHQUNEOFgsY0FBYzVrQixTQUFTLENBQUN5MEIsY0FBYyxHQUFHO29CQUNyQyxPQUFPLElBQUksQ0FBQ2IsT0FBTztnQkFDdkI7Z0JBRUE7O0NBRUMsR0FDRGhQLGNBQWM1a0IsU0FBUyxDQUFDbTBCLFNBQVMsR0FBRyxTQUFTckgsS0FBSztvQkFDOUNyeEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxLQUFLdXZCLFNBQVNBLFFBQVEsSUFBSSxDQUFDOEcsT0FBTztvQkFDM0QsT0FBTyxJQUFJLENBQUNZLFVBQVUsQ0FBQzFILE1BQU07Z0JBQ2pDO2dCQUVBOztDQUVDLEdBQ0RsSSxjQUFjNWtCLFNBQVMsQ0FBQ2kwQixVQUFVLEdBQUcsU0FBUzlFLENBQUM7b0JBQzNDLElBQUl1RixZQUFZO29CQUNoQixJQUFJQyxZQUFZejdCLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDNnZCLFVBQVUsQ0FBQyxFQUFFLEVBQUVyRjtvQkFDN0MsSUFBSyxJQUFJejJCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNrN0IsT0FBTyxFQUFFLEVBQUVsN0IsRUFBRzt3QkFDbkMsSUFBSTAzQixRQUFRbDNCLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDNnZCLFVBQVUsQ0FBQzk3QixFQUFFLEVBQUV5MkI7d0JBQ3pDLElBQUlpQixRQUFRdUUsV0FBVzs0QkFDbkJELFlBQVloOEI7NEJBQ1ppOEIsWUFBWXZFO3dCQUNoQjtvQkFDSjtvQkFDQSxPQUFPc0U7Z0JBQ1g7Z0JBRUE7O0NBRUMsR0FDRDlQLGNBQWM1a0IsU0FBUyxDQUFDNDBCLGdCQUFnQixHQUFHLFNBQVN6RixDQUFDO29CQUNqRCxPQUFPLElBQUksQ0FBQ3FGLFVBQVUsQ0FBQyxJQUFJLENBQUNQLFVBQVUsQ0FBQzlFLEdBQUc7Z0JBQzlDO2dCQUVBOzs7Q0FHQyxHQUNEdkssY0FBYzVrQixTQUFTLENBQUNpRCxHQUFHLEdBQUcsU0FBU29FLEtBQUssRUFBRXlsQixLQUFLO29CQUMvQyxpQ0FBaUM7b0JBQ2pDcnhCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsT0FBTzhKLE1BQU04YyxvQkFBb0IsS0FBSztvQkFDL0Q5YyxNQUFNOGMsb0JBQW9CLENBQUMsSUFBSSxFQUFFMkk7Z0JBQ3JDO2dCQUVBLFNBQVMrSDtvQkFDTCxJQUFJLENBQUM5cUIsTUFBTTtvQkFDWCxXQUFXO29CQUNYLElBQUksQ0FBQ0UsTUFBTTtvQkFDWCxXQUFXO29CQUNYLElBQUksQ0FBQ3NMLEVBQUUsR0FBR3JjLEtBQUtzRCxJQUFJO29CQUNuQiwwQkFBMEI7b0JBQzFCLElBQUksQ0FBQ2laLEVBQUUsR0FBR3ZjLEtBQUtzRCxJQUFJO29CQUNuQiwwQkFBMEI7b0JBQzFCLElBQUksQ0FBQ3NJLENBQUMsR0FBRzVMLEtBQUtzRCxJQUFJO29CQUNsQixVQUFVO29CQUNWLElBQUksQ0FBQ2hFLENBQUM7Z0JBQ1Y7Z0JBRUFxOEIsY0FBYzcwQixTQUFTLENBQUNpRCxHQUFHLEdBQUcsU0FBU3lCLENBQUM7b0JBQ3BDLElBQUksQ0FBQ3FGLE1BQU0sR0FBR3JGLEVBQUVxRixNQUFNO29CQUN0QixJQUFJLENBQUNFLE1BQU0sR0FBR3ZGLEVBQUV1RixNQUFNO29CQUN0QixJQUFJLENBQUNzTCxFQUFFLEdBQUdyYyxLQUFLeUYsS0FBSyxDQUFDK0YsRUFBRTZRLEVBQUU7b0JBQ3pCLElBQUksQ0FBQ0UsRUFBRSxHQUFHdmMsS0FBS3lGLEtBQUssQ0FBQytGLEVBQUUrUSxFQUFFO29CQUN6QixJQUFJLENBQUMzUSxDQUFDLEdBQUc1TCxLQUFLeUYsS0FBSyxDQUFDK0YsRUFBRUksQ0FBQztvQkFDdkIsSUFBSSxDQUFDdE0sQ0FBQyxHQUFHa00sRUFBRWxNLENBQUM7Z0JBQ2hCO2dCQUVBLFNBQVN5NkI7b0JBQ0wsSUFBSSxDQUFDNkIsSUFBSSxHQUFHLElBQUlEO29CQUNoQixJQUFJLENBQUNFLElBQUksR0FBRyxJQUFJRjtvQkFDaEIsSUFBSSxDQUFDRyxJQUFJLEdBQUcsSUFBSUg7b0JBQ2hCLElBQUksQ0FBQ3pCLEdBQUcsR0FBRzt3QkFBRSxJQUFJLENBQUMwQixJQUFJO3dCQUFFLElBQUksQ0FBQ0MsSUFBSTt3QkFBRSxJQUFJLENBQUNDLElBQUk7cUJBQUU7b0JBQzlDLElBQUksQ0FBQ3BCLE9BQU87Z0JBQ2hCO2dCQUVBWCxRQUFRanpCLFNBQVMsQ0FBQ2kxQixLQUFLLEdBQUc7b0JBQ3RCLElBQUksSUFBSSxDQUFDckIsT0FBTyxJQUFJLEdBQUc7d0JBQ25CLE9BQU87NEJBQUUsTUFBTSxJQUFJLENBQUNBLE9BQU87NEJBQUUsSUFBSSxDQUFDa0IsSUFBSSxDQUFDdDhCLENBQUM7NEJBQUUsSUFBSSxDQUFDczhCLElBQUksQ0FBQ3ZmLEVBQUUsQ0FBQ2tELENBQUM7NEJBQUUsSUFBSSxDQUFDcWMsSUFBSSxDQUFDdmYsRUFBRSxDQUFDb0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNtYyxJQUFJLENBQUNyZixFQUFFLENBQUNnRCxDQUFDOzRCQUFFLElBQUksQ0FBQ3FjLElBQUksQ0FBQ3JmLEVBQUUsQ0FBQ2tELENBQUM7NEJBQUUsSUFBSSxDQUFDb2MsSUFBSSxDQUFDdjhCLENBQUM7NEJBQUUsSUFBSSxDQUFDdThCLElBQUksQ0FBQ3hmLEVBQUUsQ0FBQ2tELENBQUM7NEJBQUUsSUFBSSxDQUFDc2MsSUFBSSxDQUFDeGYsRUFBRSxDQUFDb0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNvYyxJQUFJLENBQUN0ZixFQUFFLENBQUNnRCxDQUFDOzRCQUFFLElBQUksQ0FBQ3NjLElBQUksQ0FBQ3RmLEVBQUUsQ0FBQ2tELENBQUM7NEJBQUUsSUFBSSxDQUFDcWMsSUFBSSxDQUFDeDhCLENBQUM7NEJBQUUsSUFBSSxDQUFDdzhCLElBQUksQ0FBQ3pmLEVBQUUsQ0FBQ2tELENBQUM7NEJBQUUsSUFBSSxDQUFDdWMsSUFBSSxDQUFDemYsRUFBRSxDQUFDb0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNxYyxJQUFJLENBQUN2ZixFQUFFLENBQUNnRCxDQUFDOzRCQUFFLElBQUksQ0FBQ3VjLElBQUksQ0FBQ3ZmLEVBQUUsQ0FBQ2tELENBQUM7eUJBQUUsQ0FBQzJZLFFBQVE7b0JBQ2pSLE9BQU8sSUFBSSxJQUFJLENBQUNzQyxPQUFPLElBQUksR0FBRzt3QkFDMUIsT0FBTzs0QkFBRSxNQUFNLElBQUksQ0FBQ0EsT0FBTzs0QkFBRSxJQUFJLENBQUNrQixJQUFJLENBQUN0OEIsQ0FBQzs0QkFBRSxJQUFJLENBQUNzOEIsSUFBSSxDQUFDdmYsRUFBRSxDQUFDa0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNxYyxJQUFJLENBQUN2ZixFQUFFLENBQUNvRCxDQUFDOzRCQUFFLElBQUksQ0FBQ21jLElBQUksQ0FBQ3JmLEVBQUUsQ0FBQ2dELENBQUM7NEJBQUUsSUFBSSxDQUFDcWMsSUFBSSxDQUFDcmYsRUFBRSxDQUFDa0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNvYyxJQUFJLENBQUN2OEIsQ0FBQzs0QkFBRSxJQUFJLENBQUN1OEIsSUFBSSxDQUFDeGYsRUFBRSxDQUFDa0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNzYyxJQUFJLENBQUN4ZixFQUFFLENBQUNvRCxDQUFDOzRCQUFFLElBQUksQ0FBQ29jLElBQUksQ0FBQ3RmLEVBQUUsQ0FBQ2dELENBQUM7NEJBQUUsSUFBSSxDQUFDc2MsSUFBSSxDQUFDdGYsRUFBRSxDQUFDa0QsQ0FBQzt5QkFBRSxDQUFDMlksUUFBUTtvQkFDcE0sT0FBTyxJQUFJLElBQUksQ0FBQ3NDLE9BQU8sSUFBSSxHQUFHO3dCQUMxQixPQUFPOzRCQUFFLE1BQU0sSUFBSSxDQUFDQSxPQUFPOzRCQUFFLElBQUksQ0FBQ2tCLElBQUksQ0FBQ3Q4QixDQUFDOzRCQUFFLElBQUksQ0FBQ3M4QixJQUFJLENBQUN2ZixFQUFFLENBQUNrRCxDQUFDOzRCQUFFLElBQUksQ0FBQ3FjLElBQUksQ0FBQ3ZmLEVBQUUsQ0FBQ29ELENBQUM7NEJBQUUsSUFBSSxDQUFDbWMsSUFBSSxDQUFDcmYsRUFBRSxDQUFDZ0QsQ0FBQzs0QkFBRSxJQUFJLENBQUNxYyxJQUFJLENBQUNyZixFQUFFLENBQUNrRCxDQUFDO3lCQUFFLENBQUMyWSxRQUFRO29CQUN2SCxPQUFPO3dCQUNILE9BQU8sTUFBTSxJQUFJLENBQUNzQyxPQUFPO29CQUM3QjtnQkFDSjtnQkFFQSxxQ0FBcUM7Z0JBQ3JDWCxRQUFRanpCLFNBQVMsQ0FBQ2t6QixTQUFTLEdBQUcsU0FBU3pKLEtBQUssRUFBRWpCLE1BQU0sRUFBRWMsVUFBVSxFQUFFYixNQUFNLEVBQUVjLFVBQVU7b0JBQ2hGOXRCLFdBQVdFLFFBQU80QixNQUFNLENBQUNrc0IsTUFBTUUsS0FBSyxJQUFJO29CQUN4Qyx3QkFBd0I7b0JBQ3hCLElBQUksQ0FBQ2lLLE9BQU8sR0FBR25LLE1BQU1FLEtBQUs7b0JBQzFCLElBQUssSUFBSWp4QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDazdCLE9BQU8sRUFBRSxFQUFFbDdCLEVBQUc7d0JBQ25DLElBQUlnTSxJQUFJLElBQUksQ0FBQzB1QixHQUFHLENBQUMxNkIsRUFBRTt3QkFDbkJnTSxFQUFFcUYsTUFBTSxHQUFHMGYsTUFBTTFmLE1BQU0sQ0FBQ3JSLEVBQUU7d0JBQzFCZ00sRUFBRXVGLE1BQU0sR0FBR3dmLE1BQU14ZixNQUFNLENBQUN2UixFQUFFO3dCQUMxQixJQUFJdzhCLFVBQVUxTSxPQUFPMkwsU0FBUyxDQUFDenZCLEVBQUVxRixNQUFNO3dCQUN2QyxJQUFJb3JCLFVBQVUxTSxPQUFPMEwsU0FBUyxDQUFDenZCLEVBQUV1RixNQUFNO3dCQUN2Q3ZGLEVBQUU2USxFQUFFLEdBQUdqYyxVQUFVNk8sT0FBTyxDQUFDbWhCLFlBQVk0TDt3QkFDckN4d0IsRUFBRStRLEVBQUUsR0FBR25jLFVBQVU2TyxPQUFPLENBQUNvaEIsWUFBWTRMO3dCQUNyQ3p3QixFQUFFSSxDQUFDLEdBQUc1TCxLQUFLaUwsR0FBRyxDQUFDTyxFQUFFK1EsRUFBRSxFQUFFL1EsRUFBRTZRLEVBQUU7d0JBQ3pCN1EsRUFBRWxNLENBQUMsR0FBRztvQkFDVjtvQkFDQSx3RUFBd0U7b0JBQ3hFLHFDQUFxQztvQkFDckMsSUFBSSxJQUFJLENBQUNvN0IsT0FBTyxHQUFHLEdBQUc7d0JBQ2xCLElBQUl3QixVQUFVM0wsTUFBTXNKLE1BQU07d0JBQzFCLElBQUlzQyxVQUFVLElBQUksQ0FBQ0MsU0FBUzt3QkFDNUIsSUFBSUQsVUFBVSxLQUFLRCxXQUFXLElBQUlBLFVBQVVDLFdBQVdBLFVBQVVwOEIsTUFBS3NvQixPQUFPLEVBQUU7NEJBQzNFLHFCQUFxQjs0QkFDckIsSUFBSSxDQUFDcVMsT0FBTyxHQUFHO3dCQUNuQjtvQkFDSjtvQkFDQSxzQ0FBc0M7b0JBQ3RDLElBQUksSUFBSSxDQUFDQSxPQUFPLElBQUksR0FBRzt3QkFDbkIsSUFBSWx2QixJQUFJLElBQUksQ0FBQzB1QixHQUFHLENBQUMsRUFBRTt3QkFDbkIsZ0JBQWdCO3dCQUNoQjF1QixFQUFFcUYsTUFBTSxHQUFHO3dCQUNYckYsRUFBRXVGLE1BQU0sR0FBRzt3QkFDWCxJQUFJaXJCLFVBQVUxTSxPQUFPMkwsU0FBUyxDQUFDO3dCQUMvQixJQUFJZ0IsVUFBVTFNLE9BQU8wTCxTQUFTLENBQUM7d0JBQy9CenZCLEVBQUU2USxFQUFFLEdBQUdqYyxVQUFVNk8sT0FBTyxDQUFDbWhCLFlBQVk0TDt3QkFDckN4d0IsRUFBRStRLEVBQUUsR0FBR25jLFVBQVU2TyxPQUFPLENBQUNvaEIsWUFBWTRMO3dCQUNyQ3p3QixFQUFFSSxDQUFDLEdBQUc1TCxLQUFLaUwsR0FBRyxDQUFDTyxFQUFFK1EsRUFBRSxFQUFFL1EsRUFBRTZRLEVBQUU7d0JBQ3pCN1EsRUFBRWxNLENBQUMsR0FBRzt3QkFDTixJQUFJLENBQUNvN0IsT0FBTyxHQUFHO29CQUNuQjtnQkFDSjtnQkFFQSxpQkFBaUI7Z0JBQ2pCWCxRQUFRanpCLFNBQVMsQ0FBQ3MwQixVQUFVLEdBQUcsU0FBUzdLLEtBQUs7b0JBQ3pDQSxNQUFNc0osTUFBTSxHQUFHLElBQUksQ0FBQ3VDLFNBQVM7b0JBQzdCN0wsTUFBTUUsS0FBSyxHQUFHLElBQUksQ0FBQ2lLLE9BQU87b0JBQzFCLElBQUssSUFBSWw3QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDazdCLE9BQU8sRUFBRSxFQUFFbDdCLEVBQUc7d0JBQ25DK3dCLE1BQU0xZixNQUFNLENBQUNyUixFQUFFLEdBQUcsSUFBSSxDQUFDMDZCLEdBQUcsQ0FBQzE2QixFQUFFLENBQUNxUixNQUFNO3dCQUNwQzBmLE1BQU14ZixNQUFNLENBQUN2UixFQUFFLEdBQUcsSUFBSSxDQUFDMDZCLEdBQUcsQ0FBQzE2QixFQUFFLENBQUN1UixNQUFNO29CQUN4QztnQkFDSjtnQkFFQWdwQixRQUFRanpCLFNBQVMsQ0FBQyt6QixrQkFBa0IsR0FBRztvQkFDbkMsT0FBUSxJQUFJLENBQUNILE9BQU87d0JBQ2xCLEtBQUs7NEJBQ0gsT0FBTzE2QixLQUFLZzdCLEdBQUcsQ0FBQyxJQUFJLENBQUNZLElBQUksQ0FBQ2h3QixDQUFDO3dCQUU3QixLQUFLOzRCQUNIO2dDQUNJLElBQUl5d0IsTUFBTXI4QixLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQzR3QixJQUFJLENBQUNqd0IsQ0FBQyxFQUFFLElBQUksQ0FBQ2d3QixJQUFJLENBQUNod0IsQ0FBQztnQ0FDM0MsSUFBSTB3QixNQUFNdDhCLEtBQUttTCxLQUFLLENBQUNreEIsS0FBS3I4QixLQUFLZzdCLEdBQUcsQ0FBQyxJQUFJLENBQUNZLElBQUksQ0FBQ2h3QixDQUFDO2dDQUM5QyxJQUFJMHdCLE1BQU0sR0FBRztvQ0FDVCx5QkFBeUI7b0NBQ3pCLE9BQU90OEIsS0FBS21MLEtBQUssQ0FBQyxHQUFHa3hCO2dDQUN6QixPQUFPO29DQUNILDBCQUEwQjtvQ0FDMUIsT0FBT3I4QixLQUFLbUwsS0FBSyxDQUFDa3hCLEtBQUs7Z0NBQzNCOzRCQUNKO3dCQUVGOzRCQUNFOTVCLFdBQVdFLFFBQU80QixNQUFNLENBQUM7NEJBQ3pCLE9BQU9yRSxLQUFLc0QsSUFBSTtvQkFDcEI7Z0JBQ0o7Z0JBRUF5MkIsUUFBUWp6QixTQUFTLENBQUM4ekIsZUFBZSxHQUFHO29CQUNoQyxPQUFRLElBQUksQ0FBQ0YsT0FBTzt3QkFDbEIsS0FBSzs0QkFDSG40QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDOzRCQUN6QixPQUFPckUsS0FBS3NELElBQUk7d0JBRWxCLEtBQUs7NEJBQ0gsT0FBT3RELEtBQUt5RixLQUFLLENBQUMsSUFBSSxDQUFDbTJCLElBQUksQ0FBQ2h3QixDQUFDO3dCQUUvQixLQUFLOzRCQUNILE9BQU81TCxLQUFLNmtCLE9BQU8sQ0FBQyxJQUFJLENBQUMrVyxJQUFJLENBQUN0OEIsQ0FBQyxFQUFFLElBQUksQ0FBQ3M4QixJQUFJLENBQUNod0IsQ0FBQyxFQUFFLElBQUksQ0FBQ2l3QixJQUFJLENBQUN2OEIsQ0FBQyxFQUFFLElBQUksQ0FBQ3U4QixJQUFJLENBQUNqd0IsQ0FBQzt3QkFFeEUsS0FBSzs0QkFDSCxPQUFPNUwsS0FBS3NELElBQUk7d0JBRWxCOzRCQUNFZixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDOzRCQUN6QixPQUFPckUsS0FBS3NELElBQUk7b0JBQ3BCO2dCQUNKO2dCQUVBeTJCLFFBQVFqekIsU0FBUyxDQUFDcTBCLGdCQUFnQixHQUFHLFNBQVNvQixFQUFFLEVBQUVDLEVBQUU7b0JBQ2hELE9BQVEsSUFBSSxDQUFDOUIsT0FBTzt3QkFDbEIsS0FBSzs0QkFDSG40QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDOzRCQUN6Qjt3QkFFRixLQUFLOzRCQUNIazRCLEdBQUd4eUIsR0FBRyxDQUFDLElBQUksQ0FBQzZ4QixJQUFJLENBQUN2ZixFQUFFOzRCQUNuQm1nQixHQUFHenlCLEdBQUcsQ0FBQyxJQUFJLENBQUM2eEIsSUFBSSxDQUFDcmYsRUFBRTs0QkFDbkI7d0JBRUYsS0FBSzs0QkFDSGdnQixHQUFHL2YsVUFBVSxDQUFDLElBQUksQ0FBQ29mLElBQUksQ0FBQ3Q4QixDQUFDLEVBQUUsSUFBSSxDQUFDczhCLElBQUksQ0FBQ3ZmLEVBQUUsRUFBRSxJQUFJLENBQUN3ZixJQUFJLENBQUN2OEIsQ0FBQyxFQUFFLElBQUksQ0FBQ3U4QixJQUFJLENBQUN4ZixFQUFFOzRCQUNsRW1nQixHQUFHaGdCLFVBQVUsQ0FBQyxJQUFJLENBQUNvZixJQUFJLENBQUN0OEIsQ0FBQyxFQUFFLElBQUksQ0FBQ3M4QixJQUFJLENBQUNyZixFQUFFLEVBQUUsSUFBSSxDQUFDc2YsSUFBSSxDQUFDdjhCLENBQUMsRUFBRSxJQUFJLENBQUN1OEIsSUFBSSxDQUFDdGYsRUFBRTs0QkFDbEU7d0JBRUYsS0FBSzs0QkFDSGdnQixHQUFHL2YsVUFBVSxDQUFDLElBQUksQ0FBQ29mLElBQUksQ0FBQ3Q4QixDQUFDLEVBQUUsSUFBSSxDQUFDczhCLElBQUksQ0FBQ3ZmLEVBQUUsRUFBRSxJQUFJLENBQUN3ZixJQUFJLENBQUN2OEIsQ0FBQyxFQUFFLElBQUksQ0FBQ3U4QixJQUFJLENBQUN4ZixFQUFFOzRCQUNsRWtnQixHQUFHMXZCLE1BQU0sQ0FBQyxJQUFJLENBQUNpdkIsSUFBSSxDQUFDeDhCLENBQUMsRUFBRSxJQUFJLENBQUN3OEIsSUFBSSxDQUFDemYsRUFBRTs0QkFDbkNtZ0IsR0FBR3p5QixHQUFHLENBQUN3eUI7NEJBQ1A7d0JBRUY7NEJBQ0VoNkIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzs0QkFDekI7b0JBQ0o7Z0JBQ0o7Z0JBRUEwMUIsUUFBUWp6QixTQUFTLENBQUNzMUIsU0FBUyxHQUFHO29CQUMxQixPQUFRLElBQUksQ0FBQzFCLE9BQU87d0JBQ2xCLEtBQUs7NEJBQ0huNEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzs0QkFDekIsT0FBTzt3QkFFVCxLQUFLOzRCQUNILE9BQU87d0JBRVQsS0FBSzs0QkFDSCxPQUFPckUsS0FBS3d3QixRQUFRLENBQUMsSUFBSSxDQUFDb0wsSUFBSSxDQUFDaHdCLENBQUMsRUFBRSxJQUFJLENBQUNpd0IsSUFBSSxDQUFDandCLENBQUM7d0JBRS9DLEtBQUs7NEJBQ0gsT0FBTzVMLEtBQUttTCxLQUFLLENBQUNuTCxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQzR3QixJQUFJLENBQUNqd0IsQ0FBQyxFQUFFLElBQUksQ0FBQ2d3QixJQUFJLENBQUNod0IsQ0FBQyxHQUFHNUwsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUM2d0IsSUFBSSxDQUFDbHdCLENBQUMsRUFBRSxJQUFJLENBQUNnd0IsSUFBSSxDQUFDaHdCLENBQUM7d0JBRXpGOzRCQUNFckosV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzs0QkFDekIsT0FBTztvQkFDWDtnQkFDSjtnQkFFQTAxQixRQUFRanpCLFNBQVMsQ0FBQzZ6QixLQUFLLEdBQUc7b0JBQ3RCLE9BQVEsSUFBSSxDQUFDRCxPQUFPO3dCQUNsQixLQUFLOzRCQUNIO3dCQUVGLEtBQUs7NEJBQ0gsSUFBSSxDQUFDK0IsTUFBTTs0QkFDWDt3QkFFRixLQUFLOzRCQUNILElBQUksQ0FBQ0MsTUFBTTs0QkFDWDt3QkFFRjs0QkFDRW42QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDO29CQUM3QjtnQkFDSjtnQkFFQSxzREFBc0Q7Z0JBQ3RELEVBQUU7Z0JBQ0Ysd0JBQXdCO2dCQUN4QixjQUFjO2dCQUNkLEVBQUU7Z0JBQ0YsaUVBQWlFO2dCQUNqRSw2QkFBNkI7Z0JBQzdCLGdCQUFnQjtnQkFDaEIsZ0JBQWdCO2dCQUNoQix3Q0FBd0M7Z0JBQ3hDLEVBQUU7Z0JBQ0YsdUJBQXVCO2dCQUN2QixtQkFBbUI7Z0JBQ25CLDRCQUE0QjtnQkFDNUIsRUFBRTtnQkFDRixTQUFTO2dCQUNULHVCQUF1QjtnQkFDdkIsd0JBQXdCO2dCQUN4QixzQkFBc0I7Z0JBQ3RCLEVBQUU7Z0JBQ0YsV0FBVztnQkFDWCxtQkFBbUI7Z0JBQ25CLG1CQUFtQjtnQkFDbkIwMUIsUUFBUWp6QixTQUFTLENBQUMyMUIsTUFBTSxHQUFHO29CQUN2QixJQUFJRSxLQUFLLElBQUksQ0FBQ2YsSUFBSSxDQUFDaHdCLENBQUM7b0JBQ3BCLElBQUlneEIsS0FBSyxJQUFJLENBQUNmLElBQUksQ0FBQ2p3QixDQUFDO29CQUNwQixJQUFJeXdCLE1BQU1yOEIsS0FBS2lMLEdBQUcsQ0FBQzJ4QixJQUFJRDtvQkFDdkIsWUFBWTtvQkFDWixJQUFJRSxRQUFRLENBQUM3OEIsS0FBS3lMLEdBQUcsQ0FBQ2t4QixJQUFJTjtvQkFDMUIsSUFBSVEsU0FBUyxHQUFHO3dCQUNaLCtCQUErQjt3QkFDL0IsSUFBSSxDQUFDakIsSUFBSSxDQUFDdDhCLENBQUMsR0FBRzt3QkFDZCxJQUFJLENBQUNvN0IsT0FBTyxHQUFHO3dCQUNmO29CQUNKO29CQUNBLFlBQVk7b0JBQ1osSUFBSW9DLFFBQVE5OEIsS0FBS3lMLEdBQUcsQ0FBQ214QixJQUFJUDtvQkFDekIsSUFBSVMsU0FBUyxHQUFHO3dCQUNaLCtCQUErQjt3QkFDL0IsSUFBSSxDQUFDakIsSUFBSSxDQUFDdjhCLENBQUMsR0FBRzt3QkFDZCxJQUFJLENBQUNvN0IsT0FBTyxHQUFHO3dCQUNmLElBQUksQ0FBQ2tCLElBQUksQ0FBQzd4QixHQUFHLENBQUMsSUFBSSxDQUFDOHhCLElBQUk7d0JBQ3ZCO29CQUNKO29CQUNBLHlCQUF5QjtvQkFDekIsSUFBSWtCLFVBQVUsSUFBS0QsQ0FBQUEsUUFBUUQsS0FBSTtvQkFDL0IsSUFBSSxDQUFDakIsSUFBSSxDQUFDdDhCLENBQUMsR0FBR3c5QixRQUFRQztvQkFDdEIsSUFBSSxDQUFDbEIsSUFBSSxDQUFDdjhCLENBQUMsR0FBR3U5QixRQUFRRTtvQkFDdEIsSUFBSSxDQUFDckMsT0FBTyxHQUFHO2dCQUNuQjtnQkFFQSxvQkFBb0I7Z0JBQ3BCLGNBQWM7Z0JBQ2QsNkJBQTZCO2dCQUM3Qiw2QkFBNkI7Z0JBQzdCLHdCQUF3QjtnQkFDeEJYLFFBQVFqekIsU0FBUyxDQUFDNDFCLE1BQU0sR0FBRztvQkFDdkIsSUFBSUMsS0FBSyxJQUFJLENBQUNmLElBQUksQ0FBQ2h3QixDQUFDO29CQUNwQixJQUFJZ3hCLEtBQUssSUFBSSxDQUFDZixJQUFJLENBQUNqd0IsQ0FBQztvQkFDcEIsSUFBSW94QixLQUFLLElBQUksQ0FBQ2xCLElBQUksQ0FBQ2x3QixDQUFDO29CQUNwQixTQUFTO29CQUNULG1CQUFtQjtvQkFDbkIsNEJBQTRCO29CQUM1QixTQUFTO29CQUNULElBQUl5d0IsTUFBTXI4QixLQUFLaUwsR0FBRyxDQUFDMnhCLElBQUlEO29CQUN2QixJQUFJTSxRQUFRajlCLEtBQUt5TCxHQUFHLENBQUNreEIsSUFBSU47b0JBQ3pCLElBQUlhLFFBQVFsOUIsS0FBS3lMLEdBQUcsQ0FBQ214QixJQUFJUDtvQkFDekIsSUFBSVMsUUFBUUk7b0JBQ1osSUFBSUwsUUFBUSxDQUFDSTtvQkFDYixTQUFTO29CQUNULG1CQUFtQjtvQkFDbkIsNEJBQTRCO29CQUM1QixTQUFTO29CQUNULElBQUlFLE1BQU1uOUIsS0FBS2lMLEdBQUcsQ0FBQyt4QixJQUFJTDtvQkFDdkIsSUFBSVMsUUFBUXA5QixLQUFLeUwsR0FBRyxDQUFDa3hCLElBQUlRO29CQUN6QixJQUFJRSxRQUFRcjlCLEtBQUt5TCxHQUFHLENBQUN1eEIsSUFBSUc7b0JBQ3pCLElBQUlHLFFBQVFEO29CQUNaLElBQUlFLFFBQVEsQ0FBQ0g7b0JBQ2IsU0FBUztvQkFDVCxtQkFBbUI7b0JBQ25CLDRCQUE0QjtvQkFDNUIsU0FBUztvQkFDVCxJQUFJSSxNQUFNeDlCLEtBQUtpTCxHQUFHLENBQUMreEIsSUFBSUo7b0JBQ3ZCLE9BQU87b0JBQ1AsSUFBSWEsUUFBUXo5QixLQUFLeUwsR0FBRyxDQUFDbXhCLElBQUlZO29CQUN6QixJQUFJRSxRQUFRMTlCLEtBQUt5TCxHQUFHLENBQUN1eEIsSUFBSVE7b0JBQ3pCLElBQUlHLFFBQVFEO29CQUNaLElBQUlFLFFBQVEsQ0FBQ0g7b0JBQ2IsY0FBYztvQkFDZCxJQUFJSSxPQUFPNzlCLEtBQUttTCxLQUFLLENBQUNreEIsS0FBS2M7b0JBQzNCLElBQUlXLFNBQVNELE9BQU83OUIsS0FBS21MLEtBQUssQ0FBQ3l4QixJQUFJSTtvQkFDbkMsSUFBSWUsU0FBU0YsT0FBTzc5QixLQUFLbUwsS0FBSyxDQUFDNnhCLElBQUlMO29CQUNuQyxJQUFJcUIsU0FBU0gsT0FBTzc5QixLQUFLbUwsS0FBSyxDQUFDd3hCLElBQUlDO29CQUNuQyxZQUFZO29CQUNaLElBQUlDLFNBQVMsS0FBS1UsU0FBUyxHQUFHO3dCQUMxQixJQUFJLENBQUMzQixJQUFJLENBQUN0OEIsQ0FBQyxHQUFHO3dCQUNkLElBQUksQ0FBQ283QixPQUFPLEdBQUc7d0JBQ2Y7b0JBQ0o7b0JBQ0EsTUFBTTtvQkFDTixJQUFJb0MsUUFBUSxLQUFLRCxRQUFRLEtBQUttQixVQUFVLEdBQUc7d0JBQ3ZDLElBQUlqQixVQUFVLElBQUtELENBQUFBLFFBQVFELEtBQUk7d0JBQy9CLElBQUksQ0FBQ2pCLElBQUksQ0FBQ3Q4QixDQUFDLEdBQUd3OUIsUUFBUUM7d0JBQ3RCLElBQUksQ0FBQ2xCLElBQUksQ0FBQ3Y4QixDQUFDLEdBQUd1OUIsUUFBUUU7d0JBQ3RCLElBQUksQ0FBQ3JDLE9BQU8sR0FBRzt3QkFDZjtvQkFDSjtvQkFDQSxNQUFNO29CQUNOLElBQUk0QyxRQUFRLEtBQUtDLFFBQVEsS0FBS1EsVUFBVSxHQUFHO3dCQUN2QyxJQUFJRSxVQUFVLElBQUtYLENBQUFBLFFBQVFDLEtBQUk7d0JBQy9CLElBQUksQ0FBQzNCLElBQUksQ0FBQ3Q4QixDQUFDLEdBQUdnK0IsUUFBUVc7d0JBQ3RCLElBQUksQ0FBQ25DLElBQUksQ0FBQ3g4QixDQUFDLEdBQUdpK0IsUUFBUVU7d0JBQ3RCLElBQUksQ0FBQ3ZELE9BQU8sR0FBRzt3QkFDZixJQUFJLENBQUNtQixJQUFJLENBQUM5eEIsR0FBRyxDQUFDLElBQUksQ0FBQyt4QixJQUFJO3dCQUN2QjtvQkFDSjtvQkFDQSxZQUFZO29CQUNaLElBQUlnQixTQUFTLEtBQUtjLFNBQVMsR0FBRzt3QkFDMUIsSUFBSSxDQUFDL0IsSUFBSSxDQUFDdjhCLENBQUMsR0FBRzt3QkFDZCxJQUFJLENBQUNvN0IsT0FBTyxHQUFHO3dCQUNmLElBQUksQ0FBQ2tCLElBQUksQ0FBQzd4QixHQUFHLENBQUMsSUFBSSxDQUFDOHhCLElBQUk7d0JBQ3ZCO29CQUNKO29CQUNBLFlBQVk7b0JBQ1osSUFBSXlCLFNBQVMsS0FBS0ssU0FBUyxHQUFHO3dCQUMxQixJQUFJLENBQUM3QixJQUFJLENBQUN4OEIsQ0FBQyxHQUFHO3dCQUNkLElBQUksQ0FBQ283QixPQUFPLEdBQUc7d0JBQ2YsSUFBSSxDQUFDa0IsSUFBSSxDQUFDN3hCLEdBQUcsQ0FBQyxJQUFJLENBQUMreEIsSUFBSTt3QkFDdkI7b0JBQ0o7b0JBQ0EsTUFBTTtvQkFDTixJQUFJNkIsUUFBUSxLQUFLQyxRQUFRLEtBQUtFLFVBQVUsR0FBRzt3QkFDdkMsSUFBSUksVUFBVSxJQUFLUCxDQUFBQSxRQUFRQyxLQUFJO3dCQUMvQixJQUFJLENBQUMvQixJQUFJLENBQUN2OEIsQ0FBQyxHQUFHcStCLFFBQVFPO3dCQUN0QixJQUFJLENBQUNwQyxJQUFJLENBQUN4OEIsQ0FBQyxHQUFHcytCLFFBQVFNO3dCQUN0QixJQUFJLENBQUN4RCxPQUFPLEdBQUc7d0JBQ2YsSUFBSSxDQUFDa0IsSUFBSSxDQUFDN3hCLEdBQUcsQ0FBQyxJQUFJLENBQUMreEIsSUFBSTt3QkFDdkI7b0JBQ0o7b0JBQ0EseUJBQXlCO29CQUN6QixJQUFJcUMsV0FBVyxJQUFLTCxDQUFBQSxTQUFTQyxTQUFTQyxNQUFLO29CQUMzQyxJQUFJLENBQUNwQyxJQUFJLENBQUN0OEIsQ0FBQyxHQUFHdytCLFNBQVNLO29CQUN2QixJQUFJLENBQUN0QyxJQUFJLENBQUN2OEIsQ0FBQyxHQUFHeStCLFNBQVNJO29CQUN2QixJQUFJLENBQUNyQyxJQUFJLENBQUN4OEIsQ0FBQyxHQUFHMCtCLFNBQVNHO29CQUN2QixJQUFJLENBQUN6RCxPQUFPLEdBQUc7Z0JBQ25CO2dCQUVBOztDQUVDLEdBQ0R6NEIsU0FBUzBVLFdBQVcsR0FBRyxTQUFTeEQsTUFBTSxFQUFFdEMsTUFBTSxFQUFFd0MsTUFBTSxFQUFFdEMsTUFBTSxFQUFFaUYsR0FBRyxFQUFFQyxHQUFHO29CQUNwRSxJQUFJaU8sUUFBUSxJQUFJc0g7b0JBQ2hCdEgsTUFBTW9MLE1BQU0sQ0FBQ3ZsQixHQUFHLENBQUNvSixRQUFRdEM7b0JBQ3pCcVQsTUFBTXFMLE1BQU0sQ0FBQ3hsQixHQUFHLENBQUNzSixRQUFRdEM7b0JBQ3pCbVQsTUFBTWtNLFVBQVUsR0FBR3BhO29CQUNuQmtPLE1BQU1tTSxVQUFVLEdBQUdwYTtvQkFDbkJpTyxNQUFNb00sUUFBUSxHQUFHO29CQUNqQixJQUFJQyxRQUFRLElBQUkzRTtvQkFDaEIsSUFBSTNILFNBQVMsSUFBSXdIO29CQUNqQnhwQixTQUFTZ2lCLFFBQVFzTSxPQUFPck07b0JBQ3hCLE9BQU9ELE9BQU91TSxRQUFRLEdBQUcsS0FBS3p3QixNQUFLc29CLE9BQU87Z0JBQzlDO1lBR0E7WUFBRTtnQkFBQyxlQUFjO2dCQUFFLG1CQUFrQjtnQkFBRyxtQkFBa0I7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsbUJBQWtCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxtQkFBa0I7Z0JBQUcsa0JBQWlCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTOW9CLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN4VCxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJSixXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSWtELFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJa1EsT0FBT2xRLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUllLE9BQU9mLFNBQVE7Z0JBRW5CZixRQUFPRCxPQUFPLEdBQUc0RDtnQkFFakIsSUFBSWk4QixXQUFXLElBQUkzdUIsS0FBSztvQkFDcEJ3UyxRQUFRO3dCQUNKLE9BQU8sSUFBSTNoQjtvQkFDZjtvQkFDQXFpQixTQUFTLFNBQVNRLElBQUk7d0JBQ2xCQSxLQUFLNFMsVUFBVSxDQUFDN3RCLE9BQU87d0JBQ3ZCaWIsS0FBSzZTLFVBQVUsQ0FBQzl0QixPQUFPO29CQUMzQjtnQkFDSjtnQkFFQSxJQUFJbTJCLFdBQVcsSUFBSTV1QixLQUFLO29CQUNwQndTLFFBQVE7d0JBQ0osT0FBTyxJQUFJcWM7b0JBQ2Y7Z0JBQ0o7Z0JBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQSxTQUFTdm5CLEVBQUU7b0JBQ2hCLElBQUksQ0FBQ0EsRUFBRSxHQUFHQTtvQkFDVixJQUFJLENBQUNvTSxJQUFJLEdBQUcsSUFBSTdpQjtvQkFDaEIsSUFBSSxDQUFDNEQsUUFBUSxHQUFHO29CQUNoQixJQUFJLENBQUNxNkIsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7b0JBQ2YsSUFBSSxDQUFDdEcsUUFBUSxHQUFHO3dCQUNaLE9BQU8sSUFBSSxDQUFDcmhCLEVBQUUsR0FBRyxPQUFPLElBQUksQ0FBQzdTLFFBQVE7b0JBQ3pDO2dCQUNKO2dCQUVBbzZCLFNBQVN4M0IsU0FBUyxDQUFDNjNCLE1BQU0sR0FBRztvQkFDeEIsT0FBTyxJQUFJLENBQUNILE1BQU0sSUFBSTtnQkFDMUI7Z0JBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNyOEI7b0JBQ0wsSUFBSSxDQUFDeThCLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDO29CQUNoQixJQUFJLENBQUNDLGFBQWEsR0FBRztnQkFDekI7Z0JBRUE7Ozs7Q0FJQyxHQUNEMzhCLFlBQVkyRSxTQUFTLENBQUNPLFdBQVcsR0FBRyxTQUFTMFAsRUFBRTtvQkFDM0MsSUFBSXJJLE9BQU8sSUFBSSxDQUFDbXdCLE9BQU8sQ0FBQzluQixHQUFHO29CQUMzQnhVLFdBQVdFLFFBQU80QixNQUFNLENBQUMsQ0FBQyxDQUFDcUs7b0JBQzNCLE9BQU9BLEtBQUt4SyxRQUFRO2dCQUN4QjtnQkFFQTs7OztDQUlDLEdBQ0QvQixZQUFZMkUsU0FBUyxDQUFDNHhCLFVBQVUsR0FBRyxTQUFTM2hCLEVBQUU7b0JBQzFDLElBQUlySSxPQUFPLElBQUksQ0FBQ213QixPQUFPLENBQUM5bkIsR0FBRztvQkFDM0J4VSxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLENBQUMsQ0FBQ3FLO29CQUMzQixPQUFPQSxLQUFLeVUsSUFBSTtnQkFDcEI7Z0JBRUFoaEIsWUFBWTJFLFNBQVMsQ0FBQ2k0QixZQUFZLEdBQUc7b0JBQ2pDLElBQUlyd0IsT0FBTzJ2QixTQUFTN2IsUUFBUTtvQkFDNUI5VCxLQUFLcUksRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDK25CLGFBQWE7b0JBQzlCcHdCLEtBQUt4SyxRQUFRLEdBQUc7b0JBQ2hCd0ssS0FBSzZ2QixNQUFNLEdBQUc7b0JBQ2Q3dkIsS0FBSzh2QixNQUFNLEdBQUc7b0JBQ2Q5dkIsS0FBSyt2QixNQUFNLEdBQUc7b0JBQ2QvdkIsS0FBS2d3QixNQUFNLEdBQUcsQ0FBQztvQkFDZixJQUFJLENBQUNHLE9BQU8sQ0FBQ253QixLQUFLcUksRUFBRSxDQUFDLEdBQUdySTtvQkFDeEIsT0FBT0E7Z0JBQ1g7Z0JBRUF2TSxZQUFZMkUsU0FBUyxDQUFDazRCLFFBQVEsR0FBRyxTQUFTdHdCLElBQUk7b0JBQzFDMnZCLFNBQVMxYixPQUFPLENBQUNqVTtvQkFDakJBLEtBQUtnd0IsTUFBTSxHQUFHLENBQUM7b0JBQ2YsT0FBTyxJQUFJLENBQUNHLE9BQU8sQ0FBQ253QixLQUFLcUksRUFBRSxDQUFDO2dCQUNoQztnQkFFQTs7Ozs7Q0FLQyxHQUNENVUsWUFBWTJFLFNBQVMsQ0FBQ3lkLFdBQVcsR0FBRyxTQUFTcEIsSUFBSSxFQUFFamYsUUFBUTtvQkFDdkQzQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDL0QsS0FBS2dFLE9BQU8sQ0FBQzZlO29CQUN0QyxJQUFJelUsT0FBTyxJQUFJLENBQUNxd0IsWUFBWTtvQkFDNUJyd0IsS0FBS3lVLElBQUksQ0FBQ3BaLEdBQUcsQ0FBQ29aO29CQUNkLG1CQUFtQjtvQkFDbkJ6VSxLQUFLeVUsSUFBSSxDQUFDOFQsTUFBTSxDQUFDNzBCLFNBQVNxbkIsYUFBYTtvQkFDdkMvYSxLQUFLeEssUUFBUSxHQUFHQTtvQkFDaEJ3SyxLQUFLZ3dCLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNPLFVBQVUsQ0FBQ3Z3QjtvQkFDaEIsT0FBT0EsS0FBS3FJLEVBQUU7Z0JBQ2xCO2dCQUVBOztDQUVDLEdBQ0Q1VSxZQUFZMkUsU0FBUyxDQUFDMGQsWUFBWSxHQUFHLFNBQVN6TixFQUFFO29CQUM1QyxJQUFJckksT0FBTyxJQUFJLENBQUNtd0IsT0FBTyxDQUFDOW5CLEdBQUc7b0JBQzNCeFUsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxDQUFDLENBQUNxSztvQkFDM0JuTSxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDcUssS0FBS2l3QixNQUFNO29CQUNwQyxJQUFJLENBQUNPLFVBQVUsQ0FBQ3h3QjtvQkFDaEIsSUFBSSxDQUFDc3dCLFFBQVEsQ0FBQ3R3QjtnQkFDbEI7Z0JBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNEdk0sWUFBWTJFLFNBQVMsQ0FBQ2llLFNBQVMsR0FBRyxTQUFTaE8sRUFBRSxFQUFFb00sSUFBSSxFQUFFOFMsQ0FBQztvQkFDbEQxekIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQy9ELEtBQUtnRSxPQUFPLENBQUM2ZTtvQkFDdEM1Z0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxDQUFDNHhCLEtBQUtqMkIsS0FBS3NFLE9BQU8sQ0FBQzJ4QjtvQkFDNUMsSUFBSXZuQixPQUFPLElBQUksQ0FBQ213QixPQUFPLENBQUM5bkIsR0FBRztvQkFDM0J4VSxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLENBQUMsQ0FBQ3FLO29CQUMzQm5NLFdBQVdFLFFBQU80QixNQUFNLENBQUNxSyxLQUFLaXdCLE1BQU07b0JBQ3BDLElBQUlqd0IsS0FBS3lVLElBQUksQ0FBQzRULFFBQVEsQ0FBQzVULE9BQU87d0JBQzFCLE9BQU87b0JBQ1g7b0JBQ0EsSUFBSSxDQUFDK2IsVUFBVSxDQUFDeHdCO29CQUNoQkEsS0FBS3lVLElBQUksQ0FBQ3BaLEdBQUcsQ0FBQ29aO29CQUNkLGVBQWU7b0JBQ2ZBLE9BQU96VSxLQUFLeVUsSUFBSTtvQkFDaEI3aUIsS0FBSzIyQixNQUFNLENBQUM5VCxNQUFNL2dCLFNBQVNxbkIsYUFBYTtvQkFDeEMsNkJBQTZCO29CQUM3QiwyREFBMkQ7b0JBQzNELElBQUl3TSxFQUFFMVcsQ0FBQyxHQUFHLEdBQUc7d0JBQ1Q0RCxLQUFLNFMsVUFBVSxDQUFDeFcsQ0FBQyxJQUFJMFcsRUFBRTFXLENBQUMsR0FBR25kLFNBQVNzbkIsY0FBYztvQkFDdEQsT0FBTzt3QkFDSHZHLEtBQUs2UyxVQUFVLENBQUN6VyxDQUFDLElBQUkwVyxFQUFFMVcsQ0FBQyxHQUFHbmQsU0FBU3NuQixjQUFjO29CQUN0RDtvQkFDQSxJQUFJdU0sRUFBRXhXLENBQUMsR0FBRyxHQUFHO3dCQUNUMEQsS0FBSzRTLFVBQVUsQ0FBQ3RXLENBQUMsSUFBSXdXLEVBQUV4VyxDQUFDLEdBQUdyZCxTQUFTc25CLGNBQWM7b0JBQ3RELE9BQU87d0JBQ0h2RyxLQUFLNlMsVUFBVSxDQUFDdlcsQ0FBQyxJQUFJd1csRUFBRXhXLENBQUMsR0FBR3JkLFNBQVNzbkIsY0FBYztvQkFDdEQ7b0JBQ0EsSUFBSSxDQUFDdVYsVUFBVSxDQUFDdndCO29CQUNoQixPQUFPO2dCQUNYO2dCQUVBdk0sWUFBWTJFLFNBQVMsQ0FBQ200QixVQUFVLEdBQUcsU0FBU0UsSUFBSTtvQkFDNUM1OEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQy9ELEtBQUtnRSxPQUFPLENBQUM2NkIsS0FBS2hjLElBQUk7b0JBQy9DLElBQUksSUFBSSxDQUFDeWIsTUFBTSxJQUFJLE1BQU07d0JBQ3JCLElBQUksQ0FBQ0EsTUFBTSxHQUFHTzt3QkFDZCxJQUFJLENBQUNQLE1BQU0sQ0FBQ0wsTUFBTSxHQUFHO3dCQUNyQjtvQkFDSjtvQkFDQSxzQ0FBc0M7b0JBQ3RDLElBQUlhLFdBQVdELEtBQUtoYyxJQUFJO29CQUN4QixJQUFJeVEsUUFBUSxJQUFJLENBQUNnTCxNQUFNO29CQUN2QixNQUFPaEwsTUFBTStLLE1BQU0sTUFBTSxNQUFPO3dCQUM1QixJQUFJSCxTQUFTNUssTUFBTTRLLE1BQU07d0JBQ3pCLElBQUlDLFNBQVM3SyxNQUFNNkssTUFBTTt3QkFDekIsSUFBSVksT0FBT3pMLE1BQU16USxJQUFJLENBQUNrVCxZQUFZO3dCQUNsQyxJQUFJaUosZUFBZWxCLFNBQVM1YixRQUFRO3dCQUNwQzhjLGFBQWF6YSxPQUFPLENBQUMrTyxNQUFNelEsSUFBSSxFQUFFaWM7d0JBQ2pDLElBQUlHLGVBQWVELGFBQWFqSixZQUFZO3dCQUM1QytILFNBQVN6YixPQUFPLENBQUMyYzt3QkFDakIsK0RBQStEO3dCQUMvRCxJQUFJRSxPQUFPLElBQUlEO3dCQUNmLHlEQUF5RDt3QkFDekQsSUFBSUUsa0JBQWtCLElBQUtGLENBQUFBLGVBQWVGLElBQUc7d0JBQzdDLGlDQUFpQzt3QkFDakMsSUFBSUs7d0JBQ0osSUFBSWxCLE9BQU9HLE1BQU0sSUFBSTs0QkFDakIsSUFBSXhiLE9BQU9pYixTQUFTNWIsUUFBUTs0QkFDNUJXLEtBQUswQixPQUFPLENBQUN1YSxVQUFVWixPQUFPcmIsSUFBSTs0QkFDbEN1YyxRQUFRdmMsS0FBS2tULFlBQVksS0FBS29KOzRCQUM5QnJCLFNBQVN6YixPQUFPLENBQUNRO3dCQUNyQixPQUFPOzRCQUNILElBQUlBLE9BQU9pYixTQUFTNWIsUUFBUTs0QkFDNUJXLEtBQUswQixPQUFPLENBQUN1YSxVQUFVWixPQUFPcmIsSUFBSTs0QkFDbEMsSUFBSXdjLFVBQVVuQixPQUFPcmIsSUFBSSxDQUFDa1QsWUFBWTs0QkFDdEMsSUFBSXVKLFVBQVV6YyxLQUFLa1QsWUFBWTs0QkFDL0JxSixRQUFRRSxVQUFVRCxVQUFVRjs0QkFDNUJyQixTQUFTemIsT0FBTyxDQUFDUTt3QkFDckI7d0JBQ0EsaUNBQWlDO3dCQUNqQyxJQUFJMGM7d0JBQ0osSUFBSXBCLE9BQU9FLE1BQU0sSUFBSTs0QkFDakIsSUFBSXhiLE9BQU9pYixTQUFTNWIsUUFBUTs0QkFDNUJXLEtBQUswQixPQUFPLENBQUN1YSxVQUFVWCxPQUFPdGIsSUFBSTs0QkFDbEMwYyxRQUFRMWMsS0FBS2tULFlBQVksS0FBS29KOzRCQUM5QnJCLFNBQVN6YixPQUFPLENBQUNRO3dCQUNyQixPQUFPOzRCQUNILElBQUlBLE9BQU9pYixTQUFTNWIsUUFBUTs0QkFDNUJXLEtBQUswQixPQUFPLENBQUN1YSxVQUFVWCxPQUFPdGIsSUFBSTs0QkFDbEMsSUFBSXdjLFVBQVVsQixPQUFPdGIsSUFBSSxDQUFDa1QsWUFBWTs0QkFDdEMsSUFBSXVKLFVBQVV6YyxLQUFLa1QsWUFBWTs0QkFDL0J3SixRQUFRRCxVQUFVRCxVQUFVRjs0QkFDNUJyQixTQUFTemIsT0FBTyxDQUFDUTt3QkFDckI7d0JBQ0EseUNBQXlDO3dCQUN6QyxJQUFJcWMsT0FBT0UsU0FBU0YsT0FBT0ssT0FBTzs0QkFDOUI7d0JBQ0o7d0JBQ0EsVUFBVTt3QkFDVixJQUFJSCxRQUFRRyxPQUFPOzRCQUNmak0sUUFBUTRLO3dCQUNaLE9BQU87NEJBQ0g1SyxRQUFRNks7d0JBQ1o7b0JBQ0o7b0JBQ0EsSUFBSXFCLFVBQVVsTTtvQkFDZCx1QkFBdUI7b0JBQ3ZCLElBQUltTSxZQUFZRCxRQUFRdkIsTUFBTTtvQkFDOUIsSUFBSXlCLFlBQVksSUFBSSxDQUFDakIsWUFBWTtvQkFDakNpQixVQUFVekIsTUFBTSxHQUFHd0I7b0JBQ25CQyxVQUFVOTdCLFFBQVEsR0FBRztvQkFDckI4N0IsVUFBVTdjLElBQUksQ0FBQzBCLE9BQU8sQ0FBQ3VhLFVBQVVVLFFBQVEzYyxJQUFJO29CQUM3QzZjLFVBQVV0QixNQUFNLEdBQUdvQixRQUFRcEIsTUFBTSxHQUFHO29CQUNwQyxJQUFJcUIsYUFBYSxNQUFNO3dCQUNuQixnQ0FBZ0M7d0JBQ2hDLElBQUlBLFVBQVV2QixNQUFNLElBQUlzQixTQUFTOzRCQUM3QkMsVUFBVXZCLE1BQU0sR0FBR3dCO3dCQUN2QixPQUFPOzRCQUNIRCxVQUFVdEIsTUFBTSxHQUFHdUI7d0JBQ3ZCO3dCQUNBQSxVQUFVeEIsTUFBTSxHQUFHc0I7d0JBQ25CRSxVQUFVdkIsTUFBTSxHQUFHVTt3QkFDbkJXLFFBQVF2QixNQUFNLEdBQUd5Qjt3QkFDakJiLEtBQUtaLE1BQU0sR0FBR3lCO29CQUNsQixPQUFPO3dCQUNILDRCQUE0Qjt3QkFDNUJBLFVBQVV4QixNQUFNLEdBQUdzQjt3QkFDbkJFLFVBQVV2QixNQUFNLEdBQUdVO3dCQUNuQlcsUUFBUXZCLE1BQU0sR0FBR3lCO3dCQUNqQmIsS0FBS1osTUFBTSxHQUFHeUI7d0JBQ2QsSUFBSSxDQUFDcEIsTUFBTSxHQUFHb0I7b0JBQ2xCO29CQUNBLGlEQUFpRDtvQkFDakRwTSxRQUFRdUwsS0FBS1osTUFBTTtvQkFDbkIsTUFBTzNLLFNBQVMsS0FBTTt3QkFDbEJBLFFBQVEsSUFBSSxDQUFDcU0sT0FBTyxDQUFDck07d0JBQ3JCLElBQUk0SyxTQUFTNUssTUFBTTRLLE1BQU07d0JBQ3pCLElBQUlDLFNBQVM3SyxNQUFNNkssTUFBTTt3QkFDekJsOEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ202QixVQUFVO3dCQUNuQ2o4QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDbzZCLFVBQVU7d0JBQ25DN0ssTUFBTThLLE1BQU0sR0FBRyxJQUFJMytCLE1BQUtzZ0IsR0FBRyxDQUFDbWUsT0FBT0UsTUFBTSxFQUFFRCxPQUFPQyxNQUFNO3dCQUN4RDlLLE1BQU16USxJQUFJLENBQUMwQixPQUFPLENBQUMyWixPQUFPcmIsSUFBSSxFQUFFc2IsT0FBT3RiLElBQUk7d0JBQzNDeVEsUUFBUUEsTUFBTTJLLE1BQU07b0JBQ3hCO2dCQUNKO2dCQUVBcDhCLFlBQVkyRSxTQUFTLENBQUNvNEIsVUFBVSxHQUFHLFNBQVNDLElBQUk7b0JBQzVDLElBQUlBLFFBQVEsSUFBSSxDQUFDUCxNQUFNLEVBQUU7d0JBQ3JCLElBQUksQ0FBQ0EsTUFBTSxHQUFHO3dCQUNkO29CQUNKO29CQUNBLElBQUlMLFNBQVNZLEtBQUtaLE1BQU07b0JBQ3hCLElBQUkyQixjQUFjM0IsT0FBT0EsTUFBTTtvQkFDL0IsSUFBSXVCO29CQUNKLElBQUl2QixPQUFPQyxNQUFNLElBQUlXLE1BQU07d0JBQ3ZCVyxVQUFVdkIsT0FBT0UsTUFBTTtvQkFDM0IsT0FBTzt3QkFDSHFCLFVBQVV2QixPQUFPQyxNQUFNO29CQUMzQjtvQkFDQSxJQUFJMEIsZUFBZSxNQUFNO3dCQUNyQixxREFBcUQ7d0JBQ3JELElBQUlBLFlBQVkxQixNQUFNLElBQUlELFFBQVE7NEJBQzlCMkIsWUFBWTFCLE1BQU0sR0FBR3NCO3dCQUN6QixPQUFPOzRCQUNISSxZQUFZekIsTUFBTSxHQUFHcUI7d0JBQ3pCO3dCQUNBQSxRQUFRdkIsTUFBTSxHQUFHMkI7d0JBQ2pCLElBQUksQ0FBQ2xCLFFBQVEsQ0FBQ1Q7d0JBQ2QsMEJBQTBCO3dCQUMxQixJQUFJM0ssUUFBUXNNO3dCQUNaLE1BQU90TSxTQUFTLEtBQU07NEJBQ2xCQSxRQUFRLElBQUksQ0FBQ3FNLE9BQU8sQ0FBQ3JNOzRCQUNyQixJQUFJNEssU0FBUzVLLE1BQU00SyxNQUFNOzRCQUN6QixJQUFJQyxTQUFTN0ssTUFBTTZLLE1BQU07NEJBQ3pCN0ssTUFBTXpRLElBQUksQ0FBQzBCLE9BQU8sQ0FBQzJaLE9BQU9yYixJQUFJLEVBQUVzYixPQUFPdGIsSUFBSTs0QkFDM0N5USxNQUFNOEssTUFBTSxHQUFHLElBQUkzK0IsTUFBS3NnQixHQUFHLENBQUNtZSxPQUFPRSxNQUFNLEVBQUVELE9BQU9DLE1BQU07NEJBQ3hEOUssUUFBUUEsTUFBTTJLLE1BQU07d0JBQ3hCO29CQUNKLE9BQU87d0JBQ0gsSUFBSSxDQUFDSyxNQUFNLEdBQUdrQjt3QkFDZEEsUUFBUXZCLE1BQU0sR0FBRzt3QkFDakIsSUFBSSxDQUFDUyxRQUFRLENBQUNUO29CQUNsQjtnQkFDSjtnQkFFQTs7O0NBR0MsR0FDRHA4QixZQUFZMkUsU0FBUyxDQUFDbTVCLE9BQU8sR0FBRyxTQUFTL21CLEVBQUU7b0JBQ3ZDM1csV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzZVLE1BQU07b0JBQy9CLElBQUlpbkIsSUFBSWpuQjtvQkFDUixJQUFJaW5CLEVBQUV4QixNQUFNLE1BQU13QixFQUFFekIsTUFBTSxHQUFHLEdBQUc7d0JBQzVCLE9BQU94bEI7b0JBQ1g7b0JBQ0EsSUFBSWtuQixJQUFJRCxFQUFFM0IsTUFBTTtvQkFDaEIsSUFBSTNqQixJQUFJc2xCLEVBQUUxQixNQUFNO29CQUNoQixJQUFJd0IsVUFBVXBsQixFQUFFNmpCLE1BQU0sR0FBRzBCLEVBQUUxQixNQUFNO29CQUNqQyxjQUFjO29CQUNkLElBQUl1QixVQUFVLEdBQUc7d0JBQ2IsSUFBSUksSUFBSXhsQixFQUFFMmpCLE1BQU07d0JBQ2hCLElBQUk4QixJQUFJemxCLEVBQUU0akIsTUFBTTt3QkFDaEIsZUFBZTt3QkFDZjVqQixFQUFFMmpCLE1BQU0sR0FBRzJCO3dCQUNYdGxCLEVBQUUwakIsTUFBTSxHQUFHNEIsRUFBRTVCLE1BQU07d0JBQ25CNEIsRUFBRTVCLE1BQU0sR0FBRzFqQjt3QkFDWCxtQ0FBbUM7d0JBQ25DLElBQUlBLEVBQUUwakIsTUFBTSxJQUFJLE1BQU07NEJBQ2xCLElBQUkxakIsRUFBRTBqQixNQUFNLENBQUNDLE1BQU0sSUFBSXRsQixJQUFJO2dDQUN2QjJCLEVBQUUwakIsTUFBTSxDQUFDQyxNQUFNLEdBQUczakI7NEJBQ3RCLE9BQU87Z0NBQ0hBLEVBQUUwakIsTUFBTSxDQUFDRSxNQUFNLEdBQUc1akI7NEJBQ3RCO3dCQUNKLE9BQU87NEJBQ0gsSUFBSSxDQUFDK2pCLE1BQU0sR0FBRy9qQjt3QkFDbEI7d0JBQ0EsU0FBUzt3QkFDVCxJQUFJd2xCLEVBQUUzQixNQUFNLEdBQUc0QixFQUFFNUIsTUFBTSxFQUFFOzRCQUNyQjdqQixFQUFFNGpCLE1BQU0sR0FBRzRCOzRCQUNYRixFQUFFMUIsTUFBTSxHQUFHNkI7NEJBQ1hBLEVBQUUvQixNQUFNLEdBQUc0Qjs0QkFDWEEsRUFBRWhkLElBQUksQ0FBQzBCLE9BQU8sQ0FBQ3ViLEVBQUVqZCxJQUFJLEVBQUVtZCxFQUFFbmQsSUFBSTs0QkFDN0J0SSxFQUFFc0ksSUFBSSxDQUFDMEIsT0FBTyxDQUFDc2IsRUFBRWhkLElBQUksRUFBRWtkLEVBQUVsZCxJQUFJOzRCQUM3QmdkLEVBQUV6QixNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQytmLEVBQUUxQixNQUFNLEVBQUU0QixFQUFFNUIsTUFBTTs0QkFDMUM3akIsRUFBRTZqQixNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQzhmLEVBQUV6QixNQUFNLEVBQUUyQixFQUFFM0IsTUFBTTt3QkFDOUMsT0FBTzs0QkFDSDdqQixFQUFFNGpCLE1BQU0sR0FBRzZCOzRCQUNYSCxFQUFFMUIsTUFBTSxHQUFHNEI7NEJBQ1hBLEVBQUU5QixNQUFNLEdBQUc0Qjs0QkFDWEEsRUFBRWhkLElBQUksQ0FBQzBCLE9BQU8sQ0FBQ3ViLEVBQUVqZCxJQUFJLEVBQUVrZCxFQUFFbGQsSUFBSTs0QkFDN0J0SSxFQUFFc0ksSUFBSSxDQUFDMEIsT0FBTyxDQUFDc2IsRUFBRWhkLElBQUksRUFBRW1kLEVBQUVuZCxJQUFJOzRCQUM3QmdkLEVBQUV6QixNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQytmLEVBQUUxQixNQUFNLEVBQUUyQixFQUFFM0IsTUFBTTs0QkFDMUM3akIsRUFBRTZqQixNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQzhmLEVBQUV6QixNQUFNLEVBQUU0QixFQUFFNUIsTUFBTTt3QkFDOUM7d0JBQ0EsT0FBTzdqQjtvQkFDWDtvQkFDQSxjQUFjO29CQUNkLElBQUlvbEIsVUFBVSxDQUFDLEdBQUc7d0JBQ2QsSUFBSU0sSUFBSUgsRUFBRTVCLE1BQU07d0JBQ2hCLElBQUlnQyxJQUFJSixFQUFFM0IsTUFBTTt3QkFDaEIsZUFBZTt3QkFDZjJCLEVBQUU1QixNQUFNLEdBQUcyQjt3QkFDWEMsRUFBRTdCLE1BQU0sR0FBRzRCLEVBQUU1QixNQUFNO3dCQUNuQjRCLEVBQUU1QixNQUFNLEdBQUc2Qjt3QkFDWCxtQ0FBbUM7d0JBQ25DLElBQUlBLEVBQUU3QixNQUFNLElBQUksTUFBTTs0QkFDbEIsSUFBSTZCLEVBQUU3QixNQUFNLENBQUNDLE1BQU0sSUFBSTJCLEdBQUc7Z0NBQ3RCQyxFQUFFN0IsTUFBTSxDQUFDQyxNQUFNLEdBQUc0Qjs0QkFDdEIsT0FBTztnQ0FDSEEsRUFBRTdCLE1BQU0sQ0FBQ0UsTUFBTSxHQUFHMkI7NEJBQ3RCO3dCQUNKLE9BQU87NEJBQ0gsSUFBSSxDQUFDeEIsTUFBTSxHQUFHd0I7d0JBQ2xCO3dCQUNBLFNBQVM7d0JBQ1QsSUFBSUcsRUFBRTdCLE1BQU0sR0FBRzhCLEVBQUU5QixNQUFNLEVBQUU7NEJBQ3JCMEIsRUFBRTNCLE1BQU0sR0FBRzhCOzRCQUNYSixFQUFFM0IsTUFBTSxHQUFHZ0M7NEJBQ1hBLEVBQUVqQyxNQUFNLEdBQUc0Qjs0QkFDWEEsRUFBRWhkLElBQUksQ0FBQzBCLE9BQU8sQ0FBQ2hLLEVBQUVzSSxJQUFJLEVBQUVxZCxFQUFFcmQsSUFBSTs0QkFDN0JpZCxFQUFFamQsSUFBSSxDQUFDMEIsT0FBTyxDQUFDc2IsRUFBRWhkLElBQUksRUFBRW9kLEVBQUVwZCxJQUFJOzRCQUM3QmdkLEVBQUV6QixNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQ3hGLEVBQUU2akIsTUFBTSxFQUFFOEIsRUFBRTlCLE1BQU07NEJBQzFDMEIsRUFBRTFCLE1BQU0sR0FBRyxJQUFJMytCLE1BQUtzZ0IsR0FBRyxDQUFDOGYsRUFBRXpCLE1BQU0sRUFBRTZCLEVBQUU3QixNQUFNO3dCQUM5QyxPQUFPOzRCQUNIMEIsRUFBRTNCLE1BQU0sR0FBRytCOzRCQUNYTCxFQUFFM0IsTUFBTSxHQUFHK0I7NEJBQ1hBLEVBQUVoQyxNQUFNLEdBQUc0Qjs0QkFDWEEsRUFBRWhkLElBQUksQ0FBQzBCLE9BQU8sQ0FBQ2hLLEVBQUVzSSxJQUFJLEVBQUVvZCxFQUFFcGQsSUFBSTs0QkFDN0JpZCxFQUFFamQsSUFBSSxDQUFDMEIsT0FBTyxDQUFDc2IsRUFBRWhkLElBQUksRUFBRXFkLEVBQUVyZCxJQUFJOzRCQUM3QmdkLEVBQUV6QixNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQ3hGLEVBQUU2akIsTUFBTSxFQUFFNkIsRUFBRTdCLE1BQU07NEJBQzFDMEIsRUFBRTFCLE1BQU0sR0FBRyxJQUFJMytCLE1BQUtzZ0IsR0FBRyxDQUFDOGYsRUFBRXpCLE1BQU0sRUFBRThCLEVBQUU5QixNQUFNO3dCQUM5Qzt3QkFDQSxPQUFPMEI7b0JBQ1g7b0JBQ0EsT0FBT0Q7Z0JBQ1g7Z0JBRUE7OztDQUdDLEdBQ0RoK0IsWUFBWTJFLFNBQVMsQ0FBQzh4QixTQUFTLEdBQUc7b0JBQzlCLElBQUksSUFBSSxDQUFDZ0csTUFBTSxJQUFJLE1BQU07d0JBQ3JCLE9BQU87b0JBQ1g7b0JBQ0EsT0FBTyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0YsTUFBTTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRHY4QixZQUFZMkUsU0FBUyxDQUFDZ3lCLFlBQVksR0FBRztvQkFDakMsSUFBSSxJQUFJLENBQUM4RixNQUFNLElBQUksTUFBTTt3QkFDckIsT0FBTztvQkFDWDtvQkFDQSxJQUFJNkIsT0FBTyxJQUFJLENBQUM3QixNQUFNO29CQUN0QixJQUFJOEIsV0FBV0QsS0FBS3RkLElBQUksQ0FBQ2tULFlBQVk7b0JBQ3JDLElBQUlzSyxZQUFZO29CQUNoQixJQUFJanlCLE1BQU1reUIsS0FBS0MsYUFBYXJlLFFBQVEsR0FBR3NlLFFBQVE7b0JBQy9DLE1BQU9weUIsT0FBT2t5QixHQUFHcDRCLElBQUksR0FBSTt3QkFDckIsSUFBSWtHLEtBQUtnd0IsTUFBTSxHQUFHLEdBQUc7NEJBRWpCO3dCQUNKO3dCQUNBaUMsYUFBYWp5QixLQUFLeVUsSUFBSSxDQUFDa1QsWUFBWTtvQkFDdkM7b0JBQ0F3SyxhQUFhbGUsT0FBTyxDQUFDaWU7b0JBQ3JCLE9BQU9ELFlBQVlEO2dCQUN2QjtnQkFFQTs7Q0FFQyxHQUNEditCLFlBQVkyRSxTQUFTLENBQUNpNkIsYUFBYSxHQUFHLFNBQVNocUIsRUFBRTtvQkFDN0MsSUFBSXJJO29CQUNKLElBQUksT0FBT3FJLE9BQU8sYUFBYTt3QkFDM0JySSxPQUFPLElBQUksQ0FBQ213QixPQUFPLENBQUM5bkIsR0FBRztvQkFDM0IsT0FBTzt3QkFDSHJJLE9BQU8sSUFBSSxDQUFDa3dCLE1BQU07b0JBQ3RCO29CQUNBLGlFQUFpRTtvQkFDakUsSUFBSWx3QixLQUFLaXdCLE1BQU0sSUFBSTt3QkFDZixPQUFPO29CQUNYO29CQUNBLElBQUlxQyxVQUFVQyxjQUFjdnlCLEtBQUs4dkIsTUFBTTtvQkFDdkMsSUFBSTBDLFVBQVVELGNBQWN2eUIsS0FBSyt2QixNQUFNO29CQUN2QyxPQUFPLElBQUkxK0IsTUFBS3NnQixHQUFHLENBQUMyZ0IsU0FBU0U7Z0JBQ2pDO2dCQUVBLytCLFlBQVkyRSxTQUFTLENBQUNxNkIsaUJBQWlCLEdBQUcsU0FBU3p5QixJQUFJO29CQUNuRCxJQUFJQSxRQUFRLE1BQU07d0JBQ2Q7b0JBQ0o7b0JBQ0EsSUFBSUEsUUFBUSxJQUFJLENBQUNrd0IsTUFBTSxFQUFFO3dCQUNyQnI4QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDcUssS0FBSzZ2QixNQUFNLElBQUk7b0JBQzVDO29CQUNBLElBQUlDLFNBQVM5dkIsS0FBSzh2QixNQUFNO29CQUN4QixJQUFJQyxTQUFTL3ZCLEtBQUsrdkIsTUFBTTtvQkFDeEIsSUFBSS92QixLQUFLaXdCLE1BQU0sSUFBSTt3QkFDZnA4QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDbTZCLFVBQVU7d0JBQ25DajhCLFdBQVdFLFFBQU80QixNQUFNLENBQUNvNkIsVUFBVTt3QkFDbkNsOEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3FLLEtBQUtnd0IsTUFBTSxJQUFJO3dCQUN4QztvQkFDSjtvQkFDQSx5RUFBeUU7b0JBQ3pFLHlFQUF5RTtvQkFDekVuOEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ202QixPQUFPRCxNQUFNLElBQUk3dkI7b0JBQzFDbk0sV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ282QixPQUFPRixNQUFNLElBQUk3dkI7b0JBQzFDLElBQUksQ0FBQ3l5QixpQkFBaUIsQ0FBQzNDO29CQUN2QixJQUFJLENBQUMyQyxpQkFBaUIsQ0FBQzFDO2dCQUMzQjtnQkFFQXQ4QixZQUFZMkUsU0FBUyxDQUFDczZCLGVBQWUsR0FBRyxTQUFTMXlCLElBQUk7b0JBQ2pELElBQUlBLFFBQVEsTUFBTTt3QkFDZDtvQkFDSjtvQkFDQSxJQUFJOHZCLFNBQVM5dkIsS0FBSzh2QixNQUFNO29CQUN4QixJQUFJQyxTQUFTL3ZCLEtBQUsrdkIsTUFBTTtvQkFDeEIsSUFBSS92QixLQUFLaXdCLE1BQU0sSUFBSTt3QkFDZnA4QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDbTZCLFVBQVU7d0JBQ25DajhCLFdBQVdFLFFBQU80QixNQUFNLENBQUNvNkIsVUFBVTt3QkFDbkNsOEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3FLLEtBQUtnd0IsTUFBTSxJQUFJO3dCQUN4QztvQkFDSjtvQkFDQSx5RUFBeUU7b0JBQ3pFLHlFQUF5RTtvQkFDekUsSUFBSXNDLFVBQVUsSUFBSSxDQUFDbkMsT0FBTyxDQUFDTCxPQUFPLENBQUNFLE1BQU07b0JBQ3pDLElBQUl3QyxVQUFVLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQ0osT0FBTyxDQUFDQyxNQUFNO29CQUN6QyxJQUFJQSxTQUFTLElBQUkzK0IsTUFBS3NnQixHQUFHLENBQUMyZ0IsU0FBU0U7b0JBQ25DMytCLFdBQVdFLFFBQU80QixNQUFNLENBQUNxSyxLQUFLZ3dCLE1BQU0sSUFBSUE7b0JBQ3hDbjhCLFdBQVdFLFFBQU80QixNQUFNLENBQUMvRCxLQUFLaTNCLFFBQVEsQ0FBQyxJQUFJajNCLE9BQU91a0IsT0FBTyxDQUFDMlosT0FBT3JiLElBQUksRUFBRXNiLE9BQU90YixJQUFJLEdBQUd6VSxLQUFLeVUsSUFBSTtvQkFDOUYsSUFBSSxDQUFDaWUsZUFBZSxDQUFDNUM7b0JBQ3JCLElBQUksQ0FBQzRDLGVBQWUsQ0FBQzNDO2dCQUN6QjtnQkFFQSxtQ0FBbUM7Z0JBQ25DdDhCLFlBQVkyRSxTQUFTLENBQUN1NkIsUUFBUSxHQUFHO29CQUM3QkMsa0JBQWtCLElBQUksQ0FBQzFDLE1BQU07b0JBQzdCMkMsZ0JBQWdCLElBQUksQ0FBQzNDLE1BQU07b0JBQzNCcjhCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsSUFBSSxDQUFDdTBCLFNBQVMsTUFBTSxJQUFJLENBQUNtSSxhQUFhO2dCQUNuRTtnQkFFQTs7O0NBR0MsR0FDRDUrQixZQUFZMkUsU0FBUyxDQUFDK3hCLGFBQWEsR0FBRztvQkFDbEMsSUFBSTJJLGFBQWE7b0JBQ2pCLElBQUk5eUIsTUFBTWt5QixLQUFLQyxhQUFhcmUsUUFBUSxHQUFHc2UsUUFBUTtvQkFDL0MsTUFBT3B5QixPQUFPa3lCLEdBQUdwNEIsSUFBSSxHQUFJO3dCQUNyQixJQUFJa0csS0FBS2d3QixNQUFNLElBQUksR0FBRzs0QkFDbEI7d0JBQ0o7d0JBQ0FuOEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3FLLEtBQUtpd0IsTUFBTSxNQUFNO3dCQUMxQyxJQUFJc0IsVUFBVWxnQyxNQUFLMGhCLEdBQUcsQ0FBQy9TLEtBQUsrdkIsTUFBTSxDQUFDQyxNQUFNLEdBQUdod0IsS0FBSzh2QixNQUFNLENBQUNFLE1BQU07d0JBQzlEOEMsYUFBYXpoQyxNQUFLc2dCLEdBQUcsQ0FBQ21oQixZQUFZdkI7b0JBQ3RDO29CQUNBWSxhQUFhbGUsT0FBTyxDQUFDaWU7b0JBQ3JCLE9BQU9ZO2dCQUNYO2dCQUVBOztDQUVDLEdBQ0RyL0IsWUFBWTJFLFNBQVMsQ0FBQzI2QixlQUFlLEdBQUc7b0JBQ3BDLElBQUlDLFFBQVEsRUFBRTtvQkFDZCxJQUFJalIsUUFBUTtvQkFDWix3Q0FBd0M7b0JBQ3hDLElBQUkvaEIsTUFBTWt5QixLQUFLQyxhQUFhcmUsUUFBUSxHQUFHc2UsUUFBUTtvQkFDL0MsTUFBT3B5QixPQUFPa3lCLEdBQUdwNEIsSUFBSSxHQUFJO3dCQUNyQixJQUFJa0csS0FBS2d3QixNQUFNLEdBQUcsR0FBRzs0QkFFakI7d0JBQ0o7d0JBQ0EsSUFBSWh3QixLQUFLaXdCLE1BQU0sSUFBSTs0QkFDZmp3QixLQUFLNnZCLE1BQU0sR0FBRzs0QkFDZG1ELEtBQUssQ0FBQ2pSLE1BQU0sR0FBRy9oQjs0QkFDZixFQUFFK2hCO3dCQUNOLE9BQU87NEJBQ0gsSUFBSSxDQUFDdU8sUUFBUSxDQUFDdHdCO3dCQUNsQjtvQkFDSjtvQkFDQW15QixhQUFhbGUsT0FBTyxDQUFDaWU7b0JBQ3JCLE1BQU9uUSxRQUFRLEVBQUc7d0JBQ2QsSUFBSWtSLFVBQVV4VDt3QkFDZCxJQUFJeVQsT0FBTyxDQUFDLEdBQUdDLE9BQU8sQ0FBQzt3QkFDdkIsSUFBSyxJQUFJcmlDLElBQUksR0FBR0EsSUFBSWl4QixPQUFPLEVBQUVqeEIsRUFBRzs0QkFDNUIsSUFBSXNpQyxRQUFRSixLQUFLLENBQUNsaUMsRUFBRSxDQUFDMmpCLElBQUk7NEJBQ3pCLElBQUssSUFBSXJQLElBQUl0VSxJQUFJLEdBQUdzVSxJQUFJMmMsT0FBTyxFQUFFM2MsRUFBRztnQ0FDaEMsSUFBSWl1QixRQUFRTCxLQUFLLENBQUM1dEIsRUFBRSxDQUFDcVAsSUFBSTtnQ0FDekIsSUFBSTBKLElBQUl1UixTQUFTNWIsUUFBUTtnQ0FDekJxSyxFQUFFaEksT0FBTyxDQUFDaWQsT0FBT0M7Z0NBQ2pCLElBQUl2QyxPQUFPM1MsRUFBRXdKLFlBQVk7Z0NBQ3pCLElBQUltSixPQUFPbUMsU0FBUztvQ0FDaEJDLE9BQU9waUM7b0NBQ1BxaUMsT0FBTy90QjtvQ0FDUDZ0QixVQUFVbkM7Z0NBQ2Q7Z0NBQ0FwQixTQUFTemIsT0FBTyxDQUFDa0s7NEJBQ3JCO3dCQUNKO3dCQUNBLElBQUkyUixTQUFTa0QsS0FBSyxDQUFDRSxLQUFLO3dCQUN4QixJQUFJbkQsU0FBU2lELEtBQUssQ0FBQ0csS0FBSzt3QkFDeEIsSUFBSXRELFNBQVMsSUFBSSxDQUFDUSxZQUFZO3dCQUM5QlIsT0FBT0MsTUFBTSxHQUFHQTt3QkFDaEJELE9BQU9FLE1BQU0sR0FBR0E7d0JBQ2hCRixPQUFPRyxNQUFNLEdBQUcsSUFBSTMrQixNQUFLc2dCLEdBQUcsQ0FBQ21lLE9BQU9FLE1BQU0sRUFBRUQsT0FBT0MsTUFBTTt3QkFDekRILE9BQU9wYixJQUFJLENBQUMwQixPQUFPLENBQUMyWixPQUFPcmIsSUFBSSxFQUFFc2IsT0FBT3RiLElBQUk7d0JBQzVDb2IsT0FBT0EsTUFBTSxHQUFHO3dCQUNoQkMsT0FBT0QsTUFBTSxHQUFHQTt3QkFDaEJFLE9BQU9GLE1BQU0sR0FBR0E7d0JBQ2hCbUQsS0FBSyxDQUFDRyxLQUFLLEdBQUdILEtBQUssQ0FBQ2pSLFFBQVEsRUFBRTt3QkFDOUJpUixLQUFLLENBQUNFLEtBQUssR0FBR3JEO3dCQUNkLEVBQUU5TjtvQkFDTjtvQkFDQSxJQUFJLENBQUNtTyxNQUFNLEdBQUc4QyxLQUFLLENBQUMsRUFBRTtvQkFDdEIsSUFBSSxDQUFDTCxRQUFRO2dCQUNqQjtnQkFFQTs7Ozs7Q0FLQyxHQUNEbC9CLFlBQVkyRSxTQUFTLENBQUM0ZixXQUFXLEdBQUcsU0FBU0MsU0FBUztvQkFDbEQsd0NBQXdDO29CQUN4QyxJQUFJalksTUFBTWt5QixLQUFLQyxhQUFhcmUsUUFBUSxHQUFHc2UsUUFBUTtvQkFDL0MsTUFBT3B5QixPQUFPa3lCLEdBQUdwNEIsSUFBSSxHQUFJO3dCQUNyQixJQUFJMmEsT0FBT3pVLEtBQUt5VSxJQUFJO3dCQUNwQkEsS0FBSzRTLFVBQVUsQ0FBQ3hXLENBQUMsSUFBSW9ILFVBQVVwSCxDQUFDO3dCQUNoQzRELEtBQUs0UyxVQUFVLENBQUN0VyxDQUFDLElBQUlrSCxVQUFVbEgsQ0FBQzt3QkFDaEMwRCxLQUFLNlMsVUFBVSxDQUFDelcsQ0FBQyxJQUFJb0gsVUFBVXBILENBQUM7d0JBQ2hDNEQsS0FBSzZTLFVBQVUsQ0FBQ3ZXLENBQUMsSUFBSWtILFVBQVVsSCxDQUFDO29CQUNwQztvQkFDQW9oQixhQUFhbGUsT0FBTyxDQUFDaWU7Z0JBQ3pCO2dCQUVBOzs7O0NBSUMsR0FDRDs7Ozs7Q0FLQyxHQUNEeitCLFlBQVkyRSxTQUFTLENBQUN1c0IsS0FBSyxHQUFHLFNBQVNsUSxJQUFJLEVBQUVpUSxhQUFhO29CQUN0RDd3QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLE9BQU8rdUIsa0JBQWtCO29CQUNsRCxJQUFJckcsUUFBUWlWLFVBQVV4ZixRQUFRO29CQUM5QnVLLE1BQU1OLElBQUksQ0FBQyxJQUFJLENBQUNtUyxNQUFNO29CQUN0QixNQUFPN1IsTUFBTWx0QixNQUFNLEdBQUcsRUFBRzt3QkFDckIsSUFBSTZPLE9BQU9xZSxNQUFNRyxHQUFHO3dCQUNwQixJQUFJeGUsUUFBUSxNQUFNOzRCQUNkO3dCQUNKO3dCQUNBLElBQUlwTyxLQUFLcVcsV0FBVyxDQUFDakksS0FBS3lVLElBQUksRUFBRUEsT0FBTzs0QkFDbkMsSUFBSXpVLEtBQUtpd0IsTUFBTSxJQUFJO2dDQUNmLElBQUlzRCxVQUFVN08sY0FBYzFrQixLQUFLcUksRUFBRTtnQ0FDbkMsSUFBSWtyQixXQUFXLE9BQU87b0NBQ2xCO2dDQUNKOzRCQUNKLE9BQU87Z0NBQ0hsVixNQUFNTixJQUFJLENBQUMvZCxLQUFLOHZCLE1BQU07Z0NBQ3RCelIsTUFBTU4sSUFBSSxDQUFDL2QsS0FBSyt2QixNQUFNOzRCQUMxQjt3QkFDSjtvQkFDSjtvQkFDQXVELFVBQVVyZixPQUFPLENBQUNvSztnQkFDdEI7Z0JBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRDVxQixZQUFZMkUsU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNFLEtBQUssRUFBRTZVLGVBQWU7b0JBQzNELFVBQVU7b0JBQ1Z4MkIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxPQUFPMDBCLG9CQUFvQjtvQkFDcEQsSUFBSXJGLEtBQUt4UCxNQUFNd1AsRUFBRTtvQkFDakIsSUFBSUMsS0FBS3pQLE1BQU15UCxFQUFFO29CQUNqQixJQUFJejBCLElBQUljLEtBQUtpTCxHQUFHLENBQUMwb0IsSUFBSUQ7b0JBQ3JCbnhCLFdBQVdFLFFBQU80QixNQUFNLENBQUNuRixFQUFFa3BCLGFBQWEsS0FBSztvQkFDN0NscEIsRUFBRWdiLFNBQVM7b0JBQ1gscUNBQXFDO29CQUNyQyxJQUFJMU8sSUFBSXhMLEtBQUttTCxLQUFLLENBQUMsR0FBR2pNO29CQUN0QixJQUFJZ2pDLFFBQVFsaUMsS0FBS3loQixHQUFHLENBQUNqVztvQkFDckIsMkNBQTJDO29CQUMzQyxpQ0FBaUM7b0JBQ2pDLElBQUlpb0IsY0FBY3ZQLE1BQU11UCxXQUFXO29CQUNuQyx3Q0FBd0M7b0JBQ3hDLElBQUkwTyxjQUFjLElBQUk3aEM7b0JBQ3RCLElBQUl0QixJQUFJZ0IsS0FBSzZrQixPQUFPLENBQUMsSUFBSTRPLGFBQWFDLElBQUlELGFBQWFFO29CQUN2RHdPLFlBQVlyTCxhQUFhLENBQUNwRCxJQUFJMTBCO29CQUM5QixJQUFJK3RCLFFBQVFpVixVQUFVeGYsUUFBUTtvQkFDOUIsSUFBSTRmLFdBQVdDLFVBQVU3ZixRQUFRO29CQUNqQ3VLLE1BQU1OLElBQUksQ0FBQyxJQUFJLENBQUNtUyxNQUFNO29CQUN0QixNQUFPN1IsTUFBTWx0QixNQUFNLEdBQUcsRUFBRzt3QkFDckIsSUFBSTZPLE9BQU9xZSxNQUFNRyxHQUFHO3dCQUNwQixJQUFJeGUsUUFBUSxNQUFNOzRCQUNkO3dCQUNKO3dCQUNBLElBQUlwTyxLQUFLcVcsV0FBVyxDQUFDakksS0FBS3lVLElBQUksRUFBRWdmLGdCQUFnQixPQUFPOzRCQUNuRDt3QkFDSjt3QkFDQSwyQ0FBMkM7d0JBQzNDLGlDQUFpQzt3QkFDakMsSUFBSTkzQixJQUFJcUUsS0FBS3lVLElBQUksQ0FBQ2dULFNBQVM7d0JBQzNCLElBQUkzSSxJQUFJOWUsS0FBS3lVLElBQUksQ0FBQ2lULFVBQVU7d0JBQzVCLElBQUl0YyxhQUFhL1osTUFBSzBoQixHQUFHLENBQUN6aEIsS0FBS3lMLEdBQUcsQ0FBQ0QsR0FBR3hMLEtBQUtpTCxHQUFHLENBQUN5b0IsSUFBSXJwQixPQUFPckssS0FBS3lMLEdBQUcsQ0FBQ3kyQixPQUFPMVU7d0JBQzFFLElBQUkxVCxhQUFhLEdBQUc7NEJBQ2hCO3dCQUNKO3dCQUNBLElBQUlwTCxLQUFLaXdCLE1BQU0sSUFBSTs0QkFDZnlELFNBQVMxTyxFQUFFLEdBQUcxekIsS0FBS3lGLEtBQUssQ0FBQ3llLE1BQU13UCxFQUFFOzRCQUNqQzBPLFNBQVN6TyxFQUFFLEdBQUczekIsS0FBS3lGLEtBQUssQ0FBQ3llLE1BQU15UCxFQUFFOzRCQUNqQ3lPLFNBQVMzTyxXQUFXLEdBQUdBOzRCQUN2QixJQUFJeUQsUUFBUTZCLGdCQUFnQnFKLFVBQVUxekIsS0FBS3FJLEVBQUU7NEJBQzdDLElBQUltZ0IsU0FBUyxHQUFHO2dDQUNaLDBDQUEwQztnQ0FDMUM7NEJBQ0o7NEJBQ0EsSUFBSUEsUUFBUSxHQUFHO2dDQUNYLCtCQUErQjtnQ0FDL0J6RCxjQUFjeUQ7Z0NBQ2RsNEIsSUFBSWdCLEtBQUs2a0IsT0FBTyxDQUFDLElBQUk0TyxhQUFhQyxJQUFJRCxhQUFhRTtnQ0FDbkR3TyxZQUFZckwsYUFBYSxDQUFDcEQsSUFBSTEwQjs0QkFDbEM7d0JBQ0osT0FBTzs0QkFDSCt0QixNQUFNTixJQUFJLENBQUMvZCxLQUFLOHZCLE1BQU07NEJBQ3RCelIsTUFBTU4sSUFBSSxDQUFDL2QsS0FBSyt2QixNQUFNO3dCQUMxQjtvQkFDSjtvQkFDQXVELFVBQVVyZixPQUFPLENBQUNvSztvQkFDbEJzVixVQUFVMWYsT0FBTyxDQUFDeWY7Z0JBQ3RCO2dCQUVBLElBQUlDLFlBQVksSUFBSTV5QixLQUFLO29CQUNyQndTLFFBQVE7d0JBQ0osT0FBTyxDQUFDO29CQUNaO29CQUNBVSxTQUFTLFNBQVNvSyxLQUFLLEdBQUc7Z0JBQzlCO2dCQUVBLElBQUlpVixZQUFZLElBQUl2eUIsS0FBSztvQkFDckJ3UyxRQUFRO3dCQUNKLE9BQU8sRUFBRTtvQkFDYjtvQkFDQVUsU0FBUyxTQUFTb0ssS0FBSzt3QkFDbkJBLE1BQU1sdEIsTUFBTSxHQUFHO29CQUNuQjtnQkFDSjtnQkFFQSxJQUFJZ2hDLGVBQWUsSUFBSXB4QixLQUFLO29CQUN4QndTLFFBQVE7d0JBQ0osT0FBTyxJQUFJcWdCO29CQUNmO29CQUNBM2YsU0FBUyxTQUFTNGYsUUFBUTt3QkFDdEJBLFNBQVNDLEtBQUs7b0JBQ2xCO2dCQUNKO2dCQUVBLFNBQVNGO29CQUNMLElBQUlHLFVBQVUsRUFBRTtvQkFDaEIsSUFBSUMsU0FBUyxFQUFFO29CQUNmLE9BQU87d0JBQ0g1QixVQUFVLFNBQVNMLElBQUk7NEJBQ25CZ0MsUUFBUTVpQyxNQUFNLEdBQUc7NEJBQ2pCNGlDLFFBQVFoVyxJQUFJLENBQUNnVTs0QkFDYmlDLE9BQU83aUMsTUFBTSxHQUFHOzRCQUNoQjZpQyxPQUFPalcsSUFBSSxDQUFDOzRCQUNaLE9BQU8sSUFBSTt3QkFDZjt3QkFDQWprQixNQUFNOzRCQUNGLE1BQU9pNkIsUUFBUTVpQyxNQUFNLEdBQUcsRUFBRztnQ0FDdkIsSUFBSUwsSUFBSWlqQyxRQUFRNWlDLE1BQU0sR0FBRztnQ0FDekIsSUFBSTZPLE9BQU8rekIsT0FBTyxDQUFDampDLEVBQUU7Z0NBQ3JCLElBQUlrakMsTUFBTSxDQUFDbGpDLEVBQUUsS0FBSyxHQUFHO29DQUNqQmtqQyxNQUFNLENBQUNsakMsRUFBRSxHQUFHO29DQUNaLE9BQU9rUDtnQ0FDWDtnQ0FDQSxJQUFJZzBCLE1BQU0sQ0FBQ2xqQyxFQUFFLEtBQUssR0FBRztvQ0FDakJrakMsTUFBTSxDQUFDbGpDLEVBQUUsR0FBRztvQ0FDWixJQUFJa1AsS0FBSzh2QixNQUFNLEVBQUU7d0NBQ2JpRSxRQUFRaFcsSUFBSSxDQUFDL2QsS0FBSzh2QixNQUFNO3dDQUN4QmtFLE9BQU9qVyxJQUFJLENBQUM7d0NBQ1osT0FBTy9kLEtBQUs4dkIsTUFBTTtvQ0FDdEI7Z0NBQ0o7Z0NBQ0EsSUFBSWtFLE1BQU0sQ0FBQ2xqQyxFQUFFLEtBQUssR0FBRztvQ0FDakJrakMsTUFBTSxDQUFDbGpDLEVBQUUsR0FBRztvQ0FDWixJQUFJa1AsS0FBSyt2QixNQUFNLEVBQUU7d0NBQ2JnRSxRQUFRaFcsSUFBSSxDQUFDL2QsS0FBSyt2QixNQUFNO3dDQUN4QmlFLE9BQU9qVyxJQUFJLENBQUM7d0NBQ1osT0FBTy9kLEtBQUsrdkIsTUFBTTtvQ0FDdEI7Z0NBQ0o7Z0NBQ0FnRSxRQUFRdlYsR0FBRztnQ0FDWHdWLE9BQU94VixHQUFHOzRCQUNkO3dCQUNKO3dCQUNBc1YsT0FBTzs0QkFDSEMsUUFBUTVpQyxNQUFNLEdBQUc7d0JBQ3JCO29CQUNKO2dCQUNKO1lBR0E7WUFBRTtnQkFBQyxlQUFjO2dCQUFFLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsZ0JBQWU7Z0JBQUcsa0JBQWlCO2dCQUFHLFVBQVM7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNOLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNsSixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBRzJEO2dCQUVqQjFELFFBQU9ELE9BQU8sQ0FBQzhzQixLQUFLLEdBQUdEO2dCQUV2QjVzQixRQUFPRCxPQUFPLENBQUNndEIsTUFBTSxHQUFHRDtnQkFFeEIsSUFBSWxwQixXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSWtELFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJb2pDLFFBQVFwakMsU0FBUTtnQkFFcEIsSUFBSXdDLFFBQVF4QyxTQUFRO2dCQUVwQixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJVSxPQUFPVixTQUFRO2dCQUVuQixJQUFJVyxRQUFRWCxTQUFRO2dCQUVwQixJQUFJWSxRQUFRWixTQUFRO2dCQUVwQixJQUFJYyxNQUFNZCxTQUFRO2dCQUVsQixJQUFJdUMsUUFBUXZDLFNBQVE7Z0JBRXBCLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlvRCxXQUFXcEQsU0FBUTtnQkFFdkIsSUFBSXFELFdBQVdyRCxTQUFRO2dCQUV2QixJQUFJMEMsV0FBVzFDLFNBQVE7Z0JBRXZCLElBQUlpc0IsZ0JBQWdCdnBCLFNBQVNvcEIsS0FBSztnQkFFbEMsSUFBSUksaUJBQWlCeHBCLFNBQVNzcEIsTUFBTTtnQkFFcEMsSUFBSUcsZ0JBQWdCenBCLFNBQVMwcEIsS0FBSztnQkFFbEMsSUFBSUMsZUFBZTNwQixTQUFTNHBCLEtBQUs7Z0JBRWpDOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU1Q7b0JBQ0wsSUFBSSxDQUFDa0UsTUFBTSxHQUFHLElBQUk1RDtvQkFDbEIsSUFBSSxDQUFDNkQsTUFBTSxHQUFHLElBQUk3RDtvQkFDbEIsSUFBSSxDQUFDMEQsTUFBTSxHQUFHLElBQUl0dEI7b0JBQ2xCLElBQUksQ0FBQ3V0QixNQUFNLEdBQUcsSUFBSXZ0QjtvQkFDbEIsSUFBSSxDQUFDMHRCLElBQUk7Z0JBQ2I7Z0JBRUEsa0JBQWtCO2dCQUNsQmxFLFVBQVVzWCxTQUFTLEdBQUc7Z0JBRXRCdFgsVUFBVXVYLFFBQVEsR0FBRztnQkFFckJ2WCxVQUFVd1gsWUFBWSxHQUFHO2dCQUV6QnhYLFVBQVVxRSxVQUFVLEdBQUc7Z0JBRXZCckUsVUFBVXlYLFdBQVcsR0FBRztnQkFFeEI7Ozs7O0NBS0MsR0FDRCxTQUFTelg7b0JBQ0wsSUFBSSxDQUFDb0UsS0FBSztvQkFDVixJQUFJLENBQUMxd0IsQ0FBQztnQkFDVjtnQkFFQStDLE1BQU1paEMsT0FBTyxHQUFHO2dCQUVoQmpoQyxNQUFNa2hDLFVBQVUsR0FBRztnQkFFbkJsaEMsTUFBTW1oQyxRQUFRLEdBQUc7Z0JBRWpCbmhDLE1BQU1vaEMsUUFBUSxHQUFHO2dCQUVqQnBoQyxNQUFNcWhDLFdBQVcsR0FBRztnQkFFcEJyaEMsTUFBTXNoQyxZQUFZLEdBQUc7Z0JBRXJCdGhDLE1BQU11aEMsZUFBZSxHQUFHO2dCQUV4Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNwaEMsYUFBYStoQixNQUFNLEVBQUVDLEtBQUs7b0JBQy9CLElBQUlxZixRQUFRWixNQUFNYSxHQUFHO29CQUNyQixFQUFFemhDLE1BQU1taEMsUUFBUTtvQkFDaEJqZixPQUFPeUwsS0FBSyxHQUFHcEUsVUFBVXNYLFNBQVM7b0JBQ2xDM2UsT0FBT2psQixDQUFDLEdBQUdrbEIsTUFBTXNMLElBQUk7b0JBQ3JCLElBQUlGLFNBQVNwTCxNQUFNb0wsTUFBTTtvQkFDekIsZ0JBQWdCO29CQUNoQixJQUFJQyxTQUFTckwsTUFBTXFMLE1BQU07b0JBQ3pCLGdCQUFnQjtvQkFDaEIsSUFBSUgsU0FBU2xMLE1BQU1rTCxNQUFNO29CQUN6QixRQUFRO29CQUNSLElBQUlDLFNBQVNuTCxNQUFNbUwsTUFBTTtvQkFDekIsUUFBUTtvQkFDUixxRUFBcUU7b0JBQ3JFLGdCQUFnQjtvQkFDaEJELE9BQU9sVixTQUFTO29CQUNoQm1WLE9BQU9uVixTQUFTO29CQUNoQixJQUFJc1YsT0FBT3RMLE1BQU1zTCxJQUFJO29CQUNyQixJQUFJaVUsY0FBY25VLE9BQU8xYixRQUFRLEdBQUcyYixPQUFPM2IsUUFBUTtvQkFDbkQsSUFBSTh2QixTQUFTM2pDLE1BQUtzZ0IsR0FBRyxDQUFDamUsU0FBU3VZLFVBQVUsRUFBRThvQixjQUFjLElBQUlyaEMsU0FBU3VZLFVBQVU7b0JBQ2hGLElBQUlncEIsWUFBWSxNQUFNdmhDLFNBQVN1WSxVQUFVO29CQUN6Q3BZLFdBQVdFLFFBQU80QixNQUFNLENBQUNxL0IsU0FBU0M7b0JBQ2xDLElBQUkxTCxLQUFLO29CQUNULElBQUkyTCxrQkFBa0J4aEMsU0FBUzZuQixnQkFBZ0I7b0JBQy9DLElBQUl3USxPQUFPO29CQUNYLG9DQUFvQztvQkFDcEMsSUFBSWxLLFFBQVEsSUFBSTNFO29CQUNoQixJQUFJaVksZ0JBQWdCLElBQUlyWTtvQkFDeEJxWSxjQUFjdlUsTUFBTSxHQUFHcEwsTUFBTW9MLE1BQU07b0JBQ25DdVUsY0FBY3RVLE1BQU0sR0FBR3JMLE1BQU1xTCxNQUFNO29CQUNuQ3NVLGNBQWN2VCxRQUFRLEdBQUc7b0JBQ3pCLHdFQUF3RTtvQkFDeEUsdUVBQXVFO29CQUN2RSxPQUFTO3dCQUNMLElBQUl0YSxNQUFNNVYsVUFBVW1GLFFBQVE7d0JBQzVCLElBQUkwUSxNQUFNN1YsVUFBVW1GLFFBQVE7d0JBQzVCNnBCLE9BQU90bEIsWUFBWSxDQUFDa00sS0FBS2lpQjt3QkFDekI1SSxPQUFPdmxCLFlBQVksQ0FBQ21NLEtBQUtnaUI7d0JBQ3pCLCtEQUErRDt3QkFDL0QsNEJBQTRCO3dCQUM1QjRMLGNBQWN6VCxVQUFVLEdBQUdwYTt3QkFDM0I2dEIsY0FBY3hULFVBQVUsR0FBR3BhO3dCQUMzQixJQUFJNnRCLGlCQUFpQixJQUFJclk7d0JBQ3pCeHBCLFNBQVM2aEMsZ0JBQWdCdlQsT0FBT3NUO3dCQUNoQyxvRUFBb0U7d0JBQ3BFLElBQUlDLGVBQWV0VCxRQUFRLElBQUksR0FBRzs0QkFDOUIsV0FBVzs0QkFDWHZNLE9BQU95TCxLQUFLLEdBQUdwRSxVQUFVd1gsWUFBWTs0QkFDckM3ZSxPQUFPamxCLENBQUMsR0FBRzs0QkFDWDt3QkFDSjt3QkFDQSxJQUFJOGtDLGVBQWV0VCxRQUFRLEdBQUdrVCxTQUFTQyxXQUFXOzRCQUM5QyxXQUFXOzRCQUNYMWYsT0FBT3lMLEtBQUssR0FBR3BFLFVBQVVxRSxVQUFVOzRCQUNuQzFMLE9BQU9qbEIsQ0FBQyxHQUFHaTVCOzRCQUNYO3dCQUNKO3dCQUNBLGtDQUFrQzt3QkFDbEMsSUFBSThMLE1BQU0sSUFBSUM7d0JBQ2RELElBQUlFLFVBQVUsQ0FBQzFULE9BQU9qQixRQUFRRixRQUFRRyxRQUFRRixRQUFRNEk7d0JBQ3RELElBQUksT0FBTzs0QkFDUCx5Q0FBeUM7NEJBQ3pDLElBQUlpTSxJQUFJOzRCQUNSLElBQUlDLEtBQUssSUFBSUQ7NEJBQ2IsSUFBSUUsS0FBSyxFQUFFOzRCQUNYLGFBQWE7NEJBQ2IsSUFBSUMsS0FBSyxFQUFFOzRCQUNYLGFBQWE7NEJBQ2IsSUFBSTlrQixJQUFJOzRCQUNSLElBQUssSUFBSS9mLElBQUksR0FBR0EsS0FBSzBrQyxHQUFHLEVBQUUxa0MsRUFBRztnQ0FDekI0dkIsT0FBT3RsQixZQUFZLENBQUNrTSxLQUFLdUo7Z0NBQ3pCOFAsT0FBT3ZsQixZQUFZLENBQUNtTSxLQUFLc0o7Z0NBQ3pCLElBQUk1Z0IsSUFBSW9sQyxJQUFJaHVCLFFBQVEsQ0FBQ0MsS0FBS0MsT0FBT3l0QjtnQ0FDakNZLE9BQU8sV0FBVy9rQixHQUFHNWdCO2dDQUNyQnlsQyxFQUFFLENBQUM1a0MsRUFBRSxHQUFHK2Y7Z0NBQ1I4a0IsRUFBRSxDQUFDN2tDLEVBQUUsR0FBR2I7Z0NBQ1I0Z0IsS0FBSzRrQjs0QkFDVDt3QkFDSjt3QkFDQSxxRUFBcUU7d0JBQ3JFLHFFQUFxRTt3QkFDckUsWUFBWTt3QkFDWixJQUFJSSxPQUFPO3dCQUNYLElBQUlyTSxLQUFLMUk7d0JBQ1QsSUFBSWdWLGVBQWU7d0JBQ25CLE9BQVM7NEJBQ0wsaUVBQWlFOzRCQUNqRSxJQUFJQyxLQUFLVixJQUFJVyxpQkFBaUIsQ0FBQ3hNOzRCQUMvQixJQUFJcm5CLFNBQVNrekIsSUFBSWx6QixNQUFNOzRCQUN2QixJQUFJRSxTQUFTZ3pCLElBQUloekIsTUFBTTs0QkFDdkIsd0NBQXdDOzRCQUN4QyxJQUFJMHpCLEtBQUtmLFNBQVNDLFdBQVc7Z0NBQ3pCLFdBQVc7Z0NBQ1gxZixPQUFPeUwsS0FBSyxHQUFHcEUsVUFBVXlYLFdBQVc7Z0NBQ3BDOWUsT0FBT2psQixDQUFDLEdBQUd3d0I7Z0NBQ1grVSxPQUFPO2dDQUNQOzRCQUNKOzRCQUNBLHdDQUF3Qzs0QkFDeEMsSUFBSUUsS0FBS2YsU0FBU0MsV0FBVztnQ0FDekIscUJBQXFCO2dDQUNyQjFMLEtBQUtDO2dDQUNMOzRCQUNKOzRCQUNBLHdEQUF3RDs0QkFDeEQsSUFBSXlNLEtBQUtaLElBQUlodUIsUUFBUSxDQUFDa2lCOzRCQUN0QixJQUFJcG5CLFNBQVNrekIsSUFBSWx6QixNQUFNOzRCQUN2QixJQUFJRSxTQUFTZ3pCLElBQUloekIsTUFBTTs0QkFDdkIsa0VBQWtFOzRCQUNsRSwwQkFBMEI7NEJBQzFCLElBQUk0ekIsS0FBS2pCLFNBQVNDLFdBQVc7Z0NBQ3pCMWYsT0FBT3lMLEtBQUssR0FBR3BFLFVBQVV1WCxRQUFRO2dDQUNqQzVlLE9BQU9qbEIsQ0FBQyxHQUFHaTVCO2dDQUNYc00sT0FBTztnQ0FDUDs0QkFDSjs0QkFDQSxxQkFBcUI7NEJBQ3JCLElBQUlJLE1BQU1qQixTQUFTQyxXQUFXO2dDQUMxQixrREFBa0Q7Z0NBQ2xEMWYsT0FBT3lMLEtBQUssR0FBR3BFLFVBQVVxRSxVQUFVO2dDQUNuQzFMLE9BQU9qbEIsQ0FBQyxHQUFHaTVCO2dDQUNYc00sT0FBTztnQ0FDUDs0QkFDSjs0QkFDQSx3Q0FBd0M7NEJBQ3hDLElBQUlLLGdCQUFnQjs0QkFDcEIsSUFBSUMsS0FBSzVNLElBQUk2TSxLQUFLNU07NEJBQ2xCLE9BQVM7Z0NBQ0wsOENBQThDO2dDQUM5QyxJQUFJbDVCO2dDQUNKLElBQUk0bEMsZ0JBQWdCLEdBQUc7b0NBQ25CLHNDQUFzQztvQ0FDdEM1bEMsSUFBSTZsQyxLQUFLLEFBQUNuQixDQUFBQSxTQUFTaUIsRUFBQyxJQUFNRyxDQUFBQSxLQUFLRCxFQUFDLElBQU1KLENBQUFBLEtBQUtFLEVBQUM7Z0NBQ2hELE9BQU87b0NBQ0gsbUNBQW1DO29DQUNuQzNsQyxJQUFJLEtBQU02bEMsQ0FBQUEsS0FBS0MsRUFBQztnQ0FDcEI7Z0NBQ0EsRUFBRUY7Z0NBQ0YsRUFBRTdpQyxNQUFNc2hDLFlBQVk7Z0NBQ3BCLElBQUlsa0MsSUFBSTRrQyxJQUFJaHVCLFFBQVEsQ0FBQy9XO2dDQUNyQixJQUFJNlIsU0FBU2t6QixJQUFJbHpCLE1BQU07Z0NBQ3ZCLElBQUlFLFNBQVNnekIsSUFBSWh6QixNQUFNO2dDQUN2QixJQUFJaFIsTUFBSzBoQixHQUFHLENBQUN0aUIsSUFBSXVrQyxVQUFVQyxXQUFXO29DQUNsQyxvQ0FBb0M7b0NBQ3BDekwsS0FBS2w1QjtvQ0FDTDtnQ0FDSjtnQ0FDQSwwQ0FBMEM7Z0NBQzFDLElBQUlHLElBQUl1a0MsUUFBUTtvQ0FDWm1CLEtBQUs3bEM7b0NBQ0wybEMsS0FBS3hsQztnQ0FDVCxPQUFPO29DQUNIMmxDLEtBQUs5bEM7b0NBQ0x5bEMsS0FBS3RsQztnQ0FDVDtnQ0FDQSxJQUFJeWxDLGlCQUFpQixJQUFJO29DQUNyQjtnQ0FDSjs0QkFDSjs0QkFDQTdpQyxNQUFNdWhDLGVBQWUsR0FBR3ZqQyxNQUFLc2dCLEdBQUcsQ0FBQ3RlLE1BQU11aEMsZUFBZSxFQUFFc0I7NEJBQ3hELEVBQUVKOzRCQUNGLElBQUlBLGdCQUFnQnBpQyxTQUFTb25CLGtCQUFrQixFQUFFO2dDQUM3Qzs0QkFDSjt3QkFDSjt3QkFDQSxFQUFFaVI7d0JBQ0YsRUFBRTE0QixNQUFNb2hDLFFBQVE7d0JBQ2hCLElBQUlvQixNQUFNOzRCQUNOO3dCQUNKO3dCQUNBLElBQUk5SixRQUFRbUosaUJBQWlCOzRCQUN6Qix1Q0FBdUM7NEJBQ3ZDM2YsT0FBT3lMLEtBQUssR0FBR3BFLFVBQVV1WCxRQUFROzRCQUNqQzVlLE9BQU9qbEIsQ0FBQyxHQUFHaTVCOzRCQUNYO3dCQUNKO29CQUNKO29CQUNBbDJCLE1BQU1xaEMsV0FBVyxHQUFHcmpDLE1BQUtzZ0IsR0FBRyxDQUFDdGUsTUFBTXFoQyxXQUFXLEVBQUUzSTtvQkFDaEQsSUFBSXNLLE9BQU9wQyxNQUFNbkwsSUFBSSxDQUFDK0w7b0JBQ3RCeGhDLE1BQU1raEMsVUFBVSxHQUFHbGpDLE1BQUtzZ0IsR0FBRyxDQUFDdGUsTUFBTWtoQyxVQUFVLEVBQUU4QjtvQkFDOUNoakMsTUFBTWloQyxPQUFPLElBQUkrQjtnQkFDckI7Z0JBRUEsMEJBQTBCO2dCQUMxQixJQUFJQyxXQUFXO2dCQUVmLElBQUk1cUIsVUFBVTtnQkFFZCxJQUFJRyxVQUFVO2dCQUVkLFNBQVN5cEI7b0JBQ0wsSUFBSSxDQUFDaUIsUUFBUSxHQUFHLElBQUl2WjtvQkFDcEIsSUFBSSxDQUFDd1osUUFBUSxHQUFHLElBQUl4WjtvQkFDcEIsSUFBSSxDQUFDeVosUUFBUTtvQkFDYixRQUFRO29CQUNSLElBQUksQ0FBQ0MsUUFBUTtvQkFDYixRQUFRO29CQUNSLElBQUksQ0FBQ25nQyxNQUFNO29CQUNYLElBQUksQ0FBQ29nQyxZQUFZLEdBQUdybEMsS0FBS3NELElBQUk7b0JBQzdCLElBQUksQ0FBQ2dpQyxNQUFNLEdBQUd0bEMsS0FBS3NELElBQUk7Z0JBQzNCO2dCQUVBLG9EQUFvRDtnQkFDcEQ7Ozs7Ozs7Q0FPQyxHQUNEMGdDLG1CQUFtQmw5QixTQUFTLENBQUNtOUIsVUFBVSxHQUFHLFNBQVMxVCxLQUFLLEVBQUVqQixNQUFNLEVBQUVGLE1BQU0sRUFBRUcsTUFBTSxFQUFFRixNQUFNLEVBQUU0SSxFQUFFO29CQUN4RixJQUFJLENBQUNnTixRQUFRLEdBQUczVjtvQkFDaEIsSUFBSSxDQUFDNFYsUUFBUSxHQUFHM1Y7b0JBQ2hCLElBQUlrQixRQUFRRixNQUFNRSxLQUFLO29CQUN2Qmx1QixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUlvc0IsU0FBU0EsUUFBUTtvQkFDOUMsSUFBSSxDQUFDMFUsUUFBUSxHQUFHL1Y7b0JBQ2hCLElBQUksQ0FBQ2dXLFFBQVEsR0FBRy9WO29CQUNoQixJQUFJclosTUFBTTVWLFVBQVVtRixRQUFRO29CQUM1QixJQUFJMFEsTUFBTTdWLFVBQVVtRixRQUFRO29CQUM1QixJQUFJLENBQUM0L0IsUUFBUSxDQUFDcjdCLFlBQVksQ0FBQ2tNLEtBQUtpaUI7b0JBQ2hDLElBQUksQ0FBQ21OLFFBQVEsQ0FBQ3Q3QixZQUFZLENBQUNtTSxLQUFLZ2lCO29CQUNoQyxJQUFJeEgsU0FBUyxHQUFHO3dCQUNaLElBQUksQ0FBQ3hyQixNQUFNLEdBQUcrL0I7d0JBQ2QsSUFBSU8sY0FBYyxJQUFJLENBQUNOLFFBQVEsQ0FBQ2hLLFNBQVMsQ0FBQzFLLE1BQU0xZixNQUFNLENBQUMsRUFBRTt3QkFDekQsSUFBSTIwQixjQUFjLElBQUksQ0FBQ04sUUFBUSxDQUFDakssU0FBUyxDQUFDMUssTUFBTXhmLE1BQU0sQ0FBQyxFQUFFO3dCQUN6RCxJQUFJaUosU0FBUzVaLFVBQVU2TyxPQUFPLENBQUMrRyxLQUFLdXZCO3dCQUNwQyxJQUFJdHJCLFNBQVM3WixVQUFVNk8sT0FBTyxDQUFDZ0gsS0FBS3V2Qjt3QkFDcEMsSUFBSSxDQUFDRixNQUFNLENBQUM5b0IsVUFBVSxDQUFDLEdBQUd2QyxRQUFRLENBQUMsR0FBR0Q7d0JBQ3RDLElBQUk3YSxJQUFJLElBQUksQ0FBQ21tQyxNQUFNLENBQUNwckIsU0FBUzt3QkFDN0IsT0FBTy9hO29CQUNYLE9BQU8sSUFBSW94QixNQUFNMWYsTUFBTSxDQUFDLEVBQUUsSUFBSTBmLE1BQU0xZixNQUFNLENBQUMsRUFBRSxFQUFFO3dCQUMzQyxnQ0FBZ0M7d0JBQ2hDLElBQUksQ0FBQzVMLE1BQU0sR0FBR3NWO3dCQUNkLElBQUlrckIsZUFBZWxXLE9BQU8wTCxTQUFTLENBQUMxSyxNQUFNeGYsTUFBTSxDQUFDLEVBQUU7d0JBQ25ELElBQUkyMEIsZUFBZW5XLE9BQU8wTCxTQUFTLENBQUMxSyxNQUFNeGYsTUFBTSxDQUFDLEVBQUU7d0JBQ25ELElBQUksQ0FBQ3UwQixNQUFNLEdBQUd0bEMsS0FBS21MLEtBQUssQ0FBQ25MLEtBQUtpTCxHQUFHLENBQUN5NkIsY0FBY0QsZUFBZTt3QkFDL0QsSUFBSSxDQUFDSCxNQUFNLENBQUNwckIsU0FBUzt3QkFDckIsSUFBSUwsU0FBU3haLElBQUk0TyxPQUFPLENBQUNnSCxJQUFJdlEsQ0FBQyxFQUFFLElBQUksQ0FBQzQvQixNQUFNO3dCQUMzQyxJQUFJLENBQUNELFlBQVksR0FBR3JsQyxLQUFLc29CLEdBQUcsQ0FBQ21kLGNBQWNDO3dCQUMzQyxJQUFJenJCLFNBQVM3WixVQUFVNk8sT0FBTyxDQUFDZ0gsS0FBSyxJQUFJLENBQUNvdkIsWUFBWTt3QkFDckQsSUFBSUUsY0FBY2pXLE9BQU8yTCxTQUFTLENBQUMxSyxNQUFNMWYsTUFBTSxDQUFDLEVBQUU7d0JBQ2xELElBQUltSixTQUFTNVosVUFBVTZPLE9BQU8sQ0FBQytHLEtBQUt1dkI7d0JBQ3BDLElBQUlwbUMsSUFBSWEsS0FBS3lMLEdBQUcsQ0FBQ3VPLFFBQVFILFVBQVU3WixLQUFLeUwsR0FBRyxDQUFDd08sUUFBUUo7d0JBQ3BELElBQUkxYSxJQUFJLEdBQUc7NEJBQ1AsSUFBSSxDQUFDbW1DLE1BQU0sR0FBR3RsQyxLQUFLZzdCLEdBQUcsQ0FBQyxJQUFJLENBQUNzSyxNQUFNOzRCQUNsQ25tQyxJQUFJLENBQUNBO3dCQUNUO3dCQUNBLE9BQU9BO29CQUNYLE9BQU87d0JBQ0gsOENBQThDO3dCQUM5QyxJQUFJLENBQUM4RixNQUFNLEdBQUdtVjt3QkFDZCxJQUFJdXJCLGVBQWUsSUFBSSxDQUFDVixRQUFRLENBQUNoSyxTQUFTLENBQUMxSyxNQUFNMWYsTUFBTSxDQUFDLEVBQUU7d0JBQzFELElBQUkrMEIsZUFBZSxJQUFJLENBQUNYLFFBQVEsQ0FBQ2hLLFNBQVMsQ0FBQzFLLE1BQU0xZixNQUFNLENBQUMsRUFBRTt3QkFDMUQsSUFBSSxDQUFDeTBCLE1BQU0sR0FBR3RsQyxLQUFLbUwsS0FBSyxDQUFDbkwsS0FBS2lMLEdBQUcsQ0FBQzI2QixjQUFjRCxlQUFlO3dCQUMvRCxJQUFJLENBQUNMLE1BQU0sQ0FBQ3ByQixTQUFTO3dCQUNyQixJQUFJTCxTQUFTeFosSUFBSTRPLE9BQU8sQ0FBQytHLElBQUl0USxDQUFDLEVBQUUsSUFBSSxDQUFDNC9CLE1BQU07d0JBQzNDLElBQUksQ0FBQ0QsWUFBWSxHQUFHcmxDLEtBQUtzb0IsR0FBRyxDQUFDcWQsY0FBY0M7d0JBQzNDLElBQUk1ckIsU0FBUzVaLFVBQVU2TyxPQUFPLENBQUMrRyxLQUFLLElBQUksQ0FBQ3F2QixZQUFZO3dCQUNyRCxJQUFJRyxjQUFjLElBQUksQ0FBQ04sUUFBUSxDQUFDakssU0FBUyxDQUFDMUssTUFBTXhmLE1BQU0sQ0FBQyxFQUFFO3dCQUN6RCxJQUFJa0osU0FBUzdaLFVBQVU2TyxPQUFPLENBQUNnSCxLQUFLdXZCO3dCQUNwQyxJQUFJcm1DLElBQUlhLEtBQUt5TCxHQUFHLENBQUN3TyxRQUFRSixVQUFVN1osS0FBS3lMLEdBQUcsQ0FBQ3VPLFFBQVFIO3dCQUNwRCxJQUFJMWEsSUFBSSxHQUFHOzRCQUNQLElBQUksQ0FBQ21tQyxNQUFNLEdBQUd0bEMsS0FBS2c3QixHQUFHLENBQUMsSUFBSSxDQUFDc0ssTUFBTTs0QkFDbENubUMsSUFBSSxDQUFDQTt3QkFDVDt3QkFDQSxPQUFPQTtvQkFDWDtnQkFDSjtnQkFFQTZrQyxtQkFBbUJsOUIsU0FBUyxDQUFDKytCLE9BQU8sR0FBRyxTQUFTQyxJQUFJLEVBQUU5bUMsQ0FBQztvQkFDbkQsd0NBQXdDO29CQUN4QyxJQUFJZ1gsTUFBTTVWLFVBQVVtRixRQUFRO29CQUM1QixJQUFJMFEsTUFBTTdWLFVBQVVtRixRQUFRO29CQUM1QixJQUFJLENBQUM0L0IsUUFBUSxDQUFDcjdCLFlBQVksQ0FBQ2tNLEtBQUtoWDtvQkFDaEMsSUFBSSxDQUFDb21DLFFBQVEsQ0FBQ3Q3QixZQUFZLENBQUNtTSxLQUFLalg7b0JBQ2hDLE9BQVEsSUFBSSxDQUFDaUcsTUFBTTt3QkFDakIsS0FBSysvQjs0QkFDSDtnQ0FDSSxJQUFJYyxNQUFNO29DQUNOLElBQUlDLFFBQVExbEMsSUFBSWdQLFFBQVEsQ0FBQzJHLElBQUl0USxDQUFDLEVBQUUsSUFBSSxDQUFDNC9CLE1BQU07b0NBQzNDLElBQUlVLFFBQVEzbEMsSUFBSWdQLFFBQVEsQ0FBQzRHLElBQUl2USxDQUFDLEVBQUUxRixLQUFLZzdCLEdBQUcsQ0FBQyxJQUFJLENBQUNzSyxNQUFNO29DQUNwRCxJQUFJLENBQUN6MEIsTUFBTSxHQUFHLElBQUksQ0FBQ28wQixRQUFRLENBQUNsSyxVQUFVLENBQUNnTDtvQ0FDdkMsSUFBSSxDQUFDaDFCLE1BQU0sR0FBRyxJQUFJLENBQUNtMEIsUUFBUSxDQUFDbkssVUFBVSxDQUFDaUw7Z0NBQzNDO2dDQUNBLElBQUlULGNBQWMsSUFBSSxDQUFDTixRQUFRLENBQUNoSyxTQUFTLENBQUMsSUFBSSxDQUFDcHFCLE1BQU07Z0NBQ3JELElBQUkyMEIsY0FBYyxJQUFJLENBQUNOLFFBQVEsQ0FBQ2pLLFNBQVMsQ0FBQyxJQUFJLENBQUNscUIsTUFBTTtnQ0FDckQsSUFBSWlKLFNBQVM1WixVQUFVNk8sT0FBTyxDQUFDK0csS0FBS3V2QjtnQ0FDcEMsSUFBSXRyQixTQUFTN1osVUFBVTZPLE9BQU8sQ0FBQ2dILEtBQUt1dkI7Z0NBQ3BDLElBQUlTLE1BQU1qbUMsS0FBS3lMLEdBQUcsQ0FBQ3dPLFFBQVEsSUFBSSxDQUFDcXJCLE1BQU0sSUFBSXRsQyxLQUFLeUwsR0FBRyxDQUFDdU8sUUFBUSxJQUFJLENBQUNzckIsTUFBTTtnQ0FDdEUsT0FBT1c7NEJBQ1g7d0JBRUYsS0FBSzdyQjs0QkFDSDtnQ0FDSSxJQUFJUCxTQUFTeFosSUFBSTRPLE9BQU8sQ0FBQytHLElBQUl0USxDQUFDLEVBQUUsSUFBSSxDQUFDNC9CLE1BQU07Z0NBQzNDLElBQUl0ckIsU0FBUzVaLFVBQVU2TyxPQUFPLENBQUMrRyxLQUFLLElBQUksQ0FBQ3F2QixZQUFZO2dDQUNyRCxJQUFJUyxNQUFNO29DQUNOLElBQUlFLFFBQVEzbEMsSUFBSWdQLFFBQVEsQ0FBQzRHLElBQUl2USxDQUFDLEVBQUUxRixLQUFLZzdCLEdBQUcsQ0FBQ25oQjtvQ0FDekMsSUFBSSxDQUFDaEosTUFBTSxHQUFHLENBQUM7b0NBQ2YsSUFBSSxDQUFDRSxNQUFNLEdBQUcsSUFBSSxDQUFDbTBCLFFBQVEsQ0FBQ25LLFVBQVUsQ0FBQ2lMO2dDQUMzQztnQ0FDQSxJQUFJUixjQUFjLElBQUksQ0FBQ04sUUFBUSxDQUFDakssU0FBUyxDQUFDLElBQUksQ0FBQ2xxQixNQUFNO2dDQUNyRCxJQUFJa0osU0FBUzdaLFVBQVU2TyxPQUFPLENBQUNnSCxLQUFLdXZCO2dDQUNwQyxJQUFJUyxNQUFNam1DLEtBQUt5TCxHQUFHLENBQUN3TyxRQUFRSixVQUFVN1osS0FBS3lMLEdBQUcsQ0FBQ3VPLFFBQVFIO2dDQUN0RCxPQUFPb3NCOzRCQUNYO3dCQUVGLEtBQUsxckI7NEJBQ0g7Z0NBQ0ksSUFBSVYsU0FBU3haLElBQUk0TyxPQUFPLENBQUNnSCxJQUFJdlEsQ0FBQyxFQUFFLElBQUksQ0FBQzQvQixNQUFNO2dDQUMzQyxJQUFJcnJCLFNBQVM3WixVQUFVNk8sT0FBTyxDQUFDZ0gsS0FBSyxJQUFJLENBQUNvdkIsWUFBWTtnQ0FDckQsSUFBSVMsTUFBTTtvQ0FDTixJQUFJQyxRQUFRMWxDLElBQUlnUCxRQUFRLENBQUMyRyxJQUFJdFEsQ0FBQyxFQUFFMUYsS0FBS2c3QixHQUFHLENBQUNuaEI7b0NBQ3pDLElBQUksQ0FBQzlJLE1BQU0sR0FBRyxDQUFDO29DQUNmLElBQUksQ0FBQ0YsTUFBTSxHQUFHLElBQUksQ0FBQ28wQixRQUFRLENBQUNsSyxVQUFVLENBQUNnTDtnQ0FDM0M7Z0NBQ0EsSUFBSVIsY0FBYyxJQUFJLENBQUNOLFFBQVEsQ0FBQ2hLLFNBQVMsQ0FBQyxJQUFJLENBQUNwcUIsTUFBTTtnQ0FDckQsSUFBSW1KLFNBQVM1WixVQUFVNk8sT0FBTyxDQUFDK0csS0FBS3V2QjtnQ0FDcEMsSUFBSVUsTUFBTWptQyxLQUFLeUwsR0FBRyxDQUFDdU8sUUFBUUgsVUFBVTdaLEtBQUt5TCxHQUFHLENBQUN3TyxRQUFRSjtnQ0FDdEQsT0FBT29zQjs0QkFDWDt3QkFFRjs0QkFDRTFqQyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDOzRCQUN6QixJQUFJeWhDLE1BQU07Z0NBQ04sSUFBSSxDQUFDajFCLE1BQU0sR0FBRyxDQUFDO2dDQUNmLElBQUksQ0FBQ0UsTUFBTSxHQUFHLENBQUM7NEJBQ25COzRCQUNBLE9BQU87b0JBQ1g7Z0JBQ0o7Z0JBRUFpekIsbUJBQW1CbDlCLFNBQVMsQ0FBQzQ5QixpQkFBaUIsR0FBRyxTQUFTMWxDLENBQUM7b0JBQ3ZELE9BQU8sSUFBSSxDQUFDNm1DLE9BQU8sQ0FBQyxNQUFNN21DO2dCQUM5QjtnQkFFQWdsQyxtQkFBbUJsOUIsU0FBUyxDQUFDaVAsUUFBUSxHQUFHLFNBQVMvVyxDQUFDO29CQUM5QyxPQUFPLElBQUksQ0FBQzZtQyxPQUFPLENBQUMsT0FBTzdtQztnQkFDL0I7WUFHQTtZQUFFO2dCQUFDLGVBQWM7Z0JBQUUsbUJBQWtCO2dCQUFHLG1CQUFrQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxtQkFBa0I7Z0JBQUcsdUJBQXNCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLG1CQUFrQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGNBQWE7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNPLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUMzVixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBRzJCO2dCQUVqQixJQUFJdUMsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5COztDQUVDLEdBQ0QsU0FBU1csTUFBTVosQ0FBQyxFQUFFdXRCLENBQUMsRUFBRXhpQixDQUFDLEVBQUU0ckIsQ0FBQztvQkFDckIsSUFBSSxPQUFPMzJCLE1BQU0sWUFBWUEsTUFBTSxNQUFNO3dCQUNyQyxJQUFJLENBQUN1ZSxFQUFFLEdBQUc3ZCxLQUFLeUYsS0FBSyxDQUFDbkc7d0JBQ3JCLElBQUksQ0FBQ3dlLEVBQUUsR0FBRzlkLEtBQUt5RixLQUFLLENBQUNvbkI7b0JBQ3pCLE9BQU8sSUFBSSxPQUFPdnRCLE1BQU0sVUFBVTt3QkFDOUIsSUFBSSxDQUFDdWUsRUFBRSxHQUFHN2QsS0FBS2tvQixHQUFHLENBQUM1b0IsR0FBRytLO3dCQUN0QixJQUFJLENBQUN5VCxFQUFFLEdBQUc5ZCxLQUFLa29CLEdBQUcsQ0FBQzJFLEdBQUdvSjtvQkFDMUIsT0FBTzt3QkFDSCxJQUFJLENBQUNwWSxFQUFFLEdBQUc3ZCxLQUFLc0QsSUFBSTt3QkFDbkIsSUFBSSxDQUFDd2EsRUFBRSxHQUFHOWQsS0FBS3NELElBQUk7b0JBQ3ZCO2dCQUNKO2dCQUVBcEQsTUFBTTRHLFNBQVMsQ0FBQ3N4QixRQUFRLEdBQUc7b0JBQ3ZCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQyxJQUFJO2dCQUM5QjtnQkFFQXA0QixNQUFNb0UsT0FBTyxHQUFHLFNBQVNsRixDQUFDO29CQUN0QixPQUFPQSxLQUFLWSxLQUFLc0UsT0FBTyxDQUFDbEYsRUFBRXllLEVBQUUsS0FBSzdkLEtBQUtzRSxPQUFPLENBQUNsRixFQUFFMGUsRUFBRTtnQkFDdkQ7Z0JBRUE1ZCxNQUFNbUUsTUFBTSxHQUFHLFNBQVNqRixDQUFDO29CQUNyQixJQUFJLENBQUNtRCxTQUFTO29CQUNkLElBQUksQ0FBQ3JDLE1BQU1vRSxPQUFPLENBQUNsRixJQUFJO3dCQUNuQmlELFVBQVVJLFFBQU84ckIsS0FBSyxDQUFDbnZCO3dCQUN2QixNQUFNLElBQUlLLE1BQU07b0JBQ3BCO2dCQUNKO2dCQUVBUyxNQUFNNEcsU0FBUyxDQUFDaUQsR0FBRyxHQUFHLFNBQVN6SyxDQUFDLEVBQUV1dEIsQ0FBQyxFQUFFeGlCLENBQUMsRUFBRTRyQixDQUFDO29CQUNyQyxJQUFJLE9BQU8zMkIsTUFBTSxZQUFZLE9BQU91dEIsTUFBTSxZQUFZLE9BQU94aUIsTUFBTSxZQUFZLE9BQU80ckIsTUFBTSxVQUFVO3dCQUNsRyxJQUFJLENBQUNwWSxFQUFFLENBQUM5VCxHQUFHLENBQUN6SyxHQUFHK0s7d0JBQ2YsSUFBSSxDQUFDeVQsRUFBRSxDQUFDL1QsR0FBRyxDQUFDOGlCLEdBQUdvSjtvQkFDbkIsT0FBTyxJQUFJLE9BQU8zMkIsTUFBTSxZQUFZLE9BQU91dEIsTUFBTSxVQUFVO3dCQUN2RCxJQUFJLENBQUNoUCxFQUFFLENBQUM5VCxHQUFHLENBQUN6Szt3QkFDWixJQUFJLENBQUN3ZSxFQUFFLENBQUMvVCxHQUFHLENBQUM4aUI7b0JBQ2hCLE9BQU8sSUFBSSxPQUFPdnRCLE1BQU0sVUFBVTt3QkFDOUJpRCxXQUFXckMsTUFBTW1FLE1BQU0sQ0FBQy9FO3dCQUN4QixJQUFJLENBQUN1ZSxFQUFFLENBQUM5VCxHQUFHLENBQUN6SyxFQUFFdWUsRUFBRTt3QkFDaEIsSUFBSSxDQUFDQyxFQUFFLENBQUMvVCxHQUFHLENBQUN6SyxFQUFFd2UsRUFBRTtvQkFDcEIsT0FBTzt3QkFDSHZiLFdBQVdFLFFBQU80QixNQUFNLENBQUM7b0JBQzdCO2dCQUNKO2dCQUVBbkUsTUFBTTRHLFNBQVMsQ0FBQzRTLFdBQVcsR0FBRztvQkFDMUIsSUFBSSxDQUFDbUUsRUFBRSxDQUFDMEIsQ0FBQyxHQUFHO29CQUNaLElBQUksQ0FBQ3pCLEVBQUUsQ0FBQ3lCLENBQUMsR0FBRztvQkFDWixJQUFJLENBQUMxQixFQUFFLENBQUM0QixDQUFDLEdBQUc7b0JBQ1osSUFBSSxDQUFDM0IsRUFBRSxDQUFDMkIsQ0FBQyxHQUFHO2dCQUNoQjtnQkFFQXZmLE1BQU00RyxTQUFTLENBQUNvQixPQUFPLEdBQUc7b0JBQ3RCLElBQUksQ0FBQzJWLEVBQUUsQ0FBQzBCLENBQUMsR0FBRztvQkFDWixJQUFJLENBQUN6QixFQUFFLENBQUN5QixDQUFDLEdBQUc7b0JBQ1osSUFBSSxDQUFDMUIsRUFBRSxDQUFDNEIsQ0FBQyxHQUFHO29CQUNaLElBQUksQ0FBQzNCLEVBQUUsQ0FBQzJCLENBQUMsR0FBRztnQkFDaEI7Z0JBRUF2ZixNQUFNNEcsU0FBUyxDQUFDaVgsVUFBVSxHQUFHO29CQUN6QixJQUFJemUsSUFBSSxJQUFJLENBQUN1ZSxFQUFFLENBQUMwQixDQUFDO29CQUNqQixJQUFJc04sSUFBSSxJQUFJLENBQUMvTyxFQUFFLENBQUN5QixDQUFDO29CQUNqQixJQUFJbFYsSUFBSSxJQUFJLENBQUN3VCxFQUFFLENBQUM0QixDQUFDO29CQUNqQixJQUFJd1csSUFBSSxJQUFJLENBQUNuWSxFQUFFLENBQUMyQixDQUFDO29CQUNqQixJQUFJeW1CLE1BQU01bUMsSUFBSTIyQixJQUFJcEosSUFBSXhpQjtvQkFDdEIsSUFBSTY3QixPQUFPLEdBQUc7d0JBQ1ZBLE1BQU0sSUFBSUE7b0JBQ2Q7b0JBQ0EsSUFBSUMsTUFBTSxJQUFJam1DO29CQUNkaW1DLElBQUl0b0IsRUFBRSxDQUFDMEIsQ0FBQyxHQUFHMm1CLE1BQU1qUTtvQkFDakJrUSxJQUFJcm9CLEVBQUUsQ0FBQ3lCLENBQUMsR0FBRyxDQUFDMm1CLE1BQU1yWjtvQkFDbEJzWixJQUFJdG9CLEVBQUUsQ0FBQzRCLENBQUMsR0FBRyxDQUFDeW1CLE1BQU03N0I7b0JBQ2xCODdCLElBQUlyb0IsRUFBRSxDQUFDMkIsQ0FBQyxHQUFHeW1CLE1BQU01bUM7b0JBQ2pCLE9BQU82bUM7Z0JBQ1g7Z0JBRUE7OztDQUdDLEdBQ0RqbUMsTUFBTTRHLFNBQVMsQ0FBQzZ6QixLQUFLLEdBQUcsU0FBU252QixDQUFDO29CQUM5QmpKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCLElBQUlsTSxJQUFJLElBQUksQ0FBQ3VlLEVBQUUsQ0FBQzBCLENBQUM7b0JBQ2pCLElBQUlzTixJQUFJLElBQUksQ0FBQy9PLEVBQUUsQ0FBQ3lCLENBQUM7b0JBQ2pCLElBQUlsVixJQUFJLElBQUksQ0FBQ3dULEVBQUUsQ0FBQzRCLENBQUM7b0JBQ2pCLElBQUl3VyxJQUFJLElBQUksQ0FBQ25ZLEVBQUUsQ0FBQzJCLENBQUM7b0JBQ2pCLElBQUl5bUIsTUFBTTVtQyxJQUFJMjJCLElBQUlwSixJQUFJeGlCO29CQUN0QixJQUFJNjdCLE9BQU8sR0FBRzt3QkFDVkEsTUFBTSxJQUFJQTtvQkFDZDtvQkFDQSxJQUFJdDZCLElBQUk1TCxLQUFLc0QsSUFBSTtvQkFDakJzSSxFQUFFMlQsQ0FBQyxHQUFHMm1CLE1BQU9qUSxDQUFBQSxJQUFJenFCLEVBQUUrVCxDQUFDLEdBQUdzTixJQUFJcmhCLEVBQUVpVSxDQUFDLEFBQURBO29CQUM3QjdULEVBQUU2VCxDQUFDLEdBQUd5bUIsTUFBTzVtQyxDQUFBQSxJQUFJa00sRUFBRWlVLENBQUMsR0FBR3BWLElBQUltQixFQUFFK1QsQ0FBQyxBQUFEQTtvQkFDN0IsT0FBTzNUO2dCQUNYO2dCQUVBOzs7Q0FHQyxHQUNEMUwsTUFBTTRNLEdBQUcsR0FBRyxTQUFTczVCLEVBQUUsRUFBRTU2QixDQUFDO29CQUN0QixJQUFJQSxLQUFLLE9BQU9BLEtBQUssT0FBT0EsR0FBRzt3QkFDM0JqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO3dCQUN2QixJQUFJK1QsSUFBSTZtQixHQUFHdm9CLEVBQUUsQ0FBQzBCLENBQUMsR0FBRy9ULEVBQUUrVCxDQUFDLEdBQUc2bUIsR0FBR3RvQixFQUFFLENBQUN5QixDQUFDLEdBQUcvVCxFQUFFaVUsQ0FBQzt3QkFDckMsSUFBSUEsSUFBSTJtQixHQUFHdm9CLEVBQUUsQ0FBQzRCLENBQUMsR0FBR2pVLEVBQUUrVCxDQUFDLEdBQUc2bUIsR0FBR3RvQixFQUFFLENBQUMyQixDQUFDLEdBQUdqVSxFQUFFaVUsQ0FBQzt3QkFDckMsT0FBT3pmLEtBQUtrb0IsR0FBRyxDQUFDM0ksR0FBR0U7b0JBQ3ZCLE9BQU8sSUFBSWpVLEtBQUssUUFBUUEsS0FBSyxRQUFRQSxHQUFHO3dCQUNwQyxRQUFRO3dCQUNSakosV0FBV3JDLE1BQU1tRSxNQUFNLENBQUNtSDt3QkFDeEIsT0FBTyxJQUFJdEwsTUFBTUYsS0FBSzhNLEdBQUcsQ0FBQ3M1QixJQUFJNTZCLEVBQUVxUyxFQUFFLEdBQUc3ZCxLQUFLOE0sR0FBRyxDQUFDczVCLElBQUk1NkIsRUFBRXNTLEVBQUU7b0JBQzFEO29CQUNBdmIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQztnQkFDN0I7Z0JBRUFuRSxNQUFNK08sT0FBTyxHQUFHLFNBQVNtM0IsRUFBRSxFQUFFNTZCLENBQUM7b0JBQzFCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkIsSUFBSStULElBQUk2bUIsR0FBR3ZvQixFQUFFLENBQUMwQixDQUFDLEdBQUcvVCxFQUFFK1QsQ0FBQyxHQUFHNm1CLEdBQUd0b0IsRUFBRSxDQUFDeUIsQ0FBQyxHQUFHL1QsRUFBRWlVLENBQUM7b0JBQ3JDLElBQUlBLElBQUkybUIsR0FBR3ZvQixFQUFFLENBQUM0QixDQUFDLEdBQUdqVSxFQUFFK1QsQ0FBQyxHQUFHNm1CLEdBQUd0b0IsRUFBRSxDQUFDMkIsQ0FBQyxHQUFHalUsRUFBRWlVLENBQUM7b0JBQ3JDLE9BQU96ZixLQUFLa29CLEdBQUcsQ0FBQzNJLEdBQUdFO2dCQUN2QjtnQkFFQXZmLE1BQU0wWixRQUFRLEdBQUcsU0FBU3dzQixFQUFFLEVBQUU1NkIsQ0FBQyxFQUFFNjZCLENBQUM7b0JBQzlCOWpDLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCLElBQUkrVCxJQUFJNm1CLEdBQUd2b0IsRUFBRSxDQUFDMEIsQ0FBQyxHQUFHL1QsRUFBRStULENBQUMsR0FBRzZtQixHQUFHdG9CLEVBQUUsQ0FBQ3lCLENBQUMsR0FBRy9ULEVBQUVpVSxDQUFDO29CQUNyQyxJQUFJQSxJQUFJMm1CLEdBQUd2b0IsRUFBRSxDQUFDNEIsQ0FBQyxHQUFHalUsRUFBRStULENBQUMsR0FBRzZtQixHQUFHdG9CLEVBQUUsQ0FBQzJCLENBQUMsR0FBR2pVLEVBQUVpVSxDQUFDO29CQUNyQyxPQUFPNG1CLEVBQUV0OEIsR0FBRyxDQUFDd1YsR0FBR0U7Z0JBQ3BCO2dCQUVBdmYsTUFBTW9tQyxRQUFRLEdBQUcsU0FBU0YsRUFBRSxFQUFFNTZCLENBQUM7b0JBQzNCakosV0FBV3JDLE1BQU1tRSxNQUFNLENBQUNtSDtvQkFDeEIsT0FBTyxJQUFJdEwsTUFBTUYsS0FBSzhNLEdBQUcsQ0FBQ3M1QixJQUFJNTZCLEVBQUVxUyxFQUFFLEdBQUc3ZCxLQUFLOE0sR0FBRyxDQUFDczVCLElBQUk1NkIsRUFBRXNTLEVBQUU7b0JBQ3REdmIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQztnQkFDN0I7Z0JBRUE7Ozs7Q0FJQyxHQUNEbkUsTUFBTXFtQyxJQUFJLEdBQUcsU0FBU0gsRUFBRSxFQUFFNTZCLENBQUM7b0JBQ3ZCLElBQUlBLEtBQUssT0FBT0EsS0FBSyxPQUFPQSxHQUFHO3dCQUMzQixPQUFPO3dCQUNQakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDt3QkFDdkIsT0FBT3hMLEtBQUtrb0IsR0FBRyxDQUFDbG9CLEtBQUt5TCxHQUFHLENBQUNELEdBQUc0NkIsR0FBR3ZvQixFQUFFLEdBQUc3ZCxLQUFLeUwsR0FBRyxDQUFDRCxHQUFHNDZCLEdBQUd0b0IsRUFBRTtvQkFDekQsT0FBTyxJQUFJdFMsS0FBSyxRQUFRQSxLQUFLLFFBQVFBLEdBQUc7d0JBQ3BDLFFBQVE7d0JBQ1JqSixXQUFXckMsTUFBTW1FLE1BQU0sQ0FBQ21IO3dCQUN4QixJQUFJZzdCLEtBQUt4bUMsS0FBS2tvQixHQUFHLENBQUNsb0IsS0FBS3lMLEdBQUcsQ0FBQzI2QixHQUFHdm9CLEVBQUUsRUFBRXJTLEVBQUVxUyxFQUFFLEdBQUc3ZCxLQUFLeUwsR0FBRyxDQUFDMjZCLEdBQUd0b0IsRUFBRSxFQUFFdFMsRUFBRXFTLEVBQUU7d0JBQzdELElBQUk0b0IsS0FBS3ptQyxLQUFLa29CLEdBQUcsQ0FBQ2xvQixLQUFLeUwsR0FBRyxDQUFDMjZCLEdBQUd2b0IsRUFBRSxFQUFFclMsRUFBRXNTLEVBQUUsR0FBRzlkLEtBQUt5TCxHQUFHLENBQUMyNkIsR0FBR3RvQixFQUFFLEVBQUV0UyxFQUFFc1MsRUFBRTt3QkFDN0QsT0FBTyxJQUFJNWQsTUFBTXNtQyxJQUFJQztvQkFDekI7b0JBQ0Fsa0MsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQztnQkFDN0I7Z0JBRUFuRSxNQUFNbVAsUUFBUSxHQUFHLFNBQVMrMkIsRUFBRSxFQUFFNTZCLENBQUM7b0JBQzNCakosV0FBV3JDLE1BQU1tRSxNQUFNLENBQUMraEM7b0JBQ3hCN2pDLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCLE9BQU94TCxLQUFLa29CLEdBQUcsQ0FBQ2xvQixLQUFLeUwsR0FBRyxDQUFDRCxHQUFHNDZCLEdBQUd2b0IsRUFBRSxHQUFHN2QsS0FBS3lMLEdBQUcsQ0FBQ0QsR0FBRzQ2QixHQUFHdG9CLEVBQUU7Z0JBQ3pEO2dCQUVBNWQsTUFBTXdtQyxTQUFTLEdBQUcsU0FBU04sRUFBRSxFQUFFNTZCLENBQUM7b0JBQzVCakosV0FBV3JDLE1BQU1tRSxNQUFNLENBQUMraEM7b0JBQ3hCN2pDLFdBQVdyQyxNQUFNbUUsTUFBTSxDQUFDbUg7b0JBQ3hCLElBQUlnN0IsS0FBS3htQyxLQUFLa29CLEdBQUcsQ0FBQ2xvQixLQUFLeUwsR0FBRyxDQUFDMjZCLEdBQUd2b0IsRUFBRSxFQUFFclMsRUFBRXFTLEVBQUUsR0FBRzdkLEtBQUt5TCxHQUFHLENBQUMyNkIsR0FBR3RvQixFQUFFLEVBQUV0UyxFQUFFcVMsRUFBRTtvQkFDN0QsSUFBSTRvQixLQUFLem1DLEtBQUtrb0IsR0FBRyxDQUFDbG9CLEtBQUt5TCxHQUFHLENBQUMyNkIsR0FBR3ZvQixFQUFFLEVBQUVyUyxFQUFFc1MsRUFBRSxHQUFHOWQsS0FBS3lMLEdBQUcsQ0FBQzI2QixHQUFHdG9CLEVBQUUsRUFBRXRTLEVBQUVzUyxFQUFFO29CQUM3RCxPQUFPLElBQUk1ZCxNQUFNc21DLElBQUlDO2dCQUN6QjtnQkFFQXZtQyxNQUFNdWhCLEdBQUcsR0FBRyxTQUFTMmtCLEVBQUU7b0JBQ25CN2pDLFdBQVdyQyxNQUFNbUUsTUFBTSxDQUFDK2hDO29CQUN4QixPQUFPLElBQUlsbUMsTUFBTUYsS0FBS3loQixHQUFHLENBQUMya0IsR0FBR3ZvQixFQUFFLEdBQUc3ZCxLQUFLeWhCLEdBQUcsQ0FBQzJrQixHQUFHdG9CLEVBQUU7Z0JBQ3BEO2dCQUVBNWQsTUFBTWdMLEdBQUcsR0FBRyxTQUFTeTdCLEdBQUcsRUFBRUMsR0FBRztvQkFDekJya0MsV0FBV3JDLE1BQU1tRSxNQUFNLENBQUNzaUM7b0JBQ3hCcGtDLFdBQVdyQyxNQUFNbUUsTUFBTSxDQUFDdWlDO29CQUN4QixPQUFPLElBQUkxbUMsTUFBTUYsS0FBS2tMLEdBQUcsQ0FBQ3k3QixJQUFJOW9CLEVBQUUsR0FBRytvQixJQUFJL29CLEVBQUUsR0FBRzdkLEtBQUtrTCxHQUFHLENBQUN5N0IsSUFBSTdvQixFQUFFLEdBQUc4b0IsSUFBSTlvQixFQUFFO2dCQUN4RTtZQUdBO1lBQUU7Z0JBQUMsa0JBQWlCO2dCQUFHLFVBQVM7Z0JBQUcsVUFBUztZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU3ZlLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNwRixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBRzRCO2dCQUVqQixJQUFJc0MsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlVLE9BQU9WLFNBQVE7Z0JBRW5COztDQUVDLEdBQ0QsU0FBU1ksTUFBTWIsQ0FBQyxFQUFFdXRCLENBQUMsRUFBRXhpQixDQUFDO29CQUNsQixJQUFJLE9BQU8vSyxNQUFNLFlBQVlBLE1BQU0sTUFBTTt3QkFDckMsSUFBSSxDQUFDdWUsRUFBRSxHQUFHNWQsS0FBS3dGLEtBQUssQ0FBQ25HO3dCQUNyQixJQUFJLENBQUN3ZSxFQUFFLEdBQUc3ZCxLQUFLd0YsS0FBSyxDQUFDb25CO3dCQUNyQixJQUFJLENBQUNnYSxFQUFFLEdBQUc1bUMsS0FBS3dGLEtBQUssQ0FBQzRFO29CQUN6QixPQUFPO3dCQUNILElBQUksQ0FBQ3dULEVBQUUsR0FBRzVkO3dCQUNWLElBQUksQ0FBQzZkLEVBQUUsR0FBRzdkO3dCQUNWLElBQUksQ0FBQzRtQyxFQUFFLEdBQUc1bUM7b0JBQ2Q7Z0JBQ0o7Z0JBRUFFLE1BQU0yRyxTQUFTLENBQUNzeEIsUUFBUSxHQUFHO29CQUN2QixPQUFPQyxLQUFLQyxTQUFTLENBQUMsSUFBSTtnQkFDOUI7Z0JBRUFuNEIsTUFBTW1FLE9BQU8sR0FBRyxTQUFTbEYsQ0FBQztvQkFDdEIsT0FBT0EsS0FBS2EsS0FBS3FFLE9BQU8sQ0FBQ2xGLEVBQUV5ZSxFQUFFLEtBQUs1ZCxLQUFLcUUsT0FBTyxDQUFDbEYsRUFBRTBlLEVBQUUsS0FBSzdkLEtBQUtxRSxPQUFPLENBQUNsRixFQUFFeW5DLEVBQUU7Z0JBQzdFO2dCQUVBMW1DLE1BQU1rRSxNQUFNLEdBQUcsU0FBU2pGLENBQUM7b0JBQ3JCLElBQUksQ0FBQ21ELFNBQVM7b0JBQ2QsSUFBSSxDQUFDcEMsTUFBTW1FLE9BQU8sQ0FBQ2xGLElBQUk7d0JBQ25CaUQsVUFBVUksUUFBTzhyQixLQUFLLENBQUNudkI7d0JBQ3ZCLE1BQU0sSUFBSUssTUFBTTtvQkFDcEI7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRFUsTUFBTTJHLFNBQVMsQ0FBQ29CLE9BQU8sR0FBRztvQkFDdEIsSUFBSSxDQUFDMlYsRUFBRSxDQUFDM1YsT0FBTztvQkFDZixJQUFJLENBQUM0VixFQUFFLENBQUM1VixPQUFPO29CQUNmLElBQUksQ0FBQzIrQixFQUFFLENBQUMzK0IsT0FBTztvQkFDZixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUE7Ozs7OztDQU1DLEdBQ0QvSCxNQUFNMkcsU0FBUyxDQUFDZ2dDLE9BQU8sR0FBRyxTQUFTdDdCLENBQUM7b0JBQ2hDLElBQUkwNkIsTUFBTWptQyxLQUFLd0wsR0FBRyxDQUFDLElBQUksQ0FBQ29TLEVBQUUsRUFBRTVkLEtBQUtrTCxLQUFLLENBQUMsSUFBSSxDQUFDMlMsRUFBRSxFQUFFLElBQUksQ0FBQytvQixFQUFFO29CQUN2RCxJQUFJWCxPQUFPLEdBQUc7d0JBQ1ZBLE1BQU0sSUFBSUE7b0JBQ2Q7b0JBQ0EsSUFBSWhuQyxJQUFJLElBQUllO29CQUNaZixFQUFFcWdCLENBQUMsR0FBRzJtQixNQUFNam1DLEtBQUt3TCxHQUFHLENBQUNELEdBQUd2TCxLQUFLa0wsS0FBSyxDQUFDLElBQUksQ0FBQzJTLEVBQUUsRUFBRSxJQUFJLENBQUMrb0IsRUFBRTtvQkFDbkQzbkMsRUFBRXVnQixDQUFDLEdBQUd5bUIsTUFBTWptQyxLQUFLd0wsR0FBRyxDQUFDLElBQUksQ0FBQ29TLEVBQUUsRUFBRTVkLEtBQUtrTCxLQUFLLENBQUNLLEdBQUcsSUFBSSxDQUFDcTdCLEVBQUU7b0JBQ25EM25DLEVBQUU2bkMsQ0FBQyxHQUFHYixNQUFNam1DLEtBQUt3TCxHQUFHLENBQUMsSUFBSSxDQUFDb1MsRUFBRSxFQUFFNWQsS0FBS2tMLEtBQUssQ0FBQyxJQUFJLENBQUMyUyxFQUFFLEVBQUV0UztvQkFDbEQsT0FBT3RNO2dCQUNYO2dCQUVBOzs7Ozs7OztDQVFDLEdBQ0RpQixNQUFNMkcsU0FBUyxDQUFDa2dDLE9BQU8sR0FBRyxTQUFTeDdCLENBQUM7b0JBQ2hDLElBQUl5N0IsTUFBTSxJQUFJLENBQUNwcEIsRUFBRSxDQUFDMEIsQ0FBQztvQkFDbkIsSUFBSTJuQixNQUFNLElBQUksQ0FBQ3BwQixFQUFFLENBQUN5QixDQUFDO29CQUNuQixJQUFJNG5CLE1BQU0sSUFBSSxDQUFDdHBCLEVBQUUsQ0FBQzRCLENBQUM7b0JBQ25CLElBQUkybkIsTUFBTSxJQUFJLENBQUN0cEIsRUFBRSxDQUFDMkIsQ0FBQztvQkFDbkIsSUFBSXltQixNQUFNZSxNQUFNRyxNQUFNRixNQUFNQztvQkFDNUIsSUFBSWpCLE9BQU8sR0FBRzt3QkFDVkEsTUFBTSxJQUFJQTtvQkFDZDtvQkFDQSxJQUFJaG5DLElBQUljLEtBQUtzRCxJQUFJO29CQUNqQnBFLEVBQUVxZ0IsQ0FBQyxHQUFHMm1CLE1BQU9rQixDQUFBQSxNQUFNNTdCLEVBQUUrVCxDQUFDLEdBQUcybkIsTUFBTTE3QixFQUFFaVUsQ0FBQyxBQUFEQTtvQkFDakN2Z0IsRUFBRXVnQixDQUFDLEdBQUd5bUIsTUFBT2UsQ0FBQUEsTUFBTXo3QixFQUFFaVUsQ0FBQyxHQUFHMG5CLE1BQU0zN0IsRUFBRStULENBQUMsQUFBREE7b0JBQ2pDLE9BQU9yZ0I7Z0JBQ1g7Z0JBRUE7Ozs7O0NBS0MsR0FDRGlCLE1BQU0yRyxTQUFTLENBQUN1Z0MsWUFBWSxHQUFHLFNBQVNDLENBQUM7b0JBQ3JDLElBQUlob0MsSUFBSSxJQUFJLENBQUN1ZSxFQUFFLENBQUMwQixDQUFDO29CQUNqQixJQUFJc04sSUFBSSxJQUFJLENBQUMvTyxFQUFFLENBQUN5QixDQUFDO29CQUNqQixJQUFJbFYsSUFBSSxJQUFJLENBQUN3VCxFQUFFLENBQUM0QixDQUFDO29CQUNqQixJQUFJd1csSUFBSSxJQUFJLENBQUNuWSxFQUFFLENBQUMyQixDQUFDO29CQUNqQixJQUFJeW1CLE1BQU01bUMsSUFBSTIyQixJQUFJcEosSUFBSXhpQjtvQkFDdEIsSUFBSTY3QixPQUFPLEdBQUc7d0JBQ1ZBLE1BQU0sSUFBSUE7b0JBQ2Q7b0JBQ0FvQixFQUFFenBCLEVBQUUsQ0FBQzBCLENBQUMsR0FBRzJtQixNQUFNalE7b0JBQ2ZxUixFQUFFeHBCLEVBQUUsQ0FBQ3lCLENBQUMsR0FBRyxDQUFDMm1CLE1BQU1yWjtvQkFDaEJ5YSxFQUFFenBCLEVBQUUsQ0FBQ2twQixDQUFDLEdBQUc7b0JBQ1RPLEVBQUV6cEIsRUFBRSxDQUFDNEIsQ0FBQyxHQUFHLENBQUN5bUIsTUFBTTc3QjtvQkFDaEJpOUIsRUFBRXhwQixFQUFFLENBQUMyQixDQUFDLEdBQUd5bUIsTUFBTTVtQztvQkFDZmdvQyxFQUFFeHBCLEVBQUUsQ0FBQ2lwQixDQUFDLEdBQUc7b0JBQ1RPLEVBQUVULEVBQUUsQ0FBQ3RuQixDQUFDLEdBQUc7b0JBQ1QrbkIsRUFBRVQsRUFBRSxDQUFDcG5CLENBQUMsR0FBRztvQkFDVDZuQixFQUFFVCxFQUFFLENBQUNFLENBQUMsR0FBRztnQkFDYjtnQkFFQTs7Ozs7Q0FLQyxHQUNENW1DLE1BQU0yRyxTQUFTLENBQUN5Z0MsZUFBZSxHQUFHLFNBQVNELENBQUM7b0JBQ3hDLElBQUlwQixNQUFNam1DLEtBQUt3TCxHQUFHLENBQUMsSUFBSSxDQUFDb1MsRUFBRSxFQUFFNWQsS0FBS2tMLEtBQUssQ0FBQyxJQUFJLENBQUMyUyxFQUFFLEVBQUUsSUFBSSxDQUFDK29CLEVBQUU7b0JBQ3ZELElBQUlYLE9BQU8sR0FBRzt3QkFDVkEsTUFBTSxJQUFJQTtvQkFDZDtvQkFDQSxJQUFJZSxNQUFNLElBQUksQ0FBQ3BwQixFQUFFLENBQUMwQixDQUFDO29CQUNuQixJQUFJMm5CLE1BQU0sSUFBSSxDQUFDcHBCLEVBQUUsQ0FBQ3lCLENBQUM7b0JBQ25CLElBQUlpb0IsTUFBTSxJQUFJLENBQUNYLEVBQUUsQ0FBQ3RuQixDQUFDO29CQUNuQixJQUFJNm5CLE1BQU0sSUFBSSxDQUFDdHBCLEVBQUUsQ0FBQzJCLENBQUM7b0JBQ25CLElBQUlnb0IsTUFBTSxJQUFJLENBQUNaLEVBQUUsQ0FBQ3BuQixDQUFDO29CQUNuQixJQUFJaW9CLE1BQU0sSUFBSSxDQUFDYixFQUFFLENBQUNFLENBQUM7b0JBQ25CTyxFQUFFenBCLEVBQUUsQ0FBQzBCLENBQUMsR0FBRzJtQixNQUFPa0IsQ0FBQUEsTUFBTU0sTUFBTUQsTUFBTUEsR0FBRTtvQkFDcENILEVBQUV6cEIsRUFBRSxDQUFDNEIsQ0FBQyxHQUFHeW1CLE1BQU9zQixDQUFBQSxNQUFNQyxNQUFNUCxNQUFNUSxHQUFFO29CQUNwQ0osRUFBRXpwQixFQUFFLENBQUNrcEIsQ0FBQyxHQUFHYixNQUFPZ0IsQ0FBQUEsTUFBTU8sTUFBTUQsTUFBTUosR0FBRTtvQkFDcENFLEVBQUV4cEIsRUFBRSxDQUFDeUIsQ0FBQyxHQUFHK25CLEVBQUV6cEIsRUFBRSxDQUFDNEIsQ0FBQztvQkFDZjZuQixFQUFFeHBCLEVBQUUsQ0FBQzJCLENBQUMsR0FBR3ltQixNQUFPZSxDQUFBQSxNQUFNUyxNQUFNRixNQUFNQSxHQUFFO29CQUNwQ0YsRUFBRXhwQixFQUFFLENBQUNpcEIsQ0FBQyxHQUFHYixNQUFPc0IsQ0FBQUEsTUFBTU4sTUFBTUQsTUFBTVEsR0FBRTtvQkFDcENILEVBQUVULEVBQUUsQ0FBQ3RuQixDQUFDLEdBQUcrbkIsRUFBRXpwQixFQUFFLENBQUNrcEIsQ0FBQztvQkFDZk8sRUFBRVQsRUFBRSxDQUFDcG5CLENBQUMsR0FBRzZuQixFQUFFeHBCLEVBQUUsQ0FBQ2lwQixDQUFDO29CQUNmTyxFQUFFVCxFQUFFLENBQUNFLENBQUMsR0FBR2IsTUFBT2UsQ0FBQUEsTUFBTUcsTUFBTUYsTUFBTUEsR0FBRTtnQkFDeEM7Z0JBRUE7Ozs7Ozs7Q0FPQyxHQUNEL21DLE1BQU0yTSxHQUFHLEdBQUcsU0FBU3hOLENBQUMsRUFBRXV0QixDQUFDO29CQUNyQnRxQixXQUFXcEMsTUFBTWtFLE1BQU0sQ0FBQy9FO29CQUN4QixJQUFJdXRCLEtBQUssT0FBT0EsS0FBSyxPQUFPQSxLQUFLLE9BQU9BLEdBQUc7d0JBQ3ZDdHFCLFdBQVd0QyxLQUFLb0UsTUFBTSxDQUFDd29CO3dCQUN2QixJQUFJdE4sSUFBSWpnQixFQUFFdWUsRUFBRSxDQUFDMEIsQ0FBQyxHQUFHc04sRUFBRXROLENBQUMsR0FBR2pnQixFQUFFd2UsRUFBRSxDQUFDeUIsQ0FBQyxHQUFHc04sRUFBRXBOLENBQUMsR0FBR25nQixFQUFFdW5DLEVBQUUsQ0FBQ3RuQixDQUFDLEdBQUdzTixFQUFFa2EsQ0FBQzt3QkFDbEQsSUFBSXRuQixJQUFJbmdCLEVBQUV1ZSxFQUFFLENBQUM0QixDQUFDLEdBQUdvTixFQUFFdE4sQ0FBQyxHQUFHamdCLEVBQUV3ZSxFQUFFLENBQUMyQixDQUFDLEdBQUdvTixFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUV1bkMsRUFBRSxDQUFDcG5CLENBQUMsR0FBR29OLEVBQUVrYSxDQUFDO3dCQUNsRCxJQUFJQSxJQUFJem5DLEVBQUV1ZSxFQUFFLENBQUNrcEIsQ0FBQyxHQUFHbGEsRUFBRXROLENBQUMsR0FBR2pnQixFQUFFd2UsRUFBRSxDQUFDaXBCLENBQUMsR0FBR2xhLEVBQUVwTixDQUFDLEdBQUduZ0IsRUFBRXVuQyxFQUFFLENBQUNFLENBQUMsR0FBR2xhLEVBQUVrYSxDQUFDO3dCQUNsRCxPQUFPLElBQUk5bUMsS0FBS3NmLEdBQUdFLEdBQUdzbkI7b0JBQzFCLE9BQU8sSUFBSWxhLEtBQUssT0FBT0EsS0FBSyxPQUFPQSxHQUFHO3dCQUNsQ3RxQixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3dvQjt3QkFDdkIsSUFBSXROLElBQUlqZ0IsRUFBRXVlLEVBQUUsQ0FBQzBCLENBQUMsR0FBR3NOLEVBQUV0TixDQUFDLEdBQUdqZ0IsRUFBRXdlLEVBQUUsQ0FBQ3lCLENBQUMsR0FBR3NOLEVBQUVwTixDQUFDO3dCQUNuQyxJQUFJQSxJQUFJbmdCLEVBQUV1ZSxFQUFFLENBQUM0QixDQUFDLEdBQUdvTixFQUFFdE4sQ0FBQyxHQUFHamdCLEVBQUV3ZSxFQUFFLENBQUMyQixDQUFDLEdBQUdvTixFQUFFcE4sQ0FBQzt3QkFDbkMsT0FBT3pmLEtBQUtrb0IsR0FBRyxDQUFDM0ksR0FBR0U7b0JBQ3ZCO29CQUNBbGQsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQztnQkFDN0I7Z0JBRUFsRSxNQUFNd25DLE9BQU8sR0FBRyxTQUFTcm9DLENBQUMsRUFBRXV0QixDQUFDO29CQUN6QnRxQixXQUFXcEMsTUFBTWtFLE1BQU0sQ0FBQy9FO29CQUN4QmlELFdBQVd0QyxLQUFLb0UsTUFBTSxDQUFDd29CO29CQUN2QixJQUFJdE4sSUFBSWpnQixFQUFFdWUsRUFBRSxDQUFDMEIsQ0FBQyxHQUFHc04sRUFBRXROLENBQUMsR0FBR2pnQixFQUFFd2UsRUFBRSxDQUFDeUIsQ0FBQyxHQUFHc04sRUFBRXBOLENBQUMsR0FBR25nQixFQUFFdW5DLEVBQUUsQ0FBQ3RuQixDQUFDLEdBQUdzTixFQUFFa2EsQ0FBQztvQkFDbEQsSUFBSXRuQixJQUFJbmdCLEVBQUV1ZSxFQUFFLENBQUM0QixDQUFDLEdBQUdvTixFQUFFdE4sQ0FBQyxHQUFHamdCLEVBQUV3ZSxFQUFFLENBQUMyQixDQUFDLEdBQUdvTixFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUV1bkMsRUFBRSxDQUFDcG5CLENBQUMsR0FBR29OLEVBQUVrYSxDQUFDO29CQUNsRCxJQUFJQSxJQUFJem5DLEVBQUV1ZSxFQUFFLENBQUNrcEIsQ0FBQyxHQUFHbGEsRUFBRXROLENBQUMsR0FBR2pnQixFQUFFd2UsRUFBRSxDQUFDaXBCLENBQUMsR0FBR2xhLEVBQUVwTixDQUFDLEdBQUduZ0IsRUFBRXVuQyxFQUFFLENBQUNFLENBQUMsR0FBR2xhLEVBQUVrYSxDQUFDO29CQUNsRCxPQUFPLElBQUk5bUMsS0FBS3NmLEdBQUdFLEdBQUdzbkI7Z0JBQzFCO2dCQUVBNW1DLE1BQU04TyxPQUFPLEdBQUcsU0FBUzNQLENBQUMsRUFBRXV0QixDQUFDO29CQUN6QnRxQixXQUFXcEMsTUFBTWtFLE1BQU0sQ0FBQy9FO29CQUN4QmlELFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDd29CO29CQUN2QixJQUFJdE4sSUFBSWpnQixFQUFFdWUsRUFBRSxDQUFDMEIsQ0FBQyxHQUFHc04sRUFBRXROLENBQUMsR0FBR2pnQixFQUFFd2UsRUFBRSxDQUFDeUIsQ0FBQyxHQUFHc04sRUFBRXBOLENBQUM7b0JBQ25DLElBQUlBLElBQUluZ0IsRUFBRXVlLEVBQUUsQ0FBQzRCLENBQUMsR0FBR29OLEVBQUV0TixDQUFDLEdBQUdqZ0IsRUFBRXdlLEVBQUUsQ0FBQzJCLENBQUMsR0FBR29OLEVBQUVwTixDQUFDO29CQUNuQyxPQUFPemYsS0FBS2tvQixHQUFHLENBQUMzSSxHQUFHRTtnQkFDdkI7Z0JBRUF0ZixNQUFNK0ssR0FBRyxHQUFHLFNBQVM1TCxDQUFDLEVBQUV1dEIsQ0FBQztvQkFDckJ0cUIsV0FBV3BDLE1BQU1rRSxNQUFNLENBQUMvRTtvQkFDeEJpRCxXQUFXcEMsTUFBTWtFLE1BQU0sQ0FBQ3dvQjtvQkFDeEIsT0FBTyxJQUFJMXNCLE1BQU1GLEtBQUtpTCxHQUFHLENBQUM1TCxFQUFFdWUsRUFBRSxHQUFHZ1AsRUFBRWhQLEVBQUUsR0FBRzVkLEtBQUtpTCxHQUFHLENBQUM1TCxFQUFFd2UsRUFBRSxHQUFHK08sRUFBRS9PLEVBQUUsR0FBRzdkLEtBQUtpTCxHQUFHLENBQUM1TCxFQUFFdW5DLEVBQUUsR0FBR2hhLEVBQUVnYSxFQUFFO2dCQUN2RjtZQUdBO1lBQUU7Z0JBQUMsa0JBQWlCO2dCQUFHLFVBQVM7Z0JBQUcsVUFBUztnQkFBRyxVQUFTO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTdG5DLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNoRyxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUlxb0MsU0FBUzduQztnQkFFYixJQUFJOG5DLE9BQU9ycEMsUUFBT0QsT0FBTyxHQUFHMGpCLE9BQU8ybEI7Z0JBRW5DQyxLQUFLeGYsT0FBTyxHQUFHO2dCQUVmLE9BQU87Z0JBQ1A7OztDQUdDLEdBQ0R3ZixLQUFLdGpDLFFBQVEsR0FBRyxTQUFTZ2IsQ0FBQztvQkFDdEIsT0FBTyxPQUFPQSxNQUFNLFlBQVloYixTQUFTZ2IsTUFBTSxDQUFDdW9CLE1BQU12b0I7Z0JBQzFEO2dCQUVBc29CLEtBQUt4akMsTUFBTSxHQUFHLFNBQVNrYixDQUFDO29CQUNwQixJQUFJLENBQUNoZCxTQUFTO29CQUNkLElBQUksQ0FBQ3NsQyxLQUFLdGpDLFFBQVEsQ0FBQ2diLElBQUk7d0JBQ25CbGQsVUFBVUksUUFBTzhyQixLQUFLLENBQUNoUDt3QkFDdkIsTUFBTSxJQUFJOWYsTUFBTTtvQkFDcEI7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRG9vQyxLQUFLRSxPQUFPLEdBQUcsU0FBU3hvQixDQUFDO29CQUNyQixPQUFPO29CQUNQLE9BQU8sSUFBSXFvQixPQUFPaG1CLElBQUksQ0FBQ3JDO2dCQUMzQjtnQkFFQTs7Ozs7O0NBTUMsR0FDRHNvQixLQUFLRyxjQUFjLEdBQUcsU0FBU3pvQixDQUFDO29CQUM1QixPQUFPO29CQUNQQSxLQUFLQSxLQUFLO29CQUNWQSxLQUFLQSxLQUFLO29CQUNWQSxLQUFLQSxLQUFLO29CQUNWQSxLQUFLQSxLQUFLO29CQUNWQSxLQUFLQSxLQUFLO29CQUNWLE9BQU9BLElBQUk7Z0JBQ2Y7Z0JBRUFzb0IsS0FBS0ksWUFBWSxHQUFHLFNBQVMxb0IsQ0FBQztvQkFDMUIsT0FBT0EsSUFBSSxLQUFLLEFBQUNBLENBQUFBLElBQUlBLElBQUksQ0FBQSxLQUFNO2dCQUNuQztnQkFFQXNvQixLQUFLSyxHQUFHLEdBQUcsU0FBU0MsR0FBRyxFQUFFM3RCLEdBQUcsRUFBRTZGLEdBQUc7b0JBQzdCLElBQUksT0FBTzdGLFFBQVEsYUFBYTt3QkFDNUI2RixNQUFNLEdBQUc3RixNQUFNO29CQUNuQixPQUFPLElBQUksT0FBTzZGLFFBQVEsYUFBYTt3QkFDbkNBLE1BQU03RixLQUFLQSxNQUFNO29CQUNyQjtvQkFDQSxJQUFJNkYsTUFBTTdGLEtBQUs7d0JBQ1gydEIsTUFBTSxBQUFDQSxDQUFBQSxNQUFNM3RCLEdBQUUsSUFBTTZGLENBQUFBLE1BQU03RixHQUFFO3dCQUM3QixPQUFPMnRCLE1BQU9BLENBQUFBLE1BQU0sSUFBSTluQixNQUFNN0YsR0FBRTtvQkFDcEMsT0FBTzt3QkFDSDJ0QixNQUFNLEFBQUNBLENBQUFBLE1BQU05bkIsR0FBRSxJQUFNN0YsQ0FBQUEsTUFBTTZGLEdBQUU7d0JBQzdCLE9BQU84bkIsTUFBT0EsQ0FBQUEsT0FBTyxJQUFJM3RCLE1BQU02RixHQUFFO29CQUNyQztnQkFDSjtnQkFFQXduQixLQUFLL3NCLEtBQUssR0FBRyxTQUFTcXRCLEdBQUcsRUFBRTN0QixHQUFHLEVBQUU2RixHQUFHO29CQUMvQixJQUFJOG5CLE1BQU0zdEIsS0FBSzt3QkFDWCxPQUFPQTtvQkFDWCxPQUFPLElBQUkydEIsTUFBTTluQixLQUFLO3dCQUNsQixPQUFPQTtvQkFDWCxPQUFPO3dCQUNILE9BQU84bkI7b0JBQ1g7Z0JBQ0o7Z0JBRUFOLEtBQUtPLE1BQU0sR0FBRyxTQUFTNXRCLEdBQUcsRUFBRTZGLEdBQUc7b0JBQzNCLElBQUksT0FBTzdGLFFBQVEsYUFBYTt3QkFDNUI2RixNQUFNO3dCQUNON0YsTUFBTTtvQkFDVixPQUFPLElBQUksT0FBTzZGLFFBQVEsYUFBYTt3QkFDbkNBLE1BQU03Rjt3QkFDTkEsTUFBTTtvQkFDVjtvQkFDQSxPQUFPQSxPQUFPNkYsTUFBTTdGLE1BQU1vdEIsT0FBT1EsTUFBTSxLQUFNL25CLENBQUFBLE1BQU03RixHQUFFLElBQUtBO2dCQUM5RDtZQUdBO1lBQUU7Z0JBQUMsa0JBQWlCO2dCQUFHLGtCQUFpQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU2piLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNoRixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR3FFO2dCQUVqQixJQUFJNUMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEI7OztDQUdDLEdBQ0QsU0FBU3FEO29CQUNMLElBQUksQ0FBQ3lILENBQUMsR0FBR3JLLEtBQUtzRCxJQUFJO29CQUNsQixJQUFJLENBQUNoRSxDQUFDLEdBQUc7Z0JBQ2I7Z0JBRUFzRCxTQUFTa0UsU0FBUyxDQUFDZ0QsWUFBWSxHQUFHLFNBQVNJLEVBQUUsRUFBRTFFLENBQUM7b0JBQzVDMEUsR0FBR3hFLENBQUMsQ0FBQ3FFLEdBQUcsQ0FBQyxJQUFJLENBQUN6SyxDQUFDO29CQUNmNEssR0FBRzFFLENBQUMsQ0FBQ3VFLEdBQUcsQ0FBQy9KLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDWixDQUFDLEVBQUVoSyxJQUFJNE8sT0FBTyxDQUFDL0UsR0FBR3hFLENBQUMsRUFBRUY7b0JBQzVDLE9BQU8wRTtnQkFDWDtZQUdBO1lBQUU7Z0JBQUMsU0FBUTtnQkFBRyxVQUFTO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTM0ssUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQy9ELElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHOEI7Z0JBRWpCLElBQUlvQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsNEJBQTRCO2dCQUM1Qjs7Q0FFQyxHQUNELFNBQVNjLElBQUlrRCxLQUFLO29CQUNkLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWWxELEdBQUUsR0FBSTt3QkFDeEIsT0FBTyxJQUFJQSxJQUFJa0Q7b0JBQ25CO29CQUNBLElBQUksT0FBT0EsVUFBVSxVQUFVO3dCQUMzQixJQUFJLENBQUNvQyxRQUFRLENBQUNwQztvQkFDbEIsT0FBTyxJQUFJLE9BQU9BLFVBQVUsVUFBVTt3QkFDbEMsSUFBSSxDQUFDd0csR0FBRyxDQUFDeEc7b0JBQ2IsT0FBTzt3QkFDSCxJQUFJLENBQUNtVyxXQUFXO29CQUNwQjtnQkFDSjtnQkFFQXJaLElBQUk2bkIsR0FBRyxHQUFHLFNBQVMza0IsS0FBSztvQkFDcEIsSUFBSThrQyxNQUFNM2dCLE9BQU96RixNQUFNLENBQUM1aEIsSUFBSXlHLFNBQVM7b0JBQ3JDdWhDLElBQUkxaUMsUUFBUSxDQUFDcEM7b0JBQ2IsT0FBTzhrQztnQkFDWDtnQkFFQWhvQyxJQUFJb0YsS0FBSyxHQUFHLFNBQVM2aUMsR0FBRztvQkFDcEIvbEMsV0FBV2xDLElBQUlnRSxNQUFNLENBQUNpa0M7b0JBQ3RCLElBQUlELE1BQU0zZ0IsT0FBT3pGLE1BQU0sQ0FBQzVoQixJQUFJeUcsU0FBUztvQkFDckN1aEMsSUFBSWxwQyxDQUFDLEdBQUdtcEMsSUFBSW5wQyxDQUFDO29CQUNia3BDLElBQUloK0IsQ0FBQyxHQUFHaStCLElBQUlqK0IsQ0FBQztvQkFDYixPQUFPZytCO2dCQUNYO2dCQUVBaG9DLElBQUlrRixRQUFRLEdBQUc7b0JBQ1gsSUFBSThpQyxNQUFNM2dCLE9BQU96RixNQUFNLENBQUM1aEIsSUFBSXlHLFNBQVM7b0JBQ3JDdWhDLElBQUlscEMsQ0FBQyxHQUFHO29CQUNSa3BDLElBQUloK0IsQ0FBQyxHQUFHO29CQUNSLE9BQU9nK0I7Z0JBQ1g7Z0JBRUFob0MsSUFBSWlFLE9BQU8sR0FBRyxTQUFTbEYsQ0FBQztvQkFDcEIsT0FBT0EsS0FBS1csTUFBS3dFLFFBQVEsQ0FBQ25GLEVBQUVELENBQUMsS0FBS1ksTUFBS3dFLFFBQVEsQ0FBQ25GLEVBQUVpTCxDQUFDO2dCQUN2RDtnQkFFQWhLLElBQUlnRSxNQUFNLEdBQUcsU0FBU2pGLENBQUM7b0JBQ25CLElBQUksQ0FBQ21ELFNBQVM7b0JBQ2QsSUFBSSxDQUFDbEMsSUFBSWlFLE9BQU8sQ0FBQ2xGLElBQUk7d0JBQ2pCaUQsVUFBVUksUUFBTzhyQixLQUFLLENBQUNudkI7d0JBQ3ZCLE1BQU0sSUFBSUssTUFBTTtvQkFDcEI7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRFksSUFBSXlHLFNBQVMsQ0FBQzRTLFdBQVcsR0FBRztvQkFDeEIsSUFBSSxDQUFDdmEsQ0FBQyxHQUFHO29CQUNULElBQUksQ0FBQ2tMLENBQUMsR0FBRztvQkFDVCxPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUFoSyxJQUFJeUcsU0FBUyxDQUFDaUQsR0FBRyxHQUFHLFNBQVN4RyxLQUFLO29CQUM5QixJQUFJLE9BQU9BLFVBQVUsVUFBVTt3QkFDM0JoQixXQUFXbEMsSUFBSWdFLE1BQU0sQ0FBQ2Q7d0JBQ3RCLElBQUksQ0FBQ3BFLENBQUMsR0FBR29FLE1BQU1wRSxDQUFDO3dCQUNoQixJQUFJLENBQUNrTCxDQUFDLEdBQUc5RyxNQUFNOEcsQ0FBQztvQkFDcEIsT0FBTzt3QkFDSDlILFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDZDt3QkFDdkIscUJBQXFCO3dCQUNyQixJQUFJLENBQUNwRSxDQUFDLEdBQUdZLE1BQUt3b0MsR0FBRyxDQUFDaGxDO3dCQUNsQixJQUFJLENBQUM4RyxDQUFDLEdBQUd0SyxNQUFLeW9DLEdBQUcsQ0FBQ2psQztvQkFDdEI7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRGxELElBQUl5RyxTQUFTLENBQUNuQixRQUFRLEdBQUcsU0FBU3BDLEtBQUs7b0JBQ25DaEIsV0FBV3hDLE1BQUtzRSxNQUFNLENBQUNkO29CQUN2QixxQkFBcUI7b0JBQ3JCLElBQUksQ0FBQ3BFLENBQUMsR0FBR1ksTUFBS3dvQyxHQUFHLENBQUNobEM7b0JBQ2xCLElBQUksQ0FBQzhHLENBQUMsR0FBR3RLLE1BQUt5b0MsR0FBRyxDQUFDamxDO2dCQUN0QjtnQkFFQTs7Q0FFQyxHQUNEbEQsSUFBSXlHLFNBQVMsQ0FBQzRELFFBQVEsR0FBRztvQkFDckIsT0FBTzNLLE1BQUswb0MsS0FBSyxDQUFDLElBQUksQ0FBQ3RwQyxDQUFDLEVBQUUsSUFBSSxDQUFDa0wsQ0FBQztnQkFDcEM7Z0JBRUE7O0NBRUMsR0FDRGhLLElBQUl5RyxTQUFTLENBQUM0aEMsUUFBUSxHQUFHO29CQUNyQixPQUFPMW9DLEtBQUtrb0IsR0FBRyxDQUFDLElBQUksQ0FBQzdkLENBQUMsRUFBRSxJQUFJLENBQUNsTCxDQUFDO2dCQUNsQztnQkFFQTs7Q0FFQyxHQUNEa0IsSUFBSXlHLFNBQVMsQ0FBQzZoQyxRQUFRLEdBQUc7b0JBQ3JCLE9BQU8zb0MsS0FBS2tvQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMvb0IsQ0FBQyxFQUFFLElBQUksQ0FBQ2tMLENBQUM7Z0JBQ25DO2dCQUVBOzs7Ozs7OztDQVFDLEdBQ0RoSyxJQUFJeU0sR0FBRyxHQUFHLFNBQVN3N0IsR0FBRyxFQUFFTSxDQUFDO29CQUNyQnJtQyxXQUFXbEMsSUFBSWdFLE1BQU0sQ0FBQ2lrQztvQkFDdEIsSUFBSSxPQUFPTSxLQUFLLE9BQU9BLEdBQUc7d0JBQ3RCcm1DLFdBQVdsQyxJQUFJZ0UsTUFBTSxDQUFDdWtDO3dCQUN0QixtREFBbUQ7d0JBQ25ELDZDQUE2Qzt3QkFDN0Msd0JBQXdCO3dCQUN4Qix3QkFBd0I7d0JBQ3hCLElBQUlDLEtBQUt4b0MsSUFBSWtGLFFBQVE7d0JBQ3JCc2pDLEdBQUcxcEMsQ0FBQyxHQUFHbXBDLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUV2K0IsQ0FBQyxHQUFHaStCLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUV6cEMsQ0FBQzt3QkFDaEMwcEMsR0FBR3grQixDQUFDLEdBQUdpK0IsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRXYrQixDQUFDLEdBQUdpK0IsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRXpwQyxDQUFDO3dCQUNoQyxPQUFPMHBDO29CQUNYLE9BQU8sSUFBSSxPQUFPRCxLQUFLLE9BQU9BLEdBQUc7d0JBQzdCcm1DLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDdWtDO3dCQUN2QixPQUFPNW9DLEtBQUtrb0IsR0FBRyxDQUFDb2dCLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUVycEIsQ0FBQyxHQUFHK29CLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUVucEIsQ0FBQyxFQUFFNm9CLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUVycEIsQ0FBQyxHQUFHK29CLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUVucEIsQ0FBQztvQkFDeEU7Z0JBQ0o7Z0JBRUFwZixJQUFJeW9DLE1BQU0sR0FBRyxTQUFTUixHQUFHLEVBQUVNLENBQUM7b0JBQ3hCcm1DLFdBQVdsQyxJQUFJZ0UsTUFBTSxDQUFDaWtDO29CQUN0Qi9sQyxXQUFXbEMsSUFBSWdFLE1BQU0sQ0FBQ3VrQztvQkFDdEIsbURBQW1EO29CQUNuRCw2Q0FBNkM7b0JBQzdDLHdCQUF3QjtvQkFDeEIsd0JBQXdCO29CQUN4QixJQUFJQyxLQUFLeG9DLElBQUlrRixRQUFRO29CQUNyQnNqQyxHQUFHMXBDLENBQUMsR0FBR21wQyxJQUFJbnBDLENBQUMsR0FBR3lwQyxFQUFFditCLENBQUMsR0FBR2krQixJQUFJaitCLENBQUMsR0FBR3UrQixFQUFFenBDLENBQUM7b0JBQ2hDMHBDLEdBQUd4K0IsQ0FBQyxHQUFHaStCLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUV2K0IsQ0FBQyxHQUFHaStCLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUV6cEMsQ0FBQztvQkFDaEMsT0FBTzBwQztnQkFDWDtnQkFFQXhvQyxJQUFJNE8sT0FBTyxHQUFHLFNBQVNxNUIsR0FBRyxFQUFFTSxDQUFDO29CQUN6QnJtQyxXQUFXbEMsSUFBSWdFLE1BQU0sQ0FBQ2lrQztvQkFDdEIvbEMsV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1a0M7b0JBQ3ZCLE9BQU81b0MsS0FBS2tvQixHQUFHLENBQUNvZ0IsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRXJwQixDQUFDLEdBQUcrb0IsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRW5wQixDQUFDLEVBQUU2b0IsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRXJwQixDQUFDLEdBQUcrb0IsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRW5wQixDQUFDO2dCQUN4RTtnQkFFQXBmLElBQUl1WixRQUFRLEdBQUcsU0FBUzB1QixHQUFHLEVBQUVNLENBQUMsRUFBRXZDLENBQUM7b0JBQzdCOWpDLFdBQVdsQyxJQUFJZ0UsTUFBTSxDQUFDaWtDO29CQUN0Qi9sQyxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VrQztvQkFDdkIsT0FBT3ZDLEVBQUV0OEIsR0FBRyxDQUFDdStCLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUVycEIsQ0FBQyxHQUFHK29CLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUVucEIsQ0FBQyxFQUFFNm9CLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUVycEIsQ0FBQyxHQUFHK29CLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUVucEIsQ0FBQztnQkFDckU7Z0JBRUFwZixJQUFJMG9DLE1BQU0sR0FBRyxTQUFTVCxHQUFHLEVBQUU5OEIsQ0FBQyxFQUFFSSxDQUFDO29CQUMzQixJQUFJMlQsSUFBSStvQixJQUFJaitCLENBQUMsR0FBSW1CLENBQUFBLEVBQUUrVCxDQUFDLEdBQUczVCxFQUFFMlQsQ0FBQyxBQUFEQSxJQUFLK29CLElBQUlucEMsQ0FBQyxHQUFJcU0sQ0FBQUEsRUFBRWlVLENBQUMsR0FBRzdULEVBQUU2VCxDQUFDLEFBQURBO29CQUMvQyxJQUFJQSxJQUFJNm9CLElBQUlucEMsQ0FBQyxHQUFJcU0sQ0FBQUEsRUFBRStULENBQUMsR0FBRzNULEVBQUU2VCxDQUFDLEFBQURBLElBQUs2b0IsSUFBSWorQixDQUFDLEdBQUltQixDQUFBQSxFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTZULENBQUMsQUFBREE7b0JBQy9DLE9BQU96ZixLQUFLa29CLEdBQUcsQ0FBQzNJLEdBQUdFO2dCQUN2QjtnQkFFQTs7Ozs7Ozs7Q0FRQyxHQUNEcGYsSUFBSWttQyxJQUFJLEdBQUcsU0FBUytCLEdBQUcsRUFBRU0sQ0FBQztvQkFDdEIsSUFBSSxPQUFPQSxLQUFLLE9BQU9BLEdBQUc7d0JBQ3RCcm1DLFdBQVdsQyxJQUFJZ0UsTUFBTSxDQUFDdWtDO3dCQUN0QixtREFBbUQ7d0JBQ25ELDhDQUE4Qzt3QkFDOUMsd0JBQXdCO3dCQUN4Qix3QkFBd0I7d0JBQ3hCLElBQUlDLEtBQUt4b0MsSUFBSWtGLFFBQVE7d0JBQ3JCc2pDLEdBQUcxcEMsQ0FBQyxHQUFHbXBDLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUV6cEMsQ0FBQyxHQUFHbXBDLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUV2K0IsQ0FBQzt3QkFDaEN3K0IsR0FBR3grQixDQUFDLEdBQUdpK0IsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRXYrQixDQUFDLEdBQUdpK0IsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRXpwQyxDQUFDO3dCQUNoQyxPQUFPMHBDO29CQUNYLE9BQU8sSUFBSSxPQUFPRCxLQUFLLE9BQU9BLEdBQUc7d0JBQzdCcm1DLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDdWtDO3dCQUN2QixPQUFPNW9DLEtBQUtrb0IsR0FBRyxDQUFDb2dCLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUVycEIsQ0FBQyxHQUFHK29CLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUVucEIsQ0FBQyxFQUFFLENBQUM2b0IsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRXJwQixDQUFDLEdBQUcrb0IsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRW5wQixDQUFDO29CQUN6RTtnQkFDSjtnQkFFQXBmLElBQUkyb0MsT0FBTyxHQUFHLFNBQVNWLEdBQUcsRUFBRU0sQ0FBQztvQkFDekJybUMsV0FBV2xDLElBQUlnRSxNQUFNLENBQUN1a0M7b0JBQ3RCLG1EQUFtRDtvQkFDbkQsOENBQThDO29CQUM5Qyx3QkFBd0I7b0JBQ3hCLHdCQUF3QjtvQkFDeEIsSUFBSUMsS0FBS3hvQyxJQUFJa0YsUUFBUTtvQkFDckJzakMsR0FBRzFwQyxDQUFDLEdBQUdtcEMsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRXpwQyxDQUFDLEdBQUdtcEMsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRXYrQixDQUFDO29CQUNoQ3crQixHQUFHeCtCLENBQUMsR0FBR2krQixJQUFJaitCLENBQUMsR0FBR3UrQixFQUFFditCLENBQUMsR0FBR2krQixJQUFJbnBDLENBQUMsR0FBR3lwQyxFQUFFenBDLENBQUM7b0JBQ2hDLE9BQU8wcEM7Z0JBQ1g7Z0JBRUF4b0MsSUFBSTRvQyxRQUFRLEdBQUcsU0FBU1gsR0FBRyxFQUFFTSxDQUFDLEVBQUV2QyxDQUFDO29CQUM3QjlqQyxXQUFXbEMsSUFBSWdFLE1BQU0sQ0FBQ3VrQztvQkFDdEIsbURBQW1EO29CQUNuRCw4Q0FBOEM7b0JBQzlDLHdCQUF3QjtvQkFDeEIsd0JBQXdCO29CQUN4QixJQUFJQyxLQUFLeEMsRUFBRTNzQixXQUFXO29CQUN0Qm12QixHQUFHMXBDLENBQUMsR0FBR21wQyxJQUFJaitCLENBQUMsR0FBR3UrQixFQUFFenBDLENBQUMsR0FBR21wQyxJQUFJbnBDLENBQUMsR0FBR3lwQyxFQUFFditCLENBQUM7b0JBQ2hDdytCLEdBQUd4K0IsQ0FBQyxHQUFHaStCLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUV2K0IsQ0FBQyxHQUFHaStCLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUV6cEMsQ0FBQztvQkFDaEMsT0FBTzBwQztnQkFDWDtnQkFFQXhvQyxJQUFJZ1AsUUFBUSxHQUFHLFNBQVNpNUIsR0FBRyxFQUFFTSxDQUFDO29CQUMxQnJtQyxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VrQztvQkFDdkIsT0FBTzVvQyxLQUFLa29CLEdBQUcsQ0FBQ29nQixJQUFJaitCLENBQUMsR0FBR3UrQixFQUFFcnBCLENBQUMsR0FBRytvQixJQUFJbnBDLENBQUMsR0FBR3lwQyxFQUFFbnBCLENBQUMsRUFBRSxDQUFDNm9CLElBQUlucEMsQ0FBQyxHQUFHeXBDLEVBQUVycEIsQ0FBQyxHQUFHK29CLElBQUlqK0IsQ0FBQyxHQUFHdStCLEVBQUVucEIsQ0FBQztnQkFDekU7Z0JBRUFwZixJQUFJNm9DLFNBQVMsR0FBRyxTQUFTWixHQUFHLEVBQUVNLENBQUMsRUFBRXZDLENBQUM7b0JBQzlCOWpDLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDdWtDO29CQUN2QixPQUFPdkMsRUFBRXQ4QixHQUFHLENBQUN1K0IsSUFBSWorQixDQUFDLEdBQUd1K0IsRUFBRXJwQixDQUFDLEdBQUcrb0IsSUFBSW5wQyxDQUFDLEdBQUd5cEMsRUFBRW5wQixDQUFDLEVBQUUsQ0FBQzZvQixJQUFJbnBDLENBQUMsR0FBR3lwQyxFQUFFcnBCLENBQUMsR0FBRytvQixJQUFJaitCLENBQUMsR0FBR3UrQixFQUFFbnBCLENBQUM7Z0JBQ3RFO1lBR0E7WUFBRTtnQkFBQyxrQkFBaUI7Z0JBQUcsVUFBUztnQkFBRyxVQUFTO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTbGdCLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNwRixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR3VEO2dCQUVqQixJQUFJVyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTdUMsTUFBTXVJLENBQUMsRUFBRS9LLENBQUM7b0JBQ2ZpRCxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLE9BQU9nRyxNQUFNO29CQUN0QzlILFdBQVdFLFFBQU80QixNQUFNLENBQUMsT0FBTy9FLE1BQU07b0JBQ3RDLElBQUksQ0FBQ3VMLFdBQVcsR0FBRzdLLEtBQUtzRCxJQUFJO29CQUM1QixJQUFJLENBQUMrRyxDQUFDLEdBQUdySyxLQUFLc0QsSUFBSTtvQkFDbEIsSUFBSSxDQUFDaEUsQ0FBQyxHQUFHO29CQUNULElBQUksQ0FBQ3F2QixNQUFNLEdBQUc7b0JBQ2QsSUFBSSxDQUFDcmtCLEVBQUUsR0FBR3RLLEtBQUtzRCxJQUFJO29CQUNuQixJQUFJLENBQUNpSCxFQUFFLEdBQUc7Z0JBQ2Q7Z0JBRUF6SSxNQUFNZ0YsU0FBUyxDQUFDakIsWUFBWSxHQUFHLFNBQVNxRSxFQUFFO29CQUN0QyxJQUFJRyxJQUFJakssVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDVyxXQUFXO29CQUM5QyxJQUFJLENBQUNSLENBQUMsQ0FBQ04sR0FBRyxDQUFDTTtvQkFDWCxJQUFJLENBQUNDLEVBQUUsQ0FBQ1AsR0FBRyxDQUFDTTtvQkFDWixJQUFJLENBQUMvSyxDQUFDLEdBQUc0SyxHQUFHeEUsQ0FBQyxDQUFDZ0YsUUFBUTtvQkFDdEIsSUFBSSxDQUFDSCxFQUFFLEdBQUdMLEdBQUd4RSxDQUFDLENBQUNnRixRQUFRO2dCQUMzQjtnQkFFQTVJLE1BQU1nRixTQUFTLENBQUNrRyxjQUFjLEdBQUcsU0FBU25DLFdBQVcsRUFBRVgsRUFBRTtvQkFDckQsSUFBSSxDQUFDVyxXQUFXLENBQUNkLEdBQUcsQ0FBQ2M7b0JBQ3JCLElBQUlSLElBQUlqSyxVQUFVNk8sT0FBTyxDQUFDL0UsSUFBSSxJQUFJLENBQUNXLFdBQVc7b0JBQzlDLElBQUksQ0FBQ1IsQ0FBQyxDQUFDTixHQUFHLENBQUNNO29CQUNYLElBQUksQ0FBQ0MsRUFBRSxDQUFDUCxHQUFHLENBQUNNO2dCQUNoQjtnQkFFQTs7Ozs7Q0FLQyxHQUNEdkksTUFBTWdGLFNBQVMsQ0FBQ2dELFlBQVksR0FBRyxTQUFTSSxFQUFFLEVBQUV1bEIsSUFBSTtvQkFDNUNBLE9BQU8sT0FBT0EsU0FBUyxjQUFjLElBQUlBO29CQUN6Q3ZsQixHQUFHeEUsQ0FBQyxDQUFDQyxRQUFRLENBQUMsQUFBQyxDQUFBLElBQUk4cEIsSUFBRyxJQUFLLElBQUksQ0FBQ2xsQixFQUFFLEdBQUdrbEIsT0FBTyxJQUFJLENBQUNud0IsQ0FBQztvQkFDbEQ0SyxHQUFHMUUsQ0FBQyxDQUFDZ1gsVUFBVSxDQUFDLElBQUlpVCxNQUFNLElBQUksQ0FBQ25sQixFQUFFLEVBQUVtbEIsTUFBTSxJQUFJLENBQUNwbEIsQ0FBQztvQkFDL0Msa0JBQWtCO29CQUNsQkgsR0FBRzFFLENBQUMsQ0FBQ3lGLEdBQUcsQ0FBQzVLLElBQUk0TyxPQUFPLENBQUMvRSxHQUFHeEUsQ0FBQyxFQUFFLElBQUksQ0FBQ21GLFdBQVc7Z0JBQy9DO2dCQUVBOzs7O0NBSUMsR0FDRC9JLE1BQU1nRixTQUFTLENBQUNxRCxPQUFPLEdBQUcsU0FBU0MsS0FBSztvQkFDcEM3SCxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQ3NxQixNQUFNLEdBQUc7b0JBQ3ZDLElBQUljLE9BQU8sQUFBQ3JsQixDQUFBQSxRQUFRLElBQUksQ0FBQ3VrQixNQUFNLEFBQUQsSUFBTSxDQUFBLElBQUksSUFBSSxDQUFDQSxNQUFNLEFBQUQ7b0JBQ2xELElBQUksQ0FBQ3JrQixFQUFFLENBQUNrUyxVQUFVLENBQUNpVCxNQUFNLElBQUksQ0FBQ3BsQixDQUFDLEVBQUUsSUFBSW9sQixNQUFNLElBQUksQ0FBQ25sQixFQUFFO29CQUNsRCxJQUFJLENBQUNDLEVBQUUsR0FBR2tsQixPQUFPLElBQUksQ0FBQ253QixDQUFDLEdBQUcsQUFBQyxDQUFBLElBQUltd0IsSUFBRyxJQUFLLElBQUksQ0FBQ2xsQixFQUFFO29CQUM5QyxJQUFJLENBQUNva0IsTUFBTSxHQUFHdmtCO2dCQUNsQjtnQkFFQXRJLE1BQU1nRixTQUFTLENBQUNxQixPQUFPLEdBQUc7b0JBQ3RCLElBQUksQ0FBQ29DLEVBQUUsR0FBRyxJQUFJLENBQUNqTCxDQUFDO29CQUNoQixJQUFJLENBQUNnTCxFQUFFLENBQUNQLEdBQUcsQ0FBQyxJQUFJLENBQUNNLENBQUM7Z0JBQ3RCO2dCQUVBOztDQUVDLEdBQ0R2SSxNQUFNZ0YsU0FBUyxDQUFDb1QsU0FBUyxHQUFHO29CQUN4QixJQUFJM1AsS0FBS3hLLE1BQUttb0MsR0FBRyxDQUFDLElBQUksQ0FBQzM5QixFQUFFLEVBQUUsQ0FBQ3hLLE1BQUs4cEIsRUFBRSxFQUFFLENBQUM5cEIsTUFBSzhwQixFQUFFO29CQUM3QyxJQUFJLENBQUN2cUIsQ0FBQyxJQUFJLElBQUksQ0FBQ2lMLEVBQUUsR0FBR0E7b0JBQ3BCLElBQUksQ0FBQ0EsRUFBRSxHQUFHQTtnQkFDZDtnQkFFQXpJLE1BQU1nRixTQUFTLENBQUNyQixLQUFLLEdBQUc7b0JBQ3BCLElBQUlBLFFBQVEsSUFBSTNEO29CQUNoQjJELE1BQU1vRixXQUFXLENBQUNkLEdBQUcsQ0FBQyxJQUFJLENBQUNjLFdBQVc7b0JBQ3RDcEYsTUFBTWtwQixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO29CQUMxQmxwQixNQUFNOEUsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRTtvQkFDbEI5RSxNQUFNbkcsQ0FBQyxHQUFHLElBQUksQ0FBQ0EsQ0FBQztvQkFDaEJtRyxNQUFNNkUsRUFBRSxDQUFDUCxHQUFHLENBQUMsSUFBSSxDQUFDTyxFQUFFO29CQUNwQjdFLE1BQU00RSxDQUFDLENBQUNOLEdBQUcsQ0FBQyxJQUFJLENBQUNNLENBQUM7b0JBQ2xCLE9BQU81RTtnQkFDWDtnQkFFQTNELE1BQU1nRixTQUFTLENBQUNpRCxHQUFHLEdBQUcsU0FBUzhELElBQUk7b0JBQy9CLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ2QsR0FBRyxDQUFDOEQsS0FBS2hELFdBQVc7b0JBQ3JDLElBQUksQ0FBQzhqQixNQUFNLEdBQUc5Z0IsS0FBSzhnQixNQUFNO29CQUN6QixJQUFJLENBQUNwa0IsRUFBRSxHQUFHc0QsS0FBS3RELEVBQUU7b0JBQ2pCLElBQUksQ0FBQ2pMLENBQUMsR0FBR3VPLEtBQUt2TyxDQUFDO29CQUNmLElBQUksQ0FBQ2dMLEVBQUUsQ0FBQ1AsR0FBRyxDQUFDOEQsS0FBS3ZELEVBQUU7b0JBQ25CLElBQUksQ0FBQ0QsQ0FBQyxDQUFDTixHQUFHLENBQUM4RCxLQUFLeEQsQ0FBQztnQkFDckI7WUFHQTtZQUFFO2dCQUFDLGtCQUFpQjtnQkFBRyxVQUFTO2dCQUFHLFNBQVE7Z0JBQUcsZUFBYztnQkFBRyxVQUFTO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTOUssUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ2hILElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHNkI7Z0JBRWpCLElBQUlxQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsc0JBQXNCO2dCQUN0Qjs7Ozs7OztDQU9DLEdBQ0QsU0FBU2EsVUFBVWlELFFBQVEsRUFBRXVxQixRQUFRO29CQUNqQyxJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVl4dEIsU0FBUSxHQUFJO3dCQUM5QixPQUFPLElBQUlBLFVBQVVpRCxVQUFVdXFCO29CQUNuQztvQkFDQSxJQUFJLENBQUNwb0IsQ0FBQyxHQUFHeEYsS0FBS3NELElBQUk7b0JBQ2xCLElBQUksQ0FBQ29DLENBQUMsR0FBR3JGLElBQUlrRixRQUFRO29CQUNyQixJQUFJLE9BQU9sQyxhQUFhLGFBQWE7d0JBQ2pDLElBQUksQ0FBQ21DLENBQUMsQ0FBQ3VFLEdBQUcsQ0FBQzFHO29CQUNmO29CQUNBLElBQUksT0FBT3VxQixhQUFhLGFBQWE7d0JBQ2pDLElBQUksQ0FBQ2xvQixDQUFDLENBQUNxRSxHQUFHLENBQUM2akI7b0JBQ2Y7Z0JBQ0o7Z0JBRUF4dEIsVUFBVXFGLEtBQUssR0FBRyxTQUFTeUUsRUFBRTtvQkFDekIsSUFBSW0rQixNQUFNM2dCLE9BQU96RixNQUFNLENBQUM3aEIsVUFBVTBHLFNBQVM7b0JBQzNDdWhDLElBQUk3aUMsQ0FBQyxHQUFHeEYsS0FBS3lGLEtBQUssQ0FBQ3lFLEdBQUcxRSxDQUFDO29CQUN2QjZpQyxJQUFJM2lDLENBQUMsR0FBR3JGLElBQUlvRixLQUFLLENBQUN5RSxHQUFHeEUsQ0FBQztvQkFDdEIsT0FBTzJpQztnQkFDWDtnQkFFQWpvQyxVQUFVOG5CLEdBQUcsR0FBRyxTQUFTN2tCLFFBQVEsRUFBRXVxQixRQUFRO29CQUN2QyxJQUFJeWEsTUFBTTNnQixPQUFPekYsTUFBTSxDQUFDN2hCLFVBQVUwRyxTQUFTO29CQUMzQ3VoQyxJQUFJN2lDLENBQUMsR0FBR3hGLEtBQUt5RixLQUFLLENBQUNwQztvQkFDbkJnbEMsSUFBSTNpQyxDQUFDLEdBQUdyRixJQUFJb0YsS0FBSyxDQUFDbW9CO29CQUNsQixPQUFPeWE7Z0JBQ1g7Z0JBRUFqb0MsVUFBVW1GLFFBQVEsR0FBRztvQkFDakIsSUFBSThpQyxNQUFNM2dCLE9BQU96RixNQUFNLENBQUM3aEIsVUFBVTBHLFNBQVM7b0JBQzNDdWhDLElBQUk3aUMsQ0FBQyxHQUFHeEYsS0FBS3NELElBQUk7b0JBQ2pCK2tDLElBQUkzaUMsQ0FBQyxHQUFHckYsSUFBSWtGLFFBQVE7b0JBQ3BCLE9BQU84aUM7Z0JBQ1g7Z0JBRUE7O0NBRUMsR0FDRGpvQyxVQUFVMEcsU0FBUyxDQUFDNFMsV0FBVyxHQUFHO29CQUM5QixJQUFJLENBQUNsVSxDQUFDLENBQUMwQyxPQUFPO29CQUNkLElBQUksQ0FBQ3hDLENBQUMsQ0FBQ2dVLFdBQVc7b0JBQ2xCLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7Q0FFQyxHQUNEdFosVUFBVTBHLFNBQVMsQ0FBQ2lELEdBQUcsR0FBRyxTQUFTekssQ0FBQyxFQUFFdXRCLENBQUM7b0JBQ25DLElBQUksT0FBT0EsTUFBTSxhQUFhO3dCQUMxQixJQUFJLENBQUNybkIsQ0FBQyxDQUFDdUUsR0FBRyxDQUFDekssRUFBRWtHLENBQUM7d0JBQ2QsSUFBSSxDQUFDRSxDQUFDLENBQUNxRSxHQUFHLENBQUN6SyxFQUFFb0csQ0FBQztvQkFDbEIsT0FBTzt3QkFDSCxJQUFJLENBQUNGLENBQUMsQ0FBQ3VFLEdBQUcsQ0FBQ3pLO3dCQUNYLElBQUksQ0FBQ29HLENBQUMsQ0FBQ3FFLEdBQUcsQ0FBQzhpQjtvQkFDZjtnQkFDSjtnQkFFQXpzQixVQUFVa0UsT0FBTyxHQUFHLFNBQVNsRixDQUFDO29CQUMxQixPQUFPQSxLQUFLWSxLQUFLc0UsT0FBTyxDQUFDbEYsRUFBRW9HLENBQUMsS0FBS25GLElBQUlpRSxPQUFPLENBQUNsRixFQUFFc0csQ0FBQztnQkFDcEQ7Z0JBRUF0RixVQUFVaUUsTUFBTSxHQUFHLFNBQVNqRixDQUFDO29CQUN6QixJQUFJLENBQUNtRCxTQUFTO29CQUNkLElBQUksQ0FBQ25DLFVBQVVrRSxPQUFPLENBQUNsRixJQUFJO3dCQUN2QmlELFVBQVVJLFFBQU84ckIsS0FBSyxDQUFDbnZCO3dCQUN2QixNQUFNLElBQUlLLE1BQU07b0JBQ3BCO2dCQUNKO2dCQUVBOzs7Ozs7OztDQVFDLEdBQ0RXLFVBQVUwTSxHQUFHLEdBQUcsU0FBU3hOLENBQUMsRUFBRXV0QixDQUFDO29CQUN6QnRxQixXQUFXbkMsVUFBVWlFLE1BQU0sQ0FBQy9FO29CQUM1QixJQUFJNnBDLE1BQU1DLE9BQU8sQ0FBQ3ZjLElBQUk7d0JBQ2xCLElBQUl3YyxNQUFNLEVBQUU7d0JBQ1osSUFBSyxJQUFJN3BDLElBQUksR0FBR0EsSUFBSXF0QixFQUFFaHRCLE1BQU0sRUFBRUwsSUFBSzs0QkFDL0I2cEMsR0FBRyxDQUFDN3BDLEVBQUUsR0FBR1ksVUFBVTBNLEdBQUcsQ0FBQ3hOLEdBQUd1dEIsQ0FBQyxDQUFDcnRCLEVBQUU7d0JBQ2xDO3dCQUNBLE9BQU82cEM7b0JBQ1gsT0FBTyxJQUFJLE9BQU94YyxLQUFLLE9BQU9BLEdBQUc7d0JBQzdCdHFCLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDd29CO3dCQUN2QixJQUFJdE4sSUFBSWpnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHd2lCLEVBQUV0TixDQUFDLEdBQUdqZ0IsRUFBRW9HLENBQUMsQ0FBQ3ZHLENBQUMsR0FBRzB0QixFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUVrRyxDQUFDLENBQUMrWixDQUFDO3dCQUN6QyxJQUFJRSxJQUFJbmdCLEVBQUVvRyxDQUFDLENBQUN2RyxDQUFDLEdBQUcwdEIsRUFBRXROLENBQUMsR0FBR2pnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHd2lCLEVBQUVwTixDQUFDLEdBQUduZ0IsRUFBRWtHLENBQUMsQ0FBQ2lhLENBQUM7d0JBQ3pDLE9BQU96ZixLQUFLa29CLEdBQUcsQ0FBQzNJLEdBQUdFO29CQUN2QixPQUFPLElBQUksT0FBT29OLEtBQUssT0FBT0EsR0FBRzt3QkFDN0J0cUIsV0FBV25DLFVBQVVpRSxNQUFNLENBQUN3b0I7d0JBQzVCLHdDQUF3Qzt3QkFDeEMsNkNBQTZDO3dCQUM3QyxJQUFJM2lCLEtBQUs5SixVQUFVbUYsUUFBUTt3QkFDM0IyRSxHQUFHeEUsQ0FBQyxHQUFHckYsSUFBSXlvQyxNQUFNLENBQUN4cEMsRUFBRW9HLENBQUMsRUFBRW1uQixFQUFFbm5CLENBQUM7d0JBQzFCd0UsR0FBRzFFLENBQUMsR0FBR3hGLEtBQUtrTCxHQUFHLENBQUM3SyxJQUFJNE8sT0FBTyxDQUFDM1AsRUFBRW9HLENBQUMsRUFBRW1uQixFQUFFcm5CLENBQUMsR0FBR2xHLEVBQUVrRyxDQUFDO3dCQUMxQyxPQUFPMEU7b0JBQ1g7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRDlKLFVBQVVrcEMsTUFBTSxHQUFHLFNBQVNocUMsQ0FBQyxFQUFFdXRCLENBQUM7b0JBQzVCdHFCLFdBQVduQyxVQUFVaUUsTUFBTSxDQUFDL0U7b0JBQzVCLElBQUkrcEMsTUFBTSxFQUFFO29CQUNaLElBQUssSUFBSTdwQyxJQUFJLEdBQUdBLElBQUlxdEIsRUFBRWh0QixNQUFNLEVBQUVMLElBQUs7d0JBQy9CNnBDLEdBQUcsQ0FBQzdwQyxFQUFFLEdBQUdZLFVBQVUwTSxHQUFHLENBQUN4TixHQUFHdXRCLENBQUMsQ0FBQ3J0QixFQUFFO29CQUNsQztvQkFDQSxPQUFPNnBDO2dCQUNYO2dCQUVBOztDQUVDLEdBQ0RqcEMsVUFBVW1wQyxLQUFLLEdBQUcsU0FBU2pxQyxDQUFDO29CQUN4QmlELFdBQVduQyxVQUFVaUUsTUFBTSxDQUFDL0U7b0JBQzVCLE9BQU8sU0FBU3V0QixDQUFDO3dCQUNiLE9BQU96c0IsVUFBVTBNLEdBQUcsQ0FBQ3hOLEdBQUd1dEI7b0JBQzVCO2dCQUNKO2dCQUVBenNCLFVBQVU2TyxPQUFPLEdBQUcsU0FBUzNQLENBQUMsRUFBRXV0QixDQUFDO29CQUM3QnRxQixXQUFXbkMsVUFBVWlFLE1BQU0sQ0FBQy9FO29CQUM1QmlELFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDd29CO29CQUN2QixJQUFJdE4sSUFBSWpnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHd2lCLEVBQUV0TixDQUFDLEdBQUdqZ0IsRUFBRW9HLENBQUMsQ0FBQ3ZHLENBQUMsR0FBRzB0QixFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUVrRyxDQUFDLENBQUMrWixDQUFDO29CQUN6QyxJQUFJRSxJQUFJbmdCLEVBQUVvRyxDQUFDLENBQUN2RyxDQUFDLEdBQUcwdEIsRUFBRXROLENBQUMsR0FBR2pnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHd2lCLEVBQUVwTixDQUFDLEdBQUduZ0IsRUFBRWtHLENBQUMsQ0FBQ2lhLENBQUM7b0JBQ3pDLE9BQU96ZixLQUFLa29CLEdBQUcsQ0FBQzNJLEdBQUdFO2dCQUN2QjtnQkFFQXJmLFVBQVV3WixRQUFRLEdBQUcsU0FBU3RhLENBQUMsRUFBRXV0QixDQUFDLEVBQUV3WixDQUFDO29CQUNqQzlqQyxXQUFXbkMsVUFBVWlFLE1BQU0sQ0FBQy9FO29CQUM1QmlELFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDd29CO29CQUN2QixJQUFJdE4sSUFBSWpnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHd2lCLEVBQUV0TixDQUFDLEdBQUdqZ0IsRUFBRW9HLENBQUMsQ0FBQ3ZHLENBQUMsR0FBRzB0QixFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUVrRyxDQUFDLENBQUMrWixDQUFDO29CQUN6QyxJQUFJRSxJQUFJbmdCLEVBQUVvRyxDQUFDLENBQUN2RyxDQUFDLEdBQUcwdEIsRUFBRXROLENBQUMsR0FBR2pnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHd2lCLEVBQUVwTixDQUFDLEdBQUduZ0IsRUFBRWtHLENBQUMsQ0FBQ2lhLENBQUM7b0JBQ3pDLE9BQU80bUIsRUFBRXQ4QixHQUFHLENBQUN3VixHQUFHRTtnQkFDcEI7Z0JBRUFyZixVQUFVb3BDLEtBQUssR0FBRyxTQUFTbHFDLENBQUMsRUFBRXV0QixDQUFDO29CQUMzQnRxQixXQUFXbkMsVUFBVWlFLE1BQU0sQ0FBQy9FO29CQUM1QmlELFdBQVduQyxVQUFVaUUsTUFBTSxDQUFDd29CO29CQUM1Qix3Q0FBd0M7b0JBQ3hDLDZDQUE2QztvQkFDN0MsSUFBSTNpQixLQUFLOUosVUFBVW1GLFFBQVE7b0JBQzNCMkUsR0FBR3hFLENBQUMsR0FBR3JGLElBQUl5b0MsTUFBTSxDQUFDeHBDLEVBQUVvRyxDQUFDLEVBQUVtbkIsRUFBRW5uQixDQUFDO29CQUMxQndFLEdBQUcxRSxDQUFDLEdBQUd4RixLQUFLa0wsR0FBRyxDQUFDN0ssSUFBSTRPLE9BQU8sQ0FBQzNQLEVBQUVvRyxDQUFDLEVBQUVtbkIsRUFBRXJuQixDQUFDLEdBQUdsRyxFQUFFa0csQ0FBQztvQkFDMUMsT0FBTzBFO2dCQUNYO2dCQUVBOzs7Ozs7OztDQVFDLEdBQ0Q5SixVQUFVbW1DLElBQUksR0FBRyxTQUFTam5DLENBQUMsRUFBRXV0QixDQUFDO29CQUMxQnRxQixXQUFXbkMsVUFBVWlFLE1BQU0sQ0FBQy9FO29CQUM1QixJQUFJLE9BQU91dEIsS0FBSyxPQUFPQSxHQUFHO3dCQUN0QnRxQixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3dvQjt3QkFDdkIsSUFBSTRjLEtBQUs1YyxFQUFFdE4sQ0FBQyxHQUFHamdCLEVBQUVrRyxDQUFDLENBQUMrWixDQUFDO3dCQUNwQixJQUFJbXFCLEtBQUs3YyxFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUVrRyxDQUFDLENBQUNpYSxDQUFDO3dCQUNwQixJQUFJRixJQUFJamdCLEVBQUVvRyxDQUFDLENBQUMyRSxDQUFDLEdBQUdvL0IsS0FBS25xQyxFQUFFb0csQ0FBQyxDQUFDdkcsQ0FBQyxHQUFHdXFDO3dCQUM3QixJQUFJanFCLElBQUksQ0FBQ25nQixFQUFFb0csQ0FBQyxDQUFDdkcsQ0FBQyxHQUFHc3FDLEtBQUtucUMsRUFBRW9HLENBQUMsQ0FBQzJFLENBQUMsR0FBR3EvQjt3QkFDOUIsT0FBTzFwQyxLQUFLa29CLEdBQUcsQ0FBQzNJLEdBQUdFO29CQUN2QixPQUFPLElBQUksT0FBT29OLEtBQUssT0FBT0EsR0FBRzt3QkFDN0J0cUIsV0FBV25DLFVBQVVpRSxNQUFNLENBQUN3b0I7d0JBQzVCLHFDQUFxQzt3QkFDckMseUNBQXlDO3dCQUN6QyxJQUFJM2lCLEtBQUs5SixVQUFVbUYsUUFBUTt3QkFDM0IyRSxHQUFHeEUsQ0FBQyxDQUFDcUUsR0FBRyxDQUFDMUosSUFBSTJvQyxPQUFPLENBQUMxcEMsRUFBRW9HLENBQUMsRUFBRW1uQixFQUFFbm5CLENBQUM7d0JBQzdCd0UsR0FBRzFFLENBQUMsQ0FBQ3VFLEdBQUcsQ0FBQzFKLElBQUlnUCxRQUFRLENBQUMvUCxFQUFFb0csQ0FBQyxFQUFFMUYsS0FBS2lMLEdBQUcsQ0FBQzRoQixFQUFFcm5CLENBQUMsRUFBRWxHLEVBQUVrRyxDQUFDO3dCQUM1QyxPQUFPMEU7b0JBQ1g7Z0JBQ0o7Z0JBRUE5SixVQUFVaVAsUUFBUSxHQUFHLFNBQVMvUCxDQUFDLEVBQUV1dEIsQ0FBQztvQkFDOUJ0cUIsV0FBV25DLFVBQVVpRSxNQUFNLENBQUMvRTtvQkFDNUJpRCxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3dvQjtvQkFDdkIsSUFBSTRjLEtBQUs1YyxFQUFFdE4sQ0FBQyxHQUFHamdCLEVBQUVrRyxDQUFDLENBQUMrWixDQUFDO29CQUNwQixJQUFJbXFCLEtBQUs3YyxFQUFFcE4sQ0FBQyxHQUFHbmdCLEVBQUVrRyxDQUFDLENBQUNpYSxDQUFDO29CQUNwQixJQUFJRixJQUFJamdCLEVBQUVvRyxDQUFDLENBQUMyRSxDQUFDLEdBQUdvL0IsS0FBS25xQyxFQUFFb0csQ0FBQyxDQUFDdkcsQ0FBQyxHQUFHdXFDO29CQUM3QixJQUFJanFCLElBQUksQ0FBQ25nQixFQUFFb0csQ0FBQyxDQUFDdkcsQ0FBQyxHQUFHc3FDLEtBQUtucUMsRUFBRW9HLENBQUMsQ0FBQzJFLENBQUMsR0FBR3EvQjtvQkFDOUIsT0FBTzFwQyxLQUFLa29CLEdBQUcsQ0FBQzNJLEdBQUdFO2dCQUN2QjtnQkFFQXJmLFVBQVU4b0MsU0FBUyxHQUFHLFNBQVM1cEMsQ0FBQyxFQUFFdXRCLENBQUMsRUFBRXdaLENBQUM7b0JBQ2xDOWpDLFdBQVduQyxVQUFVaUUsTUFBTSxDQUFDL0U7b0JBQzVCaUQsV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN3b0I7b0JBQ3ZCLElBQUk0YyxLQUFLNWMsRUFBRXROLENBQUMsR0FBR2pnQixFQUFFa0csQ0FBQyxDQUFDK1osQ0FBQztvQkFDcEIsSUFBSW1xQixLQUFLN2MsRUFBRXBOLENBQUMsR0FBR25nQixFQUFFa0csQ0FBQyxDQUFDaWEsQ0FBQztvQkFDcEIsSUFBSUYsSUFBSWpnQixFQUFFb0csQ0FBQyxDQUFDMkUsQ0FBQyxHQUFHby9CLEtBQUtucUMsRUFBRW9HLENBQUMsQ0FBQ3ZHLENBQUMsR0FBR3VxQztvQkFDN0IsSUFBSWpxQixJQUFJLENBQUNuZ0IsRUFBRW9HLENBQUMsQ0FBQ3ZHLENBQUMsR0FBR3NxQyxLQUFLbnFDLEVBQUVvRyxDQUFDLENBQUMyRSxDQUFDLEdBQUdxL0I7b0JBQzlCLE9BQU9yRCxFQUFFdDhCLEdBQUcsQ0FBQ3dWLEdBQUdFO2dCQUNwQjtnQkFFQXJmLFVBQVV1cEMsTUFBTSxHQUFHLFNBQVNycUMsQ0FBQyxFQUFFdXRCLENBQUM7b0JBQzVCdHFCLFdBQVduQyxVQUFVaUUsTUFBTSxDQUFDL0U7b0JBQzVCaUQsV0FBV25DLFVBQVVpRSxNQUFNLENBQUN3b0I7b0JBQzVCLHFDQUFxQztvQkFDckMseUNBQXlDO29CQUN6QyxJQUFJM2lCLEtBQUs5SixVQUFVbUYsUUFBUTtvQkFDM0IyRSxHQUFHeEUsQ0FBQyxDQUFDcUUsR0FBRyxDQUFDMUosSUFBSTJvQyxPQUFPLENBQUMxcEMsRUFBRW9HLENBQUMsRUFBRW1uQixFQUFFbm5CLENBQUM7b0JBQzdCd0UsR0FBRzFFLENBQUMsQ0FBQ3VFLEdBQUcsQ0FBQzFKLElBQUlnUCxRQUFRLENBQUMvUCxFQUFFb0csQ0FBQyxFQUFFMUYsS0FBS2lMLEdBQUcsQ0FBQzRoQixFQUFFcm5CLENBQUMsRUFBRWxHLEVBQUVrRyxDQUFDO29CQUM1QyxPQUFPMEU7Z0JBQ1g7Z0JBRUEsSUFBSTAvQixPQUFPNXBDLEtBQUtzRCxJQUFJO2dCQUVwQmxELFVBQVV5cEMsT0FBTyxHQUFHLFNBQVN2cUMsQ0FBQyxFQUFFdXRCLENBQUMsRUFBRXdaLENBQUM7b0JBQ2hDOWpDLFdBQVduQyxVQUFVaUUsTUFBTSxDQUFDL0U7b0JBQzVCaUQsV0FBV25DLFVBQVVpRSxNQUFNLENBQUN3b0I7b0JBQzVCLHFDQUFxQztvQkFDckMseUNBQXlDO29CQUN6Q3hzQixJQUFJNG9DLFFBQVEsQ0FBQzNwQyxFQUFFb0csQ0FBQyxFQUFFbW5CLEVBQUVubkIsQ0FBQyxFQUFFMmdDLEVBQUUzZ0MsQ0FBQztvQkFDMUJyRixJQUFJNm9DLFNBQVMsQ0FBQzVwQyxFQUFFb0csQ0FBQyxFQUFFMUYsS0FBS2lMLEdBQUcsQ0FBQzRoQixFQUFFcm5CLENBQUMsRUFBRWxHLEVBQUVrRyxDQUFDLEVBQUVva0MsT0FBT3ZELEVBQUU3Z0MsQ0FBQztvQkFDaEQsT0FBTzZnQztnQkFDWDtZQUdBO1lBQUU7Z0JBQUMsa0JBQWlCO2dCQUFHLFNBQVE7Z0JBQUcsVUFBUztZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBUzltQyxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDbkYsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERoRSxRQUFPRCxPQUFPLEdBQUd5QjtnQkFFakIsSUFBSXlDLFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixTQUFTUyxLQUFLdWYsQ0FBQyxFQUFFRSxDQUFDO29CQUNkLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWXpmLElBQUcsR0FBSTt3QkFDekIsT0FBTyxJQUFJQSxLQUFLdWYsR0FBR0U7b0JBQ3ZCO29CQUNBLElBQUksT0FBT0YsTUFBTSxhQUFhO3dCQUMxQixJQUFJLENBQUNBLENBQUMsR0FBRzt3QkFDVCxJQUFJLENBQUNFLENBQUMsR0FBRztvQkFDYixPQUFPLElBQUksT0FBT0YsTUFBTSxVQUFVO3dCQUM5QixJQUFJLENBQUNBLENBQUMsR0FBR0EsRUFBRUEsQ0FBQzt3QkFDWixJQUFJLENBQUNFLENBQUMsR0FBR0YsRUFBRUUsQ0FBQztvQkFDaEIsT0FBTzt3QkFDSCxJQUFJLENBQUNGLENBQUMsR0FBR0E7d0JBQ1QsSUFBSSxDQUFDRSxDQUFDLEdBQUdBO29CQUNiO29CQUNBbGQsV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUMsSUFBSTtnQkFDL0I7Z0JBRUFyRSxLQUFLc0QsSUFBSSxHQUFHO29CQUNSLElBQUkra0MsTUFBTTNnQixPQUFPekYsTUFBTSxDQUFDamlCLEtBQUs4RyxTQUFTO29CQUN0Q3VoQyxJQUFJOW9CLENBQUMsR0FBRztvQkFDUjhvQixJQUFJNW9CLENBQUMsR0FBRztvQkFDUixPQUFPNG9CO2dCQUNYO2dCQUVBcm9DLEtBQUtrb0IsR0FBRyxHQUFHLFNBQVMzSSxDQUFDLEVBQUVFLENBQUM7b0JBQ3BCLElBQUk0b0IsTUFBTTNnQixPQUFPekYsTUFBTSxDQUFDamlCLEtBQUs4RyxTQUFTO29CQUN0Q3VoQyxJQUFJOW9CLENBQUMsR0FBR0E7b0JBQ1I4b0IsSUFBSTVvQixDQUFDLEdBQUdBO29CQUNSLE9BQU80b0I7Z0JBQ1g7Z0JBRUFyb0MsS0FBS3lGLEtBQUssR0FBRyxTQUFTK0YsQ0FBQztvQkFDbkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QixPQUFPeEwsS0FBS2tvQixHQUFHLENBQUMxYyxFQUFFK1QsQ0FBQyxFQUFFL1QsRUFBRWlVLENBQUM7Z0JBQzVCO2dCQUVBemYsS0FBSzhHLFNBQVMsQ0FBQ3N4QixRQUFRLEdBQUc7b0JBQ3RCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQyxJQUFJO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEdDRCLEtBQUtzRSxPQUFPLEdBQUcsU0FBU2tILENBQUM7b0JBQ3JCLE9BQU9BLEtBQUt6TCxNQUFLd0UsUUFBUSxDQUFDaUgsRUFBRStULENBQUMsS0FBS3hmLE1BQUt3RSxRQUFRLENBQUNpSCxFQUFFaVUsQ0FBQztnQkFDdkQ7Z0JBRUF6ZixLQUFLcUUsTUFBTSxHQUFHLFNBQVNqRixDQUFDO29CQUNwQixJQUFJLENBQUNtRCxTQUFTO29CQUNkLElBQUksQ0FBQ3ZDLEtBQUtzRSxPQUFPLENBQUNsRixJQUFJO3dCQUNsQmlELFVBQVVJLFFBQU84ckIsS0FBSyxDQUFDbnZCO3dCQUN2QixNQUFNLElBQUlLLE1BQU07b0JBQ3BCO2dCQUNKO2dCQUVBTyxLQUFLOEcsU0FBUyxDQUFDckIsS0FBSyxHQUFHO29CQUNuQixPQUFPekYsS0FBS3lGLEtBQUssQ0FBQyxJQUFJO2dCQUMxQjtnQkFFQTs7OztDQUlDLEdBQ0R6RixLQUFLOEcsU0FBUyxDQUFDb0IsT0FBTyxHQUFHO29CQUNyQixJQUFJLENBQUNxWCxDQUFDLEdBQUc7b0JBQ1QsSUFBSSxDQUFDRSxDQUFDLEdBQUc7b0JBQ1QsT0FBTyxJQUFJO2dCQUNmO2dCQUVBOzs7O0NBSUMsR0FDRHpmLEtBQUs4RyxTQUFTLENBQUNpRCxHQUFHLEdBQUcsU0FBU3dWLENBQUMsRUFBRUUsQ0FBQztvQkFDOUIsSUFBSSxPQUFPRixNQUFNLFVBQVU7d0JBQ3ZCaGQsV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNrYjt3QkFDdkIsSUFBSSxDQUFDQSxDQUFDLEdBQUdBLEVBQUVBLENBQUM7d0JBQ1osSUFBSSxDQUFDRSxDQUFDLEdBQUdGLEVBQUVFLENBQUM7b0JBQ2hCLE9BQU87d0JBQ0hsZCxXQUFXeEMsTUFBS3NFLE1BQU0sQ0FBQ2tiO3dCQUN2QmhkLFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDb2I7d0JBQ3ZCLElBQUksQ0FBQ0YsQ0FBQyxHQUFHQTt3QkFDVCxJQUFJLENBQUNFLENBQUMsR0FBR0E7b0JBQ2I7b0JBQ0EsT0FBTyxJQUFJO2dCQUNmO2dCQUVBemYsS0FBSzhHLFNBQVMsQ0FBQ2dqQyxLQUFLLEdBQUcsU0FBU3ZxQixDQUFDLEVBQUVFLENBQUM7b0JBQ2hDLElBQUksQ0FBQ0YsQ0FBQyxHQUFHQTtvQkFDVCxJQUFJLENBQUNFLENBQUMsR0FBR0E7b0JBQ1QsT0FBTyxJQUFJO2dCQUNmO2dCQUVBemYsS0FBSzhHLFNBQVMsQ0FBQzZNLE9BQU8sR0FBRyxTQUFTNEwsQ0FBQztvQkFDL0IsSUFBSSxDQUFDQSxDQUFDLEdBQUdBLEVBQUVBLENBQUM7b0JBQ1osSUFBSSxDQUFDRSxDQUFDLEdBQUdGLEVBQUVFLENBQUM7b0JBQ1osT0FBTyxJQUFJO2dCQUNmO2dCQUVBOztDQUVDLEdBQ0R6ZixLQUFLOEcsU0FBUyxDQUFDaWpDLElBQUksR0FBRyxTQUFTenFDLENBQUMsRUFBRWtNLENBQUMsRUFBRXFoQixDQUFDLEVBQUVqaEIsQ0FBQztvQkFDckMsSUFBSSxPQUFPaWhCLE1BQU0sZUFBZSxPQUFPamhCLE1BQU0sYUFBYTt3QkFDdEQsT0FBTyxJQUFJLENBQUM0USxVQUFVLENBQUNsZCxHQUFHa00sR0FBR3FoQixHQUFHamhCO29CQUNwQyxPQUFPO3dCQUNILE9BQU8sSUFBSSxDQUFDbytCLE1BQU0sQ0FBQzFxQyxHQUFHa007b0JBQzFCO2dCQUNKO2dCQUVBOztDQUVDLEdBQ0R4TCxLQUFLOEcsU0FBUyxDQUFDMFYsVUFBVSxHQUFHLFNBQVNsZCxDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUM7b0JBQzNDckosV0FBV3hDLE1BQUtzRSxNQUFNLENBQUMvRTtvQkFDdkJpRCxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QmpKLFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDd29CO29CQUN2QnRxQixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixJQUFJMlQsSUFBSWpnQixJQUFJa00sRUFBRStULENBQUMsR0FBR3NOLElBQUlqaEIsRUFBRTJULENBQUM7b0JBQ3pCLElBQUlFLElBQUluZ0IsSUFBSWtNLEVBQUVpVSxDQUFDLEdBQUdvTixJQUFJamhCLEVBQUU2VCxDQUFDO29CQUN6QixvQkFBb0I7b0JBQ3BCLElBQUksQ0FBQ0YsQ0FBQyxHQUFHQTtvQkFDVCxJQUFJLENBQUNFLENBQUMsR0FBR0E7b0JBQ1QsT0FBTyxJQUFJO2dCQUNmO2dCQUVBemYsS0FBSzhHLFNBQVMsQ0FBQ2tqQyxNQUFNLEdBQUcsU0FBUzFxQyxDQUFDLEVBQUVrTSxDQUFDO29CQUNqQ2pKLFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDL0U7b0JBQ3ZCaUQsV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkIsSUFBSStULElBQUlqZ0IsSUFBSWtNLEVBQUUrVCxDQUFDO29CQUNmLElBQUlFLElBQUluZ0IsSUFBSWtNLEVBQUVpVSxDQUFDO29CQUNmLElBQUksQ0FBQ0YsQ0FBQyxHQUFHQTtvQkFDVCxJQUFJLENBQUNFLENBQUMsR0FBR0E7b0JBQ1QsT0FBTyxJQUFJO2dCQUNmO2dCQUVBOzs7O0NBSUMsR0FDRHpmLEtBQUs4RyxTQUFTLENBQUNvRSxHQUFHLEdBQUcsU0FBU1UsQ0FBQztvQkFDM0JySixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixJQUFJLENBQUMyVCxDQUFDLElBQUkzVCxFQUFFMlQsQ0FBQztvQkFDYixJQUFJLENBQUNFLENBQUMsSUFBSTdULEVBQUU2VCxDQUFDO29CQUNiLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7Q0FFQyxHQUNEemYsS0FBSzhHLFNBQVMsQ0FBQ21qQyxJQUFJLEdBQUcsU0FBUzNxQyxDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUM7b0JBQ3JDLElBQUksT0FBT2loQixNQUFNLGVBQWUsT0FBT2poQixNQUFNLGFBQWE7d0JBQ3RELE9BQU8sSUFBSSxDQUFDcytCLFVBQVUsQ0FBQzVxQyxHQUFHa00sR0FBR3FoQixHQUFHamhCO29CQUNwQyxPQUFPO3dCQUNILE9BQU8sSUFBSSxDQUFDaUIsTUFBTSxDQUFDdk4sR0FBR2tNO29CQUMxQjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEeEwsS0FBSzhHLFNBQVMsQ0FBQ29qQyxVQUFVLEdBQUcsU0FBUzVxQyxDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUM7b0JBQzNDckosV0FBV3hDLE1BQUtzRSxNQUFNLENBQUMvRTtvQkFDdkJpRCxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QmpKLFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDd29CO29CQUN2QnRxQixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixJQUFJMlQsSUFBSWpnQixJQUFJa00sRUFBRStULENBQUMsR0FBR3NOLElBQUlqaEIsRUFBRTJULENBQUM7b0JBQ3pCLElBQUlFLElBQUluZ0IsSUFBSWtNLEVBQUVpVSxDQUFDLEdBQUdvTixJQUFJamhCLEVBQUU2VCxDQUFDO29CQUN6QixvQkFBb0I7b0JBQ3BCLElBQUksQ0FBQ0YsQ0FBQyxJQUFJQTtvQkFDVixJQUFJLENBQUNFLENBQUMsSUFBSUE7b0JBQ1YsT0FBTyxJQUFJO2dCQUNmO2dCQUVBemYsS0FBSzhHLFNBQVMsQ0FBQytGLE1BQU0sR0FBRyxTQUFTdk4sQ0FBQyxFQUFFa00sQ0FBQztvQkFDakNqSixXQUFXeEMsTUFBS3NFLE1BQU0sQ0FBQy9FO29CQUN2QmlELFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCLElBQUkrVCxJQUFJamdCLElBQUlrTSxFQUFFK1QsQ0FBQztvQkFDZixJQUFJRSxJQUFJbmdCLElBQUlrTSxFQUFFaVUsQ0FBQztvQkFDZixJQUFJLENBQUNGLENBQUMsSUFBSUE7b0JBQ1YsSUFBSSxDQUFDRSxDQUFDLElBQUlBO29CQUNWLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7Q0FFQyxHQUNEemYsS0FBSzhHLFNBQVMsQ0FBQ3FqQyxJQUFJLEdBQUcsU0FBUzdxQyxDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUM7b0JBQ3JDLElBQUksT0FBT2loQixNQUFNLGVBQWUsT0FBT2poQixNQUFNLGFBQWE7d0JBQ3RELE9BQU8sSUFBSSxDQUFDdytCLFVBQVUsQ0FBQzlxQyxHQUFHa00sR0FBR3FoQixHQUFHamhCO29CQUNwQyxPQUFPO3dCQUNILE9BQU8sSUFBSSxDQUFDeVAsTUFBTSxDQUFDL2IsR0FBR2tNO29CQUMxQjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEeEwsS0FBSzhHLFNBQVMsQ0FBQ3NqQyxVQUFVLEdBQUcsU0FBUzlxQyxDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUM7b0JBQzNDckosV0FBV3hDLE1BQUtzRSxNQUFNLENBQUMvRTtvQkFDdkJpRCxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QmpKLFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDd29CO29CQUN2QnRxQixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixJQUFJMlQsSUFBSWpnQixJQUFJa00sRUFBRStULENBQUMsR0FBR3NOLElBQUlqaEIsRUFBRTJULENBQUM7b0JBQ3pCLElBQUlFLElBQUluZ0IsSUFBSWtNLEVBQUVpVSxDQUFDLEdBQUdvTixJQUFJamhCLEVBQUU2VCxDQUFDO29CQUN6QixvQkFBb0I7b0JBQ3BCLElBQUksQ0FBQ0YsQ0FBQyxJQUFJQTtvQkFDVixJQUFJLENBQUNFLENBQUMsSUFBSUE7b0JBQ1YsT0FBTyxJQUFJO2dCQUNmO2dCQUVBemYsS0FBSzhHLFNBQVMsQ0FBQ3VVLE1BQU0sR0FBRyxTQUFTL2IsQ0FBQyxFQUFFa00sQ0FBQztvQkFDakNqSixXQUFXeEMsTUFBS3NFLE1BQU0sQ0FBQy9FO29CQUN2QmlELFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCLElBQUkrVCxJQUFJamdCLElBQUlrTSxFQUFFK1QsQ0FBQztvQkFDZixJQUFJRSxJQUFJbmdCLElBQUlrTSxFQUFFaVUsQ0FBQztvQkFDZixJQUFJLENBQUNGLENBQUMsSUFBSUE7b0JBQ1YsSUFBSSxDQUFDRSxDQUFDLElBQUlBO29CQUNWLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7OztDQUlDLEdBQ0R6ZixLQUFLOEcsU0FBUyxDQUFDbUUsR0FBRyxHQUFHLFNBQVNXLENBQUM7b0JBQzNCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1SDtvQkFDdkIsSUFBSSxDQUFDMlQsQ0FBQyxJQUFJM1QsRUFBRTJULENBQUM7b0JBQ2IsSUFBSSxDQUFDRSxDQUFDLElBQUk3VCxFQUFFNlQsQ0FBQztvQkFDYixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUE7Ozs7Q0FJQyxHQUNEemYsS0FBSzhHLFNBQVMsQ0FBQ2dHLEdBQUcsR0FBRyxTQUFTODdCLENBQUM7b0JBQzNCcm1DLFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDdWtDO29CQUN2QixJQUFJLENBQUNycEIsQ0FBQyxJQUFJcXBCO29CQUNWLElBQUksQ0FBQ25wQixDQUFDLElBQUltcEI7b0JBQ1YsT0FBTyxJQUFJO2dCQUNmO2dCQUVBOzs7O0NBSUMsR0FDRDVvQyxLQUFLOEcsU0FBUyxDQUFDakgsTUFBTSxHQUFHO29CQUNwQixPQUFPRyxLQUFLcXFDLFFBQVEsQ0FBQyxJQUFJO2dCQUM3QjtnQkFFQTs7Q0FFQyxHQUNEcnFDLEtBQUs4RyxTQUFTLENBQUNzaEIsYUFBYSxHQUFHO29CQUMzQixPQUFPcG9CLEtBQUtvb0IsYUFBYSxDQUFDLElBQUk7Z0JBQ2xDO2dCQUVBOzs7O0NBSUMsR0FDRHBvQixLQUFLOEcsU0FBUyxDQUFDb1QsU0FBUyxHQUFHO29CQUN2QixJQUFJcmEsU0FBUyxJQUFJLENBQUNBLE1BQU07b0JBQ3hCLElBQUlBLFNBQVNFLE1BQUtzb0IsT0FBTyxFQUFFO3dCQUN2QixPQUFPO29CQUNYO29CQUNBLElBQUlpaUIsWUFBWSxJQUFJenFDO29CQUNwQixJQUFJLENBQUMwZixDQUFDLElBQUkrcUI7b0JBQ1YsSUFBSSxDQUFDN3FCLENBQUMsSUFBSTZxQjtvQkFDVixPQUFPenFDO2dCQUNYO2dCQUVBOzs7O0NBSUMsR0FDREcsS0FBS3FxQyxRQUFRLEdBQUcsU0FBUzcrQixDQUFDO29CQUN0QmpKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCLE9BQU96TCxNQUFLNmhCLElBQUksQ0FBQ3BXLEVBQUUrVCxDQUFDLEdBQUcvVCxFQUFFK1QsQ0FBQyxHQUFHL1QsRUFBRWlVLENBQUMsR0FBR2pVLEVBQUVpVSxDQUFDO2dCQUMxQztnQkFFQTs7Q0FFQyxHQUNEemYsS0FBS29vQixhQUFhLEdBQUcsU0FBUzVjLENBQUM7b0JBQzNCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkIsT0FBT0EsRUFBRStULENBQUMsR0FBRy9ULEVBQUUrVCxDQUFDLEdBQUcvVCxFQUFFaVUsQ0FBQyxHQUFHalUsRUFBRWlVLENBQUM7Z0JBQ2hDO2dCQUVBemYsS0FBS3d3QixRQUFRLEdBQUcsU0FBU2hsQixDQUFDLEVBQUVJLENBQUM7b0JBQ3pCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixJQUFJdTRCLEtBQUszNEIsRUFBRStULENBQUMsR0FBRzNULEVBQUUyVCxDQUFDLEVBQUVnckIsS0FBSy8rQixFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTZULENBQUM7b0JBQ2xDLE9BQU8xZixNQUFLNmhCLElBQUksQ0FBQ3VpQixLQUFLQSxLQUFLb0csS0FBS0E7Z0JBQ3BDO2dCQUVBdnFDLEtBQUt3cUMsZUFBZSxHQUFHLFNBQVNoL0IsQ0FBQyxFQUFFSSxDQUFDO29CQUNoQ3JKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1SDtvQkFDdkIsSUFBSXU0QixLQUFLMzRCLEVBQUUrVCxDQUFDLEdBQUczVCxFQUFFMlQsQ0FBQyxFQUFFZ3JCLEtBQUsvK0IsRUFBRWlVLENBQUMsR0FBRzdULEVBQUU2VCxDQUFDO29CQUNsQyxPQUFPMGtCLEtBQUtBLEtBQUtvRyxLQUFLQTtnQkFDMUI7Z0JBRUF2cUMsS0FBS3UzQixRQUFRLEdBQUcsU0FBUy9yQixDQUFDLEVBQUVJLENBQUM7b0JBQ3pCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixPQUFPSixLQUFLSSxLQUFLLE9BQU9BLE1BQU0sWUFBWUEsTUFBTSxRQUFRSixFQUFFK1QsQ0FBQyxLQUFLM1QsRUFBRTJULENBQUMsSUFBSS9ULEVBQUVpVSxDQUFDLEtBQUs3VCxFQUFFNlQsQ0FBQztnQkFDdEY7Z0JBRUE7O0NBRUMsR0FDRHpmLEtBQUt5cUMsSUFBSSxHQUFHLFNBQVNqL0IsQ0FBQztvQkFDbEJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QixPQUFPeEwsS0FBS2tvQixHQUFHLENBQUMsQ0FBQzFjLEVBQUVpVSxDQUFDLEVBQUVqVSxFQUFFK1QsQ0FBQztnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRHZmLEtBQUt5TCxHQUFHLEdBQUcsU0FBU0QsQ0FBQyxFQUFFSSxDQUFDO29CQUNwQnJKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1SDtvQkFDdkIsT0FBT0osRUFBRStULENBQUMsR0FBRzNULEVBQUUyVCxDQUFDLEdBQUcvVCxFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTZULENBQUM7Z0JBQ2hDO2dCQUVBOzs7OztDQUtDLEdBQ0R6ZixLQUFLbUwsS0FBSyxHQUFHLFNBQVNLLENBQUMsRUFBRUksQ0FBQztvQkFDdEIsSUFBSSxPQUFPQSxNQUFNLFVBQVU7d0JBQ3ZCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDt3QkFDdkJqSixXQUFXeEMsTUFBS3NFLE1BQU0sQ0FBQ3VIO3dCQUN2QixPQUFPNUwsS0FBS2tvQixHQUFHLENBQUN0YyxJQUFJSixFQUFFaVUsQ0FBQyxFQUFFLENBQUM3VCxJQUFJSixFQUFFK1QsQ0FBQztvQkFDckMsT0FBTyxJQUFJLE9BQU8vVCxNQUFNLFVBQVU7d0JBQzlCakosV0FBV3hDLE1BQUtzRSxNQUFNLENBQUNtSDt3QkFDdkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO3dCQUN2QixPQUFPNUwsS0FBS2tvQixHQUFHLENBQUMsQ0FBQzFjLElBQUlJLEVBQUU2VCxDQUFDLEVBQUVqVSxJQUFJSSxFQUFFMlQsQ0FBQztvQkFDckMsT0FBTzt3QkFDSGhkLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7d0JBQ3ZCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1SDt3QkFDdkIsT0FBT0osRUFBRStULENBQUMsR0FBRzNULEVBQUU2VCxDQUFDLEdBQUdqVSxFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTJULENBQUM7b0JBQ2hDO2dCQUNKO2dCQUVBdmYsS0FBS2diLGFBQWEsR0FBRyxTQUFTeFAsQ0FBQyxFQUFFSSxDQUFDO29CQUM5QixPQUFPSixFQUFFK1QsQ0FBQyxHQUFHM1QsRUFBRTZULENBQUMsR0FBR2pVLEVBQUVpVSxDQUFDLEdBQUc3VCxFQUFFMlQsQ0FBQztnQkFDaEM7Z0JBRUF2ZixLQUFLZ2QsYUFBYSxHQUFHLFNBQVN4UixDQUFDLEVBQUVJLENBQUMsRUFBRXk2QixDQUFDO29CQUNqQyxPQUFPQSxFQUFFeUQsS0FBSyxDQUFDLENBQUN0K0IsSUFBSUksRUFBRTZULENBQUMsRUFBRWpVLElBQUlJLEVBQUUyVCxDQUFDO2dCQUNwQztnQkFFQXZmLEtBQUsyYyxhQUFhLEdBQUcsU0FBU25SLENBQUMsRUFBRUksQ0FBQyxFQUFFeTZCLENBQUM7b0JBQ2pDLE9BQU9BLEVBQUV5RCxLQUFLLENBQUNsK0IsSUFBSUosRUFBRWlVLENBQUMsRUFBRSxDQUFDN1QsSUFBSUosRUFBRStULENBQUM7Z0JBQ3BDO2dCQUVBOztDQUVDLEdBQ0R2ZixLQUFLMHFDLFFBQVEsR0FBRyxTQUFTcHJDLENBQUMsRUFBRWtNLENBQUMsRUFBRUksQ0FBQztvQkFDNUIsSUFBSSxPQUFPQSxNQUFNLFVBQVU7d0JBQ3ZCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDt3QkFDdkJqSixXQUFXeEMsTUFBS3NFLE1BQU0sQ0FBQ3VIO3dCQUN2QixPQUFPNUwsS0FBS2tvQixHQUFHLENBQUN0YyxJQUFJSixFQUFFaVUsQ0FBQyxHQUFHbmdCLEVBQUVpZ0IsQ0FBQyxFQUFFLENBQUMzVCxJQUFJSixFQUFFK1QsQ0FBQyxHQUFHamdCLEVBQUVtZ0IsQ0FBQztvQkFDakQsT0FBTyxJQUFJLE9BQU9qVSxNQUFNLFVBQVU7d0JBQzlCakosV0FBV3hDLE1BQUtzRSxNQUFNLENBQUNtSDt3QkFDdkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO3dCQUN2QixPQUFPNUwsS0FBS2tvQixHQUFHLENBQUMsQ0FBQzFjLElBQUlJLEVBQUU2VCxDQUFDLEdBQUduZ0IsRUFBRWlnQixDQUFDLEVBQUUvVCxJQUFJSSxFQUFFMlQsQ0FBQyxHQUFHamdCLEVBQUVtZ0IsQ0FBQztvQkFDakQ7b0JBQ0FsZCxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDO2dCQUM3QjtnQkFFQXJFLEtBQUtrTCxHQUFHLEdBQUcsU0FBU00sQ0FBQyxFQUFFSSxDQUFDO29CQUNwQnJKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1SDtvQkFDdkIsT0FBTzVMLEtBQUtrb0IsR0FBRyxDQUFDMWMsRUFBRStULENBQUMsR0FBRzNULEVBQUUyVCxDQUFDLEVBQUUvVCxFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTZULENBQUM7Z0JBQ3hDO2dCQUVBOztDQUVDLEdBQ0R6ZixLQUFLaXFDLElBQUksR0FBRyxTQUFTM3FDLENBQUMsRUFBRWtNLENBQUMsRUFBRXFoQixDQUFDLEVBQUVqaEIsQ0FBQztvQkFDM0IsSUFBSSxPQUFPaWhCLE1BQU0sZUFBZSxPQUFPamhCLE1BQU0sYUFBYTt3QkFDdEQsT0FBTzVMLEtBQUs2a0IsT0FBTyxDQUFDdmxCLEdBQUdrTSxHQUFHcWhCLEdBQUdqaEI7b0JBQ2pDLE9BQU87d0JBQ0gsT0FBTzVMLEtBQUs4TSxHQUFHLENBQUN4TixHQUFHa007b0JBQ3ZCO2dCQUNKO2dCQUVBeEwsS0FBSzZrQixPQUFPLEdBQUcsU0FBU3ZsQixDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUM7b0JBQzlCLE9BQU81TCxLQUFLc0QsSUFBSSxHQUFHa1osVUFBVSxDQUFDbGQsR0FBR2tNLEdBQUdxaEIsR0FBR2poQjtnQkFDM0M7Z0JBRUE1TCxLQUFLbWEsUUFBUSxHQUFHLFNBQVM3YSxDQUFDLEVBQUVrTSxDQUFDLEVBQUVxaEIsQ0FBQyxFQUFFamhCLENBQUMsRUFBRXk2QixDQUFDO29CQUNsQyxPQUFPQSxFQUFFN3BCLFVBQVUsQ0FBQ2xkLEdBQUdrTSxHQUFHcWhCLEdBQUdqaEI7Z0JBQ2pDO2dCQUVBNUwsS0FBS2lMLEdBQUcsR0FBRyxTQUFTTyxDQUFDLEVBQUVJLENBQUM7b0JBQ3BCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixPQUFPNUwsS0FBS2tvQixHQUFHLENBQUMxYyxFQUFFK1QsQ0FBQyxHQUFHM1QsRUFBRTJULENBQUMsRUFBRS9ULEVBQUVpVSxDQUFDLEdBQUc3VCxFQUFFNlQsQ0FBQztnQkFDeEM7Z0JBRUF6ZixLQUFLMlosSUFBSSxHQUFHLFNBQVNuTyxDQUFDLEVBQUVJLENBQUMsRUFBRXk2QixDQUFDO29CQUN4QjlqQyxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QmpKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDdUg7b0JBQ3ZCLE9BQU95NkIsRUFBRXlELEtBQUssQ0FBQ3QrQixFQUFFK1QsQ0FBQyxHQUFHM1QsRUFBRTJULENBQUMsRUFBRS9ULEVBQUVpVSxDQUFDLEdBQUc3VCxFQUFFNlQsQ0FBQztnQkFDdkM7Z0JBRUF6ZixLQUFLOE0sR0FBRyxHQUFHLFNBQVN4TixDQUFDLEVBQUV1dEIsQ0FBQztvQkFDcEIsSUFBSSxPQUFPdnRCLE1BQU0sVUFBVTt3QkFDdkJpRCxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQy9FO3dCQUN2QmlELFdBQVd4QyxNQUFLc0UsTUFBTSxDQUFDd29CO3dCQUN2QixPQUFPN3NCLEtBQUtrb0IsR0FBRyxDQUFDNW9CLEVBQUVpZ0IsQ0FBQyxHQUFHc04sR0FBR3Z0QixFQUFFbWdCLENBQUMsR0FBR29OO29CQUNuQyxPQUFPLElBQUksT0FBT0EsTUFBTSxVQUFVO3dCQUM5QnRxQixXQUFXeEMsTUFBS3NFLE1BQU0sQ0FBQy9FO3dCQUN2QmlELFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDd29CO3dCQUN2QixPQUFPN3NCLEtBQUtrb0IsR0FBRyxDQUFDNW9CLElBQUl1dEIsRUFBRXROLENBQUMsRUFBRWpnQixJQUFJdXRCLEVBQUVwTixDQUFDO29CQUNwQztnQkFDSjtnQkFFQXpmLEtBQUsycUMsV0FBVyxHQUFHLFNBQVNyckMsQ0FBQyxFQUFFdXRCLENBQUMsRUFBRXdaLENBQUM7b0JBQy9CLE9BQU9BLEVBQUV5RCxLQUFLLENBQUN4cUMsRUFBRWlnQixDQUFDLEdBQUdzTixHQUFHdnRCLEVBQUVtZ0IsQ0FBQyxHQUFHb047Z0JBQ2xDO2dCQUVBN3NCLEtBQUtvYixXQUFXLEdBQUcsU0FBUzliLENBQUMsRUFBRXV0QixDQUFDLEVBQUV3WixDQUFDO29CQUMvQixPQUFPQSxFQUFFeUQsS0FBSyxDQUFDeHFDLElBQUl1dEIsRUFBRXROLENBQUMsRUFBRWpnQixJQUFJdXRCLEVBQUVwTixDQUFDO2dCQUNuQztnQkFFQXpmLEtBQUs4RyxTQUFTLENBQUNrMEIsR0FBRyxHQUFHO29CQUNqQixJQUFJLENBQUN6YixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUNBLENBQUM7b0JBQ2hCLElBQUksQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDQSxDQUFDO29CQUNoQixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUF6ZixLQUFLZzdCLEdBQUcsR0FBRyxTQUFTeHZCLENBQUM7b0JBQ2pCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkIsT0FBT3hMLEtBQUtrb0IsR0FBRyxDQUFDLENBQUMxYyxFQUFFK1QsQ0FBQyxFQUFFLENBQUMvVCxFQUFFaVUsQ0FBQztnQkFDOUI7Z0JBRUF6ZixLQUFLNHFDLElBQUksR0FBRyxTQUFTcC9CLENBQUMsRUFBRTY2QixDQUFDO29CQUNyQjlqQyxXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QixPQUFPNjZCLEVBQUV5RCxLQUFLLENBQUMsQ0FBQ3QrQixFQUFFK1QsQ0FBQyxFQUFFLENBQUMvVCxFQUFFaVUsQ0FBQztnQkFDN0I7Z0JBRUF6ZixLQUFLeWhCLEdBQUcsR0FBRyxTQUFTalcsQ0FBQztvQkFDakJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QixPQUFPeEwsS0FBS2tvQixHQUFHLENBQUNub0IsTUFBSzBoQixHQUFHLENBQUNqVyxFQUFFK1QsQ0FBQyxHQUFHeGYsTUFBSzBoQixHQUFHLENBQUNqVyxFQUFFaVUsQ0FBQztnQkFDL0M7Z0JBRUF6ZixLQUFLc29CLEdBQUcsR0FBRyxTQUFTOWMsQ0FBQyxFQUFFSSxDQUFDO29CQUNwQnJKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDbUg7b0JBQ3ZCakosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUN1SDtvQkFDdkIsT0FBTzVMLEtBQUtrb0IsR0FBRyxDQUFDLEFBQUMxYyxDQUFBQSxFQUFFK1QsQ0FBQyxHQUFHM1QsRUFBRTJULENBQUMsQUFBREEsSUFBSyxJQUFJLEFBQUMvVCxDQUFBQSxFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTZULENBQUMsQUFBREEsSUFBSztnQkFDcEQ7Z0JBRUF6ZixLQUFLODFCLEtBQUssR0FBRyxTQUFTdHFCLENBQUMsRUFBRUksQ0FBQztvQkFDdEJySixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ21IO29CQUN2QmpKLFdBQVd2QyxLQUFLcUUsTUFBTSxDQUFDdUg7b0JBQ3ZCLE9BQU81TCxLQUFLa29CLEdBQUcsQ0FBQ25vQixNQUFLc2dCLEdBQUcsQ0FBQzdVLEVBQUUrVCxDQUFDLEVBQUUzVCxFQUFFMlQsQ0FBQyxHQUFHeGYsTUFBS3NnQixHQUFHLENBQUM3VSxFQUFFaVUsQ0FBQyxFQUFFN1QsRUFBRTZULENBQUM7Z0JBQ3pEO2dCQUVBemYsS0FBSzYxQixLQUFLLEdBQUcsU0FBU3JxQixDQUFDLEVBQUVJLENBQUM7b0JBQ3RCckosV0FBV3ZDLEtBQUtxRSxNQUFNLENBQUNtSDtvQkFDdkJqSixXQUFXdkMsS0FBS3FFLE1BQU0sQ0FBQ3VIO29CQUN2QixPQUFPNUwsS0FBS2tvQixHQUFHLENBQUNub0IsTUFBS3lhLEdBQUcsQ0FBQ2hQLEVBQUUrVCxDQUFDLEVBQUUzVCxFQUFFMlQsQ0FBQyxHQUFHeGYsTUFBS3lhLEdBQUcsQ0FBQ2hQLEVBQUVpVSxDQUFDLEVBQUU3VCxFQUFFNlQsQ0FBQztnQkFDekQ7Z0JBRUF6ZixLQUFLOEcsU0FBUyxDQUFDZ1UsS0FBSyxHQUFHLFNBQVN1RixHQUFHO29CQUMvQixJQUFJd3FCLFlBQVksSUFBSSxDQUFDdHJCLENBQUMsR0FBRyxJQUFJLENBQUNBLENBQUMsR0FBRyxJQUFJLENBQUNFLENBQUMsR0FBRyxJQUFJLENBQUNBLENBQUM7b0JBQ2pELElBQUlvckIsWUFBWXhxQixNQUFNQSxLQUFLO3dCQUN2QixJQUFJaXFCLFlBQVl2cUMsTUFBS2dvQyxPQUFPLENBQUM4Qzt3QkFDN0IsSUFBSSxDQUFDdHJCLENBQUMsSUFBSStxQixZQUFZanFCO3dCQUN0QixJQUFJLENBQUNaLENBQUMsSUFBSTZxQixZQUFZanFCO29CQUMxQjtvQkFDQSxPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUFyZ0IsS0FBSzhhLEtBQUssR0FBRyxTQUFTdFAsQ0FBQyxFQUFFNlUsR0FBRztvQkFDeEI3VSxJQUFJeEwsS0FBS2tvQixHQUFHLENBQUMxYyxFQUFFK1QsQ0FBQyxFQUFFL1QsRUFBRWlVLENBQUM7b0JBQ3JCalUsRUFBRXNQLEtBQUssQ0FBQ3VGO29CQUNSLE9BQU83VTtnQkFDWDtnQkFFQTs7Q0FFQyxHQUNEeEwsS0FBSzhxQyxPQUFPLEdBQUcsU0FBU3ZyQixDQUFDLEVBQUVFLENBQUM7b0JBQ3hCLE9BQU8sU0FBU2pVLENBQUM7d0JBQ2IsT0FBT3hMLEtBQUtrb0IsR0FBRyxDQUFDMWMsRUFBRStULENBQUMsR0FBR0EsR0FBRy9ULEVBQUVpVSxDQUFDLEdBQUdBO29CQUNuQztnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEemYsS0FBSytxQyxXQUFXLEdBQUcsU0FBU3hyQixDQUFDLEVBQUVFLENBQUM7b0JBQzVCLE9BQU8sU0FBU2pVLENBQUM7d0JBQ2IsT0FBT3hMLEtBQUtrb0IsR0FBRyxDQUFDMWMsRUFBRStULENBQUMsR0FBR0EsR0FBRy9ULEVBQUVpVSxDQUFDLEdBQUdBO29CQUNuQztnQkFDSjtZQUdBO1lBQUU7Z0JBQUMsa0JBQWlCO2dCQUFHLFVBQVM7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNsZ0IsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3hFLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHMEI7Z0JBRWpCLElBQUl3QyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsU0FBU1UsS0FBS3NmLENBQUMsRUFBRUUsQ0FBQyxFQUFFc25CLENBQUM7b0JBQ2pCLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWTltQyxJQUFHLEdBQUk7d0JBQ3pCLE9BQU8sSUFBSUEsS0FBS3NmLEdBQUdFLEdBQUdzbkI7b0JBQzFCO29CQUNBLElBQUksT0FBT3huQixNQUFNLGFBQWE7d0JBQzFCLElBQUksQ0FBQ0EsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUNzbkIsQ0FBQyxHQUFHO29CQUNyQyxPQUFPLElBQUksT0FBT3huQixNQUFNLFVBQVU7d0JBQzlCLElBQUksQ0FBQ0EsQ0FBQyxHQUFHQSxFQUFFQSxDQUFDLEVBQUUsSUFBSSxDQUFDRSxDQUFDLEdBQUdGLEVBQUVFLENBQUMsRUFBRSxJQUFJLENBQUNzbkIsQ0FBQyxHQUFHeG5CLEVBQUV3bkIsQ0FBQztvQkFDNUMsT0FBTzt3QkFDSCxJQUFJLENBQUN4bkIsQ0FBQyxHQUFHQSxHQUFHLElBQUksQ0FBQ0UsQ0FBQyxHQUFHQSxHQUFHLElBQUksQ0FBQ3NuQixDQUFDLEdBQUdBO29CQUNyQztvQkFDQXhrQyxXQUFXdEMsS0FBS29FLE1BQU0sQ0FBQyxJQUFJO2dCQUMvQjtnQkFFQXBFLEtBQUtpb0IsR0FBRyxHQUFHLFNBQVMzSSxDQUFDLEVBQUVFLENBQUMsRUFBRXNuQixDQUFDO29CQUN2QixJQUFJc0IsTUFBTTNnQixPQUFPekYsTUFBTSxDQUFDaGlCLEtBQUs2RyxTQUFTO29CQUN0Q3VoQyxJQUFJOW9CLENBQUMsR0FBR0E7b0JBQ1I4b0IsSUFBSTVvQixDQUFDLEdBQUdBO29CQUNSNG9CLElBQUl0QixDQUFDLEdBQUdBO29CQUNSLE9BQU9zQjtnQkFDWDtnQkFFQXBvQyxLQUFLd0YsS0FBSyxHQUFHLFNBQVMrRixDQUFDO29CQUNuQmpKLFdBQVd0QyxLQUFLb0UsTUFBTSxDQUFDbUg7b0JBQ3ZCLE9BQU92TCxLQUFLaW9CLEdBQUcsQ0FBQzFjLEVBQUUrVCxDQUFDLEVBQUUvVCxFQUFFaVUsQ0FBQyxFQUFFalUsRUFBRXU3QixDQUFDO2dCQUNqQztnQkFFQTltQyxLQUFLNkcsU0FBUyxDQUFDc3hCLFFBQVEsR0FBRztvQkFDdEIsT0FBT0MsS0FBS0MsU0FBUyxDQUFDLElBQUk7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0RyNEIsS0FBS3FFLE9BQU8sR0FBRyxTQUFTa0gsQ0FBQztvQkFDckIsT0FBT0EsS0FBS3pMLE1BQUt3RSxRQUFRLENBQUNpSCxFQUFFK1QsQ0FBQyxLQUFLeGYsTUFBS3dFLFFBQVEsQ0FBQ2lILEVBQUVpVSxDQUFDLEtBQUsxZixNQUFLd0UsUUFBUSxDQUFDaUgsRUFBRXU3QixDQUFDO2dCQUM3RTtnQkFFQTltQyxLQUFLb0UsTUFBTSxHQUFHLFNBQVNqRixDQUFDO29CQUNwQixJQUFJLENBQUNtRCxTQUFTO29CQUNkLElBQUksQ0FBQ3RDLEtBQUtxRSxPQUFPLENBQUNsRixJQUFJO3dCQUNsQmlELFVBQVVJLFFBQU84ckIsS0FBSyxDQUFDbnZCO3dCQUN2QixNQUFNLElBQUlLLE1BQU07b0JBQ3BCO2dCQUNKO2dCQUVBUSxLQUFLNkcsU0FBUyxDQUFDb0IsT0FBTyxHQUFHO29CQUNyQixJQUFJLENBQUNxWCxDQUFDLEdBQUc7b0JBQ1QsSUFBSSxDQUFDRSxDQUFDLEdBQUc7b0JBQ1QsSUFBSSxDQUFDc25CLENBQUMsR0FBRztvQkFDVCxPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUE5bUMsS0FBSzZHLFNBQVMsQ0FBQ2lELEdBQUcsR0FBRyxTQUFTd1YsQ0FBQyxFQUFFRSxDQUFDLEVBQUVzbkIsQ0FBQztvQkFDakMsSUFBSSxDQUFDeG5CLENBQUMsR0FBR0E7b0JBQ1QsSUFBSSxDQUFDRSxDQUFDLEdBQUdBO29CQUNULElBQUksQ0FBQ3NuQixDQUFDLEdBQUdBO29CQUNULE9BQU8sSUFBSTtnQkFDZjtnQkFFQTltQyxLQUFLNkcsU0FBUyxDQUFDb0UsR0FBRyxHQUFHLFNBQVNVLENBQUM7b0JBQzNCLElBQUksQ0FBQzJULENBQUMsSUFBSTNULEVBQUUyVCxDQUFDO29CQUNiLElBQUksQ0FBQ0UsQ0FBQyxJQUFJN1QsRUFBRTZULENBQUM7b0JBQ2IsSUFBSSxDQUFDc25CLENBQUMsSUFBSW43QixFQUFFbTdCLENBQUM7b0JBQ2IsT0FBTyxJQUFJO2dCQUNmO2dCQUVBOW1DLEtBQUs2RyxTQUFTLENBQUNtRSxHQUFHLEdBQUcsU0FBU1csQ0FBQztvQkFDM0IsSUFBSSxDQUFDMlQsQ0FBQyxJQUFJM1QsRUFBRTJULENBQUM7b0JBQ2IsSUFBSSxDQUFDRSxDQUFDLElBQUk3VCxFQUFFNlQsQ0FBQztvQkFDYixJQUFJLENBQUNzbkIsQ0FBQyxJQUFJbjdCLEVBQUVtN0IsQ0FBQztvQkFDYixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUE5bUMsS0FBSzZHLFNBQVMsQ0FBQ2dHLEdBQUcsR0FBRyxTQUFTODdCLENBQUM7b0JBQzNCLElBQUksQ0FBQ3JwQixDQUFDLElBQUlxcEI7b0JBQ1YsSUFBSSxDQUFDbnBCLENBQUMsSUFBSW1wQjtvQkFDVixJQUFJLENBQUM3QixDQUFDLElBQUk2QjtvQkFDVixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUEzb0MsS0FBS3MzQixRQUFRLEdBQUcsU0FBUy9yQixDQUFDLEVBQUVJLENBQUM7b0JBQ3pCckosV0FBV3RDLEtBQUtvRSxNQUFNLENBQUNtSDtvQkFDdkJqSixXQUFXdEMsS0FBS29FLE1BQU0sQ0FBQ3VIO29CQUN2QixPQUFPSixLQUFLSSxLQUFLLE9BQU9KLE1BQU0sWUFBWUEsTUFBTSxRQUFRLE9BQU9JLE1BQU0sWUFBWUEsTUFBTSxRQUFRSixFQUFFK1QsQ0FBQyxLQUFLM1QsRUFBRTJULENBQUMsSUFBSS9ULEVBQUVpVSxDQUFDLEtBQUs3VCxFQUFFNlQsQ0FBQyxJQUFJalUsRUFBRXU3QixDQUFDLEtBQUtuN0IsRUFBRW03QixDQUFDO2dCQUM1STtnQkFFQTs7Q0FFQyxHQUNEOW1DLEtBQUt3TCxHQUFHLEdBQUcsU0FBU0QsQ0FBQyxFQUFFSSxDQUFDO29CQUNwQixPQUFPSixFQUFFK1QsQ0FBQyxHQUFHM1QsRUFBRTJULENBQUMsR0FBRy9ULEVBQUVpVSxDQUFDLEdBQUc3VCxFQUFFNlQsQ0FBQyxHQUFHalUsRUFBRXU3QixDQUFDLEdBQUduN0IsRUFBRW03QixDQUFDO2dCQUM1QztnQkFFQTs7Q0FFQyxHQUNEOW1DLEtBQUtrTCxLQUFLLEdBQUcsU0FBU0ssQ0FBQyxFQUFFSSxDQUFDO29CQUN0QixPQUFPLElBQUkzTCxLQUFLdUwsRUFBRWlVLENBQUMsR0FBRzdULEVBQUVtN0IsQ0FBQyxHQUFHdjdCLEVBQUV1N0IsQ0FBQyxHQUFHbjdCLEVBQUU2VCxDQUFDLEVBQUVqVSxFQUFFdTdCLENBQUMsR0FBR243QixFQUFFMlQsQ0FBQyxHQUFHL1QsRUFBRStULENBQUMsR0FBRzNULEVBQUVtN0IsQ0FBQyxFQUFFdjdCLEVBQUUrVCxDQUFDLEdBQUczVCxFQUFFNlQsQ0FBQyxHQUFHalUsRUFBRWlVLENBQUMsR0FBRzdULEVBQUUyVCxDQUFDO2dCQUN2RjtnQkFFQXRmLEtBQUtpTCxHQUFHLEdBQUcsU0FBU00sQ0FBQyxFQUFFSSxDQUFDO29CQUNwQixPQUFPLElBQUkzTCxLQUFLdUwsRUFBRStULENBQUMsR0FBRzNULEVBQUUyVCxDQUFDLEVBQUUvVCxFQUFFaVUsQ0FBQyxHQUFHN1QsRUFBRTZULENBQUMsRUFBRWpVLEVBQUV1N0IsQ0FBQyxHQUFHbjdCLEVBQUVtN0IsQ0FBQztnQkFDbkQ7Z0JBRUE5bUMsS0FBS2dMLEdBQUcsR0FBRyxTQUFTTyxDQUFDLEVBQUVJLENBQUM7b0JBQ3BCLE9BQU8sSUFBSTNMLEtBQUt1TCxFQUFFK1QsQ0FBQyxHQUFHM1QsRUFBRTJULENBQUMsRUFBRS9ULEVBQUVpVSxDQUFDLEdBQUc3VCxFQUFFNlQsQ0FBQyxFQUFFalUsRUFBRXU3QixDQUFDLEdBQUduN0IsRUFBRW03QixDQUFDO2dCQUNuRDtnQkFFQTltQyxLQUFLNk0sR0FBRyxHQUFHLFNBQVN0QixDQUFDLEVBQUVvOUIsQ0FBQztvQkFDcEIsT0FBTyxJQUFJM29DLEtBQUsyb0MsSUFBSXA5QixFQUFFK1QsQ0FBQyxFQUFFcXBCLElBQUlwOUIsRUFBRWlVLENBQUMsRUFBRW1wQixJQUFJcDlCLEVBQUV1N0IsQ0FBQztnQkFDN0M7Z0JBRUE5bUMsS0FBSzZHLFNBQVMsQ0FBQ2swQixHQUFHLEdBQUc7b0JBQ2pCLElBQUksQ0FBQ3piLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQ0EsQ0FBQztvQkFDaEIsSUFBSSxDQUFDRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUNBLENBQUM7b0JBQ2hCLElBQUksQ0FBQ3NuQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUNBLENBQUM7b0JBQ2hCLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTltQyxLQUFLKzZCLEdBQUcsR0FBRyxTQUFTeHZCLENBQUM7b0JBQ2pCLE9BQU8sSUFBSXZMLEtBQUssQ0FBQ3VMLEVBQUUrVCxDQUFDLEVBQUUsQ0FBQy9ULEVBQUVpVSxDQUFDLEVBQUUsQ0FBQ2pVLEVBQUV1N0IsQ0FBQztnQkFDcEM7WUFHQTtZQUFFO2dCQUFDLGtCQUFpQjtnQkFBRyxVQUFTO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTeG5DLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN4RSxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR29FO2dCQUVqQixJQUFJM0MsT0FBT1QsU0FBUTtnQkFFbkI7OztDQUdDLEdBQ0QsU0FBU29EO29CQUNMLElBQUksQ0FBQzZJLENBQUMsR0FBR3hMLEtBQUtzRCxJQUFJO29CQUNsQixJQUFJLENBQUNzSSxDQUFDLEdBQUc7Z0JBQ2I7WUFHQTtZQUFFO2dCQUFDLFVBQVM7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNyTSxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDcEQsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERqRSxTQUFRNjVCLFFBQVEsR0FBRyxTQUFTNFMsT0FBTztvQkFDL0JBLFVBQVUsT0FBT0EsWUFBWSxXQUFXQSxVQUFVO29CQUNsRCxJQUFJQyxTQUFTO29CQUNiLElBQUssSUFBSTVWLFFBQVEsSUFBSSxDQUFFO3dCQUNuQixJQUFJLE9BQU8sSUFBSSxDQUFDQSxLQUFLLEtBQUssY0FBYyxPQUFPLElBQUksQ0FBQ0EsS0FBSyxLQUFLLFVBQVU7NEJBQ3BFNFYsVUFBVTVWLE9BQU8sT0FBTyxJQUFJLENBQUNBLEtBQUssR0FBRzJWO3dCQUN6QztvQkFDSjtvQkFDQSxPQUFPQztnQkFDWDtZQUdBO1lBQUUsQ0FBQztTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVMxckMsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3pDLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHNEM7Z0JBRWpCLElBQUl1QixVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSVUsT0FBT1YsU0FBUTtnQkFFbkIsSUFBSVcsUUFBUVgsU0FBUTtnQkFFcEIsSUFBSVksUUFBUVosU0FBUTtnQkFFcEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSXVDLFFBQVF2QyxTQUFRO2dCQUVwQixJQUFJYSxZQUFZYixTQUFRO2dCQUV4QixJQUFJb0QsV0FBV3BELFNBQVE7Z0JBRXZCLElBQUlxRCxXQUFXckQsU0FBUTtnQkFFdkIsSUFBSW9CLFFBQVFwQixTQUFRO2dCQUVwQjRCLGNBQWMrcEMsSUFBSSxHQUFHO2dCQUVyQi9wQyxjQUFjZ3FDLE1BQU0sR0FBR3hxQztnQkFFdkJRLGNBQWMyRixTQUFTLEdBQUdtYixPQUFPOWdCLGNBQWNncUMsTUFBTSxDQUFDcmtDLFNBQVM7Z0JBRS9EOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNELElBQUk2ZSxXQUFXO29CQUNYeWxCLGFBQWE7b0JBQ2JDLGNBQWM7Z0JBQ2xCO2dCQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNscUMsY0FBY2lELEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFODNCLE9BQU8sRUFBRUMsT0FBTztvQkFDdEQsSUFBSSxDQUFFLENBQUEsSUFBSSxZQUFZcHFDLGFBQVksR0FBSTt3QkFDbEMsT0FBTyxJQUFJQSxjQUFjaUQsS0FBS2tQLE9BQU9FLE9BQU84M0IsU0FBU0M7b0JBQ3pEO29CQUNBLG9EQUFvRDtvQkFDcEQsSUFBSS8zQixTQUFTODNCLFdBQVcsWUFBWUEsV0FBVyxPQUFPOTNCLFNBQVMsT0FBT0EsT0FBTzt3QkFDekUsSUFBSTJrQixPQUFPM2tCO3dCQUNYQSxRQUFRODNCO3dCQUNSQSxVQUFVblQ7b0JBQ2Q7b0JBQ0EvekIsTUFBTTFCLFFBQVEwQixLQUFLdWhCO29CQUNuQmhsQixNQUFNZixJQUFJLENBQUMsSUFBSSxFQUFFd0UsS0FBS2tQLE9BQU9FO29CQUM3QkYsUUFBUSxJQUFJLENBQUN1UyxPQUFPO29CQUNwQnJTLFFBQVEsSUFBSSxDQUFDc1MsT0FBTztvQkFDcEIsSUFBSSxDQUFDN2dCLE1BQU0sR0FBRzlELGNBQWMrcEMsSUFBSTtvQkFDaEMsZ0JBQWdCO29CQUNoQixJQUFJLENBQUNNLGNBQWMsR0FBR0YsVUFBVWg0QixNQUFNbEUsYUFBYSxDQUFDazhCLFdBQVdsbkMsSUFBSXFuQyxZQUFZLElBQUl6ckMsS0FBS3NELElBQUk7b0JBQzVGLElBQUksQ0FBQ29vQyxjQUFjLEdBQUdILFVBQVUvM0IsTUFBTXBFLGFBQWEsQ0FBQ204QixXQUFXbm5DLElBQUl1bkMsWUFBWSxJQUFJM3JDLEtBQUtzRCxJQUFJO29CQUM1RixJQUFJLENBQUNzb0MsUUFBUSxHQUFHN3JDLE1BQUt3RSxRQUFRLENBQUNILElBQUl2RSxNQUFNLElBQUl1RSxJQUFJdkUsTUFBTSxHQUFHRyxLQUFLd3dCLFFBQVEsQ0FBQ2xkLE1BQU1oSSxhQUFhLENBQUMsSUFBSSxDQUFDa2dDLGNBQWMsR0FBR2g0QixNQUFNbEksYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO29CQUN4SixJQUFJLENBQUNHLGFBQWEsR0FBR3puQyxJQUFJZ25DLFdBQVc7b0JBQ3BDLElBQUksQ0FBQ1UsY0FBYyxHQUFHMW5DLElBQUlpbkMsWUFBWTtvQkFDdEMsSUFBSSxDQUFDVSxTQUFTLEdBQUc7b0JBQ2pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO29CQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHO29CQUNkLGNBQWM7b0JBQ2QsSUFBSSxDQUFDQyxHQUFHO29CQUNSLE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxjQUFjO29CQUNuQixPQUFPO29CQUNQLElBQUksQ0FBQ0MsY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLFVBQVU7b0JBQ2YsSUFBSSxDQUFDQyxVQUFVO29CQUNmLElBQUksQ0FBQ0MsT0FBTztvQkFDWixJQUFJLENBQUNDLE9BQU87b0JBQ1osSUFBSSxDQUFDeG5DLE1BQU07Z0JBQ2Y7Z0JBRUE7O0NBRUMsR0FDRC9ELGNBQWMyRixTQUFTLENBQUM2bEMsZUFBZSxHQUFHO29CQUN0QyxPQUFPLElBQUksQ0FBQ25CLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0RycUMsY0FBYzJGLFNBQVMsQ0FBQzhsQyxlQUFlLEdBQUc7b0JBQ3RDLE9BQU8sSUFBSSxDQUFDbEIsY0FBYztnQkFDOUI7Z0JBRUE7OztDQUdDLEdBQ0R2cUMsY0FBYzJGLFNBQVMsQ0FBQytsQyxTQUFTLEdBQUcsU0FBU2h0QyxNQUFNO29CQUMvQyxJQUFJLENBQUMrckMsUUFBUSxHQUFHL3JDO2dCQUNwQjtnQkFFQXNCLGNBQWMyRixTQUFTLENBQUNnbUMsU0FBUyxHQUFHO29CQUNoQyxPQUFPLElBQUksQ0FBQ2xCLFFBQVE7Z0JBQ3hCO2dCQUVBenFDLGNBQWMyRixTQUFTLENBQUNpbUMsWUFBWSxHQUFHLFNBQVNDLEVBQUU7b0JBQzlDLElBQUksQ0FBQ25CLGFBQWEsR0FBR21CO2dCQUN6QjtnQkFFQTdyQyxjQUFjMkYsU0FBUyxDQUFDbW1DLFlBQVksR0FBRztvQkFDbkMsT0FBTyxJQUFJLENBQUNwQixhQUFhO2dCQUM3QjtnQkFFQTFxQyxjQUFjMkYsU0FBUyxDQUFDb21DLGVBQWUsR0FBRyxTQUFTdmYsS0FBSztvQkFDcEQsSUFBSSxDQUFDbWUsY0FBYyxHQUFHbmU7Z0JBQzFCO2dCQUVBeHNCLGNBQWMyRixTQUFTLENBQUNxbUMsZUFBZSxHQUFHO29CQUN0QyxPQUFPLElBQUksQ0FBQ3JCLGNBQWM7Z0JBQzlCO2dCQUVBM3FDLGNBQWMyRixTQUFTLENBQUN1ZixVQUFVLEdBQUc7b0JBQ2pDLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN2YSxhQUFhLENBQUMsSUFBSSxDQUFDa2dDLGNBQWM7Z0JBQ3pEO2dCQUVBcnFDLGNBQWMyRixTQUFTLENBQUN3ZixVQUFVLEdBQUc7b0JBQ2pDLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN4YSxhQUFhLENBQUMsSUFBSSxDQUFDb2dDLGNBQWM7Z0JBQ3pEO2dCQUVBdnFDLGNBQWMyRixTQUFTLENBQUN5ZixnQkFBZ0IsR0FBRyxTQUFTQyxNQUFNO29CQUN0RCxPQUFPeG1CLEtBQUs4TSxHQUFHLENBQUMsSUFBSSxDQUFDaS9CLFNBQVMsRUFBRSxJQUFJLENBQUNHLEdBQUcsRUFBRXAvQixHQUFHLENBQUMwWjtnQkFDbEQ7Z0JBRUFybEIsY0FBYzJGLFNBQVMsQ0FBQzJmLGlCQUFpQixHQUFHLFNBQVNELE1BQU07b0JBQ3ZELE9BQU87Z0JBQ1g7Z0JBRUFybEIsY0FBYzJGLFNBQVMsQ0FBQzhmLHVCQUF1QixHQUFHLFNBQVMxVCxJQUFJO29CQUMzRCxJQUFJLENBQUNtNUIsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNqZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDeWhDLGNBQWMsR0FBRyxJQUFJLENBQUN4bUIsT0FBTyxDQUFDbGdCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3RELElBQUksQ0FBQzBoQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzFnQixTQUFTO29CQUN4QyxJQUFJLENBQUNxbkMsVUFBVSxHQUFHLElBQUksQ0FBQzFtQixPQUFPLENBQUMzZ0IsU0FBUztvQkFDeEMsSUFBSSxDQUFDc25DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDeGdCLE1BQU07b0JBQ2xDLElBQUksQ0FBQ3FuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUNsQyxJQUFJZ1UsS0FBSyxJQUFJLENBQUN3TSxPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJaVAsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOGMsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMk4sS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJbVAsS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJZ2QsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUl3aEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPO29CQUNqQixJQUFJK3pCLEtBQUtodEMsSUFBSTZuQixHQUFHLENBQUMxTztvQkFDakIsSUFBSSxDQUFDMnlCLElBQUksR0FBRzlyQyxJQUFJNE8sT0FBTyxDQUFDbStCLElBQUlwdEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN1Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ2EsY0FBYztvQkFDN0UsSUFBSSxDQUFDRCxJQUFJLEdBQUcvckMsSUFBSTRPLE9BQU8sQ0FBQ28rQixJQUFJcnRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDeWdDLGNBQWMsRUFBRSxJQUFJLENBQUNZLGNBQWM7b0JBQzdFLElBQUksQ0FBQ0osR0FBRyxHQUFHbHNDLEtBQUtpTCxHQUFHLENBQUNqTCxLQUFLa0wsR0FBRyxDQUFDcU8sSUFBSSxJQUFJLENBQUM2eUIsSUFBSSxHQUFHcHNDLEtBQUtrTCxHQUFHLENBQUNtTyxJQUFJLElBQUksQ0FBQzh5QixJQUFJO29CQUNuRSxzQkFBc0I7b0JBQ3RCLElBQUl0c0MsU0FBUyxJQUFJLENBQUNxc0MsR0FBRyxDQUFDcnNDLE1BQU07b0JBQzVCLElBQUlBLFNBQVN1QyxTQUFTdVksVUFBVSxFQUFFO3dCQUM5QixJQUFJLENBQUN1eEIsR0FBRyxDQUFDcC9CLEdBQUcsQ0FBQyxJQUFJak47b0JBQ3JCLE9BQU87d0JBQ0gsSUFBSSxDQUFDcXNDLEdBQUcsQ0FBQ25pQyxHQUFHLENBQUMsR0FBRztvQkFDcEI7b0JBQ0EsSUFBSXVqQyxPQUFPdHRDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRSxJQUFJLENBQUNELEdBQUc7b0JBQ3pDLElBQUlxQixPQUFPdnRDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRSxJQUFJLENBQUNGLEdBQUc7b0JBQ3pDLElBQUlzQixVQUFVLElBQUksQ0FBQ2pCLFVBQVUsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBR2EsT0FBT0EsT0FBTyxJQUFJLENBQUNkLFVBQVUsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBR2EsT0FBT0E7b0JBQ3JHLHFDQUFxQztvQkFDckMsSUFBSSxDQUFDcm9DLE1BQU0sR0FBR3NvQyxXQUFXLElBQUksSUFBSUEsVUFBVTtvQkFDM0MsSUFBSSxJQUFJLENBQUMzQixhQUFhLEdBQUcsR0FBRzt3QkFDeEIsSUFBSWh4QixJQUFJaGIsU0FBUyxJQUFJLENBQUMrckMsUUFBUTt3QkFDOUIsWUFBWTt3QkFDWixJQUFJNkIsUUFBUSxJQUFJMXRDLE1BQUs4cEIsRUFBRSxHQUFHLElBQUksQ0FBQ2dpQixhQUFhO3dCQUM1QyxzQkFBc0I7d0JBQ3RCLElBQUk1VixJQUFJLElBQUksSUFBSSxDQUFDL3dCLE1BQU0sR0FBRyxJQUFJLENBQUM0bUMsY0FBYyxHQUFHMkI7d0JBQ2hELG1CQUFtQjt3QkFDbkIsSUFBSUMsSUFBSSxJQUFJLENBQUN4b0MsTUFBTSxHQUFHdW9DLFFBQVFBO3dCQUM5QixpQkFBaUI7d0JBQ2pCLElBQUlqZ0IsSUFBSXRhLEtBQUs0WSxFQUFFO3dCQUNmLElBQUksQ0FBQ2tnQixPQUFPLEdBQUd4ZSxJQUFLeUksQ0FBQUEsSUFBSXpJLElBQUlrZ0IsQ0FBQUE7d0JBQzVCLElBQUksQ0FBQzFCLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDQSxPQUFPLEdBQUc7d0JBQ3RELElBQUksQ0FBQ0MsTUFBTSxHQUFHcHhCLElBQUkyUyxJQUFJa2dCLElBQUksSUFBSSxDQUFDMUIsT0FBTzt3QkFDdEN3QixXQUFXLElBQUksQ0FBQ3hCLE9BQU87d0JBQ3ZCLElBQUksQ0FBQzltQyxNQUFNLEdBQUdzb0MsV0FBVyxJQUFJLElBQUlBLFVBQVU7b0JBQy9DLE9BQU87d0JBQ0gsSUFBSSxDQUFDeEIsT0FBTyxHQUFHO3dCQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHO29CQUNsQjtvQkFDQSxJQUFJLzRCLEtBQUtnQixZQUFZLEVBQUU7d0JBQ25CLHFEQUFxRDt3QkFDckQsSUFBSSxDQUFDNjNCLFNBQVMsSUFBSTc0QixLQUFLa0IsT0FBTzt3QkFDOUIsSUFBSStHLElBQUluYixLQUFLOE0sR0FBRyxDQUFDLElBQUksQ0FBQ2kvQixTQUFTLEVBQUUsSUFBSSxDQUFDRyxHQUFHO3dCQUN6Qzl2QixHQUFHZixNQUFNLENBQUMsSUFBSSxDQUFDa3hCLFVBQVUsRUFBRXB4Qjt3QkFDM0JrQixNQUFNLElBQUksQ0FBQ293QixPQUFPLEdBQUd6c0MsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNnaEMsSUFBSSxFQUFFaHhCO3dCQUMzQ21CLEdBQUd6UCxNQUFNLENBQUMsSUFBSSxDQUFDMi9CLFVBQVUsRUFBRXJ4Qjt3QkFDM0JvQixNQUFNLElBQUksQ0FBQ213QixPQUFPLEdBQUcxc0MsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFanhCO29CQUMvQyxPQUFPO3dCQUNILElBQUksQ0FBQzR3QixTQUFTLEdBQUc7b0JBQ3JCO29CQUNBLElBQUksQ0FBQ2xtQixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLENBQUN6QixHQUFHLENBQUNxUztvQkFDOUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLENBQUN6QixHQUFHLENBQUN1UztvQkFDOUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO2dCQUNoQztnQkFFQXBiLGNBQWMyRixTQUFTLENBQUMrZix3QkFBd0IsR0FBRyxTQUFTM1QsSUFBSTtvQkFDNUQsSUFBSWtKLEtBQUssSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSTZRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSTBRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUkrUSxLQUFLLElBQUksQ0FBQ3VKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxpQ0FBaUM7b0JBQ2pDLElBQUkraEMsTUFBTTN0QyxLQUFLa0wsR0FBRyxDQUFDa1IsSUFBSXBjLEtBQUttTCxLQUFLLENBQUNrUixJQUFJLElBQUksQ0FBQzh2QixJQUFJO29CQUMvQyxJQUFJeUIsTUFBTTV0QyxLQUFLa0wsR0FBRyxDQUFDb1IsSUFBSXRjLEtBQUttTCxLQUFLLENBQUNvUixJQUFJLElBQUksQ0FBQzZ2QixJQUFJO29CQUMvQyxJQUFJeUIsT0FBTzd0QyxLQUFLeUwsR0FBRyxDQUFDLElBQUksQ0FBQ3lnQyxHQUFHLEVBQUUwQixPQUFPNXRDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDeWdDLEdBQUcsRUFBRXlCO29CQUN4RCxJQUFJamdDLFVBQVUsQ0FBQyxJQUFJLENBQUN4SSxNQUFNLEdBQUkyb0MsQ0FBQUEsT0FBTyxJQUFJLENBQUM1QixNQUFNLEdBQUcsSUFBSSxDQUFDRCxPQUFPLEdBQUcsSUFBSSxDQUFDRCxTQUFTLEFBQUQ7b0JBQy9FLElBQUksQ0FBQ0EsU0FBUyxJQUFJcitCO29CQUNsQixJQUFJeU4sSUFBSW5iLEtBQUs4TSxHQUFHLENBQUNZLFNBQVMsSUFBSSxDQUFDdytCLEdBQUc7b0JBQ2xDOXZCLEdBQUdmLE1BQU0sQ0FBQyxJQUFJLENBQUNreEIsVUFBVSxFQUFFcHhCO29CQUMzQmtCLE1BQU0sSUFBSSxDQUFDb3dCLE9BQU8sR0FBR3pzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2doQyxJQUFJLEVBQUVoeEI7b0JBQzNDbUIsR0FBR3pQLE1BQU0sQ0FBQyxJQUFJLENBQUMyL0IsVUFBVSxFQUFFcnhCO29CQUMzQm9CLE1BQU0sSUFBSSxDQUFDbXdCLE9BQU8sR0FBRzFzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUVqeEI7b0JBQzNDLElBQUksQ0FBQzBLLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3FTO29CQUM5QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3VTO29CQUM5QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBcGIsY0FBYzJGLFNBQVMsQ0FBQ2dnQix3QkFBd0IsR0FBRyxTQUFTNVQsSUFBSTtvQkFDNUQsSUFBSSxJQUFJLENBQUMyNEIsYUFBYSxHQUFHLEdBQUc7d0JBQ3hCLGlFQUFpRTt3QkFDakUsT0FBTztvQkFDWDtvQkFDQSxJQUFJeHlCLEtBQUssSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsSUFBSWlQLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSWlhLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDL2YsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsSUFBSW1QLEtBQUssSUFBSSxDQUFDc00sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSTh0QyxLQUFLL3NDLElBQUk2bkIsR0FBRyxDQUFDNU87b0JBQ2pCLElBQUkrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixJQUFJbEYsS0FBS2pVLElBQUkwb0MsTUFBTSxDQUFDcUUsSUFBSSxJQUFJLENBQUM1QixjQUFjLEVBQUUsSUFBSSxDQUFDYSxjQUFjO29CQUNoRSxJQUFJOTNCLEtBQUtsVSxJQUFJMG9DLE1BQU0sQ0FBQ3NFLElBQUksSUFBSSxDQUFDM0IsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDaEUsSUFBSWp0QyxJQUFJVyxLQUFLaUwsR0FBRyxDQUFDakwsS0FBS2tMLEdBQUcsQ0FBQ3FPLElBQUloRixLQUFLdlUsS0FBS2tMLEdBQUcsQ0FBQ21PLElBQUkvRTtvQkFDaEQsSUFBSXpVLFNBQVNSLEVBQUU2YSxTQUFTO29CQUN4QixJQUFJVyxJQUFJaGIsU0FBUyxJQUFJLENBQUMrckMsUUFBUTtvQkFDOUIvd0IsSUFBSTlhLE1BQUsrYSxLQUFLLENBQUNELEdBQUcsQ0FBQ3pZLFNBQVN3WSxtQkFBbUIsRUFBRXhZLFNBQVN3WSxtQkFBbUI7b0JBQzdFLElBQUlsTixVQUFVLENBQUMsSUFBSSxDQUFDeEksTUFBTSxHQUFHMlY7b0JBQzdCLElBQUlNLElBQUluYixLQUFLOE0sR0FBRyxDQUFDWSxTQUFTck87b0JBQzFCZ2EsR0FBR2dDLE1BQU0sQ0FBQyxJQUFJLENBQUNreEIsVUFBVSxFQUFFcHhCO29CQUMzQjdCLE1BQU0sSUFBSSxDQUFDbXpCLE9BQU8sR0FBR3pzQyxLQUFLbUwsS0FBSyxDQUFDbUosSUFBSTZHO29CQUNwQzVCLEdBQUcxTSxNQUFNLENBQUMsSUFBSSxDQUFDMi9CLFVBQVUsRUFBRXJ4QjtvQkFDM0IzQixNQUFNLElBQUksQ0FBQ2t6QixPQUFPLEdBQUcxc0MsS0FBS21MLEtBQUssQ0FBQ29KLElBQUk0RztvQkFDcEMsSUFBSSxDQUFDMEssT0FBTyxDQUFDOWYsVUFBVSxDQUFDc0UsQ0FBQyxDQUFDTixHQUFHLENBQUNzUDtvQkFDOUIsSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQyxHQUFHZ2E7b0JBQzVCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUMsQ0FBQ04sR0FBRyxDQUFDd1A7b0JBQzlCLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR2thO29CQUM1QixPQUFPelosTUFBSzBoQixHQUFHLENBQUM1RyxLQUFLelksU0FBU3VZLFVBQVU7Z0JBQzVDO1lBR0E7WUFBRTtnQkFBQyxZQUFXO2dCQUFFLGVBQWM7Z0JBQUUsbUJBQWtCO2dCQUFHLG1CQUFrQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxtQkFBa0I7Z0JBQUcsdUJBQXNCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGtCQUFpQjtnQkFBRyxtQkFBa0I7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNwYixRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDclUsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERoRSxRQUFPRCxPQUFPLEdBQUc2QztnQkFFakIsSUFBSXFCLFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJbUQsVUFBVW5ELFNBQVE7Z0JBRXRCLElBQUkwaUIsU0FBUzFpQixTQUFRO2dCQUVyQixJQUFJNkMsV0FBVzdDLFNBQVE7Z0JBRXZCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlVLE9BQU9WLFNBQVE7Z0JBRW5CLElBQUlXLFFBQVFYLFNBQVE7Z0JBRXBCLElBQUlZLFFBQVFaLFNBQVE7Z0JBRXBCLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCLElBQUl1QyxRQUFRdkMsU0FBUTtnQkFFcEIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSW9ELFdBQVdwRCxTQUFRO2dCQUV2QixJQUFJcUQsV0FBV3JELFNBQVE7Z0JBRXZCLElBQUlvQixRQUFRcEIsU0FBUTtnQkFFcEI2QixjQUFjOHBDLElBQUksR0FBRztnQkFFckI5cEMsY0FBYytwQyxNQUFNLEdBQUd4cUM7Z0JBRXZCUyxjQUFjMEYsU0FBUyxHQUFHbWIsT0FBTzdnQixjQUFjK3BDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUUvRDs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSTZlLFdBQVc7b0JBQ1htb0IsVUFBVTtvQkFDVkMsV0FBVztnQkFDZjtnQkFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVMzc0MsY0FBY2dELEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFdzZCLE1BQU07b0JBQzVDLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWTVzQyxhQUFZLEdBQUk7d0JBQ2xDLE9BQU8sSUFBSUEsY0FBY2dELEtBQUtrUCxPQUFPRSxPQUFPdzZCO29CQUNoRDtvQkFDQTVwQyxNQUFNMUIsUUFBUTBCLEtBQUt1aEI7b0JBQ25CaGxCLE1BQU1mLElBQUksQ0FBQyxJQUFJLEVBQUV3RSxLQUFLa1AsT0FBT0U7b0JBQzdCRixRQUFRLElBQUksQ0FBQ3VTLE9BQU87b0JBQ3BCclMsUUFBUSxJQUFJLENBQUNzUyxPQUFPO29CQUNwQixJQUFJLENBQUM3Z0IsTUFBTSxHQUFHN0QsY0FBYzhwQyxJQUFJO29CQUNoQyxJQUFJLENBQUNNLGNBQWMsR0FBR3dDLFNBQVMxNkIsTUFBTWxFLGFBQWEsQ0FBQzQrQixVQUFVNXBDLElBQUlxbkMsWUFBWSxJQUFJenJDLEtBQUtzRCxJQUFJO29CQUMxRixJQUFJLENBQUNvb0MsY0FBYyxHQUFHc0MsU0FBU3g2QixNQUFNcEUsYUFBYSxDQUFDNCtCLFVBQVU1cEMsSUFBSXVuQyxZQUFZLElBQUkzckMsS0FBS3NELElBQUk7b0JBQzFGLGdCQUFnQjtvQkFDaEIsSUFBSSxDQUFDMnFDLGVBQWUsR0FBR2p1QyxLQUFLc0QsSUFBSTtvQkFDaEMsSUFBSSxDQUFDNHFDLGdCQUFnQixHQUFHO29CQUN4QixJQUFJLENBQUNDLFVBQVUsR0FBRy9wQyxJQUFJMHBDLFFBQVE7b0JBQzlCLElBQUksQ0FBQ00sV0FBVyxHQUFHaHFDLElBQUkycEMsU0FBUztvQkFDaEMsY0FBYztvQkFDZCxJQUFJLENBQUM1QixJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxjQUFjO29CQUNuQixPQUFPO29CQUNQLElBQUksQ0FBQ0MsY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLFVBQVU7b0JBQ2YsUUFBUTtvQkFDUixJQUFJLENBQUNDLFVBQVU7b0JBQ2YsUUFBUTtvQkFDUixJQUFJLENBQUNDLE9BQU87b0JBQ1osUUFBUTtvQkFDUixJQUFJLENBQUNDLE9BQU87b0JBQ1osUUFBUTtvQkFDUixJQUFJLENBQUMyQixZQUFZO29CQUNqQixRQUFRO29CQUNSLElBQUksQ0FBQ0MsYUFBYTtnQkFDdEI7Z0JBRUE7O0NBRUMsR0FDRGx0QyxjQUFjMEYsU0FBUyxDQUFDNmxDLGVBQWUsR0FBRztvQkFDdEMsT0FBTyxJQUFJLENBQUNuQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEcHFDLGNBQWMwRixTQUFTLENBQUM4bEMsZUFBZSxHQUFHO29CQUN0QyxPQUFPLElBQUksQ0FBQ2xCLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0R0cUMsY0FBYzBGLFNBQVMsQ0FBQ3luQyxXQUFXLEdBQUcsU0FBU3BoQyxLQUFLO29CQUNoRDVLLFdBQVdFLFFBQU80QixNQUFNLENBQUN0RSxNQUFLd0UsUUFBUSxDQUFDNEksVUFBVUEsU0FBUztvQkFDMUQsSUFBSSxDQUFDZ2hDLFVBQVUsR0FBR2hoQztnQkFDdEI7Z0JBRUE7O0NBRUMsR0FDRC9MLGNBQWMwRixTQUFTLENBQUMwbkMsV0FBVyxHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ0wsVUFBVTtnQkFDMUI7Z0JBRUE7O0NBRUMsR0FDRC9zQyxjQUFjMEYsU0FBUyxDQUFDMm5DLFlBQVksR0FBRyxTQUFTamhDLE1BQU07b0JBQ2xEakwsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUt3RSxRQUFRLENBQUNpSixXQUFXQSxVQUFVO29CQUM1RCxJQUFJLENBQUM0Z0MsV0FBVyxHQUFHNWdDO2dCQUN2QjtnQkFFQTs7Q0FFQyxHQUNEcE0sY0FBYzBGLFNBQVMsQ0FBQzRuQyxZQUFZLEdBQUc7b0JBQ25DLE9BQU8sSUFBSSxDQUFDTixXQUFXO2dCQUMzQjtnQkFFQWh0QyxjQUFjMEYsU0FBUyxDQUFDdWYsVUFBVSxHQUFHO29CQUNqQyxPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDdmEsYUFBYSxDQUFDLElBQUksQ0FBQ2tnQyxjQUFjO2dCQUN6RDtnQkFFQXBxQyxjQUFjMEYsU0FBUyxDQUFDd2YsVUFBVSxHQUFHO29CQUNqQyxPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDeGEsYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO2dCQUN6RDtnQkFFQXRxQyxjQUFjMEYsU0FBUyxDQUFDeWYsZ0JBQWdCLEdBQUcsU0FBU0MsTUFBTTtvQkFDdEQsT0FBT3htQixLQUFLOE0sR0FBRyxDQUFDMFosUUFBUSxJQUFJLENBQUN5bkIsZUFBZTtnQkFDaEQ7Z0JBRUE3c0MsY0FBYzBGLFNBQVMsQ0FBQzJmLGlCQUFpQixHQUFHLFNBQVNELE1BQU07b0JBQ3ZELE9BQU9BLFNBQVMsSUFBSSxDQUFDMG5CLGdCQUFnQjtnQkFDekM7Z0JBRUE5c0MsY0FBYzBGLFNBQVMsQ0FBQzhmLHVCQUF1QixHQUFHLFNBQVMxVCxJQUFJO29CQUMzRCxJQUFJLENBQUNtNUIsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNqZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDeWhDLGNBQWMsR0FBRyxJQUFJLENBQUN4bUIsT0FBTyxDQUFDbGdCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3RELElBQUksQ0FBQzBoQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzFnQixTQUFTO29CQUN4QyxJQUFJLENBQUNxbkMsVUFBVSxHQUFHLElBQUksQ0FBQzFtQixPQUFPLENBQUMzZ0IsU0FBUztvQkFDeEMsSUFBSSxDQUFDc25DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDeGdCLE1BQU07b0JBQ2xDLElBQUksQ0FBQ3FuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUNsQyxJQUFJaVUsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOGMsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJNE4sS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJZ2QsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUl3aEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPLEtBQUsrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNuQyxxQ0FBcUM7b0JBQ3JDLElBQUksQ0FBQzJ5QixJQUFJLEdBQUc5ckMsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJcHRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDdWdDLGNBQWMsRUFBRSxJQUFJLENBQUNhLGNBQWM7b0JBQzdFLElBQUksQ0FBQ0QsSUFBSSxHQUFHL3JDLElBQUk0TyxPQUFPLENBQUNvK0IsSUFBSXJ0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3lnQyxjQUFjLEVBQUUsSUFBSSxDQUFDWSxjQUFjO29CQUM3RSw4QkFBOEI7b0JBQzlCLGNBQWM7b0JBQ2QscUJBQXFCO29CQUNyQixTQUFTO29CQUNULHlFQUF5RTtvQkFDekUsb0VBQW9FO29CQUNwRSwwQ0FBMEM7b0JBQzFDLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsVUFBVSxFQUFFcHpCLEtBQUssSUFBSSxDQUFDcXpCLFVBQVU7b0JBQzlDLFFBQVE7b0JBQ1IsSUFBSXR6QixLQUFLLElBQUksQ0FBQ3V6QixPQUFPLEVBQUVyekIsS0FBSyxJQUFJLENBQUNzekIsT0FBTztvQkFDeEMsUUFBUTtvQkFDUixJQUFJeHhCLElBQUksSUFBSWhiO29CQUNaZ2IsRUFBRTJDLEVBQUUsQ0FBQzBCLENBQUMsR0FBR3RHLEtBQUtFLEtBQUtELEtBQUssSUFBSSxDQUFDaXpCLElBQUksQ0FBQzFzQixDQUFDLEdBQUcsSUFBSSxDQUFDMHNCLElBQUksQ0FBQzFzQixDQUFDLEdBQUdyRyxLQUFLLElBQUksQ0FBQ2d6QixJQUFJLENBQUMzc0IsQ0FBQyxHQUFHLElBQUksQ0FBQzJzQixJQUFJLENBQUMzc0IsQ0FBQztvQkFDbEZ2RSxFQUFFMkMsRUFBRSxDQUFDNEIsQ0FBQyxHQUFHLENBQUN2RyxLQUFLLElBQUksQ0FBQ2l6QixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzRzQixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHckcsS0FBSyxJQUFJLENBQUNnekIsSUFBSSxDQUFDN3NCLENBQUMsR0FBRyxJQUFJLENBQUM2c0IsSUFBSSxDQUFDM3NCLENBQUM7b0JBQ3pFdkUsRUFBRTRDLEVBQUUsQ0FBQ3lCLENBQUMsR0FBR3JFLEVBQUUyQyxFQUFFLENBQUM0QixDQUFDO29CQUNmdkUsRUFBRTRDLEVBQUUsQ0FBQzJCLENBQUMsR0FBR3hHLEtBQUtFLEtBQUtELEtBQUssSUFBSSxDQUFDaXpCLElBQUksQ0FBQzVzQixDQUFDLEdBQUcsSUFBSSxDQUFDNHNCLElBQUksQ0FBQzVzQixDQUFDLEdBQUduRyxLQUFLLElBQUksQ0FBQ2d6QixJQUFJLENBQUM3c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzZzQixJQUFJLENBQUM3c0IsQ0FBQztvQkFDbEYsSUFBSSxDQUFDOHVCLFlBQVksR0FBR256QixFQUFFNkMsVUFBVTtvQkFDaEMsSUFBSSxDQUFDdXdCLGFBQWEsR0FBR3AxQixLQUFLRTtvQkFDMUIsSUFBSSxJQUFJLENBQUNrMUIsYUFBYSxHQUFHLEdBQUc7d0JBQ3hCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksSUFBSSxDQUFDQSxhQUFhO29CQUMvQztvQkFDQSxJQUFJcDdCLEtBQUtnQixZQUFZLEVBQUU7d0JBQ25CLGtEQUFrRDt3QkFDbEQsSUFBSSxDQUFDKzVCLGVBQWUsQ0FBQ25oQyxHQUFHLENBQUNvRyxLQUFLa0IsT0FBTzt3QkFDckMsSUFBSSxDQUFDODVCLGdCQUFnQixJQUFJaDdCLEtBQUtrQixPQUFPO3dCQUNyQyxJQUFJK0csSUFBSW5iLEtBQUtrb0IsR0FBRyxDQUFDLElBQUksQ0FBQytsQixlQUFlLENBQUMxdUIsQ0FBQyxFQUFFLElBQUksQ0FBQzB1QixlQUFlLENBQUN4dUIsQ0FBQzt3QkFDL0RyRCxHQUFHZixNQUFNLENBQUNwQyxJQUFJa0M7d0JBQ2RrQixNQUFNbkQsS0FBTWxaLENBQUFBLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRWh4QixLQUFLLElBQUksQ0FBQyt5QixnQkFBZ0IsQUFBRDt3QkFDM0Q1eEIsR0FBR3pQLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZG9CLE1BQU1uRCxLQUFNcFosQ0FBQUEsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFanhCLEtBQUssSUFBSSxDQUFDK3lCLGdCQUFnQixBQUFEO29CQUMvRCxPQUFPO3dCQUNILElBQUksQ0FBQ0QsZUFBZSxDQUFDL2xDLE9BQU87d0JBQzVCLElBQUksQ0FBQ2dtQyxnQkFBZ0IsR0FBRztvQkFDNUI7b0JBQ0EsSUFBSSxDQUFDcm9CLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzRRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzhRO29CQUM1QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBbmIsY0FBYzBGLFNBQVMsQ0FBQytmLHdCQUF3QixHQUFHLFNBQVMzVCxJQUFJO29CQUM1RCxJQUFJa0osS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMFEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUlxTixLQUFLLElBQUksQ0FBQ3N6QixVQUFVLEVBQUVwekIsS0FBSyxJQUFJLENBQUNxekIsVUFBVTtvQkFDOUMsUUFBUTtvQkFDUixJQUFJdHpCLEtBQUssSUFBSSxDQUFDdXpCLE9BQU8sRUFBRXJ6QixLQUFLLElBQUksQ0FBQ3N6QixPQUFPO29CQUN4QyxRQUFRO29CQUNSLElBQUlsZixJQUFJdGEsS0FBSzRZLEVBQUU7b0JBQ2YsUUFBUTtvQkFDUix5QkFBeUI7b0JBQ3pCO3dCQUNJLElBQUkraEIsT0FBT3R4QixLQUFLRjt3QkFDaEIsUUFBUTt3QkFDUixJQUFJM08sVUFBVSxDQUFDLElBQUksQ0FBQzRnQyxhQUFhLEdBQUdUO3dCQUNwQyxRQUFRO3dCQUNSLElBQUljLGFBQWEsSUFBSSxDQUFDVCxnQkFBZ0I7d0JBQ3RDLFFBQVE7d0JBQ1IsSUFBSVUsYUFBYXBoQixJQUFJLElBQUksQ0FBQzRnQixXQUFXO3dCQUNyQyxRQUFRO3dCQUNSLElBQUksQ0FBQ0YsZ0JBQWdCLEdBQUdudUMsTUFBSythLEtBQUssQ0FBQyxJQUFJLENBQUNvekIsZ0JBQWdCLEdBQUd4Z0MsU0FBUyxDQUFDa2hDLFlBQVlBO3dCQUNqRmxoQyxVQUFVLElBQUksQ0FBQ3dnQyxnQkFBZ0IsR0FBR1M7d0JBQ2xDdHlCLE1BQU1uRCxLQUFLeEw7d0JBQ1g2TyxNQUFNbkQsS0FBSzFMO29CQUNmO29CQUNBLHdCQUF3QjtvQkFDeEI7d0JBQ0ksSUFBSW1nQyxPQUFPN3RDLEtBQUtpTCxHQUFHLENBQUNqTCxLQUFLa0wsR0FBRyxDQUFDb1IsSUFBSXRjLEtBQUttTCxLQUFLLENBQUNvUixJQUFJLElBQUksQ0FBQzZ2QixJQUFJLElBQUlwc0MsS0FBS2tMLEdBQUcsQ0FBQ2tSLElBQUlwYyxLQUFLbUwsS0FBSyxDQUFDa1IsSUFBSSxJQUFJLENBQUM4dkIsSUFBSTt3QkFDbEcsT0FBTzt3QkFDUCxJQUFJeitCLFVBQVUxTixLQUFLZzdCLEdBQUcsQ0FBQzk2QixNQUFNK08sT0FBTyxDQUFDLElBQUksQ0FBQ28vQixZQUFZLEVBQUVSO3dCQUN4RCxPQUFPO3dCQUNQLElBQUljLGFBQWEsSUFBSSxDQUFDVixlQUFlO3dCQUNyQyxPQUFPO3dCQUNQLElBQUksQ0FBQ0EsZUFBZSxDQUFDL2lDLEdBQUcsQ0FBQ3dDO3dCQUN6QixJQUFJa2hDLGFBQWFwaEIsSUFBSSxJQUFJLENBQUMyZ0IsVUFBVTt3QkFDcEMsUUFBUTt3QkFDUixJQUFJLElBQUksQ0FBQ0YsZUFBZSxDQUFDN2xCLGFBQWEsS0FBS3dtQixhQUFhQSxZQUFZOzRCQUNoRSxJQUFJLENBQUNYLGVBQWUsQ0FBQy96QixTQUFTOzRCQUM5QixJQUFJLENBQUMrekIsZUFBZSxDQUFDbmhDLEdBQUcsQ0FBQzhoQzt3QkFDN0I7d0JBQ0FsaEMsVUFBVTFOLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDZ2pDLGVBQWUsRUFBRVU7d0JBQ3pDdnlCLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUl2TDt3QkFDZDJPLE1BQU1uRCxLQUFLbFosS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNnaEMsSUFBSSxFQUFFeitCO3dCQUNqQzRPLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJekw7d0JBQ2Q2TyxNQUFNbkQsS0FBS3BaLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRTErQjtvQkFDckM7b0JBQ0EsSUFBSSxDQUFDbVksT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQyxHQUFHNFE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUMsR0FBR3lRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQyxHQUFHOFE7b0JBQzVCLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDLEdBQUcyUTtnQkFDaEM7Z0JBRUFuYixjQUFjMEYsU0FBUyxDQUFDZ2dCLHdCQUF3QixHQUFHLFNBQVM1VCxJQUFJO29CQUM1RCxPQUFPO2dCQUNYO1lBR0E7WUFBRTtnQkFBQyxZQUFXO2dCQUFFLGVBQWM7Z0JBQUUsbUJBQWtCO2dCQUFHLG1CQUFrQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxtQkFBa0I7Z0JBQUcsdUJBQXNCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsbUJBQWtCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTM1QsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3pWLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHOEM7Z0JBRWpCLElBQUlvQixVQUFTbEQsU0FBUTtnQkFFckIsSUFBSW1ELFVBQVVuRCxTQUFRO2dCQUV0QixJQUFJMGlCLFNBQVMxaUIsU0FBUTtnQkFFckIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJVSxPQUFPVixTQUFRO2dCQUVuQixJQUFJVyxRQUFRWCxTQUFRO2dCQUVwQixJQUFJWSxRQUFRWixTQUFRO2dCQUVwQixJQUFJYyxNQUFNZCxTQUFRO2dCQUVsQixJQUFJdUMsUUFBUXZDLFNBQVE7Z0JBRXBCLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlvRCxXQUFXcEQsU0FBUTtnQkFFdkIsSUFBSXFELFdBQVdyRCxTQUFRO2dCQUV2QixJQUFJb0IsUUFBUXBCLFNBQVE7Z0JBRXBCLElBQUltQyxnQkFBZ0JuQyxTQUFRO2dCQUU1QixJQUFJaUMsaUJBQWlCakMsU0FBUTtnQkFFN0I4QixVQUFVNnBDLElBQUksR0FBRztnQkFFakI3cEMsVUFBVThwQyxNQUFNLEdBQUd4cUM7Z0JBRW5CVSxVQUFVeUYsU0FBUyxHQUFHbWIsT0FBTzVnQixVQUFVOHBDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUV2RDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELElBQUk2ZSxXQUFXO29CQUNYZ0ksT0FBTztnQkFDWDtnQkFFQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELFNBQVN0c0IsVUFBVStDLEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFcTdCLE1BQU0sRUFBRUMsTUFBTSxFQUFFbmhCLEtBQUs7b0JBQ3ZELElBQUksQ0FBRSxDQUFBLElBQUksWUFBWXRzQixTQUFRLEdBQUk7d0JBQzlCLE9BQU8sSUFBSUEsVUFBVStDLEtBQUtrUCxPQUFPRSxPQUFPcTdCLFFBQVFDLFFBQVFuaEI7b0JBQzVEO29CQUNBdnBCLE1BQU0xQixRQUFRMEIsS0FBS3VoQjtvQkFDbkJobEIsTUFBTWYsSUFBSSxDQUFDLElBQUksRUFBRXdFLEtBQUtrUCxPQUFPRTtvQkFDN0JGLFFBQVEsSUFBSSxDQUFDdVMsT0FBTztvQkFDcEJyUyxRQUFRLElBQUksQ0FBQ3NTLE9BQU87b0JBQ3BCLElBQUksQ0FBQzdnQixNQUFNLEdBQUc1RCxVQUFVNnBDLElBQUk7b0JBQzVCM29DLFdBQVdFLFFBQU80QixNQUFNLENBQUN3cUMsT0FBTzVwQyxNQUFNLEtBQUt2RCxjQUFjd3BDLElBQUksSUFBSTJELE9BQU81cEMsTUFBTSxLQUFLekQsZUFBZTBwQyxJQUFJO29CQUN0RzNvQyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDeXFDLE9BQU83cEMsTUFBTSxLQUFLdkQsY0FBY3dwQyxJQUFJLElBQUk0RCxPQUFPN3BDLE1BQU0sS0FBS3pELGVBQWUwcEMsSUFBSTtvQkFDdEcsSUFBSSxDQUFDNkQsUUFBUSxHQUFHRixTQUFTQSxTQUFTenFDLElBQUl5cUMsTUFBTTtvQkFDNUMsSUFBSSxDQUFDRyxRQUFRLEdBQUdGLFNBQVNBLFNBQVMxcUMsSUFBSTBxQyxNQUFNO29CQUM1QyxJQUFJLENBQUNHLE9BQU8sR0FBR2x2QyxNQUFLd0UsUUFBUSxDQUFDb3BCLFNBQVNBLFFBQVF2cEIsSUFBSXVwQixLQUFLO29CQUN2RCxJQUFJLENBQUN1aEIsT0FBTyxHQUFHLElBQUksQ0FBQ0gsUUFBUSxDQUFDL21DLE9BQU87b0JBQ3BDLElBQUksQ0FBQ21uQyxPQUFPLEdBQUcsSUFBSSxDQUFDSCxRQUFRLENBQUNobkMsT0FBTztvQkFDcEMsbUNBQW1DO29CQUNuQyxtQ0FBbUM7b0JBQ25DLElBQUlvbkMsYUFBYUM7b0JBQ2pCLFFBQVE7b0JBQ1IsdUVBQXVFO29CQUN2RSxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJLENBQUNQLFFBQVEsQ0FBQzdvQixRQUFRO29CQUNyQyxJQUFJLENBQUNMLE9BQU8sR0FBRyxJQUFJLENBQUNrcEIsUUFBUSxDQUFDNW9CLFFBQVE7b0JBQ3JDLHlCQUF5QjtvQkFDekIsSUFBSW5RLE1BQU0sSUFBSSxDQUFDNlAsT0FBTyxDQUFDdmdCLElBQUk7b0JBQzNCLElBQUlnVSxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQ2pnQixPQUFPLENBQUN0RyxDQUFDO29CQUMvQixJQUFJaXdDLE1BQU0sSUFBSSxDQUFDRCxPQUFPLENBQUNocUMsSUFBSTtvQkFDM0IsSUFBSWtxQyxLQUFLLElBQUksQ0FBQ0YsT0FBTyxDQUFDMXBDLE9BQU8sQ0FBQ3RHLENBQUM7b0JBQy9CLElBQUksSUFBSSxDQUFDNHZDLE9BQU8sS0FBS3h0QyxjQUFjd3BDLElBQUksRUFBRTt3QkFDckMsSUFBSXVFLFdBQVcsSUFBSSxDQUFDVixRQUFRO3dCQUM1QixnQkFBZ0I7d0JBQ2hCLElBQUksQ0FBQ1csY0FBYyxHQUFHRCxTQUFTakUsY0FBYzt3QkFDN0MsSUFBSSxDQUFDQSxjQUFjLEdBQUdpRSxTQUFTL0QsY0FBYzt3QkFDN0MsSUFBSSxDQUFDaUUsaUJBQWlCLEdBQUdGLFNBQVNHLGdCQUFnQjt3QkFDbEQsSUFBSSxDQUFDQyxZQUFZLEdBQUc3dkMsS0FBS3NELElBQUk7d0JBQzdCOHJDLGNBQWM5MUIsS0FBS2syQixLQUFLLElBQUksQ0FBQ0csaUJBQWlCO29CQUNsRCxPQUFPO3dCQUNILElBQUlHLFlBQVksSUFBSSxDQUFDZixRQUFRO3dCQUM3QixpQkFBaUI7d0JBQ2pCLElBQUksQ0FBQ1csY0FBYyxHQUFHSSxVQUFVdEUsY0FBYzt3QkFDOUMsSUFBSSxDQUFDQSxjQUFjLEdBQUdzRSxVQUFVcEUsY0FBYzt3QkFDOUMsSUFBSSxDQUFDaUUsaUJBQWlCLEdBQUdHLFVBQVVGLGdCQUFnQjt3QkFDbkQsSUFBSSxDQUFDQyxZQUFZLEdBQUdDLFVBQVVDLGFBQWE7d0JBQzNDLElBQUlDLEtBQUssSUFBSSxDQUFDTixjQUFjO3dCQUM1QixJQUFJblQsS0FBS2w4QixJQUFJZ1AsUUFBUSxDQUFDa2dDLElBQUk3cEMsQ0FBQyxFQUFFMUYsS0FBS2tMLEdBQUcsQ0FBQzdLLElBQUl5TSxHQUFHLENBQUNrSixJQUFJdFEsQ0FBQyxFQUFFLElBQUksQ0FBQzhsQyxjQUFjLEdBQUd4ckMsS0FBS2lMLEdBQUcsQ0FBQytLLElBQUl4USxDQUFDLEVBQUUrcEMsSUFBSS9wQyxDQUFDO3dCQUNoRzRwQyxjQUFjcHZDLEtBQUt5TCxHQUFHLENBQUM4d0IsSUFBSSxJQUFJLENBQUNzVCxZQUFZLElBQUk3dkMsS0FBS3lMLEdBQUcsQ0FBQ3VrQyxJQUFJLElBQUksQ0FBQ0gsWUFBWTtvQkFDbEY7b0JBQ0EsSUFBSSxDQUFDSSxPQUFPLEdBQUcsSUFBSSxDQUFDakIsUUFBUSxDQUFDOW9CLFFBQVE7b0JBQ3JDLElBQUksQ0FBQ0osT0FBTyxHQUFHLElBQUksQ0FBQ2twQixRQUFRLENBQUM3b0IsUUFBUTtvQkFDckMseUJBQXlCO29CQUN6QixJQUFJbFEsTUFBTSxJQUFJLENBQUM2UCxPQUFPLENBQUN4Z0IsSUFBSTtvQkFDM0IsSUFBSWtVLEtBQUssSUFBSSxDQUFDc00sT0FBTyxDQUFDbGdCLE9BQU8sQ0FBQ3RHLENBQUM7b0JBQy9CLElBQUk0d0MsTUFBTSxJQUFJLENBQUNELE9BQU8sQ0FBQzNxQyxJQUFJO29CQUMzQixJQUFJNnFDLEtBQUssSUFBSSxDQUFDRixPQUFPLENBQUNycUMsT0FBTyxDQUFDdEcsQ0FBQztvQkFDL0IsSUFBSSxJQUFJLENBQUM2dkMsT0FBTyxLQUFLenRDLGNBQWN3cEMsSUFBSSxFQUFFO3dCQUNyQyxJQUFJdUUsV0FBVyxJQUFJLENBQUNULFFBQVE7d0JBQzVCLGdCQUFnQjt3QkFDaEIsSUFBSSxDQUFDb0IsY0FBYyxHQUFHWCxTQUFTakUsY0FBYzt3QkFDN0MsSUFBSSxDQUFDRSxjQUFjLEdBQUcrRCxTQUFTL0QsY0FBYzt3QkFDN0MsSUFBSSxDQUFDMkUsaUJBQWlCLEdBQUdaLFNBQVNHLGdCQUFnQjt3QkFDbEQsSUFBSSxDQUFDVSxZQUFZLEdBQUd0d0MsS0FBS3NELElBQUk7d0JBQzdCK3JDLGNBQWM3MUIsS0FBSzIyQixLQUFLLElBQUksQ0FBQ0UsaUJBQWlCO29CQUNsRCxPQUFPO3dCQUNILElBQUlQLFlBQVksSUFBSSxDQUFDZCxRQUFRO3dCQUM3QixpQkFBaUI7d0JBQ2pCLElBQUksQ0FBQ29CLGNBQWMsR0FBR04sVUFBVXRFLGNBQWM7d0JBQzlDLElBQUksQ0FBQ0UsY0FBYyxHQUFHb0UsVUFBVXBFLGNBQWM7d0JBQzlDLElBQUksQ0FBQzJFLGlCQUFpQixHQUFHUCxVQUFVRixnQkFBZ0I7d0JBQ25ELElBQUksQ0FBQ1UsWUFBWSxHQUFHUixVQUFVQyxhQUFhO3dCQUMzQyxJQUFJUSxLQUFLLElBQUksQ0FBQ0gsY0FBYzt3QkFDNUIsSUFBSTVULEtBQUtuOEIsSUFBSWdQLFFBQVEsQ0FBQzZnQyxJQUFJeHFDLENBQUMsRUFBRTFGLEtBQUtrTCxHQUFHLENBQUM3SyxJQUFJeU0sR0FBRyxDQUFDbUosSUFBSXZRLENBQUMsRUFBRSxJQUFJLENBQUNnbUMsY0FBYyxHQUFHMXJDLEtBQUtpTCxHQUFHLENBQUNnTCxJQUFJelEsQ0FBQyxFQUFFMHFDLElBQUkxcUMsQ0FBQzt3QkFDaEc2cEMsY0FBY3J2QyxLQUFLeUwsR0FBRyxDQUFDK3dCLElBQUksSUFBSSxDQUFDOFQsWUFBWSxJQUFJdHdDLEtBQUt5TCxHQUFHLENBQUM4a0MsSUFBSSxJQUFJLENBQUNELFlBQVk7b0JBQ2xGO29CQUNBLElBQUksQ0FBQ0UsVUFBVSxHQUFHcEIsY0FBYyxJQUFJLENBQUNILE9BQU8sR0FBR0k7b0JBQy9DLElBQUksQ0FBQ3RELFNBQVMsR0FBRztvQkFDakIsY0FBYztvQkFDZCxJQUFJLENBQUMwRSxLQUFLLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxLQUFLO29CQUM5QyxPQUFPO29CQUNQLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQ0MsSUFBSTtvQkFDMUMsUUFBUTtvQkFDUixJQUFJLENBQUNDLElBQUksRUFBRSxJQUFJLENBQUNDLElBQUksRUFBRSxJQUFJLENBQUNDLElBQUksRUFBRSxJQUFJLENBQUNDLElBQUk7b0JBQzFDLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxNQUFNLEVBQUUsSUFBSSxDQUFDQyxNQUFNO29CQUN4QixPQUFPO29CQUNQLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0MsS0FBSztvQkFDOUMsUUFBUTtvQkFDUixJQUFJLENBQUN4c0MsTUFBTTtnQkFDZjtnQkFFQTs7Q0FFQyxHQUNEN0QsVUFBVXlGLFNBQVMsQ0FBQzZxQyxTQUFTLEdBQUc7b0JBQzVCLE9BQU8sSUFBSSxDQUFDNUMsUUFBUTtnQkFDeEI7Z0JBRUE7O0NBRUMsR0FDRDF0QyxVQUFVeUYsU0FBUyxDQUFDOHFDLFNBQVMsR0FBRztvQkFDNUIsT0FBTyxJQUFJLENBQUM1QyxRQUFRO2dCQUN4QjtnQkFFQTs7Q0FFQyxHQUNEM3RDLFVBQVV5RixTQUFTLENBQUMrcUMsUUFBUSxHQUFHLFNBQVNsa0IsS0FBSztvQkFDekNwckIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUt3RSxRQUFRLENBQUNvcEI7b0JBQ3ZDLElBQUksQ0FBQ3NoQixPQUFPLEdBQUd0aEI7Z0JBQ25CO2dCQUVBdHNCLFVBQVV5RixTQUFTLENBQUNnckMsUUFBUSxHQUFHO29CQUMzQixPQUFPLElBQUksQ0FBQzdDLE9BQU87Z0JBQ3ZCO2dCQUVBNXRDLFVBQVV5RixTQUFTLENBQUN1ZixVQUFVLEdBQUc7b0JBQzdCLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN2YSxhQUFhLENBQUMsSUFBSSxDQUFDa2dDLGNBQWM7Z0JBQ3pEO2dCQUVBbnFDLFVBQVV5RixTQUFTLENBQUN3ZixVQUFVLEdBQUc7b0JBQzdCLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN4YSxhQUFhLENBQUMsSUFBSSxDQUFDb2dDLGNBQWM7Z0JBQ3pEO2dCQUVBcnFDLFVBQVV5RixTQUFTLENBQUN5ZixnQkFBZ0IsR0FBRyxTQUFTQyxNQUFNO29CQUNsRCxPQUFPeG1CLEtBQUs4TSxHQUFHLENBQUMsSUFBSSxDQUFDaS9CLFNBQVMsRUFBRSxJQUFJLENBQUNzRixNQUFNLEVBQUV2a0MsR0FBRyxDQUFDMFo7Z0JBQ3JEO2dCQUVBbmxCLFVBQVV5RixTQUFTLENBQUMyZixpQkFBaUIsR0FBRyxTQUFTRCxNQUFNO29CQUNuRCxJQUFJdXJCLElBQUksSUFBSSxDQUFDaEcsU0FBUyxHQUFHLElBQUksQ0FBQ3dGLEtBQUs7b0JBQ25DLFFBQVE7b0JBQ1IsT0FBTy9xQixTQUFTdXJCO2dCQUNwQjtnQkFFQTF3QyxVQUFVeUYsU0FBUyxDQUFDOGYsdUJBQXVCLEdBQUcsU0FBUzFULElBQUk7b0JBQ3ZELElBQUksQ0FBQ3U5QixLQUFLLEdBQUcsSUFBSSxDQUFDNXFCLE9BQU8sQ0FBQ2pnQixPQUFPLENBQUNpRixXQUFXO29CQUM3QyxJQUFJLENBQUM2bEMsS0FBSyxHQUFHLElBQUksQ0FBQzVxQixPQUFPLENBQUNsZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDN0MsSUFBSSxDQUFDOGxDLEtBQUssR0FBRyxJQUFJLENBQUNyQixPQUFPLENBQUMxcEMsT0FBTyxDQUFDaUYsV0FBVztvQkFDN0MsSUFBSSxDQUFDK2xDLEtBQUssR0FBRyxJQUFJLENBQUNYLE9BQU8sQ0FBQ3JxQyxPQUFPLENBQUNpRixXQUFXO29CQUM3QyxJQUFJLENBQUNnbUMsSUFBSSxHQUFHLElBQUksQ0FBQ2hyQixPQUFPLENBQUMxZ0IsU0FBUztvQkFDbEMsSUFBSSxDQUFDMnJDLElBQUksR0FBRyxJQUFJLENBQUNockIsT0FBTyxDQUFDM2dCLFNBQVM7b0JBQ2xDLElBQUksQ0FBQzRyQyxJQUFJLEdBQUcsSUFBSSxDQUFDekIsT0FBTyxDQUFDbnFDLFNBQVM7b0JBQ2xDLElBQUksQ0FBQzZyQyxJQUFJLEdBQUcsSUFBSSxDQUFDZixPQUFPLENBQUM5cUMsU0FBUztvQkFDbEMsSUFBSSxDQUFDOHJDLElBQUksR0FBRyxJQUFJLENBQUNwckIsT0FBTyxDQUFDeGdCLE1BQU07b0JBQy9CLElBQUksQ0FBQzZyQyxJQUFJLEdBQUcsSUFBSSxDQUFDcHJCLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUMvQixJQUFJLENBQUM4ckMsSUFBSSxHQUFHLElBQUksQ0FBQzdCLE9BQU8sQ0FBQ2pxQyxNQUFNO29CQUMvQixJQUFJLENBQUMrckMsSUFBSSxHQUFHLElBQUksQ0FBQ25CLE9BQU8sQ0FBQzVxQyxNQUFNO29CQUMvQixJQUFJaVUsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOGMsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJNE4sS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJZ2QsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUk0akMsS0FBSyxJQUFJLENBQUNGLE9BQU8sQ0FBQ3ZwQyxVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJMHlDLEtBQUssSUFBSSxDQUFDMUMsT0FBTyxDQUFDeHBDLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUl5bUMsS0FBSyxJQUFJLENBQUMzQyxPQUFPLENBQUN4cEMsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSXVrQyxLQUFLLElBQUksQ0FBQ0YsT0FBTyxDQUFDbHFDLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk0eUMsS0FBSyxJQUFJLENBQUNqQyxPQUFPLENBQUNucUMsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSWlzQixLQUFLLElBQUksQ0FBQ3dZLE9BQU8sQ0FBQ25xQyxVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJd2hDLEtBQUsvc0MsSUFBSTZuQixHQUFHLENBQUM1TztvQkFDakIsSUFBSSt6QixLQUFLaHRDLElBQUk2bkIsR0FBRyxDQUFDMU87b0JBQ2pCLElBQUkyNEIsS0FBSzl4QyxJQUFJNm5CLEdBQUcsQ0FBQ3NuQjtvQkFDakIsSUFBSTRDLEtBQUsveEMsSUFBSTZuQixHQUFHLENBQUNpb0I7b0JBQ2pCLElBQUksQ0FBQ2pyQyxNQUFNLEdBQUc7b0JBQ2QsSUFBSSxJQUFJLENBQUNncUMsT0FBTyxJQUFJeHRDLGNBQWN3cEMsSUFBSSxFQUFFO3dCQUNwQyxJQUFJLENBQUNtRyxNQUFNLEdBQUdyeEMsS0FBS3NELElBQUk7d0JBQ3ZCLElBQUksQ0FBQ2l1QyxLQUFLLEdBQUc7d0JBQ2IsSUFBSSxDQUFDRSxLQUFLLEdBQUc7d0JBQ2IsSUFBSSxDQUFDdnNDLE1BQU0sSUFBSSxJQUFJLENBQUMrckMsSUFBSSxHQUFHLElBQUksQ0FBQ0UsSUFBSTtvQkFDeEMsT0FBTzt3QkFDSCxJQUFJOXhDLElBQUlnQixJQUFJNE8sT0FBTyxDQUFDa2pDLElBQUksSUFBSSxDQUFDdEMsWUFBWTt3QkFDekMsT0FBTzt3QkFDUCxJQUFJd0MsS0FBS2h5QyxJQUFJMG9DLE1BQU0sQ0FBQ29KLElBQUksSUFBSSxDQUFDekMsY0FBYyxFQUFFLElBQUksQ0FBQ2lCLEtBQUs7d0JBQ3ZELE9BQU87d0JBQ1AsSUFBSXI4QixLQUFLalUsSUFBSTBvQyxNQUFNLENBQUNxRSxJQUFJLElBQUksQ0FBQzVCLGNBQWMsRUFBRSxJQUFJLENBQUNpRixLQUFLO3dCQUN2RCxPQUFPO3dCQUNQLElBQUksQ0FBQ1ksTUFBTSxHQUFHaHlDO3dCQUNkLElBQUksQ0FBQ295QyxLQUFLLEdBQUd6eEMsS0FBS21MLEtBQUssQ0FBQ2tuQyxJQUFJaHpDO3dCQUM1QixJQUFJLENBQUNreUMsS0FBSyxHQUFHdnhDLEtBQUttTCxLQUFLLENBQUNtSixJQUFJalY7d0JBQzVCLElBQUksQ0FBQzZGLE1BQU0sSUFBSSxJQUFJLENBQUM2ckMsSUFBSSxHQUFHLElBQUksQ0FBQ0YsSUFBSSxHQUFHLElBQUksQ0FBQ00sSUFBSSxHQUFHLElBQUksQ0FBQ00sS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHLElBQUksQ0FBQ1IsSUFBSSxHQUFHLElBQUksQ0FBQ00sS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSztvQkFDcEg7b0JBQ0EsSUFBSSxJQUFJLENBQUNwQyxPQUFPLElBQUl6dEMsY0FBY3dwQyxJQUFJLEVBQUU7d0JBQ3BDLElBQUksQ0FBQ29HLE1BQU0sR0FBR3R4QyxLQUFLc0QsSUFBSTt3QkFDdkIsSUFBSSxDQUFDa3VDLEtBQUssR0FBRyxJQUFJLENBQUN2QyxPQUFPO3dCQUN6QixJQUFJLENBQUN5QyxLQUFLLEdBQUcsSUFBSSxDQUFDekMsT0FBTzt3QkFDekIsSUFBSSxDQUFDL3BDLE1BQU0sSUFBSSxJQUFJLENBQUMrcEMsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxHQUFJLENBQUEsSUFBSSxDQUFDaUMsSUFBSSxHQUFHLElBQUksQ0FBQ0UsSUFBSSxBQUFEO29CQUN0RSxPQUFPO3dCQUNILElBQUkveEMsSUFBSWdCLElBQUk0TyxPQUFPLENBQUNtakMsSUFBSSxJQUFJLENBQUM5QixZQUFZO3dCQUN6QyxPQUFPO3dCQUNQLElBQUlnQyxLQUFLanlDLElBQUkwb0MsTUFBTSxDQUFDcUosSUFBSSxJQUFJLENBQUNoQyxjQUFjLEVBQUUsSUFBSSxDQUFDUSxLQUFLO3dCQUN2RCxPQUFPO3dCQUNQLElBQUlyOEIsS0FBS2xVLElBQUkwb0MsTUFBTSxDQUFDc0UsSUFBSSxJQUFJLENBQUMzQixjQUFjLEVBQUUsSUFBSSxDQUFDZ0YsS0FBSzt3QkFDdkQsT0FBTzt3QkFDUCxJQUFJLENBQUNZLE1BQU0sR0FBR3R4QyxLQUFLOE0sR0FBRyxDQUFDLElBQUksQ0FBQ21pQyxPQUFPLEVBQUU1dkM7d0JBQ3JDLElBQUksQ0FBQ3F5QyxLQUFLLEdBQUcsSUFBSSxDQUFDekMsT0FBTyxHQUFHanZDLEtBQUttTCxLQUFLLENBQUNtbkMsSUFBSWp6Qzt3QkFDM0MsSUFBSSxDQUFDbXlDLEtBQUssR0FBRyxJQUFJLENBQUN2QyxPQUFPLEdBQUdqdkMsS0FBS21MLEtBQUssQ0FBQ29KLElBQUlsVjt3QkFDM0MsSUFBSSxDQUFDNkYsTUFBTSxJQUFJLElBQUksQ0FBQytwQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLEdBQUksQ0FBQSxJQUFJLENBQUMrQixJQUFJLEdBQUcsSUFBSSxDQUFDRixJQUFJLEFBQUQsSUFBSyxJQUFJLENBQUNNLElBQUksR0FBRyxJQUFJLENBQUNNLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJLENBQUNSLElBQUksR0FBRyxJQUFJLENBQUNNLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7b0JBQ3BKO29CQUNBLDBCQUEwQjtvQkFDMUIsSUFBSSxDQUFDdHNDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDQSxNQUFNLEdBQUc7b0JBQ2xELElBQUlnTyxLQUFLZ0IsWUFBWSxFQUFFO3dCQUNuQmtJLEdBQUd2UCxNQUFNLENBQUMsSUFBSSxDQUFDZ2tDLElBQUksR0FBRyxJQUFJLENBQUM5RSxTQUFTLEVBQUUsSUFBSSxDQUFDc0YsTUFBTTt3QkFDakRoMUIsTUFBTSxJQUFJLENBQUM0MEIsSUFBSSxHQUFHLElBQUksQ0FBQ2xGLFNBQVMsR0FBRyxJQUFJLENBQUN3RixLQUFLO3dCQUM3Q2oxQixHQUFHelAsTUFBTSxDQUFDLElBQUksQ0FBQ2lrQyxJQUFJLEdBQUcsSUFBSSxDQUFDL0UsU0FBUyxFQUFFLElBQUksQ0FBQ3VGLE1BQU07d0JBQ2pELzBCLE1BQU0sSUFBSSxDQUFDMjBCLElBQUksR0FBRyxJQUFJLENBQUNuRixTQUFTLEdBQUcsSUFBSSxDQUFDeUYsS0FBSzt3QkFDN0NRLEdBQUczMkIsTUFBTSxDQUFDLElBQUksQ0FBQzAxQixJQUFJLEdBQUcsSUFBSSxDQUFDaEYsU0FBUyxFQUFFLElBQUksQ0FBQ3NGLE1BQU07d0JBQ2pEWSxNQUFNLElBQUksQ0FBQ2QsSUFBSSxHQUFHLElBQUksQ0FBQ3BGLFNBQVMsR0FBRyxJQUFJLENBQUMwRixLQUFLO3dCQUM3Q1MsR0FBRzcyQixNQUFNLENBQUMsSUFBSSxDQUFDMjFCLElBQUksR0FBRyxJQUFJLENBQUNqRixTQUFTLEVBQUUsSUFBSSxDQUFDdUYsTUFBTTt3QkFDakQ3WixNQUFNLElBQUksQ0FBQzJaLElBQUksR0FBRyxJQUFJLENBQUNyRixTQUFTLEdBQUcsSUFBSSxDQUFDMkYsS0FBSztvQkFDakQsT0FBTzt3QkFDSCxJQUFJLENBQUMzRixTQUFTLEdBQUc7b0JBQ3JCO29CQUNBLElBQUksQ0FBQ2xtQixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLENBQUN6QixHQUFHLENBQUNxUztvQkFDOUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLENBQUN6QixHQUFHLENBQUN1UztvQkFDOUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO29CQUM1QixJQUFJLENBQUMreUIsT0FBTyxDQUFDeHBDLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ2lvQztvQkFDOUIsSUFBSSxDQUFDMUMsT0FBTyxDQUFDeHBDLFVBQVUsQ0FBQzhGLENBQUMsR0FBR3FtQztvQkFDNUIsSUFBSSxDQUFDaEMsT0FBTyxDQUFDbnFDLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ21vQztvQkFDOUIsSUFBSSxDQUFDakMsT0FBTyxDQUFDbnFDLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzZyQjtnQkFDaEM7Z0JBRUFwMkIsVUFBVXlGLFNBQVMsQ0FBQytmLHdCQUF3QixHQUFHLFNBQVMzVCxJQUFJO29CQUN4RCxJQUFJa0osS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMFEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUlvbUMsS0FBSyxJQUFJLENBQUMxQyxPQUFPLENBQUN4cEMsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSXltQyxLQUFLLElBQUksQ0FBQzNDLE9BQU8sQ0FBQ3hwQyxVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJc21DLEtBQUssSUFBSSxDQUFDakMsT0FBTyxDQUFDbnFDLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUlpc0IsS0FBSyxJQUFJLENBQUN3WSxPQUFPLENBQUNucUMsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSWlpQyxPQUFPN3RDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDNGxDLE1BQU0sRUFBRWoxQixNQUFNcGMsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUM0bEMsTUFBTSxFQUFFVyxNQUFNaHlDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDNmxDLE1BQU0sRUFBRWgxQixNQUFNdGMsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUM2bEMsTUFBTSxFQUFFWTtvQkFDckgsUUFBUTtvQkFDUnJFLFFBQVEsSUFBSSxDQUFDMEQsS0FBSyxHQUFHbDFCLEtBQUssSUFBSSxDQUFDbzFCLEtBQUssR0FBR1EsS0FBTSxDQUFBLElBQUksQ0FBQ1QsS0FBSyxHQUFHajFCLEtBQUssSUFBSSxDQUFDbTFCLEtBQUssR0FBR2phLEVBQUM7b0JBQzdFLElBQUkvcEIsVUFBVSxDQUFDLElBQUksQ0FBQ3hJLE1BQU0sR0FBRzJvQztvQkFDN0IsUUFBUTtvQkFDUixJQUFJLENBQUM5QixTQUFTLElBQUlyK0I7b0JBQ2xCME8sR0FBR3ZQLE1BQU0sQ0FBQyxJQUFJLENBQUNna0MsSUFBSSxHQUFHbmpDLFNBQVMsSUFBSSxDQUFDMmpDLE1BQU07b0JBQzFDaDFCLE1BQU0sSUFBSSxDQUFDNDBCLElBQUksR0FBR3ZqQyxVQUFVLElBQUksQ0FBQzZqQyxLQUFLO29CQUN0Q2oxQixHQUFHelAsTUFBTSxDQUFDLElBQUksQ0FBQ2lrQyxJQUFJLEdBQUdwakMsU0FBUyxJQUFJLENBQUM0akMsTUFBTTtvQkFDMUMvMEIsTUFBTSxJQUFJLENBQUMyMEIsSUFBSSxHQUFHeGpDLFVBQVUsSUFBSSxDQUFDOGpDLEtBQUs7b0JBQ3RDUSxHQUFHMzJCLE1BQU0sQ0FBQyxJQUFJLENBQUMwMUIsSUFBSSxHQUFHcmpDLFNBQVMsSUFBSSxDQUFDMmpDLE1BQU07b0JBQzFDWSxNQUFNLElBQUksQ0FBQ2QsSUFBSSxHQUFHempDLFVBQVUsSUFBSSxDQUFDK2pDLEtBQUs7b0JBQ3RDUyxHQUFHNzJCLE1BQU0sQ0FBQyxJQUFJLENBQUMyMUIsSUFBSSxHQUFHdGpDLFNBQVMsSUFBSSxDQUFDNGpDLE1BQU07b0JBQzFDN1osTUFBTSxJQUFJLENBQUMyWixJQUFJLEdBQUcxakMsVUFBVSxJQUFJLENBQUNna0MsS0FBSztvQkFDdEMsSUFBSSxDQUFDN3JCLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3FTO29CQUM5QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3VTO29CQUM5QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7b0JBQzVCLElBQUksQ0FBQyt5QixPQUFPLENBQUN4cEMsVUFBVSxDQUFDMEYsQ0FBQyxDQUFDekIsR0FBRyxDQUFDaW9DO29CQUM5QixJQUFJLENBQUMxQyxPQUFPLENBQUN4cEMsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHcW1DO29CQUM1QixJQUFJLENBQUNoQyxPQUFPLENBQUNucUMsVUFBVSxDQUFDMEYsQ0FBQyxDQUFDekIsR0FBRyxDQUFDbW9DO29CQUM5QixJQUFJLENBQUNqQyxPQUFPLENBQUNucUMsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHNnJCO2dCQUNoQztnQkFFQXAyQixVQUFVeUYsU0FBUyxDQUFDZ2dCLHdCQUF3QixHQUFHLFNBQVM1VCxJQUFJO29CQUN4RCxJQUFJbUcsS0FBSyxJQUFJLENBQUN3TSxPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJaVAsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJaWEsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJbVAsS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJaXpDLEtBQUssSUFBSSxDQUFDakQsT0FBTyxDQUFDdnBDLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltbEMsS0FBSyxJQUFJLENBQUNGLE9BQU8sQ0FBQ3ZwQyxVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJa3pDLEtBQUssSUFBSSxDQUFDdkMsT0FBTyxDQUFDbHFDLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUk4bEMsS0FBSyxJQUFJLENBQUNGLE9BQU8sQ0FBQ2xxQyxVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOHRDLEtBQUsvc0MsSUFBSTZuQixHQUFHLENBQUM1TztvQkFDakIsSUFBSSt6QixLQUFLaHRDLElBQUk2bkIsR0FBRyxDQUFDMU87b0JBQ2pCLElBQUkyNEIsS0FBSzl4QyxJQUFJNm5CLEdBQUcsQ0FBQ3NuQjtvQkFDakIsSUFBSTRDLEtBQUsveEMsSUFBSTZuQixHQUFHLENBQUNpb0I7b0JBQ2pCLElBQUlzQyxjQUFjO29CQUNsQixRQUFRO29CQUNSLElBQUlyRCxhQUFhQztvQkFDakIsUUFBUTtvQkFDUixJQUFJcUQsTUFBTUM7b0JBQ1YsT0FBTztvQkFDUCxJQUFJQyxLQUFLQyxLQUFLQyxLQUFLQztvQkFDbkIsUUFBUTtvQkFDUixJQUFJeG1DLE9BQU87b0JBQ1gsUUFBUTtvQkFDUixJQUFJLElBQUksQ0FBQzJpQyxPQUFPLElBQUl4dEMsY0FBY3dwQyxJQUFJLEVBQUU7d0JBQ3BDd0gsT0FBTzF5QyxLQUFLc0QsSUFBSTt3QkFDaEJzdkMsTUFBTTt3QkFDTkUsTUFBTTt3QkFDTnZtQyxRQUFRLElBQUksQ0FBQzBrQyxJQUFJLEdBQUcsSUFBSSxDQUFDRSxJQUFJO3dCQUM3Qi9CLGNBQWM5MUIsS0FBS2syQixLQUFLLElBQUksQ0FBQ0csaUJBQWlCO29CQUNsRCxPQUFPO3dCQUNILElBQUl0d0MsSUFBSWdCLElBQUk0TyxPQUFPLENBQUNrakMsSUFBSSxJQUFJLENBQUN0QyxZQUFZO3dCQUN6QyxPQUFPO3dCQUNQLElBQUl3QyxLQUFLaHlDLElBQUkwb0MsTUFBTSxDQUFDb0osSUFBSSxJQUFJLENBQUN6QyxjQUFjLEVBQUUsSUFBSSxDQUFDaUIsS0FBSzt3QkFDdkQsT0FBTzt3QkFDUCxJQUFJcjhCLEtBQUtqVSxJQUFJMG9DLE1BQU0sQ0FBQ3FFLElBQUksSUFBSSxDQUFDNUIsY0FBYyxFQUFFLElBQUksQ0FBQ2lGLEtBQUs7d0JBQ3ZELE9BQU87d0JBQ1BpQyxPQUFPcnpDO3dCQUNQeXpDLE1BQU05eUMsS0FBS21MLEtBQUssQ0FBQ2tuQyxJQUFJaHpDO3dCQUNyQnV6QyxNQUFNNXlDLEtBQUttTCxLQUFLLENBQUNtSixJQUFJalY7d0JBQ3JCa04sUUFBUSxJQUFJLENBQUN3a0MsSUFBSSxHQUFHLElBQUksQ0FBQ0YsSUFBSSxHQUFHLElBQUksQ0FBQ00sSUFBSSxHQUFHMkIsTUFBTUEsTUFBTSxJQUFJLENBQUM3QixJQUFJLEdBQUcyQixNQUFNQTt3QkFDMUUsSUFBSTVDLEtBQUtod0MsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5a0MsY0FBYyxFQUFFLElBQUksQ0FBQ2lCLEtBQUs7d0JBQ2pELE9BQU87d0JBQ1AsSUFBSXBVLEtBQUtsOEIsSUFBSWdQLFFBQVEsQ0FBQzhpQyxJQUFJbnlDLEtBQUtrTCxHQUFHLENBQUNvSixJQUFJdFUsS0FBS2lMLEdBQUcsQ0FBQ29PLElBQUlrNUI7d0JBQ3BELE9BQU87d0JBQ1BuRCxjQUFjcHZDLEtBQUt5TCxHQUFHLENBQUN6TCxLQUFLaUwsR0FBRyxDQUFDc3hCLElBQUl5VCxLQUFLLElBQUksQ0FBQ0gsWUFBWTtvQkFDOUQ7b0JBQ0EsSUFBSSxJQUFJLENBQUNWLE9BQU8sSUFBSXp0QyxjQUFjd3BDLElBQUksRUFBRTt3QkFDcEN5SCxPQUFPM3lDLEtBQUtzRCxJQUFJO3dCQUNoQnV2QyxNQUFNLElBQUksQ0FBQzVELE9BQU87d0JBQ2xCOEQsTUFBTSxJQUFJLENBQUM5RCxPQUFPO3dCQUNsQjFpQyxRQUFRLElBQUksQ0FBQzBpQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLEdBQUksQ0FBQSxJQUFJLENBQUNpQyxJQUFJLEdBQUcsSUFBSSxDQUFDRSxJQUFJLEFBQUQ7d0JBQzNEL0IsY0FBYzcxQixLQUFLMjJCLEtBQUssSUFBSSxDQUFDRSxpQkFBaUI7b0JBQ2xELE9BQU87d0JBQ0gsSUFBSWh4QyxJQUFJZ0IsSUFBSTRPLE9BQU8sQ0FBQ21qQyxJQUFJLElBQUksQ0FBQzlCLFlBQVk7d0JBQ3pDLElBQUlnQyxLQUFLanlDLElBQUkwb0MsTUFBTSxDQUFDcUosSUFBSSxJQUFJLENBQUNoQyxjQUFjLEVBQUUsSUFBSSxDQUFDUSxLQUFLO3dCQUN2RCxJQUFJcjhCLEtBQUtsVSxJQUFJMG9DLE1BQU0sQ0FBQ3NFLElBQUksSUFBSSxDQUFDM0IsY0FBYyxFQUFFLElBQUksQ0FBQ2dGLEtBQUs7d0JBQ3ZEaUMsT0FBTzN5QyxLQUFLOE0sR0FBRyxDQUFDLElBQUksQ0FBQ21pQyxPQUFPLEVBQUU1dkM7d0JBQzlCMHpDLE1BQU0sSUFBSSxDQUFDOUQsT0FBTyxHQUFHanZDLEtBQUttTCxLQUFLLENBQUNtbkMsSUFBSWp6Qzt3QkFDcEN3ekMsTUFBTSxJQUFJLENBQUM1RCxPQUFPLEdBQUdqdkMsS0FBS21MLEtBQUssQ0FBQ29KLElBQUlsVjt3QkFDcENrTixRQUFRLElBQUksQ0FBQzBpQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLEdBQUksQ0FBQSxJQUFJLENBQUMrQixJQUFJLEdBQUcsSUFBSSxDQUFDRixJQUFJLEFBQUQsSUFBSyxJQUFJLENBQUNNLElBQUksR0FBRzJCLE1BQU1BLE1BQU0sSUFBSSxDQUFDN0IsSUFBSSxHQUFHMkIsTUFBTUE7d0JBQzFHLElBQUl0QyxLQUFLdndDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDbWxDLGNBQWMsRUFBRSxJQUFJLENBQUNRLEtBQUs7d0JBQ2pELE9BQU87d0JBQ1AsSUFBSXBVLEtBQUtuOEIsSUFBSWdQLFFBQVEsQ0FBQytpQyxJQUFJcHlDLEtBQUtrTCxHQUFHLENBQUNxSixJQUFJdlUsS0FBS2lMLEdBQUcsQ0FBQ3NPLElBQUlpNUI7d0JBQ3BELE9BQU87d0JBQ1BuRCxjQUFjcnZDLEtBQUt5TCxHQUFHLENBQUMrd0IsSUFBSSxJQUFJLENBQUM4VCxZQUFZLElBQUl0d0MsS0FBS3lMLEdBQUcsQ0FBQzhrQyxJQUFJLElBQUksQ0FBQ0QsWUFBWTtvQkFDbEY7b0JBQ0EsSUFBSXoxQixJQUFJdTBCLGNBQWMsSUFBSSxDQUFDSCxPQUFPLEdBQUdJLGNBQWMsSUFBSSxDQUFDbUIsVUFBVTtvQkFDbEUsUUFBUTtvQkFDUixJQUFJOWlDLFVBQVU7b0JBQ2QsUUFBUTtvQkFDUixJQUFJbkIsT0FBTyxHQUFHO3dCQUNWbUIsVUFBVSxDQUFDbU4sSUFBSXRPO29CQUNuQjtvQkFDQThNLEdBQUd4TSxNQUFNLENBQUMsSUFBSSxDQUFDZ2tDLElBQUksR0FBR25qQyxTQUFTZ2xDO29CQUMvQnA1QixNQUFNLElBQUksQ0FBQzIzQixJQUFJLEdBQUd2akMsVUFBVWtsQztvQkFDNUJyNUIsR0FBRzFNLE1BQU0sQ0FBQyxJQUFJLENBQUNpa0MsSUFBSSxHQUFHcGpDLFNBQVNpbEM7b0JBQy9CbjVCLE1BQU0sSUFBSSxDQUFDMDNCLElBQUksR0FBR3hqQyxVQUFVbWxDO29CQUM1Qk4sR0FBR2wzQixNQUFNLENBQUMsSUFBSSxDQUFDMDFCLElBQUksR0FBR3JqQyxTQUFTZ2xDO29CQUMvQmxELE1BQU0sSUFBSSxDQUFDMkIsSUFBSSxHQUFHempDLFVBQVVvbEM7b0JBQzVCTixHQUFHbjNCLE1BQU0sQ0FBQyxJQUFJLENBQUMyMUIsSUFBSSxHQUFHdGpDLFNBQVNpbEM7b0JBQy9CeEMsTUFBTSxJQUFJLENBQUNpQixJQUFJLEdBQUcxakMsVUFBVXFsQztvQkFDNUIsSUFBSSxDQUFDbHRCLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUMsQ0FBQ04sR0FBRyxDQUFDc1A7b0JBQzlCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR2dhO29CQUM1QixJQUFJLENBQUN3TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3dQO29CQUM5QixJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDLEdBQUdrYTtvQkFDNUIsSUFBSSxDQUFDODFCLE9BQU8sQ0FBQ3ZwQyxVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3dvQztvQkFDOUIsSUFBSSxDQUFDakQsT0FBTyxDQUFDdnBDLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR2t3QztvQkFDNUIsSUFBSSxDQUFDUyxPQUFPLENBQUNscUMsVUFBVSxDQUFDc0UsQ0FBQyxDQUFDTixHQUFHLENBQUN5b0M7b0JBQzlCLElBQUksQ0FBQ3ZDLE9BQU8sQ0FBQ2xxQyxVQUFVLENBQUN6RyxDQUFDLEdBQUc2d0M7b0JBQzVCLDRCQUE0QjtvQkFDNUIsT0FBT3NDLGNBQWNyd0MsU0FBU3VZLFVBQVU7Z0JBQzVDO1lBR0E7WUFBRTtnQkFBQyxZQUFXO2dCQUFFLGVBQWM7Z0JBQUUsbUJBQWtCO2dCQUFHLG1CQUFrQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGlCQUFnQjtnQkFBRyxtQkFBa0I7Z0JBQUcsdUJBQXNCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsc0JBQXFCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsbUJBQWtCO2dCQUFHLG9CQUFtQjtnQkFBRyxtQkFBa0I7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNwYixRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDcFksSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERoRSxRQUFPRCxPQUFPLEdBQUcrQztnQkFFakIsSUFBSW1CLFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJbUQsVUFBVW5ELFNBQVE7Z0JBRXRCLElBQUkwaUIsU0FBUzFpQixTQUFRO2dCQUVyQixJQUFJNkMsV0FBVzdDLFNBQVE7Z0JBRXZCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlVLE9BQU9WLFNBQVE7Z0JBRW5CLElBQUlXLFFBQVFYLFNBQVE7Z0JBRXBCLElBQUlZLFFBQVFaLFNBQVE7Z0JBRXBCLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCLElBQUl1QyxRQUFRdkMsU0FBUTtnQkFFcEIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSW9ELFdBQVdwRCxTQUFRO2dCQUV2QixJQUFJcUQsV0FBV3JELFNBQVE7Z0JBRXZCLElBQUlvQixRQUFRcEIsU0FBUTtnQkFFcEIrQixXQUFXNHBDLElBQUksR0FBRztnQkFFbEI1cEMsV0FBVzZwQyxNQUFNLEdBQUd4cUM7Z0JBRXBCVyxXQUFXd0YsU0FBUyxHQUFHbWIsT0FBTzNnQixXQUFXNnBDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUV6RDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELElBQUk2ZSxXQUFXO29CQUNYbW9CLFVBQVU7b0JBQ1ZDLFdBQVc7b0JBQ1hpRixrQkFBa0I7Z0JBQ3RCO2dCQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBUzF4QyxXQUFXOEMsR0FBRyxFQUFFa1AsS0FBSyxFQUFFRSxLQUFLO29CQUNqQyxJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVlsUyxVQUFTLEdBQUk7d0JBQy9CLE9BQU8sSUFBSUEsV0FBVzhDLEtBQUtrUCxPQUFPRTtvQkFDdEM7b0JBQ0FwUCxNQUFNMUIsUUFBUTBCLEtBQUt1aEI7b0JBQ25CaGxCLE1BQU1mLElBQUksQ0FBQyxJQUFJLEVBQUV3RSxLQUFLa1AsT0FBT0U7b0JBQzdCRixRQUFRLElBQUksQ0FBQ3VTLE9BQU87b0JBQ3BCclMsUUFBUSxJQUFJLENBQUNzUyxPQUFPO29CQUNwQixJQUFJLENBQUM3Z0IsTUFBTSxHQUFHM0QsV0FBVzRwQyxJQUFJO29CQUM3QixJQUFJLENBQUMrSCxjQUFjLEdBQUc3dUMsSUFBSTh1QyxZQUFZLEdBQUc5dUMsSUFBSTh1QyxZQUFZLEdBQUc1L0IsTUFBTWxFLGFBQWEsQ0FBQ29FLE1BQU1oSixXQUFXO29CQUNqRyxJQUFJMm9DLFNBQVM3L0IsTUFBTTVJLFFBQVE7b0JBQzNCLElBQUkwb0MsU0FBUzUvQixNQUFNOUksUUFBUTtvQkFDM0IsSUFBSSxDQUFDMm9DLGVBQWUsR0FBR0QsU0FBU0Q7b0JBQ2hDLElBQUksQ0FBQ2xGLGVBQWUsR0FBR2p1QyxLQUFLc0QsSUFBSTtvQkFDaEMsSUFBSSxDQUFDNHFDLGdCQUFnQixHQUFHO29CQUN4QixJQUFJLENBQUNDLFVBQVUsR0FBRy9wQyxJQUFJMHBDLFFBQVE7b0JBQzlCLElBQUksQ0FBQ00sV0FBVyxHQUFHaHFDLElBQUkycEMsU0FBUztvQkFDaEMsSUFBSSxDQUFDdUYsa0JBQWtCLEdBQUdsdkMsSUFBSTR1QyxnQkFBZ0I7b0JBQzlDLGNBQWM7b0JBQ2QsSUFBSSxDQUFDN0csSUFBSTtvQkFDVCxPQUFPO29CQUNQLElBQUksQ0FBQ0MsSUFBSTtvQkFDVCxPQUFPO29CQUNQLElBQUksQ0FBQ0MsY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLGNBQWM7b0JBQ25CLE9BQU87b0JBQ1AsSUFBSSxDQUFDaUgsYUFBYTtvQkFDbEIsT0FBTztvQkFDUCxJQUFJLENBQUNDLGNBQWM7b0JBQ25CLFFBQVE7b0JBQ1IsSUFBSSxDQUFDakgsVUFBVTtvQkFDZixRQUFRO29CQUNSLElBQUksQ0FBQ0MsVUFBVTtvQkFDZixRQUFRO29CQUNSLElBQUksQ0FBQ0MsT0FBTztvQkFDWixRQUFRO29CQUNSLElBQUksQ0FBQ0MsT0FBTztvQkFDWixRQUFRO29CQUNSLElBQUksQ0FBQzJCLFlBQVk7b0JBQ2pCLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxhQUFhO2dCQUN0QjtnQkFFQTs7Q0FFQyxHQUNEaHRDLFdBQVd3RixTQUFTLENBQUN5bkMsV0FBVyxHQUFHLFNBQVNwaEMsS0FBSztvQkFDN0M1SyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdEUsTUFBS3dFLFFBQVEsQ0FBQzRJLFVBQVVBLFNBQVM7b0JBQzFELElBQUksQ0FBQ2doQyxVQUFVLEdBQUdoaEM7Z0JBQ3RCO2dCQUVBOztDQUVDLEdBQ0Q3TCxXQUFXd0YsU0FBUyxDQUFDMG5DLFdBQVcsR0FBRztvQkFDL0IsT0FBTyxJQUFJLENBQUNMLFVBQVU7Z0JBQzFCO2dCQUVBOztDQUVDLEdBQ0Q3c0MsV0FBV3dGLFNBQVMsQ0FBQzJuQyxZQUFZLEdBQUcsU0FBU2poQyxNQUFNO29CQUMvQ2pMLFdBQVdFLFFBQU80QixNQUFNLENBQUN0RSxNQUFLd0UsUUFBUSxDQUFDaUosV0FBV0EsVUFBVTtvQkFDNUQsSUFBSSxDQUFDNGdDLFdBQVcsR0FBRzVnQztnQkFDdkI7Z0JBRUE7O0NBRUMsR0FDRGxNLFdBQVd3RixTQUFTLENBQUM0bkMsWUFBWSxHQUFHO29CQUNoQyxPQUFPLElBQUksQ0FBQ04sV0FBVztnQkFDM0I7Z0JBRUE7O0NBRUMsR0FDRDlzQyxXQUFXd0YsU0FBUyxDQUFDMnNDLG1CQUFtQixHQUFHLFNBQVNDLE1BQU07b0JBQ3REbnhDLFdBQVdFLFFBQU80QixNQUFNLENBQUN0RSxNQUFLd0UsUUFBUSxDQUFDbXZDLFdBQVcsS0FBS0EsVUFBVUEsVUFBVTtvQkFDM0UsSUFBSSxDQUFDSixrQkFBa0IsR0FBR0k7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0RweUMsV0FBV3dGLFNBQVMsQ0FBQzZzQyxtQkFBbUIsR0FBRztvQkFDdkMsT0FBTyxJQUFJLENBQUNMLGtCQUFrQjtnQkFDbEM7Z0JBRUE7O0NBRUMsR0FDRGh5QyxXQUFXd0YsU0FBUyxDQUFDOHNDLGVBQWUsR0FBRyxTQUFTVixZQUFZO29CQUN4RCxJQUFJQSxhQUFhM3pCLENBQUMsSUFBSSxJQUFJLENBQUMwekIsY0FBYyxDQUFDMXpCLENBQUMsSUFBSTJ6QixhQUFhenpCLENBQUMsSUFBSSxJQUFJLENBQUN3ekIsY0FBYyxDQUFDeHpCLENBQUMsRUFBRTt3QkFDcEYsSUFBSSxDQUFDb0csT0FBTyxDQUFDeGQsUUFBUSxDQUFDO3dCQUN0QixJQUFJLENBQUN5ZCxPQUFPLENBQUN6ZCxRQUFRLENBQUM7d0JBQ3RCLElBQUksQ0FBQzRxQyxjQUFjLEdBQUdDO29CQUMxQjtnQkFDSjtnQkFFQTV4QyxXQUFXd0YsU0FBUyxDQUFDK3NDLGVBQWUsR0FBRztvQkFDbkMsT0FBTyxJQUFJLENBQUNaLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0QzeEMsV0FBV3dGLFNBQVMsQ0FBQ2d0QyxnQkFBZ0IsR0FBRyxTQUFTQyxhQUFhO29CQUMxRCxJQUFJQSxpQkFBaUIsSUFBSSxDQUFDVixlQUFlLEVBQUU7d0JBQ3ZDLElBQUksQ0FBQ3h0QixPQUFPLENBQUN4ZCxRQUFRLENBQUM7d0JBQ3RCLElBQUksQ0FBQ3lkLE9BQU8sQ0FBQ3pkLFFBQVEsQ0FBQzt3QkFDdEIsSUFBSSxDQUFDZ3JDLGVBQWUsR0FBR1U7b0JBQzNCO2dCQUNKO2dCQUVBenlDLFdBQVd3RixTQUFTLENBQUNrdEMsZ0JBQWdCLEdBQUc7b0JBQ3BDLE9BQU8sSUFBSSxDQUFDWCxlQUFlO2dCQUMvQjtnQkFFQS94QyxXQUFXd0YsU0FBUyxDQUFDdWYsVUFBVSxHQUFHO29CQUM5QixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDcmIsV0FBVztnQkFDbkM7Z0JBRUFsSixXQUFXd0YsU0FBUyxDQUFDd2YsVUFBVSxHQUFHO29CQUM5QixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDdGIsV0FBVztnQkFDbkM7Z0JBRUFsSixXQUFXd0YsU0FBUyxDQUFDeWYsZ0JBQWdCLEdBQUcsU0FBU0MsTUFBTTtvQkFDbkQsT0FBT3htQixLQUFLOE0sR0FBRyxDQUFDMFosUUFBUSxJQUFJLENBQUN5bkIsZUFBZTtnQkFDaEQ7Z0JBRUEzc0MsV0FBV3dGLFNBQVMsQ0FBQzJmLGlCQUFpQixHQUFHLFNBQVNELE1BQU07b0JBQ3BELE9BQU9BLFNBQVMsSUFBSSxDQUFDMG5CLGdCQUFnQjtnQkFDekM7Z0JBRUE1c0MsV0FBV3dGLFNBQVMsQ0FBQzhmLHVCQUF1QixHQUFHLFNBQVMxVCxJQUFJO29CQUN4RCxJQUFJLENBQUNtNUIsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNqZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDeWhDLGNBQWMsR0FBRyxJQUFJLENBQUN4bUIsT0FBTyxDQUFDbGdCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3RELElBQUksQ0FBQzBoQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzFnQixTQUFTO29CQUN4QyxJQUFJLENBQUNxbkMsVUFBVSxHQUFHLElBQUksQ0FBQzFtQixPQUFPLENBQUMzZ0IsU0FBUztvQkFDeEMsSUFBSSxDQUFDc25DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDeGdCLE1BQU07b0JBQ2xDLElBQUksQ0FBQ3FuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUNsQyxJQUFJZ1UsS0FBSyxJQUFJLENBQUN3TSxPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJaVAsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOGMsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMk4sS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJbVAsS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJZ2QsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUl3aEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPLEtBQUsrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNuQyxxQ0FBcUM7b0JBQ3JDLElBQUksQ0FBQzJ5QixJQUFJLEdBQUc5ckMsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJcHRDLEtBQUtnN0IsR0FBRyxDQUFDLElBQUksQ0FBQ3FSLGNBQWM7b0JBQ3hELElBQUksQ0FBQ0QsSUFBSSxHQUFHL3JDLElBQUk0TyxPQUFPLENBQUNvK0IsSUFBSXJ0QyxLQUFLZzdCLEdBQUcsQ0FBQyxJQUFJLENBQUNzUixjQUFjO29CQUN4RCw4QkFBOEI7b0JBQzlCLGNBQWM7b0JBQ2QscUJBQXFCO29CQUNyQixTQUFTO29CQUNULHlFQUF5RTtvQkFDekUsb0VBQW9FO29CQUNwRSwwQ0FBMEM7b0JBQzFDLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsVUFBVTtvQkFDeEIsSUFBSXB6QixLQUFLLElBQUksQ0FBQ3F6QixVQUFVO29CQUN4QixJQUFJdHpCLEtBQUssSUFBSSxDQUFDdXpCLE9BQU87b0JBQ3JCLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsT0FBTztvQkFDckIsSUFBSXh4QixJQUFJLElBQUloYjtvQkFDWmdiLEVBQUUyQyxFQUFFLENBQUMwQixDQUFDLEdBQUd0RyxLQUFLRSxLQUFLRCxLQUFLLElBQUksQ0FBQ2l6QixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHLElBQUksQ0FBQzBzQixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHckcsS0FBSyxJQUFJLENBQUNnekIsSUFBSSxDQUFDM3NCLENBQUMsR0FBRyxJQUFJLENBQUMyc0IsSUFBSSxDQUFDM3NCLENBQUM7b0JBQ2xGdkUsRUFBRTJDLEVBQUUsQ0FBQzRCLENBQUMsR0FBRyxDQUFDdkcsS0FBSyxJQUFJLENBQUNpekIsSUFBSSxDQUFDNXNCLENBQUMsR0FBRyxJQUFJLENBQUM0c0IsSUFBSSxDQUFDMXNCLENBQUMsR0FBR3JHLEtBQUssSUFBSSxDQUFDZ3pCLElBQUksQ0FBQzdzQixDQUFDLEdBQUcsSUFBSSxDQUFDNnNCLElBQUksQ0FBQzNzQixDQUFDO29CQUN6RXZFLEVBQUU0QyxFQUFFLENBQUN5QixDQUFDLEdBQUdyRSxFQUFFMkMsRUFBRSxDQUFDNEIsQ0FBQztvQkFDZnZFLEVBQUU0QyxFQUFFLENBQUMyQixDQUFDLEdBQUd4RyxLQUFLRSxLQUFLRCxLQUFLLElBQUksQ0FBQ2l6QixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzRzQixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHbkcsS0FBSyxJQUFJLENBQUNnekIsSUFBSSxDQUFDN3NCLENBQUMsR0FBRyxJQUFJLENBQUM2c0IsSUFBSSxDQUFDN3NCLENBQUM7b0JBQ2xGLElBQUksQ0FBQzh1QixZQUFZLEdBQUduekIsRUFBRTZDLFVBQVU7b0JBQ2hDLElBQUksQ0FBQ3V3QixhQUFhLEdBQUdwMUIsS0FBS0U7b0JBQzFCLElBQUksSUFBSSxDQUFDazFCLGFBQWEsR0FBRyxHQUFHO3dCQUN4QixJQUFJLENBQUNBLGFBQWEsR0FBRyxJQUFJLElBQUksQ0FBQ0EsYUFBYTtvQkFDL0M7b0JBQ0EsSUFBSSxDQUFDaUYsYUFBYSxHQUFHdnpDLEtBQUtzRCxJQUFJO29CQUM5QixJQUFJLENBQUNpd0MsYUFBYSxDQUFDckosVUFBVSxDQUFDLEdBQUczd0IsSUFBSSxHQUFHLElBQUksQ0FBQzZ5QixJQUFJO29CQUNqRCxJQUFJLENBQUNtSCxhQUFhLENBQUNuSixVQUFVLENBQUMsR0FBRy93QixJQUFJLEdBQUcsSUFBSSxDQUFDOHlCLElBQUk7b0JBQ2pELElBQUksQ0FBQ29ILGFBQWEsQ0FBQ3RvQyxHQUFHLENBQUM1SyxJQUFJNE8sT0FBTyxDQUFDbStCLElBQUksSUFBSSxDQUFDNkYsY0FBYztvQkFDMUQsSUFBSSxDQUFDTyxjQUFjLEdBQUdoNkIsS0FBS0YsS0FBSyxJQUFJLENBQUMrNUIsZUFBZTtvQkFDcEQsSUFBSW5nQyxLQUFLZ0IsWUFBWSxFQUFFO3dCQUNuQixrREFBa0Q7d0JBQ2xELElBQUksQ0FBQys1QixlQUFlLENBQUNuaEMsR0FBRyxDQUFDb0csS0FBS2tCLE9BQU87d0JBQ3JDLElBQUksQ0FBQzg1QixnQkFBZ0IsSUFBSWg3QixLQUFLa0IsT0FBTzt3QkFDckMsSUFBSStHLElBQUluYixLQUFLa29CLEdBQUcsQ0FBQyxJQUFJLENBQUMrbEIsZUFBZSxDQUFDMXVCLENBQUMsRUFBRSxJQUFJLENBQUMwdUIsZUFBZSxDQUFDeHVCLENBQUM7d0JBQy9EckQsR0FBR2YsTUFBTSxDQUFDcEMsSUFBSWtDO3dCQUNka0IsTUFBTW5ELEtBQU1sWixDQUFBQSxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2doQyxJQUFJLEVBQUVoeEIsS0FBSyxJQUFJLENBQUMreUIsZ0JBQWdCLEFBQUQ7d0JBQzNENXhCLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBTXBaLENBQUFBLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRWp4QixLQUFLLElBQUksQ0FBQyt5QixnQkFBZ0IsQUFBRDtvQkFDL0QsT0FBTzt3QkFDSCxJQUFJLENBQUNELGVBQWUsQ0FBQy9sQyxPQUFPO3dCQUM1QixJQUFJLENBQUNnbUMsZ0JBQWdCLEdBQUc7b0JBQzVCO29CQUNBLElBQUksQ0FBQ3JvQixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLEdBQUc0UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLEdBQUc4UTtvQkFDNUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO2dCQUNoQztnQkFFQWpiLFdBQVd3RixTQUFTLENBQUMrZix3QkFBd0IsR0FBRyxTQUFTM1QsSUFBSTtvQkFDekQsSUFBSWtKLEtBQUssSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSTZRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSTBRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUkrUSxLQUFLLElBQUksQ0FBQ3VKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJcU4sS0FBSyxJQUFJLENBQUNzekIsVUFBVSxFQUFFcHpCLEtBQUssSUFBSSxDQUFDcXpCLFVBQVU7b0JBQzlDLElBQUl0ekIsS0FBSyxJQUFJLENBQUN1ekIsT0FBTyxFQUFFcnpCLEtBQUssSUFBSSxDQUFDc3pCLE9BQU87b0JBQ3hDLElBQUlsZixJQUFJdGEsS0FBSzRZLEVBQUU7b0JBQ2YsSUFBSW1vQixRQUFRL2dDLEtBQUtzVCxNQUFNO29CQUN2Qix5QkFBeUI7b0JBQ3pCO3dCQUNJLElBQUlxbkIsT0FBT3R4QixLQUFLRixLQUFLNDNCLFFBQVEsSUFBSSxDQUFDWCxrQkFBa0IsR0FBRyxJQUFJLENBQUNFLGNBQWM7d0JBQzFFLElBQUk5bEMsVUFBVSxDQUFDLElBQUksQ0FBQzRnQyxhQUFhLEdBQUdUO3dCQUNwQyxJQUFJYyxhQUFhLElBQUksQ0FBQ1QsZ0JBQWdCO3dCQUN0QyxJQUFJVSxhQUFhcGhCLElBQUksSUFBSSxDQUFDNGdCLFdBQVc7d0JBQ3JDLElBQUksQ0FBQ0YsZ0JBQWdCLEdBQUdudUMsTUFBSythLEtBQUssQ0FBQyxJQUFJLENBQUNvekIsZ0JBQWdCLEdBQUd4Z0MsU0FBUyxDQUFDa2hDLFlBQVlBO3dCQUNqRmxoQyxVQUFVLElBQUksQ0FBQ3dnQyxnQkFBZ0IsR0FBR1M7d0JBQ2xDdHlCLE1BQU1uRCxLQUFLeEw7d0JBQ1g2TyxNQUFNbkQsS0FBSzFMO29CQUNmO29CQUNBLHdCQUF3QjtvQkFDeEI7d0JBQ0ksSUFBSW1nQyxPQUFPN3RDLEtBQUtzRCxJQUFJO3dCQUNwQnVxQyxLQUFLM0QsVUFBVSxDQUFDLEdBQUc1dEIsSUFBSSxHQUFHdGMsS0FBS21MLEtBQUssQ0FBQ29SLElBQUksSUFBSSxDQUFDNnZCLElBQUk7d0JBQ2xEeUIsS0FBS3pELFVBQVUsQ0FBQyxHQUFHaHVCLElBQUksR0FBR3BjLEtBQUttTCxLQUFLLENBQUNrUixJQUFJLElBQUksQ0FBQzh2QixJQUFJO3dCQUNsRDBCLEtBQUtoaEMsTUFBTSxDQUFDb25DLFFBQVEsSUFBSSxDQUFDWCxrQkFBa0IsRUFBRSxJQUFJLENBQUNDLGFBQWE7d0JBQy9ELElBQUk3bEMsVUFBVTFOLEtBQUtnN0IsR0FBRyxDQUFDOTZCLE1BQU0rTyxPQUFPLENBQUMsSUFBSSxDQUFDby9CLFlBQVksRUFBRVI7d0JBQ3hELElBQUljLGFBQWEzdUMsS0FBS3lGLEtBQUssQ0FBQyxJQUFJLENBQUN3b0MsZUFBZTt3QkFDaEQsSUFBSSxDQUFDQSxlQUFlLENBQUMvaUMsR0FBRyxDQUFDd0M7d0JBQ3pCLElBQUlraEMsYUFBYXBoQixJQUFJLElBQUksQ0FBQzJnQixVQUFVO3dCQUNwQyxJQUFJLENBQUNGLGVBQWUsQ0FBQ256QixLQUFLLENBQUM4ekI7d0JBQzNCbGhDLFVBQVUxTixLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ2dqQyxlQUFlLEVBQUVVO3dCQUN6Q3Z5QixHQUFHZixNQUFNLENBQUNwQyxJQUFJdkw7d0JBQ2QyTyxNQUFNbkQsS0FBS2xaLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRXorQjt3QkFDakM0TyxHQUFHelAsTUFBTSxDQUFDc00sSUFBSXpMO3dCQUNkNk8sTUFBTW5ELEtBQUtwWixLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUUxK0I7b0JBQ3JDO29CQUNBLElBQUksQ0FBQ21ZLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzRRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzhRO29CQUM1QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBamIsV0FBV3dGLFNBQVMsQ0FBQ2dnQix3QkFBd0IsR0FBRyxTQUFTNVQsSUFBSTtvQkFDekQsT0FBTztnQkFDWDtZQUdBO1lBQUU7Z0JBQUMsWUFBVztnQkFBRSxlQUFjO2dCQUFFLG1CQUFrQjtnQkFBRyxtQkFBa0I7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsbUJBQWtCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLG1CQUFrQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBUzNULFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN6VixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR2dEO2dCQUVqQixJQUFJa0IsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUltRCxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUlVLE9BQU9WLFNBQVE7Z0JBRW5CLElBQUlXLFFBQVFYLFNBQVE7Z0JBRXBCLElBQUlZLFFBQVFaLFNBQVE7Z0JBRXBCLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCLElBQUl1QyxRQUFRdkMsU0FBUTtnQkFFcEIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSW9ELFdBQVdwRCxTQUFRO2dCQUV2QixJQUFJcUQsV0FBV3JELFNBQVE7Z0JBRXZCLElBQUlvQixRQUFRcEIsU0FBUTtnQkFFcEJnQyxXQUFXMnBDLElBQUksR0FBRztnQkFFbEIzcEMsV0FBVzRwQyxNQUFNLEdBQUd4cUM7Z0JBRXBCWSxXQUFXdUYsU0FBUyxHQUFHbWIsT0FBTzFnQixXQUFXNHBDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUV6RDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJNmUsV0FBVztvQkFDWG1vQixVQUFVO29CQUNWMUMsYUFBYTtvQkFDYkMsY0FBYztnQkFDbEI7Z0JBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBUzlwQyxXQUFXNkMsR0FBRyxFQUFFa1AsS0FBSyxFQUFFRSxLQUFLLEVBQUVrd0IsTUFBTTtvQkFDekMsSUFBSSxDQUFFLENBQUEsSUFBSSxZQUFZbmlDLFVBQVMsR0FBSTt3QkFDL0IsT0FBTyxJQUFJQSxXQUFXNkMsS0FBS2tQLE9BQU9FLE9BQU9rd0I7b0JBQzdDO29CQUNBdC9CLE1BQU0xQixRQUFRMEIsS0FBS3VoQjtvQkFDbkJobEIsTUFBTWYsSUFBSSxDQUFDLElBQUksRUFBRXdFLEtBQUtrUCxPQUFPRTtvQkFDN0JGLFFBQVEsSUFBSSxDQUFDdVMsT0FBTztvQkFDcEJyUyxRQUFRLElBQUksQ0FBQ3NTLE9BQU87b0JBQ3BCLElBQUksQ0FBQzdnQixNQUFNLEdBQUcxRCxXQUFXMnBDLElBQUk7b0JBQzdCM29DLFdBQVdFLFFBQU80QixNQUFNLENBQUN0RSxNQUFLd0UsUUFBUSxDQUFDSCxJQUFJMHBDLFFBQVEsS0FBSzFwQyxJQUFJMHBDLFFBQVEsSUFBSTtvQkFDeEV2ckMsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3RFLE1BQUt3RSxRQUFRLENBQUNILElBQUlnbkMsV0FBVyxLQUFLaG5DLElBQUlnbkMsV0FBVyxJQUFJO29CQUM5RTdvQyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdEUsTUFBS3dFLFFBQVEsQ0FBQ0gsSUFBSWluQyxZQUFZLEtBQUtqbkMsSUFBSWluQyxZQUFZLElBQUk7b0JBQ2hGLElBQUksQ0FBQzZJLFNBQVMsR0FBR3hRLFNBQVMxakMsS0FBS3lGLEtBQUssQ0FBQ2krQixVQUFVdC9CLElBQUlzL0IsTUFBTSxJQUFJMWpDLEtBQUtzRCxJQUFJO29CQUN0RSxJQUFJLENBQUNvb0MsY0FBYyxHQUFHdHJDLFVBQVVpUCxRQUFRLENBQUNtRSxNQUFNMUosWUFBWSxJQUFJLElBQUksQ0FBQ29xQyxTQUFTO29CQUM3RSxJQUFJLENBQUMvRixVQUFVLEdBQUcvcEMsSUFBSTBwQyxRQUFRO29CQUM5QixJQUFJLENBQUMvQixTQUFTLEdBQUcvckMsS0FBS3NELElBQUk7b0JBQzFCLElBQUksQ0FBQ3VvQyxhQUFhLEdBQUd6bkMsSUFBSWduQyxXQUFXO29CQUNwQyxJQUFJLENBQUNVLGNBQWMsR0FBRzFuQyxJQUFJaW5DLFlBQVk7b0JBQ3RDLElBQUksQ0FBQzhJLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNuSSxPQUFPLEdBQUc7b0JBQ2YsY0FBYztvQkFDZCxJQUFJLENBQUNJLElBQUksR0FBR3BzQyxLQUFLc0QsSUFBSTtvQkFDckIsSUFBSSxDQUFDZ3BDLGNBQWMsR0FBR3RzQyxLQUFLc0QsSUFBSTtvQkFDL0IsSUFBSSxDQUFDa3BDLFVBQVUsR0FBRztvQkFDbEIsSUFBSSxDQUFDRSxPQUFPLEdBQUc7b0JBQ2YsSUFBSSxDQUFDbmdDLElBQUksR0FBRyxJQUFJck07b0JBQ2hCLElBQUksQ0FBQ2swQyxHQUFHLEdBQUdwMEMsS0FBS3NELElBQUk7Z0JBQ3hCO2dCQUVBOztDQUVDLEdBQ0QvQixXQUFXdUYsU0FBUyxDQUFDdXRDLFNBQVMsR0FBRyxTQUFTM1EsTUFBTTtvQkFDNUMsSUFBSSxJQUFJLENBQUM1ZCxPQUFPLENBQUN2YyxPQUFPLE1BQU0sT0FBTzt3QkFDakMsSUFBSSxDQUFDdWMsT0FBTyxDQUFDemQsUUFBUSxDQUFDO29CQUMxQjtvQkFDQSxJQUFJLENBQUM2ckMsU0FBUyxHQUFHbDBDLEtBQUt5RixLQUFLLENBQUNpK0I7Z0JBQ2hDO2dCQUVBbmlDLFdBQVd1RixTQUFTLENBQUN3dEMsU0FBUyxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQ0osU0FBUztnQkFDekI7Z0JBRUE7O0NBRUMsR0FDRDN5QyxXQUFXdUYsU0FBUyxDQUFDeW5DLFdBQVcsR0FBRyxTQUFTcGhDLEtBQUs7b0JBQzdDLElBQUksQ0FBQ2doQyxVQUFVLEdBQUdoaEM7Z0JBQ3RCO2dCQUVBNUwsV0FBV2l0QyxXQUFXLEdBQUc7b0JBQ3JCLE9BQU8sSUFBSSxDQUFDTCxVQUFVO2dCQUMxQjtnQkFFQTs7Q0FFQyxHQUNENXNDLFdBQVd1RixTQUFTLENBQUNpbUMsWUFBWSxHQUFHLFNBQVNDLEVBQUU7b0JBQzNDLElBQUksQ0FBQ25CLGFBQWEsR0FBR21CO2dCQUN6QjtnQkFFQXpyQyxXQUFXdUYsU0FBUyxDQUFDbW1DLFlBQVksR0FBRztvQkFDaEMsT0FBTyxJQUFJLENBQUNwQixhQUFhO2dCQUM3QjtnQkFFQTs7Q0FFQyxHQUNEdHFDLFdBQVd1RixTQUFTLENBQUNvbUMsZUFBZSxHQUFHLFNBQVN2ZixLQUFLO29CQUNqRCxJQUFJLENBQUNtZSxjQUFjLEdBQUduZTtnQkFDMUI7Z0JBRUFwc0IsV0FBV3VGLFNBQVMsQ0FBQ3FtQyxlQUFlLEdBQUc7b0JBQ25DLE9BQU8sSUFBSSxDQUFDckIsY0FBYztnQkFDOUI7Z0JBRUF2cUMsV0FBV3VGLFNBQVMsQ0FBQ3VmLFVBQVUsR0FBRztvQkFDOUIsT0FBT3JtQixLQUFLeUYsS0FBSyxDQUFDLElBQUksQ0FBQ3l1QyxTQUFTO2dCQUNwQztnQkFFQTN5QyxXQUFXdUYsU0FBUyxDQUFDd2YsVUFBVSxHQUFHO29CQUM5QixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDeGEsYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO2dCQUN6RDtnQkFFQW5xQyxXQUFXdUYsU0FBUyxDQUFDeWYsZ0JBQWdCLEdBQUcsU0FBU0MsTUFBTTtvQkFDbkQsT0FBT3htQixLQUFLOE0sR0FBRyxDQUFDMFosUUFBUSxJQUFJLENBQUN1bEIsU0FBUztnQkFDMUM7Z0JBRUF4cUMsV0FBV3VGLFNBQVMsQ0FBQzJmLGlCQUFpQixHQUFHLFNBQVNELE1BQU07b0JBQ3BELE9BQU9BLFNBQVM7Z0JBQ3BCO2dCQUVBamxCLFdBQVd1RixTQUFTLENBQUM0ZixXQUFXLEdBQUcsU0FBU0MsU0FBUztvQkFDakQsSUFBSSxDQUFDdXRCLFNBQVMsQ0FBQ2pwQyxHQUFHLENBQUMwYjtnQkFDdkI7Z0JBRUFwbEIsV0FBV3VGLFNBQVMsQ0FBQzhmLHVCQUF1QixHQUFHLFNBQVMxVCxJQUFJO29CQUN4RCxJQUFJLENBQUNvNUIsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNsZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDMmhDLFVBQVUsR0FBRyxJQUFJLENBQUMxbUIsT0FBTyxDQUFDM2dCLFNBQVM7b0JBQ3hDLElBQUksQ0FBQ3VuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUNsQyxJQUFJaEMsV0FBVyxJQUFJLENBQUN5aUIsT0FBTyxDQUFDL2YsVUFBVTtvQkFDdEMsSUFBSXd1QyxXQUFXLElBQUksQ0FBQ3p1QixPQUFPLENBQUNoZ0IsVUFBVTtvQkFDdEMsSUFBSXlULEtBQUtsVyxTQUFTZ0gsQ0FBQztvQkFDbkIsSUFBSW1QLEtBQUtuVyxTQUFTL0QsQ0FBQztvQkFDbkIsSUFBSWdkLEtBQUtpNEIsU0FBUy9vQyxDQUFDO29CQUNuQixJQUFJK1EsS0FBS2c0QixTQUFTM29DLENBQUM7b0JBQ25CLElBQUl5aEMsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixJQUFJak4sT0FBTyxJQUFJLENBQUN1WixPQUFPLENBQUMxWixPQUFPO29CQUMvQixZQUFZO29CQUNaLElBQUlxaEMsUUFBUSxJQUFJMXRDLE1BQUs4cEIsRUFBRSxHQUFHLElBQUksQ0FBQ2dpQixhQUFhO29CQUM1QyxzQkFBc0I7b0JBQ3RCLElBQUk1VixJQUFJLElBQUkxcEIsT0FBTyxJQUFJLENBQUN1L0IsY0FBYyxHQUFHMkI7b0JBQ3pDLG1CQUFtQjtvQkFDbkIsSUFBSUMsSUFBSW5oQyxPQUFRa2hDLENBQUFBLFFBQVFBLEtBQUk7b0JBQzVCLGlCQUFpQjtvQkFDakIsbUNBQW1DO29CQUNuQyxrQ0FBa0M7b0JBQ2xDLElBQUlqZ0IsSUFBSXRhLEtBQUs0WSxFQUFFO29CQUNmdnBCLFdBQVdFLFFBQU80QixNQUFNLENBQUM0eEIsSUFBSXpJLElBQUlrZ0IsSUFBSTN0QyxNQUFLc29CLE9BQU87b0JBQ2pELElBQUksQ0FBQzJqQixPQUFPLEdBQUd4ZSxJQUFLeUksQ0FBQUEsSUFBSXpJLElBQUlrZ0IsQ0FBQUE7b0JBQzVCLElBQUksSUFBSSxDQUFDMUIsT0FBTyxJQUFJLEdBQUc7d0JBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDQSxPQUFPO29CQUNuQztvQkFDQSxJQUFJLENBQUNtSSxNQUFNLEdBQUczbUIsSUFBSWtnQixJQUFJLElBQUksQ0FBQzFCLE9BQU87b0JBQ2xDLHFDQUFxQztvQkFDckMsSUFBSSxDQUFDSSxJQUFJLEdBQUcvckMsSUFBSTRPLE9BQU8sQ0FBQ28rQixJQUFJcnRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDeWdDLGNBQWMsRUFBRSxJQUFJLENBQUNZLGNBQWM7b0JBQzdFLHlFQUF5RTtvQkFDekUsb0JBQW9CO29CQUNwQix5RUFBeUU7b0JBQ3pFLGNBQWM7b0JBQ2QsK0RBQStEO29CQUMvRCxJQUFJcHhCLElBQUksSUFBSWhiO29CQUNaZ2IsRUFBRTJDLEVBQUUsQ0FBQzBCLENBQUMsR0FBRyxJQUFJLENBQUNpdEIsVUFBVSxHQUFHLElBQUksQ0FBQ0UsT0FBTyxHQUFHLElBQUksQ0FBQ04sSUFBSSxDQUFDM3NCLENBQUMsR0FBRyxJQUFJLENBQUMyc0IsSUFBSSxDQUFDM3NCLENBQUMsR0FBRyxJQUFJLENBQUN1c0IsT0FBTztvQkFDbEY5d0IsRUFBRTJDLEVBQUUsQ0FBQzRCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQ2l0QixPQUFPLEdBQUcsSUFBSSxDQUFDTixJQUFJLENBQUM3c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzZzQixJQUFJLENBQUMzc0IsQ0FBQztvQkFDbER2RSxFQUFFNEMsRUFBRSxDQUFDeUIsQ0FBQyxHQUFHckUsRUFBRTJDLEVBQUUsQ0FBQzRCLENBQUM7b0JBQ2Z2RSxFQUFFNEMsRUFBRSxDQUFDMkIsQ0FBQyxHQUFHLElBQUksQ0FBQytzQixVQUFVLEdBQUcsSUFBSSxDQUFDRSxPQUFPLEdBQUcsSUFBSSxDQUFDTixJQUFJLENBQUM3c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzZzQixJQUFJLENBQUM3c0IsQ0FBQyxHQUFHLElBQUksQ0FBQ3lzQixPQUFPO29CQUNsRixJQUFJLENBQUM5bUMsTUFBTSxHQUFHZ1csRUFBRTZDLFVBQVU7b0JBQzFCLElBQUksQ0FBQ3EyQixHQUFHLENBQUNycUMsR0FBRyxDQUFDd1A7b0JBQ2IsSUFBSSxDQUFDNjZCLEdBQUcsQ0FBQ2xLLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQ2tDLElBQUksRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDOEgsU0FBUztvQkFDcEQsSUFBSSxDQUFDRSxHQUFHLENBQUN0bkMsR0FBRyxDQUFDLElBQUksQ0FBQ3FuQyxNQUFNO29CQUN4QiwwQkFBMEI7b0JBQzFCNTNCLE1BQU07b0JBQ04sSUFBSXJKLEtBQUtnQixZQUFZLEVBQUU7d0JBQ25CLElBQUksQ0FBQzYzQixTQUFTLENBQUNqL0IsR0FBRyxDQUFDb0csS0FBS2tCLE9BQU87d0JBQy9Ca0ksR0FBR3pQLE1BQU0sQ0FBQyxJQUFJLENBQUMyL0IsVUFBVSxFQUFFLElBQUksQ0FBQ1QsU0FBUzt3QkFDekN4dkIsTUFBTSxJQUFJLENBQUNtd0IsT0FBTyxHQUFHMXNDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRSxJQUFJLENBQUNMLFNBQVM7b0JBQzdELE9BQU87d0JBQ0gsSUFBSSxDQUFDQSxTQUFTLENBQUM3akMsT0FBTztvQkFDMUI7b0JBQ0Fxc0MsU0FBUy9vQyxDQUFDLENBQUN6QixHQUFHLENBQUN1UztvQkFDZmk0QixTQUFTM29DLENBQUMsR0FBRzJRO2dCQUNqQjtnQkFFQWhiLFdBQVd1RixTQUFTLENBQUMrZix3QkFBd0IsR0FBRyxTQUFTM1QsSUFBSTtvQkFDekQsSUFBSXFoQyxXQUFXLElBQUksQ0FBQ3p1QixPQUFPLENBQUNoZ0IsVUFBVTtvQkFDdEMsSUFBSXdXLEtBQUt0YyxLQUFLeUYsS0FBSyxDQUFDOHVDLFNBQVMvb0MsQ0FBQztvQkFDOUIsSUFBSStRLEtBQUtnNEIsU0FBUzNvQyxDQUFDO29CQUNuQix5QkFBeUI7b0JBQ3pCLElBQUlpaUMsT0FBTzd0QyxLQUFLbUwsS0FBSyxDQUFDb1IsSUFBSSxJQUFJLENBQUM2dkIsSUFBSTtvQkFDbkN5QixLQUFLM2lDLEdBQUcsQ0FBQ29SO29CQUNUdXhCLEtBQUszRCxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUNrSyxHQUFHLEVBQUUsSUFBSSxDQUFDcEksT0FBTyxFQUFFLElBQUksQ0FBQ0QsU0FBUztvQkFDekQ4QixLQUFLN1MsR0FBRztvQkFDUixJQUFJdHRCLFVBQVV4TixNQUFNK08sT0FBTyxDQUFDLElBQUksQ0FBQy9KLE1BQU0sRUFBRTJvQztvQkFDekMsSUFBSWMsYUFBYTN1QyxLQUFLeUYsS0FBSyxDQUFDLElBQUksQ0FBQ3NtQyxTQUFTO29CQUMxQyxJQUFJLENBQUNBLFNBQVMsQ0FBQzdnQyxHQUFHLENBQUN3QztvQkFDbkIsSUFBSWtoQyxhQUFhMTdCLEtBQUs0WSxFQUFFLEdBQUcsSUFBSSxDQUFDcWlCLFVBQVU7b0JBQzFDLElBQUksQ0FBQ3BDLFNBQVMsQ0FBQ2p4QixLQUFLLENBQUM4ekI7b0JBQ3JCbGhDLFVBQVUxTixLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQzhnQyxTQUFTLEVBQUU0QztvQkFDbkNyeUIsR0FBR3pQLE1BQU0sQ0FBQyxJQUFJLENBQUMyL0IsVUFBVSxFQUFFOStCO29CQUMzQjZPLE1BQU0sSUFBSSxDQUFDbXdCLE9BQU8sR0FBRzFzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUUxK0I7b0JBQzNDNm1DLFNBQVMvb0MsQ0FBQyxDQUFDekIsR0FBRyxDQUFDdVM7b0JBQ2ZpNEIsU0FBUzNvQyxDQUFDLEdBQUcyUTtnQkFDakI7Z0JBRUFoYixXQUFXdUYsU0FBUyxDQUFDZ2dCLHdCQUF3QixHQUFHLFNBQVM1VCxJQUFJO29CQUN6RCxPQUFPO2dCQUNYO1lBR0E7WUFBRTtnQkFBQyxZQUFXO2dCQUFFLG1CQUFrQjtnQkFBRyxtQkFBa0I7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsbUJBQWtCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLG1CQUFrQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBUzNULFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN6VSxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR2lEO2dCQUVqQixJQUFJaUIsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUltRCxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSVUsT0FBT1YsU0FBUTtnQkFFbkIsSUFBSVcsUUFBUVgsU0FBUTtnQkFFcEIsSUFBSVksUUFBUVosU0FBUTtnQkFFcEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSXVDLFFBQVF2QyxTQUFRO2dCQUVwQixJQUFJYSxZQUFZYixTQUFRO2dCQUV4QixJQUFJb0QsV0FBV3BELFNBQVE7Z0JBRXZCLElBQUlxRCxXQUFXckQsU0FBUTtnQkFFdkIsSUFBSW9CLFFBQVFwQixTQUFRO2dCQUVwQixJQUFJaTFDLGdCQUFnQjtnQkFFcEIsSUFBSUMsZUFBZTtnQkFFbkIsSUFBSUMsZUFBZTtnQkFFbkIsSUFBSUMsY0FBYztnQkFFbEJuekMsZUFBZTBwQyxJQUFJLEdBQUc7Z0JBRXRCMXBDLGVBQWUycEMsTUFBTSxHQUFHeHFDO2dCQUV4QmEsZUFBZXNGLFNBQVMsR0FBR21iLE9BQU96Z0IsZUFBZTJwQyxNQUFNLENBQUNya0MsU0FBUztnQkFFakU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNELElBQUk2ZSxXQUFXO29CQUNYaXZCLGFBQWE7b0JBQ2JDLGtCQUFrQjtvQkFDbEJDLGtCQUFrQjtvQkFDbEJDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLFlBQVk7Z0JBQ2hCO2dCQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVN6ekMsZUFBZTRDLEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFdzZCLE1BQU0sRUFBRWtILElBQUk7b0JBQ25ELElBQUksQ0FBRSxDQUFBLElBQUksWUFBWTF6QyxjQUFhLEdBQUk7d0JBQ25DLE9BQU8sSUFBSUEsZUFBZTRDLEtBQUtrUCxPQUFPRSxPQUFPdzZCLFFBQVFrSDtvQkFDekQ7b0JBQ0E5d0MsTUFBTTFCLFFBQVEwQixLQUFLdWhCO29CQUNuQmhsQixNQUFNZixJQUFJLENBQUMsSUFBSSxFQUFFd0UsS0FBS2tQLE9BQU9FO29CQUM3QkYsUUFBUSxJQUFJLENBQUN1UyxPQUFPO29CQUNwQnJTLFFBQVEsSUFBSSxDQUFDc1MsT0FBTztvQkFDcEIsSUFBSSxDQUFDN2dCLE1BQU0sR0FBR3pELGVBQWUwcEMsSUFBSTtvQkFDakMsSUFBSSxDQUFDTSxjQUFjLEdBQUd3QyxTQUFTMTZCLE1BQU1sRSxhQUFhLENBQUM0K0IsVUFBVTVwQyxJQUFJcW5DLFlBQVksSUFBSXpyQyxLQUFLc0QsSUFBSTtvQkFDMUYsSUFBSSxDQUFDb29DLGNBQWMsR0FBR3NDLFNBQVN4NkIsTUFBTXBFLGFBQWEsQ0FBQzQrQixVQUFVNXBDLElBQUl1bkMsWUFBWSxJQUFJM3JDLEtBQUtzRCxJQUFJO29CQUMxRixJQUFJLENBQUN5c0MsYUFBYSxHQUFHbUYsT0FBTzVoQyxNQUFNaEUsY0FBYyxDQUFDNGxDLFFBQVE5d0MsSUFBSSt3QyxVQUFVLElBQUluMUMsS0FBS2tvQixHQUFHLENBQUMsR0FBRztvQkFDdkYsSUFBSSxDQUFDNm5CLGFBQWEsQ0FBQzcxQixTQUFTO29CQUM1QixJQUFJLENBQUNrN0IsYUFBYSxHQUFHcDFDLEtBQUttTCxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM0a0MsYUFBYTtvQkFDckQsSUFBSSxDQUFDSCxnQkFBZ0IsR0FBRzd2QyxNQUFLd0UsUUFBUSxDQUFDSCxJQUFJaXhDLGNBQWMsSUFBSWp4QyxJQUFJaXhDLGNBQWMsR0FBRzdoQyxNQUFNOUksUUFBUSxLQUFLNEksTUFBTTVJLFFBQVE7b0JBQ2xILElBQUksQ0FBQ3FoQyxTQUFTLEdBQUc5ckM7b0JBQ2pCLElBQUksQ0FBQ3ExQyxXQUFXLEdBQUc7b0JBQ25CLElBQUksQ0FBQ0MsY0FBYyxHQUFHO29CQUN0QixJQUFJLENBQUNDLGtCQUFrQixHQUFHcHhDLElBQUl5d0MsZ0JBQWdCO29CQUM5QyxJQUFJLENBQUNZLGtCQUFrQixHQUFHcnhDLElBQUkwd0MsZ0JBQWdCO29CQUM5QyxJQUFJLENBQUNZLGVBQWUsR0FBR3R4QyxJQUFJNHdDLGFBQWE7b0JBQ3hDLElBQUksQ0FBQ1csWUFBWSxHQUFHdnhDLElBQUk2d0MsVUFBVTtvQkFDbEMsSUFBSSxDQUFDVyxhQUFhLEdBQUd4eEMsSUFBSXd3QyxXQUFXO29CQUNwQyxJQUFJLENBQUNpQixhQUFhLEdBQUd6eEMsSUFBSTJ3QyxXQUFXO29CQUNwQyxJQUFJLENBQUNlLFlBQVksR0FBR3RCO29CQUNwQixJQUFJLENBQUNsUCxNQUFNLEdBQUd0bEMsS0FBS3NELElBQUk7b0JBQ3ZCLElBQUksQ0FBQ3l5QyxNQUFNLEdBQUcvMUMsS0FBS3NELElBQUk7b0JBQ3ZCLGNBQWM7b0JBQ2QsSUFBSSxDQUFDK29DLGNBQWM7b0JBQ25CLE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxjQUFjO29CQUNuQixPQUFPO29CQUNQLElBQUksQ0FBQ0MsVUFBVTtvQkFDZixRQUFRO29CQUNSLElBQUksQ0FBQ0MsVUFBVTtvQkFDZixRQUFRO29CQUNSLElBQUksQ0FBQ0MsT0FBTztvQkFDWixRQUFRO29CQUNSLElBQUksQ0FBQ0MsT0FBTztvQkFDWixRQUFRO29CQUNSLElBQUksQ0FBQ3BILE1BQU0sRUFBRSxJQUFJLENBQUN5USxNQUFNO29CQUN4QixPQUFPO29CQUNQLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQ0MsSUFBSTtvQkFDcEIsUUFBUTtvQkFDUixJQUFJLENBQUNDLElBQUksRUFBRSxJQUFJLENBQUNDLElBQUk7b0JBQ3BCLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxHQUFHLEdBQUcsSUFBSWoyQztvQkFDZixJQUFJLENBQUNtMUMsV0FBVztnQkFDcEI7Z0JBRUE7O0NBRUMsR0FDRDl6QyxlQUFlc0YsU0FBUyxDQUFDNmxDLGVBQWUsR0FBRztvQkFDdkMsT0FBTyxJQUFJLENBQUNuQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEaHFDLGVBQWVzRixTQUFTLENBQUM4bEMsZUFBZSxHQUFHO29CQUN2QyxPQUFPLElBQUksQ0FBQ2xCLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0RscUMsZUFBZXNGLFNBQVMsQ0FBQ3V2QyxhQUFhLEdBQUc7b0JBQ3JDLE9BQU8sSUFBSSxDQUFDdEcsYUFBYTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRHZ1QyxlQUFlc0YsU0FBUyxDQUFDd3ZDLGlCQUFpQixHQUFHO29CQUN6QyxPQUFPLElBQUksQ0FBQzFHLGdCQUFnQjtnQkFDaEM7Z0JBRUE7O0NBRUMsR0FDRHB1QyxlQUFlc0YsU0FBUyxDQUFDeXZDLG1CQUFtQixHQUFHO29CQUMzQyxJQUFJaGEsS0FBSyxJQUFJLENBQUMxVyxPQUFPLENBQUN2YSxhQUFhLENBQUMsSUFBSSxDQUFDa2dDLGNBQWM7b0JBQ3ZELElBQUloUCxLQUFLLElBQUksQ0FBQzFXLE9BQU8sQ0FBQ3hhLGFBQWEsQ0FBQyxJQUFJLENBQUNvZ0MsY0FBYztvQkFDdkQsSUFBSXpWLElBQUlqMkIsS0FBS2lMLEdBQUcsQ0FBQ3V4QixJQUFJRDtvQkFDckIsSUFBSTJZLE9BQU8sSUFBSSxDQUFDcnZCLE9BQU8sQ0FBQzNXLGNBQWMsQ0FBQyxJQUFJLENBQUM2Z0MsYUFBYTtvQkFDekQsSUFBSXJpQixjQUFjMXRCLEtBQUt5TCxHQUFHLENBQUN3cUIsR0FBR2lmO29CQUM5QixPQUFPeG5CO2dCQUNYO2dCQUVBOztDQUVDLEdBQ0Rsc0IsZUFBZXNGLFNBQVMsQ0FBQzB2QyxhQUFhLEdBQUc7b0JBQ3JDLElBQUkxbkIsS0FBSyxJQUFJLENBQUNqSixPQUFPO29CQUNyQixJQUFJa0osS0FBSyxJQUFJLENBQUNqSixPQUFPO29CQUNyQixJQUFJeFIsS0FBS2pVLElBQUk0TyxPQUFPLENBQUM2ZixHQUFHeHBCLElBQUksQ0FBQ0ksQ0FBQyxFQUFFMUYsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN1Z0MsY0FBYyxFQUFFMWMsR0FBR2xwQixPQUFPLENBQUNpRixXQUFXO29CQUNwRixPQUFPO29CQUNQLElBQUkwSixLQUFLbFUsSUFBSTRPLE9BQU8sQ0FBQzhmLEdBQUd6cEIsSUFBSSxDQUFDSSxDQUFDLEVBQUUxRixLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3lnQyxjQUFjLEVBQUUzYyxHQUFHbnBCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3BGLE9BQU87b0JBQ1AsSUFBSTZvQixLQUFLMXpCLEtBQUtrTCxHQUFHLENBQUM0akIsR0FBR2xwQixPQUFPLENBQUN5RSxDQUFDLEVBQUVpSztvQkFDaEMsT0FBTztvQkFDUCxJQUFJcWYsS0FBSzN6QixLQUFLa0wsR0FBRyxDQUFDNmpCLEdBQUducEIsT0FBTyxDQUFDeUUsQ0FBQyxFQUFFa0s7b0JBQ2hDLE9BQU87b0JBQ1AsSUFBSTBoQixJQUFJajJCLEtBQUtpTCxHQUFHLENBQUMwb0IsSUFBSUQ7b0JBQ3JCLE9BQU87b0JBQ1AsSUFBSXdoQixPQUFPNzBDLElBQUk0TyxPQUFPLENBQUM2ZixHQUFHeHBCLElBQUksQ0FBQ0ksQ0FBQyxFQUFFLElBQUksQ0FBQ3FxQyxhQUFhO29CQUNwRCxPQUFPO29CQUNQLElBQUkzekIsS0FBSzBTLEdBQUc1b0IsZ0JBQWdCO29CQUM1QixPQUFPO29CQUNQLElBQUlvVyxLQUFLeVMsR0FBRzdvQixnQkFBZ0I7b0JBQzVCLE9BQU87b0JBQ1AsSUFBSW1XLEtBQUt5UyxHQUFHM29CLGlCQUFpQjtvQkFDN0IsUUFBUTtvQkFDUixJQUFJb1csS0FBS3dTLEdBQUc1b0IsaUJBQWlCO29CQUM3QixRQUFRO29CQUNSLElBQUkwUCxRQUFRN1YsS0FBS3lMLEdBQUcsQ0FBQ3dxQixHQUFHajJCLEtBQUttTCxLQUFLLENBQUNrUixJQUFJNjRCLFNBQVNsMUMsS0FBS3lMLEdBQUcsQ0FBQ3lwQyxNQUFNbDFDLEtBQUtpTCxHQUFHLENBQUNqTCxLQUFLMHFDLFFBQVEsQ0FBQ3B1QixJQUFJQyxJQUFJaEksS0FBS3ZVLEtBQUswcUMsUUFBUSxDQUFDdHVCLElBQUlDLElBQUkvSDtvQkFDekgsUUFBUTtvQkFDUixPQUFPdUI7Z0JBQ1g7Z0JBRUE7O0NBRUMsR0FDRHJVLGVBQWVzRixTQUFTLENBQUMydkMsY0FBYyxHQUFHO29CQUN0QyxPQUFPLElBQUksQ0FBQ2IsYUFBYTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRHAwQyxlQUFlc0YsU0FBUyxDQUFDOHRDLFdBQVcsR0FBRyxTQUFTeHJDLElBQUk7b0JBQ2hELElBQUlBLFFBQVEsSUFBSSxDQUFDd3NDLGFBQWEsRUFBRTt3QkFDNUIsSUFBSSxDQUFDL3ZCLE9BQU8sQ0FBQ3hkLFFBQVEsQ0FBQzt3QkFDdEIsSUFBSSxDQUFDeWQsT0FBTyxDQUFDemQsUUFBUSxDQUFDO3dCQUN0QixJQUFJLENBQUN1dEMsYUFBYSxHQUFHeHNDO3dCQUNyQixJQUFJLENBQUMyaUMsU0FBUyxDQUFDaEYsQ0FBQyxHQUFHO29CQUN2QjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEdmxDLGVBQWVzRixTQUFTLENBQUM0dkMsYUFBYSxHQUFHO29CQUNyQyxPQUFPLElBQUksQ0FBQ2xCLGtCQUFrQjtnQkFDbEM7Z0JBRUE7O0NBRUMsR0FDRGgwQyxlQUFlc0YsU0FBUyxDQUFDNnZDLGFBQWEsR0FBRztvQkFDckMsT0FBTyxJQUFJLENBQUNsQixrQkFBa0I7Z0JBQ2xDO2dCQUVBOztDQUVDLEdBQ0RqMEMsZUFBZXNGLFNBQVMsQ0FBQzh2QyxTQUFTLEdBQUcsU0FBUy9nQixLQUFLLEVBQUVDLEtBQUs7b0JBQ3REdnpCLFdBQVdFLFFBQU80QixNQUFNLENBQUN3eEIsU0FBU0M7b0JBQ2xDLElBQUlELFNBQVMsSUFBSSxDQUFDMmYsa0JBQWtCLElBQUkxZixTQUFTLElBQUksQ0FBQzJmLGtCQUFrQixFQUFFO3dCQUN0RSxJQUFJLENBQUM1dkIsT0FBTyxDQUFDeGQsUUFBUSxDQUFDO3dCQUN0QixJQUFJLENBQUN5ZCxPQUFPLENBQUN6ZCxRQUFRLENBQUM7d0JBQ3RCLElBQUksQ0FBQ210QyxrQkFBa0IsR0FBRzNmO3dCQUMxQixJQUFJLENBQUM0ZixrQkFBa0IsR0FBRzNmO3dCQUMxQixJQUFJLENBQUNpVyxTQUFTLENBQUNoRixDQUFDLEdBQUc7b0JBQ3ZCO2dCQUNKO2dCQUVBOztDQUVDLEdBQ0R2bEMsZUFBZXNGLFNBQVMsQ0FBQyt2QyxjQUFjLEdBQUc7b0JBQ3RDLE9BQU8sSUFBSSxDQUFDaEIsYUFBYTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRHIwQyxlQUFlc0YsU0FBUyxDQUFDaXVDLFdBQVcsR0FBRyxTQUFTM3JDLElBQUk7b0JBQ2hELElBQUksQ0FBQ3ljLE9BQU8sQ0FBQ3hkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDeWQsT0FBTyxDQUFDemQsUUFBUSxDQUFDO29CQUN0QixJQUFJLENBQUN3dEMsYUFBYSxHQUFHenNDO2dCQUN6QjtnQkFFQTs7Q0FFQyxHQUNENUgsZUFBZXNGLFNBQVMsQ0FBQ2d3QyxhQUFhLEdBQUcsU0FBU2poQyxLQUFLO29CQUNuRCxJQUFJLENBQUNnUSxPQUFPLENBQUN4ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQ3lkLE9BQU8sQ0FBQ3pkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDc3RDLFlBQVksR0FBRzkvQjtnQkFDeEI7Z0JBRUE7O0NBRUMsR0FDRHJVLGVBQWVzRixTQUFTLENBQUNpd0MsZ0JBQWdCLEdBQUcsU0FBUzVwQyxLQUFLO29CQUN0RCxJQUFJLENBQUMwWSxPQUFPLENBQUN4ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQ3lkLE9BQU8sQ0FBQ3pkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDcXRDLGVBQWUsR0FBR3ZvQztnQkFDM0I7Z0JBRUE7O0NBRUMsR0FDRDNMLGVBQWVzRixTQUFTLENBQUNrd0MsYUFBYSxHQUFHO29CQUNyQyxPQUFPLElBQUksQ0FBQ3JCLFlBQVk7Z0JBQzVCO2dCQUVBOztDQUVDLEdBQ0RuMEMsZUFBZXNGLFNBQVMsQ0FBQ213QyxhQUFhLEdBQUcsU0FBU3p3QixNQUFNO29CQUNwRCxPQUFPQSxTQUFTLElBQUksQ0FBQyt1QixjQUFjO2dCQUN2QztnQkFFQS96QyxlQUFlc0YsU0FBUyxDQUFDdWYsVUFBVSxHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDdmEsYUFBYSxDQUFDLElBQUksQ0FBQ2tnQyxjQUFjO2dCQUN6RDtnQkFFQWhxQyxlQUFlc0YsU0FBUyxDQUFDd2YsVUFBVSxHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDeGEsYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO2dCQUN6RDtnQkFFQWxxQyxlQUFlc0YsU0FBUyxDQUFDeWYsZ0JBQWdCLEdBQUcsU0FBU0MsTUFBTTtvQkFDdkQsT0FBT3htQixLQUFLNmtCLE9BQU8sQ0FBQyxJQUFJLENBQUNrbkIsU0FBUyxDQUFDeHNCLENBQUMsRUFBRSxJQUFJLENBQUN3MkIsTUFBTSxFQUFFLElBQUksQ0FBQ1IsY0FBYyxHQUFHLElBQUksQ0FBQ3hKLFNBQVMsQ0FBQ2hGLENBQUMsRUFBRSxJQUFJLENBQUN6QixNQUFNLEVBQUV4NEIsR0FBRyxDQUFDMFo7Z0JBQ2hIO2dCQUVBaGxCLGVBQWVzRixTQUFTLENBQUMyZixpQkFBaUIsR0FBRyxTQUFTRCxNQUFNO29CQUN4RCxPQUFPQSxTQUFTLElBQUksQ0FBQ3VsQixTQUFTLENBQUN0c0IsQ0FBQztnQkFDcEM7Z0JBRUFqZSxlQUFlc0YsU0FBUyxDQUFDOGYsdUJBQXVCLEdBQUcsU0FBUzFULElBQUk7b0JBQzVELElBQUksQ0FBQ201QixjQUFjLEdBQUcsSUFBSSxDQUFDeG1CLE9BQU8sQ0FBQ2pnQixPQUFPLENBQUNpRixXQUFXO29CQUN0RCxJQUFJLENBQUN5aEMsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNsZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDMGhDLFVBQVUsR0FBRyxJQUFJLENBQUMxbUIsT0FBTyxDQUFDMWdCLFNBQVM7b0JBQ3hDLElBQUksQ0FBQ3FuQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzNnQixTQUFTO29CQUN4QyxJQUFJLENBQUNzbkMsT0FBTyxHQUFHLElBQUksQ0FBQzVtQixPQUFPLENBQUN4Z0IsTUFBTTtvQkFDbEMsSUFBSSxDQUFDcW5DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDemdCLE1BQU07b0JBQ2xDLElBQUlnVSxLQUFLLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUlpUCxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk4YyxLQUFLLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUk2USxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUkyTixLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltUCxLQUFLLElBQUksQ0FBQ3NNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUlnZCxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJK1EsS0FBSyxJQUFJLENBQUN1SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSXdoQyxLQUFLL3NDLElBQUk2bkIsR0FBRyxDQUFDNU87b0JBQ2pCLElBQUkrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixnQ0FBZ0M7b0JBQ2hDLElBQUlsRixLQUFLalUsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJcHRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDdWdDLGNBQWMsRUFBRSxJQUFJLENBQUNhLGNBQWM7b0JBQzFFLElBQUk5M0IsS0FBS2xVLElBQUk0TyxPQUFPLENBQUNvK0IsSUFBSXJ0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3lnQyxjQUFjLEVBQUUsSUFBSSxDQUFDWSxjQUFjO29CQUMxRSxJQUFJclcsSUFBSWoyQixLQUFLc0QsSUFBSTtvQkFDakIyeUIsRUFBRWlVLFVBQVUsQ0FBQyxHQUFHM3dCLElBQUksR0FBR2hGO29CQUN2QjBoQixFQUFFbVUsVUFBVSxDQUFDLEdBQUcvd0IsSUFBSSxHQUFHL0U7b0JBQ3ZCLElBQUkyRSxLQUFLLElBQUksQ0FBQ3N6QixVQUFVLEVBQUVwekIsS0FBSyxJQUFJLENBQUNxekIsVUFBVTtvQkFDOUMsSUFBSXR6QixLQUFLLElBQUksQ0FBQ3V6QixPQUFPLEVBQUVyekIsS0FBSyxJQUFJLENBQUNzekIsT0FBTztvQkFDeEMsNkNBQTZDO29CQUM3Qzt3QkFDSSxJQUFJLENBQUNwSCxNQUFNLEdBQUdqbEMsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJLElBQUksQ0FBQzJDLGFBQWE7d0JBQ2hELElBQUksQ0FBQ21HLElBQUksR0FBR2wyQyxLQUFLbUwsS0FBSyxDQUFDbkwsS0FBS2tMLEdBQUcsQ0FBQytxQixHQUFHM2hCLEtBQUssSUFBSSxDQUFDZ3hCLE1BQU07d0JBQ25ELElBQUksQ0FBQzZRLElBQUksR0FBR24yQyxLQUFLbUwsS0FBSyxDQUFDb0osSUFBSSxJQUFJLENBQUMrd0IsTUFBTTt3QkFDdEMsSUFBSSxDQUFDZ1EsV0FBVyxHQUFHcjhCLEtBQUtFLEtBQUtELEtBQUssSUFBSSxDQUFDZzlCLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksR0FBRzk4QixLQUFLLElBQUksQ0FBQys4QixJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJO3dCQUNwRixJQUFJLElBQUksQ0FBQ2IsV0FBVyxHQUFHLEdBQUc7NEJBQ3RCLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUksSUFBSSxDQUFDQSxXQUFXO3dCQUMzQztvQkFDSjtvQkFDQSx3QkFBd0I7b0JBQ3hCO3dCQUNJLElBQUksQ0FBQ1MsTUFBTSxHQUFHMTFDLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSSxJQUFJLENBQUNnSSxhQUFhO3dCQUNoRCxJQUFJLENBQUNZLElBQUksR0FBR2gyQyxLQUFLbUwsS0FBSyxDQUFDbkwsS0FBS2tMLEdBQUcsQ0FBQytxQixHQUFHM2hCLEtBQUssSUFBSSxDQUFDeWhDLE1BQU07d0JBQ25ELElBQUksQ0FBQ0UsSUFBSSxHQUFHajJDLEtBQUttTCxLQUFLLENBQUNvSixJQUFJLElBQUksQ0FBQ3doQyxNQUFNO3dCQUN0QyxJQUFJbUIsU0FBU2wzQyxLQUFLbUwsS0FBSyxDQUFDbUosSUFBSSxJQUFJLENBQUN5aEMsTUFBTTt3QkFDdkMsSUFBSXQ0QixNQUFNeEUsS0FBS0UsS0FBS0QsS0FBSyxJQUFJLENBQUM4OEIsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxHQUFHNThCLEtBQUssSUFBSSxDQUFDNjhCLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7d0JBQzNFLElBQUl0NEIsTUFBTXpFLEtBQUssSUFBSSxDQUFDODhCLElBQUksR0FBRzU4QixLQUFLLElBQUksQ0FBQzY4QixJQUFJO3dCQUN6QyxJQUFJa0IsTUFBTWorQixLQUFLLElBQUksQ0FBQzg4QixJQUFJLEdBQUcsSUFBSSxDQUFDRSxJQUFJLEdBQUc5OEIsS0FBSyxJQUFJLENBQUM2OEIsSUFBSSxHQUFHLElBQUksQ0FBQ0UsSUFBSTt3QkFDakUsSUFBSXo0QixNQUFNeEUsS0FBS0U7d0JBQ2YsSUFBSXNFLE9BQU8sR0FBRzs0QkFDVixrQ0FBa0M7NEJBQ2xDQSxNQUFNO3dCQUNWO3dCQUNBLElBQUkwNUIsTUFBTWwrQixLQUFLLElBQUksQ0FBQ2c5QixJQUFJLEdBQUc5OEIsS0FBSyxJQUFJLENBQUMrOEIsSUFBSTt3QkFDekMsSUFBSWtCLE1BQU1wK0IsS0FBS0UsS0FBS0QsS0FBSyxJQUFJLENBQUNnOUIsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxHQUFHOThCLEtBQUssSUFBSSxDQUFDKzhCLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7d0JBQzNFLElBQUksQ0FBQ0MsR0FBRyxDQUFDdjRCLEVBQUUsQ0FBQzlULEdBQUcsQ0FBQzBULEtBQUtFLEtBQUt3NUI7d0JBQzFCLElBQUksQ0FBQ2YsR0FBRyxDQUFDdDRCLEVBQUUsQ0FBQy9ULEdBQUcsQ0FBQzRULEtBQUtELEtBQUswNUI7d0JBQzFCLElBQUksQ0FBQ2hCLEdBQUcsQ0FBQ3ZQLEVBQUUsQ0FBQzk4QixHQUFHLENBQUNvdEMsS0FBS0MsS0FBS0M7b0JBQzlCO29CQUNBLGlDQUFpQztvQkFDakMsSUFBSSxJQUFJLENBQUN6QixhQUFhLEVBQUU7d0JBQ3BCLElBQUkwQixtQkFBbUJ0M0MsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUM2NUIsTUFBTSxFQUFFclA7d0JBQzdDLFFBQVE7d0JBQ1IsSUFBSWwyQixNQUFLMGhCLEdBQUcsQ0FBQyxJQUFJLENBQUNnMEIsa0JBQWtCLEdBQUcsSUFBSSxDQUFDRCxrQkFBa0IsSUFBSSxJQUFJcHpDLFNBQVN1WSxVQUFVLEVBQUU7NEJBQ3ZGLElBQUksQ0FBQ203QixZQUFZLEdBQUduQjt3QkFDeEIsT0FBTyxJQUFJMkMsb0JBQW9CLElBQUksQ0FBQzlCLGtCQUFrQixFQUFFOzRCQUNwRCxJQUFJLElBQUksQ0FBQ00sWUFBWSxJQUFJckIsY0FBYztnQ0FDbkMsSUFBSSxDQUFDcUIsWUFBWSxHQUFHckI7Z0NBQ3BCLElBQUksQ0FBQzFJLFNBQVMsQ0FBQ2hGLENBQUMsR0FBRzs0QkFDdkI7d0JBQ0osT0FBTyxJQUFJdVEsb0JBQW9CLElBQUksQ0FBQzdCLGtCQUFrQixFQUFFOzRCQUNwRCxJQUFJLElBQUksQ0FBQ0ssWUFBWSxJQUFJcEIsY0FBYztnQ0FDbkMsSUFBSSxDQUFDb0IsWUFBWSxHQUFHcEI7Z0NBQ3BCLElBQUksQ0FBQzNJLFNBQVMsQ0FBQ2hGLENBQUMsR0FBRzs0QkFDdkI7d0JBQ0osT0FBTzs0QkFDSCxJQUFJLENBQUMrTyxZQUFZLEdBQUd0Qjs0QkFDcEIsSUFBSSxDQUFDekksU0FBUyxDQUFDaEYsQ0FBQyxHQUFHO3dCQUN2QjtvQkFDSixPQUFPO3dCQUNILElBQUksQ0FBQytPLFlBQVksR0FBR3RCO3dCQUNwQixJQUFJLENBQUN6SSxTQUFTLENBQUNoRixDQUFDLEdBQUc7b0JBQ3ZCO29CQUNBLElBQUksSUFBSSxDQUFDOE8sYUFBYSxJQUFJLE9BQU87d0JBQzdCLElBQUksQ0FBQ04sY0FBYyxHQUFHO29CQUMxQjtvQkFDQSxJQUFJcmlDLEtBQUtnQixZQUFZLEVBQUU7d0JBQ25CLGtDQUFrQzt3QkFDbEMsSUFBSSxDQUFDNjNCLFNBQVMsQ0FBQ2ovQixHQUFHLENBQUNvRyxLQUFLa0IsT0FBTzt3QkFDL0IsSUFBSSxDQUFDbWhDLGNBQWMsSUFBSXJpQyxLQUFLa0IsT0FBTzt3QkFDbkMsSUFBSStHLElBQUluYixLQUFLNmtCLE9BQU8sQ0FBQyxJQUFJLENBQUNrbkIsU0FBUyxDQUFDeHNCLENBQUMsRUFBRSxJQUFJLENBQUN3MkIsTUFBTSxFQUFFLElBQUksQ0FBQ1IsY0FBYyxHQUFHLElBQUksQ0FBQ3hKLFNBQVMsQ0FBQ2hGLENBQUMsRUFBRSxJQUFJLENBQUN6QixNQUFNO3dCQUN2RyxJQUFJaVMsS0FBSyxJQUFJLENBQUN4TCxTQUFTLENBQUN4c0IsQ0FBQyxHQUFHLElBQUksQ0FBQ3kyQixJQUFJLEdBQUcsSUFBSSxDQUFDakssU0FBUyxDQUFDdHNCLENBQUMsR0FBRyxBQUFDLENBQUEsSUFBSSxDQUFDODFCLGNBQWMsR0FBRyxJQUFJLENBQUN4SixTQUFTLENBQUNoRixDQUFDLEFBQURBLElBQUssSUFBSSxDQUFDbVAsSUFBSTt3QkFDL0csSUFBSXNCLEtBQUssSUFBSSxDQUFDekwsU0FBUyxDQUFDeHNCLENBQUMsR0FBRyxJQUFJLENBQUMwMkIsSUFBSSxHQUFHLElBQUksQ0FBQ2xLLFNBQVMsQ0FBQ3RzQixDQUFDLEdBQUcsQUFBQyxDQUFBLElBQUksQ0FBQzgxQixjQUFjLEdBQUcsSUFBSSxDQUFDeEosU0FBUyxDQUFDaEYsQ0FBQyxBQUFEQSxJQUFLLElBQUksQ0FBQ29QLElBQUk7d0JBQy9HLzVCLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZGtCLE1BQU1uRCxLQUFLcStCO3dCQUNYajdCLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBS28rQjtvQkFDZixPQUFPO3dCQUNILElBQUksQ0FBQ3pMLFNBQVMsQ0FBQzdqQyxPQUFPO3dCQUN0QixJQUFJLENBQUNxdEMsY0FBYyxHQUFHO29CQUMxQjtvQkFDQSxJQUFJLENBQUMxdkIsT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQyxDQUFDekIsR0FBRyxDQUFDcVM7b0JBQzlCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUMsR0FBR3lRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQyxDQUFDekIsR0FBRyxDQUFDdVM7b0JBQzlCLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDLEdBQUcyUTtnQkFDaEM7Z0JBRUEvYSxlQUFlc0YsU0FBUyxDQUFDK2Ysd0JBQXdCLEdBQUcsU0FBUzNULElBQUk7b0JBQzdELElBQUlrSixLQUFLLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUk2USxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUkwUSxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJK1EsS0FBSyxJQUFJLENBQUN1SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSXFOLEtBQUssSUFBSSxDQUFDc3pCLFVBQVU7b0JBQ3hCLElBQUlwekIsS0FBSyxJQUFJLENBQUNxekIsVUFBVTtvQkFDeEIsSUFBSXR6QixLQUFLLElBQUksQ0FBQ3V6QixPQUFPO29CQUNyQixJQUFJcnpCLEtBQUssSUFBSSxDQUFDc3pCLE9BQU87b0JBQ3JCLGlDQUFpQztvQkFDakMsSUFBSSxJQUFJLENBQUNtSixhQUFhLElBQUksSUFBSSxDQUFDQyxZQUFZLElBQUluQixhQUFhO3dCQUN4RCxJQUFJOUcsT0FBTzd0QyxLQUFLeUwsR0FBRyxDQUFDLElBQUksQ0FBQzY1QixNQUFNLEVBQUV0bEMsS0FBS2lMLEdBQUcsQ0FBQ3FSLElBQUlGLE9BQU8sSUFBSSxDQUFDKzVCLElBQUksR0FBRzU1QixLQUFLLElBQUksQ0FBQzI1QixJQUFJLEdBQUc3NUI7d0JBQ2xGLElBQUkzTyxVQUFVLElBQUksQ0FBQzRuQyxXQUFXLEdBQUksQ0FBQSxJQUFJLENBQUNLLFlBQVksR0FBRzlILElBQUc7d0JBQ3pELElBQUljLGFBQWEsSUFBSSxDQUFDNEcsY0FBYzt3QkFDcEMsSUFBSTNHLGFBQWExN0IsS0FBSzRZLEVBQUUsR0FBRyxJQUFJLENBQUM0cEIsZUFBZTt3QkFDL0MsSUFBSSxDQUFDSCxjQUFjLEdBQUd4MUMsTUFBSythLEtBQUssQ0FBQyxJQUFJLENBQUN5NkIsY0FBYyxHQUFHN25DLFNBQVMsQ0FBQ2toQyxZQUFZQTt3QkFDN0VsaEMsVUFBVSxJQUFJLENBQUM2bkMsY0FBYyxHQUFHNUc7d0JBQ2hDLElBQUl4ekIsSUFBSW5iLEtBQUs4TSxHQUFHLENBQUNZLFNBQVMsSUFBSSxDQUFDNDNCLE1BQU07d0JBQ3JDLElBQUlpUyxLQUFLN3BDLFVBQVUsSUFBSSxDQUFDd29DLElBQUk7d0JBQzVCLElBQUlzQixLQUFLOXBDLFVBQVUsSUFBSSxDQUFDeW9DLElBQUk7d0JBQzVCLzVCLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZGtCLE1BQU1uRCxLQUFLcStCO3dCQUNYajdCLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBS28rQjtvQkFDZjtvQkFDQSxJQUFJQyxRQUFRejNDLEtBQUtzRCxJQUFJO29CQUNyQm0wQyxNQUFNbDRCLENBQUMsSUFBSXZmLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDc3FDLE1BQU0sRUFBRXo1QixNQUFNLElBQUksQ0FBQzI1QixJQUFJLEdBQUcxNUI7b0JBQ25EazdCLE1BQU1sNEIsQ0FBQyxJQUFJdmYsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUNzcUMsTUFBTSxFQUFFMzVCLE1BQU0sSUFBSSxDQUFDNDVCLElBQUksR0FBRzM1QjtvQkFDbkRvN0IsTUFBTWg0QixDQUFDLEdBQUdsRCxLQUFLRjtvQkFDZixJQUFJLElBQUksQ0FBQ3U1QixhQUFhLElBQUksSUFBSSxDQUFDRSxZQUFZLElBQUl0QixlQUFlO3dCQUMxRCxzREFBc0Q7d0JBQ3RELElBQUlrRCxRQUFRO3dCQUNaQSxTQUFTMTNDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDNjVCLE1BQU0sRUFBRWhwQixNQUFNLElBQUksQ0FBQzY1QixJQUFJLEdBQUc1NUI7d0JBQ2pEbTdCLFNBQVMxM0MsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUM2NUIsTUFBTSxFQUFFbHBCLE1BQU0sSUFBSSxDQUFDODVCLElBQUksR0FBRzc1Qjt3QkFDakQsSUFBSXd4QixPQUFPNXRDLEtBQUt3M0MsTUFBTWw0QixDQUFDLEVBQUVrNEIsTUFBTWg0QixDQUFDLEVBQUVpNEI7d0JBQ2xDLElBQUlDLEtBQUsxM0MsS0FBSyxJQUFJLENBQUM4ckMsU0FBUzt3QkFDNUIsSUFBSTZMLEtBQUssSUFBSSxDQUFDeEIsR0FBRyxDQUFDdFAsT0FBTyxDQUFDN21DLEtBQUsrNkIsR0FBRyxDQUFDNlM7d0JBQ25DLE9BQU87d0JBQ1AsSUFBSSxDQUFDOUIsU0FBUyxDQUFDN2dDLEdBQUcsQ0FBQzBzQzt3QkFDbkIsSUFBSSxJQUFJLENBQUM5QixZQUFZLElBQUlyQixjQUFjOzRCQUNuQyxJQUFJLENBQUMxSSxTQUFTLENBQUNoRixDQUFDLEdBQUdobkMsTUFBS3NnQixHQUFHLENBQUMsSUFBSSxDQUFDMHJCLFNBQVMsQ0FBQ2hGLENBQUMsRUFBRTt3QkFDbEQsT0FBTyxJQUFJLElBQUksQ0FBQytPLFlBQVksSUFBSXBCLGNBQWM7NEJBQzFDLElBQUksQ0FBQzNJLFNBQVMsQ0FBQ2hGLENBQUMsR0FBR2huQyxNQUFLeWEsR0FBRyxDQUFDLElBQUksQ0FBQ3V4QixTQUFTLENBQUNoRixDQUFDLEVBQUU7d0JBQ2xEO3dCQUNBLHdFQUF3RTt3QkFDeEUsVUFBVTt3QkFDVixJQUFJbGEsSUFBSTdzQixLQUFLNmtCLE9BQU8sQ0FBQyxDQUFDLEdBQUc0eUIsT0FBTyxDQUFFLENBQUEsSUFBSSxDQUFDMUwsU0FBUyxDQUFDaEYsQ0FBQyxHQUFHNFEsR0FBRzVRLENBQUMsQUFBREEsR0FBSS9tQyxLQUFLa29CLEdBQUcsQ0FBQyxJQUFJLENBQUNrdUIsR0FBRyxDQUFDdlAsRUFBRSxDQUFDdG5CLENBQUMsRUFBRSxJQUFJLENBQUM2MkIsR0FBRyxDQUFDdlAsRUFBRSxDQUFDcG5CLENBQUM7d0JBQ2pHLE9BQU87d0JBQ1AsSUFBSW80QixNQUFNNzNDLEtBQUtrTCxHQUFHLENBQUMsSUFBSSxDQUFDa3JDLEdBQUcsQ0FBQ3BQLE9BQU8sQ0FBQ25hLElBQUk3c0IsS0FBS2tvQixHQUFHLENBQUN5dkIsR0FBR3A0QixDQUFDLEVBQUVvNEIsR0FBR2w0QixDQUFDO3dCQUMzRCxPQUFPO3dCQUNQLElBQUksQ0FBQ3NzQixTQUFTLENBQUN4c0IsQ0FBQyxHQUFHczRCLElBQUl0NEIsQ0FBQzt3QkFDeEIsSUFBSSxDQUFDd3NCLFNBQVMsQ0FBQ3RzQixDQUFDLEdBQUdvNEIsSUFBSXA0QixDQUFDO3dCQUN4Qm00QixLQUFLMzNDLEtBQUtnTCxHQUFHLENBQUMsSUFBSSxDQUFDOGdDLFNBQVMsRUFBRTRMO3dCQUM5QixJQUFJeDhCLElBQUluYixLQUFLNmtCLE9BQU8sQ0FBQyt5QixHQUFHcjRCLENBQUMsRUFBRSxJQUFJLENBQUN3MkIsTUFBTSxFQUFFNkIsR0FBRzdRLENBQUMsRUFBRSxJQUFJLENBQUN6QixNQUFNO3dCQUN6RCxPQUFPO3dCQUNQLElBQUlpUyxLQUFLSyxHQUFHcjRCLENBQUMsR0FBRyxJQUFJLENBQUN5MkIsSUFBSSxHQUFHNEIsR0FBR240QixDQUFDLEdBQUdtNEIsR0FBRzdRLENBQUMsR0FBRyxJQUFJLENBQUNtUCxJQUFJO3dCQUNuRCxRQUFRO3dCQUNSLElBQUlzQixLQUFLSSxHQUFHcjRCLENBQUMsR0FBRyxJQUFJLENBQUMwMkIsSUFBSSxHQUFHMkIsR0FBR240QixDQUFDLEdBQUdtNEIsR0FBRzdRLENBQUMsR0FBRyxJQUFJLENBQUNvUCxJQUFJO3dCQUNuRCxRQUFRO3dCQUNSLzVCLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZGtCLE1BQU1uRCxLQUFLcStCO3dCQUNYajdCLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBS28rQjtvQkFDZixPQUFPO3dCQUNILHdFQUF3RTt3QkFDeEUsSUFBSUksS0FBSyxJQUFJLENBQUN4QixHQUFHLENBQUNwUCxPQUFPLENBQUNobkMsS0FBS2c3QixHQUFHLENBQUN5Yzt3QkFDbkMsT0FBTzt3QkFDUCxJQUFJLENBQUMxTCxTQUFTLENBQUN4c0IsQ0FBQyxJQUFJcTRCLEdBQUdyNEIsQ0FBQzt3QkFDeEIsSUFBSSxDQUFDd3NCLFNBQVMsQ0FBQ3RzQixDQUFDLElBQUltNEIsR0FBR240QixDQUFDO3dCQUN4QixJQUFJdEUsSUFBSW5iLEtBQUs4TSxHQUFHLENBQUM4cUMsR0FBR3I0QixDQUFDLEVBQUUsSUFBSSxDQUFDdzJCLE1BQU07d0JBQ2xDLE9BQU87d0JBQ1AsSUFBSXdCLEtBQUtLLEdBQUdyNEIsQ0FBQyxHQUFHLElBQUksQ0FBQ3kyQixJQUFJLEdBQUc0QixHQUFHbjRCLENBQUM7d0JBQ2hDLFFBQVE7d0JBQ1IsSUFBSSszQixLQUFLSSxHQUFHcjRCLENBQUMsR0FBRyxJQUFJLENBQUMwMkIsSUFBSSxHQUFHMkIsR0FBR240QixDQUFDO3dCQUNoQyxRQUFRO3dCQUNSckQsR0FBR2YsTUFBTSxDQUFDcEMsSUFBSWtDO3dCQUNka0IsTUFBTW5ELEtBQUtxK0I7d0JBQ1hqN0IsR0FBR3pQLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZG9CLE1BQU1uRCxLQUFLbytCO29CQUNmO29CQUNBLElBQUksQ0FBQzN4QixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLEdBQUc0UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLEdBQUc4UTtvQkFDNUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO2dCQUNoQztnQkFFQS9hLGVBQWVzRixTQUFTLENBQUNnZ0Isd0JBQXdCLEdBQUcsU0FBUzVULElBQUk7b0JBQzdELElBQUltRyxLQUFLLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUlpUCxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUlpYSxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltUCxLQUFLLElBQUksQ0FBQ3NNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk4dEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPO29CQUNqQixJQUFJK3pCLEtBQUtodEMsSUFBSTZuQixHQUFHLENBQUMxTztvQkFDakIsSUFBSVAsS0FBSyxJQUFJLENBQUNzekIsVUFBVTtvQkFDeEIsSUFBSXB6QixLQUFLLElBQUksQ0FBQ3F6QixVQUFVO29CQUN4QixJQUFJdHpCLEtBQUssSUFBSSxDQUFDdXpCLE9BQU87b0JBQ3JCLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsT0FBTztvQkFDckIsMEJBQTBCO29CQUMxQixJQUFJcDRCLEtBQUtqVSxJQUFJNE8sT0FBTyxDQUFDbStCLElBQUlwdEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN1Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ2EsY0FBYztvQkFDMUUsT0FBTztvQkFDUCxJQUFJOTNCLEtBQUtsVSxJQUFJNE8sT0FBTyxDQUFDbytCLElBQUlydEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDMUUsT0FBTztvQkFDUCxJQUFJclcsSUFBSWoyQixLQUFLaUwsR0FBRyxDQUFDakwsS0FBS2tMLEdBQUcsQ0FBQ3FPLElBQUloRixLQUFLdlUsS0FBS2tMLEdBQUcsQ0FBQ21PLElBQUkvRTtvQkFDaEQsT0FBTztvQkFDUCxJQUFJNGdDLE9BQU83MEMsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJLElBQUksQ0FBQzJDLGFBQWE7b0JBQzdDLE9BQU87b0JBQ1AsSUFBSWxMLEtBQUs3a0MsS0FBS21MLEtBQUssQ0FBQ25MLEtBQUtrTCxHQUFHLENBQUMrcUIsR0FBRzNoQixLQUFLNGdDO29CQUNyQyxRQUFRO29CQUNSLElBQUlwUSxLQUFLOWtDLEtBQUttTCxLQUFLLENBQUNvSixJQUFJMmdDO29CQUN4QixRQUFRO29CQUNSLElBQUk0QyxPQUFPejNDLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSSxJQUFJLENBQUNnSSxhQUFhO29CQUM3QyxPQUFPO29CQUNQLElBQUl6USxLQUFLM2tDLEtBQUttTCxLQUFLLENBQUNuTCxLQUFLa0wsR0FBRyxDQUFDK3FCLEdBQUczaEIsS0FBS3dqQztvQkFDckMsUUFBUTtvQkFDUixJQUFJclQsS0FBS3prQyxLQUFLbUwsS0FBSyxDQUFDb0osSUFBSXVqQztvQkFDeEIsUUFBUTtvQkFDUixJQUFJcHFDLFVBQVV6TjtvQkFDZCxJQUFJODNDLEtBQUsvM0MsS0FBS3NELElBQUk7b0JBQ2xCLE9BQU87b0JBQ1B5MEMsR0FBR3g0QixDQUFDLEdBQUd2ZixLQUFLeUwsR0FBRyxDQUFDcXNDLE1BQU03aEI7b0JBQ3RCOGhCLEdBQUd0NEIsQ0FBQyxHQUFHakcsS0FBS0YsS0FBSyxJQUFJLENBQUNzMkIsZ0JBQWdCO29CQUN0QyxJQUFJNkMsY0FBYzF5QyxNQUFLMGhCLEdBQUcsQ0FBQ3MyQixHQUFHeDRCLENBQUM7b0JBQy9CLFFBQVE7b0JBQ1IsSUFBSXk0QixlQUFlajRDLE1BQUswaEIsR0FBRyxDQUFDczJCLEdBQUd0NEIsQ0FBQztvQkFDaEMsUUFBUTtvQkFDUixJQUFJOUUsYUFBYXZZLFNBQVN1WSxVQUFVO29CQUNwQyxJQUFJQyxzQkFBc0J4WSxTQUFTd1ksbUJBQW1CO29CQUN0RCxJQUFJM1csU0FBUztvQkFDYixPQUFPO29CQUNQLElBQUlnMEMsS0FBSztvQkFDVCxRQUFRO29CQUNSLElBQUksSUFBSSxDQUFDckMsYUFBYSxFQUFFO3dCQUNwQixJQUFJbG9CLGNBQWMxdEIsS0FBS3lMLEdBQUcsQ0FBQ3lwQyxNQUFNamY7d0JBQ2pDLFFBQVE7d0JBQ1IsSUFBSWwyQixNQUFLMGhCLEdBQUcsQ0FBQyxJQUFJLENBQUNnMEIsa0JBQWtCLEdBQUcsSUFBSSxDQUFDRCxrQkFBa0IsSUFBSSxJQUFJNzZCLFlBQVk7NEJBQzlFLG9DQUFvQzs0QkFDcENzOUIsS0FBS2w0QyxNQUFLK2EsS0FBSyxDQUFDNFMsYUFBYSxDQUFDOVMscUJBQXFCQTs0QkFDbkQ2M0IsY0FBYzF5QyxNQUFLc2dCLEdBQUcsQ0FBQ295QixhQUFhMXlDLE1BQUswaEIsR0FBRyxDQUFDaU07NEJBQzdDenBCLFNBQVM7d0JBQ2IsT0FBTyxJQUFJeXBCLGVBQWUsSUFBSSxDQUFDOG5CLGtCQUFrQixFQUFFOzRCQUMvQyx3REFBd0Q7NEJBQ3hEeUMsS0FBS2w0QyxNQUFLK2EsS0FBSyxDQUFDNFMsY0FBYyxJQUFJLENBQUM4bkIsa0JBQWtCLEdBQUc3NkIsWUFBWSxDQUFDQyxxQkFBcUI7NEJBQzFGNjNCLGNBQWMxeUMsTUFBS3NnQixHQUFHLENBQUNveUIsYUFBYSxJQUFJLENBQUMrQyxrQkFBa0IsR0FBRzluQjs0QkFDOUR6cEIsU0FBUzt3QkFDYixPQUFPLElBQUl5cEIsZUFBZSxJQUFJLENBQUMrbkIsa0JBQWtCLEVBQUU7NEJBQy9DLHdEQUF3RDs0QkFDeER3QyxLQUFLbDRDLE1BQUsrYSxLQUFLLENBQUM0UyxjQUFjLElBQUksQ0FBQytuQixrQkFBa0IsR0FBRzk2QixZQUFZLEdBQUdDOzRCQUN2RTYzQixjQUFjMXlDLE1BQUtzZ0IsR0FBRyxDQUFDb3lCLGFBQWEva0IsY0FBYyxJQUFJLENBQUMrbkIsa0JBQWtCOzRCQUN6RXh4QyxTQUFTO3dCQUNiO29CQUNKO29CQUNBLElBQUlBLFFBQVE7d0JBQ1IsSUFBSXdaLE1BQU14RSxLQUFLRSxLQUFLRCxLQUFLeXJCLEtBQUtBLEtBQUt2ckIsS0FBS3FyQixLQUFLQTt3QkFDN0MsUUFBUTt3QkFDUixJQUFJOW1CLE1BQU16RSxLQUFLeXJCLEtBQUt2ckIsS0FBS3FyQjt3QkFDekIsUUFBUTt3QkFDUixJQUFJMFMsTUFBTWorQixLQUFLeXJCLEtBQUtFLEtBQUt6ckIsS0FBS3FyQixLQUFLSzt3QkFDbkMsUUFBUTt3QkFDUixJQUFJcG5CLE1BQU14RSxLQUFLRTt3QkFDZixRQUFRO3dCQUNSLElBQUlzRSxPQUFPLEdBQUc7NEJBQ1YscUJBQXFCOzRCQUNyQkEsTUFBTTt3QkFDVjt3QkFDQSxJQUFJMDVCLE1BQU1sK0IsS0FBSzJyQixLQUFLenJCLEtBQUswckI7d0JBQ3pCLFFBQVE7d0JBQ1IsSUFBSXVTLE1BQU1wK0IsS0FBS0UsS0FBS0QsS0FBSzJyQixLQUFLQSxLQUFLenJCLEtBQUswckIsS0FBS0E7d0JBQzdDLFFBQVE7d0JBQ1IsSUFBSTVwQixJQUFJLElBQUkvYTt3QkFDWithLEVBQUUyQyxFQUFFLENBQUM5VCxHQUFHLENBQUMwVCxLQUFLRSxLQUFLdzVCO3dCQUNuQmo4QixFQUFFNEMsRUFBRSxDQUFDL1QsR0FBRyxDQUFDNFQsS0FBS0QsS0FBSzA1Qjt3QkFDbkJsOEIsRUFBRTJyQixFQUFFLENBQUM5OEIsR0FBRyxDQUFDb3RDLEtBQUtDLEtBQUtDO3dCQUNuQixJQUFJeDhCLElBQUk1YTt3QkFDUjRhLEVBQUUwRSxDQUFDLEdBQUd3NEIsR0FBR3g0QixDQUFDO3dCQUNWMUUsRUFBRTRFLENBQUMsR0FBR3M0QixHQUFHdDRCLENBQUM7d0JBQ1Y1RSxFQUFFa3NCLENBQUMsR0FBR2tSO3dCQUNOdnFDLFVBQVV3TixFQUFFNHJCLE9BQU8sQ0FBQzdtQyxLQUFLKzZCLEdBQUcsQ0FBQ25nQjtvQkFDakMsT0FBTzt3QkFDSCxJQUFJNEMsTUFBTXhFLEtBQUtFLEtBQUtELEtBQUt5ckIsS0FBS0EsS0FBS3ZyQixLQUFLcXJCLEtBQUtBO3dCQUM3QyxRQUFRO3dCQUNSLElBQUk5bUIsTUFBTXpFLEtBQUt5ckIsS0FBS3ZyQixLQUFLcXJCO3dCQUN6QixRQUFRO3dCQUNSLElBQUkvbUIsTUFBTXhFLEtBQUtFO3dCQUNmLFFBQVE7d0JBQ1IsSUFBSXNFLE9BQU8sR0FBRzs0QkFDVkEsTUFBTTt3QkFDVjt3QkFDQSxJQUFJeEMsSUFBSSxJQUFJaGI7d0JBQ1pnYixFQUFFMkMsRUFBRSxDQUFDOVQsR0FBRyxDQUFDMFQsS0FBS0U7d0JBQ2R6QyxFQUFFNEMsRUFBRSxDQUFDL1QsR0FBRyxDQUFDNFQsS0FBS0Q7d0JBQ2QsSUFBSXc2QixXQUFXaDlCLEVBQUV5ZixLQUFLLENBQUMzNkIsS0FBS2c3QixHQUFHLENBQUMrYzt3QkFDaEMsT0FBTzt3QkFDUHJxQyxRQUFRNlIsQ0FBQyxHQUFHMjRCLFNBQVMzNEIsQ0FBQzt3QkFDdEI3UixRQUFRK1IsQ0FBQyxHQUFHeTRCLFNBQVN6NEIsQ0FBQzt3QkFDdEIvUixRQUFRcTVCLENBQUMsR0FBRztvQkFDaEI7b0JBQ0EsSUFBSTVyQixJQUFJbmIsS0FBSzZrQixPQUFPLENBQUNuWCxRQUFRNlIsQ0FBQyxFQUFFdTRCLE1BQU1wcUMsUUFBUXE1QixDQUFDLEVBQUVtTztvQkFDakQsT0FBTztvQkFDUCxJQUFJcUMsS0FBSzdwQyxRQUFRNlIsQ0FBQyxHQUFHb2xCLEtBQUtqM0IsUUFBUStSLENBQUMsR0FBRy9SLFFBQVFxNUIsQ0FBQyxHQUFHbEM7b0JBQ2xELFFBQVE7b0JBQ1IsSUFBSTJTLEtBQUs5cEMsUUFBUTZSLENBQUMsR0FBR2tsQixLQUFLLzJCLFFBQVErUixDQUFDLEdBQUcvUixRQUFRcTVCLENBQUMsR0FBR2pDO29CQUNsRCxRQUFRO29CQUNSenJCLEdBQUdnQyxNQUFNLENBQUNwQyxJQUFJa0M7b0JBQ2Q3QixNQUFNSixLQUFLcStCO29CQUNYaCtCLEdBQUcxTSxNQUFNLENBQUNzTSxJQUFJZ0M7b0JBQ2QzQixNQUFNSixLQUFLbytCO29CQUNYLElBQUksQ0FBQzN4QixPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDLEdBQUdnUDtvQkFDNUIsSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQyxHQUFHZ2E7b0JBQzVCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUMsR0FBR2tQO29CQUM1QixJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDLEdBQUdrYTtvQkFDNUIsT0FBT2k1QixlQUFlcndDLFNBQVN1WSxVQUFVLElBQUlxOUIsZ0JBQWdCNTFDLFNBQVN3bkIsV0FBVztnQkFDckY7WUFHQTtZQUFFO2dCQUFDLFlBQVc7Z0JBQUUsZUFBYztnQkFBRSxtQkFBa0I7Z0JBQUcsbUJBQWtCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsaUJBQWdCO2dCQUFHLG1CQUFrQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxtQkFBa0I7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNycUIsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3pWLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHa0Q7Z0JBRWpCLElBQUlnQixVQUFTbEQsU0FBUTtnQkFFckIsSUFBSW1ELFVBQVVuRCxTQUFRO2dCQUV0QixJQUFJMGlCLFNBQVMxaUIsU0FBUTtnQkFFckIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJVSxPQUFPVixTQUFRO2dCQUVuQixJQUFJVyxRQUFRWCxTQUFRO2dCQUVwQixJQUFJWSxRQUFRWixTQUFRO2dCQUVwQixJQUFJYyxNQUFNZCxTQUFRO2dCQUVsQixJQUFJdUMsUUFBUXZDLFNBQVE7Z0JBRXBCLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlvRCxXQUFXcEQsU0FBUTtnQkFFdkIsSUFBSXFELFdBQVdyRCxTQUFRO2dCQUV2QixJQUFJb0IsUUFBUXBCLFNBQVE7Z0JBRXBCa0MsWUFBWXlwQyxJQUFJLEdBQUc7Z0JBRW5CenBDLFlBQVkwMkMsaUJBQWlCLEdBQUc7Z0JBRWhDLGtCQUFrQjtnQkFDbEIxMkMsWUFBWTBwQyxNQUFNLEdBQUd4cUM7Z0JBRXJCYyxZQUFZcUYsU0FBUyxHQUFHbWIsT0FBT3hnQixZQUFZMHBDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUUzRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJc3hDLGlCQUFpQjtvQkFDakJ4eUIsa0JBQWtCO2dCQUN0QjtnQkFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVNua0IsWUFBWTJDLEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFNmtDLE9BQU8sRUFBRUMsT0FBTyxFQUFFaE4sT0FBTyxFQUFFQyxPQUFPLEVBQUU1ZCxLQUFLO29CQUM3RSxJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVlsc0IsV0FBVSxHQUFJO3dCQUNoQyxPQUFPLElBQUlBLFlBQVkyQyxLQUFLa1AsT0FBT0UsT0FBTzZrQyxTQUFTQyxTQUFTaE4sU0FBU0MsU0FBUzVkO29CQUNsRjtvQkFDQXZwQixNQUFNMUIsUUFBUTBCLEtBQUtnMEM7b0JBQ25CejNDLE1BQU1mLElBQUksQ0FBQyxJQUFJLEVBQUV3RSxLQUFLa1AsT0FBT0U7b0JBQzdCRixRQUFRLElBQUksQ0FBQ3VTLE9BQU87b0JBQ3BCclMsUUFBUSxJQUFJLENBQUNzUyxPQUFPO29CQUNwQixJQUFJLENBQUM3Z0IsTUFBTSxHQUFHeEQsWUFBWXlwQyxJQUFJO29CQUM5QixJQUFJLENBQUNxTixlQUFlLEdBQUdGLFVBQVVBLFVBQVVqMEMsSUFBSW8wQyxhQUFhLElBQUl4NEMsS0FBS2tvQixHQUFHLENBQUMsQ0FBQyxHQUFHO29CQUM3RSxJQUFJLENBQUN1d0IsZUFBZSxHQUFHSCxVQUFVQSxVQUFVbDBDLElBQUlzMEMsYUFBYSxJQUFJMTRDLEtBQUtrb0IsR0FBRyxDQUFDLEdBQUc7b0JBQzVFLElBQUksQ0FBQ3NqQixjQUFjLEdBQUdGLFVBQVVoNEIsTUFBTWxFLGFBQWEsQ0FBQ2s4QixXQUFXbG5DLElBQUlxbkMsWUFBWSxJQUFJenJDLEtBQUtrb0IsR0FBRyxDQUFDLENBQUMsR0FBRztvQkFDaEcsSUFBSSxDQUFDd2pCLGNBQWMsR0FBR0gsVUFBVS8zQixNQUFNcEUsYUFBYSxDQUFDbThCLFdBQVdubkMsSUFBSXVuQyxZQUFZLElBQUkzckMsS0FBS2tvQixHQUFHLENBQUMsR0FBRztvQkFDL0YsSUFBSSxDQUFDeXdCLFNBQVMsR0FBRzU0QyxNQUFLd0UsUUFBUSxDQUFDSCxJQUFJdzBDLE9BQU8sSUFBSXgwQyxJQUFJdzBDLE9BQU8sR0FBRzU0QyxLQUFLd3dCLFFBQVEsQ0FBQzhhLFNBQVMrTTtvQkFDbkYsSUFBSSxDQUFDUSxTQUFTLEdBQUc5NEMsTUFBS3dFLFFBQVEsQ0FBQ0gsSUFBSTAwQyxPQUFPLElBQUkxMEMsSUFBSTAwQyxPQUFPLEdBQUc5NEMsS0FBS3d3QixRQUFRLENBQUMrYSxTQUFTK007b0JBQ25GLElBQUksQ0FBQ3JKLE9BQU8sR0FBR2x2QyxNQUFLd0UsUUFBUSxDQUFDb3BCLFNBQVNBLFFBQVF2cEIsSUFBSXVwQixLQUFLO29CQUN2RHByQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDc3BCLFFBQVE1dEIsTUFBS3NvQixPQUFPO29CQUM3QyxJQUFJLENBQUNtb0IsVUFBVSxHQUFHLElBQUksQ0FBQ21JLFNBQVMsR0FBRyxJQUFJLENBQUMxSixPQUFPLEdBQUcsSUFBSSxDQUFDNEosU0FBUztvQkFDaEUsSUFBSSxDQUFDOU0sU0FBUyxHQUFHO29CQUNqQixjQUFjO29CQUNkLElBQUksQ0FBQ2dOLElBQUk7b0JBQ1QsT0FBTztvQkFDUCxJQUFJLENBQUNDLElBQUk7b0JBQ1QsT0FBTztvQkFDUCxJQUFJLENBQUM3TSxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxjQUFjO29CQUNuQixPQUFPO29CQUNQLElBQUksQ0FBQ0MsY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLFVBQVU7b0JBQ2YsUUFBUTtvQkFDUixJQUFJLENBQUNDLFVBQVU7b0JBQ2YsUUFBUTtvQkFDUixJQUFJLENBQUNDLE9BQU87b0JBQ1osUUFBUTtvQkFDUixJQUFJLENBQUNDLE9BQU87b0JBQ1osUUFBUTtvQkFDUixJQUFJLENBQUN4bkMsTUFBTTtnQkFDZjtnQkFFQTs7Q0FFQyxHQUNEekQsWUFBWXFGLFNBQVMsQ0FBQ215QyxnQkFBZ0IsR0FBRztvQkFDckMsT0FBTyxJQUFJLENBQUNWLGVBQWU7Z0JBQy9CO2dCQUVBOztDQUVDLEdBQ0Q5MkMsWUFBWXFGLFNBQVMsQ0FBQ295QyxnQkFBZ0IsR0FBRztvQkFDckMsT0FBTyxJQUFJLENBQUNULGVBQWU7Z0JBQy9CO2dCQUVBOztDQUVDLEdBQ0RoM0MsWUFBWXFGLFNBQVMsQ0FBQ3F5QyxVQUFVLEdBQUc7b0JBQy9CLE9BQU8sSUFBSSxDQUFDUixTQUFTO2dCQUN6QjtnQkFFQTs7Q0FFQyxHQUNEbDNDLFlBQVlxRixTQUFTLENBQUNzeUMsVUFBVSxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ1AsU0FBUztnQkFDekI7Z0JBRUE7O0NBRUMsR0FDRHAzQyxZQUFZcUYsU0FBUyxDQUFDZ3JDLFFBQVEsR0FBRztvQkFDN0IsT0FBTyxJQUFJLENBQUM3QyxPQUFPO2dCQUN2QjtnQkFFQTs7Q0FFQyxHQUNEeHRDLFlBQVlxRixTQUFTLENBQUN1eUMsaUJBQWlCLEdBQUc7b0JBQ3RDLElBQUk3ekMsSUFBSSxJQUFJLENBQUNxZ0IsT0FBTyxDQUFDdmEsYUFBYSxDQUFDLElBQUksQ0FBQ2tnQyxjQUFjO29CQUN0RCxJQUFJcnNDLElBQUksSUFBSSxDQUFDbzVDLGVBQWU7b0JBQzVCLE9BQU92NEMsS0FBS3d3QixRQUFRLENBQUNockIsR0FBR3JHO2dCQUM1QjtnQkFFQTs7Q0FFQyxHQUNEc0MsWUFBWXFGLFNBQVMsQ0FBQ3d5QyxpQkFBaUIsR0FBRztvQkFDdEMsSUFBSTl6QyxJQUFJLElBQUksQ0FBQ3NnQixPQUFPLENBQUN4YSxhQUFhLENBQUMsSUFBSSxDQUFDb2dDLGNBQWM7b0JBQ3RELElBQUl2c0MsSUFBSSxJQUFJLENBQUNzNUMsZUFBZTtvQkFDNUIsT0FBT3o0QyxLQUFLd3dCLFFBQVEsQ0FBQ2hyQixHQUFHckc7Z0JBQzVCO2dCQUVBc0MsWUFBWXFGLFNBQVMsQ0FBQzRmLFdBQVcsR0FBRyxTQUFTQyxTQUFTO29CQUNsRCxJQUFJLENBQUM0eEIsZUFBZSxDQUFDdHRDLEdBQUcsQ0FBQzBiO29CQUN6QixJQUFJLENBQUM4eEIsZUFBZSxDQUFDeHRDLEdBQUcsQ0FBQzBiO2dCQUM3QjtnQkFFQWxsQixZQUFZcUYsU0FBUyxDQUFDdWYsVUFBVSxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDdmEsYUFBYSxDQUFDLElBQUksQ0FBQ2tnQyxjQUFjO2dCQUN6RDtnQkFFQS9wQyxZQUFZcUYsU0FBUyxDQUFDd2YsVUFBVSxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDeGEsYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO2dCQUN6RDtnQkFFQWpxQyxZQUFZcUYsU0FBUyxDQUFDeWYsZ0JBQWdCLEdBQUcsU0FBU0MsTUFBTTtvQkFDcEQsT0FBT3htQixLQUFLOE0sR0FBRyxDQUFDLElBQUksQ0FBQ2kvQixTQUFTLEVBQUUsSUFBSSxDQUFDaU4sSUFBSSxFQUFFbHNDLEdBQUcsQ0FBQzBaO2dCQUNuRDtnQkFFQS9rQixZQUFZcUYsU0FBUyxDQUFDMmYsaUJBQWlCLEdBQUcsU0FBU0QsTUFBTTtvQkFDckQsT0FBTztnQkFDWDtnQkFFQS9rQixZQUFZcUYsU0FBUyxDQUFDOGYsdUJBQXVCLEdBQUcsU0FBUzFULElBQUk7b0JBQ3pELElBQUksQ0FBQ201QixjQUFjLEdBQUcsSUFBSSxDQUFDeG1CLE9BQU8sQ0FBQ2pnQixPQUFPLENBQUNpRixXQUFXO29CQUN0RCxJQUFJLENBQUN5aEMsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNsZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDMGhDLFVBQVUsR0FBRyxJQUFJLENBQUMxbUIsT0FBTyxDQUFDMWdCLFNBQVM7b0JBQ3hDLElBQUksQ0FBQ3FuQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzNnQixTQUFTO29CQUN4QyxJQUFJLENBQUNzbkMsT0FBTyxHQUFHLElBQUksQ0FBQzVtQixPQUFPLENBQUN4Z0IsTUFBTTtvQkFDbEMsSUFBSSxDQUFDcW5DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDemdCLE1BQU07b0JBQ2xDLElBQUlnVSxLQUFLLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUlpUCxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk4YyxLQUFLLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUk2USxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUkyTixLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltUCxLQUFLLElBQUksQ0FBQ3NNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUlnZCxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJK1EsS0FBSyxJQUFJLENBQUN1SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSXdoQyxLQUFLL3NDLElBQUk2bkIsR0FBRyxDQUFDNU87b0JBQ2pCLElBQUkrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixJQUFJLENBQUMyeUIsSUFBSSxHQUFHOXJDLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSXB0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3VnQyxjQUFjLEVBQUUsSUFBSSxDQUFDYSxjQUFjO29CQUM3RSxJQUFJLENBQUNELElBQUksR0FBRy9yQyxJQUFJNE8sT0FBTyxDQUFDbytCLElBQUlydEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDN0UsdUJBQXVCO29CQUN2QixJQUFJLENBQUN5TSxJQUFJLEdBQUcvNEMsS0FBS2lMLEdBQUcsQ0FBQ2pMLEtBQUtrTCxHQUFHLENBQUNtTyxJQUFJLElBQUksQ0FBQzh5QixJQUFJLEdBQUcsSUFBSSxDQUFDb00sZUFBZTtvQkFDbEUsSUFBSSxDQUFDUyxJQUFJLEdBQUdoNUMsS0FBS2lMLEdBQUcsQ0FBQ2pMLEtBQUtrTCxHQUFHLENBQUNxTyxJQUFJLElBQUksQ0FBQzZ5QixJQUFJLEdBQUcsSUFBSSxDQUFDcU0sZUFBZTtvQkFDbEUsSUFBSUcsVUFBVSxJQUFJLENBQUNHLElBQUksQ0FBQ2w1QyxNQUFNO29CQUM5QixJQUFJaTVDLFVBQVUsSUFBSSxDQUFDRSxJQUFJLENBQUNuNUMsTUFBTTtvQkFDOUIsSUFBSSs0QyxVQUFVLEtBQUt4MkMsU0FBU3VZLFVBQVUsRUFBRTt3QkFDcEMsSUFBSSxDQUFDbytCLElBQUksQ0FBQ2pzQyxHQUFHLENBQUMsSUFBSThyQztvQkFDdEIsT0FBTzt3QkFDSCxJQUFJLENBQUNHLElBQUksQ0FBQzd3QyxPQUFPO29CQUNyQjtvQkFDQSxJQUFJNHdDLFVBQVUsS0FBSzEyQyxTQUFTdVksVUFBVSxFQUFFO3dCQUNwQyxJQUFJLENBQUNxK0IsSUFBSSxDQUFDbHNDLEdBQUcsQ0FBQyxJQUFJZ3NDO29CQUN0QixPQUFPO3dCQUNILElBQUksQ0FBQ0UsSUFBSSxDQUFDOXdDLE9BQU87b0JBQ3JCO29CQUNBLDBCQUEwQjtvQkFDMUIsSUFBSXF4QyxNQUFNdjVDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRSxJQUFJLENBQUM0TSxJQUFJO29CQUN6QyxRQUFRO29CQUNSLElBQUlTLE1BQU14NUMsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFLElBQUksQ0FBQzRNLElBQUk7b0JBQ3pDLFFBQVE7b0JBQ1IsSUFBSS8vQixLQUFLLElBQUksQ0FBQ3N6QixVQUFVLEdBQUcsSUFBSSxDQUFDRSxPQUFPLEdBQUc4TSxNQUFNQTtvQkFDaEQsUUFBUTtvQkFDUixJQUFJcGdDLEtBQUssSUFBSSxDQUFDcXpCLFVBQVUsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBRzhNLE1BQU1BO29CQUNoRCxRQUFRO29CQUNSLElBQUksQ0FBQ3QwQyxNQUFNLEdBQUcrVCxLQUFLLElBQUksQ0FBQ2cyQixPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLEdBQUc5MUI7b0JBQ2pELElBQUksSUFBSSxDQUFDalUsTUFBTSxHQUFHLEdBQUc7d0JBQ2pCLElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDQSxNQUFNO29CQUNqQztvQkFDQSxJQUFJZ08sS0FBS2dCLFlBQVksRUFBRTt3QkFDbkIsaURBQWlEO3dCQUNqRCxJQUFJLENBQUM2M0IsU0FBUyxJQUFJNzRCLEtBQUtrQixPQUFPO3dCQUM5QixpQkFBaUI7d0JBQ2pCLElBQUlxbEMsS0FBS3o1QyxLQUFLOE0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDaS9CLFNBQVMsRUFBRSxJQUFJLENBQUNnTixJQUFJO3dCQUM1QyxJQUFJVyxLQUFLMTVDLEtBQUs4TSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUNtaUMsT0FBTyxHQUFHLElBQUksQ0FBQ2xELFNBQVMsRUFBRSxJQUFJLENBQUNpTixJQUFJO3dCQUMzRDU4QixHQUFHdlAsTUFBTSxDQUFDLElBQUksQ0FBQzAvQixVQUFVLEVBQUVrTjt3QkFDM0JwOUIsTUFBTSxJQUFJLENBQUNvd0IsT0FBTyxHQUFHenNDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRXNOO3dCQUMzQ245QixHQUFHelAsTUFBTSxDQUFDLElBQUksQ0FBQzIvQixVQUFVLEVBQUVrTjt3QkFDM0JuOUIsTUFBTSxJQUFJLENBQUNtd0IsT0FBTyxHQUFHMXNDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRXNOO29CQUMvQyxPQUFPO3dCQUNILElBQUksQ0FBQzNOLFNBQVMsR0FBRztvQkFDckI7b0JBQ0EsSUFBSSxDQUFDbG1CLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzRRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzhRO29CQUM1QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBOWEsWUFBWXFGLFNBQVMsQ0FBQytmLHdCQUF3QixHQUFHLFNBQVMzVCxJQUFJO29CQUMxRCxJQUFJa0osS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMFEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUkraEMsTUFBTTN0QyxLQUFLa0wsR0FBRyxDQUFDa1IsSUFBSXBjLEtBQUttTCxLQUFLLENBQUNrUixJQUFJLElBQUksQ0FBQzh2QixJQUFJO29CQUMvQyxJQUFJeUIsTUFBTTV0QyxLQUFLa0wsR0FBRyxDQUFDb1IsSUFBSXRjLEtBQUttTCxLQUFLLENBQUNvUixJQUFJLElBQUksQ0FBQzZ2QixJQUFJO29CQUMvQyxJQUFJeUIsT0FBTyxDQUFDN3RDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDc3RDLElBQUksRUFBRXBMLE9BQU8sSUFBSSxDQUFDc0IsT0FBTyxHQUFHanZDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDdXRDLElBQUksRUFBRXBMO29CQUMxRSxRQUFRO29CQUNSLElBQUlsZ0MsVUFBVSxDQUFDLElBQUksQ0FBQ3hJLE1BQU0sR0FBRzJvQztvQkFDN0IsUUFBUTtvQkFDUixJQUFJLENBQUM5QixTQUFTLElBQUlyK0I7b0JBQ2xCLElBQUkrckMsS0FBS3o1QyxLQUFLOE0sR0FBRyxDQUFDLENBQUNZLFNBQVMsSUFBSSxDQUFDcXJDLElBQUk7b0JBQ3JDLE9BQU87b0JBQ1AsSUFBSVcsS0FBSzE1QyxLQUFLOE0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDbWlDLE9BQU8sR0FBR3ZoQyxTQUFTLElBQUksQ0FBQ3NyQyxJQUFJO29CQUNwRCxPQUFPO29CQUNQNThCLEdBQUd2UCxNQUFNLENBQUMsSUFBSSxDQUFDMC9CLFVBQVUsRUFBRWtOO29CQUMzQnA5QixNQUFNLElBQUksQ0FBQ293QixPQUFPLEdBQUd6c0MsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNnaEMsSUFBSSxFQUFFc047b0JBQzNDbjlCLEdBQUd6UCxNQUFNLENBQUMsSUFBSSxDQUFDMi9CLFVBQVUsRUFBRWtOO29CQUMzQm45QixNQUFNLElBQUksQ0FBQ213QixPQUFPLEdBQUcxc0MsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFc047b0JBQzNDLElBQUksQ0FBQzd6QixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLEdBQUc0UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLEdBQUc4UTtvQkFDNUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO2dCQUNoQztnQkFFQTlhLFlBQVlxRixTQUFTLENBQUNnZ0Isd0JBQXdCLEdBQUcsU0FBUzVULElBQUk7b0JBQzFELElBQUltRyxLQUFLLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUlpUCxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUlpYSxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltUCxLQUFLLElBQUksQ0FBQ3NNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk4dEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPLEtBQUsrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNuQyxJQUFJbEYsS0FBS2pVLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSXB0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3VnQyxjQUFjLEVBQUUsSUFBSSxDQUFDYSxjQUFjO29CQUMxRSxJQUFJOTNCLEtBQUtsVSxJQUFJNE8sT0FBTyxDQUFDbytCLElBQUlydEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDMUUsdUJBQXVCO29CQUN2QixJQUFJcU4sS0FBSzM1QyxLQUFLaUwsR0FBRyxDQUFDakwsS0FBS2tMLEdBQUcsQ0FBQ21PLElBQUksSUFBSSxDQUFDOHlCLElBQUksR0FBRyxJQUFJLENBQUNvTSxlQUFlO29CQUMvRCxJQUFJcUIsS0FBSzU1QyxLQUFLaUwsR0FBRyxDQUFDakwsS0FBS2tMLEdBQUcsQ0FBQ3FPLElBQUksSUFBSSxDQUFDNnlCLElBQUksR0FBRyxJQUFJLENBQUNxTSxlQUFlO29CQUMvRCxJQUFJRyxVQUFVZSxHQUFHOTVDLE1BQU07b0JBQ3ZCLElBQUlpNUMsVUFBVWMsR0FBRy81QyxNQUFNO29CQUN2QixJQUFJKzRDLFVBQVUsS0FBS3gyQyxTQUFTdVksVUFBVSxFQUFFO3dCQUNwQ2cvQixHQUFHN3NDLEdBQUcsQ0FBQyxJQUFJOHJDO29CQUNmLE9BQU87d0JBQ0hlLEdBQUd6eEMsT0FBTztvQkFDZDtvQkFDQSxJQUFJNHdDLFVBQVUsS0FBSzEyQyxTQUFTdVksVUFBVSxFQUFFO3dCQUNwQ2kvQixHQUFHOXNDLEdBQUcsQ0FBQyxJQUFJZ3NDO29CQUNmLE9BQU87d0JBQ0hjLEdBQUcxeEMsT0FBTztvQkFDZDtvQkFDQSwwQkFBMEI7b0JBQzFCLElBQUlxeEMsTUFBTXY1QyxLQUFLbUwsS0FBSyxDQUFDbUosSUFBSXFsQztvQkFDekIsSUFBSUgsTUFBTXg1QyxLQUFLbUwsS0FBSyxDQUFDb0osSUFBSXFsQztvQkFDekIsSUFBSTNnQyxLQUFLLElBQUksQ0FBQ3N6QixVQUFVLEdBQUcsSUFBSSxDQUFDRSxPQUFPLEdBQUc4TSxNQUFNQTtvQkFDaEQsUUFBUTtvQkFDUixJQUFJcGdDLEtBQUssSUFBSSxDQUFDcXpCLFVBQVUsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBRzhNLE1BQU1BO29CQUNoRCxRQUFRO29CQUNSLElBQUlqdEMsT0FBTzBNLEtBQUssSUFBSSxDQUFDZzJCLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sR0FBRzkxQjtvQkFDOUMsUUFBUTtvQkFDUixJQUFJNU0sT0FBTyxHQUFHO3dCQUNWQSxPQUFPLElBQUlBO29CQUNmO29CQUNBLElBQUlzTyxJQUFJLElBQUksQ0FBQzIxQixVQUFVLEdBQUdvSSxVQUFVLElBQUksQ0FBQzNKLE9BQU8sR0FBRzZKO29CQUNuRCxRQUFRO29CQUNSLElBQUlyRyxjQUFjMXlDLE1BQUswaEIsR0FBRyxDQUFDNUc7b0JBQzNCLFFBQVE7b0JBQ1IsSUFBSW5OLFVBQVUsQ0FBQ25CLE9BQU9zTztvQkFDdEIsUUFBUTtvQkFDUixJQUFJNCtCLEtBQUt6NUMsS0FBSzhNLEdBQUcsQ0FBQyxDQUFDWSxTQUFTaXNDO29CQUM1QixPQUFPO29CQUNQLElBQUlELEtBQUsxNUMsS0FBSzhNLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ21pQyxPQUFPLEdBQUd2aEMsU0FBU2tzQztvQkFDM0MsT0FBTztvQkFDUHZnQyxHQUFHeE0sTUFBTSxDQUFDLElBQUksQ0FBQzAvQixVQUFVLEVBQUVrTjtvQkFDM0JuZ0MsTUFBTSxJQUFJLENBQUNtekIsT0FBTyxHQUFHenNDLEtBQUttTCxLQUFLLENBQUNtSixJQUFJbWxDO29CQUNwQ2xnQyxHQUFHMU0sTUFBTSxDQUFDLElBQUksQ0FBQzIvQixVQUFVLEVBQUVrTjtvQkFDM0JsZ0MsTUFBTSxJQUFJLENBQUNrekIsT0FBTyxHQUFHMXNDLEtBQUttTCxLQUFLLENBQUNvSixJQUFJbWxDO29CQUNwQyxJQUFJLENBQUM3ekIsT0FBTyxDQUFDOWYsVUFBVSxDQUFDc0UsQ0FBQyxHQUFHZ1A7b0JBQzVCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR2dhO29CQUM1QixJQUFJLENBQUN3TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDLEdBQUdrUDtvQkFDNUIsSUFBSSxDQUFDdU0sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQyxHQUFHa2E7b0JBQzVCLE9BQU9pNUIsY0FBY3J3QyxTQUFTdVksVUFBVTtnQkFDNUM7WUFHQTtZQUFFO2dCQUFDLFlBQVc7Z0JBQUUsZUFBYztnQkFBRSxtQkFBa0I7Z0JBQUcsbUJBQWtCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsaUJBQWdCO2dCQUFHLG1CQUFrQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxtQkFBa0I7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNwYixRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDelYsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERoRSxRQUFPRCxPQUFPLEdBQUdtRDtnQkFFakIsSUFBSWUsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUltRCxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSVUsT0FBT1YsU0FBUTtnQkFFbkIsSUFBSVcsUUFBUVgsU0FBUTtnQkFFcEIsSUFBSVksUUFBUVosU0FBUTtnQkFFcEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSXVDLFFBQVF2QyxTQUFRO2dCQUVwQixJQUFJYSxZQUFZYixTQUFRO2dCQUV4QixJQUFJb0QsV0FBV3BELFNBQVE7Z0JBRXZCLElBQUlxRCxXQUFXckQsU0FBUTtnQkFFdkIsSUFBSW9CLFFBQVFwQixTQUFRO2dCQUVwQixJQUFJaTFDLGdCQUFnQjtnQkFFcEIsSUFBSUMsZUFBZTtnQkFFbkIsSUFBSUMsZUFBZTtnQkFFbkIsSUFBSUMsY0FBYztnQkFFbEJqekMsY0FBY3dwQyxJQUFJLEdBQUc7Z0JBRXJCeHBDLGNBQWN5cEMsTUFBTSxHQUFHeHFDO2dCQUV2QmUsY0FBY29GLFNBQVMsR0FBR21iLE9BQU92Z0IsY0FBY3lwQyxNQUFNLENBQUNya0MsU0FBUztnQkFFL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJCQyxHQUNELElBQUk2ZSxXQUFXO29CQUNYazBCLFlBQVk7b0JBQ1pDLFlBQVk7b0JBQ1pDLGdCQUFnQjtvQkFDaEI5RSxZQUFZO29CQUNaTCxhQUFhO29CQUNiRyxhQUFhO2dCQUNqQjtnQkFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNyekMsY0FBYzBDLEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFdzZCLE1BQU07b0JBQzVDLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWXRzQyxhQUFZLEdBQUk7d0JBQ2xDLE9BQU8sSUFBSUEsY0FBYzBDLEtBQUtrUCxPQUFPRSxPQUFPdzZCO29CQUNoRDtvQkFDQTVwQyxNQUFNMUIsUUFBUTBCLEtBQUt1aEI7b0JBQ25CaGxCLE1BQU1mLElBQUksQ0FBQyxJQUFJLEVBQUV3RSxLQUFLa1AsT0FBT0U7b0JBQzdCRixRQUFRLElBQUksQ0FBQ3VTLE9BQU87b0JBQ3BCclMsUUFBUSxJQUFJLENBQUNzUyxPQUFPO29CQUNwQixJQUFJLENBQUM3Z0IsTUFBTSxHQUFHdkQsY0FBY3dwQyxJQUFJO29CQUNoQyxJQUFJLENBQUNNLGNBQWMsR0FBR3dDLFNBQVMxNkIsTUFBTWxFLGFBQWEsQ0FBQzQrQixVQUFVNXBDLElBQUlxbkMsWUFBWSxJQUFJenJDLEtBQUtzRCxJQUFJO29CQUMxRixJQUFJLENBQUNvb0MsY0FBYyxHQUFHc0MsU0FBU3g2QixNQUFNcEUsYUFBYSxDQUFDNCtCLFVBQVU1cEMsSUFBSXVuQyxZQUFZLElBQUkzckMsS0FBS3NELElBQUk7b0JBQzFGLElBQUksQ0FBQ3NzQyxnQkFBZ0IsR0FBRzd2QyxNQUFLd0UsUUFBUSxDQUFDSCxJQUFJaXhDLGNBQWMsSUFBSWp4QyxJQUFJaXhDLGNBQWMsR0FBRzdoQyxNQUFNOUksUUFBUSxLQUFLNEksTUFBTTVJLFFBQVE7b0JBQ2xILElBQUksQ0FBQ3FoQyxTQUFTLEdBQUc5ckM7b0JBQ2pCLElBQUksQ0FBQ3MxQyxjQUFjLEdBQUc7b0JBQ3RCLElBQUksQ0FBQ3lFLFlBQVksR0FBRzUxQyxJQUFJeTFDLFVBQVU7b0JBQ2xDLElBQUksQ0FBQ0ksWUFBWSxHQUFHNzFDLElBQUkwMUMsVUFBVTtvQkFDbEMsSUFBSSxDQUFDSSxnQkFBZ0IsR0FBRzkxQyxJQUFJMjFDLGNBQWM7b0JBQzFDLElBQUksQ0FBQ3BFLFlBQVksR0FBR3Z4QyxJQUFJNndDLFVBQVU7b0JBQ2xDLElBQUksQ0FBQ1csYUFBYSxHQUFHeHhDLElBQUl3d0MsV0FBVztvQkFDcEMsSUFBSSxDQUFDaUIsYUFBYSxHQUFHenhDLElBQUkyd0MsV0FBVztvQkFDcEMsY0FBYztvQkFDZCxJQUFJLENBQUM1SSxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxJQUFJO29CQUNULE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxjQUFjO29CQUNuQixPQUFPO29CQUNQLElBQUksQ0FBQ0MsY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLFVBQVU7b0JBQ2YsUUFBUTtvQkFDUixJQUFJLENBQUNDLFVBQVU7b0JBQ2YsUUFBUTtvQkFDUixJQUFJLENBQUNDLE9BQU87b0JBQ1osUUFBUTtvQkFDUixJQUFJLENBQUNDLE9BQU87b0JBQ1osUUFBUTtvQkFDUixnREFBZ0Q7b0JBQ2hELElBQUksQ0FBQ3huQyxNQUFNLEdBQUcsSUFBSS9FO29CQUNsQixxREFBcUQ7b0JBQ3JELElBQUksQ0FBQ20xQyxXQUFXO29CQUNoQixRQUFRO29CQUNSLElBQUksQ0FBQ1EsWUFBWSxHQUFHdEI7Z0JBQ3hCO2dCQUVBOztDQUVDLEdBQ0Q5eUMsY0FBY29GLFNBQVMsQ0FBQzZsQyxlQUFlLEdBQUc7b0JBQ3RDLE9BQU8sSUFBSSxDQUFDbkIsY0FBYztnQkFDOUI7Z0JBRUE7O0NBRUMsR0FDRDlwQyxjQUFjb0YsU0FBUyxDQUFDOGxDLGVBQWUsR0FBRztvQkFDdEMsT0FBTyxJQUFJLENBQUNsQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEaHFDLGNBQWNvRixTQUFTLENBQUN3dkMsaUJBQWlCLEdBQUc7b0JBQ3hDLE9BQU8sSUFBSSxDQUFDMUcsZ0JBQWdCO2dCQUNoQztnQkFFQTs7Q0FFQyxHQUNEbHVDLGNBQWNvRixTQUFTLENBQUNxekMsYUFBYSxHQUFHO29CQUNwQyxJQUFJcnJCLEtBQUssSUFBSSxDQUFDakosT0FBTztvQkFDckIsSUFBSWtKLEtBQUssSUFBSSxDQUFDakosT0FBTztvQkFDckIsT0FBT2lKLEdBQUducEIsT0FBTyxDQUFDdEcsQ0FBQyxHQUFHd3ZCLEdBQUdscEIsT0FBTyxDQUFDdEcsQ0FBQyxHQUFHLElBQUksQ0FBQ3N3QyxnQkFBZ0I7Z0JBQzlEO2dCQUVBOztDQUVDLEdBQ0RsdUMsY0FBY29GLFNBQVMsQ0FBQzB2QyxhQUFhLEdBQUc7b0JBQ3BDLElBQUkxbkIsS0FBSyxJQUFJLENBQUNqSixPQUFPO29CQUNyQixJQUFJa0osS0FBSyxJQUFJLENBQUNqSixPQUFPO29CQUNyQixPQUFPaUosR0FBRzVvQixpQkFBaUIsR0FBRzJvQixHQUFHM29CLGlCQUFpQjtnQkFDdEQ7Z0JBRUE7O0NBRUMsR0FDRHpFLGNBQWNvRixTQUFTLENBQUMrdkMsY0FBYyxHQUFHO29CQUNyQyxPQUFPLElBQUksQ0FBQ2hCLGFBQWE7Z0JBQzdCO2dCQUVBOztDQUVDLEdBQ0RuMEMsY0FBY29GLFNBQVMsQ0FBQ2l1QyxXQUFXLEdBQUcsU0FBUzNyQyxJQUFJO29CQUMvQyxJQUFJLENBQUN5YyxPQUFPLENBQUN4ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQ3lkLE9BQU8sQ0FBQ3pkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDd3RDLGFBQWEsR0FBR3pzQztnQkFDekI7Z0JBRUE7O0NBRUMsR0FDRDFILGNBQWNvRixTQUFTLENBQUNzekMsY0FBYyxHQUFHLFNBQVM1ekIsTUFBTTtvQkFDcEQsT0FBT0EsU0FBUyxJQUFJLENBQUMrdUIsY0FBYztnQkFDdkM7Z0JBRUE7O0NBRUMsR0FDRDd6QyxjQUFjb0YsU0FBUyxDQUFDZ3dDLGFBQWEsR0FBRyxTQUFTamhDLEtBQUs7b0JBQ2xELElBQUksQ0FBQ2dRLE9BQU8sQ0FBQ3hkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDeWQsT0FBTyxDQUFDemQsUUFBUSxDQUFDO29CQUN0QixJQUFJLENBQUNzdEMsWUFBWSxHQUFHOS9CO2dCQUN4QjtnQkFFQTs7Q0FFQyxHQUNEblUsY0FBY29GLFNBQVMsQ0FBQ2t3QyxhQUFhLEdBQUc7b0JBQ3BDLE9BQU8sSUFBSSxDQUFDckIsWUFBWTtnQkFDNUI7Z0JBRUE7O0NBRUMsR0FDRGowQyxjQUFjb0YsU0FBUyxDQUFDdXpDLGlCQUFpQixHQUFHLFNBQVM3c0MsTUFBTTtvQkFDdkQsSUFBSSxDQUFDcVksT0FBTyxDQUFDeGQsUUFBUSxDQUFDO29CQUN0QixJQUFJLENBQUN5ZCxPQUFPLENBQUN6ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQzZ4QyxnQkFBZ0IsR0FBRzFzQztnQkFDNUI7Z0JBRUE7O0NBRUMsR0FDRDlMLGNBQWNvRixTQUFTLENBQUMydkMsY0FBYyxHQUFHO29CQUNyQyxPQUFPLElBQUksQ0FBQ2IsYUFBYTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRGwwQyxjQUFjb0YsU0FBUyxDQUFDOHRDLFdBQVcsR0FBRyxTQUFTeHJDLElBQUk7b0JBQy9DLElBQUlBLFFBQVEsSUFBSSxDQUFDd3NDLGFBQWEsRUFBRTt3QkFDNUIsSUFBSSxDQUFDL3ZCLE9BQU8sQ0FBQ3hkLFFBQVEsQ0FBQzt3QkFDdEIsSUFBSSxDQUFDeWQsT0FBTyxDQUFDemQsUUFBUSxDQUFDO3dCQUN0QixJQUFJLENBQUN1dEMsYUFBYSxHQUFHeHNDO3dCQUNyQixJQUFJLENBQUMyaUMsU0FBUyxDQUFDaEYsQ0FBQyxHQUFHO29CQUN2QjtnQkFDSjtnQkFFQTs7Q0FFQyxHQUNEcmxDLGNBQWNvRixTQUFTLENBQUM0dkMsYUFBYSxHQUFHO29CQUNwQyxPQUFPLElBQUksQ0FBQ3NELFlBQVk7Z0JBQzVCO2dCQUVBOztDQUVDLEdBQ0R0NEMsY0FBY29GLFNBQVMsQ0FBQzZ2QyxhQUFhLEdBQUc7b0JBQ3BDLE9BQU8sSUFBSSxDQUFDc0QsWUFBWTtnQkFDNUI7Z0JBRUE7O0NBRUMsR0FDRHY0QyxjQUFjb0YsU0FBUyxDQUFDOHZDLFNBQVMsR0FBRyxTQUFTL2dCLEtBQUssRUFBRUMsS0FBSztvQkFDckR2ekIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3d4QixTQUFTQztvQkFDbEMsSUFBSUQsU0FBUyxJQUFJLENBQUNta0IsWUFBWSxJQUFJbGtCLFNBQVMsSUFBSSxDQUFDbWtCLFlBQVksRUFBRTt3QkFDMUQsSUFBSSxDQUFDcDBCLE9BQU8sQ0FBQ3hkLFFBQVEsQ0FBQzt3QkFDdEIsSUFBSSxDQUFDeWQsT0FBTyxDQUFDemQsUUFBUSxDQUFDO3dCQUN0QixJQUFJLENBQUMwakMsU0FBUyxDQUFDaEYsQ0FBQyxHQUFHO3dCQUNuQixJQUFJLENBQUNpVCxZQUFZLEdBQUdua0I7d0JBQ3BCLElBQUksQ0FBQ29rQixZQUFZLEdBQUdua0I7b0JBQ3hCO2dCQUNKO2dCQUVBcDBCLGNBQWNvRixTQUFTLENBQUN1ZixVQUFVLEdBQUc7b0JBQ2pDLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN2YSxhQUFhLENBQUMsSUFBSSxDQUFDa2dDLGNBQWM7Z0JBQ3pEO2dCQUVBOXBDLGNBQWNvRixTQUFTLENBQUN3ZixVQUFVLEdBQUc7b0JBQ2pDLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN4YSxhQUFhLENBQUMsSUFBSSxDQUFDb2dDLGNBQWM7Z0JBQ3pEO2dCQUVBOztDQUVDLEdBQ0RocUMsY0FBY29GLFNBQVMsQ0FBQ3lmLGdCQUFnQixHQUFHLFNBQVNDLE1BQU07b0JBQ3RELE9BQU94bUIsS0FBS2tvQixHQUFHLENBQUMsSUFBSSxDQUFDNmpCLFNBQVMsQ0FBQ3hzQixDQUFDLEVBQUUsSUFBSSxDQUFDd3NCLFNBQVMsQ0FBQ3RzQixDQUFDLEVBQUUzUyxHQUFHLENBQUMwWjtnQkFDNUQ7Z0JBRUE7OztDQUdDLEdBQ0Q5a0IsY0FBY29GLFNBQVMsQ0FBQzJmLGlCQUFpQixHQUFHLFNBQVNELE1BQU07b0JBQ3ZELE9BQU9BLFNBQVMsSUFBSSxDQUFDdWxCLFNBQVMsQ0FBQ2hGLENBQUM7Z0JBQ3BDO2dCQUVBcmxDLGNBQWNvRixTQUFTLENBQUM4Zix1QkFBdUIsR0FBRyxTQUFTMVQsSUFBSTtvQkFDM0QsSUFBSSxDQUFDbTVCLGNBQWMsR0FBRyxJQUFJLENBQUN4bUIsT0FBTyxDQUFDamdCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3RELElBQUksQ0FBQ3loQyxjQUFjLEdBQUcsSUFBSSxDQUFDeG1CLE9BQU8sQ0FBQ2xnQixPQUFPLENBQUNpRixXQUFXO29CQUN0RCxJQUFJLENBQUMwaEMsVUFBVSxHQUFHLElBQUksQ0FBQzFtQixPQUFPLENBQUMxZ0IsU0FBUztvQkFDeEMsSUFBSSxDQUFDcW5DLFVBQVUsR0FBRyxJQUFJLENBQUMxbUIsT0FBTyxDQUFDM2dCLFNBQVM7b0JBQ3hDLElBQUksQ0FBQ3NuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3hnQixNQUFNO29CQUNsQyxJQUFJLENBQUNxbkMsT0FBTyxHQUFHLElBQUksQ0FBQzVtQixPQUFPLENBQUN6Z0IsTUFBTTtvQkFDbEMsSUFBSWlVLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSThjLEtBQUssSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSTZRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSTROLEtBQUssSUFBSSxDQUFDc00sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSWdkLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUkrUSxLQUFLLElBQUksQ0FBQ3VKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJd2hDLEtBQUsvc0MsSUFBSTZuQixHQUFHLENBQUM1TztvQkFDakIsSUFBSSt6QixLQUFLaHRDLElBQUk2bkIsR0FBRyxDQUFDMU87b0JBQ2pCLElBQUksQ0FBQzJ5QixJQUFJLEdBQUc5ckMsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJcHRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDdWdDLGNBQWMsRUFBRSxJQUFJLENBQUNhLGNBQWM7b0JBQzdFLElBQUksQ0FBQ0QsSUFBSSxHQUFHL3JDLElBQUk0TyxPQUFPLENBQUNvK0IsSUFBSXJ0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3lnQyxjQUFjLEVBQUUsSUFBSSxDQUFDWSxjQUFjO29CQUM3RSw4QkFBOEI7b0JBQzlCLGNBQWM7b0JBQ2QscUJBQXFCO29CQUNyQixTQUFTO29CQUNULHlFQUF5RTtvQkFDekUsb0VBQW9FO29CQUNwRSwwQ0FBMEM7b0JBQzFDLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsVUFBVTtvQkFDeEIsSUFBSXB6QixLQUFLLElBQUksQ0FBQ3F6QixVQUFVO29CQUN4QixRQUFRO29CQUNSLElBQUl0ekIsS0FBSyxJQUFJLENBQUN1ekIsT0FBTztvQkFDckIsSUFBSXJ6QixLQUFLLElBQUksQ0FBQ3N6QixPQUFPO29CQUNyQixRQUFRO29CQUNSLElBQUk5b0MsZ0JBQWdCc1YsS0FBS0UsT0FBTztvQkFDaEMsT0FBTztvQkFDUCxJQUFJLENBQUNsVSxNQUFNLENBQUMyWSxFQUFFLENBQUMwQixDQUFDLEdBQUd0RyxLQUFLRSxLQUFLLElBQUksQ0FBQ2d6QixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHLElBQUksQ0FBQzBzQixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHdkcsS0FBSyxJQUFJLENBQUNrekIsSUFBSSxDQUFDM3NCLENBQUMsR0FBRyxJQUFJLENBQUMyc0IsSUFBSSxDQUFDM3NCLENBQUMsR0FBR3JHO29CQUMxRixJQUFJLENBQUNsVSxNQUFNLENBQUM0WSxFQUFFLENBQUN5QixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM0c0IsSUFBSSxDQUFDMXNCLENBQUMsR0FBRyxJQUFJLENBQUMwc0IsSUFBSSxDQUFDNXNCLENBQUMsR0FBR3JHLEtBQUssSUFBSSxDQUFDa3pCLElBQUksQ0FBQzNzQixDQUFDLEdBQUcsSUFBSSxDQUFDMnNCLElBQUksQ0FBQzdzQixDQUFDLEdBQUduRztvQkFDakYsSUFBSSxDQUFDbFUsTUFBTSxDQUFDMmhDLEVBQUUsQ0FBQ3RuQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM0c0IsSUFBSSxDQUFDMXNCLENBQUMsR0FBR3ZHLEtBQUssSUFBSSxDQUFDa3pCLElBQUksQ0FBQzNzQixDQUFDLEdBQUdyRztvQkFDckQsSUFBSSxDQUFDbFUsTUFBTSxDQUFDMlksRUFBRSxDQUFDNEIsQ0FBQyxHQUFHLElBQUksQ0FBQ3ZhLE1BQU0sQ0FBQzRZLEVBQUUsQ0FBQ3lCLENBQUM7b0JBQ25DLElBQUksQ0FBQ3JhLE1BQU0sQ0FBQzRZLEVBQUUsQ0FBQzJCLENBQUMsR0FBR3hHLEtBQUtFLEtBQUssSUFBSSxDQUFDZ3pCLElBQUksQ0FBQzVzQixDQUFDLEdBQUcsSUFBSSxDQUFDNHNCLElBQUksQ0FBQzVzQixDQUFDLEdBQUdyRyxLQUFLLElBQUksQ0FBQ2t6QixJQUFJLENBQUM3c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzZzQixJQUFJLENBQUM3c0IsQ0FBQyxHQUFHbkc7b0JBQzFGLElBQUksQ0FBQ2xVLE1BQU0sQ0FBQzJoQyxFQUFFLENBQUNwbkIsQ0FBQyxHQUFHLElBQUksQ0FBQzBzQixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHckcsS0FBSyxJQUFJLENBQUNrekIsSUFBSSxDQUFDN3NCLENBQUMsR0FBR25HO29CQUNwRCxJQUFJLENBQUNsVSxNQUFNLENBQUMyWSxFQUFFLENBQUNrcEIsQ0FBQyxHQUFHLElBQUksQ0FBQzdoQyxNQUFNLENBQUMyaEMsRUFBRSxDQUFDdG5CLENBQUM7b0JBQ25DLElBQUksQ0FBQ3JhLE1BQU0sQ0FBQzRZLEVBQUUsQ0FBQ2lwQixDQUFDLEdBQUcsSUFBSSxDQUFDN2hDLE1BQU0sQ0FBQzJoQyxFQUFFLENBQUNwbkIsQ0FBQztvQkFDbkMsSUFBSSxDQUFDdmEsTUFBTSxDQUFDMmhDLEVBQUUsQ0FBQ0UsQ0FBQyxHQUFHN3RCLEtBQUtFO29CQUN4QixJQUFJLENBQUNrOEIsV0FBVyxHQUFHcDhCLEtBQUtFO29CQUN4QixJQUFJLElBQUksQ0FBQ2s4QixXQUFXLEdBQUcsR0FBRzt3QkFDdEIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSSxJQUFJLENBQUNBLFdBQVc7b0JBQzNDO29CQUNBLElBQUksSUFBSSxDQUFDTyxhQUFhLElBQUksU0FBU2p5QyxlQUFlO3dCQUM5QyxJQUFJLENBQUMyeEMsY0FBYyxHQUFHO29CQUMxQjtvQkFDQSxJQUFJLElBQUksQ0FBQ0ssYUFBYSxJQUFJaHlDLGlCQUFpQixPQUFPO3dCQUM5QyxJQUFJMDJDLGFBQWE5Z0MsS0FBS0YsS0FBSyxJQUFJLENBQUNzMkIsZ0JBQWdCO3dCQUNoRCxRQUFRO3dCQUNSLElBQUk3dkMsTUFBSzBoQixHQUFHLENBQUMsSUFBSSxDQUFDdzRCLFlBQVksR0FBRyxJQUFJLENBQUNELFlBQVksSUFBSSxJQUFJNTNDLFNBQVN3bkIsV0FBVyxFQUFFOzRCQUM1RSxJQUFJLENBQUNrc0IsWUFBWSxHQUFHbkI7d0JBQ3hCLE9BQU8sSUFBSTJGLGNBQWMsSUFBSSxDQUFDTixZQUFZLEVBQUU7NEJBQ3hDLElBQUksSUFBSSxDQUFDbEUsWUFBWSxJQUFJckIsY0FBYztnQ0FDbkMsSUFBSSxDQUFDMUksU0FBUyxDQUFDaEYsQ0FBQyxHQUFHOzRCQUN2Qjs0QkFDQSxJQUFJLENBQUMrTyxZQUFZLEdBQUdyQjt3QkFDeEIsT0FBTyxJQUFJNkYsY0FBYyxJQUFJLENBQUNMLFlBQVksRUFBRTs0QkFDeEMsSUFBSSxJQUFJLENBQUNuRSxZQUFZLElBQUlwQixjQUFjO2dDQUNuQyxJQUFJLENBQUMzSSxTQUFTLENBQUNoRixDQUFDLEdBQUc7NEJBQ3ZCOzRCQUNBLElBQUksQ0FBQytPLFlBQVksR0FBR3BCO3dCQUN4QixPQUFPOzRCQUNILElBQUksQ0FBQ29CLFlBQVksR0FBR3RCOzRCQUNwQixJQUFJLENBQUN6SSxTQUFTLENBQUNoRixDQUFDLEdBQUc7d0JBQ3ZCO29CQUNKLE9BQU87d0JBQ0gsSUFBSSxDQUFDK08sWUFBWSxHQUFHdEI7b0JBQ3hCO29CQUNBLElBQUl0aEMsS0FBS2dCLFlBQVksRUFBRTt3QkFDbkIsa0RBQWtEO3dCQUNsRCxJQUFJLENBQUM2M0IsU0FBUyxDQUFDai9CLEdBQUcsQ0FBQ29HLEtBQUtrQixPQUFPO3dCQUMvQixJQUFJLENBQUNtaEMsY0FBYyxJQUFJcmlDLEtBQUtrQixPQUFPO3dCQUNuQyxJQUFJK0csSUFBSW5iLEtBQUtrb0IsR0FBRyxDQUFDLElBQUksQ0FBQzZqQixTQUFTLENBQUN4c0IsQ0FBQyxFQUFFLElBQUksQ0FBQ3dzQixTQUFTLENBQUN0c0IsQ0FBQzt3QkFDbkRyRCxHQUFHZixNQUFNLENBQUNwQyxJQUFJa0M7d0JBQ2RrQixNQUFNbkQsS0FBTWxaLENBQUFBLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRWh4QixLQUFLLElBQUksQ0FBQ282QixjQUFjLEdBQUcsSUFBSSxDQUFDeEosU0FBUyxDQUFDaEYsQ0FBQyxBQUFEQTt3QkFDNUV6cUIsR0FBR3pQLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZG9CLE1BQU1uRCxLQUFNcFosQ0FBQUEsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFanhCLEtBQUssSUFBSSxDQUFDbzZCLGNBQWMsR0FBRyxJQUFJLENBQUN4SixTQUFTLENBQUNoRixDQUFDLEFBQURBO29CQUNoRixPQUFPO3dCQUNILElBQUksQ0FBQ2dGLFNBQVMsQ0FBQzdqQyxPQUFPO3dCQUN0QixJQUFJLENBQUNxdEMsY0FBYyxHQUFHO29CQUMxQjtvQkFDQSxJQUFJLENBQUMxdkIsT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQyxHQUFHNFE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUMsR0FBR3lRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQyxHQUFHOFE7b0JBQzVCLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDLEdBQUcyUTtnQkFDaEM7Z0JBRUE3YSxjQUFjb0YsU0FBUyxDQUFDK2Ysd0JBQXdCLEdBQUcsU0FBUzNULElBQUk7b0JBQzVELElBQUlrSixLQUFLLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUk2USxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUkwUSxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJK1EsS0FBSyxJQUFJLENBQUN1SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSXFOLEtBQUssSUFBSSxDQUFDc3pCLFVBQVU7b0JBQ3hCLElBQUlwekIsS0FBSyxJQUFJLENBQUNxekIsVUFBVTtvQkFDeEIsUUFBUTtvQkFDUixJQUFJdHpCLEtBQUssSUFBSSxDQUFDdXpCLE9BQU87b0JBQ3JCLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsT0FBTztvQkFDckIsUUFBUTtvQkFDUixJQUFJOW9DLGdCQUFnQnNWLEtBQUtFLE9BQU87b0JBQ2hDLE9BQU87b0JBQ1AsMEJBQTBCO29CQUMxQixJQUFJLElBQUksQ0FBQ3k4QixhQUFhLElBQUksSUFBSSxDQUFDQyxZQUFZLElBQUluQixlQUFlL3dDLGlCQUFpQixPQUFPO3dCQUNsRixJQUFJaXFDLE9BQU90eEIsS0FBS0YsS0FBSyxJQUFJLENBQUNzNUIsWUFBWTt3QkFDdEMsUUFBUTt3QkFDUixJQUFJam9DLFVBQVUsQ0FBQyxJQUFJLENBQUM0bkMsV0FBVyxHQUFHekg7d0JBQ2xDLFFBQVE7d0JBQ1IsSUFBSWMsYUFBYSxJQUFJLENBQUM0RyxjQUFjO3dCQUNwQyxRQUFRO3dCQUNSLElBQUkzRyxhQUFhMTdCLEtBQUs0WSxFQUFFLEdBQUcsSUFBSSxDQUFDb3VCLGdCQUFnQjt3QkFDaEQsUUFBUTt3QkFDUixJQUFJLENBQUMzRSxjQUFjLEdBQUd4MUMsTUFBSythLEtBQUssQ0FBQyxJQUFJLENBQUN5NkIsY0FBYyxHQUFHN25DLFNBQVMsQ0FBQ2toQyxZQUFZQTt3QkFDN0VsaEMsVUFBVSxJQUFJLENBQUM2bkMsY0FBYyxHQUFHNUc7d0JBQ2hDdHlCLE1BQU1uRCxLQUFLeEw7d0JBQ1g2TyxNQUFNbkQsS0FBSzFMO29CQUNmO29CQUNBLDBCQUEwQjtvQkFDMUIsSUFBSSxJQUFJLENBQUNrb0MsYUFBYSxJQUFJLElBQUksQ0FBQ0UsWUFBWSxJQUFJdEIsaUJBQWlCNXdDLGlCQUFpQixPQUFPO3dCQUNwRixJQUFJNnpDLFFBQVF6M0MsS0FBS3NELElBQUk7d0JBQ3JCbTBDLE1BQU12TixVQUFVLENBQUMsR0FBRzV0QixJQUFJLEdBQUd0YyxLQUFLbUwsS0FBSyxDQUFDb1IsSUFBSSxJQUFJLENBQUM2dkIsSUFBSTt3QkFDbkRxTCxNQUFNck4sVUFBVSxDQUFDLEdBQUdodUIsSUFBSSxHQUFHcGMsS0FBS21MLEtBQUssQ0FBQ2tSLElBQUksSUFBSSxDQUFDOHZCLElBQUk7d0JBQ25ELElBQUl1TCxRQUFRbjdCLEtBQUtGO3dCQUNqQixRQUFRO3dCQUNSLElBQUl3eEIsT0FBTzV0QyxLQUFLdzNDLE1BQU1sNEIsQ0FBQyxFQUFFazRCLE1BQU1oNEIsQ0FBQyxFQUFFaTRCO3dCQUNsQyxJQUFJaHFDLFVBQVV6TixLQUFLKzZCLEdBQUcsQ0FBQyxJQUFJLENBQUM5MUIsTUFBTSxDQUFDNGhDLE9BQU8sQ0FBQytHO3dCQUMzQyxPQUFPO3dCQUNQLElBQUksSUFBSSxDQUFDaUksWUFBWSxJQUFJbkIsYUFBYTs0QkFDbEMsSUFBSSxDQUFDNUksU0FBUyxDQUFDN2dDLEdBQUcsQ0FBQ3dDO3dCQUN2QixPQUFPLElBQUksSUFBSSxDQUFDb29DLFlBQVksSUFBSXJCLGNBQWM7NEJBQzFDLElBQUl4MEIsYUFBYSxJQUFJLENBQUM4ckIsU0FBUyxDQUFDaEYsQ0FBQyxHQUFHcjVCLFFBQVFxNUIsQ0FBQzs0QkFDN0MsUUFBUTs0QkFDUixJQUFJOW1CLGFBQWEsR0FBRztnQ0FDaEIsSUFBSXM2QixNQUFNdjZDLEtBQUs2a0IsT0FBTyxDQUFDLENBQUMsR0FBRzR5QixPQUFPLElBQUksQ0FBQzFMLFNBQVMsQ0FBQ2hGLENBQUMsRUFBRS9tQyxLQUFLa29CLEdBQUcsQ0FBQyxJQUFJLENBQUNoakIsTUFBTSxDQUFDMmhDLEVBQUUsQ0FBQ3RuQixDQUFDLEVBQUUsSUFBSSxDQUFDcmEsTUFBTSxDQUFDMmhDLEVBQUUsQ0FBQ3BuQixDQUFDO2dDQUMvRixPQUFPO2dDQUNQLElBQUkrNkIsVUFBVSxJQUFJLENBQUN0MUMsTUFBTSxDQUFDOGhDLE9BQU8sQ0FBQ3VUO2dDQUNsQyxPQUFPO2dDQUNQN3NDLFFBQVE2UixDQUFDLEdBQUdpN0IsUUFBUWo3QixDQUFDO2dDQUNyQjdSLFFBQVErUixDQUFDLEdBQUcrNkIsUUFBUS82QixDQUFDO2dDQUNyQi9SLFFBQVFxNUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDZ0YsU0FBUyxDQUFDaEYsQ0FBQztnQ0FDN0IsSUFBSSxDQUFDZ0YsU0FBUyxDQUFDeHNCLENBQUMsSUFBSWk3QixRQUFRajdCLENBQUM7Z0NBQzdCLElBQUksQ0FBQ3dzQixTQUFTLENBQUN0c0IsQ0FBQyxJQUFJKzZCLFFBQVEvNkIsQ0FBQztnQ0FDN0IsSUFBSSxDQUFDc3NCLFNBQVMsQ0FBQ2hGLENBQUMsR0FBRzs0QkFDdkIsT0FBTztnQ0FDSCxJQUFJLENBQUNnRixTQUFTLENBQUM3Z0MsR0FBRyxDQUFDd0M7NEJBQ3ZCO3dCQUNKLE9BQU8sSUFBSSxJQUFJLENBQUNvb0MsWUFBWSxJQUFJcEIsY0FBYzs0QkFDMUMsSUFBSXowQixhQUFhLElBQUksQ0FBQzhyQixTQUFTLENBQUNoRixDQUFDLEdBQUdyNUIsUUFBUXE1QixDQUFDOzRCQUM3QyxRQUFROzRCQUNSLElBQUk5bUIsYUFBYSxHQUFHO2dDQUNoQixJQUFJczZCLE1BQU12NkMsS0FBSzZrQixPQUFPLENBQUMsQ0FBQyxHQUFHNHlCLE9BQU8sSUFBSSxDQUFDMUwsU0FBUyxDQUFDaEYsQ0FBQyxFQUFFL21DLEtBQUtrb0IsR0FBRyxDQUFDLElBQUksQ0FBQ2hqQixNQUFNLENBQUMyaEMsRUFBRSxDQUFDdG5CLENBQUMsRUFBRSxJQUFJLENBQUNyYSxNQUFNLENBQUMyaEMsRUFBRSxDQUFDcG5CLENBQUM7Z0NBQy9GLE9BQU87Z0NBQ1AsSUFBSSs2QixVQUFVLElBQUksQ0FBQ3QxQyxNQUFNLENBQUM4aEMsT0FBTyxDQUFDdVQ7Z0NBQ2xDLE9BQU87Z0NBQ1A3c0MsUUFBUTZSLENBQUMsR0FBR2k3QixRQUFRajdCLENBQUM7Z0NBQ3JCN1IsUUFBUStSLENBQUMsR0FBRys2QixRQUFRLzZCLENBQUM7Z0NBQ3JCL1IsUUFBUXE1QixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUNnRixTQUFTLENBQUNoRixDQUFDO2dDQUM3QixJQUFJLENBQUNnRixTQUFTLENBQUN4c0IsQ0FBQyxJQUFJaTdCLFFBQVFqN0IsQ0FBQztnQ0FDN0IsSUFBSSxDQUFDd3NCLFNBQVMsQ0FBQ3RzQixDQUFDLElBQUkrNkIsUUFBUS82QixDQUFDO2dDQUM3QixJQUFJLENBQUNzc0IsU0FBUyxDQUFDaEYsQ0FBQyxHQUFHOzRCQUN2QixPQUFPO2dDQUNILElBQUksQ0FBQ2dGLFNBQVMsQ0FBQzdnQyxHQUFHLENBQUN3Qzs0QkFDdkI7d0JBQ0o7d0JBQ0EsSUFBSXlOLElBQUluYixLQUFLa29CLEdBQUcsQ0FBQ3hhLFFBQVE2UixDQUFDLEVBQUU3UixRQUFRK1IsQ0FBQzt3QkFDckNyRCxHQUFHZixNQUFNLENBQUNwQyxJQUFJa0M7d0JBQ2RrQixNQUFNbkQsS0FBTWxaLENBQUFBLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRWh4QixLQUFLek4sUUFBUXE1QixDQUFDLEFBQURBO3dCQUMvQ3pxQixHQUFHelAsTUFBTSxDQUFDc00sSUFBSWdDO3dCQUNkb0IsTUFBTW5ELEtBQU1wWixDQUFBQSxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUVqeEIsS0FBS3pOLFFBQVFxNUIsQ0FBQyxBQUFEQTtvQkFDbkQsT0FBTzt3QkFDSCxrQ0FBa0M7d0JBQ2xDLElBQUk4RyxPQUFPN3RDLEtBQUtzRCxJQUFJO3dCQUNwQnVxQyxLQUFLM0QsVUFBVSxDQUFDLEdBQUc1dEIsSUFBSSxHQUFHdGMsS0FBS21MLEtBQUssQ0FBQ29SLElBQUksSUFBSSxDQUFDNnZCLElBQUk7d0JBQ2xEeUIsS0FBS3pELFVBQVUsQ0FBQyxHQUFHaHVCLElBQUksR0FBR3BjLEtBQUttTCxLQUFLLENBQUNrUixJQUFJLElBQUksQ0FBQzh2QixJQUFJO3dCQUNsRCxJQUFJeitCLFVBQVUsSUFBSSxDQUFDeEksTUFBTSxDQUFDOGhDLE9BQU8sQ0FBQ2huQyxLQUFLZzdCLEdBQUcsQ0FBQzZTO3dCQUMzQyxPQUFPO3dCQUNQLElBQUksQ0FBQzlCLFNBQVMsQ0FBQ3hzQixDQUFDLElBQUk3UixRQUFRNlIsQ0FBQzt3QkFDN0IsSUFBSSxDQUFDd3NCLFNBQVMsQ0FBQ3RzQixDQUFDLElBQUkvUixRQUFRK1IsQ0FBQzt3QkFDN0JyRCxHQUFHZixNQUFNLENBQUNwQyxJQUFJdkw7d0JBQ2QyTyxNQUFNbkQsS0FBS2xaLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRXorQjt3QkFDakM0TyxHQUFHelAsTUFBTSxDQUFDc00sSUFBSXpMO3dCQUNkNk8sTUFBTW5ELEtBQUtwWixLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUUxK0I7b0JBQ3JDO29CQUNBLElBQUksQ0FBQ21ZLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzRRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzhRO29CQUM1QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBN2EsY0FBY29GLFNBQVMsQ0FBQ2dnQix3QkFBd0IsR0FBRyxTQUFTNVQsSUFBSTtvQkFDNUQsSUFBSW1HLEtBQUssSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsSUFBSWlQLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSWlhLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDL2YsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsSUFBSW1QLEtBQUssSUFBSSxDQUFDc00sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSTh0QyxLQUFLL3NDLElBQUk2bkIsR0FBRyxDQUFDNU87b0JBQ2pCLElBQUkrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixJQUFJdytCLGVBQWU7b0JBQ25CLFFBQVE7b0JBQ1IsSUFBSXlDLGdCQUFnQjtvQkFDcEIsUUFBUTtvQkFDUixJQUFJNzJDLGdCQUFnQixJQUFJLENBQUM2b0MsT0FBTyxHQUFHLElBQUksQ0FBQ0MsT0FBTyxJQUFJO29CQUNuRCxPQUFPO29CQUNQLGtDQUFrQztvQkFDbEMsSUFBSSxJQUFJLENBQUNrSixhQUFhLElBQUksSUFBSSxDQUFDRSxZQUFZLElBQUl0QixpQkFBaUI1d0MsaUJBQWlCLE9BQU87d0JBQ3BGLElBQUlMLFFBQVFpVyxLQUFLRixLQUFLLElBQUksQ0FBQ3MyQixnQkFBZ0I7d0JBQzNDLFFBQVE7d0JBQ1IsSUFBSThLLGVBQWU7d0JBQ25CLFFBQVE7d0JBQ1IsSUFBSSxJQUFJLENBQUM1RSxZQUFZLElBQUluQixhQUFhOzRCQUNsQyxvQ0FBb0M7NEJBQ3BDLElBQUk5NUIsSUFBSTlhLE1BQUsrYSxLQUFLLENBQUN2WCxRQUFRLElBQUksQ0FBQ3kyQyxZQUFZLEVBQUUsQ0FBQzUzQyxTQUFTK25CLG9CQUFvQixFQUFFL25CLFNBQVMrbkIsb0JBQW9COzRCQUMzRyxRQUFROzRCQUNSdXdCLGVBQWUsQ0FBQyxJQUFJLENBQUNwRixXQUFXLEdBQUd6NkI7NEJBQ25DbTlCLGVBQWVqNEMsTUFBSzBoQixHQUFHLENBQUM1Rzt3QkFDNUIsT0FBTyxJQUFJLElBQUksQ0FBQ2k3QixZQUFZLElBQUlyQixjQUFjOzRCQUMxQyxJQUFJNTVCLElBQUl0WCxRQUFRLElBQUksQ0FBQ3kyQyxZQUFZOzRCQUNqQyxRQUFROzRCQUNSaEMsZUFBZSxDQUFDbjlCOzRCQUNoQix5REFBeUQ7NEJBQ3pEQSxJQUFJOWEsTUFBSythLEtBQUssQ0FBQ0QsSUFBSXpZLFNBQVN3bkIsV0FBVyxFQUFFLENBQUN4bkIsU0FBUytuQixvQkFBb0IsRUFBRTs0QkFDekV1d0IsZUFBZSxDQUFDLElBQUksQ0FBQ3BGLFdBQVcsR0FBR3o2Qjt3QkFDdkMsT0FBTyxJQUFJLElBQUksQ0FBQ2k3QixZQUFZLElBQUlwQixjQUFjOzRCQUMxQyxJQUFJNzVCLElBQUl0WCxRQUFRLElBQUksQ0FBQzAyQyxZQUFZOzRCQUNqQyxRQUFROzRCQUNSakMsZUFBZW45Qjs0QkFDZix5REFBeUQ7NEJBQ3pEQSxJQUFJOWEsTUFBSythLEtBQUssQ0FBQ0QsSUFBSXpZLFNBQVN3bkIsV0FBVyxFQUFFLEdBQUd4bkIsU0FBUytuQixvQkFBb0I7NEJBQ3pFdXdCLGVBQWUsQ0FBQyxJQUFJLENBQUNwRixXQUFXLEdBQUd6NkI7d0JBQ3ZDO3dCQUNBdkIsTUFBTSxJQUFJLENBQUNtekIsT0FBTyxHQUFHaU87d0JBQ3JCbGhDLE1BQU0sSUFBSSxDQUFDa3pCLE9BQU8sR0FBR2dPO29CQUN6QjtvQkFDQSxtQ0FBbUM7b0JBQ25DO3dCQUNJdE4sR0FBR3JqQyxHQUFHLENBQUN1UDt3QkFDUCt6QixHQUFHdGpDLEdBQUcsQ0FBQ3lQO3dCQUNQLElBQUlsRixLQUFLalUsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJcHRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDdWdDLGNBQWMsRUFBRSxJQUFJLENBQUNhLGNBQWM7d0JBQzFFLE9BQU87d0JBQ1AsSUFBSTkzQixLQUFLbFUsSUFBSTRPLE9BQU8sQ0FBQ28rQixJQUFJcnRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDeWdDLGNBQWMsRUFBRSxJQUFJLENBQUNZLGNBQWM7d0JBQzFFLE9BQU87d0JBQ1AsSUFBSXp4QixJQUFJN2EsS0FBS3NELElBQUk7d0JBQ2pCdVgsRUFBRXF2QixVQUFVLENBQUMsR0FBRzN3QixJQUFJLEdBQUdoRjt3QkFDdkJzRyxFQUFFdXZCLFVBQVUsQ0FBQyxHQUFHL3dCLElBQUksR0FBRy9FO3dCQUN2Qm1tQyxnQkFBZ0I1L0IsRUFBRWhiLE1BQU07d0JBQ3hCLElBQUlvWixLQUFLLElBQUksQ0FBQ3N6QixVQUFVO3dCQUN4QixJQUFJcHpCLEtBQUssSUFBSSxDQUFDcXpCLFVBQVU7d0JBQ3hCLFFBQVE7d0JBQ1IsSUFBSXR6QixLQUFLLElBQUksQ0FBQ3V6QixPQUFPO3dCQUNyQixJQUFJcnpCLEtBQUssSUFBSSxDQUFDc3pCLE9BQU87d0JBQ3JCLFFBQVE7d0JBQ1IsSUFBSXh4QixJQUFJLElBQUloYjt3QkFDWmdiLEVBQUUyQyxFQUFFLENBQUMwQixDQUFDLEdBQUd0RyxLQUFLRSxLQUFLRCxLQUFLNUUsR0FBR21MLENBQUMsR0FBR25MLEdBQUdtTCxDQUFDLEdBQUdyRyxLQUFLN0UsR0FBR2tMLENBQUMsR0FBR2xMLEdBQUdrTCxDQUFDO3dCQUN0RHZFLEVBQUUyQyxFQUFFLENBQUM0QixDQUFDLEdBQUcsQ0FBQ3ZHLEtBQUs1RSxHQUFHaUwsQ0FBQyxHQUFHakwsR0FBR21MLENBQUMsR0FBR3JHLEtBQUs3RSxHQUFHZ0wsQ0FBQyxHQUFHaEwsR0FBR2tMLENBQUM7d0JBQzdDdkUsRUFBRTRDLEVBQUUsQ0FBQ3lCLENBQUMsR0FBR3JFLEVBQUUyQyxFQUFFLENBQUM0QixDQUFDO3dCQUNmdkUsRUFBRTRDLEVBQUUsQ0FBQzJCLENBQUMsR0FBR3hHLEtBQUtFLEtBQUtELEtBQUs1RSxHQUFHaUwsQ0FBQyxHQUFHakwsR0FBR2lMLENBQUMsR0FBR25HLEtBQUs3RSxHQUFHZ0wsQ0FBQyxHQUFHaEwsR0FBR2dMLENBQUM7d0JBQ3RELElBQUk3UixVQUFVMU4sS0FBS2c3QixHQUFHLENBQUM5ZixFQUFFeWYsS0FBSyxDQUFDOWY7d0JBQy9CLE9BQU87d0JBQ1B4QixHQUFHZ0MsTUFBTSxDQUFDcEMsSUFBSXZMO3dCQUNkNEwsTUFBTUosS0FBS2xaLEtBQUttTCxLQUFLLENBQUNtSixJQUFJNUc7d0JBQzFCNkwsR0FBRzFNLE1BQU0sQ0FBQ3NNLElBQUl6TDt3QkFDZDhMLE1BQU1KLEtBQUtwWixLQUFLbUwsS0FBSyxDQUFDb0osSUFBSTdHO29CQUM5QjtvQkFDQSxJQUFJLENBQUNtWSxPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3NQO29CQUM5QixJQUFJLENBQUN3TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDLEdBQUdnYTtvQkFDNUIsSUFBSSxDQUFDd00sT0FBTyxDQUFDL2YsVUFBVSxDQUFDc0UsQ0FBQyxDQUFDTixHQUFHLENBQUN3UDtvQkFDOUIsSUFBSSxDQUFDdU0sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQyxHQUFHa2E7b0JBQzVCLE9BQU9paEMsaUJBQWlCcjRDLFNBQVN1WSxVQUFVLElBQUlxOUIsZ0JBQWdCNTFDLFNBQVN3bkIsV0FBVztnQkFDdkY7WUFHQTtZQUFFO2dCQUFDLFlBQVc7Z0JBQUUsZUFBYztnQkFBRSxtQkFBa0I7Z0JBQUcsbUJBQWtCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsaUJBQWdCO2dCQUFHLG1CQUFrQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxtQkFBa0I7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNycUIsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3pWLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHb0Q7Z0JBRWpCLElBQUllLFVBQVVuRCxTQUFRO2dCQUV0QixJQUFJMGlCLFNBQVMxaUIsU0FBUTtnQkFFckIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJUSxRQUFPUixTQUFRO2dCQUVuQixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJVSxPQUFPVixTQUFRO2dCQUVuQixJQUFJVyxRQUFRWCxTQUFRO2dCQUVwQixJQUFJWSxRQUFRWixTQUFRO2dCQUVwQixJQUFJYyxNQUFNZCxTQUFRO2dCQUVsQixJQUFJdUMsUUFBUXZDLFNBQVE7Z0JBRXBCLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUlvRCxXQUFXcEQsU0FBUTtnQkFFdkIsSUFBSXFELFdBQVdyRCxTQUFRO2dCQUV2QixJQUFJb0IsUUFBUXBCLFNBQVE7Z0JBRXBCLElBQUlpMUMsZ0JBQWdCO2dCQUVwQixJQUFJQyxlQUFlO2dCQUVuQixJQUFJQyxlQUFlO2dCQUVuQixJQUFJQyxjQUFjO2dCQUVsQmh6QyxVQUFVdXBDLElBQUksR0FBRztnQkFFakJ2cEMsVUFBVXdwQyxNQUFNLEdBQUd4cUM7Z0JBRW5CZ0IsVUFBVW1GLFNBQVMsR0FBR21iLE9BQU90Z0IsVUFBVXdwQyxNQUFNLENBQUNya0MsU0FBUztnQkFFdkQ7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsSUFBSTZlLFdBQVc7b0JBQ1hnMUIsV0FBVztnQkFDZjtnQkFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVNoNUMsVUFBVXlDLEdBQUcsRUFBRWtQLEtBQUssRUFBRUUsS0FBSyxFQUFFdzZCLE1BQU07b0JBQ3hDLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWXJzQyxTQUFRLEdBQUk7d0JBQzlCLE9BQU8sSUFBSUEsVUFBVXlDLEtBQUtrUCxPQUFPRSxPQUFPdzZCO29CQUM1QztvQkFDQTVwQyxNQUFNMUIsUUFBUTBCLEtBQUt1aEI7b0JBQ25CaGxCLE1BQU1mLElBQUksQ0FBQyxJQUFJLEVBQUV3RSxLQUFLa1AsT0FBT0U7b0JBQzdCRixRQUFRLElBQUksQ0FBQ3VTLE9BQU87b0JBQ3BCclMsUUFBUSxJQUFJLENBQUNzUyxPQUFPO29CQUNwQixJQUFJLENBQUM3Z0IsTUFBTSxHQUFHdEQsVUFBVXVwQyxJQUFJO29CQUM1QixJQUFJLENBQUNNLGNBQWMsR0FBR3dDLFNBQVMxNkIsTUFBTWxFLGFBQWEsQ0FBQzQrQixVQUFVNXBDLElBQUlxbkMsWUFBWSxJQUFJenJDLEtBQUtrb0IsR0FBRyxDQUFDLENBQUMsR0FBRztvQkFDOUYsSUFBSSxDQUFDd2pCLGNBQWMsR0FBR3NDLFNBQVN4NkIsTUFBTXBFLGFBQWEsQ0FBQzQrQixVQUFVNXBDLElBQUl1bkMsWUFBWSxJQUFJM3JDLEtBQUtrb0IsR0FBRyxDQUFDLEdBQUc7b0JBQzdGLElBQUksQ0FBQzB5QixXQUFXLEdBQUd4MkMsSUFBSXUyQyxTQUFTO29CQUNoQyxJQUFJLENBQUN6MUMsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQzZtQyxTQUFTLEdBQUc7b0JBQ2pCLElBQUksQ0FBQ0gsUUFBUSxHQUFHO29CQUNoQixJQUFJLENBQUNpUCxPQUFPLEdBQUdyRztvQkFDZixjQUFjO29CQUNkLElBQUksQ0FBQ3RJLEdBQUc7b0JBQ1IsT0FBTztvQkFDUCxJQUFJLENBQUNDLElBQUk7b0JBQ1QsT0FBTztvQkFDUCxJQUFJLENBQUNDLElBQUk7b0JBQ1QsT0FBTztvQkFDUCxJQUFJLENBQUNDLGNBQWM7b0JBQ25CLE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxjQUFjO29CQUNuQixPQUFPO29CQUNQLElBQUksQ0FBQ0MsVUFBVTtvQkFDZixRQUFRO29CQUNSLElBQUksQ0FBQ0MsVUFBVTtvQkFDZixRQUFRO29CQUNSLElBQUksQ0FBQ0MsT0FBTztvQkFDWixRQUFRO29CQUNSLElBQUksQ0FBQ0MsT0FBTztvQkFDWixRQUFRO29CQUNSLElBQUksQ0FBQ3huQyxNQUFNO2dCQUNmO2dCQUVBOztDQUVDLEdBQ0R2RCxVQUFVbUYsU0FBUyxDQUFDNmxDLGVBQWUsR0FBRztvQkFDbEMsT0FBTyxJQUFJLENBQUNuQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEN3BDLFVBQVVtRixTQUFTLENBQUM4bEMsZUFBZSxHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ2xCLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0QvcEMsVUFBVW1GLFNBQVMsQ0FBQ2cwQyxZQUFZLEdBQUcsU0FBU2o3QyxNQUFNO29CQUM5QyxJQUFJLENBQUMrNkMsV0FBVyxHQUFHLzZDO2dCQUN2QjtnQkFFQThCLFVBQVVtRixTQUFTLENBQUNpMEMsWUFBWSxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ0gsV0FBVztnQkFDM0I7Z0JBRUFqNUMsVUFBVW1GLFNBQVMsQ0FBQ2swQyxhQUFhLEdBQUc7b0JBQ2hDLGtCQUFrQjtvQkFDbEIsT0FBTyxJQUFJLENBQUNILE9BQU87Z0JBQ3ZCO2dCQUVBbDVDLFVBQVVtRixTQUFTLENBQUN1ZixVQUFVLEdBQUc7b0JBQzdCLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN2YSxhQUFhLENBQUMsSUFBSSxDQUFDa2dDLGNBQWM7Z0JBQ3pEO2dCQUVBN3BDLFVBQVVtRixTQUFTLENBQUN3ZixVQUFVLEdBQUc7b0JBQzdCLE9BQU8sSUFBSSxDQUFDUixPQUFPLENBQUN4YSxhQUFhLENBQUMsSUFBSSxDQUFDb2dDLGNBQWM7Z0JBQ3pEO2dCQUVBL3BDLFVBQVVtRixTQUFTLENBQUN5ZixnQkFBZ0IsR0FBRyxTQUFTQyxNQUFNO29CQUNsRCxPQUFPeG1CLEtBQUs4TSxHQUFHLENBQUMsSUFBSSxDQUFDaS9CLFNBQVMsRUFBRSxJQUFJLENBQUNHLEdBQUcsRUFBRXAvQixHQUFHLENBQUMwWjtnQkFDbEQ7Z0JBRUE3a0IsVUFBVW1GLFNBQVMsQ0FBQzJmLGlCQUFpQixHQUFHLFNBQVNELE1BQU07b0JBQ25ELE9BQU87Z0JBQ1g7Z0JBRUE3a0IsVUFBVW1GLFNBQVMsQ0FBQzhmLHVCQUF1QixHQUFHLFNBQVMxVCxJQUFJO29CQUN2RCxJQUFJLENBQUNtNUIsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNqZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDeWhDLGNBQWMsR0FBRyxJQUFJLENBQUN4bUIsT0FBTyxDQUFDbGdCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3RELElBQUksQ0FBQzBoQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzFnQixTQUFTO29CQUN4QyxJQUFJLENBQUNxbkMsVUFBVSxHQUFHLElBQUksQ0FBQzFtQixPQUFPLENBQUMzZ0IsU0FBUztvQkFDeEMsSUFBSSxDQUFDc25DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDeGdCLE1BQU07b0JBQ2xDLElBQUksQ0FBQ3FuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUNsQyxJQUFJZ1UsS0FBSyxJQUFJLENBQUN3TSxPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJaVAsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOGMsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMk4sS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDO29CQUNsQyxJQUFJbVAsS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJZ2QsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUl3aEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPO29CQUNqQixJQUFJK3pCLEtBQUtodEMsSUFBSTZuQixHQUFHLENBQUMxTztvQkFDakIsSUFBSSxDQUFDMnlCLElBQUksR0FBRzlyQyxJQUFJMG9DLE1BQU0sQ0FBQ3FFLElBQUksSUFBSSxDQUFDNUIsY0FBYyxFQUFFLElBQUksQ0FBQ2EsY0FBYztvQkFDbkUsSUFBSSxDQUFDRCxJQUFJLEdBQUcvckMsSUFBSTBvQyxNQUFNLENBQUNzRSxJQUFJLElBQUksQ0FBQzNCLGNBQWMsRUFBRSxJQUFJLENBQUNZLGNBQWM7b0JBQ25FLElBQUksQ0FBQ0osR0FBRyxHQUFHbHNDLEtBQUtzRCxJQUFJO29CQUNwQixJQUFJLENBQUM0b0MsR0FBRyxDQUFDaEMsVUFBVSxDQUFDLEdBQUczd0IsSUFBSSxHQUFHLElBQUksQ0FBQzZ5QixJQUFJO29CQUN2QyxJQUFJLENBQUNGLEdBQUcsQ0FBQzlCLFVBQVUsQ0FBQyxHQUFHL3dCLElBQUksR0FBRyxJQUFJLENBQUM4eUIsSUFBSTtvQkFDdkMsT0FBTztvQkFDUCxJQUFJLENBQUNQLFFBQVEsR0FBRyxJQUFJLENBQUNNLEdBQUcsQ0FBQ3JzQyxNQUFNO29CQUMvQixJQUFJZ2IsSUFBSSxJQUFJLENBQUMrd0IsUUFBUSxHQUFHLElBQUksQ0FBQ2dQLFdBQVc7b0JBQ3hDLFFBQVE7b0JBQ1IsSUFBSS8vQixJQUFJLEdBQUc7d0JBQ1AsSUFBSSxDQUFDZ2dDLE9BQU8sR0FBR25HO29CQUNuQixPQUFPO3dCQUNILElBQUksQ0FBQ21HLE9BQU8sR0FBR3JHO29CQUNuQjtvQkFDQSxJQUFJLElBQUksQ0FBQzVJLFFBQVEsR0FBR3hwQyxTQUFTdVksVUFBVSxFQUFFO3dCQUNyQyxJQUFJLENBQUN1eEIsR0FBRyxDQUFDcC9CLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQzgrQixRQUFRO29CQUNsQyxPQUFPO3dCQUNILElBQUksQ0FBQ00sR0FBRyxDQUFDaGtDLE9BQU87d0JBQ2hCLElBQUksQ0FBQ2hELE1BQU0sR0FBRzt3QkFDZCxJQUFJLENBQUM2bUMsU0FBUyxHQUFHO3dCQUNqQjtvQkFDSjtvQkFDQSwwQkFBMEI7b0JBQzFCLElBQUlrUCxNQUFNajdDLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDZ2hDLElBQUksRUFBRSxJQUFJLENBQUNELEdBQUc7b0JBQ3hDLFFBQVE7b0JBQ1IsSUFBSWdQLE1BQU1sN0MsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFLElBQUksQ0FBQ0YsR0FBRztvQkFDeEMsUUFBUTtvQkFDUixJQUFJc0IsVUFBVSxJQUFJLENBQUNqQixVQUFVLEdBQUcsSUFBSSxDQUFDRSxPQUFPLEdBQUd3TyxNQUFNQSxNQUFNLElBQUksQ0FBQ3pPLFVBQVUsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBR3dPLE1BQU1BO29CQUNsRyxRQUFRO29CQUNSLElBQUksQ0FBQ2gyQyxNQUFNLEdBQUdzb0MsV0FBVyxJQUFJLElBQUlBLFVBQVU7b0JBQzNDLElBQUl0NkIsS0FBS2dCLFlBQVksRUFBRTt3QkFDbkIscURBQXFEO3dCQUNyRCxJQUFJLENBQUM2M0IsU0FBUyxJQUFJNzRCLEtBQUtrQixPQUFPO3dCQUM5QixJQUFJK0csSUFBSW5iLEtBQUs4TSxHQUFHLENBQUMsSUFBSSxDQUFDaS9CLFNBQVMsRUFBRSxJQUFJLENBQUNHLEdBQUc7d0JBQ3pDOXZCLEdBQUdmLE1BQU0sQ0FBQyxJQUFJLENBQUNreEIsVUFBVSxFQUFFcHhCO3dCQUMzQmtCLE1BQU0sSUFBSSxDQUFDb3dCLE9BQU8sR0FBR3pzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2doQyxJQUFJLEVBQUVoeEI7d0JBQzNDbUIsR0FBR3pQLE1BQU0sQ0FBQyxJQUFJLENBQUMyL0IsVUFBVSxFQUFFcnhCO3dCQUMzQm9CLE1BQU0sSUFBSSxDQUFDbXdCLE9BQU8sR0FBRzFzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUVqeEI7b0JBQy9DLE9BQU87d0JBQ0gsSUFBSSxDQUFDNHdCLFNBQVMsR0FBRztvQkFDckI7b0JBQ0EsSUFBSSxDQUFDbG1CLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3FTO29CQUM5QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3VTO29CQUM5QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBNWEsVUFBVW1GLFNBQVMsQ0FBQytmLHdCQUF3QixHQUFHLFNBQVMzVCxJQUFJO29CQUN4RCxJQUFJa0osS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMFEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLGlDQUFpQztvQkFDakMsSUFBSStoQyxNQUFNM3RDLEtBQUswcUMsUUFBUSxDQUFDdHVCLElBQUlDLElBQUksSUFBSSxDQUFDOHZCLElBQUk7b0JBQ3pDLE9BQU87b0JBQ1AsSUFBSXlCLE1BQU01dEMsS0FBSzBxQyxRQUFRLENBQUNwdUIsSUFBSUMsSUFBSSxJQUFJLENBQUM2dkIsSUFBSTtvQkFDekMsT0FBTztvQkFDUCxJQUFJdnhCLElBQUksSUFBSSxDQUFDK3dCLFFBQVEsR0FBRyxJQUFJLENBQUNnUCxXQUFXO29CQUN4QyxRQUFRO29CQUNSLElBQUkvTSxPQUFPN3RDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDeWdDLEdBQUcsRUFBRWxzQyxLQUFLaUwsR0FBRyxDQUFDMmlDLEtBQUtEO29CQUM1QyxRQUFRO29CQUNSLHlCQUF5QjtvQkFDekIsSUFBSTl5QixJQUFJLEdBQUc7d0JBQ1BnekIsUUFBUTM2QixLQUFLc1QsTUFBTSxHQUFHM0w7b0JBQzFCO29CQUNBLElBQUluTixVQUFVLENBQUMsSUFBSSxDQUFDeEksTUFBTSxHQUFHMm9DO29CQUM3QixRQUFRO29CQUNSLElBQUljLGFBQWEsSUFBSSxDQUFDNUMsU0FBUztvQkFDL0IsUUFBUTtvQkFDUixJQUFJLENBQUNBLFNBQVMsR0FBR2hzQyxNQUFLeWEsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDdXhCLFNBQVMsR0FBR3IrQjtvQkFDOUNBLFVBQVUsSUFBSSxDQUFDcStCLFNBQVMsR0FBRzRDO29CQUMzQixJQUFJeHpCLElBQUluYixLQUFLOE0sR0FBRyxDQUFDWSxTQUFTLElBQUksQ0FBQ3crQixHQUFHO29CQUNsQyxPQUFPO29CQUNQOXZCLEdBQUdmLE1BQU0sQ0FBQyxJQUFJLENBQUNreEIsVUFBVSxFQUFFcHhCO29CQUMzQmtCLE1BQU0sSUFBSSxDQUFDb3dCLE9BQU8sR0FBR3pzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2doQyxJQUFJLEVBQUVoeEI7b0JBQzNDbUIsR0FBR3pQLE1BQU0sQ0FBQyxJQUFJLENBQUMyL0IsVUFBVSxFQUFFcnhCO29CQUMzQm9CLE1BQU0sSUFBSSxDQUFDbXdCLE9BQU8sR0FBRzFzQyxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2loQyxJQUFJLEVBQUVqeEI7b0JBQzNDLElBQUksQ0FBQzBLLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzRRO29CQUM1QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsR0FBRzhRO29CQUM1QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBNWEsVUFBVW1GLFNBQVMsQ0FBQ2dnQix3QkFBd0IsR0FBRyxTQUFTNVQsSUFBSTtvQkFDeEQsSUFBSW1HLEtBQUssSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsT0FBTztvQkFDUCxJQUFJaVAsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxRQUFRO29CQUNSLElBQUlpYSxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLE9BQU87b0JBQ1AsSUFBSW1QLEtBQUssSUFBSSxDQUFDc00sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsUUFBUTtvQkFDUixJQUFJOHRDLEtBQUsvc0MsSUFBSTZuQixHQUFHLENBQUM1TztvQkFDakIsSUFBSSt6QixLQUFLaHRDLElBQUk2bkIsR0FBRyxDQUFDMU87b0JBQ2pCLElBQUlsRixLQUFLalUsSUFBSTBvQyxNQUFNLENBQUNxRSxJQUFJLElBQUksQ0FBQzVCLGNBQWMsRUFBRSxJQUFJLENBQUNhLGNBQWM7b0JBQ2hFLElBQUk5M0IsS0FBS2xVLElBQUkwb0MsTUFBTSxDQUFDc0UsSUFBSSxJQUFJLENBQUMzQixjQUFjLEVBQUUsSUFBSSxDQUFDWSxjQUFjO29CQUNoRSxJQUFJanRDLElBQUlXLEtBQUtzRCxJQUFJO29CQUNqQmpFLEVBQUU2cUMsVUFBVSxDQUFDLEdBQUczd0IsSUFBSSxHQUFHaEY7b0JBQ3ZCbFYsRUFBRStxQyxVQUFVLENBQUMsR0FBRy93QixJQUFJLEdBQUcvRTtvQkFDdkIsT0FBTztvQkFDUCxJQUFJelUsU0FBU1IsRUFBRTZhLFNBQVM7b0JBQ3hCLFFBQVE7b0JBQ1IsSUFBSVcsSUFBSWhiLFNBQVMsSUFBSSxDQUFDKzZDLFdBQVc7b0JBQ2pDLFFBQVE7b0JBQ1IvL0IsSUFBSTlhLE1BQUsrYSxLQUFLLENBQUNELEdBQUcsR0FBR3pZLFNBQVN3WSxtQkFBbUI7b0JBQ2pELElBQUlsTixVQUFVLENBQUMsSUFBSSxDQUFDeEksTUFBTSxHQUFHMlY7b0JBQzdCLFFBQVE7b0JBQ1IsSUFBSU0sSUFBSW5iLEtBQUs4TSxHQUFHLENBQUNZLFNBQVNyTztvQkFDMUIsT0FBTztvQkFDUGdhLEdBQUdnQyxNQUFNLENBQUMsSUFBSSxDQUFDa3hCLFVBQVUsRUFBRXB4QjtvQkFDM0I3QixNQUFNLElBQUksQ0FBQ216QixPQUFPLEdBQUd6c0MsS0FBS21MLEtBQUssQ0FBQ21KLElBQUk2RztvQkFDcEM1QixHQUFHMU0sTUFBTSxDQUFDLElBQUksQ0FBQzIvQixVQUFVLEVBQUVyeEI7b0JBQzNCM0IsTUFBTSxJQUFJLENBQUNrekIsT0FBTyxHQUFHMXNDLEtBQUttTCxLQUFLLENBQUNvSixJQUFJNEc7b0JBQ3BDLElBQUksQ0FBQzBLLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUMsQ0FBQ04sR0FBRyxDQUFDc1A7b0JBQzlCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR2dhO29CQUM1QixJQUFJLENBQUN3TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3dQO29CQUM5QixJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDLEdBQUdrYTtvQkFDNUIsT0FBTzNaLFNBQVMsSUFBSSxDQUFDKzZDLFdBQVcsR0FBR3g0QyxTQUFTdVksVUFBVTtnQkFDMUQ7WUFHQTtZQUFFO2dCQUFDLFlBQVc7Z0JBQUUsZUFBYztnQkFBRSxtQkFBa0I7Z0JBQUcsbUJBQWtCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsaUJBQWdCO2dCQUFHLG1CQUFrQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxzQkFBcUI7Z0JBQUcsa0JBQWlCO2dCQUFHLG1CQUFrQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU3BiLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNyVSxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR3FEO2dCQUVqQixJQUFJYyxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSVUsT0FBT1YsU0FBUTtnQkFFbkIsSUFBSVcsUUFBUVgsU0FBUTtnQkFFcEIsSUFBSVksUUFBUVosU0FBUTtnQkFFcEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSXVDLFFBQVF2QyxTQUFRO2dCQUVwQixJQUFJYSxZQUFZYixTQUFRO2dCQUV4QixJQUFJb0QsV0FBV3BELFNBQVE7Z0JBRXZCLElBQUlxRCxXQUFXckQsU0FBUTtnQkFFdkIsSUFBSW9CLFFBQVFwQixTQUFRO2dCQUVwQnFDLFVBQVVzcEMsSUFBSSxHQUFHO2dCQUVqQnRwQyxVQUFVdXBDLE1BQU0sR0FBR3hxQztnQkFFbkJpQixVQUFVa0YsU0FBUyxHQUFHbWIsT0FBT3JnQixVQUFVdXBDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUV2RDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELElBQUk2ZSxXQUFXO29CQUNYeWxCLGFBQWE7b0JBQ2JDLGNBQWM7Z0JBQ2xCO2dCQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTenBDLFVBQVV3QyxHQUFHLEVBQUVrUCxLQUFLLEVBQUVFLEtBQUssRUFBRXc2QixNQUFNO29CQUN4QyxJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVlwc0MsU0FBUSxHQUFJO3dCQUM5QixPQUFPLElBQUlBLFVBQVV3QyxLQUFLa1AsT0FBT0UsT0FBT3c2QjtvQkFDNUM7b0JBQ0E1cEMsTUFBTTFCLFFBQVEwQixLQUFLdWhCO29CQUNuQmhsQixNQUFNZixJQUFJLENBQUMsSUFBSSxFQUFFd0UsS0FBS2tQLE9BQU9FO29CQUM3QkYsUUFBUSxJQUFJLENBQUN1UyxPQUFPO29CQUNwQnJTLFFBQVEsSUFBSSxDQUFDc1MsT0FBTztvQkFDcEIsSUFBSSxDQUFDN2dCLE1BQU0sR0FBR3JELFVBQVVzcEMsSUFBSTtvQkFDNUIsSUFBSSxDQUFDTSxjQUFjLEdBQUd3QyxTQUFTMTZCLE1BQU1sRSxhQUFhLENBQUM0K0IsVUFBVTVwQyxJQUFJcW5DLFlBQVksSUFBSXpyQyxLQUFLc0QsSUFBSTtvQkFDMUYsSUFBSSxDQUFDb29DLGNBQWMsR0FBR3NDLFNBQVN4NkIsTUFBTXBFLGFBQWEsQ0FBQzQrQixVQUFVNXBDLElBQUl1bkMsWUFBWSxJQUFJM3JDLEtBQUtzRCxJQUFJO29CQUMxRixJQUFJLENBQUNzc0MsZ0JBQWdCLEdBQUc3dkMsTUFBS3dFLFFBQVEsQ0FBQ0gsSUFBSWl4QyxjQUFjLElBQUlqeEMsSUFBSWl4QyxjQUFjLEdBQUc3aEMsTUFBTTlJLFFBQVEsS0FBSzRJLE1BQU01SSxRQUFRO29CQUNsSCxJQUFJLENBQUNtaEMsYUFBYSxHQUFHem5DLElBQUlnbkMsV0FBVztvQkFDcEMsSUFBSSxDQUFDVSxjQUFjLEdBQUcxbkMsSUFBSWluQyxZQUFZO29CQUN0QyxJQUFJLENBQUNVLFNBQVMsR0FBRzlyQztvQkFDakIsSUFBSSxDQUFDZ3NDLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNELE9BQU8sR0FBRztvQkFDZixjQUFjO29CQUNkLElBQUksQ0FBQ0csSUFBSTtvQkFDVCxPQUFPO29CQUNQLElBQUksQ0FBQ0MsSUFBSTtvQkFDVCxPQUFPO29CQUNQLElBQUksQ0FBQ0MsY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLGNBQWM7b0JBQ25CLE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxVQUFVO29CQUNmLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxVQUFVO29CQUNmLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxPQUFPO29CQUNaLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxPQUFPO29CQUNaLFFBQVE7b0JBQ1IsSUFBSSxDQUFDeG5DLE1BQU0sR0FBRyxJQUFJL0U7Z0JBQ3RCO2dCQUVBOztDQUVDLEdBQ0R5QixVQUFVa0YsU0FBUyxDQUFDNmxDLGVBQWUsR0FBRztvQkFDbEMsT0FBTyxJQUFJLENBQUNuQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNENXBDLFVBQVVrRixTQUFTLENBQUM4bEMsZUFBZSxHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ2xCLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0Q5cEMsVUFBVWtGLFNBQVMsQ0FBQ3d2QyxpQkFBaUIsR0FBRztvQkFDcEMsT0FBTyxJQUFJLENBQUMxRyxnQkFBZ0I7Z0JBQ2hDO2dCQUVBOztDQUVDLEdBQ0RodUMsVUFBVWtGLFNBQVMsQ0FBQ2ltQyxZQUFZLEdBQUcsU0FBU0MsRUFBRTtvQkFDMUMsSUFBSSxDQUFDbkIsYUFBYSxHQUFHbUI7Z0JBQ3pCO2dCQUVBcHJDLFVBQVVrRixTQUFTLENBQUNtbUMsWUFBWSxHQUFHO29CQUMvQixPQUFPLElBQUksQ0FBQ3BCLGFBQWE7Z0JBQzdCO2dCQUVBOztDQUVDLEdBQ0RqcUMsVUFBVWtGLFNBQVMsQ0FBQ29tQyxlQUFlLEdBQUcsU0FBU3ZmLEtBQUs7b0JBQ2hELElBQUksQ0FBQ21lLGNBQWMsR0FBR25lO2dCQUMxQjtnQkFFQS9yQixVQUFVa0YsU0FBUyxDQUFDcW1DLGVBQWUsR0FBRztvQkFDbEMsT0FBTyxJQUFJLENBQUNyQixjQUFjO2dCQUM5QjtnQkFFQWxxQyxVQUFVa0YsU0FBUyxDQUFDdWYsVUFBVSxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDdmEsYUFBYSxDQUFDLElBQUksQ0FBQ2tnQyxjQUFjO2dCQUN6RDtnQkFFQTVwQyxVQUFVa0YsU0FBUyxDQUFDd2YsVUFBVSxHQUFHO29CQUM3QixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDeGEsYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO2dCQUN6RDtnQkFFQTlwQyxVQUFVa0YsU0FBUyxDQUFDeWYsZ0JBQWdCLEdBQUcsU0FBU0MsTUFBTTtvQkFDbEQsT0FBT3htQixLQUFLa29CLEdBQUcsQ0FBQyxJQUFJLENBQUM2akIsU0FBUyxDQUFDeHNCLENBQUMsRUFBRSxJQUFJLENBQUN3c0IsU0FBUyxDQUFDdHNCLENBQUMsRUFBRTNTLEdBQUcsQ0FBQzBaO2dCQUM1RDtnQkFFQTVrQixVQUFVa0YsU0FBUyxDQUFDMmYsaUJBQWlCLEdBQUcsU0FBU0QsTUFBTTtvQkFDbkQsT0FBT0EsU0FBUyxJQUFJLENBQUN1bEIsU0FBUyxDQUFDaEYsQ0FBQztnQkFDcEM7Z0JBRUFubEMsVUFBVWtGLFNBQVMsQ0FBQzhmLHVCQUF1QixHQUFHLFNBQVMxVCxJQUFJO29CQUN2RCxJQUFJLENBQUNtNUIsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNqZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDeWhDLGNBQWMsR0FBRyxJQUFJLENBQUN4bUIsT0FBTyxDQUFDbGdCLE9BQU8sQ0FBQ2lGLFdBQVc7b0JBQ3RELElBQUksQ0FBQzBoQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzFnQixTQUFTO29CQUN4QyxJQUFJLENBQUNxbkMsVUFBVSxHQUFHLElBQUksQ0FBQzFtQixPQUFPLENBQUMzZ0IsU0FBUztvQkFDeEMsSUFBSSxDQUFDc25DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDeGdCLE1BQU07b0JBQ2xDLElBQUksQ0FBQ3FuQyxPQUFPLEdBQUcsSUFBSSxDQUFDNW1CLE9BQU8sQ0FBQ3pnQixNQUFNO29CQUNsQyxJQUFJaVUsS0FBSyxJQUFJLENBQUN1TSxPQUFPLENBQUM5ZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJOGMsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJNE4sS0FBSyxJQUFJLENBQUNzTSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDO29CQUNsQyxJQUFJZ2QsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUl3aEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPLEtBQUsrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNuQyxJQUFJLENBQUMyeUIsSUFBSSxHQUFHOXJDLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSXB0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3VnQyxjQUFjLEVBQUUsSUFBSSxDQUFDYSxjQUFjO29CQUM3RSxJQUFJLENBQUNELElBQUksR0FBRy9yQyxJQUFJNE8sT0FBTyxDQUFDbytCLElBQUlydEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDN0UsOEJBQThCO29CQUM5QixjQUFjO29CQUNkLHFCQUFxQjtvQkFDckIsU0FBUztvQkFDVCx5RUFBeUU7b0JBQ3pFLG9FQUFvRTtvQkFDcEUsMENBQTBDO29CQUMxQyxJQUFJcnpCLEtBQUssSUFBSSxDQUFDc3pCLFVBQVU7b0JBQ3hCLElBQUlwekIsS0FBSyxJQUFJLENBQUNxekIsVUFBVTtvQkFDeEIsUUFBUTtvQkFDUixJQUFJdHpCLEtBQUssSUFBSSxDQUFDdXpCLE9BQU87b0JBQ3JCLElBQUlyekIsS0FBSyxJQUFJLENBQUNzekIsT0FBTztvQkFDckIsUUFBUTtvQkFDUixJQUFJeHhCLElBQUksSUFBSS9hO29CQUNaK2EsRUFBRTJDLEVBQUUsQ0FBQzBCLENBQUMsR0FBR3RHLEtBQUtFLEtBQUssSUFBSSxDQUFDZ3pCLElBQUksQ0FBQzFzQixDQUFDLEdBQUcsSUFBSSxDQUFDMHNCLElBQUksQ0FBQzFzQixDQUFDLEdBQUd2RyxLQUFLLElBQUksQ0FBQ2t6QixJQUFJLENBQUMzc0IsQ0FBQyxHQUFHLElBQUksQ0FBQzJzQixJQUFJLENBQUMzc0IsQ0FBQyxHQUFHckc7b0JBQ2hGOEIsRUFBRTRDLEVBQUUsQ0FBQ3lCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQzRzQixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHLElBQUksQ0FBQzBzQixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHckcsS0FBSyxJQUFJLENBQUNrekIsSUFBSSxDQUFDM3NCLENBQUMsR0FBRyxJQUFJLENBQUMyc0IsSUFBSSxDQUFDN3NCLENBQUMsR0FBR25HO29CQUN2RThCLEVBQUUyckIsRUFBRSxDQUFDdG5CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQzRzQixJQUFJLENBQUMxc0IsQ0FBQyxHQUFHdkcsS0FBSyxJQUFJLENBQUNrekIsSUFBSSxDQUFDM3NCLENBQUMsR0FBR3JHO29CQUMzQzhCLEVBQUUyQyxFQUFFLENBQUM0QixDQUFDLEdBQUd2RSxFQUFFNEMsRUFBRSxDQUFDeUIsQ0FBQztvQkFDZnJFLEVBQUU0QyxFQUFFLENBQUMyQixDQUFDLEdBQUd4RyxLQUFLRSxLQUFLLElBQUksQ0FBQ2d6QixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzRzQixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHckcsS0FBSyxJQUFJLENBQUNrekIsSUFBSSxDQUFDN3NCLENBQUMsR0FBRyxJQUFJLENBQUM2c0IsSUFBSSxDQUFDN3NCLENBQUMsR0FBR25HO29CQUNoRjhCLEVBQUUyckIsRUFBRSxDQUFDcG5CLENBQUMsR0FBRyxJQUFJLENBQUMwc0IsSUFBSSxDQUFDNXNCLENBQUMsR0FBR3JHLEtBQUssSUFBSSxDQUFDa3pCLElBQUksQ0FBQzdzQixDQUFDLEdBQUduRztvQkFDMUM4QixFQUFFMkMsRUFBRSxDQUFDa3BCLENBQUMsR0FBRzdyQixFQUFFMnJCLEVBQUUsQ0FBQ3RuQixDQUFDO29CQUNmckUsRUFBRTRDLEVBQUUsQ0FBQ2lwQixDQUFDLEdBQUc3ckIsRUFBRTJyQixFQUFFLENBQUNwbkIsQ0FBQztvQkFDZnZFLEVBQUUyckIsRUFBRSxDQUFDRSxDQUFDLEdBQUc3dEIsS0FBS0U7b0JBQ2QsSUFBSSxJQUFJLENBQUN5eUIsYUFBYSxHQUFHLEdBQUc7d0JBQ3hCM3dCLEVBQUVtc0IsWUFBWSxDQUFDLElBQUksQ0FBQ25pQyxNQUFNO3dCQUMxQixJQUFJaTJDLE9BQU9qaUMsS0FBS0U7d0JBQ2hCLFFBQVE7d0JBQ1IsSUFBSXd2QixJQUFJdVMsT0FBTyxJQUFJLElBQUlBLE9BQU87d0JBQzlCLFFBQVE7d0JBQ1IsSUFBSXRnQyxJQUFJckIsS0FBS0YsS0FBSyxJQUFJLENBQUNzMkIsZ0JBQWdCO3dCQUN2QyxRQUFRO3dCQUNSLFlBQVk7d0JBQ1osSUFBSW5DLFFBQVEsSUFBSTF0QyxNQUFLOHBCLEVBQUUsR0FBRyxJQUFJLENBQUNnaUIsYUFBYTt3QkFDNUMsUUFBUTt3QkFDUixzQkFBc0I7d0JBQ3RCLElBQUk1VixJQUFJLElBQUkyUyxJQUFJLElBQUksQ0FBQ2tELGNBQWMsR0FBRzJCO3dCQUN0QyxRQUFRO3dCQUNSLG1CQUFtQjt3QkFDbkIsSUFBSUMsSUFBSTlFLElBQUk2RSxRQUFRQTt3QkFDcEIsUUFBUTt3QkFDUixpQkFBaUI7d0JBQ2pCLElBQUlqZ0IsSUFBSXRhLEtBQUs0WSxFQUFFO3dCQUNmLFFBQVE7d0JBQ1IsSUFBSSxDQUFDa2dCLE9BQU8sR0FBR3hlLElBQUt5SSxDQUFBQSxJQUFJekksSUFBSWtnQixDQUFBQTt3QkFDNUIsSUFBSSxDQUFDMUIsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUNBLE9BQU8sR0FBRzt3QkFDdEQsSUFBSSxDQUFDQyxNQUFNLEdBQUdweEIsSUFBSTJTLElBQUlrZ0IsSUFBSSxJQUFJLENBQUMxQixPQUFPO3dCQUN0Q21QLFFBQVEsSUFBSSxDQUFDblAsT0FBTzt3QkFDcEIsSUFBSSxDQUFDOW1DLE1BQU0sQ0FBQzJoQyxFQUFFLENBQUNFLENBQUMsR0FBR29VLFFBQVEsSUFBSSxJQUFJQSxPQUFPO29CQUM5QyxPQUFPLElBQUlqZ0MsRUFBRTJyQixFQUFFLENBQUNFLENBQUMsSUFBSSxHQUFHO3dCQUNwQjdyQixFQUFFbXNCLFlBQVksQ0FBQyxJQUFJLENBQUNuaUMsTUFBTTt3QkFDMUIsSUFBSSxDQUFDOG1DLE9BQU8sR0FBRzt3QkFDZixJQUFJLENBQUNDLE1BQU0sR0FBRztvQkFDbEIsT0FBTzt3QkFDSC93QixFQUFFcXNCLGVBQWUsQ0FBQyxJQUFJLENBQUNyaUMsTUFBTTt3QkFDN0IsSUFBSSxDQUFDOG1DLE9BQU8sR0FBRzt3QkFDZixJQUFJLENBQUNDLE1BQU0sR0FBRztvQkFDbEI7b0JBQ0EsSUFBSS80QixLQUFLZ0IsWUFBWSxFQUFFO3dCQUNuQixrREFBa0Q7d0JBQ2xELElBQUksQ0FBQzYzQixTQUFTLENBQUNqL0IsR0FBRyxDQUFDb0csS0FBS2tCLE9BQU87d0JBQy9CLElBQUkrRyxJQUFJbmIsS0FBS2tvQixHQUFHLENBQUMsSUFBSSxDQUFDNmpCLFNBQVMsQ0FBQ3hzQixDQUFDLEVBQUUsSUFBSSxDQUFDd3NCLFNBQVMsQ0FBQ3RzQixDQUFDO3dCQUNuRHJELEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZGtCLE1BQU1uRCxLQUFNbFosQ0FBQUEsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNnaEMsSUFBSSxFQUFFaHhCLEtBQUssSUFBSSxDQUFDNHdCLFNBQVMsQ0FBQ2hGLENBQUMsQUFBREE7d0JBQ3REenFCLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBTXBaLENBQUFBLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRWp4QixLQUFLLElBQUksQ0FBQzR3QixTQUFTLENBQUNoRixDQUFDLEFBQURBO29CQUMxRCxPQUFPO3dCQUNILElBQUksQ0FBQ2dGLFNBQVMsQ0FBQzdqQyxPQUFPO29CQUMxQjtvQkFDQSxJQUFJLENBQUMyZCxPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLEdBQUc0UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLEdBQUc4UTtvQkFDNUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO2dCQUNoQztnQkFFQTNhLFVBQVVrRixTQUFTLENBQUMrZix3QkFBd0IsR0FBRyxTQUFTM1QsSUFBSTtvQkFDeEQsSUFBSWtKLEtBQUssSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSTZRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSTBRLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUkrUSxLQUFLLElBQUksQ0FBQ3VKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJcU4sS0FBSyxJQUFJLENBQUNzekIsVUFBVTtvQkFDeEIsSUFBSXB6QixLQUFLLElBQUksQ0FBQ3F6QixVQUFVO29CQUN4QixRQUFRO29CQUNSLElBQUl0ekIsS0FBSyxJQUFJLENBQUN1ekIsT0FBTztvQkFDckIsSUFBSXJ6QixLQUFLLElBQUksQ0FBQ3N6QixPQUFPO29CQUNyQixRQUFRO29CQUNSLElBQUksSUFBSSxDQUFDYixhQUFhLEdBQUcsR0FBRzt3QkFDeEIsSUFBSTZMLFFBQVFuN0IsS0FBS0Y7d0JBQ2pCLFFBQVE7d0JBQ1IsSUFBSSsrQixXQUFXLENBQUMsSUFBSSxDQUFDbDJDLE1BQU0sQ0FBQzJoQyxFQUFFLENBQUNFLENBQUMsR0FBSTJRLENBQUFBLFFBQVEsSUFBSSxDQUFDekwsTUFBTSxHQUFHLElBQUksQ0FBQ0QsT0FBTyxHQUFHLElBQUksQ0FBQ0QsU0FBUyxDQUFDaEYsQ0FBQyxBQUFEQTt3QkFDeEYsUUFBUTt3QkFDUixJQUFJLENBQUNnRixTQUFTLENBQUNoRixDQUFDLElBQUlxVTt3QkFDcEIvK0IsTUFBTW5ELEtBQUtraUM7d0JBQ1g3K0IsTUFBTW5ELEtBQUtnaUM7d0JBQ1gsSUFBSTNELFFBQVF6M0MsS0FBS3NELElBQUk7d0JBQ3JCbTBDLE1BQU12TixVQUFVLENBQUMsR0FBRzV0QixJQUFJLEdBQUd0YyxLQUFLbUwsS0FBSyxDQUFDb1IsSUFBSSxJQUFJLENBQUM2dkIsSUFBSTt3QkFDbkRxTCxNQUFNck4sVUFBVSxDQUFDLEdBQUdodUIsSUFBSSxHQUFHcGMsS0FBS21MLEtBQUssQ0FBQ2tSLElBQUksSUFBSSxDQUFDOHZCLElBQUk7d0JBQ25ELE9BQU87d0JBQ1AsSUFBSStMLFdBQVdsNEMsS0FBS2c3QixHQUFHLENBQUM3NkIsTUFBTThPLE9BQU8sQ0FBQyxJQUFJLENBQUMvSixNQUFNLEVBQUV1eUM7d0JBQ25ELE9BQU87d0JBQ1AsSUFBSSxDQUFDMUwsU0FBUyxDQUFDeHNCLENBQUMsSUFBSTI0QixTQUFTMzRCLENBQUM7d0JBQzlCLElBQUksQ0FBQ3dzQixTQUFTLENBQUN0c0IsQ0FBQyxJQUFJeTRCLFNBQVN6NEIsQ0FBQzt3QkFDOUIsSUFBSXRFLElBQUluYixLQUFLeUYsS0FBSyxDQUFDeXlDO3dCQUNuQixPQUFPO3dCQUNQOTdCLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZGtCLE1BQU1uRCxLQUFLbFosS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNnaEMsSUFBSSxFQUFFaHhCO3dCQUNqQ21CLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBS3BaLEtBQUttTCxLQUFLLENBQUMsSUFBSSxDQUFDaWhDLElBQUksRUFBRWp4QjtvQkFDckMsT0FBTzt3QkFDSCxJQUFJczhCLFFBQVF6M0MsS0FBS3NELElBQUk7d0JBQ3JCbTBDLE1BQU12TixVQUFVLENBQUMsR0FBRzV0QixJQUFJLEdBQUd0YyxLQUFLbUwsS0FBSyxDQUFDb1IsSUFBSSxJQUFJLENBQUM2dkIsSUFBSTt3QkFDbkRxTCxNQUFNck4sVUFBVSxDQUFDLEdBQUdodUIsSUFBSSxHQUFHcGMsS0FBS21MLEtBQUssQ0FBQ2tSLElBQUksSUFBSSxDQUFDOHZCLElBQUk7d0JBQ25ELE9BQU87d0JBQ1AsSUFBSXVMLFFBQVFuN0IsS0FBS0Y7d0JBQ2pCLFFBQVE7d0JBQ1IsSUFBSXd4QixPQUFPNXRDLEtBQUt3M0MsTUFBTWw0QixDQUFDLEVBQUVrNEIsTUFBTWg0QixDQUFDLEVBQUVpNEI7d0JBQ2xDLE9BQU87d0JBQ1AsSUFBSWhxQyxVQUFVek4sS0FBSys2QixHQUFHLENBQUM3NkIsTUFBTXduQyxPQUFPLENBQUMsSUFBSSxDQUFDemlDLE1BQU0sRUFBRTJvQzt3QkFDbEQsT0FBTzt3QkFDUCxJQUFJLENBQUM5QixTQUFTLENBQUM3Z0MsR0FBRyxDQUFDd0M7d0JBQ25CLElBQUl5TixJQUFJbmIsS0FBS2tvQixHQUFHLENBQUN4YSxRQUFRNlIsQ0FBQyxFQUFFN1IsUUFBUStSLENBQUM7d0JBQ3JDckQsR0FBR2YsTUFBTSxDQUFDcEMsSUFBSWtDO3dCQUNka0IsTUFBTW5ELEtBQU1sWixDQUFBQSxLQUFLbUwsS0FBSyxDQUFDLElBQUksQ0FBQ2doQyxJQUFJLEVBQUVoeEIsS0FBS3pOLFFBQVFxNUIsQ0FBQyxBQUFEQTt3QkFDL0N6cUIsR0FBR3pQLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZG9CLE1BQU1uRCxLQUFNcFosQ0FBQUEsS0FBS21MLEtBQUssQ0FBQyxJQUFJLENBQUNpaEMsSUFBSSxFQUFFanhCLEtBQUt6TixRQUFRcTVCLENBQUMsQUFBREE7b0JBQ25EO29CQUNBLElBQUksQ0FBQ2xoQixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDLEdBQUc0UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDL2YsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHeVE7b0JBQzVCLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDLEdBQUc4UTtvQkFDNUIsSUFBSSxDQUFDd0osT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUMsR0FBRzJRO2dCQUNoQztnQkFFQTNhLFVBQVVrRixTQUFTLENBQUNnZ0Isd0JBQXdCLEdBQUcsU0FBUzVULElBQUk7b0JBQ3hELElBQUltRyxLQUFLLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUlpUCxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUlpYSxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltUCxLQUFLLElBQUksQ0FBQ3NNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk4dEMsS0FBSy9zQyxJQUFJNm5CLEdBQUcsQ0FBQzVPLEtBQUsrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNuQyxJQUFJUCxLQUFLLElBQUksQ0FBQ3N6QixVQUFVLEVBQUVwekIsS0FBSyxJQUFJLENBQUNxekIsVUFBVTtvQkFDOUMsUUFBUTtvQkFDUixJQUFJdHpCLEtBQUssSUFBSSxDQUFDdXpCLE9BQU8sRUFBRXJ6QixLQUFLLElBQUksQ0FBQ3N6QixPQUFPO29CQUN4QyxRQUFRO29CQUNSLElBQUlwNEIsS0FBS2pVLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSXB0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3VnQyxjQUFjLEVBQUUsSUFBSSxDQUFDYSxjQUFjO29CQUMxRSxJQUFJOTNCLEtBQUtsVSxJQUFJNE8sT0FBTyxDQUFDbytCLElBQUlydEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDMUUsSUFBSW1PLGVBQWV6QztvQkFDbkIsUUFBUTtvQkFDUixJQUFJOThCLElBQUksSUFBSS9hO29CQUNaK2EsRUFBRTJDLEVBQUUsQ0FBQzBCLENBQUMsR0FBR3RHLEtBQUtFLEtBQUs3RSxHQUFHbUwsQ0FBQyxHQUFHbkwsR0FBR21MLENBQUMsR0FBR3ZHLEtBQUszRSxHQUFHa0wsQ0FBQyxHQUFHbEwsR0FBR2tMLENBQUMsR0FBR3JHO29CQUNwRDhCLEVBQUU0QyxFQUFFLENBQUN5QixDQUFDLEdBQUcsQ0FBQ2pMLEdBQUdtTCxDQUFDLEdBQUduTCxHQUFHaUwsQ0FBQyxHQUFHckcsS0FBSzNFLEdBQUdrTCxDQUFDLEdBQUdsTCxHQUFHZ0wsQ0FBQyxHQUFHbkc7b0JBQzNDOEIsRUFBRTJyQixFQUFFLENBQUN0bkIsQ0FBQyxHQUFHLENBQUNqTCxHQUFHbUwsQ0FBQyxHQUFHdkcsS0FBSzNFLEdBQUdrTCxDQUFDLEdBQUdyRztvQkFDN0I4QixFQUFFMkMsRUFBRSxDQUFDNEIsQ0FBQyxHQUFHdkUsRUFBRTRDLEVBQUUsQ0FBQ3lCLENBQUM7b0JBQ2ZyRSxFQUFFNEMsRUFBRSxDQUFDMkIsQ0FBQyxHQUFHeEcsS0FBS0UsS0FBSzdFLEdBQUdpTCxDQUFDLEdBQUdqTCxHQUFHaUwsQ0FBQyxHQUFHckcsS0FBSzNFLEdBQUdnTCxDQUFDLEdBQUdoTCxHQUFHZ0wsQ0FBQyxHQUFHbkc7b0JBQ3BEOEIsRUFBRTJyQixFQUFFLENBQUNwbkIsQ0FBQyxHQUFHbkwsR0FBR2lMLENBQUMsR0FBR3JHLEtBQUszRSxHQUFHZ0wsQ0FBQyxHQUFHbkc7b0JBQzVCOEIsRUFBRTJDLEVBQUUsQ0FBQ2twQixDQUFDLEdBQUc3ckIsRUFBRTJyQixFQUFFLENBQUN0bkIsQ0FBQztvQkFDZnJFLEVBQUU0QyxFQUFFLENBQUNpcEIsQ0FBQyxHQUFHN3JCLEVBQUUyckIsRUFBRSxDQUFDcG5CLENBQUM7b0JBQ2Z2RSxFQUFFMnJCLEVBQUUsQ0FBQ0UsQ0FBQyxHQUFHN3RCLEtBQUtFO29CQUNkLElBQUksSUFBSSxDQUFDeXlCLGFBQWEsR0FBRyxHQUFHO3dCQUN4QixJQUFJa00sS0FBSy8zQyxLQUFLc0QsSUFBSTt3QkFDbEJ5MEMsR0FBRzdOLFVBQVUsQ0FBQyxHQUFHM3dCLElBQUksR0FBR2hGO3dCQUN4QndqQyxHQUFHM04sVUFBVSxDQUFDLEdBQUcvd0IsSUFBSSxHQUFHL0U7d0JBQ3hCLE9BQU87d0JBQ1BtbUMsZ0JBQWdCMUMsR0FBR2w0QyxNQUFNO3dCQUN6Qm00QyxlQUFlO3dCQUNmLElBQUk3OEIsSUFBSW5iLEtBQUtnN0IsR0FBRyxDQUFDOWYsRUFBRThyQixPQUFPLENBQUMrUTt3QkFDM0IsT0FBTzt3QkFDUDErQixHQUFHZ0MsTUFBTSxDQUFDcEMsSUFBSWtDO3dCQUNkN0IsTUFBTUosS0FBS2xaLEtBQUttTCxLQUFLLENBQUNtSixJQUFJNkc7d0JBQzFCNUIsR0FBRzFNLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZDNCLE1BQU1KLEtBQUtwWixLQUFLbUwsS0FBSyxDQUFDb0osSUFBSTRHO29CQUM5QixPQUFPO3dCQUNILElBQUk0OEIsS0FBSy8zQyxLQUFLc0QsSUFBSTt3QkFDbEJ5MEMsR0FBRzdOLFVBQVUsQ0FBQyxHQUFHM3dCLElBQUksR0FBR2hGO3dCQUN4QndqQyxHQUFHM04sVUFBVSxDQUFDLEdBQUcvd0IsSUFBSSxHQUFHL0U7d0JBQ3hCLElBQUkyakMsS0FBS3orQixLQUFLRixLQUFLLElBQUksQ0FBQ3MyQixnQkFBZ0I7d0JBQ3hDLFFBQVE7d0JBQ1I2SyxnQkFBZ0IxQyxHQUFHbDRDLE1BQU07d0JBQ3pCbTRDLGVBQWVqNEMsTUFBSzBoQixHQUFHLENBQUN3MkI7d0JBQ3hCLElBQUlwOUIsSUFBSTVhLEtBQUs4M0MsR0FBR3g0QixDQUFDLEVBQUV3NEIsR0FBR3Q0QixDQUFDLEVBQUV3NEI7d0JBQ3pCLElBQUl2cUMsVUFBVXpOO3dCQUNkLElBQUlpYixFQUFFMnJCLEVBQUUsQ0FBQ0UsQ0FBQyxHQUFHLEdBQUc7NEJBQ1pyNUIsVUFBVXpOLEtBQUsrNkIsR0FBRyxDQUFDOWYsRUFBRTRyQixPQUFPLENBQUNqc0I7d0JBQ2pDLE9BQU87NEJBQ0gsSUFBSXVnQyxXQUFXcDdDLEtBQUtnN0IsR0FBRyxDQUFDOWYsRUFBRThyQixPQUFPLENBQUMrUTs0QkFDbENycUMsUUFBUTNELEdBQUcsQ0FBQ3F4QyxTQUFTNzdCLENBQUMsRUFBRTY3QixTQUFTMzdCLENBQUMsRUFBRTt3QkFDeEM7d0JBQ0EsSUFBSXRFLElBQUluYixLQUFLa29CLEdBQUcsQ0FBQ3hhLFFBQVE2UixDQUFDLEVBQUU3UixRQUFRK1IsQ0FBQzt3QkFDckNwRyxHQUFHZ0MsTUFBTSxDQUFDcEMsSUFBSWtDO3dCQUNkN0IsTUFBTUosS0FBTWxaLENBQUFBLEtBQUttTCxLQUFLLENBQUNtSixJQUFJNkcsS0FBS3pOLFFBQVFxNUIsQ0FBQyxBQUFEQTt3QkFDeEN4dEIsR0FBRzFNLE1BQU0sQ0FBQ3NNLElBQUlnQzt3QkFDZDNCLE1BQU1KLEtBQU1wWixDQUFBQSxLQUFLbUwsS0FBSyxDQUFDb0osSUFBSTRHLEtBQUt6TixRQUFRcTVCLENBQUMsQUFBREE7b0JBQzVDO29CQUNBLElBQUksQ0FBQ2xoQixPQUFPLENBQUM5ZixVQUFVLENBQUNzRSxDQUFDLEdBQUdnUDtvQkFDNUIsSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQyxHQUFHZ2E7b0JBQzVCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUMsR0FBR2tQO29CQUM1QixJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDLEdBQUdrYTtvQkFDNUIsT0FBT2loQyxpQkFBaUJyNEMsU0FBU3VZLFVBQVUsSUFBSXE5QixnQkFBZ0I1MUMsU0FBU3duQixXQUFXO2dCQUN2RjtZQUdBO1lBQUU7Z0JBQUMsWUFBVztnQkFBRSxlQUFjO2dCQUFFLG1CQUFrQjtnQkFBRyxtQkFBa0I7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsbUJBQWtCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxrQkFBaUI7Z0JBQUcsbUJBQWtCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTcnFCLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNyVSxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR3NEO2dCQUVqQixJQUFJYSxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSVUsT0FBT1YsU0FBUTtnQkFFbkIsSUFBSVcsUUFBUVgsU0FBUTtnQkFFcEIsSUFBSVksUUFBUVosU0FBUTtnQkFFcEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSXVDLFFBQVF2QyxTQUFRO2dCQUVwQixJQUFJYSxZQUFZYixTQUFRO2dCQUV4QixJQUFJb0QsV0FBV3BELFNBQVE7Z0JBRXZCLElBQUlxRCxXQUFXckQsU0FBUTtnQkFFdkIsSUFBSW9CLFFBQVFwQixTQUFRO2dCQUVwQnNDLFdBQVdxcEMsSUFBSSxHQUFHO2dCQUVsQnJwQyxXQUFXc3BDLE1BQU0sR0FBR3hxQztnQkFFcEJrQixXQUFXaUYsU0FBUyxHQUFHbWIsT0FBT3BnQixXQUFXc3BDLE1BQU0sQ0FBQ3JrQyxTQUFTO2dCQUV6RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FDRCxJQUFJNmUsV0FBVztvQkFDWG92QixhQUFhO29CQUNiZ0YsZ0JBQWdCO29CQUNoQjlFLFlBQVk7b0JBQ1o3SixhQUFhO29CQUNiQyxjQUFjO2dCQUNsQjtnQkFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTeHBDLFdBQVd1QyxHQUFHLEVBQUVrUCxLQUFLLEVBQUVFLEtBQUssRUFBRXc2QixNQUFNLEVBQUVrSCxJQUFJO29CQUMvQyxJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVlyekMsVUFBUyxHQUFJO3dCQUMvQixPQUFPLElBQUlBLFdBQVd1QyxLQUFLa1AsT0FBT0UsT0FBT3c2QixRQUFRa0g7b0JBQ3JEO29CQUNBOXdDLE1BQU0xQixRQUFRMEIsS0FBS3VoQjtvQkFDbkJobEIsTUFBTWYsSUFBSSxDQUFDLElBQUksRUFBRXdFLEtBQUtrUCxPQUFPRTtvQkFDN0JGLFFBQVEsSUFBSSxDQUFDdVMsT0FBTztvQkFDcEJyUyxRQUFRLElBQUksQ0FBQ3NTLE9BQU87b0JBQ3BCLElBQUksQ0FBQzdnQixNQUFNLEdBQUdwRCxXQUFXcXBDLElBQUk7b0JBQzdCLElBQUksQ0FBQ00sY0FBYyxHQUFHd0MsU0FBUzE2QixNQUFNbEUsYUFBYSxDQUFDNCtCLFVBQVU1cEMsSUFBSXFuQyxZQUFZLElBQUl6ckMsS0FBS3NELElBQUk7b0JBQzFGLElBQUksQ0FBQ29vQyxjQUFjLEdBQUdzQyxTQUFTeDZCLE1BQU1wRSxhQUFhLENBQUM0K0IsVUFBVTVwQyxJQUFJdW5DLFlBQVksSUFBSTNyQyxLQUFLc0QsSUFBSTtvQkFDMUYsSUFBSSxDQUFDKzNDLFdBQVcsR0FBR25HLE9BQU81aEMsTUFBTWhFLGNBQWMsQ0FBQzRsQyxRQUFROXdDLElBQUkrd0MsVUFBVSxJQUFJbjFDLEtBQUtrb0IsR0FBRyxDQUFDLEdBQUc7b0JBQ3JGLElBQUksQ0FBQzZuQixhQUFhLEdBQUcsSUFBSSxDQUFDc0wsV0FBVztvQkFDckMsSUFBSSxDQUFDakcsYUFBYSxHQUFHcDFDLEtBQUttTCxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM0a0MsYUFBYTtvQkFDckQsSUFBSSxDQUFDN3FDLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUM2bUMsU0FBUyxHQUFHO29CQUNqQixJQUFJLENBQUN1SixXQUFXLEdBQUc7b0JBQ25CLElBQUksQ0FBQ0MsY0FBYyxHQUFHO29CQUN0QixJQUFJLENBQUMrRixZQUFZLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO29CQUN2QixJQUFJLENBQUNyQixnQkFBZ0IsR0FBRzkxQyxJQUFJMjFDLGNBQWM7b0JBQzFDLElBQUksQ0FBQ3BFLFlBQVksR0FBR3Z4QyxJQUFJNndDLFVBQVU7b0JBQ2xDLElBQUksQ0FBQ1ksYUFBYSxHQUFHenhDLElBQUkyd0MsV0FBVztvQkFDcEMsSUFBSSxDQUFDbEosYUFBYSxHQUFHem5DLElBQUlnbkMsV0FBVztvQkFDcEMsSUFBSSxDQUFDVSxjQUFjLEdBQUcxbkMsSUFBSWluQyxZQUFZO29CQUN0QyxJQUFJLENBQUNZLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUNELE9BQU8sR0FBRztvQkFDZixjQUFjO29CQUNkLElBQUksQ0FBQ0ssY0FBYztvQkFDbkIsT0FBTztvQkFDUCxJQUFJLENBQUNDLGNBQWM7b0JBQ25CLE9BQU87b0JBQ1AsSUFBSSxDQUFDQyxVQUFVO29CQUNmLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxVQUFVO29CQUNmLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxPQUFPO29CQUNaLFFBQVE7b0JBQ1IsSUFBSSxDQUFDQyxPQUFPO29CQUNaLFFBQVE7b0JBQ1IsSUFBSSxDQUFDOE8sSUFBSSxHQUFHeDdDLEtBQUtzRCxJQUFJO29CQUNyQixJQUFJLENBQUNtNEMsSUFBSSxHQUFHejdDLEtBQUtzRCxJQUFJO29CQUNyQixPQUFPO29CQUNQLElBQUksQ0FBQ280QyxLQUFLO29CQUNWLElBQUksQ0FBQ0MsS0FBSztvQkFDVixRQUFRO29CQUNSLElBQUksQ0FBQ0MsS0FBSztvQkFDVixJQUFJLENBQUNDLEtBQUs7Z0JBQ2Q7Z0JBRUE7O0NBRUMsR0FDRGg2QyxXQUFXaUYsU0FBUyxDQUFDNmxDLGVBQWUsR0FBRztvQkFDbkMsT0FBTyxJQUFJLENBQUNuQixjQUFjO2dCQUM5QjtnQkFFQTs7Q0FFQyxHQUNEM3BDLFdBQVdpRixTQUFTLENBQUM4bEMsZUFBZSxHQUFHO29CQUNuQyxPQUFPLElBQUksQ0FBQ2xCLGNBQWM7Z0JBQzlCO2dCQUVBOztDQUVDLEdBQ0Q3cEMsV0FBV2lGLFNBQVMsQ0FBQ3V2QyxhQUFhLEdBQUc7b0JBQ2pDLE9BQU8sSUFBSSxDQUFDdEcsYUFBYTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRGx1QyxXQUFXaUYsU0FBUyxDQUFDeXZDLG1CQUFtQixHQUFHO29CQUN2QyxJQUFJem5CLEtBQUssSUFBSSxDQUFDakosT0FBTztvQkFDckIsSUFBSWtKLEtBQUssSUFBSSxDQUFDakosT0FBTztvQkFDckIsSUFBSXlXLEtBQUt6TixHQUFHeGpCLGFBQWEsQ0FBQyxJQUFJLENBQUNrZ0MsY0FBYztvQkFDN0MsT0FBTztvQkFDUCxJQUFJaFAsS0FBS3pOLEdBQUd6akIsYUFBYSxDQUFDLElBQUksQ0FBQ29nQyxjQUFjO29CQUM3QyxPQUFPO29CQUNQLElBQUl6VixJQUFJajJCLEtBQUtpTCxHQUFHLENBQUN1eEIsSUFBSUQ7b0JBQ3JCLE9BQU87b0JBQ1AsSUFBSTJZLE9BQU9wbUIsR0FBRzVmLGNBQWMsQ0FBQyxJQUFJLENBQUM2Z0MsYUFBYTtvQkFDL0MsT0FBTztvQkFDUCxJQUFJcmlCLGNBQWMxdEIsS0FBS3lMLEdBQUcsQ0FBQ3dxQixHQUFHaWY7b0JBQzlCLFFBQVE7b0JBQ1IsT0FBT3huQjtnQkFDWDtnQkFFQTs7Q0FFQyxHQUNEN3JCLFdBQVdpRixTQUFTLENBQUMwdkMsYUFBYSxHQUFHO29CQUNqQyxJQUFJbjZCLEtBQUssSUFBSSxDQUFDd0osT0FBTyxDQUFDMWYsaUJBQWlCO29CQUN2QyxJQUFJb1csS0FBSyxJQUFJLENBQUN1SixPQUFPLENBQUMzZixpQkFBaUI7b0JBQ3ZDLE9BQU9vVyxLQUFLRjtnQkFDaEI7Z0JBRUE7O0NBRUMsR0FDRHhhLFdBQVdpRixTQUFTLENBQUMrdkMsY0FBYyxHQUFHO29CQUNsQyxPQUFPLElBQUksQ0FBQ2hCLGFBQWE7Z0JBQzdCO2dCQUVBOztDQUVDLEdBQ0RoMEMsV0FBV2lGLFNBQVMsQ0FBQ2l1QyxXQUFXLEdBQUcsU0FBUzNyQyxJQUFJO29CQUM1QyxJQUFJLENBQUN5YyxPQUFPLENBQUN4ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQ3lkLE9BQU8sQ0FBQ3pkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDd3RDLGFBQWEsR0FBR3pzQztnQkFDekI7Z0JBRUE7O0NBRUMsR0FDRHZILFdBQVdpRixTQUFTLENBQUNnd0MsYUFBYSxHQUFHLFNBQVNqaEMsS0FBSztvQkFDL0MsSUFBSSxDQUFDZ1EsT0FBTyxDQUFDeGQsUUFBUSxDQUFDO29CQUN0QixJQUFJLENBQUN5ZCxPQUFPLENBQUN6ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQ3N0QyxZQUFZLEdBQUc5L0I7Z0JBQ3hCO2dCQUVBOztDQUVDLEdBQ0RoVSxXQUFXaUYsU0FBUyxDQUFDa3dDLGFBQWEsR0FBRztvQkFDakMsT0FBTyxJQUFJLENBQUNyQixZQUFZO2dCQUM1QjtnQkFFQTs7Q0FFQyxHQUNEOXpDLFdBQVdpRixTQUFTLENBQUN1ekMsaUJBQWlCLEdBQUcsU0FBUzdzQyxNQUFNO29CQUNwRCxJQUFJLENBQUNxWSxPQUFPLENBQUN4ZCxRQUFRLENBQUM7b0JBQ3RCLElBQUksQ0FBQ3lkLE9BQU8sQ0FBQ3pkLFFBQVEsQ0FBQztvQkFDdEIsSUFBSSxDQUFDNnhDLGdCQUFnQixHQUFHMXNDO2dCQUM1QjtnQkFFQTNMLFdBQVdpRixTQUFTLENBQUNnMUMsaUJBQWlCLEdBQUc7b0JBQ3JDLE9BQU8sSUFBSSxDQUFDNUIsZ0JBQWdCO2dCQUNoQztnQkFFQTs7Q0FFQyxHQUNEcjRDLFdBQVdpRixTQUFTLENBQUNzekMsY0FBYyxHQUFHLFNBQVM1ekIsTUFBTTtvQkFDakQsT0FBT0EsU0FBUyxJQUFJLENBQUMrdUIsY0FBYztnQkFDdkM7Z0JBRUE7OztDQUdDLEdBQ0QxekMsV0FBV2lGLFNBQVMsQ0FBQ2kxQyxvQkFBb0IsR0FBRyxTQUFTL08sRUFBRTtvQkFDbkQsSUFBSSxDQUFDbkIsYUFBYSxHQUFHbUI7Z0JBQ3pCO2dCQUVBbnJDLFdBQVdpRixTQUFTLENBQUNrMUMsb0JBQW9CLEdBQUc7b0JBQ3hDLE9BQU8sSUFBSSxDQUFDblEsYUFBYTtnQkFDN0I7Z0JBRUE7O0NBRUMsR0FDRGhxQyxXQUFXaUYsU0FBUyxDQUFDbTFDLHFCQUFxQixHQUFHLFNBQVN0dUIsS0FBSztvQkFDdkQsSUFBSSxDQUFDbWUsY0FBYyxHQUFHbmU7Z0JBQzFCO2dCQUVBOXJCLFdBQVdpRixTQUFTLENBQUNvMUMscUJBQXFCLEdBQUc7b0JBQ3pDLE9BQU8sSUFBSSxDQUFDcFEsY0FBYztnQkFDOUI7Z0JBRUFqcUMsV0FBV2lGLFNBQVMsQ0FBQ3VmLFVBQVUsR0FBRztvQkFDOUIsT0FBTyxJQUFJLENBQUNSLE9BQU8sQ0FBQ3ZhLGFBQWEsQ0FBQyxJQUFJLENBQUNrZ0MsY0FBYztnQkFDekQ7Z0JBRUEzcEMsV0FBV2lGLFNBQVMsQ0FBQ3dmLFVBQVUsR0FBRztvQkFDOUIsT0FBTyxJQUFJLENBQUNSLE9BQU8sQ0FBQ3hhLGFBQWEsQ0FBQyxJQUFJLENBQUNvZ0MsY0FBYztnQkFDekQ7Z0JBRUE3cEMsV0FBV2lGLFNBQVMsQ0FBQ3lmLGdCQUFnQixHQUFHLFNBQVNDLE1BQU07b0JBQ25ELE9BQU94bUIsS0FBSzZrQixPQUFPLENBQUMsSUFBSSxDQUFDa25CLFNBQVMsRUFBRSxJQUFJLENBQUMwUCxJQUFJLEVBQUUsSUFBSSxDQUFDRixlQUFlLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUUxdUMsR0FBRyxDQUFDMFo7Z0JBQ3hGO2dCQUVBM2tCLFdBQVdpRixTQUFTLENBQUMyZixpQkFBaUIsR0FBRyxTQUFTRCxNQUFNO29CQUNwRCxPQUFPQSxTQUFTLElBQUksQ0FBQyt1QixjQUFjO2dCQUN2QztnQkFFQTF6QyxXQUFXaUYsU0FBUyxDQUFDOGYsdUJBQXVCLEdBQUcsU0FBUzFULElBQUk7b0JBQ3hELElBQUksQ0FBQ201QixjQUFjLEdBQUcsSUFBSSxDQUFDeG1CLE9BQU8sQ0FBQ2pnQixPQUFPLENBQUNpRixXQUFXO29CQUN0RCxJQUFJLENBQUN5aEMsY0FBYyxHQUFHLElBQUksQ0FBQ3htQixPQUFPLENBQUNsZ0IsT0FBTyxDQUFDaUYsV0FBVztvQkFDdEQsSUFBSSxDQUFDMGhDLFVBQVUsR0FBRyxJQUFJLENBQUMxbUIsT0FBTyxDQUFDMWdCLFNBQVM7b0JBQ3hDLElBQUksQ0FBQ3FuQyxVQUFVLEdBQUcsSUFBSSxDQUFDMW1CLE9BQU8sQ0FBQzNnQixTQUFTO29CQUN4QyxJQUFJLENBQUNzbkMsT0FBTyxHQUFHLElBQUksQ0FBQzVtQixPQUFPLENBQUN4Z0IsTUFBTTtvQkFDbEMsSUFBSSxDQUFDcW5DLE9BQU8sR0FBRyxJQUFJLENBQUM1bUIsT0FBTyxDQUFDemdCLE1BQU07b0JBQ2xDLElBQUk0VCxLQUFLLElBQUksQ0FBQ3N6QixVQUFVO29CQUN4QixJQUFJcHpCLEtBQUssSUFBSSxDQUFDcXpCLFVBQVU7b0JBQ3hCLFFBQVE7b0JBQ1IsSUFBSXR6QixLQUFLLElBQUksQ0FBQ3V6QixPQUFPO29CQUNyQixJQUFJcnpCLEtBQUssSUFBSSxDQUFDc3pCLE9BQU87b0JBQ3JCLFFBQVE7b0JBQ1IsSUFBSXJ6QixLQUFLLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUlpUCxLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUk4YyxLQUFLLElBQUksQ0FBQ3lKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUM7b0JBQ2xDLElBQUk2USxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLElBQUkyTixLQUFLLElBQUksQ0FBQ3VNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3NFLENBQUM7b0JBQ2xDLElBQUltUCxLQUFLLElBQUksQ0FBQ3NNLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQ3pHLENBQUM7b0JBQ2xDLElBQUlnZCxLQUFLLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ2hnQixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJK1EsS0FBSyxJQUFJLENBQUN1SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQztvQkFDbEMsSUFBSXdoQyxLQUFLL3NDLElBQUk2bkIsR0FBRyxDQUFDNU87b0JBQ2pCLElBQUkrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixnQ0FBZ0M7b0JBQ2hDLElBQUlsRixLQUFLalUsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJcHRDLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDdWdDLGNBQWMsRUFBRSxJQUFJLENBQUNhLGNBQWM7b0JBQzFFLElBQUk5M0IsS0FBS2xVLElBQUk0TyxPQUFPLENBQUNvK0IsSUFBSXJ0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3lnQyxjQUFjLEVBQUUsSUFBSSxDQUFDWSxjQUFjO29CQUMxRSxJQUFJclcsSUFBSWoyQixLQUFLc0QsSUFBSTtvQkFDakIyeUIsRUFBRWlVLFVBQVUsQ0FBQyxHQUFHM3dCLElBQUksR0FBR2hGO29CQUN2QjBoQixFQUFFbVUsVUFBVSxDQUFDLEdBQUcvd0IsSUFBSSxHQUFHL0U7b0JBQ3ZCLE9BQU87b0JBQ1AsMkJBQTJCO29CQUMzQjt3QkFDSSxJQUFJLENBQUNtbkMsSUFBSSxHQUFHcDdDLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSSxJQUFJLENBQUNnSSxhQUFhO3dCQUM5QyxJQUFJLENBQUN3RyxLQUFLLEdBQUc1N0MsS0FBS21MLEtBQUssQ0FBQ25MLEtBQUtrTCxHQUFHLENBQUMrcUIsR0FBRzNoQixLQUFLLElBQUksQ0FBQ21uQyxJQUFJO3dCQUNsRCxJQUFJLENBQUNJLEtBQUssR0FBRzc3QyxLQUFLbUwsS0FBSyxDQUFDb0osSUFBSSxJQUFJLENBQUNrbkMsSUFBSTt3QkFDckMsSUFBSSxDQUFDdjJDLE1BQU0sR0FBRytULEtBQUtFLEtBQUtELEtBQUssSUFBSSxDQUFDMGlDLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssR0FBR3hpQyxLQUFLLElBQUksQ0FBQ3lpQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLO3dCQUNuRixJQUFJLElBQUksQ0FBQzMyQyxNQUFNLEdBQUcsR0FBRzs0QkFDakIsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUNBLE1BQU07d0JBQ2pDO29CQUNKO29CQUNBLG9CQUFvQjtvQkFDcEIsSUFBSSxDQUFDbzJDLFlBQVksR0FBRztvQkFDcEIsSUFBSSxDQUFDclAsTUFBTSxHQUFHO29CQUNkLElBQUksQ0FBQ0QsT0FBTyxHQUFHO29CQUNmLElBQUksSUFBSSxDQUFDSCxhQUFhLEdBQUcsR0FBRzt3QkFDeEIsSUFBSSxDQUFDMlAsSUFBSSxHQUFHbjdDLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSSxJQUFJLENBQUMyQyxhQUFhO3dCQUM5QyxJQUFJLENBQUMyTCxLQUFLLEdBQUcxN0MsS0FBS21MLEtBQUssQ0FBQ25MLEtBQUtrTCxHQUFHLENBQUMrcUIsR0FBRzNoQixLQUFLLElBQUksQ0FBQ2tuQyxJQUFJO3dCQUNsRCxJQUFJLENBQUNHLEtBQUssR0FBRzM3QyxLQUFLbUwsS0FBSyxDQUFDb0osSUFBSSxJQUFJLENBQUNpbkMsSUFBSTt3QkFDckMsSUFBSWhPLFVBQVV2MEIsS0FBS0UsS0FBS0QsS0FBSyxJQUFJLENBQUN3aUMsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHdGlDLEtBQUssSUFBSSxDQUFDdWlDLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7d0JBQ25GLFFBQVE7d0JBQ1IsSUFBSW5PLFVBQVUsR0FBRzs0QkFDYixJQUFJLENBQUM4TixZQUFZLEdBQUcsSUFBSTlOOzRCQUN4QixJQUFJM3lCLElBQUk3YSxLQUFLeUwsR0FBRyxDQUFDd3FCLEdBQUcsSUFBSSxDQUFDdWxCLElBQUk7NEJBQzdCLFFBQVE7NEJBQ1IsWUFBWTs0QkFDWixJQUFJL04sUUFBUSxJQUFJMXRDLE1BQUs4cEIsRUFBRSxHQUFHLElBQUksQ0FBQ2dpQixhQUFhOzRCQUM1QyxRQUFROzRCQUNSLHNCQUFzQjs0QkFDdEIsSUFBSTVWLElBQUksSUFBSSxJQUFJLENBQUNxbEIsWUFBWSxHQUFHLElBQUksQ0FBQ3hQLGNBQWMsR0FBRzJCOzRCQUN0RCxRQUFROzRCQUNSLG1CQUFtQjs0QkFDbkIsSUFBSUMsSUFBSSxJQUFJLENBQUM0TixZQUFZLEdBQUc3TixRQUFRQTs0QkFDcEMsUUFBUTs0QkFDUixpQkFBaUI7NEJBQ2pCLElBQUlqZ0IsSUFBSXRhLEtBQUs0WSxFQUFFOzRCQUNmLFFBQVE7NEJBQ1IsSUFBSSxDQUFDa2dCLE9BQU8sR0FBR3hlLElBQUt5SSxDQUFBQSxJQUFJekksSUFBSWtnQixDQUFBQTs0QkFDNUIsSUFBSSxJQUFJLENBQUMxQixPQUFPLEdBQUcsR0FBRztnQ0FDbEIsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUNBLE9BQU87NEJBQ25DOzRCQUNBLElBQUksQ0FBQ0MsTUFBTSxHQUFHcHhCLElBQUkyUyxJQUFJa2dCLElBQUksSUFBSSxDQUFDMUIsT0FBTzs0QkFDdEMsSUFBSSxDQUFDc1AsWUFBWSxHQUFHOU4sVUFBVSxJQUFJLENBQUN4QixPQUFPOzRCQUMxQyxJQUFJLElBQUksQ0FBQ3NQLFlBQVksR0FBRyxHQUFHO2dDQUN2QixJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJLElBQUksQ0FBQ0EsWUFBWTs0QkFDN0M7d0JBQ0o7b0JBQ0osT0FBTzt3QkFDSCxJQUFJLENBQUNDLGVBQWUsR0FBRztvQkFDM0I7b0JBQ0EsbUJBQW1CO29CQUNuQixJQUFJLElBQUksQ0FBQzFGLGFBQWEsRUFBRTt3QkFDcEIsSUFBSSxDQUFDUCxXQUFXLEdBQUdwOEIsS0FBS0U7d0JBQ3hCLElBQUksSUFBSSxDQUFDazhCLFdBQVcsR0FBRyxHQUFHOzRCQUN0QixJQUFJLENBQUNBLFdBQVcsR0FBRyxJQUFJLElBQUksQ0FBQ0EsV0FBVzt3QkFDM0M7b0JBQ0osT0FBTzt3QkFDSCxJQUFJLENBQUNBLFdBQVcsR0FBRzt3QkFDbkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7b0JBQzFCO29CQUNBLElBQUlyaUMsS0FBS2dCLFlBQVksRUFBRTt3QkFDbkIsa0NBQWtDO3dCQUNsQyxJQUFJLENBQUM2M0IsU0FBUyxJQUFJNzRCLEtBQUtrQixPQUFPO3dCQUM5QixJQUFJLENBQUNtbkMsZUFBZSxJQUFJcm9DLEtBQUtrQixPQUFPO3dCQUNwQyxJQUFJLENBQUNtaEMsY0FBYyxJQUFJcmlDLEtBQUtrQixPQUFPO3dCQUNuQyxJQUFJK0csSUFBSW5iLEtBQUs2a0IsT0FBTyxDQUFDLElBQUksQ0FBQ2tuQixTQUFTLEVBQUUsSUFBSSxDQUFDMFAsSUFBSSxFQUFFLElBQUksQ0FBQ0YsZUFBZSxFQUFFLElBQUksQ0FBQ0MsSUFBSTt3QkFDL0UsSUFBSWpFLEtBQUssSUFBSSxDQUFDeEwsU0FBUyxHQUFHLElBQUksQ0FBQzZQLEtBQUssR0FBRyxJQUFJLENBQUNMLGVBQWUsR0FBRyxJQUFJLENBQUNHLEtBQUssR0FBRyxJQUFJLENBQUNuRyxjQUFjO3dCQUM5RixJQUFJaUMsS0FBSyxJQUFJLENBQUN6TCxTQUFTLEdBQUcsSUFBSSxDQUFDOFAsS0FBSyxHQUFHLElBQUksQ0FBQ04sZUFBZSxHQUFHLElBQUksQ0FBQ0ksS0FBSyxHQUFHLElBQUksQ0FBQ3BHLGNBQWM7d0JBQzlGbjVCLEdBQUdmLE1BQU0sQ0FBQyxJQUFJLENBQUNreEIsVUFBVSxFQUFFcHhCO3dCQUMzQmtCLE1BQU0sSUFBSSxDQUFDb3dCLE9BQU8sR0FBRzhLO3dCQUNyQmo3QixHQUFHelAsTUFBTSxDQUFDLElBQUksQ0FBQzIvQixVQUFVLEVBQUVyeEI7d0JBQzNCb0IsTUFBTSxJQUFJLENBQUNtd0IsT0FBTyxHQUFHOEs7b0JBQ3pCLE9BQU87d0JBQ0gsSUFBSSxDQUFDekwsU0FBUyxHQUFHO3dCQUNqQixJQUFJLENBQUN3UCxlQUFlLEdBQUc7d0JBQ3ZCLElBQUksQ0FBQ2hHLGNBQWMsR0FBRztvQkFDMUI7b0JBQ0EsSUFBSSxDQUFDMXZCLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3FTO29CQUM5QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3VTO29CQUM5QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBMWEsV0FBV2lGLFNBQVMsQ0FBQytmLHdCQUF3QixHQUFHLFNBQVMzVCxJQUFJO29CQUN6RCxJQUFJK0YsS0FBSyxJQUFJLENBQUNzekIsVUFBVTtvQkFDeEIsSUFBSXB6QixLQUFLLElBQUksQ0FBQ3F6QixVQUFVO29CQUN4QixRQUFRO29CQUNSLElBQUl0ekIsS0FBSyxJQUFJLENBQUN1ekIsT0FBTztvQkFDckIsSUFBSXJ6QixLQUFLLElBQUksQ0FBQ3N6QixPQUFPO29CQUNyQixRQUFRO29CQUNSLElBQUl0d0IsS0FBSyxJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUMwRixDQUFDO29CQUNsQyxJQUFJNlEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDO29CQUNsQyxJQUFJMFEsS0FBSyxJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDMEYsQ0FBQztvQkFDbEMsSUFBSStRLEtBQUssSUFBSSxDQUFDdUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzhGLENBQUM7b0JBQ2xDLDBCQUEwQjtvQkFDMUI7d0JBQ0ksSUFBSWlpQyxPQUFPN3RDLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDK3ZDLElBQUksRUFBRWwvQixNQUFNdGMsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUMrdkMsSUFBSSxFQUFFcC9CLE1BQU0sSUFBSSxDQUFDdS9CLEtBQUssR0FBR3AvQixLQUFLLElBQUksQ0FBQ20vQixLQUFLLEdBQUdyL0I7d0JBQzlGLFFBQVE7d0JBQ1IsSUFBSTNPLFVBQVUsQ0FBQyxJQUFJLENBQUM0dEMsWUFBWSxHQUFJek4sQ0FBQUEsT0FBTyxJQUFJLENBQUM1QixNQUFNLEdBQUcsSUFBSSxDQUFDRCxPQUFPLEdBQUcsSUFBSSxDQUFDdVAsZUFBZSxBQUFEO3dCQUMzRixRQUFRO3dCQUNSLElBQUksQ0FBQ0EsZUFBZSxJQUFJN3RDO3dCQUN4QixJQUFJeU4sSUFBSW5iLEtBQUs4TSxHQUFHLENBQUNZLFNBQVMsSUFBSSxDQUFDOHRDLElBQUk7d0JBQ25DLE9BQU87d0JBQ1AsSUFBSWpFLEtBQUs3cEMsVUFBVSxJQUFJLENBQUNndUMsS0FBSzt3QkFDN0IsUUFBUTt3QkFDUixJQUFJbEUsS0FBSzlwQyxVQUFVLElBQUksQ0FBQ2l1QyxLQUFLO3dCQUM3QixRQUFRO3dCQUNSdi9CLEdBQUdmLE1BQU0sQ0FBQ3BDLElBQUlrQzt3QkFDZGtCLE1BQU1uRCxLQUFLcStCO3dCQUNYajdCLEdBQUd6UCxNQUFNLENBQUNzTSxJQUFJZ0M7d0JBQ2RvQixNQUFNbkQsS0FBS28rQjtvQkFDZjtvQkFDQSxvQ0FBb0M7b0JBQ3BDO3dCQUNJLElBQUkzSixPQUFPdHhCLEtBQUtGLEtBQUssSUFBSSxDQUFDczVCLFlBQVk7d0JBQ3RDLFFBQVE7d0JBQ1IsSUFBSWpvQyxVQUFVLENBQUMsSUFBSSxDQUFDNG5DLFdBQVcsR0FBR3pIO3dCQUNsQyxRQUFRO3dCQUNSLElBQUljLGFBQWEsSUFBSSxDQUFDNEcsY0FBYzt3QkFDcEMsUUFBUTt3QkFDUixJQUFJM0csYUFBYTE3QixLQUFLNFksRUFBRSxHQUFHLElBQUksQ0FBQ291QixnQkFBZ0I7d0JBQ2hELFFBQVE7d0JBQ1IsSUFBSSxDQUFDM0UsY0FBYyxHQUFHeDFDLE1BQUsrYSxLQUFLLENBQUMsSUFBSSxDQUFDeTZCLGNBQWMsR0FBRzduQyxTQUFTLENBQUNraEMsWUFBWUE7d0JBQzdFbGhDLFVBQVUsSUFBSSxDQUFDNm5DLGNBQWMsR0FBRzVHO3dCQUNoQ3R5QixNQUFNbkQsS0FBS3hMO3dCQUNYNk8sTUFBTW5ELEtBQUsxTDtvQkFDZjtvQkFDQSxpQ0FBaUM7b0JBQ2pDO3dCQUNJLElBQUltZ0MsT0FBTzd0QyxLQUFLeUwsR0FBRyxDQUFDLElBQUksQ0FBQ2d3QyxJQUFJLEVBQUVuL0IsTUFBTXRjLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDZ3dDLElBQUksRUFBRXIvQixNQUFNLElBQUksQ0FBQ3kvQixLQUFLLEdBQUd0L0IsS0FBSyxJQUFJLENBQUNxL0IsS0FBSyxHQUFHdi9CO3dCQUM5RixRQUFRO3dCQUNSLElBQUkzTyxVQUFVLENBQUMsSUFBSSxDQUFDeEksTUFBTSxHQUFHMm9DO3dCQUM3QixRQUFRO3dCQUNSLElBQUksQ0FBQzlCLFNBQVMsSUFBSXIrQjt3QkFDbEIsSUFBSXlOLElBQUluYixLQUFLOE0sR0FBRyxDQUFDWSxTQUFTLElBQUksQ0FBQyt0QyxJQUFJO3dCQUNuQyxPQUFPO3dCQUNQLElBQUlsRSxLQUFLN3BDLFVBQVUsSUFBSSxDQUFDa3VDLEtBQUs7d0JBQzdCLFFBQVE7d0JBQ1IsSUFBSXBFLEtBQUs5cEMsVUFBVSxJQUFJLENBQUNtdUMsS0FBSzt3QkFDN0IsUUFBUTt3QkFDUnovQixHQUFHZixNQUFNLENBQUNwQyxJQUFJa0M7d0JBQ2RrQixNQUFNbkQsS0FBS3ErQjt3QkFDWGo3QixHQUFHelAsTUFBTSxDQUFDc00sSUFBSWdDO3dCQUNkb0IsTUFBTW5ELEtBQUtvK0I7b0JBQ2Y7b0JBQ0EsSUFBSSxDQUFDM3hCLE9BQU8sQ0FBQy9mLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3FTO29CQUM5QixJQUFJLENBQUN5SixPQUFPLENBQUMvZixVQUFVLENBQUM4RixDQUFDLEdBQUd5UTtvQkFDNUIsSUFBSSxDQUFDeUosT0FBTyxDQUFDaGdCLFVBQVUsQ0FBQzBGLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQ3VTO29CQUM5QixJQUFJLENBQUN3SixPQUFPLENBQUNoZ0IsVUFBVSxDQUFDOEYsQ0FBQyxHQUFHMlE7Z0JBQ2hDO2dCQUVBMWEsV0FBV2lGLFNBQVMsQ0FBQ2dnQix3QkFBd0IsR0FBRyxTQUFTNVQsSUFBSTtvQkFDekQsSUFBSW1HLEtBQUssSUFBSSxDQUFDd00sT0FBTyxDQUFDOWYsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsSUFBSWlQLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDOWYsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSWlhLEtBQUssSUFBSSxDQUFDdU0sT0FBTyxDQUFDL2YsVUFBVSxDQUFDc0UsQ0FBQztvQkFDbEMsSUFBSW1QLEtBQUssSUFBSSxDQUFDc00sT0FBTyxDQUFDL2YsVUFBVSxDQUFDekcsQ0FBQztvQkFDbEMsSUFBSTh0QyxLQUFLL3NDLElBQUk2bkIsR0FBRyxDQUFDNU87b0JBQ2pCLElBQUkrekIsS0FBS2h0QyxJQUFJNm5CLEdBQUcsQ0FBQzFPO29CQUNqQixJQUFJbEYsS0FBS2pVLElBQUk0TyxPQUFPLENBQUNtK0IsSUFBSXB0QyxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3VnQyxjQUFjLEVBQUUsSUFBSSxDQUFDYSxjQUFjO29CQUMxRSxJQUFJOTNCLEtBQUtsVSxJQUFJNE8sT0FBTyxDQUFDbytCLElBQUlydEMsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUN5Z0MsY0FBYyxFQUFFLElBQUksQ0FBQ1ksY0FBYztvQkFDMUUsSUFBSXJXLElBQUlqMkIsS0FBS3NELElBQUk7b0JBQ2pCMnlCLEVBQUVpVSxVQUFVLENBQUMsR0FBRzN3QixJQUFJLEdBQUdoRjtvQkFDdkIwaEIsRUFBRW1VLFVBQVUsQ0FBQyxHQUFHL3dCLElBQUksR0FBRy9FO29CQUN2QixJQUFJNm5DLEtBQUs5N0MsSUFBSTRPLE9BQU8sQ0FBQ20rQixJQUFJLElBQUksQ0FBQ2dJLGFBQWE7b0JBQzNDLElBQUlnSCxNQUFNcDhDLEtBQUttTCxLQUFLLENBQUNuTCxLQUFLa0wsR0FBRyxDQUFDK3FCLEdBQUczaEIsS0FBSzZuQztvQkFDdEMsUUFBUTtvQkFDUixJQUFJRSxNQUFNcjhDLEtBQUttTCxLQUFLLENBQUNvSixJQUFJNG5DO29CQUN6QixRQUFRO29CQUNSLElBQUl0aEMsSUFBSTdhLEtBQUt5TCxHQUFHLENBQUN3cUIsR0FBR2ttQjtvQkFDcEIsUUFBUTtvQkFDUixJQUFJek8sSUFBSSxJQUFJLENBQUNuQixVQUFVLEdBQUcsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDbVAsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHLElBQUksQ0FBQ2xQLE9BQU8sR0FBRyxJQUFJLENBQUNtUCxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLO29CQUMzSCxRQUFRO29CQUNSLElBQUludUM7b0JBQ0osUUFBUTtvQkFDUixJQUFJZ2dDLEtBQUssR0FBRzt3QkFDUmhnQyxVQUFVLENBQUNtTixJQUFJNnlCO29CQUNuQixPQUFPO3dCQUNIaGdDLFVBQVU7b0JBQ2Q7b0JBQ0EsSUFBSXlOLElBQUluYixLQUFLOE0sR0FBRyxDQUFDWSxTQUFTeXVDO29CQUMxQixPQUFPO29CQUNQLElBQUk1RSxLQUFLN3BDLFVBQVUwdUM7b0JBQ25CLFFBQVE7b0JBQ1IsSUFBSTVFLEtBQUs5cEMsVUFBVTJ1QztvQkFDbkIsUUFBUTtvQkFDUmhqQyxHQUFHZ0MsTUFBTSxDQUFDLElBQUksQ0FBQ2t4QixVQUFVLEVBQUVweEI7b0JBQzNCN0IsTUFBTSxJQUFJLENBQUNtekIsT0FBTyxHQUFHOEs7b0JBQ3JCaCtCLEdBQUcxTSxNQUFNLENBQUMsSUFBSSxDQUFDMi9CLFVBQVUsRUFBRXJ4QjtvQkFDM0IzQixNQUFNLElBQUksQ0FBQ2t6QixPQUFPLEdBQUc4SztvQkFDckIsSUFBSSxDQUFDM3hCLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3NFLENBQUMsQ0FBQ04sR0FBRyxDQUFDc1A7b0JBQzlCLElBQUksQ0FBQ3dNLE9BQU8sQ0FBQzlmLFVBQVUsQ0FBQ3pHLENBQUMsR0FBR2dhO29CQUM1QixJQUFJLENBQUN3TSxPQUFPLENBQUMvZixVQUFVLENBQUNzRSxDQUFDLENBQUNOLEdBQUcsQ0FBQ3dQO29CQUM5QixJQUFJLENBQUN1TSxPQUFPLENBQUMvZixVQUFVLENBQUN6RyxDQUFDLEdBQUdrYTtvQkFDNUIsT0FBT3paLE1BQUswaEIsR0FBRyxDQUFDNUcsTUFBTXpZLFNBQVN1WSxVQUFVO2dCQUM3QztZQUdBO1lBQUU7Z0JBQUMsWUFBVztnQkFBRSxlQUFjO2dCQUFFLG1CQUFrQjtnQkFBRyxtQkFBa0I7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsbUJBQWtCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLHNCQUFxQjtnQkFBRyxrQkFBaUI7Z0JBQUcsbUJBQWtCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTcGIsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3JVLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHKzlDO2dCQUVqQixJQUFJNzVDLFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJMGlCLFNBQVMxaUIsU0FBUTtnQkFFckIsSUFBSWc5QyxlQUFlaDlDLFNBQVE7Z0JBRTNCKzhDLFNBQVNuUixNQUFNLEdBQUdvUjtnQkFFbEJELFNBQVN4MUMsU0FBUyxHQUFHbWIsT0FBT3E2QixTQUFTblIsTUFBTSxDQUFDcmtDLFNBQVM7Z0JBRXJEdzFDLFNBQVNwUixJQUFJLEdBQUc7Z0JBRWhCOztDQUVDLEdBQ0QsU0FBU29SLFNBQVNFLEVBQUUsRUFBRUMsRUFBRSxFQUFFandDLE1BQU0sRUFBRWpKLEtBQUs7b0JBQ25DLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWSs0QyxRQUFPLEdBQUk7d0JBQzdCLE9BQU8sSUFBSUEsU0FBU0UsSUFBSUMsSUFBSWp3QyxRQUFRako7b0JBQ3hDO29CQUNBKzRDLFNBQVNuUixNQUFNLENBQUN2ckMsSUFBSSxDQUFDLElBQUk7b0JBQ3pCLElBQUksQ0FBQzg4QyxTQUFTLENBQUNGLElBQUlDLElBQUlqd0MsUUFBUWpKO2dCQUNuQztZQUdBO1lBQUU7Z0JBQUMsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7WUFBRTtTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNoRSxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDcEcsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdERoRSxRQUFPRCxPQUFPLEdBQUdvK0M7Z0JBRWpCLElBQUlsNkMsVUFBU2xELFNBQVE7Z0JBRXJCLElBQUkwaUIsU0FBUzFpQixTQUFRO2dCQUVyQixJQUFJbUQsVUFBVW5ELFNBQVE7Z0JBRXRCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUllLE9BQU9mLFNBQVE7Z0JBRW5CLElBQUk2QyxXQUFXN0MsU0FBUTtnQkFFdkIsSUFBSWdCLFFBQVFoQixTQUFRO2dCQUVwQixJQUFJcTlDLFlBQVlyOUMsU0FBUTtnQkFFeEJvOUMsV0FBV3hSLE1BQU0sR0FBRzVxQztnQkFFcEJvOEMsV0FBVzcxQyxTQUFTLEdBQUdtYixPQUFPMDZCLFdBQVd4UixNQUFNLENBQUNya0MsU0FBUztnQkFFekQ2MUMsV0FBV3pSLElBQUksR0FBRztnQkFFbEI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVN5UixXQUFXMWlCLFFBQVEsRUFBRWpOLElBQUk7b0JBQzlCLElBQUksQ0FBRSxDQUFBLElBQUksWUFBWTJ2QixVQUFTLEdBQUk7d0JBQy9CLE9BQU8sSUFBSUEsV0FBVzFpQixVQUFVak47b0JBQ3BDO29CQUNBMnZCLFdBQVd4UixNQUFNLENBQUN2ckMsSUFBSSxDQUFDLElBQUk7b0JBQzNCLElBQUksQ0FBQ3FGLE1BQU0sR0FBRzAzQyxXQUFXelIsSUFBSTtvQkFDN0IsSUFBSSxDQUFDdDNCLFFBQVEsR0FBR3hSLFNBQVMwbkIsYUFBYTtvQkFDdEMsSUFBSSxDQUFDd1IsVUFBVSxHQUFHLEVBQUU7b0JBQ3BCLElBQUksQ0FBQ1osT0FBTyxHQUFHO29CQUNmLElBQUksQ0FBQ21pQixZQUFZLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO29CQUNwQixJQUFJLENBQUNDLGVBQWUsR0FBRztvQkFDdkIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7b0JBQ3ZCLElBQUkvaUIsWUFBWUEsU0FBU3A2QixNQUFNLEVBQUU7d0JBQzdCLElBQUltdEIsTUFBTTs0QkFDTixJQUFJLENBQUNpd0IsV0FBVyxDQUFDaGpCO3dCQUNyQixPQUFPOzRCQUNILElBQUksQ0FBQ2lqQixZQUFZLENBQUNqakI7d0JBQ3RCO29CQUNKO2dCQUNKO2dCQUVBLGtDQUFrQztnQkFDbEMsOEJBQThCO2dCQUM5QixvQkFBb0I7Z0JBQ3BCLElBQUk7Z0JBQ0o7Ozs7O0NBS0MsR0FDRDBpQixXQUFXNzFDLFNBQVMsQ0FBQ20yQyxXQUFXLEdBQUcsU0FBU2hqQixRQUFRO29CQUNoRDEzQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQ2kzQixVQUFVLENBQUN6N0IsTUFBTSxJQUFJLEtBQUssSUFBSSxDQUFDNjZCLE9BQU8sSUFBSTtvQkFDeEVuNEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzQxQixTQUFTcDZCLE1BQU0sSUFBSTtvQkFDNUMsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUl5NkIsU0FBU3A2QixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDdEMsSUFBSTI5QyxLQUFLbGpCLFFBQVEsQ0FBQ3o2QixJQUFJLEVBQUU7d0JBQ3hCLElBQUk0OUMsS0FBS25qQixRQUFRLENBQUN6NkIsRUFBRTt3QkFDcEIsMkVBQTJFO3dCQUMzRStDLFdBQVdFLFFBQU80QixNQUFNLENBQUNyRSxLQUFLd3FDLGVBQWUsQ0FBQzJTLElBQUlDLE1BQU1oN0MsU0FBU3VuQixpQkFBaUI7b0JBQ3RGO29CQUNBLElBQUksQ0FBQzJSLFVBQVUsQ0FBQ3o3QixNQUFNLEdBQUc7b0JBQ3pCLElBQUksQ0FBQzY2QixPQUFPLEdBQUdULFNBQVNwNkIsTUFBTSxHQUFHO29CQUNqQyxJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSXk2QixTQUFTcDZCLE1BQU0sRUFBRSxFQUFFTCxFQUFHO3dCQUN0QyxJQUFJLENBQUM4N0IsVUFBVSxDQUFDOTdCLEVBQUUsR0FBR3k2QixRQUFRLENBQUN6NkIsRUFBRSxDQUFDaUcsS0FBSztvQkFDMUM7b0JBQ0EsSUFBSSxDQUFDNjFCLFVBQVUsQ0FBQ3JCLFNBQVNwNkIsTUFBTSxDQUFDLEdBQUdvNkIsUUFBUSxDQUFDLEVBQUUsQ0FBQ3gwQixLQUFLO29CQUNwRCxJQUFJLENBQUNvM0MsWUFBWSxHQUFHLElBQUksQ0FBQ3ZoQixVQUFVLENBQUMsSUFBSSxDQUFDWixPQUFPLEdBQUcsRUFBRTtvQkFDckQsSUFBSSxDQUFDb2lCLFlBQVksR0FBRyxJQUFJLENBQUN4aEIsVUFBVSxDQUFDLEVBQUU7b0JBQ3RDLElBQUksQ0FBQ3loQixlQUFlLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO29CQUN2QixPQUFPLElBQUk7Z0JBQ2Y7Z0JBRUE7Ozs7O0NBS0MsR0FDREwsV0FBVzcxQyxTQUFTLENBQUNvMkMsWUFBWSxHQUFHLFNBQVNqakIsUUFBUTtvQkFDakQxM0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxJQUFJLENBQUNpM0IsVUFBVSxDQUFDejdCLE1BQU0sSUFBSSxLQUFLLElBQUksQ0FBQzY2QixPQUFPLElBQUk7b0JBQ3hFbjRCLFdBQVdFLFFBQU80QixNQUFNLENBQUM0MUIsU0FBU3A2QixNQUFNLElBQUk7b0JBQzVDLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJeTZCLFNBQVNwNkIsTUFBTSxFQUFFLEVBQUVMLEVBQUc7d0JBQ3RDLDJFQUEyRTt3QkFDM0UsSUFBSTI5QyxLQUFLbGpCLFFBQVEsQ0FBQ3o2QixJQUFJLEVBQUU7d0JBQ3hCLElBQUk0OUMsS0FBS25qQixRQUFRLENBQUN6NkIsRUFBRTt3QkFDcEIrQyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDckUsS0FBS3dxQyxlQUFlLENBQUMyUyxJQUFJQyxNQUFNaDdDLFNBQVN1bkIsaUJBQWlCO29CQUN0RjtvQkFDQSxJQUFJLENBQUMrUSxPQUFPLEdBQUdULFNBQVNwNkIsTUFBTTtvQkFDOUIsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUl5NkIsU0FBU3A2QixNQUFNLEVBQUUsRUFBRUwsRUFBRzt3QkFDdEMsSUFBSSxDQUFDODdCLFVBQVUsQ0FBQzk3QixFQUFFLEdBQUd5NkIsUUFBUSxDQUFDejZCLEVBQUUsQ0FBQ2lHLEtBQUs7b0JBQzFDO29CQUNBLElBQUksQ0FBQ3MzQyxlQUFlLEdBQUc7b0JBQ3ZCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO29CQUN2QixJQUFJLENBQUNILFlBQVksR0FBRztvQkFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7b0JBQ3BCLE9BQU8sSUFBSTtnQkFDZjtnQkFFQTs7O0NBR0MsR0FDREgsV0FBVzcxQyxTQUFTLENBQUN1MkMsY0FBYyxHQUFHLFNBQVNDLFVBQVU7b0JBQ3JELElBQUksQ0FBQ1QsWUFBWSxHQUFHUztvQkFDcEIsSUFBSSxDQUFDUCxlQUFlLEdBQUc7Z0JBQzNCO2dCQUVBOzs7Q0FHQyxHQUNESixXQUFXNzFDLFNBQVMsQ0FBQ3kyQyxjQUFjLEdBQUcsU0FBU0MsVUFBVTtvQkFDckQsSUFBSSxDQUFDVixZQUFZLEdBQUdVO29CQUNwQixJQUFJLENBQUNSLGVBQWUsR0FBRztnQkFDM0I7Z0JBRUE7O0NBRUMsR0FDREwsV0FBVzcxQyxTQUFTLENBQUNpa0IsTUFBTSxHQUFHO29CQUMxQixJQUFJdGxCLFFBQVEsSUFBSWszQztvQkFDaEJsM0MsTUFBTWc0QyxXQUFXLENBQUMsSUFBSSxDQUFDbmlCLFVBQVU7b0JBQ2pDNzFCLE1BQU1SLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU07b0JBQzFCUSxNQUFNbU8sUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtvQkFDOUJuTyxNQUFNbzNDLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7b0JBQ3RDcDNDLE1BQU1xM0MsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtvQkFDdENyM0MsTUFBTXMzQyxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO29CQUM1Q3QzQyxNQUFNdTNDLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWU7b0JBQzVDLE9BQU92M0M7Z0JBQ1g7Z0JBRUFrM0MsV0FBVzcxQyxTQUFTLENBQUM2YyxhQUFhLEdBQUc7b0JBQ2pDLGdDQUFnQztvQkFDaEMsT0FBTyxJQUFJLENBQUMrVyxPQUFPLEdBQUc7Z0JBQzFCO2dCQUVBLG9CQUFvQjtnQkFDcEJpaUIsV0FBVzcxQyxTQUFTLENBQUM0MkMsWUFBWSxHQUFHLFNBQVMvdUMsSUFBSSxFQUFFdVUsVUFBVTtvQkFDekQzZ0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxLQUFLNmUsY0FBY0EsYUFBYSxJQUFJLENBQUN3WCxPQUFPLEdBQUc7b0JBQ3hFL3JCLEtBQUsxSixNQUFNLEdBQUcyM0MsVUFBVTFSLElBQUk7b0JBQzVCdjhCLEtBQUtpRixRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO29CQUM3QmpGLEtBQUtndkMsU0FBUyxHQUFHLElBQUksQ0FBQ3JpQixVQUFVLENBQUNwWSxXQUFXO29CQUM1Q3ZVLEtBQUtpdkMsU0FBUyxHQUFHLElBQUksQ0FBQ3RpQixVQUFVLENBQUNwWSxhQUFhLEVBQUU7b0JBQ2hELElBQUlBLGFBQWEsR0FBRzt3QkFDaEJ2VSxLQUFLa3ZDLFNBQVMsR0FBRyxJQUFJLENBQUN2aUIsVUFBVSxDQUFDcFksYUFBYSxFQUFFO3dCQUNoRHZVLEtBQUttdkMsWUFBWSxHQUFHO29CQUN4QixPQUFPO3dCQUNIbnZDLEtBQUtrdkMsU0FBUyxHQUFHLElBQUksQ0FBQ2hCLFlBQVk7d0JBQ2xDbHVDLEtBQUttdkMsWUFBWSxHQUFHLElBQUksQ0FBQ2YsZUFBZTtvQkFDNUM7b0JBQ0EsSUFBSTc1QixhQUFhLElBQUksQ0FBQ3dYLE9BQU8sR0FBRyxHQUFHO3dCQUMvQi9yQixLQUFLb3ZDLFNBQVMsR0FBRyxJQUFJLENBQUN6aUIsVUFBVSxDQUFDcFksYUFBYSxFQUFFO3dCQUNoRHZVLEtBQUtxdkMsWUFBWSxHQUFHO29CQUN4QixPQUFPO3dCQUNIcnZDLEtBQUtvdkMsU0FBUyxHQUFHLElBQUksQ0FBQ2pCLFlBQVk7d0JBQ2xDbnVDLEtBQUtxdkMsWUFBWSxHQUFHLElBQUksQ0FBQ2hCLGVBQWU7b0JBQzVDO2dCQUNKO2dCQUVBTCxXQUFXNzFDLFNBQVMsQ0FBQ20wQixTQUFTLEdBQUcsU0FBU3JILEtBQUs7b0JBQzNDcnhCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsS0FBS3V2QixTQUFTQSxTQUFTLElBQUksQ0FBQzhHLE9BQU87b0JBQzVELElBQUk5RyxRQUFRLElBQUksQ0FBQzhHLE9BQU8sRUFBRTt3QkFDdEIsT0FBTyxJQUFJLENBQUNZLFVBQVUsQ0FBQzFILE1BQU07b0JBQ2pDLE9BQU87d0JBQ0gsT0FBTyxJQUFJLENBQUMwSCxVQUFVLENBQUMsRUFBRTtvQkFDN0I7Z0JBQ0o7Z0JBRUE7O0NBRUMsR0FDRHFoQixXQUFXNzFDLFNBQVMsQ0FBQ2lkLFNBQVMsR0FBRyxTQUFTN1osRUFBRSxFQUFFMUUsQ0FBQztvQkFDM0MsT0FBTztnQkFDWDtnQkFFQW0zQyxXQUFXNzFDLFNBQVMsQ0FBQ2tkLE9BQU8sR0FBRyxTQUFTQyxNQUFNLEVBQUVDLEtBQUssRUFBRWhhLEVBQUUsRUFBRWdaLFVBQVU7b0JBQ2pFM2dCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsS0FBSzZlLGNBQWNBLGFBQWEsSUFBSSxDQUFDd1gsT0FBTztvQkFDckUsSUFBSXVqQixZQUFZLElBQUlyQixVQUFVLElBQUksQ0FBQzNoQixTQUFTLENBQUMvWCxhQUFhLElBQUksQ0FBQytYLFNBQVMsQ0FBQy9YLGFBQWE7b0JBQ3RGLE9BQU8rNkIsVUFBVWo2QixPQUFPLENBQUNDLFFBQVFDLE9BQU9oYSxJQUFJO2dCQUNoRDtnQkFFQXl5QyxXQUFXNzFDLFNBQVMsQ0FBQ3dkLFdBQVcsR0FBRyxTQUFTbkIsSUFBSSxFQUFFalosRUFBRSxFQUFFZ1osVUFBVTtvQkFDNUQzZ0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxLQUFLNmUsY0FBY0EsYUFBYSxJQUFJLENBQUN3WCxPQUFPO29CQUNyRSxJQUFJeWlCLEtBQUsvOEMsVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDK3dCLFNBQVMsQ0FBQy9YO29CQUM5QyxJQUFJazZCLEtBQUtoOUMsVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDK3dCLFNBQVMsQ0FBQy9YLGFBQWE7b0JBQzNEQyxLQUFLMlQsYUFBYSxDQUFDcW1CLElBQUlDO2dCQUMzQjtnQkFFQTs7Q0FFQyxHQUNEVCxXQUFXNzFDLFNBQVMsQ0FBQ3FkLFdBQVcsR0FBRyxTQUFTdlgsUUFBUSxFQUFFaVcsT0FBTztvQkFDekRqVyxTQUFTTCxJQUFJLEdBQUc7b0JBQ2hCSyxTQUFTSixNQUFNLEdBQUd4TSxLQUFLa29CLEdBQUc7b0JBQzFCdGIsU0FBU0gsQ0FBQyxHQUFHO2dCQUNqQjtnQkFFQWt3QyxXQUFXNzFDLFNBQVMsQ0FBQ21rQixvQkFBb0IsR0FBRyxTQUFTNUcsS0FBSyxFQUFFbkIsVUFBVTtvQkFDbEUzZ0IsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxLQUFLNmUsY0FBY0EsYUFBYSxJQUFJLENBQUN3WCxPQUFPO29CQUNyRXJXLE1BQU1nWCxRQUFRLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ0osU0FBUyxDQUFDL1g7b0JBQ25DbUIsTUFBTWdYLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDSixTQUFTLENBQUMvWCxhQUFhO29CQUNoRG1CLE1BQU1pWCxVQUFVLEdBQUdqWCxNQUFNZ1gsUUFBUTtvQkFDakNoWCxNQUFNcVcsT0FBTyxHQUFHO29CQUNoQnJXLE1BQU16USxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO2dCQUNsQztZQUdBO1lBQUU7Z0JBQUMsZUFBYztnQkFBRSxZQUFXO2dCQUFFLHFCQUFvQjtnQkFBRyxrQkFBaUI7Z0JBQUcsaUJBQWdCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxtQkFBa0I7Z0JBQUcsZUFBYztZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU3JVLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUM5UCxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBRzIvQztnQkFFakIsSUFBSXo3QyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUltRCxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSWUsT0FBT2YsU0FBUTtnQkFFbkIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJZ0IsUUFBUWhCLFNBQVE7Z0JBRXBCMitDLFlBQVkvUyxNQUFNLEdBQUc1cUM7Z0JBRXJCMjlDLFlBQVlwM0MsU0FBUyxHQUFHbWIsT0FBT2k4QixZQUFZL1MsTUFBTSxDQUFDcmtDLFNBQVM7Z0JBRTNEbzNDLFlBQVloVCxJQUFJLEdBQUc7Z0JBRW5CLFNBQVNnVCxZQUFZNStDLENBQUMsRUFBRXV0QixDQUFDO29CQUNyQixJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVlxeEIsV0FBVSxHQUFJO3dCQUNoQyxPQUFPLElBQUlBLFlBQVk1K0MsR0FBR3V0QjtvQkFDOUI7b0JBQ0FxeEIsWUFBWS9TLE1BQU0sQ0FBQ3ZyQyxJQUFJLENBQUMsSUFBSTtvQkFDNUIsSUFBSSxDQUFDcUYsTUFBTSxHQUFHaTVDLFlBQVloVCxJQUFJO29CQUM5QixJQUFJLENBQUNpVCxHQUFHLEdBQUduK0MsS0FBS3NELElBQUk7b0JBQ3BCLElBQUksQ0FBQ3NRLFFBQVEsR0FBRztvQkFDaEIsSUFBSSxPQUFPdFUsTUFBTSxZQUFZVSxLQUFLc0UsT0FBTyxDQUFDaEYsSUFBSTt3QkFDMUMsSUFBSSxDQUFDNitDLEdBQUcsQ0FBQ3AwQyxHQUFHLENBQUN6Szt3QkFDYixJQUFJLE9BQU91dEIsTUFBTSxVQUFVOzRCQUN2QixJQUFJLENBQUNqWixRQUFRLEdBQUdpWjt3QkFDcEI7b0JBQ0osT0FBTyxJQUFJLE9BQU92dEIsTUFBTSxVQUFVO3dCQUM5QixJQUFJLENBQUNzVSxRQUFRLEdBQUd0VTtvQkFDcEI7Z0JBQ0o7Z0JBRUE0K0MsWUFBWXAzQyxTQUFTLENBQUNna0IsU0FBUyxHQUFHO29CQUM5QixPQUFPLElBQUksQ0FBQ2xYLFFBQVE7Z0JBQ3hCO2dCQUVBc3FDLFlBQVlwM0MsU0FBUyxDQUFDcXZCLFNBQVMsR0FBRztvQkFDOUIsT0FBTyxJQUFJLENBQUNnb0IsR0FBRztnQkFDbkI7Z0JBRUFELFlBQVlwM0MsU0FBUyxDQUFDbTBCLFNBQVMsR0FBRyxTQUFTckgsS0FBSztvQkFDNUNyeEIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3V2QixTQUFTO29CQUNsQyxPQUFPLElBQUksQ0FBQ3VxQixHQUFHO2dCQUNuQjtnQkFFQUQsWUFBWXAzQyxTQUFTLENBQUN5MEIsY0FBYyxHQUFHLFNBQVMzSCxLQUFLO29CQUNqRCxPQUFPO2dCQUNYO2dCQUVBOztDQUVDLEdBQ0RzcUIsWUFBWXAzQyxTQUFTLENBQUNpa0IsTUFBTSxHQUFHO29CQUMzQixJQUFJdGxCLFFBQVEsSUFBSXk0QztvQkFDaEJ6NEMsTUFBTVIsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtvQkFDMUJRLE1BQU1tTyxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO29CQUM5Qm5PLE1BQU0wNEMsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDMTRDLEtBQUs7b0JBQzFCLE9BQU9BO2dCQUNYO2dCQUVBeTRDLFlBQVlwM0MsU0FBUyxDQUFDNmMsYUFBYSxHQUFHO29CQUNsQyxPQUFPO2dCQUNYO2dCQUVBdTZCLFlBQVlwM0MsU0FBUyxDQUFDaWQsU0FBUyxHQUFHLFNBQVM3WixFQUFFLEVBQUUxRSxDQUFDO29CQUM1QyxJQUFJZ0gsU0FBU3hNLEtBQUtrTCxHQUFHLENBQUNoQixHQUFHMUUsQ0FBQyxFQUFFbkYsSUFBSTRPLE9BQU8sQ0FBQy9FLEdBQUd4RSxDQUFDLEVBQUUsSUFBSSxDQUFDeTRDLEdBQUc7b0JBQ3RELElBQUlsb0IsSUFBSWoyQixLQUFLaUwsR0FBRyxDQUFDekYsR0FBR2dIO29CQUNwQixPQUFPeE0sS0FBS3lMLEdBQUcsQ0FBQ3dxQixHQUFHQSxNQUFNLElBQUksQ0FBQ3JpQixRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO2dCQUMxRDtnQkFFQSw0RUFBNEU7Z0JBQzVFLHFCQUFxQjtnQkFDckIsZ0JBQWdCO2dCQUNoQixtQkFBbUI7Z0JBQ25Cc3FDLFlBQVlwM0MsU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFaGEsRUFBRSxFQUFFZ1osVUFBVTtvQkFDbEUsSUFBSTdmLFdBQVdyRCxLQUFLa0wsR0FBRyxDQUFDaEIsR0FBRzFFLENBQUMsRUFBRW5GLElBQUk0TyxPQUFPLENBQUMvRSxHQUFHeEUsQ0FBQyxFQUFFLElBQUksQ0FBQ3k0QyxHQUFHO29CQUN4RCxJQUFJaC9DLElBQUlhLEtBQUtpTCxHQUFHLENBQUNpWixNQUFNd1AsRUFBRSxFQUFFcndCO29CQUMzQixJQUFJd3BCLElBQUk3c0IsS0FBS3lMLEdBQUcsQ0FBQ3RNLEdBQUdBLEtBQUssSUFBSSxDQUFDeVUsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtvQkFDdEQsNEJBQTRCO29CQUM1QixJQUFJMVUsSUFBSWMsS0FBS2lMLEdBQUcsQ0FBQ2laLE1BQU15UCxFQUFFLEVBQUV6UCxNQUFNd1AsRUFBRTtvQkFDbkMsSUFBSXJwQixJQUFJckssS0FBS3lMLEdBQUcsQ0FBQ3RNLEdBQUdEO29CQUNwQixJQUFJay9DLEtBQUtwK0MsS0FBS3lMLEdBQUcsQ0FBQ3ZNLEdBQUdBO29CQUNyQixJQUFJbS9DLFFBQVFoMEMsSUFBSUEsSUFBSSt6QyxLQUFLdnhCO29CQUN6QixxREFBcUQ7b0JBQ3JELElBQUl3eEIsUUFBUSxLQUFLRCxLQUFLcitDLE1BQUtzb0IsT0FBTyxFQUFFO3dCQUNoQyxPQUFPO29CQUNYO29CQUNBLDhEQUE4RDtvQkFDOUQsSUFBSS9vQixJQUFJLENBQUUrSyxDQUFBQSxJQUFJdEssTUFBSzZoQixJQUFJLENBQUN5OEIsTUFBSztvQkFDN0IsNENBQTRDO29CQUM1QyxJQUFJLEtBQUsvK0MsS0FBS0EsS0FBSzRrQixNQUFNdVAsV0FBVyxHQUFHMnFCLElBQUk7d0JBQ3ZDOStDLEtBQUs4K0M7d0JBQ0xuNkIsT0FBTzZQLFFBQVEsR0FBR3gwQjt3QkFDbEIya0IsT0FBT3BLLE1BQU0sR0FBRzdaLEtBQUtrTCxHQUFHLENBQUMvTCxHQUFHYSxLQUFLOE0sR0FBRyxDQUFDeE4sR0FBR0o7d0JBQ3hDK2tCLE9BQU9wSyxNQUFNLENBQUNLLFNBQVM7d0JBQ3ZCLE9BQU87b0JBQ1g7b0JBQ0EsT0FBTztnQkFDWDtnQkFFQWdrQyxZQUFZcDNDLFNBQVMsQ0FBQ3dkLFdBQVcsR0FBRyxTQUFTbkIsSUFBSSxFQUFFalosRUFBRSxFQUFFZ1osVUFBVTtvQkFDN0QsSUFBSTFkLElBQUl4RixLQUFLa0wsR0FBRyxDQUFDaEIsR0FBRzFFLENBQUMsRUFBRW5GLElBQUk0TyxPQUFPLENBQUMvRSxHQUFHeEUsQ0FBQyxFQUFFLElBQUksQ0FBQ3k0QyxHQUFHO29CQUNqRGg3QixLQUFLNFMsVUFBVSxDQUFDaHNCLEdBQUcsQ0FBQ3ZFLEVBQUUrWixDQUFDLEdBQUcsSUFBSSxDQUFDM0wsUUFBUSxFQUFFcE8sRUFBRWlhLENBQUMsR0FBRyxJQUFJLENBQUM3TCxRQUFRO29CQUM1RHVQLEtBQUs2UyxVQUFVLENBQUNqc0IsR0FBRyxDQUFDdkUsRUFBRStaLENBQUMsR0FBRyxJQUFJLENBQUMzTCxRQUFRLEVBQUVwTyxFQUFFaWEsQ0FBQyxHQUFHLElBQUksQ0FBQzdMLFFBQVE7Z0JBQ2hFO2dCQUVBc3FDLFlBQVlwM0MsU0FBUyxDQUFDcWQsV0FBVyxHQUFHLFNBQVN2WCxRQUFRLEVBQUVpVyxPQUFPO29CQUMxRGpXLFNBQVNMLElBQUksR0FBR3NXLFVBQVU5aUIsTUFBSzhwQixFQUFFLEdBQUcsSUFBSSxDQUFDalcsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtvQkFDakVoSCxTQUFTSixNQUFNLEdBQUcsSUFBSSxDQUFDMnhDLEdBQUc7b0JBQzFCLGlDQUFpQztvQkFDakN2eEMsU0FBU0gsQ0FBQyxHQUFHRyxTQUFTTCxJQUFJLEdBQUksQ0FBQSxLQUFLLElBQUksQ0FBQ3FILFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVEsR0FBRzVULEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDMHlDLEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsQ0FBQTtnQkFDbEc7Z0JBRUFELFlBQVlwM0MsU0FBUyxDQUFDbWtCLG9CQUFvQixHQUFHLFNBQVM1RyxLQUFLO29CQUN2REEsTUFBTWlYLFVBQVUsQ0FBQzdPLElBQUksQ0FBQyxJQUFJLENBQUMweEIsR0FBRztvQkFDOUI5NUIsTUFBTXFXLE9BQU8sR0FBRztvQkFDaEJyVyxNQUFNelEsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtnQkFDbEM7WUFHQTtZQUFFO2dCQUFDLGVBQWM7Z0JBQUUsWUFBVztnQkFBRSxxQkFBb0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGlCQUFnQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsbUJBQWtCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTclUsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQzdPLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXRELElBQUlDLFVBQVNsRCxTQUFRO2dCQUVyQixJQUFJYSxZQUFZYixTQUFRO2dCQUV4QixJQUFJUyxPQUFPVCxTQUFRO2dCQUVuQixJQUFJbUIsVUFBVW5CLFNBQVE7Z0JBRXRCLElBQUl5QyxXQUFXekMsU0FBUTtnQkFFdkIsSUFBSTIrQyxjQUFjMytDLFNBQVE7Z0JBRTFCbUIsUUFBUXdoQixPQUFPLENBQUNnOEIsWUFBWWhULElBQUksRUFBRWdULFlBQVloVCxJQUFJLEVBQUVvVDtnQkFFcEQsU0FBU0Esb0JBQW9CN3FDLFFBQVEsRUFBRXVDLEdBQUcsRUFBRXBILFFBQVEsRUFBRWlDLE1BQU0sRUFBRW9GLEdBQUcsRUFBRW5ILFFBQVEsRUFBRWlDLE1BQU07b0JBQy9FeE8sV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3VLLFNBQVM1RyxPQUFPLE1BQU1rMkMsWUFBWWhULElBQUk7b0JBQy9EM29DLFdBQVdFLFFBQU80QixNQUFNLENBQUN5SyxTQUFTOUcsT0FBTyxNQUFNazJDLFlBQVloVCxJQUFJO29CQUMvRHFULGVBQWU5cUMsVUFBVTdFLFNBQVN3RSxRQUFRLElBQUk0QyxLQUFLbEgsU0FBU3NFLFFBQVEsSUFBSTZDO2dCQUM1RTtnQkFFQSxJQUFJdW9DLFFBQVF4K0MsS0FBS3NELElBQUk7Z0JBRXJCLElBQUltN0MsUUFBUXorQyxLQUFLc0QsSUFBSTtnQkFFckIsU0FBU2k3QyxlQUFlOXFDLFFBQVEsRUFBRWlyQyxPQUFPLEVBQUUxb0MsR0FBRyxFQUFFMm9DLE9BQU8sRUFBRTFvQyxHQUFHO29CQUN4RHhDLFNBQVNDLFVBQVUsR0FBRztvQkFDdEIsSUFBSTZvQixLQUFLbjhCLFVBQVV3WixRQUFRLENBQUM1RCxLQUFLMG9DLFFBQVFQLEdBQUcsRUFBRUs7b0JBQzlDLElBQUloaUIsS0FBS3A4QixVQUFVd1osUUFBUSxDQUFDM0QsS0FBSzBvQyxRQUFRUixHQUFHLEVBQUVNO29CQUM5QyxJQUFJRyxVQUFVNStDLEtBQUt3cUMsZUFBZSxDQUFDaE8sSUFBSUQ7b0JBQ3ZDLElBQUlqb0IsS0FBS29xQyxRQUFROXFDLFFBQVE7b0JBQ3pCLElBQUlXLEtBQUtvcUMsUUFBUS9xQyxRQUFRO29CQUN6QixJQUFJaXJDLFNBQVN2cUMsS0FBS0M7b0JBQ2xCLElBQUlxcUMsVUFBVUMsU0FBU0EsUUFBUTt3QkFDM0I7b0JBQ0o7b0JBQ0FwckMsU0FBU3JRLElBQUksR0FBR3BCLFNBQVMrWCxTQUFTO29CQUNsQ3RHLFNBQVNwSSxVQUFVLENBQUN0QixHQUFHLENBQUMyMEMsUUFBUVAsR0FBRztvQkFDbkMxcUMsU0FBU0ksV0FBVyxDQUFDM0wsT0FBTztvQkFDNUJ1TCxTQUFTQyxVQUFVLEdBQUc7b0JBQ3RCRCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDM0ksVUFBVSxDQUFDdEIsR0FBRyxDQUFDNDBDLFFBQVFSLEdBQUc7b0JBQzdDLGlDQUFpQztvQkFDakMxcUMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRztvQkFDbEM0QyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDbEYsS0FBSyxHQUFHdGdCLFNBQVNvbEIsUUFBUTtvQkFDbEQzVCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHO29CQUNsQzBDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO2dCQUN0RDtnQkFFQTdvQixTQUFRZ2dELGNBQWMsR0FBR0E7WUFHekI7WUFBRTtnQkFBQyxjQUFhO2dCQUFFLGVBQWM7Z0JBQUUsdUJBQXNCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsaUJBQWdCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTaC9DLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUMzSixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSXlDLFdBQVd6QyxTQUFRO2dCQUV2QixJQUFJbUIsVUFBVW5CLFNBQVE7Z0JBRXRCLElBQUkyK0MsY0FBYzMrQyxTQUFRO2dCQUUxQixJQUFJZzlDLGVBQWVoOUMsU0FBUTtnQkFFM0JtQixRQUFRd2hCLE9BQU8sQ0FBQ3E2QixhQUFhclIsSUFBSSxFQUFFZ1QsWUFBWWhULElBQUksRUFBRTRUO2dCQUVyRCxTQUFTQSxxQkFBcUJyckMsUUFBUSxFQUFFdUMsR0FBRyxFQUFFcEgsUUFBUSxFQUFFaUMsTUFBTSxFQUFFb0YsR0FBRyxFQUFFbkgsUUFBUSxFQUFFaUMsTUFBTTtvQkFDaEZ4TyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdUssU0FBUzVHLE9BQU8sT0FBT3UwQyxhQUFhclIsSUFBSTtvQkFDakUzb0MsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3lLLFNBQVM5RyxPQUFPLE9BQU9rMkMsWUFBWWhULElBQUk7b0JBQ2hFNlQscUJBQXFCdHJDLFVBQVU3RSxTQUFTd0UsUUFBUSxJQUFJNEMsS0FBS2xILFNBQVNzRSxRQUFRLElBQUk2QztnQkFDbEY7Z0JBRUEsSUFBSStvQyxRQUFRaC9DLEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJMjdDLGFBQWFqL0MsS0FBS3NELElBQUk7Z0JBRTFCLElBQUk0N0MsU0FBU2wvQyxLQUFLc0QsSUFBSTtnQkFFdEIsSUFBSTY3QyxTQUFTbi9DLEtBQUtzRCxJQUFJO2dCQUV0QixTQUFTeTdDLHFCQUFxQnRyQyxRQUFRLEVBQUUyckMsUUFBUSxFQUFFcHBDLEdBQUcsRUFBRTJvQyxPQUFPLEVBQUUxb0MsR0FBRztvQkFDL0R4QyxTQUFTQyxVQUFVLEdBQUc7b0JBQ3RCLHVEQUF1RDtvQkFDdkQsSUFBSXJKLElBQUlqSyxVQUFVd1osUUFBUSxDQUFDM0QsS0FBSzBvQyxRQUFRUixHQUFHLEVBQUVhO29CQUM3QyxJQUFJSyxTQUFTai9DLFVBQVU4b0MsU0FBUyxDQUFDbHpCLEtBQUszTCxHQUFHNDBDO29CQUN6QyxnQ0FBZ0M7b0JBQ2hDLElBQUlLLGNBQWM7b0JBQ2xCLElBQUl4bEMsYUFBYSxDQUFDcVU7b0JBQ2xCLElBQUkwd0IsU0FBU08sU0FBU3hyQyxRQUFRLEdBQUcrcUMsUUFBUS9xQyxRQUFRO29CQUNqRCxJQUFJMnJDLGNBQWNILFNBQVMxa0IsT0FBTztvQkFDbEMsSUFBSVQsV0FBV21sQixTQUFTOWpCLFVBQVU7b0JBQ2xDLElBQUlra0IsVUFBVUosU0FBU0ssU0FBUztvQkFDaEMsSUFBSyxJQUFJamdELElBQUksR0FBR0EsSUFBSSsvQyxhQUFhLEVBQUUvL0MsRUFBRzt3QkFDbEMsSUFBSUwsSUFBSWEsS0FBS3lMLEdBQUcsQ0FBQyt6QyxPQUFPLENBQUNoZ0QsRUFBRSxFQUFFUSxLQUFLMlosSUFBSSxDQUFDMGxDLFFBQVFwbEIsUUFBUSxDQUFDejZCLEVBQUUsRUFBRTAvQzt3QkFDNUQsSUFBSS8vQyxJQUFJMC9DLFFBQVE7NEJBQ1osYUFBYTs0QkFDYjt3QkFDSjt3QkFDQSxJQUFJMS9DLElBQUkyYSxZQUFZOzRCQUNoQkEsYUFBYTNhOzRCQUNibWdELGNBQWM5L0M7d0JBQ2xCO29CQUNKO29CQUNBLDJDQUEyQztvQkFDM0MsSUFBSWtnRCxhQUFhSjtvQkFDakIsSUFBSUssYUFBYUQsYUFBYSxJQUFJSCxjQUFjRyxhQUFhLElBQUk7b0JBQ2pFLElBQUl2QyxLQUFLbGpCLFFBQVEsQ0FBQ3lsQixXQUFXO29CQUM3QixJQUFJdEMsS0FBS25qQixRQUFRLENBQUMwbEIsV0FBVztvQkFDN0IsMENBQTBDO29CQUMxQyxJQUFJN2xDLGFBQWEvWixNQUFLc29CLE9BQU8sRUFBRTt3QkFDM0I1VSxTQUFTQyxVQUFVLEdBQUc7d0JBQ3RCRCxTQUFTclEsSUFBSSxHQUFHcEIsU0FBU29ZLE9BQU87d0JBQ2hDM0csU0FBU0ksV0FBVyxDQUFDOUosR0FBRyxDQUFDeTFDLE9BQU8sQ0FBQ0YsWUFBWTt3QkFDN0M3ckMsU0FBU3BJLFVBQVUsQ0FBQ21SLFVBQVUsQ0FBQyxJQUFJMmdDLElBQUksSUFBSUM7d0JBQzNDM3BDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMzSSxVQUFVLENBQUN0QixHQUFHLENBQUM0MEMsUUFBUVIsR0FBRzt3QkFDN0MsaUNBQWlDO3dCQUNqQzFxQyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDM1csTUFBTSxHQUFHO3dCQUNsQzRDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUNsRixLQUFLLEdBQUd0Z0IsU0FBU29sQixRQUFRO3dCQUNsRDNULFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUN6VyxNQUFNLEdBQUc7d0JBQ2xDMEMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2pGLEtBQUssR0FBR3ZnQixTQUFTb2xCLFFBQVE7d0JBQ2xEO29CQUNKO29CQUNBLGtDQUFrQztvQkFDbEMsSUFBSXc0QixLQUFLNS9DLEtBQUt5TCxHQUFHLENBQUN6TCxLQUFLMlosSUFBSSxDQUFDMGxDLFFBQVFsQyxJQUFJK0IsU0FBU2wvQyxLQUFLMlosSUFBSSxDQUFDeWpDLElBQUlELElBQUlnQztvQkFDbkUsSUFBSVUsS0FBSzcvQyxLQUFLeUwsR0FBRyxDQUFDekwsS0FBSzJaLElBQUksQ0FBQzBsQyxRQUFRakMsSUFBSThCLFNBQVNsL0MsS0FBSzJaLElBQUksQ0FBQ3dqQyxJQUFJQyxJQUFJK0I7b0JBQ25FLElBQUlTLE1BQU0sR0FBRzt3QkFDVCxJQUFJNS9DLEtBQUt3cUMsZUFBZSxDQUFDNlUsUUFBUWxDLE1BQU0wQixTQUFTQSxRQUFROzRCQUNwRDt3QkFDSjt3QkFDQXByQyxTQUFTQyxVQUFVLEdBQUc7d0JBQ3RCRCxTQUFTclEsSUFBSSxHQUFHcEIsU0FBU29ZLE9BQU87d0JBQ2hDM0csU0FBU0ksV0FBVyxDQUFDMkksVUFBVSxDQUFDLEdBQUc2aUMsUUFBUSxDQUFDLEdBQUdsQzt3QkFDL0MxcEMsU0FBU0ksV0FBVyxDQUFDcUcsU0FBUzt3QkFDOUJ6RyxTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDb3pDO3dCQUN4QjFwQyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDM0ksVUFBVSxDQUFDdEIsR0FBRyxDQUFDNDBDLFFBQVFSLEdBQUc7d0JBQzdDLGlDQUFpQzt3QkFDakMxcUMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRzt3QkFDbEM0QyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDbEYsS0FBSyxHQUFHdGdCLFNBQVNvbEIsUUFBUTt3QkFDbEQzVCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHO3dCQUNsQzBDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO29CQUN0RCxPQUFPLElBQUl5NEIsTUFBTSxHQUFHO3dCQUNoQixJQUFJNy9DLEtBQUt3cUMsZUFBZSxDQUFDNlUsUUFBUWpDLE1BQU15QixTQUFTQSxRQUFROzRCQUNwRDt3QkFDSjt3QkFDQXByQyxTQUFTQyxVQUFVLEdBQUc7d0JBQ3RCRCxTQUFTclEsSUFBSSxHQUFHcEIsU0FBU29ZLE9BQU87d0JBQ2hDM0csU0FBU0ksV0FBVyxDQUFDMkksVUFBVSxDQUFDLEdBQUc2aUMsUUFBUSxDQUFDLEdBQUdqQzt3QkFDL0MzcEMsU0FBU0ksV0FBVyxDQUFDcUcsU0FBUzt3QkFDOUJ6RyxTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDcXpDO3dCQUN4QjNwQyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDM0ksVUFBVSxDQUFDdEIsR0FBRyxDQUFDNDBDLFFBQVFSLEdBQUc7d0JBQzdDLGlDQUFpQzt3QkFDakMxcUMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRzt3QkFDbEM0QyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDbEYsS0FBSyxHQUFHdGdCLFNBQVNvbEIsUUFBUTt3QkFDbEQzVCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHO3dCQUNsQzBDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO29CQUN0RCxPQUFPO3dCQUNILElBQUkwNEIsYUFBYTkvQyxLQUFLc29CLEdBQUcsQ0FBQzYwQixJQUFJQzt3QkFDOUIsSUFBSXRqQyxhQUFhOVosS0FBS3lMLEdBQUcsQ0FBQzR6QyxRQUFRRyxPQUFPLENBQUNFLFdBQVcsSUFBSTEvQyxLQUFLeUwsR0FBRyxDQUFDcTBDLFlBQVlOLE9BQU8sQ0FBQ0UsV0FBVzt3QkFDakcsSUFBSTVsQyxhQUFhK2tDLFFBQVE7NEJBQ3JCO3dCQUNKO3dCQUNBcHJDLFNBQVNDLFVBQVUsR0FBRzt3QkFDdEJELFNBQVNyUSxJQUFJLEdBQUdwQixTQUFTb1ksT0FBTzt3QkFDaEMzRyxTQUFTSSxXQUFXLENBQUM5SixHQUFHLENBQUN5MUMsT0FBTyxDQUFDRSxXQUFXO3dCQUM1Q2pzQyxTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDKzFDO3dCQUN4QnJzQyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDM0ksVUFBVSxDQUFDdEIsR0FBRyxDQUFDNDBDLFFBQVFSLEdBQUc7d0JBQzdDLGlDQUFpQzt3QkFDakMxcUMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRzt3QkFDbEM0QyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDbEYsS0FBSyxHQUFHdGdCLFNBQVNvbEIsUUFBUTt3QkFDbEQzVCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHO3dCQUNsQzBDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO29CQUN0RDtnQkFDSjtZQUdBO1lBQUU7Z0JBQUMsY0FBYTtnQkFBRSxlQUFjO2dCQUFFLGtCQUFpQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxpQkFBZ0I7Z0JBQUcsa0JBQWlCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTN25CLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUNuTSxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSW1CLFVBQVVuQixTQUFRO2dCQUV0QixJQUFJeUMsV0FBV3pDLFNBQVE7Z0JBRXZCLElBQUlxOUMsWUFBWXI5QyxTQUFRO2dCQUV4QixJQUFJbzlDLGFBQWFwOUMsU0FBUTtnQkFFekIsSUFBSTIrQyxjQUFjMytDLFNBQVE7Z0JBRTFCbUIsUUFBUXdoQixPQUFPLENBQUMwNkIsVUFBVTFSLElBQUksRUFBRWdULFlBQVloVCxJQUFJLEVBQUU2VTtnQkFFbERyL0MsUUFBUXdoQixPQUFPLENBQUN5NkIsV0FBV3pSLElBQUksRUFBRWdULFlBQVloVCxJQUFJLEVBQUU4VTtnQkFFbkQsU0FBU0Qsa0JBQWtCdHNDLFFBQVEsRUFBRXVDLEdBQUcsRUFBRXBILFFBQVEsRUFBRWlDLE1BQU0sRUFBRW9GLEdBQUcsRUFBRW5ILFFBQVEsRUFBRWlDLE1BQU07b0JBQzdFeE8sV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3VLLFNBQVM1RyxPQUFPLE1BQU00MEMsVUFBVTFSLElBQUk7b0JBQzdEM29DLFdBQVdFLFFBQU80QixNQUFNLENBQUN5SyxTQUFTOUcsT0FBTyxNQUFNazJDLFlBQVloVCxJQUFJO29CQUMvRCxJQUFJLzNCLFNBQVN2RSxTQUFTd0UsUUFBUTtvQkFDOUIsSUFBSUMsU0FBU3ZFLFNBQVNzRSxRQUFRO29CQUM5QjZzQyxrQkFBa0J4c0MsVUFBVU4sUUFBUTZDLEtBQUszQyxRQUFRNEM7Z0JBQ3JEO2dCQUVBLElBQUlpcUMsV0FBVyxJQUFJdEQ7Z0JBRW5CLFNBQVNvRCxtQkFBbUJ2c0MsUUFBUSxFQUFFdUMsR0FBRyxFQUFFcEgsUUFBUSxFQUFFaUMsTUFBTSxFQUFFb0YsR0FBRyxFQUFFbkgsUUFBUSxFQUFFaUMsTUFBTTtvQkFDOUV4TyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdUssU0FBUzVHLE9BQU8sT0FBTzIwQyxXQUFXelIsSUFBSTtvQkFDL0Qzb0MsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3lLLFNBQVM5RyxPQUFPLE9BQU9rMkMsWUFBWWhULElBQUk7b0JBQ2hFLElBQUlpVixRQUFRdnhDLFNBQVN3RSxRQUFRO29CQUM3QixJQUFJekUsT0FBT3V4QztvQkFDWEMsTUFBTXpDLFlBQVksQ0FBQ3dDLFVBQVVydkM7b0JBQzdCLElBQUlzQyxTQUFTK3NDO29CQUNiLElBQUk3c0MsU0FBU3ZFLFNBQVNzRSxRQUFRO29CQUM5QjZzQyxrQkFBa0J4c0MsVUFBVU4sUUFBUTZDLEtBQUszQyxRQUFRNEM7Z0JBQ3JEO2dCQUVBLElBQUltcUMsUUFBUXBnRCxLQUFLc0QsSUFBSTtnQkFFckIsSUFBSSs4QyxRQUFRcmdELEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJZzlDLFFBQVF0Z0QsS0FBS3NELElBQUk7Z0JBRXJCLElBQUlpOUMsUUFBUXZnRCxLQUFLc0QsSUFBSTtnQkFFckIsSUFBSWs5QyxRQUFReGdELEtBQUtzRCxJQUFJO2dCQUVyQixJQUFJbTlDLFNBQVN6Z0QsS0FBS3NELElBQUk7Z0JBRXRCLElBQUlvOUMsU0FBUzFnRCxLQUFLc0QsSUFBSTtnQkFFdEIsSUFBSXE5QyxTQUFTM2dELEtBQUtzRCxJQUFJO2dCQUV0QixpREFBaUQ7Z0JBQ2pELHVDQUF1QztnQkFDdkMsU0FBUzI4QyxrQkFBa0J4c0MsUUFBUSxFQUFFbXRDLEtBQUssRUFBRTVxQyxHQUFHLEVBQUUyb0MsT0FBTyxFQUFFMW9DLEdBQUc7b0JBQ3pEeEMsU0FBU0MsVUFBVSxHQUFHO29CQUN0QixrQ0FBa0M7b0JBQ2xDLElBQUltdEMsSUFBSXpnRCxVQUFVOG9DLFNBQVMsQ0FBQ2x6QixLQUFLNVYsVUFBVXdaLFFBQVEsQ0FBQzNELEtBQUswb0MsUUFBUVIsR0FBRyxFQUFFd0MsU0FBU047b0JBQy9FLElBQUlsZ0IsSUFBSXlnQixNQUFNakQsU0FBUztvQkFDdkIsSUFBSXZkLElBQUl3Z0IsTUFBTWhELFNBQVM7b0JBQ3ZCLElBQUl0L0MsSUFBSTBCLEtBQUsyWixJQUFJLENBQUN5bUIsR0FBR0QsR0FBR2lnQjtvQkFDeEIsMEJBQTBCO29CQUMxQixJQUFJL2dELElBQUlXLEtBQUt5TCxHQUFHLENBQUNuTixHQUFHMEIsS0FBSzJaLElBQUksQ0FBQ3ltQixHQUFHeWdCLEdBQUdGO29CQUNwQyxJQUFJbjFDLElBQUl4TCxLQUFLeUwsR0FBRyxDQUFDbk4sR0FBRzBCLEtBQUsyWixJQUFJLENBQUNrbkMsR0FBRzFnQixHQUFHd2dCO29CQUNwQyxJQUFJOUIsU0FBUytCLE1BQU1odEMsUUFBUSxHQUFHK3FDLFFBQVEvcUMsUUFBUTtvQkFDOUMsV0FBVztvQkFDWCxJQUFJcEksS0FBSyxHQUFHO3dCQUNSLElBQUkyUCxJQUFJbWxDLE1BQU0zc0MsT0FBTyxDQUFDd3NCO3dCQUN0QixJQUFJbEssSUFBSWoyQixLQUFLaUwsR0FBRyxDQUFDNDFDLEdBQUcxbEMsR0FBR29sQzt3QkFDdkIsSUFBSU8sS0FBSzlnRCxLQUFLeUwsR0FBRyxDQUFDd3FCLEdBQUdBO3dCQUNyQixJQUFJNnFCLEtBQUtqQyxTQUFTQSxRQUFROzRCQUN0Qjt3QkFDSjt3QkFDQSxtQ0FBbUM7d0JBQ25DLElBQUkrQixNQUFNOUMsWUFBWSxFQUFFOzRCQUNwQixJQUFJaUQsS0FBS0gsTUFBTS9DLFNBQVM7NEJBQ3hCLElBQUltRCxLQUFLN2dCOzRCQUNULElBQUk4Z0IsS0FBS2poRCxLQUFLMlosSUFBSSxDQUFDcW5DLElBQUlELElBQUlOOzRCQUMzQixJQUFJYixLQUFLNS9DLEtBQUt5TCxHQUFHLENBQUN3MUMsSUFBSWpoRCxLQUFLaUwsR0FBRyxDQUFDKzFDLElBQUlILEdBQUdGOzRCQUN0QyxtREFBbUQ7NEJBQ25ELElBQUlmLEtBQUssR0FBRztnQ0FDUjs0QkFDSjt3QkFDSjt3QkFDQW5zQyxTQUFTclEsSUFBSSxHQUFHcEIsU0FBUytYLFNBQVM7d0JBQ2xDdEcsU0FBU0ksV0FBVyxDQUFDM0wsT0FBTzt3QkFDNUJ1TCxTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDb1I7d0JBQ3hCMUgsU0FBU0MsVUFBVSxHQUFHO3dCQUN0QkQsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQzNJLFVBQVUsQ0FBQ3RCLEdBQUcsQ0FBQzQwQyxRQUFRUixHQUFHO3dCQUM3QyxpQ0FBaUM7d0JBQ2pDMXFDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUMzVyxNQUFNLEdBQUc7d0JBQ2xDNEMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR3RnQixTQUFTb2xCLFFBQVE7d0JBQ2xEM1QsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU0sR0FBRzt3QkFDbEMwQyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHdmdCLFNBQVNvbEIsUUFBUTt3QkFDbEQ7b0JBQ0o7b0JBQ0EsV0FBVztvQkFDWCxJQUFJL25CLEtBQUssR0FBRzt3QkFDUixJQUFJOGIsSUFBSW1sQyxNQUFNM3NDLE9BQU8sQ0FBQ3lzQjt3QkFDdEIsSUFBSW5LLElBQUlqMkIsS0FBSzJaLElBQUksQ0FBQ2tuQyxHQUFHMWxDLEdBQUdvbEM7d0JBQ3hCLElBQUlPLEtBQUs5Z0QsS0FBS3lMLEdBQUcsQ0FBQ3dxQixHQUFHQTt3QkFDckIsSUFBSTZxQixLQUFLakMsU0FBU0EsUUFBUTs0QkFDdEI7d0JBQ0o7d0JBQ0EsbUNBQW1DO3dCQUNuQyxJQUFJK0IsTUFBTTVDLFlBQVksRUFBRTs0QkFDcEIsSUFBSWtELEtBQUtOLE1BQU03QyxTQUFTOzRCQUN4QixJQUFJb0QsS0FBSy9nQjs0QkFDVCxJQUFJZ2hCLEtBQUtwaEQsS0FBSzJaLElBQUksQ0FBQ3VuQyxJQUFJQyxJQUFJVDs0QkFDM0IsSUFBSXRELEtBQUtwOUMsS0FBS3lMLEdBQUcsQ0FBQzIxQyxJQUFJcGhELEtBQUsyWixJQUFJLENBQUNrbkMsR0FBR00sSUFBSVI7NEJBQ3ZDLCtDQUErQzs0QkFDL0MsSUFBSXZELEtBQUssR0FBRztnQ0FDUjs0QkFDSjt3QkFDSjt3QkFDQTNwQyxTQUFTclEsSUFBSSxHQUFHcEIsU0FBUytYLFNBQVM7d0JBQ2xDdEcsU0FBU0ksV0FBVyxDQUFDM0wsT0FBTzt3QkFDNUJ1TCxTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDb1I7d0JBQ3hCMUgsU0FBU0MsVUFBVSxHQUFHO3dCQUN0QkQsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQzNJLFVBQVUsQ0FBQ3RCLEdBQUcsQ0FBQzQwQyxRQUFRUixHQUFHO3dCQUM3QyxpQ0FBaUM7d0JBQ2pDMXFDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUMzVyxNQUFNLEdBQUc7d0JBQ2xDNEMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR3RnQixTQUFTb2xCLFFBQVE7d0JBQ2xEM1QsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU0sR0FBRzt3QkFDbEMwQyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHdmdCLFNBQVNvbEIsUUFBUTt3QkFDbEQ7b0JBQ0o7b0JBQ0EsWUFBWTtvQkFDWixJQUFJaTZCLE1BQU1yaEQsS0FBS3lMLEdBQUcsQ0FBQ25OLEdBQUdBO29CQUN0QmlFLFdBQVdFLFFBQU80QixNQUFNLENBQUNnOUMsTUFBTTtvQkFDL0IsSUFBSWxtQyxJQUFJbWxDLE1BQU05akMsVUFBVSxDQUFDbmQsSUFBSWdpRCxLQUFLbGhCLEdBQUczMEIsSUFBSTYxQyxLQUFLamhCO29CQUM5QyxJQUFJbkssSUFBSWoyQixLQUFLMlosSUFBSSxDQUFDa25DLEdBQUcxbEMsR0FBR29sQztvQkFDeEIsSUFBSU8sS0FBSzlnRCxLQUFLeUwsR0FBRyxDQUFDd3FCLEdBQUdBO29CQUNyQixJQUFJNnFCLEtBQUtqQyxTQUFTQSxRQUFRO3dCQUN0QjtvQkFDSjtvQkFDQSxJQUFJNS9DLElBQUl1aEQsTUFBTTFXLEtBQUssQ0FBQyxDQUFDeHJDLEVBQUVtaEIsQ0FBQyxFQUFFbmhCLEVBQUVpaEIsQ0FBQztvQkFDN0IsSUFBSXZmLEtBQUt5TCxHQUFHLENBQUN4TSxHQUFHZSxLQUFLMlosSUFBSSxDQUFDa25DLEdBQUcxZ0IsR0FBR3dnQixXQUFXLEdBQUc7d0JBQzFDMWhELEVBQUU4SyxHQUFHLENBQUMsQ0FBQzlLLEVBQUVzZ0IsQ0FBQyxFQUFFLENBQUN0Z0IsRUFBRXdnQixDQUFDO29CQUNwQjtvQkFDQXhnQixFQUFFaWIsU0FBUztvQkFDWHpHLFNBQVNyUSxJQUFJLEdBQUdwQixTQUFTb1ksT0FBTztvQkFDaEMzRyxTQUFTSSxXQUFXLENBQUM5SixHQUFHLENBQUM5SztvQkFDekJ3VSxTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDbzJCO29CQUN4QjFzQixTQUFTQyxVQUFVLEdBQUc7b0JBQ3RCRCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDM0ksVUFBVSxDQUFDdEIsR0FBRyxDQUFDNDBDLFFBQVFSLEdBQUc7b0JBQzdDLGlDQUFpQztvQkFDakMxcUMsU0FBU08sTUFBTSxDQUFDLEVBQUUsQ0FBQytDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRztvQkFDbEM0QyxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDbEYsS0FBSyxHQUFHdGdCLFNBQVNxbEIsTUFBTTtvQkFDaEQ1VCxTQUFTTyxNQUFNLENBQUMsRUFBRSxDQUFDK0MsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHO29CQUNsQzBDLFNBQVNPLE1BQU0sQ0FBQyxFQUFFLENBQUMrQyxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO2dCQUN0RDtZQUdBO1lBQUU7Z0JBQUMsY0FBYTtnQkFBRSxlQUFjO2dCQUFFLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGdCQUFlO2dCQUFHLGlCQUFnQjtnQkFBRyxlQUFjO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTN25CLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUM5TCxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJbUIsVUFBVW5CLFNBQVE7Z0JBRXRCLElBQUl5QyxXQUFXekMsU0FBUTtnQkFFdkIsSUFBSXE5QyxZQUFZcjlDLFNBQVE7Z0JBRXhCLElBQUlvOUMsYUFBYXA5QyxTQUFRO2dCQUV6QixJQUFJZzlDLGVBQWVoOUMsU0FBUTtnQkFFM0JtQixRQUFRd2hCLE9BQU8sQ0FBQzA2QixVQUFVMVIsSUFBSSxFQUFFcVIsYUFBYXJSLElBQUksRUFBRW9XO2dCQUVuRDVnRCxRQUFRd2hCLE9BQU8sQ0FBQ3k2QixXQUFXelIsSUFBSSxFQUFFcVIsYUFBYXJSLElBQUksRUFBRXFXO2dCQUVwRCxTQUFTRCxtQkFBbUI3dEMsUUFBUSxFQUFFdUMsR0FBRyxFQUFFcEYsRUFBRSxFQUFFQyxNQUFNLEVBQUVvRixHQUFHLEVBQUVuRixFQUFFLEVBQUVDLE1BQU07b0JBQ2xFeE8sV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3VNLEdBQUc1SSxPQUFPLE9BQU80MEMsVUFBVTFSLElBQUk7b0JBQ3hEM29DLFdBQVdFLFFBQU80QixNQUFNLENBQUN5TSxHQUFHOUksT0FBTyxPQUFPdTBDLGFBQWFyUixJQUFJO29CQUMzRHNXLG1CQUFtQi90QyxVQUFVN0MsR0FBR3dDLFFBQVEsSUFBSTRDLEtBQUtsRixHQUFHc0MsUUFBUSxJQUFJNkM7Z0JBQ3BFO2dCQUVBLElBQUl3ckMsV0FBVyxJQUFJN0U7Z0JBRW5CLFNBQVMyRSxvQkFBb0I5dEMsUUFBUSxFQUFFdUMsR0FBRyxFQUFFcEYsRUFBRSxFQUFFQyxNQUFNLEVBQUVvRixHQUFHLEVBQUVuRixFQUFFLEVBQUVDLE1BQU07b0JBQ25FeE8sV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3VNLEdBQUc1SSxPQUFPLE9BQU8yMEMsV0FBV3pSLElBQUk7b0JBQ3pEM29DLFdBQVdFLFFBQU80QixNQUFNLENBQUN5TSxHQUFHOUksT0FBTyxPQUFPdTBDLGFBQWFyUixJQUFJO29CQUMzRCxJQUFJaVYsUUFBUXZ2QyxHQUFHd0MsUUFBUTtvQkFDdkIsSUFBSXpFLE9BQU84eUM7b0JBQ1h0QixNQUFNekMsWUFBWSxDQUFDL3VDLE1BQU1rQztvQkFDekIyd0MsbUJBQW1CL3RDLFVBQVU5RSxNQUFNcUgsS0FBS2xGLEdBQUdzQyxRQUFRLElBQUk2QztnQkFDM0Q7Z0JBRUEsY0FBYztnQkFDZCxJQUFJMnNCLFlBQVksQ0FBQztnQkFFakIsSUFBSThlLFVBQVU7Z0JBRWQsSUFBSUMsVUFBVTtnQkFFZCxxQkFBcUI7Z0JBQ3JCLElBQUlDLGFBQWE7Z0JBRWpCLElBQUlDLFlBQVk7Z0JBRWhCLElBQUlDLFdBQVc7Z0JBRWYsb0VBQW9FO2dCQUNwRSxTQUFTQztvQkFDTCxJQUFJLENBQUMzK0MsSUFBSTtvQkFDVCxPQUFPO29CQUNQLElBQUksQ0FBQ3d3QixLQUFLO29CQUNWLElBQUksQ0FBQzlaLFVBQVU7Z0JBQ25CO2dCQUVBLDZDQUE2QztnQkFDN0MsU0FBU2tvQztvQkFDTCxJQUFJLENBQUMvbkIsUUFBUSxHQUFHLEVBQUU7b0JBQ2xCLG9DQUFvQztvQkFDcEMsSUFBSSxDQUFDdWxCLE9BQU8sR0FBRyxFQUFFO29CQUNqQixxQ0FBcUM7b0JBQ3JDLElBQUksQ0FBQy91QixLQUFLLEdBQUc7b0JBQ2IsSUFBSyxJQUFJanhCLElBQUksR0FBR0EsSUFBSTRDLFNBQVNvbkIsa0JBQWtCLEVBQUVocUIsSUFBSzt3QkFDbEQsSUFBSSxDQUFDeTZCLFFBQVEsQ0FBQ3hOLElBQUksQ0FBQ3pzQixLQUFLc0QsSUFBSTt3QkFDNUIsSUFBSSxDQUFDazhDLE9BQU8sQ0FBQy95QixJQUFJLENBQUN6c0IsS0FBS3NELElBQUk7b0JBQy9CO2dCQUNKO2dCQUVBLG1DQUFtQztnQkFDbkMsU0FBUzIrQztvQkFDTCxJQUFJLENBQUNDLEVBQUUsR0FBRyxDQUFDO29CQUNYLElBQUksQ0FBQ0MsRUFBRSxHQUFHLENBQUM7b0JBQ1gsSUFBSSxDQUFDaEYsRUFBRSxHQUFHbjlDLEtBQUtzRCxJQUFJO29CQUNuQixJQUFJLENBQUM4NUMsRUFBRSxHQUFHcDlDLEtBQUtzRCxJQUFJO29CQUNuQixJQUFJLENBQUN1VyxNQUFNLEdBQUc3WixLQUFLc0QsSUFBSTtvQkFDdkIsSUFBSSxDQUFDOCtDLFdBQVcsR0FBR3BpRCxLQUFLc0QsSUFBSTtvQkFDNUIsSUFBSSxDQUFDKytDLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUd0aUQsS0FBS3NELElBQUk7b0JBQzVCLElBQUksQ0FBQ2kvQyxXQUFXLEdBQUc7Z0JBQ3ZCO2dCQUVBLFNBQVM7Z0JBQ1QsSUFBSUMsV0FBVyxJQUFJVDtnQkFFbkIsSUFBSVUsY0FBYyxJQUFJVjtnQkFFdEIsSUFBSVcsWUFBWSxJQUFJVjtnQkFFcEIsSUFBSVcsS0FBSyxJQUFJVjtnQkFFYixJQUFJVyxTQUFTNWlELEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJdS9DLFNBQVM3aUQsS0FBS3NELElBQUk7Z0JBRXRCLElBQUl3L0MsUUFBUTlpRCxLQUFLc0QsSUFBSTtnQkFFckIsSUFBSXkvQyxXQUFXL2lELEtBQUtzRCxJQUFJO2dCQUV4QixJQUFJMC9DLGdCQUFnQmhqRCxLQUFLc0QsSUFBSTtnQkFFN0IsSUFBSTIvQyxZQUFZampELEtBQUtzRCxJQUFJO2dCQUV6QixJQUFJNC9DLGNBQWNsakQsS0FBS3NELElBQUk7Z0JBRTNCLElBQUk2L0MsWUFBWW5qRCxLQUFLc0QsSUFBSTtnQkFFekIsSUFBSTgvQyxjQUFjcGpELEtBQUtzRCxJQUFJO2dCQUUzQixJQUFJKy9DLFlBQVlyakQsS0FBS3NELElBQUk7Z0JBRXpCLElBQUlnZ0QsY0FBY3RqRCxLQUFLc0QsSUFBSTtnQkFFM0IsSUFBSWlnRCxhQUFhdmpELEtBQUtzRCxJQUFJO2dCQUUxQixJQUFJa2dELGlCQUFpQnhqRCxLQUFLc0QsSUFBSTtnQkFFOUIsSUFBSW1nRCxpQkFBaUJ6akQsS0FBS3NELElBQUk7Z0JBRTlCLElBQUlvZ0QsU0FBU3RqRCxVQUFVbUYsUUFBUTtnQkFFL0IsSUFBSW8rQyxrQkFBa0I7b0JBQUUsSUFBSTNoRCxTQUFTZ2xCLFVBQVU7b0JBQUksSUFBSWhsQixTQUFTZ2xCLFVBQVU7aUJBQUk7Z0JBRTlFLElBQUk0OEIsa0JBQWtCO29CQUFFLElBQUk1aEQsU0FBU2dsQixVQUFVO29CQUFJLElBQUlobEIsU0FBU2dsQixVQUFVO2lCQUFJO2dCQUU5RSxJQUFJNjhCLFNBQVM7b0JBQUUsSUFBSTdoRCxTQUFTZ2xCLFVBQVU7b0JBQUksSUFBSWhsQixTQUFTZ2xCLFVBQVU7aUJBQUk7Z0JBRXJFOzs7Q0FHQyxHQUNELFNBQVN3NkIsbUJBQW1CL3RDLFFBQVEsRUFBRW10QyxLQUFLLEVBQUU1cUMsR0FBRyxFQUFFOHRDLFFBQVEsRUFBRTd0QyxHQUFHO29CQUMzRCxhQUFhO29CQUNiLHdCQUF3QjtvQkFDeEIsZ0RBQWdEO29CQUNoRCw4QkFBOEI7b0JBQzlCLDREQUE0RDtvQkFDNUQscURBQXFEO29CQUNyRCxtRUFBbUU7b0JBQ25FLCtDQUErQztvQkFDL0MsVUFBVTtvQkFDVixJQUFJaTVCLFNBQVNDO29CQUNiLHFCQUFxQjtvQkFDckIsSUFBSWpsQyxLQUFLOUosVUFBVXlwQyxPQUFPLENBQUM3ekIsS0FBS0MsS0FBS3l0QztvQkFDckMsSUFBSUssWUFBWTNqRCxVQUFVd1osUUFBUSxDQUFDMVAsSUFBSTQ1QyxTQUFTRSxVQUFVLEVBQUVoQjtvQkFDNUQsSUFBSWlCLEtBQUtyRCxNQUFNL0MsU0FBUztvQkFDeEIsSUFBSVYsS0FBS3lELE1BQU1qRCxTQUFTO29CQUN4QixJQUFJUCxLQUFLd0QsTUFBTWhELFNBQVM7b0JBQ3hCLElBQUlzRyxLQUFLdEQsTUFBTTdDLFNBQVM7b0JBQ3hCLElBQUlvRyxhQUFhdkQsTUFBTTlDLFlBQVk7b0JBQ25DLElBQUlzRyxhQUFheEQsTUFBTTVDLFlBQVk7b0JBQ25DLElBQUlxRyxRQUFRcmtELEtBQUsyWixJQUFJLENBQUN5akMsSUFBSUQsSUFBSThGO29CQUM5Qm9CLE1BQU1ucUMsU0FBUztvQkFDZixJQUFJb3FDLFVBQVVwQixZQUFZcFosS0FBSyxDQUFDdWEsTUFBTTVrQyxDQUFDLEVBQUUsQ0FBQzRrQyxNQUFNOWtDLENBQUM7b0JBQ2pELElBQUlnbEMsVUFBVXZrRCxLQUFLeUwsR0FBRyxDQUFDNjRDLFNBQVN0a0QsS0FBSzJaLElBQUksQ0FBQ29xQyxXQUFXNUcsSUFBSXlGO29CQUN6RCxJQUFJNEIsVUFBVTtvQkFDZCxJQUFJQyxVQUFVO29CQUNkLElBQUlDLFVBQVU7b0JBQ2QsSUFBSUMsVUFBVTtvQkFDZCw2QkFBNkI7b0JBQzdCLElBQUlSLFlBQVk7d0JBQ1osSUFBSVMsUUFBUTVrRCxLQUFLMlosSUFBSSxDQUFDd2pDLElBQUk4RyxJQUFJZDt3QkFDOUJ5QixNQUFNMXFDLFNBQVM7d0JBQ2YsSUFBSTJxQyxVQUFVekIsWUFBWXRaLEtBQUssQ0FBQzhhLE1BQU1ubEMsQ0FBQyxFQUFFLENBQUNtbEMsTUFBTXJsQyxDQUFDO3dCQUNqRG1sQyxVQUFVMWtELEtBQUttTCxLQUFLLENBQUN5NUMsT0FBT1AsVUFBVTt3QkFDdENHLFVBQVV4a0QsS0FBS3lMLEdBQUcsQ0FBQ281QyxTQUFTZCxhQUFhL2pELEtBQUt5TCxHQUFHLENBQUNvNUMsU0FBU1o7b0JBQy9EO29CQUNBLDZCQUE2QjtvQkFDN0IsSUFBSUcsWUFBWTt3QkFDWixJQUFJVSxRQUFROWtELEtBQUsyWixJQUFJLENBQUN1cUMsSUFBSTlHLElBQUlpRzt3QkFDOUJ5QixNQUFNNXFDLFNBQVM7d0JBQ2YsSUFBSTZxQyxVQUFVekIsWUFBWXY1QyxHQUFHLENBQUMrNkMsTUFBTXJsQyxDQUFDLEVBQUUsQ0FBQ3FsQyxNQUFNdmxDLENBQUM7d0JBQy9Db2xDLFVBQVUza0QsS0FBS21MLEtBQUssQ0FBQ2s1QyxPQUFPUyxTQUFTO3dCQUNyQ0wsVUFBVXprRCxLQUFLeUwsR0FBRyxDQUFDczVDLFNBQVNoQixhQUFhL2pELEtBQUt5TCxHQUFHLENBQUNzNUMsU0FBUzNIO29CQUMvRDtvQkFDQSxJQUFJNEgsUUFBUTtvQkFDWixJQUFJbnJDLFNBQVMwcEMsV0FBV3I3QyxPQUFPO29CQUMvQixJQUFJKzhDLGFBQWF6QixlQUFldDdDLE9BQU87b0JBQ3ZDLElBQUlnOUMsYUFBYXpCLGVBQWV2N0MsT0FBTztvQkFDdkMsd0VBQXdFO29CQUN4RSxJQUFJaThDLGNBQWNDLFlBQVk7d0JBQzFCLElBQUlNLFdBQVdDLFNBQVM7NEJBQ3BCSyxRQUFRUixXQUFXLEtBQUtELFdBQVcsS0FBS0UsV0FBVzs0QkFDbkQsSUFBSU8sT0FBTztnQ0FDUG5yQyxPQUFPOVAsR0FBRyxDQUFDdTZDO2dDQUNYVyxXQUFXbDdDLEdBQUcsQ0FBQzg2QztnQ0FDZkssV0FBV243QyxHQUFHLENBQUNnN0M7NEJBQ25CLE9BQU87Z0NBQ0hsckMsT0FBT213QixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ2xCVyxXQUFXamIsTUFBTSxDQUFDLENBQUMsR0FBR3NhO2dDQUN0QlksV0FBV2xiLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTs0QkFDMUI7d0JBQ0osT0FBTyxJQUFJSSxTQUFTOzRCQUNoQk0sUUFBUVIsV0FBVyxLQUFLRCxXQUFXLEtBQUtFLFdBQVc7NEJBQ25ELElBQUlPLE9BQU87Z0NBQ1BuckMsT0FBTzlQLEdBQUcsQ0FBQ3U2QztnQ0FDWFcsV0FBV2w3QyxHQUFHLENBQUM4NkM7Z0NBQ2ZLLFdBQVduN0MsR0FBRyxDQUFDdTZDOzRCQUNuQixPQUFPO2dDQUNIenFDLE9BQU9td0IsTUFBTSxDQUFDLENBQUMsR0FBR3NhO2dDQUNsQlcsV0FBV2piLE1BQU0sQ0FBQyxDQUFDLEdBQUcrYTtnQ0FDdEJHLFdBQVdsYixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7NEJBQzFCO3dCQUNKLE9BQU8sSUFBSUssU0FBUzs0QkFDaEJLLFFBQVFQLFdBQVcsS0FBS0QsV0FBVyxLQUFLRCxXQUFXOzRCQUNuRCxJQUFJUyxPQUFPO2dDQUNQbnJDLE9BQU85UCxHQUFHLENBQUN1NkM7Z0NBQ1hXLFdBQVdsN0MsR0FBRyxDQUFDdTZDO2dDQUNmWSxXQUFXbjdDLEdBQUcsQ0FBQ2c3Qzs0QkFDbkIsT0FBTztnQ0FDSGxyQyxPQUFPbXdCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTtnQ0FDbEJXLFdBQVdqYixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ3RCWSxXQUFXbGIsTUFBTSxDQUFDLENBQUMsR0FBRzZhOzRCQUMxQjt3QkFDSixPQUFPOzRCQUNIRyxRQUFRUixXQUFXLEtBQUtELFdBQVcsS0FBS0UsV0FBVzs0QkFDbkQsSUFBSU8sT0FBTztnQ0FDUG5yQyxPQUFPOVAsR0FBRyxDQUFDdTZDO2dDQUNYVyxXQUFXbDdDLEdBQUcsQ0FBQ3U2QztnQ0FDZlksV0FBV243QyxHQUFHLENBQUN1NkM7NEJBQ25CLE9BQU87Z0NBQ0h6cUMsT0FBT213QixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ2xCVyxXQUFXamIsTUFBTSxDQUFDLENBQUMsR0FBRythO2dDQUN0QkcsV0FBV2xiLE1BQU0sQ0FBQyxDQUFDLEdBQUc2YTs0QkFDMUI7d0JBQ0o7b0JBQ0osT0FBTyxJQUFJVixZQUFZO3dCQUNuQixJQUFJTyxTQUFTOzRCQUNUTSxRQUFRUixXQUFXLEtBQUtELFdBQVc7NEJBQ25DLElBQUlTLE9BQU87Z0NBQ1BuckMsT0FBTzlQLEdBQUcsQ0FBQ3U2QztnQ0FDWFcsV0FBV2w3QyxHQUFHLENBQUM4NkM7Z0NBQ2ZLLFdBQVdsYixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7NEJBQzFCLE9BQU87Z0NBQ0h6cUMsT0FBT213QixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ2xCVyxXQUFXbDdDLEdBQUcsQ0FBQ3U2QztnQ0FDZlksV0FBV2xiLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTs0QkFDMUI7d0JBQ0osT0FBTzs0QkFDSFUsUUFBUVIsV0FBVyxLQUFLRCxXQUFXOzRCQUNuQyxJQUFJUyxPQUFPO2dDQUNQbnJDLE9BQU85UCxHQUFHLENBQUN1NkM7Z0NBQ1hXLFdBQVdsN0MsR0FBRyxDQUFDdTZDO2dDQUNmWSxXQUFXbGIsTUFBTSxDQUFDLENBQUMsR0FBR3NhOzRCQUMxQixPQUFPO2dDQUNIenFDLE9BQU9td0IsTUFBTSxDQUFDLENBQUMsR0FBR3NhO2dDQUNsQlcsV0FBV2w3QyxHQUFHLENBQUN1NkM7Z0NBQ2ZZLFdBQVdsYixNQUFNLENBQUMsQ0FBQyxHQUFHNmE7NEJBQzFCO3dCQUNKO29CQUNKLE9BQU8sSUFBSVQsWUFBWTt3QkFDbkIsSUFBSU8sU0FBUzs0QkFDVEssUUFBUVQsV0FBVyxLQUFLRSxXQUFXOzRCQUNuQyxJQUFJTyxPQUFPO2dDQUNQbnJDLE9BQU85UCxHQUFHLENBQUN1NkM7Z0NBQ1hXLFdBQVdqYixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ3RCWSxXQUFXbjdDLEdBQUcsQ0FBQ2c3Qzs0QkFDbkIsT0FBTztnQ0FDSGxyQyxPQUFPbXdCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTtnQ0FDbEJXLFdBQVdqYixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ3RCWSxXQUFXbjdDLEdBQUcsQ0FBQ3U2Qzs0QkFDbkI7d0JBQ0osT0FBTzs0QkFDSFUsUUFBUVQsV0FBVyxLQUFLRSxXQUFXOzRCQUNuQyxJQUFJTyxPQUFPO2dDQUNQbnJDLE9BQU85UCxHQUFHLENBQUN1NkM7Z0NBQ1hXLFdBQVdqYixNQUFNLENBQUMsQ0FBQyxHQUFHc2E7Z0NBQ3RCWSxXQUFXbjdDLEdBQUcsQ0FBQ3U2Qzs0QkFDbkIsT0FBTztnQ0FDSHpxQyxPQUFPbXdCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTtnQ0FDbEJXLFdBQVdqYixNQUFNLENBQUMsQ0FBQyxHQUFHK2E7Z0NBQ3RCRyxXQUFXbjdDLEdBQUcsQ0FBQ3U2Qzs0QkFDbkI7d0JBQ0o7b0JBQ0osT0FBTzt3QkFDSFUsUUFBUVQsV0FBVzt3QkFDbkIsSUFBSVMsT0FBTzs0QkFDUG5yQyxPQUFPOVAsR0FBRyxDQUFDdTZDOzRCQUNYVyxXQUFXamIsTUFBTSxDQUFDLENBQUMsR0FBR3NhOzRCQUN0QlksV0FBV2xiLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTt3QkFDMUIsT0FBTzs0QkFDSHpxQyxPQUFPbXdCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzYTs0QkFDbEJXLFdBQVdsN0MsR0FBRyxDQUFDdTZDOzRCQUNmWSxXQUFXbjdDLEdBQUcsQ0FBQ3U2Qzt3QkFDbkI7b0JBQ0o7b0JBQ0EseUJBQXlCO29CQUN6QjVCLFVBQVVqeUIsS0FBSyxHQUFHcXpCLFNBQVNwcEIsT0FBTztvQkFDbEMsSUFBSyxJQUFJbDdCLElBQUksR0FBR0EsSUFBSXNrRCxTQUFTcHBCLE9BQU8sRUFBRSxFQUFFbDdCLEVBQUc7d0JBQ3ZDa2pELFVBQVV6b0IsUUFBUSxDQUFDejZCLEVBQUUsR0FBR1ksVUFBVXdaLFFBQVEsQ0FBQzFQLElBQUk0NUMsU0FBU3hvQixVQUFVLENBQUM5N0IsRUFBRSxFQUFFa2pELFVBQVV6b0IsUUFBUSxDQUFDejZCLEVBQUU7d0JBQzVGa2pELFVBQVVsRCxPQUFPLENBQUNoZ0QsRUFBRSxHQUFHYSxJQUFJdVosUUFBUSxDQUFDMVAsR0FBR3hFLENBQUMsRUFBRW8rQyxTQUFTckUsU0FBUyxDQUFDamdELEVBQUUsRUFBRWtqRCxVQUFVbEQsT0FBTyxDQUFDaGdELEVBQUU7b0JBQ3pGO29CQUNBLElBQUlxL0MsU0FBUyxJQUFJejhDLFNBQVMwbkIsYUFBYTtvQkFDdkNyVyxTQUFTQyxVQUFVLEdBQUc7b0JBQ3RCO3dCQUNJLHdCQUF3Qjt3QkFDeEI4dUMsU0FBU3AvQyxJQUFJLEdBQUdzK0M7d0JBQ2hCYyxTQUFTNXVCLEtBQUssR0FBR294QixRQUFRLElBQUk7d0JBQzdCeEMsU0FBUzFvQyxVQUFVLEdBQUdxVTt3QkFDdEIsSUFBSyxJQUFJM3VCLElBQUksR0FBR0EsSUFBSWtqRCxVQUFVanlCLEtBQUssRUFBRSxFQUFFanhCLEVBQUc7NEJBQ3RDLElBQUlMLElBQUlhLEtBQUt5TCxHQUFHLENBQUNvTyxRQUFRN1osS0FBS2lMLEdBQUcsQ0FBQ3kzQyxVQUFVem9CLFFBQVEsQ0FBQ3o2QixFQUFFLEVBQUUyOUMsSUFBSXlGOzRCQUM3RCxJQUFJempELElBQUlxakQsU0FBUzFvQyxVQUFVLEVBQUU7Z0NBQ3pCMG9DLFNBQVMxb0MsVUFBVSxHQUFHM2E7NEJBQzFCO3dCQUNKO29CQUNKO29CQUNBLHFFQUFxRTtvQkFDckUsSUFBSXFqRCxTQUFTcC9DLElBQUksS0FBS3cvQixXQUFXO3dCQUM3QjtvQkFDSjtvQkFDQSxJQUFJNGYsU0FBUzFvQyxVQUFVLEdBQUcra0MsUUFBUTt3QkFDOUI7b0JBQ0o7b0JBQ0E7d0JBQ0ksMkJBQTJCO3dCQUMzQjRELFlBQVlyL0MsSUFBSSxHQUFHdy9CO3dCQUNuQjZmLFlBQVk3dUIsS0FBSyxHQUFHLENBQUM7d0JBQ3JCNnVCLFlBQVkzb0MsVUFBVSxHQUFHLENBQUNxVTt3QkFDMUIsSUFBSTJwQixPQUFPaUwsU0FBU2g1QyxHQUFHLENBQUMsQ0FBQzhQLE9BQU80RixDQUFDLEVBQUU1RixPQUFPMEYsQ0FBQzt3QkFDM0MsSUFBSyxJQUFJL2YsSUFBSSxHQUFHQSxJQUFJa2pELFVBQVVqeUIsS0FBSyxFQUFFLEVBQUVqeEIsRUFBRzs0QkFDdEMsSUFBSVAsSUFBSTZqRCxNQUFNLzRDLEdBQUcsQ0FBQzI0QyxVQUFVbEQsT0FBTyxDQUFDaGdELEVBQUUsRUFBRXc3QixHQUFHOzRCQUMzQyxJQUFJMkosS0FBSzNrQyxLQUFLeUwsR0FBRyxDQUFDeE0sR0FBR2UsS0FBSzJaLElBQUksQ0FBQytvQyxVQUFVem9CLFFBQVEsQ0FBQ3o2QixFQUFFLEVBQUUyOUMsSUFBSXlGOzRCQUMxRCxJQUFJbmUsS0FBS3prQyxLQUFLeUwsR0FBRyxDQUFDeE0sR0FBR2UsS0FBSzJaLElBQUksQ0FBQytvQyxVQUFVem9CLFFBQVEsQ0FBQ3o2QixFQUFFLEVBQUU0OUMsSUFBSXdGOzRCQUMxRCxJQUFJempELElBQUlZLE1BQUt5YSxHQUFHLENBQUNtcUIsSUFBSUY7NEJBQ3JCLElBQUl0bEMsSUFBSTAvQyxRQUFRO2dDQUNaLGVBQWU7Z0NBQ2Y0RCxZQUFZci9DLElBQUksR0FBR3UrQztnQ0FDbkJjLFlBQVk3dUIsS0FBSyxHQUFHcDBCO2dDQUNwQmlqRCxZQUFZM29DLFVBQVUsR0FBRzNhO2dDQUN6Qjs0QkFDSjs0QkFDQSxZQUFZOzRCQUNaLElBQUlhLEtBQUt5TCxHQUFHLENBQUN4TSxHQUFHNjRDLFNBQVMsR0FBRztnQ0FDeEIsSUFBSTkzQyxLQUFLeUwsR0FBRyxDQUFDekwsS0FBSzJaLElBQUksQ0FBQzFhLEdBQUdpbUQsWUFBWXRDLFNBQVMvb0MsVUFBVSxDQUFDelgsU0FBU3duQixXQUFXLEVBQUU7b0NBQzVFO2dDQUNKOzRCQUNKLE9BQU87Z0NBQ0gsSUFBSTVwQixLQUFLeUwsR0FBRyxDQUFDekwsS0FBSzJaLElBQUksQ0FBQzFhLEdBQUdnbUQsWUFBWXJDLFNBQVMvb0MsVUFBVSxDQUFDelgsU0FBU3duQixXQUFXLEVBQUU7b0NBQzVFO2dDQUNKOzRCQUNKOzRCQUNBLElBQUl6cUIsSUFBSXNqRCxZQUFZM29DLFVBQVUsRUFBRTtnQ0FDNUIyb0MsWUFBWXIvQyxJQUFJLEdBQUd1K0M7Z0NBQ25CYyxZQUFZN3VCLEtBQUssR0FBR3AwQjtnQ0FDcEJpakQsWUFBWTNvQyxVQUFVLEdBQUczYTs0QkFDN0I7d0JBQ0o7b0JBQ0o7b0JBQ0EsSUFBSXNqRCxZQUFZci9DLElBQUksS0FBS3cvQixhQUFhNmYsWUFBWTNvQyxVQUFVLEdBQUcra0MsUUFBUTt3QkFDbkU7b0JBQ0o7b0JBQ0EsdUNBQXVDO29CQUN2QyxJQUFJc0csZ0JBQWdCO29CQUNwQixJQUFJQyxnQkFBZ0I7b0JBQ3BCLElBQUlDO29CQUNKLElBQUk1QyxZQUFZci9DLElBQUksS0FBS3cvQixXQUFXO3dCQUNoQ3lpQixjQUFjN0M7b0JBQ2xCLE9BQU8sSUFBSUMsWUFBWTNvQyxVQUFVLEdBQUdxckMsZ0JBQWdCM0MsU0FBUzFvQyxVQUFVLEdBQUdzckMsZUFBZTt3QkFDckZDLGNBQWM1QztvQkFDbEIsT0FBTzt3QkFDSDRDLGNBQWM3QztvQkFDbEI7b0JBQ0FxQixNQUFNLENBQUMsRUFBRSxDQUFDbHpDLElBQUk7b0JBQ2RrekMsTUFBTSxDQUFDLEVBQUUsQ0FBQ2x6QyxJQUFJO29CQUNkLElBQUkyMEMsS0FBS3pCO29CQUNULElBQUl3QixZQUFZamlELElBQUksS0FBS3MrQyxTQUFTO3dCQUM5Qmp1QyxTQUFTclEsSUFBSSxHQUFHcEIsU0FBU29ZLE9BQU87d0JBQ2hDLHVFQUF1RTt3QkFDdkUsVUFBVTt3QkFDVixJQUFJb2hCLFlBQVk7d0JBQ2hCLElBQUlDLFlBQVl6N0IsS0FBS3lMLEdBQUcsQ0FBQ29PLFFBQVE2b0MsVUFBVWxELE9BQU8sQ0FBQyxFQUFFO3dCQUNyRCxJQUFLLElBQUloZ0QsSUFBSSxHQUFHQSxJQUFJa2pELFVBQVVqeUIsS0FBSyxFQUFFLEVBQUVqeEIsRUFBRzs0QkFDdEMsSUFBSTAzQixRQUFRbDNCLEtBQUt5TCxHQUFHLENBQUNvTyxRQUFRNm9DLFVBQVVsRCxPQUFPLENBQUNoZ0QsRUFBRTs0QkFDakQsSUFBSTAzQixRQUFRdUUsV0FBVztnQ0FDbkJBLFlBQVl2RTtnQ0FDWnNFLFlBQVloOEI7NEJBQ2hCO3dCQUNKO3dCQUNBLElBQUkwaUQsS0FBSzFtQjt3QkFDVCxJQUFJMm1CLEtBQUtELEtBQUssSUFBSVEsVUFBVWp5QixLQUFLLEdBQUd5eEIsS0FBSyxJQUFJO3dCQUM3Q29ELEVBQUUsQ0FBQyxFQUFFLENBQUM5NUMsQ0FBQyxDQUFDekIsR0FBRyxDQUFDMjRDLFVBQVV6b0IsUUFBUSxDQUFDaW9CLEdBQUc7d0JBQ2xDb0QsRUFBRSxDQUFDLEVBQUUsQ0FBQ3Z1QyxFQUFFLENBQUN5USxFQUFFLENBQUMzVyxNQUFNLEdBQUc7d0JBQ3JCeTBDLEVBQUUsQ0FBQyxFQUFFLENBQUN2dUMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDelcsTUFBTSxHQUFHbXhDO3dCQUNyQm9ELEVBQUUsQ0FBQyxFQUFFLENBQUN2dUMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDbEYsS0FBSyxHQUFHdGdCLFNBQVNxbEIsTUFBTTt3QkFDbkNpK0IsRUFBRSxDQUFDLEVBQUUsQ0FBQ3Z1QyxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO3dCQUNyQ2srQixFQUFFLENBQUMsRUFBRSxDQUFDOTVDLENBQUMsQ0FBQ3pCLEdBQUcsQ0FBQzI0QyxVQUFVem9CLFFBQVEsQ0FBQ2tvQixHQUFHO3dCQUNsQ21ELEVBQUUsQ0FBQyxFQUFFLENBQUN2dUMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDM1csTUFBTSxHQUFHO3dCQUNyQnkwQyxFQUFFLENBQUMsRUFBRSxDQUFDdnVDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU0sR0FBR294Qzt3QkFDckJtRCxFQUFFLENBQUMsRUFBRSxDQUFDdnVDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR3RnQixTQUFTcWxCLE1BQU07d0JBQ25DaStCLEVBQUUsQ0FBQyxFQUFFLENBQUN2dUMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHdmdCLFNBQVNvbEIsUUFBUTt3QkFDckMsSUFBSTQ5QixPQUFPOzRCQUNQckMsR0FBR1QsRUFBRSxHQUFHOzRCQUNSUyxHQUFHUixFQUFFLEdBQUc7NEJBQ1JRLEdBQUd4RixFQUFFLENBQUNwekMsR0FBRyxDQUFDb3pDOzRCQUNWd0YsR0FBR3ZGLEVBQUUsQ0FBQ3J6QyxHQUFHLENBQUNxekM7NEJBQ1Z1RixHQUFHOW9DLE1BQU0sQ0FBQzlQLEdBQUcsQ0FBQ3U2Qzt3QkFDbEIsT0FBTzs0QkFDSDNCLEdBQUdULEVBQUUsR0FBRzs0QkFDUlMsR0FBR1IsRUFBRSxHQUFHOzRCQUNSUSxHQUFHeEYsRUFBRSxDQUFDcHpDLEdBQUcsQ0FBQ3F6Qzs0QkFDVnVGLEdBQUd2RixFQUFFLENBQUNyekMsR0FBRyxDQUFDb3pDOzRCQUNWd0YsR0FBRzlvQyxNQUFNLENBQUM5UCxHQUFHLENBQUN1NkMsU0FBU3RwQixHQUFHO3dCQUM5QjtvQkFDSixPQUFPO3dCQUNIdm5CLFNBQVNyUSxJQUFJLEdBQUdwQixTQUFTdVksT0FBTzt3QkFDaEMrcUMsRUFBRSxDQUFDLEVBQUUsQ0FBQzk1QyxDQUFDLENBQUN6QixHQUFHLENBQUNvekM7d0JBQ1ptSSxFQUFFLENBQUMsRUFBRSxDQUFDdnVDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRzt3QkFDckJ5MEMsRUFBRSxDQUFDLEVBQUUsQ0FBQ3Z1QyxFQUFFLENBQUN5USxFQUFFLENBQUN6VyxNQUFNLEdBQUdzMEMsWUFBWXp4QixLQUFLO3dCQUN0QzB4QixFQUFFLENBQUMsRUFBRSxDQUFDdnVDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR3RnQixTQUFTb2xCLFFBQVE7d0JBQ3JDaytCLEVBQUUsQ0FBQyxFQUFFLENBQUN2dUMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHdmdCLFNBQVNxbEIsTUFBTTt3QkFDbkNpK0IsRUFBRSxDQUFDLEVBQUUsQ0FBQzk1QyxDQUFDLENBQUN6QixHQUFHLENBQUNxekM7d0JBQ1prSSxFQUFFLENBQUMsRUFBRSxDQUFDdnVDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBRzt3QkFDckJ5MEMsRUFBRSxDQUFDLEVBQUUsQ0FBQ3Z1QyxFQUFFLENBQUN5USxFQUFFLENBQUN6VyxNQUFNLEdBQUdzMEMsWUFBWXp4QixLQUFLO3dCQUN0QzB4QixFQUFFLENBQUMsRUFBRSxDQUFDdnVDLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR3RnQixTQUFTb2xCLFFBQVE7d0JBQ3JDaytCLEVBQUUsQ0FBQyxFQUFFLENBQUN2dUMsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHdmdCLFNBQVNxbEIsTUFBTTt3QkFDbkNzN0IsR0FBR1QsRUFBRSxHQUFHbUQsWUFBWXp4QixLQUFLO3dCQUN6Qit1QixHQUFHUixFQUFFLEdBQUdRLEdBQUdULEVBQUUsR0FBRyxJQUFJUSxVQUFVanlCLEtBQUssR0FBR2t5QixHQUFHVCxFQUFFLEdBQUcsSUFBSTt3QkFDbERTLEdBQUd4RixFQUFFLENBQUNwekMsR0FBRyxDQUFDMjRDLFVBQVV6b0IsUUFBUSxDQUFDMG9CLEdBQUdULEVBQUUsQ0FBQzt3QkFDbkNTLEdBQUd2RixFQUFFLENBQUNyekMsR0FBRyxDQUFDMjRDLFVBQVV6b0IsUUFBUSxDQUFDMG9CLEdBQUdSLEVBQUUsQ0FBQzt3QkFDbkNRLEdBQUc5b0MsTUFBTSxDQUFDOVAsR0FBRyxDQUFDMjRDLFVBQVVsRCxPQUFPLENBQUNtRCxHQUFHVCxFQUFFLENBQUM7b0JBQzFDO29CQUNBUyxHQUFHUCxXQUFXLENBQUNyNEMsR0FBRyxDQUFDNDRDLEdBQUc5b0MsTUFBTSxDQUFDNEYsQ0FBQyxFQUFFLENBQUNrakMsR0FBRzlvQyxNQUFNLENBQUMwRixDQUFDO29CQUM1Q29qQyxHQUFHTCxXQUFXLENBQUN0WSxNQUFNLENBQUMsQ0FBQyxHQUFHMlksR0FBR1AsV0FBVztvQkFDeENPLEdBQUdOLFdBQVcsR0FBR3JpRCxLQUFLeUwsR0FBRyxDQUFDazNDLEdBQUdQLFdBQVcsRUFBRU8sR0FBR3hGLEVBQUU7b0JBQy9Dd0YsR0FBR0osV0FBVyxHQUFHdmlELEtBQUt5TCxHQUFHLENBQUNrM0MsR0FBR0wsV0FBVyxFQUFFSyxHQUFHdkYsRUFBRTtvQkFDL0Msd0RBQXdEO29CQUN4RHVHLGVBQWUsQ0FBQyxFQUFFLENBQUNoekMsSUFBSTtvQkFDdkJnekMsZUFBZSxDQUFDLEVBQUUsQ0FBQ2h6QyxJQUFJO29CQUN2Qml6QyxlQUFlLENBQUMsRUFBRSxDQUFDanpDLElBQUk7b0JBQ3ZCaXpDLGVBQWUsQ0FBQyxFQUFFLENBQUNqekMsSUFBSTtvQkFDdkIsSUFBSTQwQyxjQUFjNUI7b0JBQ2xCLElBQUk2QixjQUFjNUI7b0JBQ2xCLElBQUk2QjtvQkFDSixxQkFBcUI7b0JBQ3JCQSxLQUFLempELFNBQVMra0IsaUJBQWlCLENBQUN3K0IsYUFBYUQsSUFBSTNDLEdBQUdQLFdBQVcsRUFBRU8sR0FBR04sV0FBVyxFQUFFTSxHQUFHVCxFQUFFO29CQUN0RixJQUFJdUQsS0FBS3JqRCxTQUFTbW5CLGlCQUFpQixFQUFFO3dCQUNqQztvQkFDSjtvQkFDQSw4QkFBOEI7b0JBQzlCazhCLEtBQUt6akQsU0FBUytrQixpQkFBaUIsQ0FBQ3krQixhQUFhRCxhQUFhNUMsR0FBR0wsV0FBVyxFQUFFSyxHQUFHSixXQUFXLEVBQUVJLEdBQUdSLEVBQUU7b0JBQy9GLElBQUlzRCxLQUFLcmpELFNBQVNtbkIsaUJBQWlCLEVBQUU7d0JBQ2pDO29CQUNKO29CQUNBLCtDQUErQztvQkFDL0MsSUFBSTg3QixZQUFZamlELElBQUksS0FBS3MrQyxTQUFTO3dCQUM5Qmp1QyxTQUFTSSxXQUFXLENBQUM5SixHQUFHLENBQUM0NEMsR0FBRzlvQyxNQUFNO3dCQUNsQ3BHLFNBQVNwSSxVQUFVLENBQUN0QixHQUFHLENBQUM0NEMsR0FBR3hGLEVBQUU7b0JBQ2pDLE9BQU87d0JBQ0gxcEMsU0FBU0ksV0FBVyxDQUFDOUosR0FBRyxDQUFDKzVDLFNBQVNyRSxTQUFTLENBQUNrRCxHQUFHVCxFQUFFLENBQUM7d0JBQ2xEenVDLFNBQVNwSSxVQUFVLENBQUN0QixHQUFHLENBQUMrNUMsU0FBU3hvQixVQUFVLENBQUNxbkIsR0FBR1QsRUFBRSxDQUFDO29CQUN0RDtvQkFDQSxJQUFJeHVDLGFBQWE7b0JBQ2pCLElBQUssSUFBSWxVLElBQUksR0FBR0EsSUFBSTRDLFNBQVNtbkIsaUJBQWlCLEVBQUUsRUFBRS9wQixFQUFHO3dCQUNqRCxJQUFJc2EsYUFBYTlaLEtBQUt5TCxHQUFHLENBQUNrM0MsR0FBRzlvQyxNQUFNLEVBQUU3WixLQUFLMlosSUFBSSxDQUFDNnJDLFdBQVcsQ0FBQ2htRCxFQUFFLENBQUNnTSxDQUFDLEVBQUVtM0MsR0FBR3hGLEVBQUUsRUFBRXlGO3dCQUN4RSxJQUFJOW9DLGNBQWMra0MsUUFBUTs0QkFDdEIsSUFBSTlxQyxLQUFLTixTQUFTTyxNQUFNLENBQUNOLFdBQVc7NEJBQ3BDLGdCQUFnQjs0QkFDaEIsSUFBSTJ4QyxZQUFZamlELElBQUksS0FBS3MrQyxTQUFTO2dDQUM5QjN0QyxHQUFHMUksVUFBVSxHQUFHakwsVUFBVThvQyxTQUFTLENBQUNoL0IsSUFBSXM3QyxXQUFXLENBQUNobUQsRUFBRSxDQUFDZ00sQ0FBQyxFQUFFdUksR0FBRzFJLFVBQVU7Z0NBQ3ZFMEksR0FBR2dELEVBQUUsQ0FBQ2hOLEdBQUcsQ0FBQ3k3QyxXQUFXLENBQUNobUQsRUFBRSxDQUFDdVgsRUFBRTs0QkFDL0IsT0FBTztnQ0FDSGhELEdBQUcxSSxVQUFVLENBQUN0QixHQUFHLENBQUN5N0MsV0FBVyxDQUFDaG1ELEVBQUUsQ0FBQ2dNLENBQUM7Z0NBQ2xDdUksR0FBR2dELEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR2tqQyxXQUFXLENBQUNobUQsRUFBRSxDQUFDdVgsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSztnQ0FDM0N4TyxHQUFHZ0QsRUFBRSxDQUFDeVEsRUFBRSxDQUFDakYsS0FBSyxHQUFHaWpDLFdBQVcsQ0FBQ2htRCxFQUFFLENBQUN1WCxFQUFFLENBQUN5USxFQUFFLENBQUNsRixLQUFLO2dDQUMzQ3ZPLEdBQUdnRCxFQUFFLENBQUN5USxFQUFFLENBQUMzVyxNQUFNLEdBQUcyMEMsV0FBVyxDQUFDaG1ELEVBQUUsQ0FBQ3VYLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU07Z0NBQzdDZ0QsR0FBR2dELEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU0sR0FBR3kwQyxXQUFXLENBQUNobUQsRUFBRSxDQUFDdVgsRUFBRSxDQUFDeVEsRUFBRSxDQUFDM1csTUFBTTs0QkFDakQ7NEJBQ0EsRUFBRTZDO3dCQUNOO29CQUNKO29CQUNBRCxTQUFTQyxVQUFVLEdBQUdBO2dCQUMxQjtZQUdBO1lBQUU7Z0JBQUMsY0FBYTtnQkFBRSxlQUFjO2dCQUFFLGVBQWM7Z0JBQUUsa0JBQWlCO2dCQUFHLGlCQUFnQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxnQkFBZTtnQkFBRyxlQUFjO2dCQUFHLGtCQUFpQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU25VLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN0UCxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RCxJQUFJQyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJeUMsV0FBV3pDLFNBQVE7Z0JBRXZCLElBQUltQixVQUFVbkIsU0FBUTtnQkFFdEIsSUFBSWc5QyxlQUFlaDlDLFNBQVE7Z0JBRTNCZixRQUFPRCxPQUFPLEdBQUcyQztnQkFFakJSLFFBQVF3aEIsT0FBTyxDQUFDcTZCLGFBQWFyUixJQUFJLEVBQUVxUixhQUFhclIsSUFBSSxFQUFFd2E7Z0JBRXRELFNBQVNBLGVBQWVqeUMsUUFBUSxFQUFFdUMsR0FBRyxFQUFFcEgsUUFBUSxFQUFFaUMsTUFBTSxFQUFFb0YsR0FBRyxFQUFFbkgsUUFBUSxFQUFFaUMsTUFBTTtvQkFDMUV4TyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDdUssU0FBUzVHLE9BQU8sTUFBTXUwQyxhQUFhclIsSUFBSTtvQkFDaEUzb0MsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ3lLLFNBQVM5RyxPQUFPLE1BQU11MEMsYUFBYXJSLElBQUk7b0JBQ2hFaHFDLGdCQUFnQnVTLFVBQVU3RSxTQUFTd0UsUUFBUSxJQUFJNEMsS0FBS2xILFNBQVNzRSxRQUFRLElBQUk2QztnQkFDN0U7Z0JBRUEsSUFBSTB2QyxTQUFTM2xELEtBQUtzRCxJQUFJO2dCQUV0QixJQUFJc2lELFFBQVE1bEQsS0FBS3NELElBQUk7Z0JBRXJCLElBQUl1aUQsU0FBU3psRCxVQUFVbUYsUUFBUTtnQkFFL0IsSUFBSXVnRDtnQkFFSixJQUFJQztnQkFFSjs7O0NBR0MsR0FDRCxTQUFTQyxrQkFBa0JDLEtBQUssRUFBRXhoQyxHQUFHLEVBQUV5aEMsS0FBSyxFQUFFeGhDLEdBQUc7b0JBQzdDLElBQUl5aEMsU0FBU0YsTUFBTXZyQixPQUFPO29CQUMxQixJQUFJMHJCLFNBQVNGLE1BQU14ckIsT0FBTztvQkFDMUIsSUFBSTJyQixNQUFNSixNQUFNeEcsU0FBUztvQkFDekIsSUFBSTZHLE1BQU1MLE1BQU0zcUIsVUFBVTtvQkFDMUIsSUFBSWlyQixNQUFNTCxNQUFNNXFCLFVBQVU7b0JBQzFCLElBQUlweEIsS0FBSzlKLFVBQVV5cEMsT0FBTyxDQUFDbmxCLEtBQUtELEtBQUtvaEM7b0JBQ3JDLElBQUlycUIsWUFBWTtvQkFDaEIsSUFBSWdyQixnQkFBZ0IsQ0FBQ3I0QjtvQkFDckIsSUFBSyxJQUFJM3VCLElBQUksR0FBR0EsSUFBSTJtRCxRQUFRLEVBQUUzbUQsRUFBRzt3QkFDN0IsOEJBQThCO3dCQUM5QixJQUFJUCxJQUFJb0IsSUFBSXVaLFFBQVEsQ0FBQzFQLEdBQUd4RSxDQUFDLEVBQUUyZ0QsR0FBRyxDQUFDN21ELEVBQUUsRUFBRW9tRDt3QkFDbkMsSUFBSXpJLEtBQUsvOEMsVUFBVXdaLFFBQVEsQ0FBQzFQLElBQUlvOEMsR0FBRyxDQUFDOW1ELEVBQUUsRUFBRW1tRDt3QkFDeEMsbUNBQW1DO3dCQUNuQyxJQUFJYyxLQUFLdDRCO3dCQUNULElBQUssSUFBSXJhLElBQUksR0FBR0EsSUFBSXN5QyxRQUFRLEVBQUV0eUMsRUFBRzs0QkFDN0IsSUFBSTR5QyxNQUFNMW1ELEtBQUt5TCxHQUFHLENBQUN4TSxHQUFHc25ELEdBQUcsQ0FBQ3p5QyxFQUFFLElBQUk5VCxLQUFLeUwsR0FBRyxDQUFDeE0sR0FBR2srQzs0QkFDNUMsSUFBSXVKLE1BQU1ELElBQUk7Z0NBQ1ZBLEtBQUtDOzRCQUNUO3dCQUNKO3dCQUNBLElBQUlELEtBQUtELGVBQWU7NEJBQ3BCQSxnQkFBZ0JDOzRCQUNoQmpyQixZQUFZaDhCO3dCQUNoQjtvQkFDSjtvQkFDQSxrREFBa0Q7b0JBQ2xEc21ELG9CQUFvQlU7b0JBQ3BCVCxnQkFBZ0J2cUI7Z0JBQ3BCO2dCQUVBLElBQUltckIsU0FBUzNtRCxLQUFLc0QsSUFBSTtnQkFFdEIsSUFBSXNqRCxjQUFjNW1ELEtBQUtzRCxJQUFJO2dCQUUzQjs7O0NBR0MsR0FDRCxTQUFTdWpELGlCQUFpQng4QyxDQUFDLEVBQUU0N0MsS0FBSyxFQUFFeGhDLEdBQUcsRUFBRTQvQixLQUFLLEVBQUU2QixLQUFLLEVBQUV4aEMsR0FBRztvQkFDdEQsSUFBSW9pQyxXQUFXYixNQUFNeEcsU0FBUztvQkFDOUIsSUFBSTJHLFNBQVNGLE1BQU14ckIsT0FBTztvQkFDMUIsSUFBSXFzQixZQUFZYixNQUFNNXFCLFVBQVU7b0JBQ2hDLElBQUkwckIsV0FBV2QsTUFBTXpHLFNBQVM7b0JBQzlCbDlDLFdBQVdFLFFBQU80QixNQUFNLENBQUMsS0FBS2dnRCxTQUFTQSxRQUFRNEIsTUFBTXZyQixPQUFPO29CQUM1RCx5REFBeUQ7b0JBQ3pELElBQUk0cEIsVUFBVWprRCxJQUFJNm9DLFNBQVMsQ0FBQ3hrQixJQUFJaGYsQ0FBQyxFQUFFckYsSUFBSXVaLFFBQVEsQ0FBQzZLLElBQUkvZSxDQUFDLEVBQUVvaEQsUUFBUSxDQUFDekMsTUFBTSxFQUFFc0MsU0FBU0M7b0JBQ2pGLG1DQUFtQztvQkFDbkMsSUFBSWh6QixRQUFRO29CQUNaLElBQUlxekIsU0FBUzk0QjtvQkFDYixJQUFLLElBQUkzdUIsSUFBSSxHQUFHQSxJQUFJNG1ELFFBQVEsRUFBRTVtRCxFQUFHO3dCQUM3QixJQUFJaU0sTUFBTXpMLEtBQUt5TCxHQUFHLENBQUM2NEMsU0FBUzBDLFFBQVEsQ0FBQ3huRCxFQUFFO3dCQUN2QyxJQUFJaU0sTUFBTXc3QyxRQUFROzRCQUNkQSxTQUFTeDdDOzRCQUNUbW9CLFFBQVFwMEI7d0JBQ1o7b0JBQ0o7b0JBQ0EsaURBQWlEO29CQUNqRCxJQUFJMGlELEtBQUt0dUI7b0JBQ1QsSUFBSXV1QixLQUFLRCxLQUFLLElBQUlrRSxTQUFTbEUsS0FBSyxJQUFJO29CQUNwQzczQyxDQUFDLENBQUMsRUFBRSxDQUFDbUIsQ0FBQyxHQUFHcEwsVUFBVTZPLE9BQU8sQ0FBQ3lWLEtBQUtxaUMsU0FBUyxDQUFDN0UsR0FBRztvQkFDN0M3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQzBNLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQzNXLE1BQU0sR0FBR3d6QztvQkFDcEJoNkMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzBNLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ3pXLE1BQU0sR0FBR214QztvQkFDcEI3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQzBNLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2xGLEtBQUssR0FBR3RnQixTQUFTcWxCLE1BQU07b0JBQ2xDaGQsQ0FBQyxDQUFDLEVBQUUsQ0FBQzBNLEVBQUUsQ0FBQ3lRLEVBQUUsQ0FBQ2pGLEtBQUssR0FBR3ZnQixTQUFTb2xCLFFBQVE7b0JBQ3BDL2MsQ0FBQyxDQUFDLEVBQUUsQ0FBQ21CLENBQUMsR0FBR3BMLFVBQVU2TyxPQUFPLENBQUN5VixLQUFLcWlDLFNBQVMsQ0FBQzVFLEdBQUc7b0JBQzdDOTNDLENBQUMsQ0FBQyxFQUFFLENBQUMwTSxFQUFFLENBQUN5USxFQUFFLENBQUMzVyxNQUFNLEdBQUd3ekM7b0JBQ3BCaDZDLENBQUMsQ0FBQyxFQUFFLENBQUMwTSxFQUFFLENBQUN5USxFQUFFLENBQUN6VyxNQUFNLEdBQUdveEM7b0JBQ3BCOTNDLENBQUMsQ0FBQyxFQUFFLENBQUMwTSxFQUFFLENBQUN5USxFQUFFLENBQUNsRixLQUFLLEdBQUd0Z0IsU0FBU3FsQixNQUFNO29CQUNsQ2hkLENBQUMsQ0FBQyxFQUFFLENBQUMwTSxFQUFFLENBQUN5USxFQUFFLENBQUNqRixLQUFLLEdBQUd2Z0IsU0FBU29sQixRQUFRO2dCQUN4QztnQkFFQSxJQUFJOC9CLGlCQUFpQmxuRCxLQUFLc0QsSUFBSTtnQkFFOUIsSUFBSTZqRCxjQUFjbm5ELEtBQUtzRCxJQUFJO2dCQUUzQixJQUFJOGpELGFBQWFwbkQsS0FBS3NELElBQUk7Z0JBRTFCLElBQUkrakQsbUJBQW1Ccm5ELEtBQUtzRCxJQUFJO2dCQUVoQyxJQUFJZ2tELGtCQUFrQnRuRCxLQUFLc0QsSUFBSTtnQkFFL0IsSUFBSWlrRCxVQUFVdm5ELEtBQUtzRCxJQUFJO2dCQUV2QixJQUFJa2tELFVBQVV4bkQsS0FBS3NELElBQUk7Z0JBRXZCLElBQUlta0QsU0FBU3puRCxLQUFLc0QsSUFBSTtnQkFFdEIsSUFBSW9rRCxrQkFBa0I7b0JBQUUsSUFBSTFsRCxTQUFTZ2xCLFVBQVU7b0JBQUksSUFBSWhsQixTQUFTZ2xCLFVBQVU7aUJBQUk7Z0JBRTlFLElBQUkyZ0Msa0JBQWtCO29CQUFFLElBQUkzbEQsU0FBU2dsQixVQUFVO29CQUFJLElBQUlobEIsU0FBU2dsQixVQUFVO2lCQUFJO2dCQUU5RSxJQUFJNGdDLG1CQUFtQjtvQkFBRSxJQUFJNWxELFNBQVNnbEIsVUFBVTtvQkFBSSxJQUFJaGxCLFNBQVNnbEIsVUFBVTtpQkFBSTtnQkFFL0U7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBUzlsQixnQkFBZ0J1UyxRQUFRLEVBQUVvMEMsS0FBSyxFQUFFN3hDLEdBQUcsRUFBRTh4QyxLQUFLLEVBQUU3eEMsR0FBRztvQkFDckR4QyxTQUFTQyxVQUFVLEdBQUc7b0JBQ3RCLElBQUkrdkIsY0FBY29rQixNQUFNajBDLFFBQVEsR0FBR2swQyxNQUFNbDBDLFFBQVE7b0JBQ2pEb3lDLGtCQUFrQjZCLE9BQU83eEMsS0FBSzh4QyxPQUFPN3hDO29CQUNyQyxJQUFJMnFDLFFBQVFtRjtvQkFDWixJQUFJZ0MsY0FBY2pDO29CQUNsQixJQUFJaUMsY0FBY3RrQixhQUFhO29CQUMvQnVpQixrQkFBa0I4QixPQUFPN3hDLEtBQUs0eEMsT0FBTzd4QztvQkFDckMsSUFBSWd5QyxRQUFRakM7b0JBQ1osSUFBSWtDLGNBQWNuQztvQkFDbEIsSUFBSW1DLGNBQWN4a0IsYUFBYTtvQkFDL0IsSUFBSXdpQjtvQkFDSixvQkFBb0I7b0JBQ3BCLElBQUlDO29CQUNKLG1CQUFtQjtvQkFDbkIsSUFBSXpoQztvQkFDSixJQUFJQztvQkFDSixJQUFJMi9CO29CQUNKLGlCQUFpQjtvQkFDakIsSUFBSTZEO29CQUNKLElBQUlDLFFBQVEsS0FBSy9sRCxTQUFTdVksVUFBVTtvQkFDcEMsSUFBSXN0QyxjQUFjRixjQUFjSSxPQUFPO3dCQUNuQ2xDLFFBQVE2Qjt3QkFDUjVCLFFBQVEyQjt3QkFDUnBqQyxNQUFNeE87d0JBQ055TyxNQUFNMU87d0JBQ05xdUMsUUFBUTJEO3dCQUNSdjBDLFNBQVNyUSxJQUFJLEdBQUdwQixTQUFTdVksT0FBTzt3QkFDaEMydEMsT0FBTztvQkFDWCxPQUFPO3dCQUNIakMsUUFBUTRCO3dCQUNSM0IsUUFBUTRCO3dCQUNScmpDLE1BQU16Tzt3QkFDTjBPLE1BQU16Tzt3QkFDTm91QyxRQUFRekQ7d0JBQ1JudEMsU0FBU3JRLElBQUksR0FBR3BCLFNBQVNvWSxPQUFPO3dCQUNoQzh0QyxPQUFPO29CQUNYO29CQUNBLElBQUlFLGVBQWVSO29CQUNuQkEsZ0JBQWdCLENBQUMsRUFBRSxDQUFDajNDLElBQUk7b0JBQ3hCaTNDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQ2ozQyxJQUFJO29CQUN4QmsyQyxpQkFBaUJ1QixjQUFjbkMsT0FBT3hoQyxLQUFLNC9CLE9BQU82QixPQUFPeGhDO29CQUN6RCxJQUFJeWhDLFNBQVNGLE1BQU12ckIsT0FBTztvQkFDMUIsSUFBSTJ0QixZQUFZcEMsTUFBTTNxQixVQUFVO29CQUNoQyxJQUFJZ3RCLE1BQU1qRTtvQkFDVixJQUFJa0UsTUFBTWxFLFFBQVEsSUFBSThCLFNBQVM5QixRQUFRLElBQUk7b0JBQzNDLElBQUltRSxNQUFNakIsUUFBUXg5QyxHQUFHLENBQUNzK0MsU0FBUyxDQUFDQyxJQUFJO29CQUNwQyxJQUFJRyxNQUFNakIsUUFBUXo5QyxHQUFHLENBQUNzK0MsU0FBUyxDQUFDRSxJQUFJO29CQUNwQyxJQUFJRyxlQUFlMW9ELEtBQUsyWixJQUFJLENBQUM4dUMsS0FBS0QsS0FBS25CO29CQUN2Q3FCLGFBQWF4dUMsU0FBUztvQkFDdEIsSUFBSXJHLGNBQWM3VCxLQUFLMmMsYUFBYSxDQUFDK3JDLGNBQWMsR0FBR3BCO29CQUN0RCxJQUFJanRDLGFBQWFyYSxLQUFLbWEsUUFBUSxDQUFDLElBQUlxdUMsS0FBSyxJQUFJQyxLQUFLdkI7b0JBQ2pELElBQUl4cUMsVUFBVXJjLElBQUl1WixRQUFRLENBQUM2SyxJQUFJL2UsQ0FBQyxFQUFFZ2pELGNBQWN2QjtvQkFDaEQsSUFBSXR0QyxTQUFTN1osS0FBSzJjLGFBQWEsQ0FBQ0QsU0FBUyxHQUFHMHFDO29CQUM1Q29CLE1BQU1wb0QsVUFBVXdaLFFBQVEsQ0FBQzZLLEtBQUsrakMsS0FBS0E7b0JBQ25DQyxNQUFNcm9ELFVBQVV3WixRQUFRLENBQUM2SyxLQUFLZ2tDLEtBQUtBO29CQUNuQyxlQUFlO29CQUNmLElBQUlFLGNBQWMzb0QsS0FBS3lMLEdBQUcsQ0FBQ29PLFFBQVEydUM7b0JBQ25DLHFEQUFxRDtvQkFDckQsSUFBSW5HLGNBQWMsQ0FBQ3JpRCxLQUFLeUwsR0FBRyxDQUFDaVIsU0FBUzhyQyxPQUFPL2tCO29CQUM1QyxJQUFJOGUsY0FBY3ZpRCxLQUFLeUwsR0FBRyxDQUFDaVIsU0FBUytyQyxPQUFPaGxCO29CQUMzQyx3REFBd0Q7b0JBQ3hEaWtCLGVBQWUsQ0FBQyxFQUFFLENBQUMvMkMsSUFBSTtvQkFDdkIrMkMsZUFBZSxDQUFDLEVBQUUsQ0FBQy8yQyxJQUFJO29CQUN2QmczQyxlQUFlLENBQUMsRUFBRSxDQUFDaDNDLElBQUk7b0JBQ3ZCZzNDLGVBQWUsQ0FBQyxFQUFFLENBQUNoM0MsSUFBSTtvQkFDdkIsSUFBSTQwQyxjQUFjbUM7b0JBQ2xCLElBQUlsQyxjQUFjbUM7b0JBQ2xCLElBQUlsQztvQkFDSixxQkFBcUI7b0JBQ3JCQSxLQUFLempELFNBQVMra0IsaUJBQWlCLENBQUN3K0IsYUFBYTZDLGNBQWNwb0QsS0FBSzRxQyxJQUFJLENBQUNsdUIsU0FBUytxQyxTQUFTcEYsYUFBYWlHO29CQUNwRyxJQUFJN0MsS0FBS3JqRCxTQUFTbW5CLGlCQUFpQixFQUFFO3dCQUNqQztvQkFDSjtvQkFDQSw4QkFBOEI7b0JBQzlCazhCLEtBQUt6akQsU0FBUytrQixpQkFBaUIsQ0FBQ3krQixhQUFhRCxhQUFhN29DLFNBQVM2bEMsYUFBYWdHO29CQUNoRixJQUFJOUMsS0FBS3JqRCxTQUFTbW5CLGlCQUFpQixFQUFFO3dCQUNqQztvQkFDSjtvQkFDQSwrQ0FBK0M7b0JBQy9DOVYsU0FBU0ksV0FBVyxDQUFDOUosR0FBRyxDQUFDOEo7b0JBQ3pCSixTQUFTcEksVUFBVSxDQUFDdEIsR0FBRyxDQUFDc1E7b0JBQ3hCLElBQUkzRyxhQUFhO29CQUNqQixJQUFLLElBQUlsVSxJQUFJLEdBQUdBLElBQUk0QyxTQUFTbW5CLGlCQUFpQixFQUFFLEVBQUUvcEIsRUFBRzt3QkFDakQsSUFBSXNhLGFBQWE5WixLQUFLeUwsR0FBRyxDQUFDb08sUUFBUTJyQyxXQUFXLENBQUNobUQsRUFBRSxDQUFDZ00sQ0FBQyxJQUFJbTlDO3dCQUN0RCxJQUFJN3VDLGNBQWMycEIsYUFBYTs0QkFDM0IsSUFBSTF2QixLQUFLTixTQUFTTyxNQUFNLENBQUN4VSxFQUFFOzRCQUMzQixnQkFBZ0I7NEJBQ2hCdVUsR0FBR3BELElBQUk7NEJBQ1BvRCxHQUFHMUksVUFBVSxDQUFDdEIsR0FBRyxDQUFDM0osVUFBVWlQLFFBQVEsQ0FBQ3FWLEtBQUs4Z0MsV0FBVyxDQUFDaG1ELEVBQUUsQ0FBQ2dNLENBQUMsRUFBRWk4Qzs0QkFDNUQxekMsR0FBR2dELEVBQUUsQ0FBQ2hOLEdBQUcsQ0FBQ3k3QyxXQUFXLENBQUNobUQsRUFBRSxDQUFDdVgsRUFBRTs0QkFDM0IsSUFBSW14QyxNQUFNO2dDQUNOLGdCQUFnQjtnQ0FDaEIsSUFBSTFnQyxLQUFLelQsR0FBR2dELEVBQUUsQ0FBQ3lRLEVBQUU7Z0NBQ2pCLGlCQUFpQjtnQ0FDakIsSUFBSTNXLFNBQVMyVyxHQUFHM1csTUFBTTtnQ0FDdEIsSUFBSUUsU0FBU3lXLEdBQUd6VyxNQUFNO2dDQUN0QixJQUFJdVIsUUFBUWtGLEdBQUdsRixLQUFLO2dDQUNwQixJQUFJQyxRQUFRaUYsR0FBR2pGLEtBQUs7Z0NBQ3BCaUYsR0FBRzNXLE1BQU0sR0FBR0U7Z0NBQ1p5VyxHQUFHelcsTUFBTSxHQUFHRjtnQ0FDWjJXLEdBQUdsRixLQUFLLEdBQUdDO2dDQUNYaUYsR0FBR2pGLEtBQUssR0FBR0Q7NEJBQ2Y7NEJBQ0EsRUFBRTVPO3dCQUNOO29CQUNKO29CQUNBRCxTQUFTQyxVQUFVLEdBQUdBO2dCQUMxQjtZQUdBO1lBQUU7Z0JBQUMsY0FBYTtnQkFBRSxlQUFjO2dCQUFFLGVBQWM7Z0JBQUUsaUJBQWdCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU25VLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUMvTCxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR3ErQztnQkFFakIsSUFBSTM2QixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUltRCxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJZ0IsUUFBUWhCLFNBQVE7Z0JBRXBCLElBQUlRLFFBQU9SLFNBQVE7Z0JBRW5CLElBQUlhLFlBQVliLFNBQVE7Z0JBRXhCLElBQUljLE1BQU1kLFNBQVE7Z0JBRWxCLElBQUlTLE9BQU9ULFNBQVE7Z0JBRW5CLElBQUllLE9BQU9mLFNBQVE7Z0JBRW5CcTlDLFVBQVV6UixNQUFNLEdBQUc1cUM7Z0JBRW5CcThDLFVBQVU5MUMsU0FBUyxHQUFHbWIsT0FBTzI2QixVQUFVelIsTUFBTSxDQUFDcmtDLFNBQVM7Z0JBRXZEODFDLFVBQVUxUixJQUFJLEdBQUc7Z0JBRWpCOzs7O0NBSUMsR0FDRCxTQUFTMFIsVUFBVU8sRUFBRSxFQUFFQyxFQUFFO29CQUNyQixJQUFJLENBQUUsQ0FBQSxJQUFJLFlBQVlSLFNBQVEsR0FBSTt3QkFDOUIsT0FBTyxJQUFJQSxVQUFVTyxJQUFJQztvQkFDN0I7b0JBQ0FSLFVBQVV6UixNQUFNLENBQUN2ckMsSUFBSSxDQUFDLElBQUk7b0JBQzFCLElBQUksQ0FBQ3FGLE1BQU0sR0FBRzIzQyxVQUFVMVIsSUFBSTtvQkFDNUIsSUFBSSxDQUFDdDNCLFFBQVEsR0FBR3hSLFNBQVMwbkIsYUFBYTtvQkFDdEMsOEJBQThCO29CQUM5QixJQUFJLENBQUM2ekIsU0FBUyxHQUFHUixLQUFLbjlDLEtBQUt5RixLQUFLLENBQUMwM0MsTUFBTW45QyxLQUFLc0QsSUFBSTtvQkFDaEQsSUFBSSxDQUFDczZDLFNBQVMsR0FBR1IsS0FBS3A5QyxLQUFLeUYsS0FBSyxDQUFDMjNDLE1BQU1wOUMsS0FBS3NELElBQUk7b0JBQ2hELG1FQUFtRTtvQkFDbkUsdUJBQXVCO29CQUN2QixJQUFJLENBQUN1NkMsU0FBUyxHQUFHNzlDLEtBQUtzRCxJQUFJO29CQUMxQixJQUFJLENBQUN5NkMsU0FBUyxHQUFHLzlDLEtBQUtzRCxJQUFJO29CQUMxQixJQUFJLENBQUN3NkMsWUFBWSxHQUFHO29CQUNwQixJQUFJLENBQUNFLFlBQVksR0FBRztnQkFDeEI7Z0JBRUFwQixVQUFVOTFDLFNBQVMsQ0FBQzhoRCxPQUFPLEdBQUcsU0FBUzFFLEVBQUU7b0JBQ3JDLElBQUlBLElBQUk7d0JBQ0osSUFBSSxDQUFDbkcsU0FBUyxDQUFDaDBDLEdBQUcsQ0FBQ202Qzt3QkFDbkIsSUFBSSxDQUFDbEcsWUFBWSxHQUFHO29CQUN4QixPQUFPO3dCQUNILElBQUksQ0FBQ0QsU0FBUyxDQUFDNzFDLE9BQU87d0JBQ3RCLElBQUksQ0FBQzgxQyxZQUFZLEdBQUc7b0JBQ3hCO29CQUNBLE9BQU8sSUFBSTtnQkFDZjtnQkFFQXBCLFVBQVU5MUMsU0FBUyxDQUFDK2hELE9BQU8sR0FBRyxTQUFTNUUsRUFBRTtvQkFDckMsSUFBSUEsSUFBSTt3QkFDSixJQUFJLENBQUNwRyxTQUFTLENBQUM5ekMsR0FBRyxDQUFDazZDO3dCQUNuQixJQUFJLENBQUNuRyxZQUFZLEdBQUc7b0JBQ3hCLE9BQU87d0JBQ0gsSUFBSSxDQUFDRCxTQUFTLENBQUMzMUMsT0FBTzt3QkFDdEIsSUFBSSxDQUFDNDFDLFlBQVksR0FBRztvQkFDeEI7b0JBQ0EsT0FBTyxJQUFJO2dCQUNmO2dCQUVBOztDQUVDLEdBQ0RsQixVQUFVOTFDLFNBQVMsQ0FBQ2dpRCxJQUFJLEdBQUcsU0FBUzNMLEVBQUUsRUFBRUMsRUFBRTtvQkFDdEMsSUFBSSxDQUFDTyxTQUFTLENBQUM1ekMsR0FBRyxDQUFDb3pDO29CQUNuQixJQUFJLENBQUNTLFNBQVMsQ0FBQzd6QyxHQUFHLENBQUNxekM7b0JBQ25CLElBQUksQ0FBQ1UsWUFBWSxHQUFHO29CQUNwQixJQUFJLENBQUNFLFlBQVksR0FBRztvQkFDcEIsT0FBTyxJQUFJO2dCQUNmO2dCQUVBOztDQUVDLEdBQ0RwQixVQUFVOTFDLFNBQVMsQ0FBQ2lrQixNQUFNLEdBQUc7b0JBQ3pCLElBQUl0bEIsUUFBUSxJQUFJbTNDO29CQUNoQm4zQyxNQUFNUixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO29CQUMxQlEsTUFBTW1PLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7b0JBQzlCbk8sTUFBTWs0QyxTQUFTLENBQUM1ekMsR0FBRyxDQUFDLElBQUksQ0FBQzR6QyxTQUFTO29CQUNsQ2w0QyxNQUFNbTRDLFNBQVMsQ0FBQzd6QyxHQUFHLENBQUMsSUFBSSxDQUFDNnpDLFNBQVM7b0JBQ2xDbjRDLE1BQU1vNEMsU0FBUyxDQUFDOXpDLEdBQUcsQ0FBQyxJQUFJLENBQUM4ekMsU0FBUztvQkFDbENwNEMsTUFBTXM0QyxTQUFTLENBQUNoMEMsR0FBRyxDQUFDLElBQUksQ0FBQ2cwQyxTQUFTO29CQUNsQ3Q0QyxNQUFNcTRDLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7b0JBQ3RDcjRDLE1BQU11NEMsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtvQkFDdEMsT0FBT3Y0QztnQkFDWDtnQkFFQW0zQyxVQUFVOTFDLFNBQVMsQ0FBQzZjLGFBQWEsR0FBRztvQkFDaEMsT0FBTztnQkFDWDtnQkFFQWk1QixVQUFVOTFDLFNBQVMsQ0FBQ2lkLFNBQVMsR0FBRyxTQUFTN1osRUFBRSxFQUFFMUUsQ0FBQztvQkFDMUMsT0FBTztnQkFDWDtnQkFFQSxpQkFBaUI7Z0JBQ2pCLGlCQUFpQjtnQkFDakIsMEJBQTBCO2dCQUMxQiwwQkFBMEI7Z0JBQzFCbzNDLFVBQVU5MUMsU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFaGEsRUFBRSxFQUFFZ1osVUFBVTtvQkFDaEUsd0JBQXdCO29CQUN4QixrREFBa0Q7b0JBQ2xELElBQUl3USxLQUFLcnpCLElBQUlnUCxRQUFRLENBQUNuRixHQUFHeEUsQ0FBQyxFQUFFMUYsS0FBS2lMLEdBQUcsQ0FBQ2laLE1BQU13UCxFQUFFLEVBQUV4cEIsR0FBRzFFLENBQUM7b0JBQ25ELElBQUltdUIsS0FBS3R6QixJQUFJZ1AsUUFBUSxDQUFDbkYsR0FBR3hFLENBQUMsRUFBRTFGLEtBQUtpTCxHQUFHLENBQUNpWixNQUFNeVAsRUFBRSxFQUFFenBCLEdBQUcxRSxDQUFDO29CQUNuRCxJQUFJeXdCLElBQUlqMkIsS0FBS2lMLEdBQUcsQ0FBQzBvQixJQUFJRDtvQkFDckIsSUFBSXlwQixLQUFLLElBQUksQ0FBQ1EsU0FBUztvQkFDdkIsSUFBSVAsS0FBSyxJQUFJLENBQUNRLFNBQVM7b0JBQ3ZCLElBQUl0L0MsSUFBSTBCLEtBQUtpTCxHQUFHLENBQUNteUMsSUFBSUQ7b0JBQ3JCLElBQUl0akMsU0FBUzdaLEtBQUtrb0IsR0FBRyxDQUFDNXBCLEVBQUVtaEIsQ0FBQyxFQUFFLENBQUNuaEIsRUFBRWloQixDQUFDO29CQUMvQjFGLE9BQU9LLFNBQVM7b0JBQ2hCLGlCQUFpQjtvQkFDakIsMEJBQTBCO29CQUMxQixnREFBZ0Q7b0JBQ2hELElBQUk2dUMsWUFBWS9vRCxLQUFLeUwsR0FBRyxDQUFDb08sUUFBUTdaLEtBQUtpTCxHQUFHLENBQUNreUMsSUFBSXpwQjtvQkFDOUMsSUFBSXMxQixjQUFjaHBELEtBQUt5TCxHQUFHLENBQUNvTyxRQUFRb2M7b0JBQ25DLElBQUkreUIsZUFBZSxHQUFHO3dCQUNsQixPQUFPO29CQUNYO29CQUNBLElBQUlocUQsSUFBSStwRCxZQUFZQztvQkFDcEIsSUFBSWhxRCxJQUFJLEtBQUtrbEIsTUFBTXVQLFdBQVcsR0FBR3owQixHQUFHO3dCQUNoQyxPQUFPO29CQUNYO29CQUNBLElBQUkwRyxJQUFJMUYsS0FBS2tMLEdBQUcsQ0FBQ3dvQixJQUFJMXpCLEtBQUs4TSxHQUFHLENBQUM5TixHQUFHaTNCO29CQUNqQyxpQkFBaUI7b0JBQ2pCLGlDQUFpQztvQkFDakMsSUFBSS8yQixJQUFJYyxLQUFLaUwsR0FBRyxDQUFDbXlDLElBQUlEO29CQUNyQixJQUFJaUIsS0FBS3ArQyxLQUFLeUwsR0FBRyxDQUFDdk0sR0FBR0E7b0JBQ3JCLElBQUlrL0MsTUFBTSxHQUFHO3dCQUNULE9BQU87b0JBQ1g7b0JBQ0EsSUFBSWovQyxJQUFJYSxLQUFLeUwsR0FBRyxDQUFDekwsS0FBS2lMLEdBQUcsQ0FBQ3ZGLEdBQUd5M0MsS0FBS2orQyxLQUFLay9DO29CQUN2QyxJQUFJai9DLElBQUksS0FBSyxJQUFJQSxHQUFHO3dCQUNoQixPQUFPO29CQUNYO29CQUNBOGtCLE9BQU82UCxRQUFRLEdBQUc5MEI7b0JBQ2xCLElBQUkrcEQsWUFBWSxHQUFHO3dCQUNmOWtDLE9BQU9wSyxNQUFNLEdBQUd4WixJQUFJNE8sT0FBTyxDQUFDL0UsR0FBR3hFLENBQUMsRUFBRW1VLFFBQVFtaEIsR0FBRztvQkFDakQsT0FBTzt3QkFDSC9XLE9BQU9wSyxNQUFNLEdBQUd4WixJQUFJNE8sT0FBTyxDQUFDL0UsR0FBR3hFLENBQUMsRUFBRW1VO29CQUN0QztvQkFDQSxPQUFPO2dCQUNYO2dCQUVBK2lDLFVBQVU5MUMsU0FBUyxDQUFDd2QsV0FBVyxHQUFHLFNBQVNuQixJQUFJLEVBQUVqWixFQUFFLEVBQUVnWixVQUFVO29CQUMzRCxJQUFJaTZCLEtBQUsvOEMsVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDeXpDLFNBQVM7b0JBQzdDLElBQUlQLEtBQUtoOUMsVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDMHpDLFNBQVM7b0JBQzdDejZCLEtBQUsyVCxhQUFhLENBQUNxbUIsSUFBSUM7b0JBQ3ZCajZCLEtBQUs4VCxNQUFNLENBQUMsSUFBSSxDQUFDcmpCLFFBQVE7Z0JBQzdCO2dCQUVBZ3BDLFVBQVU5MUMsU0FBUyxDQUFDcWQsV0FBVyxHQUFHLFNBQVN2WCxRQUFRLEVBQUVpVyxPQUFPO29CQUN4RGpXLFNBQVNMLElBQUksR0FBRztvQkFDaEJLLFNBQVNKLE1BQU0sQ0FBQ2dRLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQ21oQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUNDLFNBQVM7b0JBQ2pFaHhDLFNBQVNILENBQUMsR0FBRztnQkFDakI7Z0JBRUFtd0MsVUFBVTkxQyxTQUFTLENBQUNta0Isb0JBQW9CLEdBQUcsU0FBUzVHLEtBQUs7b0JBQ3JEQSxNQUFNaVgsVUFBVSxDQUFDN08sSUFBSSxDQUFDLElBQUksQ0FBQ2t4QixTQUFTO29CQUNwQ3Q1QixNQUFNaVgsVUFBVSxDQUFDN08sSUFBSSxDQUFDLElBQUksQ0FBQ214QixTQUFTO29CQUNwQ3Y1QixNQUFNcVcsT0FBTyxHQUFHO29CQUNoQnJXLE1BQU16USxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO2dCQUNsQztZQUdBO1lBQUU7Z0JBQUMsZUFBYztnQkFBRSxZQUFXO2dCQUFFLHFCQUFvQjtnQkFBRyxrQkFBaUI7Z0JBQUcsaUJBQWdCO2dCQUFHLHVCQUFzQjtnQkFBRyxrQkFBaUI7Z0JBQUcsa0JBQWlCO2dCQUFHLG1CQUFrQjtZQUFFO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBU3JVLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN6TixJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGhFLFFBQU9ELE9BQU8sR0FBR2crQztnQkFFakIsSUFBSTk1QyxVQUFTbEQsU0FBUTtnQkFFckIsSUFBSTBpQixTQUFTMWlCLFNBQVE7Z0JBRXJCLElBQUltRCxVQUFVbkQsU0FBUTtnQkFFdEIsSUFBSVEsUUFBT1IsU0FBUTtnQkFFbkIsSUFBSWEsWUFBWWIsU0FBUTtnQkFFeEIsSUFBSWMsTUFBTWQsU0FBUTtnQkFFbEIsSUFBSVMsT0FBT1QsU0FBUTtnQkFFbkIsSUFBSWUsT0FBT2YsU0FBUTtnQkFFbkIsSUFBSTZDLFdBQVc3QyxTQUFRO2dCQUV2QixJQUFJZ0IsUUFBUWhCLFNBQVE7Z0JBRXBCZzlDLGFBQWFwUixNQUFNLEdBQUc1cUM7Z0JBRXRCZzhDLGFBQWF6MUMsU0FBUyxHQUFHbWIsT0FBT3M2QixhQUFhcFIsTUFBTSxDQUFDcmtDLFNBQVM7Z0JBRTdEeTFDLGFBQWFyUixJQUFJLEdBQUc7Z0JBRXBCOzs7OztDQUtDLEdBQ0QsU0FBU3FSLGFBQWF0aUIsUUFBUTtvQkFDMUIsSUFBSSxDQUFFLENBQUEsSUFBSSxZQUFZc2lCLFlBQVcsR0FBSTt3QkFDakMsT0FBTyxJQUFJQSxhQUFhdGlCO29CQUM1QjtvQkFDQXNpQixhQUFhcFIsTUFBTSxDQUFDdnJDLElBQUksQ0FBQyxJQUFJO29CQUM3QixJQUFJLENBQUNxRixNQUFNLEdBQUdzM0MsYUFBYXJSLElBQUk7b0JBQy9CLElBQUksQ0FBQ3QzQixRQUFRLEdBQUd4UixTQUFTMG5CLGFBQWE7b0JBQ3RDLElBQUksQ0FBQ2s2QixVQUFVLEdBQUdoa0QsS0FBS3NELElBQUk7b0JBQzNCLElBQUksQ0FBQ2c0QixVQUFVLEdBQUcsRUFBRTtvQkFDcEIsb0NBQW9DO29CQUNwQyxJQUFJLENBQUNta0IsU0FBUyxHQUFHLEVBQUU7b0JBQ25CLG9DQUFvQztvQkFDcEMsSUFBSSxDQUFDL2tCLE9BQU8sR0FBRztvQkFDZixJQUFJVCxZQUFZQSxTQUFTcDZCLE1BQU0sRUFBRTt3QkFDN0IsSUFBSSxDQUFDaXBELElBQUksQ0FBQzd1QjtvQkFDZDtnQkFDSjtnQkFFQXNpQixhQUFhejFDLFNBQVMsQ0FBQ20wQixTQUFTLEdBQUcsU0FBU3JILEtBQUs7b0JBQzdDcnhCLFdBQVdFLFFBQU80QixNQUFNLENBQUMsS0FBS3V2QixTQUFTQSxRQUFRLElBQUksQ0FBQzhHLE9BQU87b0JBQzNELE9BQU8sSUFBSSxDQUFDWSxVQUFVLENBQUMxSCxNQUFNO2dCQUNqQztnQkFFQTs7Q0FFQyxHQUNEMm9CLGFBQWF6MUMsU0FBUyxDQUFDaWtCLE1BQU0sR0FBRztvQkFDNUIsSUFBSXRsQixRQUFRLElBQUk4MkM7b0JBQ2hCOTJDLE1BQU1SLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU07b0JBQzFCUSxNQUFNbU8sUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtvQkFDOUJuTyxNQUFNaTFCLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87b0JBQzVCajFCLE1BQU11K0MsVUFBVSxDQUFDajZDLEdBQUcsQ0FBQyxJQUFJLENBQUNpNkMsVUFBVTtvQkFDcEMsSUFBSyxJQUFJeGtELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNrN0IsT0FBTyxFQUFFbDdCLElBQUs7d0JBQ25DaUcsTUFBTTYxQixVQUFVLENBQUM3TyxJQUFJLENBQUMsSUFBSSxDQUFDNk8sVUFBVSxDQUFDOTdCLEVBQUUsQ0FBQ2lHLEtBQUs7b0JBQ2xEO29CQUNBLElBQUssSUFBSWpHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNpZ0QsU0FBUyxDQUFDNS9DLE1BQU0sRUFBRUwsSUFBSzt3QkFDNUNpRyxNQUFNZzZDLFNBQVMsQ0FBQ2h6QixJQUFJLENBQUMsSUFBSSxDQUFDZ3pCLFNBQVMsQ0FBQ2pnRCxFQUFFLENBQUNpRyxLQUFLO29CQUNoRDtvQkFDQSxPQUFPQTtnQkFDWDtnQkFFQTgyQyxhQUFhejFDLFNBQVMsQ0FBQzZjLGFBQWEsR0FBRztvQkFDbkMsT0FBTztnQkFDWDtnQkFFQSxTQUFTc2xDLGdCQUFnQkMsRUFBRSxFQUFFejRCLEtBQUs7b0JBQzlCbHVCLFdBQVdFLFFBQU80QixNQUFNLENBQUNvc0IsU0FBUztvQkFDbEMsSUFBSXBtQixJQUFJckssS0FBS3NELElBQUk7b0JBQ2pCLElBQUkrN0IsT0FBTztvQkFDWCxxREFBcUQ7b0JBQ3JELHVFQUF1RTtvQkFDdkUsSUFBSThwQixPQUFPbnBELEtBQUtzRCxJQUFJO29CQUNwQixJQUFJLE9BQU87d0JBQ1AsOERBQThEO3dCQUM5RCxJQUFLLElBQUk5RCxJQUFJLEdBQUdBLElBQUlpeEIsT0FBTyxFQUFFanhCLEVBQUc7NEJBQzVCMnBELEtBQUtqK0MsR0FBRyxDQUFDZytDLEVBQUUsQ0FBQzFwRCxFQUFFO3dCQUNsQjt3QkFDQTJwRCxLQUFLcjhDLEdBQUcsQ0FBQyxJQUFJMmpCO29CQUNqQjtvQkFDQSxJQUFJMjRCLE9BQU8sSUFBSTtvQkFDZixJQUFLLElBQUk1cEQsSUFBSSxHQUFHQSxJQUFJaXhCLE9BQU8sRUFBRWp4QixFQUFHO3dCQUM1QixxQkFBcUI7d0JBQ3JCLElBQUlrMEIsS0FBS3kxQjt3QkFDVCxJQUFJeDFCLEtBQUt1MUIsRUFBRSxDQUFDMXBELEVBQUU7d0JBQ2QsSUFBSTZwRCxLQUFLN3BELElBQUksSUFBSWl4QixRQUFReTRCLEVBQUUsQ0FBQzFwRCxJQUFJLEVBQUUsR0FBRzBwRCxFQUFFLENBQUMsRUFBRTt3QkFDMUMsSUFBSWpJLEtBQUtqaEQsS0FBS2lMLEdBQUcsQ0FBQzBvQixJQUFJRDt3QkFDdEIsSUFBSTB0QixLQUFLcGhELEtBQUtpTCxHQUFHLENBQUNvK0MsSUFBSTMxQjt3QkFDdEIsSUFBSTZNLElBQUl2Z0MsS0FBS21MLEtBQUssQ0FBQzgxQyxJQUFJRzt3QkFDdkIsSUFBSWtJLGVBQWUsS0FBSy9vQjt3QkFDeEJsQixRQUFRaXFCO3dCQUNSLHlCQUF5Qjt3QkFDekJqL0MsRUFBRXdDLE1BQU0sQ0FBQ3k4QyxlQUFlRixNQUFNMTFCO3dCQUM5QnJwQixFQUFFd0MsTUFBTSxDQUFDeThDLGVBQWVGLE1BQU16MUI7d0JBQzlCdHBCLEVBQUV3QyxNQUFNLENBQUN5OEMsZUFBZUYsTUFBTUM7b0JBQ2xDO29CQUNBLFdBQVc7b0JBQ1g5bUQsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQ2c3QixPQUFPdC9CLE1BQUtzb0IsT0FBTztvQkFDNUNoZSxFQUFFeUMsR0FBRyxDQUFDLElBQUl1eUI7b0JBQ1YsT0FBT2gxQjtnQkFDWDtnQkFFQTs7Ozs7Ozs7O0NBU0MsR0FDRGt5QyxhQUFhejFDLFNBQVMsQ0FBQ2dpRCxJQUFJLEdBQUcsU0FBUzd1QixRQUFRO29CQUMzQzEzQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLEtBQUs0MUIsU0FBU3A2QixNQUFNLElBQUlvNkIsU0FBU3A2QixNQUFNLElBQUl1QyxTQUFTb25CLGtCQUFrQjtvQkFDL0YsSUFBSXlRLFNBQVNwNkIsTUFBTSxHQUFHLEdBQUc7d0JBQ3JCLElBQUksQ0FBQzY4QyxTQUFTLENBQUMsR0FBRzt3QkFDbEI7b0JBQ0o7b0JBQ0EsSUFBSXo5QyxJQUFJYyxNQUFLeWEsR0FBRyxDQUFDeWYsU0FBU3A2QixNQUFNLEVBQUV1QyxTQUFTb25CLGtCQUFrQjtvQkFDN0QsdURBQXVEO29CQUN2RCxJQUFJKy9CLEtBQUssRUFBRTtvQkFDWCxpQ0FBaUM7b0JBQ2pDLElBQUlDLFlBQVk7b0JBQ2hCLElBQUssSUFBSWhxRCxJQUFJLEdBQUdBLElBQUlQLEdBQUcsRUFBRU8sRUFBRzt3QkFDeEIsSUFBSWdNLElBQUl5dUIsUUFBUSxDQUFDejZCLEVBQUU7d0JBQ25CLElBQUlpcUQsU0FBUzt3QkFDYixJQUFLLElBQUkzMUMsSUFBSSxHQUFHQSxJQUFJMDFDLFdBQVcsRUFBRTExQyxFQUFHOzRCQUNoQyxJQUFJOVQsS0FBS3dxQyxlQUFlLENBQUNoL0IsR0FBRys5QyxFQUFFLENBQUN6MUMsRUFBRSxJQUFJLE1BQU0xUixTQUFTdW5CLGlCQUFpQixFQUFFO2dDQUNuRTgvQixTQUFTO2dDQUNUOzRCQUNKO3dCQUNKO3dCQUNBLElBQUlBLFFBQVE7NEJBQ1JGLEVBQUUsQ0FBQ0MsWUFBWSxHQUFHaCtDO3dCQUN0QjtvQkFDSjtvQkFDQXZNLElBQUl1cUQ7b0JBQ0osSUFBSXZxRCxJQUFJLEdBQUc7d0JBQ1AseUJBQXlCO3dCQUN6QnNELFdBQVdFLFFBQU80QixNQUFNLENBQUM7d0JBQ3pCLElBQUksQ0FBQ3E0QyxTQUFTLENBQUMsR0FBRzt3QkFDbEI7b0JBQ0o7b0JBQ0EsMkRBQTJEO29CQUMzRCx1REFBdUQ7b0JBQ3ZELHdDQUF3QztvQkFDeEMsSUFBSWdOLEtBQUs7b0JBQ1QsSUFBSUMsS0FBS0osRUFBRSxDQUFDLEVBQUUsQ0FBQ2hxQyxDQUFDO29CQUNoQixJQUFLLElBQUkvZixJQUFJLEdBQUdBLElBQUlQLEdBQUcsRUFBRU8sRUFBRzt3QkFDeEIsSUFBSStmLElBQUlncUMsRUFBRSxDQUFDL3BELEVBQUUsQ0FBQytmLENBQUM7d0JBQ2YsSUFBSUEsSUFBSW9xQyxNQUFNcHFDLEtBQUtvcUMsTUFBTUosRUFBRSxDQUFDL3BELEVBQUUsQ0FBQ2lnQixDQUFDLEdBQUc4cEMsRUFBRSxDQUFDRyxHQUFHLENBQUNqcUMsQ0FBQyxFQUFFOzRCQUN6Q2lxQyxLQUFLbHFEOzRCQUNMbXFELEtBQUtwcUM7d0JBQ1Q7b0JBQ0o7b0JBQ0EsSUFBSXFxQyxPQUFPLEVBQUU7b0JBQ2IsaUNBQWlDO29CQUNqQyxJQUFJaGhCLElBQUk7b0JBQ1IsSUFBSWloQixLQUFLSDtvQkFDVCxPQUFTO3dCQUNMRSxJQUFJLENBQUNoaEIsRUFBRSxHQUFHaWhCO3dCQUNWLElBQUl2RSxLQUFLO3dCQUNULElBQUssSUFBSXh4QyxJQUFJLEdBQUdBLElBQUk3VSxHQUFHLEVBQUU2VSxFQUFHOzRCQUN4QixJQUFJd3hDLE1BQU11RSxJQUFJO2dDQUNWdkUsS0FBS3h4QztnQ0FDTDs0QkFDSjs0QkFDQSxJQUFJNVUsSUFBSWMsS0FBS2lMLEdBQUcsQ0FBQ3MrQyxFQUFFLENBQUNqRSxHQUFHLEVBQUVpRSxFQUFFLENBQUNLLElBQUksQ0FBQ2hoQixFQUFFLENBQUM7NEJBQ3BDLElBQUlwOUIsSUFBSXhMLEtBQUtpTCxHQUFHLENBQUNzK0MsRUFBRSxDQUFDejFDLEVBQUUsRUFBRXkxQyxFQUFFLENBQUNLLElBQUksQ0FBQ2hoQixFQUFFLENBQUM7NEJBQ25DLElBQUl2K0IsSUFBSXJLLEtBQUttTCxLQUFLLENBQUNqTSxHQUFHc007NEJBQ3RCLElBQUluQixJQUFJLEdBQUc7Z0NBQ1BpN0MsS0FBS3h4Qzs0QkFDVDs0QkFDQSxxQkFBcUI7NEJBQ3JCLElBQUl6SixLQUFLLEtBQUttQixFQUFFNGMsYUFBYSxLQUFLbHBCLEVBQUVrcEIsYUFBYSxJQUFJO2dDQUNqRGs5QixLQUFLeHhDOzRCQUNUO3dCQUNKO3dCQUNBLEVBQUU4MEI7d0JBQ0ZpaEIsS0FBS3ZFO3dCQUNMLElBQUlBLE1BQU1vRSxJQUFJOzRCQUNWO3dCQUNKO29CQUNKO29CQUNBLElBQUk5Z0IsSUFBSSxHQUFHO3dCQUNQLHlCQUF5Qjt3QkFDekJybUMsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQzt3QkFDekIsSUFBSSxDQUFDcTRDLFNBQVMsQ0FBQyxHQUFHO3dCQUNsQjtvQkFDSjtvQkFDQSxJQUFJLENBQUNoaUIsT0FBTyxHQUFHa087b0JBQ2YsaUJBQWlCO29CQUNqQixJQUFLLElBQUlwcEMsSUFBSSxHQUFHQSxJQUFJb3BDLEdBQUcsRUFBRXBwQyxFQUFHO3dCQUN4QixJQUFJLENBQUM4N0IsVUFBVSxDQUFDOTdCLEVBQUUsR0FBRytwRCxFQUFFLENBQUNLLElBQUksQ0FBQ3BxRCxFQUFFLENBQUM7b0JBQ3BDO29CQUNBLDBEQUEwRDtvQkFDMUQsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUlvcEMsR0FBRyxFQUFFcHBDLEVBQUc7d0JBQ3hCLElBQUkwaUQsS0FBSzFpRDt3QkFDVCxJQUFJMmlELEtBQUszaUQsSUFBSSxJQUFJb3BDLElBQUlwcEMsSUFBSSxJQUFJO3dCQUM3QixJQUFJbVAsT0FBTzNPLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDcXdCLFVBQVUsQ0FBQzZtQixHQUFHLEVBQUUsSUFBSSxDQUFDN21CLFVBQVUsQ0FBQzRtQixHQUFHO3dCQUM1RDMvQyxXQUFXRSxRQUFPNEIsTUFBTSxDQUFDc0ssS0FBS3laLGFBQWEsS0FBS3JvQixNQUFLc29CLE9BQU8sR0FBR3RvQixNQUFLc29CLE9BQU87d0JBQzNFLElBQUksQ0FBQ28zQixTQUFTLENBQUNqZ0QsRUFBRSxHQUFHUSxLQUFLbUwsS0FBSyxDQUFDd0QsTUFBTTt3QkFDckMsSUFBSSxDQUFDOHdDLFNBQVMsQ0FBQ2pnRCxFQUFFLENBQUMwYSxTQUFTO29CQUMvQjtvQkFDQSxnQ0FBZ0M7b0JBQ2hDLElBQUksQ0FBQzhwQyxVQUFVLEdBQUdpRixnQkFBZ0IsSUFBSSxDQUFDM3RCLFVBQVUsRUFBRXNOO2dCQUN2RDtnQkFFQTs7Q0FFQyxHQUNEMlQsYUFBYXoxQyxTQUFTLENBQUM0MUMsU0FBUyxHQUFHLFNBQVNGLEVBQUUsRUFBRUMsRUFBRSxFQUFFandDLE1BQU0sRUFBRWpKLEtBQUs7b0JBQzdELElBQUksQ0FBQyszQixVQUFVLENBQUMsRUFBRSxHQUFHdDdCLEtBQUtrb0IsR0FBRyxDQUFDLENBQUNzMEIsSUFBSSxDQUFDQztvQkFDcEMsSUFBSSxDQUFDbmhCLFVBQVUsQ0FBQyxFQUFFLEdBQUd0N0IsS0FBS2tvQixHQUFHLENBQUNzMEIsSUFBSSxDQUFDQztvQkFDbkMsSUFBSSxDQUFDbmhCLFVBQVUsQ0FBQyxFQUFFLEdBQUd0N0IsS0FBS2tvQixHQUFHLENBQUNzMEIsSUFBSUM7b0JBQ2xDLElBQUksQ0FBQ25oQixVQUFVLENBQUMsRUFBRSxHQUFHdDdCLEtBQUtrb0IsR0FBRyxDQUFDLENBQUNzMEIsSUFBSUM7b0JBQ25DLElBQUksQ0FBQ2dELFNBQVMsQ0FBQyxFQUFFLEdBQUd6L0MsS0FBS2tvQixHQUFHLENBQUMsR0FBRyxDQUFDO29CQUNqQyxJQUFJLENBQUN1M0IsU0FBUyxDQUFDLEVBQUUsR0FBR3ovQyxLQUFLa29CLEdBQUcsQ0FBQyxHQUFHO29CQUNoQyxJQUFJLENBQUN1M0IsU0FBUyxDQUFDLEVBQUUsR0FBR3ovQyxLQUFLa29CLEdBQUcsQ0FBQyxHQUFHO29CQUNoQyxJQUFJLENBQUN1M0IsU0FBUyxDQUFDLEVBQUUsR0FBR3ovQyxLQUFLa29CLEdBQUcsQ0FBQyxDQUFDLEdBQUc7b0JBQ2pDLElBQUksQ0FBQ3dTLE9BQU8sR0FBRztvQkFDZixJQUFJMTZCLEtBQUtzRSxPQUFPLENBQUNrSSxTQUFTO3dCQUN0QmpKLFFBQVFBLFNBQVM7d0JBQ2pCLElBQUksQ0FBQ3lnRCxVQUFVLENBQUNqNkMsR0FBRyxDQUFDeUM7d0JBQ3BCLElBQUl0QyxLQUFLOUosVUFBVW1GLFFBQVE7d0JBQzNCMkUsR0FBRzFFLENBQUMsQ0FBQ3VFLEdBQUcsQ0FBQ3lDO3dCQUNUdEMsR0FBR3hFLENBQUMsQ0FBQ3FFLEdBQUcsQ0FBQ3hHO3dCQUNULGtDQUFrQzt3QkFDbEMsSUFBSyxJQUFJL0QsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2s3QixPQUFPLEVBQUUsRUFBRWw3QixFQUFHOzRCQUNuQyxJQUFJLENBQUM4N0IsVUFBVSxDQUFDOTdCLEVBQUUsR0FBR1ksVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDb3hCLFVBQVUsQ0FBQzk3QixFQUFFOzRCQUM3RCxJQUFJLENBQUNpZ0QsU0FBUyxDQUFDamdELEVBQUUsR0FBR2EsSUFBSTRPLE9BQU8sQ0FBQy9FLEdBQUd4RSxDQUFDLEVBQUUsSUFBSSxDQUFDKzVDLFNBQVMsQ0FBQ2pnRCxFQUFFO3dCQUMzRDtvQkFDSjtnQkFDSjtnQkFFQSs4QyxhQUFhejFDLFNBQVMsQ0FBQ2lkLFNBQVMsR0FBRyxTQUFTN1osRUFBRSxFQUFFMUUsQ0FBQztvQkFDN0MsSUFBSXNrRCxTQUFTenBELElBQUlnUCxRQUFRLENBQUNuRixHQUFHeEUsQ0FBQyxFQUFFMUYsS0FBS2lMLEdBQUcsQ0FBQ3pGLEdBQUcwRSxHQUFHMUUsQ0FBQztvQkFDaEQsSUFBSyxJQUFJaEcsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2s3QixPQUFPLEVBQUUsRUFBRWw3QixFQUFHO3dCQUNuQyxJQUFJaU0sTUFBTXpMLEtBQUt5TCxHQUFHLENBQUMsSUFBSSxDQUFDZzBDLFNBQVMsQ0FBQ2pnRCxFQUFFLEVBQUVRLEtBQUtpTCxHQUFHLENBQUM2K0MsUUFBUSxJQUFJLENBQUN4dUIsVUFBVSxDQUFDOTdCLEVBQUU7d0JBQ3pFLElBQUlpTSxNQUFNLEdBQUc7NEJBQ1QsT0FBTzt3QkFDWDtvQkFDSjtvQkFDQSxPQUFPO2dCQUNYO2dCQUVBOHdDLGFBQWF6MUMsU0FBUyxDQUFDa2QsT0FBTyxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFaGEsRUFBRSxFQUFFZ1osVUFBVTtvQkFDbkUscURBQXFEO29CQUNyRCxJQUFJd1EsS0FBS3J6QixJQUFJZ1AsUUFBUSxDQUFDbkYsR0FBR3hFLENBQUMsRUFBRTFGLEtBQUtpTCxHQUFHLENBQUNpWixNQUFNd1AsRUFBRSxFQUFFeHBCLEdBQUcxRSxDQUFDO29CQUNuRCxJQUFJbXVCLEtBQUt0ekIsSUFBSWdQLFFBQVEsQ0FBQ25GLEdBQUd4RSxDQUFDLEVBQUUxRixLQUFLaUwsR0FBRyxDQUFDaVosTUFBTXlQLEVBQUUsRUFBRXpwQixHQUFHMUUsQ0FBQztvQkFDbkQsSUFBSXl3QixJQUFJajJCLEtBQUtpTCxHQUFHLENBQUMwb0IsSUFBSUQ7b0JBQ3JCLElBQUltQyxRQUFRO29CQUNaLElBQUlDLFFBQVE1UixNQUFNdVAsV0FBVztvQkFDN0IsSUFBSUcsUUFBUSxDQUFDO29CQUNiLElBQUssSUFBSXAwQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDazdCLE9BQU8sRUFBRSxFQUFFbDdCLEVBQUc7d0JBQ25DLGlCQUFpQjt3QkFDakIseUJBQXlCO3dCQUN6QiwrQ0FBK0M7d0JBQy9DLElBQUl1cEQsWUFBWS9vRCxLQUFLeUwsR0FBRyxDQUFDLElBQUksQ0FBQ2cwQyxTQUFTLENBQUNqZ0QsRUFBRSxFQUFFUSxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3F3QixVQUFVLENBQUM5N0IsRUFBRSxFQUFFazBCO3dCQUN6RSxJQUFJczFCLGNBQWNocEQsS0FBS3lMLEdBQUcsQ0FBQyxJQUFJLENBQUNnMEMsU0FBUyxDQUFDamdELEVBQUUsRUFBRXkyQjt3QkFDOUMsSUFBSSt5QixlQUFlLEdBQUc7NEJBQ2xCLElBQUlELFlBQVksR0FBRztnQ0FDZixPQUFPOzRCQUNYO3dCQUNKLE9BQU87NEJBQ0gsaURBQWlEOzRCQUNqRCx5REFBeUQ7NEJBQ3pELHlEQUF5RDs0QkFDekQsd0VBQXdFOzRCQUN4RSxJQUFJQyxjQUFjLEtBQUtELFlBQVlsekIsUUFBUW16QixhQUFhO2dDQUNwRCxrQkFBa0I7Z0NBQ2xCLHNDQUFzQztnQ0FDdENuekIsUUFBUWt6QixZQUFZQztnQ0FDcEJwMUIsUUFBUXAwQjs0QkFDWixPQUFPLElBQUl3cEQsY0FBYyxLQUFLRCxZQUFZanpCLFFBQVFrekIsYUFBYTtnQ0FDM0Qsa0JBQWtCO2dDQUNsQixxQ0FBcUM7Z0NBQ3JDbHpCLFFBQVFpekIsWUFBWUM7NEJBQ3hCO3dCQUNKO3dCQUNBLDZEQUE2RDt3QkFDN0QsZ0VBQWdFO3dCQUNoRSxxREFBcUQ7d0JBQ3JELG9DQUFvQzt3QkFDcEMsSUFBSWx6QixRQUFRRCxPQUFPOzRCQUNmLE9BQU87d0JBQ1g7b0JBQ0o7b0JBQ0F0ekIsV0FBV0UsUUFBTzRCLE1BQU0sQ0FBQyxLQUFLd3hCLFNBQVNBLFNBQVMzUixNQUFNdVAsV0FBVztvQkFDakUsSUFBSUcsU0FBUyxHQUFHO3dCQUNaM1AsT0FBTzZQLFFBQVEsR0FBRytCO3dCQUNsQjVSLE9BQU9wSyxNQUFNLEdBQUd4WixJQUFJNE8sT0FBTyxDQUFDL0UsR0FBR3hFLENBQUMsRUFBRSxJQUFJLENBQUMrNUMsU0FBUyxDQUFDN3JCLE1BQU07d0JBQ3ZELE9BQU87b0JBQ1g7b0JBQ0EsT0FBTztnQkFDWDtnQkFFQTJvQixhQUFhejFDLFNBQVMsQ0FBQ3dkLFdBQVcsR0FBRyxTQUFTbkIsSUFBSSxFQUFFalosRUFBRSxFQUFFZ1osVUFBVTtvQkFDOUQsSUFBSTZtQyxPQUFPNTdCLFVBQVU2N0IsT0FBTzc3QjtvQkFDNUIsSUFBSTg3QixPQUFPLENBQUM5N0IsVUFBVSs3QixPQUFPLENBQUMvN0I7b0JBQzlCLElBQUssSUFBSTN1QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDazdCLE9BQU8sRUFBRSxFQUFFbDdCLEVBQUc7d0JBQ25DLElBQUlnTSxJQUFJcEwsVUFBVTZPLE9BQU8sQ0FBQy9FLElBQUksSUFBSSxDQUFDb3hCLFVBQVUsQ0FBQzk3QixFQUFFO3dCQUNoRHVxRCxPQUFPaHFELE1BQUt5YSxHQUFHLENBQUN1dkMsTUFBTXYrQyxFQUFFK1QsQ0FBQzt3QkFDekIwcUMsT0FBT2xxRCxNQUFLc2dCLEdBQUcsQ0FBQzRwQyxNQUFNeitDLEVBQUUrVCxDQUFDO3dCQUN6QnlxQyxPQUFPanFELE1BQUt5YSxHQUFHLENBQUN3dkMsTUFBTXgrQyxFQUFFaVUsQ0FBQzt3QkFDekJ5cUMsT0FBT25xRCxNQUFLc2dCLEdBQUcsQ0FBQzZwQyxNQUFNMStDLEVBQUVpVSxDQUFDO29CQUM3QjtvQkFDQTBELEtBQUs0UyxVQUFVLENBQUNoc0IsR0FBRyxDQUFDZ2dELE1BQU1DO29CQUMxQjdtQyxLQUFLNlMsVUFBVSxDQUFDanNCLEdBQUcsQ0FBQ2tnRCxNQUFNQztvQkFDMUIvbUMsS0FBSzhULE1BQU0sQ0FBQyxJQUFJLENBQUNyakIsUUFBUTtnQkFDN0I7Z0JBRUEyb0MsYUFBYXoxQyxTQUFTLENBQUNxZCxXQUFXLEdBQUcsU0FBU3ZYLFFBQVEsRUFBRWlXLE9BQU87b0JBQzNELHVDQUF1QztvQkFDdkMsd0RBQXdEO29CQUN4RCxRQUFRO29CQUNSLHVCQUF1QjtvQkFDdkIsNENBQTRDO29CQUM1Qyw0Q0FBNEM7b0JBQzVDLGtDQUFrQztvQkFDbEMsRUFBRTtvQkFDRiw4REFBOEQ7b0JBQzlELDZEQUE2RDtvQkFDN0QsMERBQTBEO29CQUMxRCx5Q0FBeUM7b0JBQ3pDLDZCQUE2QjtvQkFDN0IsNkJBQTZCO29CQUM3Qix3Q0FBd0M7b0JBQ3hDLEVBQUU7b0JBQ0YscURBQXFEO29CQUNyRCwwREFBMEQ7b0JBQzFELG9CQUFvQjtvQkFDcEIsRUFBRTtvQkFDRiw2REFBNkQ7b0JBQzdELEVBQUU7b0JBQ0YsNkRBQTZEO29CQUM3RHRnQixXQUFXRSxRQUFPNEIsTUFBTSxDQUFDLElBQUksQ0FBQ3EyQixPQUFPLElBQUk7b0JBQ3pDLElBQUlsdUIsU0FBU3hNLEtBQUtzRCxJQUFJO29CQUN0QixJQUFJKzdCLE9BQU87b0JBQ1gsSUFBSTV5QixJQUFJO29CQUNSLGtEQUFrRDtvQkFDbEQsdUVBQXVFO29CQUN2RSxJQUFJdE4sSUFBSWEsS0FBS3NELElBQUk7b0JBQ2pCLDhEQUE4RDtvQkFDOUQsSUFBSyxJQUFJOUQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2s3QixPQUFPLEVBQUUsRUFBRWw3QixFQUFHO3dCQUNuQ0wsRUFBRStMLEdBQUcsQ0FBQyxJQUFJLENBQUNvd0IsVUFBVSxDQUFDOTdCLEVBQUU7b0JBQzVCO29CQUNBTCxFQUFFMk4sR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDNHRCLE9BQU87b0JBQ3RCLElBQUl5dkIsU0FBUyxJQUFJO29CQUNqQixJQUFLLElBQUkzcUQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2s3QixPQUFPLEVBQUUsRUFBRWw3QixFQUFHO3dCQUNuQyxxQkFBcUI7d0JBQ3JCLElBQUl5aEQsS0FBS2poRCxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3F3QixVQUFVLENBQUM5N0IsRUFBRSxFQUFFTDt3QkFDdEMsSUFBSWlpRCxLQUFLNWhELElBQUksSUFBSSxJQUFJLENBQUNrN0IsT0FBTyxHQUFHMTZCLEtBQUtpTCxHQUFHLENBQUMsSUFBSSxDQUFDcXdCLFVBQVUsQ0FBQzk3QixJQUFJLEVBQUUsRUFBRUwsS0FBS2EsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUNxd0IsVUFBVSxDQUFDLEVBQUUsRUFBRW44Qjt3QkFDbkcsSUFBSW9oQyxJQUFJdmdDLEtBQUttTCxLQUFLLENBQUM4MUMsSUFBSUc7d0JBQ3ZCLElBQUlrSSxlQUFlLEtBQUsvb0I7d0JBQ3hCbEIsUUFBUWlxQjt3QkFDUix5QkFBeUI7d0JBQ3pCOThDLE9BQU8wOUIsVUFBVSxDQUFDb2YsZUFBZWEsUUFBUWxKLElBQUlxSSxlQUFlYSxRQUFRL0k7d0JBQ3BFLElBQUlnSixNQUFNbkosR0FBRzFoQyxDQUFDO3dCQUNkLElBQUk4cUMsTUFBTXBKLEdBQUd4aEMsQ0FBQzt3QkFDZCxJQUFJNnFDLE1BQU1sSixHQUFHN2hDLENBQUM7d0JBQ2QsSUFBSWdyQyxNQUFNbkosR0FBRzNoQyxDQUFDO3dCQUNkLElBQUkrcUMsUUFBUUosTUFBTUEsTUFBTUUsTUFBTUYsTUFBTUUsTUFBTUE7d0JBQzFDLElBQUlHLFFBQVFKLE1BQU1BLE1BQU1FLE1BQU1GLE1BQU1FLE1BQU1BO3dCQUMxQzk5QyxLQUFLLE1BQU0wOUMsU0FBUzVwQixJQUFLaXFCLENBQUFBLFFBQVFDLEtBQUk7b0JBQ3pDO29CQUNBLGFBQWE7b0JBQ2I3OUMsU0FBU0wsSUFBSSxHQUFHc1csVUFBVXdjO29CQUMxQixpQkFBaUI7b0JBQ2pCOThCLFdBQVdFLFFBQU80QixNQUFNLENBQUNnN0IsT0FBT3QvQixNQUFLc29CLE9BQU87b0JBQzVDN2IsT0FBT00sR0FBRyxDQUFDLElBQUl1eUI7b0JBQ2Z6eUIsU0FBU0osTUFBTSxDQUFDZ1EsVUFBVSxDQUFDLEdBQUdoUSxRQUFRLEdBQUdyTjtvQkFDekMseURBQXlEO29CQUN6RHlOLFNBQVNILENBQUMsR0FBR29XLFVBQVVwVztvQkFDdkIsd0RBQXdEO29CQUN4REcsU0FBU0gsQ0FBQyxJQUFJRyxTQUFTTCxJQUFJLEdBQUl2TSxDQUFBQSxLQUFLeUwsR0FBRyxDQUFDbUIsU0FBU0osTUFBTSxFQUFFSSxTQUFTSixNQUFNLElBQUl4TSxLQUFLeUwsR0FBRyxDQUFDZSxRQUFRQSxPQUFNO2dCQUN2RztnQkFFQSwrREFBK0Q7Z0JBQy9ELHlCQUF5QjtnQkFDekIrdkMsYUFBYXoxQyxTQUFTLENBQUN1NkIsUUFBUSxHQUFHO29CQUM5QixJQUFLLElBQUk3aEMsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2s3QixPQUFPLEVBQUUsRUFBRWw3QixFQUFHO3dCQUNuQyxJQUFJMGlELEtBQUsxaUQ7d0JBQ1QsSUFBSTJpRCxLQUFLM2lELElBQUksSUFBSSxDQUFDazdCLE9BQU8sR0FBRyxJQUFJd25CLEtBQUssSUFBSTt3QkFDekMsSUFBSTE4QyxJQUFJLElBQUksQ0FBQzgxQixVQUFVLENBQUM0bUIsR0FBRzt3QkFDM0IsSUFBSTVqRCxJQUFJMEIsS0FBS2lMLEdBQUcsQ0FBQyxJQUFJLENBQUNxd0IsVUFBVSxDQUFDNm1CLEdBQUcsRUFBRTM4Qzt3QkFDdEMsSUFBSyxJQUFJc08sSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzRtQixPQUFPLEVBQUUsRUFBRTVtQixFQUFHOzRCQUNuQyxJQUFJQSxLQUFLb3VDLE1BQU1wdUMsS0FBS3F1QyxJQUFJO2dDQUNwQjs0QkFDSjs0QkFDQSxJQUFJMzJDLElBQUl4TCxLQUFLaUwsR0FBRyxDQUFDLElBQUksQ0FBQ3F3QixVQUFVLENBQUN4bkIsRUFBRSxFQUFFdE87NEJBQ3JDLElBQUk2RSxJQUFJckssS0FBS21MLEtBQUssQ0FBQzdNLEdBQUdrTjs0QkFDdEIsSUFBSW5CLElBQUksR0FBRztnQ0FDUCxPQUFPOzRCQUNYO3dCQUNKO29CQUNKO29CQUNBLE9BQU87Z0JBQ1g7Z0JBRUFreUMsYUFBYXoxQyxTQUFTLENBQUNta0Isb0JBQW9CLEdBQUcsU0FBUzVHLEtBQUs7b0JBQ3hEQSxNQUFNaVgsVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVTtvQkFDbENqWCxNQUFNcVcsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTztvQkFDNUJyVyxNQUFNelEsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtnQkFDbEM7WUFHQTtZQUFFO2dCQUFDLGVBQWM7Z0JBQUUsWUFBVztnQkFBRSxxQkFBb0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGlCQUFnQjtnQkFBRyx1QkFBc0I7Z0JBQUcsa0JBQWlCO2dCQUFHLGtCQUFpQjtnQkFBRyxrQkFBaUI7Z0JBQUcsbUJBQWtCO1lBQUU7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTclUsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQzdPLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxHQUFHa1I7Z0JBRWpCLFNBQVNBLEtBQUtpN0MsSUFBSTtvQkFDZCxJQUFJQyxTQUFTLEVBQUU7b0JBQ2YsSUFBSUMsT0FBT0YsS0FBS3JxQyxHQUFHLElBQUk4TjtvQkFDdkIsSUFBSTA4QixZQUFZSCxLQUFLem9DLE1BQU0sSUFBSTt3QkFDM0IsT0FBTyxDQUFDO29CQUNaO29CQUNBLElBQUk2b0MsU0FBU0osS0FBS2xvQyxRQUFRLElBQUksWUFBWTtvQkFDMUMsSUFBSXVvQyxRQUFRTCxLQUFLL25DLE9BQU8sSUFBSSxZQUFZO29CQUN4QyxJQUFJcW9DLGFBQWFOLEtBQUtPLE9BQU8sSUFBSSxZQUFZO29CQUM3QyxJQUFJQyxlQUFlO29CQUNuQixJQUFJQyxZQUFZO29CQUNoQixJQUFJQyxXQUFXO29CQUNmLElBQUlDLGdCQUFnQjtvQkFDcEIsSUFBSSxDQUFDaHJDLEdBQUcsR0FBRyxTQUFTcGhCLENBQUM7d0JBQ2pCLElBQUksT0FBT0EsTUFBTSxVQUFVOzRCQUN2QjJyRCxPQUFPM3JEOzRCQUNQLE9BQU8sSUFBSTt3QkFDZjt3QkFDQSxPQUFPMnJEO29CQUNYO29CQUNBLElBQUksQ0FBQ1UsSUFBSSxHQUFHO3dCQUNSLE9BQU9YLE9BQU85cUQsTUFBTTtvQkFDeEI7b0JBQ0EsSUFBSSxDQUFDMmlCLFFBQVEsR0FBRzt3QkFDWixJQUFJNmxCO3dCQUNKLElBQUlzaUIsT0FBTzlxRCxNQUFNLEdBQUcsR0FBRzs0QkFDbkJ3b0MsTUFBTXNpQixPQUFPWSxLQUFLO3dCQUN0QixPQUFPOzRCQUNITDs0QkFDQTdpQixNQUFNd2lCO3dCQUNWO3dCQUNBTTt3QkFDQUwsT0FBT3ppQjt3QkFDUCxPQUFPQTtvQkFDWDtvQkFDQSxJQUFJLENBQUMxbEIsT0FBTyxHQUFHLFNBQVMwbEIsR0FBRzt3QkFDdkIsSUFBSXNpQixPQUFPOXFELE1BQU0sR0FBRytxRCxNQUFNOzRCQUN0QlE7NEJBQ0FMLE1BQU0xaUI7NEJBQ05zaUIsT0FBT2wrQixJQUFJLENBQUM0Yjt3QkFDaEIsT0FBTzs0QkFDSGdqQjs0QkFDQUwsV0FBVzNpQjt3QkFDZjtvQkFDSjtvQkFDQSxJQUFJLENBQUNqUSxRQUFRLEdBQUc7d0JBQ1osT0FBTyxPQUFPOHlCLGVBQWUsT0FBT0MsWUFBWSxPQUFPQyxXQUFXLE9BQU9DLGdCQUFnQixPQUFPVixPQUFPOXFELE1BQU0sR0FBRyxNQUFNK3FEO29CQUMxSDtnQkFDSjtZQUdBO1lBQUUsQ0FBQztTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVNyckQsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3pDLElBQUk4RCxTQUFTLE9BQU9DLFVBQVUsY0FBYyxRQUFRQTtnQkFFcEQsSUFBSUMsVUFBVSxPQUFPQyxXQUFXLGNBQWMsUUFBUUE7Z0JBRXREaEUsUUFBT0QsT0FBTyxDQUFDaWxDLEdBQUcsR0FBRztvQkFDakIsT0FBT2dvQixLQUFLaG9CLEdBQUc7Z0JBQ25CO2dCQUVBaGxDLFFBQU9ELE9BQU8sQ0FBQ2k1QixJQUFJLEdBQUcsU0FBU3VOLElBQUk7b0JBQy9CLE9BQU95bUIsS0FBS2hvQixHQUFHLEtBQUt1QjtnQkFDeEI7WUFHQTtZQUFFLENBQUM7U0FBRTtRQUFDLElBQUc7WUFBQyxTQUFTeGxDLFFBQU8sRUFBQ2YsT0FBTSxFQUFDRCxRQUFPO2dCQUN6QyxJQUFJOEQsU0FBUyxPQUFPQyxVQUFVLGNBQWMsUUFBUUE7Z0JBRXBELElBQUlDLFVBQVUsT0FBT0MsV0FBVyxjQUFjLFFBQVFBO2dCQUV0RGpFLFNBQVFnd0IsS0FBSyxHQUFHO29CQUNaLElBQUksQ0FBQ2xzQixRQUFRO29CQUNib3BELFFBQVFDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDRixTQUFTRztnQkFDL0I7Z0JBRUFydEQsU0FBUThGLE1BQU0sR0FBRyxTQUFTd25ELFNBQVMsRUFBRUMsR0FBRyxFQUFFSixHQUFHO29CQUN6QyxJQUFJLENBQUNucEQsU0FBUztvQkFDZCxJQUFJc3BELFdBQVc7b0JBQ2ZILE9BQU9ELFFBQVFDLEdBQUcsQ0FBQ0E7b0JBQ25CLE1BQU0sSUFBSWpzRCxNQUFNcXNEO2dCQUNwQjtZQUdBO1lBQUUsQ0FBQztTQUFFO1FBQUMsSUFBRztZQUFDLFNBQVN2c0QsUUFBTyxFQUFDZixPQUFNLEVBQUNELFFBQU87Z0JBQ3pDLElBQUksT0FBT21wQixPQUFPekYsTUFBTSxJQUFJLFlBQVk7b0JBQ3BDempCLFFBQU9ELE9BQU8sR0FBRyxTQUFTd3RELEtBQUssRUFBRUMsS0FBSzt3QkFDbEMsT0FBT3RrQyxPQUFPekYsTUFBTSxDQUFDcmlCLElBQUksQ0FBQzhuQixRQUFRcWtDLE9BQU9DO29CQUM3QztnQkFDSixPQUFPO29CQUNIeHRELFFBQU9ELE9BQU8sR0FBRyxTQUFTd3RELEtBQUssRUFBRUMsS0FBSzt3QkFDbEMsSUFBSUEsT0FBTyxNQUFNdnNELE1BQU07d0JBQ3ZCLElBQUksT0FBT3NzRCxVQUFVLFlBQVlBLFVBQVUsTUFBTSxNQUFNdHNELE1BQU07d0JBQzdEd3NELEtBQUtubEQsU0FBUyxHQUFHaWxEO3dCQUNqQixPQUFPLElBQUlFO29CQUNmO29CQUNBLFNBQVNBLFFBQVE7Z0JBQ3JCO1lBR0E7WUFBRSxDQUFDO1NBQUU7UUFBQyxJQUFHO1lBQUMsU0FBUzFzRCxRQUFPLEVBQUNmLE9BQU0sRUFBQ0QsUUFBTztnQkFDekMsSUFBSThELFNBQVMsT0FBT0MsVUFBVSxjQUFjLFFBQVFBO2dCQUVwRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxRQUFRQTtnQkFFdEQsSUFBSTBwRCxtQkFBbUJ4a0MsT0FBTzVnQixTQUFTLENBQUNxbEQsb0JBQW9CO2dCQUU1RDN0RCxRQUFPRCxPQUFPLEdBQUcsU0FBUzZ0RCxFQUFFLEVBQUVDLElBQUk7b0JBQzlCLElBQUlELE9BQU8sUUFBUSxPQUFPQSxPQUFPLGFBQWE7d0JBQzFDQSxLQUFLLENBQUM7b0JBQ1Y7b0JBQ0EsSUFBSyxJQUFJcDFDLE9BQU9xMUMsS0FBTTt3QkFDbEIsSUFBSUEsS0FBS0MsY0FBYyxDQUFDdDFDLFFBQVEsT0FBT28xQyxFQUFFLENBQUNwMUMsSUFBSSxLQUFLLGFBQWE7NEJBQzVEbzFDLEVBQUUsQ0FBQ3AxQyxJQUFJLEdBQUdxMUMsSUFBSSxDQUFDcjFDLElBQUk7d0JBQ3ZCO29CQUNKO29CQUNBLElBQUksT0FBTzBRLE9BQU82a0MscUJBQXFCLEtBQUssWUFBWTt3QkFDcEQsSUFBSUMsVUFBVTlrQyxPQUFPNmtDLHFCQUFxQixDQUFDRjt3QkFDM0MsSUFBSyxJQUFJN3NELElBQUksR0FBR0EsSUFBSWd0RCxRQUFRM3NELE1BQU0sRUFBRUwsSUFBSzs0QkFDckMsSUFBSWl0RCxTQUFTRCxPQUFPLENBQUNodEQsRUFBRTs0QkFDdkIsSUFBSTZzRCxLQUFLRixvQkFBb0IsQ0FBQ00sV0FBVyxPQUFPTCxFQUFFLENBQUNwMUMsSUFBSSxLQUFLLGFBQWE7Z0NBQ3JFbzFDLEVBQUUsQ0FBQ0ssT0FBTyxHQUFHSixJQUFJLENBQUNJLE9BQU87NEJBQzdCO3dCQUNKO29CQUNKO29CQUNBLE9BQU9MO2dCQUNYO1lBR0E7WUFBRSxDQUFDO1NBQUU7SUFBQSxHQUFFLENBQUMsR0FBRTtRQUFDO0tBQUUsRUFBRTtBQUNmIn0=