// Copyright 2013-2024, University of Colorado Boulder
/**
 * Control panel around a content node.
 * Dynamically adjusts its size to fit its contents.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 * @author John Blanco (PhET Interactive Simulations)
 */ import { optionize3 } from '../../phet-core/js/optionize.js';
import { assertNoAdditionalChildren, LayoutConstraint, Node, ParallelDOM, Rectangle, Sizable } from '../../scenery/js/imports.js';
import sun from './sun.js';
// valid values for options.align
const ALIGN_VALUES = [
    'left',
    'center',
    'right'
];
const DEFAULT_OPTIONS = {
    fill: 'white',
    stroke: 'black',
    lineWidth: 1,
    lineDash: [],
    xMargin: 5,
    yMargin: 5,
    cornerRadius: 10,
    resize: true,
    backgroundPickable: true,
    excludeInvisibleChildrenFromBounds: true,
    align: 'left',
    minWidth: 0,
    minHeight: 0,
    // pdom
    labelTagName: 'span',
    helpTextBehavior: ParallelDOM.HELP_TEXT_BEFORE_CONTENT // Help text comes first for Nodes that are content containers.
};
assert && Object.freeze(DEFAULT_OPTIONS);
let Panel = class Panel extends Sizable(Node) {
    /**
   * Get the background rectangle's stroke (can be overridden)
   */ getStroke() {
        return this._background.stroke;
    }
    get stroke() {
        return this.getStroke();
    }
    set stroke(value) {
        this.setStroke(value);
    }
    /**
   * Change the background rectangle's stroke (can be overridden)
   */ setStroke(stroke) {
        this._background.stroke = stroke;
        // Since it depends on the stroke (if it's null, our minimum bounds get reduced)
        this.constraint && this.constraint.updateLayoutAutomatically();
    }
    /**
   * Get the background rectangle's fill (can be overridden)
   */ getFill() {
        return this._background.fill;
    }
    get fill() {
        return this.getFill();
    }
    set fill(value) {
        this.setFill(value);
    }
    /**
   * Change the background rectangle's fill (can be overridden)
   */ setFill(fill) {
        this._background.fill = fill;
    }
    setExcludeInvisibleChildrenFromBounds(excludeInvisibleChildrenFromBounds) {
        super.setExcludeInvisibleChildrenFromBounds(excludeInvisibleChildrenFromBounds);
        this.constraint.updateLayoutAutomatically();
    }
    constructor(content, providedOptions){
        const options = optionize3()({}, DEFAULT_OPTIONS, providedOptions);
        assert && assert(_.includes(ALIGN_VALUES, options.align), `invalid align: ${options.align}`);
        super();
        this._content = content;
        this._backgroundContainer = new Node();
        // correct size will be set by layout
        this._background = new Rectangle(0, 0, 1, 1, {
            lineWidth: options.lineWidth,
            pickable: options.backgroundPickable,
            lineDash: options.lineDash,
            cornerRadius: options.cornerRadius
        });
        // update the fill and stroke (before layout)
        this.setStroke(options.stroke);
        this.setFill(options.fill);
        this.addChild(this._backgroundContainer);
        this.addChild(content);
        // Only do this AFTER adding as a child
        this.constraint = new PanelConstraint(this, options);
        this.constraint.updateLayout();
        // Don't update automatically if resize:false
        this.constraint.enabled = options.resize;
        // Apply options after the layout is done, so that options that use the bounds will work properly.
        this.mutate(options);
        // Decorating with additional content is an anti-pattern, see https://github.com/phetsims/sun/issues/860
        assert && assertNoAdditionalChildren(this);
    }
};
Panel.DEFAULT_PANEL_OPTIONS = DEFAULT_OPTIONS;
export { Panel as default };
let PanelConstraint = class PanelConstraint extends LayoutConstraint {
    layout() {
        super.layout();
        const panel = this.panel;
        const content = panel._content;
        const background = panel._background;
        const hasValidContent = panel.isChildIncludedInLayout(content);
        // Bail out (and make the background invisible) if our bounds are invalid
        panel._backgroundContainer.children = hasValidContent ? [
            background
        ] : [];
        if (!hasValidContent) {
            panel.localMinimumWidth = null;
            panel.localMinimumHeight = null;
            return;
        }
        const contentProxy = this.createLayoutProxy(content);
        // Should only happen when we are disconnected during disposal
        if (!contentProxy) {
            return;
        }
        // We only have to account for the lineWidth in our layout if we have a stroke
        const lineWidth = panel.stroke === null ? 0 : this.lineWidth;
        const minimumContentWidth = contentProxy.minimumWidth;
        const minimumContentHeight = contentProxy.minimumHeight;
        // Our minimum dimensions are directly determined by the content, margins and lineWidth
        // NOTE: options.minWidth does NOT include the stroke (e.g. lineWidth), left for backward compatibility.
        const minimumWidth = Math.max(this.minWidth, minimumContentWidth + 2 * this.xMargin) + lineWidth;
        const minimumHeight = Math.max(this.minHeight, minimumContentHeight + 2 * this.yMargin) + lineWidth;
        // Our resulting sizes (allow setting preferred width/height on the panel)
        const preferredWidth = Math.max(minimumWidth, panel.localPreferredWidth || 0);
        const preferredHeight = Math.max(minimumHeight, panel.localPreferredHeight || 0);
        // Determine the size available to our content
        contentProxy.preferredWidth = preferredWidth - lineWidth - 2 * this.xMargin;
        contentProxy.preferredHeight = preferredHeight - lineWidth - 2 * this.yMargin;
        background.setRect(0, 0, preferredWidth - lineWidth, preferredHeight - lineWidth);
        // Align the content within the background. If the content width >= minWidth, then all alignments are equivalent.
        if (this.align === 'center') {
            contentProxy.center = background.center;
        } else if (this.align === 'left') {
            // Use background.rectWidth instead of background.width because they differ by the background lineWidth
            contentProxy.left = background.centerX - background.rectWidth / 2 + this.xMargin;
            contentProxy.centerY = background.centerY;
        } else {
            // Use background.rectWidth instead of background.width because they differ by the background lineWidth
            contentProxy.right = background.centerX + background.rectWidth / 2 - this.xMargin;
            contentProxy.centerY = background.centerY;
        }
        // Set minimums at the end
        panel.localMinimumWidth = minimumWidth;
        panel.localMinimumHeight = minimumHeight;
        contentProxy.dispose();
    }
    dispose() {
        this.panel.localPreferredWidthProperty.unlink(this._updateLayoutListener);
        this.panel.localPreferredHeightProperty.unlink(this._updateLayoutListener);
        super.dispose();
    }
    constructor(panel, options){
        super(panel);
        this.panel = panel;
        assert && assert(typeof options.minWidth === 'number', 'Panel minWidth should be a number');
        assert && assert(typeof options.xMargin === 'number', 'Panel xMargin should be a number');
        assert && assert(typeof options.yMargin === 'number', 'Panel yMargin should be a number');
        assert && assert(typeof options.lineWidth === 'number', 'Panel lineWidth should be a number');
        assert && assert(ALIGN_VALUES.includes(options.align), `Panel align should be one of ${ALIGN_VALUES}`);
        this.minWidth = options.minWidth;
        this.minHeight = options.minHeight;
        this.xMargin = options.xMargin;
        this.yMargin = options.yMargin;
        this.lineWidth = options.lineWidth;
        this.align = options.align;
        this.panel.localPreferredWidthProperty.lazyLink(this._updateLayoutListener);
        this.panel.localPreferredHeightProperty.lazyLink(this._updateLayoutListener);
        this.addNode(panel._content);
    }
};
sun.register('Panel', Panel);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3N1bi9qcy9QYW5lbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMy0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBDb250cm9sIHBhbmVsIGFyb3VuZCBhIGNvbnRlbnQgbm9kZS5cbiAqIER5bmFtaWNhbGx5IGFkanVzdHMgaXRzIHNpemUgdG8gZml0IGl0cyBjb250ZW50cy5cbiAqXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcbiAqIEBhdXRob3IgSm9obiBCbGFuY28gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKi9cblxuaW1wb3J0IHsgb3B0aW9uaXplMywgT3B0aW9uaXplRGVmYXVsdHMgfSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcbmltcG9ydCB7IGFzc2VydE5vQWRkaXRpb25hbENoaWxkcmVuLCBMYXlvdXRDb25zdHJhaW50LCBOb2RlLCBOb2RlT3B0aW9ucywgUGFyYWxsZWxET00sIFJlY3RhbmdsZSwgU2l6YWJsZSwgU2l6YWJsZU9wdGlvbnMsIFRQYWludCB9IGZyb20gJy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XG5pbXBvcnQgc3VuIGZyb20gJy4vc3VuLmpzJztcblxuLy8gdmFsaWQgdmFsdWVzIGZvciBvcHRpb25zLmFsaWduXG5jb25zdCBBTElHTl9WQUxVRVMgPSBbICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgXSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgUGFuZWxBbGlnbiA9IHR5cGVvZiBBTElHTl9WQUxVRVNbbnVtYmVyXTtcblxudHlwZSBTZWxmT3B0aW9ucyA9IHtcbiAgZmlsbD86IFRQYWludDtcbiAgc3Ryb2tlPzogVFBhaW50O1xuXG4gIC8vIHdpZHRoIG9mIHRoZSBiYWNrZ3JvdW5kIGJvcmRlclxuICBsaW5lV2lkdGg/OiBudW1iZXI7XG4gIGxpbmVEYXNoPzogbnVtYmVyW107XG5cbiAgeE1hcmdpbj86IG51bWJlcjtcbiAgeU1hcmdpbj86IG51bWJlcjtcblxuICAvLyByYWRpdXMgb2YgdGhlIHJvdW5kZWQgY29ybmVycyBvbiB0aGUgYmFja2dyb3VuZFxuICBjb3JuZXJSYWRpdXM/OiBudW1iZXI7XG5cbiAgLy8gZHluYW1pY2FsbHkgcmVzaXplIHdoZW4gY29udGVudCBib3VuZHMgY2hhbmdlXG4gIHJlc2l6ZT86IGJvb2xlYW47XG5cbiAgYmFja2dyb3VuZFBpY2thYmxlPzogYm9vbGVhbjtcblxuICAvLyBob3Jpem9udGFsIGFsaWdubWVudCBvZiBjb250ZW50IGluIHRoZSBwYW5lLCBzZWUgQUxJR05fVkFMVUVTXG4gIC8vIEFsbCBhbGlnbm1lbnRzIGFyZSBlcXVhbCB3aGVuIHRoZSBjb250ZW50IHdpZHRoID49IG1pbldpZHRoXG4gIC8vIExlZnQgaXMgdGhlIGRlZmF1bHQgYWxpZ25tZW50IHNvIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHBhbmVscywgdGhlaXIgY29udGVudCB3aWxsIGxlZnQgYWxpZ24sIHNlZSAjMjUyXG4gIGFsaWduPzogUGFuZWxBbGlnbjtcblxuICAvLyBtaW5pbXVtIHdpZHRoIG9mIHRoZSBwYW5lbCAobGluZVdpZHRoIHdpbGwgYWRkIHRvIHRoaXMpXG4gIG1pbldpZHRoPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXI7XG59O1xuXG50eXBlIFN1cGVyT3B0aW9ucyA9IFNpemFibGVPcHRpb25zICYgTm9kZU9wdGlvbnM7XG5leHBvcnQgdHlwZSBQYW5lbE9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFN1cGVyT3B0aW9ucztcblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgU3VwZXJPcHRpb25zPiA9IHtcbiAgZmlsbDogJ3doaXRlJyxcbiAgc3Ryb2tlOiAnYmxhY2snLFxuICBsaW5lV2lkdGg6IDEsXG4gIGxpbmVEYXNoOiBbXSxcbiAgeE1hcmdpbjogNSxcbiAgeU1hcmdpbjogNSxcbiAgY29ybmVyUmFkaXVzOiAxMCxcbiAgcmVzaXplOiB0cnVlLFxuICBiYWNrZ3JvdW5kUGlja2FibGU6IHRydWUsXG4gIGV4Y2x1ZGVJbnZpc2libGVDaGlsZHJlbkZyb21Cb3VuZHM6IHRydWUsXG4gIGFsaWduOiAnbGVmdCcsXG4gIG1pbldpZHRoOiAwLFxuICBtaW5IZWlnaHQ6IDAsXG5cbiAgLy8gcGRvbVxuICBsYWJlbFRhZ05hbWU6ICdzcGFuJywgLy8gQSBsYWJlbFRhZ05hbWUgZW5zdXJlcyB0aGUgYWNjZXNzaWJsZU5hbWUgZ2V0cyBpdHMgb3duIHRhZyBiZWZvcmUgY2hpbGQgY29udGVudC5cbiAgaGVscFRleHRCZWhhdmlvcjogUGFyYWxsZWxET00uSEVMUF9URVhUX0JFRk9SRV9DT05URU5UIC8vIEhlbHAgdGV4dCBjb21lcyBmaXJzdCBmb3IgTm9kZXMgdGhhdCBhcmUgY29udGVudCBjb250YWluZXJzLlxufTtcbmFzc2VydCAmJiBPYmplY3QuZnJlZXplKCBERUZBVUxUX09QVElPTlMgKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFuZWwgZXh0ZW5kcyBTaXphYmxlKCBOb2RlICkge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uc3RyYWludDogUGFuZWxDb25zdHJhaW50O1xuXG4gIC8vIFRoZXNlIGFyZSBwdWJsaWMgZm9yIHVzZSBieSBQYW5lbENvbnN0cmFpbnQgb25seS4gVGhleSBzaG91bGQgb3RoZXJ3aXNlIGJlIGNvbnNpZGVyZWQgcHJpdmF0ZS5cbiAgcHVibGljIHJlYWRvbmx5IF9jb250ZW50OiBOb2RlO1xuICBwdWJsaWMgcmVhZG9ubHkgX2JhY2tncm91bmRDb250YWluZXI6IE5vZGU7XG4gIHB1YmxpYyByZWFkb25seSBfYmFja2dyb3VuZDogUmVjdGFuZ2xlO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9QQU5FTF9PUFRJT05TID0gREVGQVVMVF9PUFRJT05TO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggY29udGVudDogTm9kZSwgcHJvdmlkZWRPcHRpb25zPzogUGFuZWxPcHRpb25zICkge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTM8UGFuZWxPcHRpb25zLCBTZWxmT3B0aW9ucywgU3VwZXJPcHRpb25zPigpKCB7fSwgREVGQVVMVF9PUFRJT05TLCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoIF8uaW5jbHVkZXMoIEFMSUdOX1ZBTFVFUywgb3B0aW9ucy5hbGlnbiApLCBgaW52YWxpZCBhbGlnbjogJHtvcHRpb25zLmFsaWdufWAgKTtcblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29udGFpbmVyID0gbmV3IE5vZGUoKTtcblxuICAgIC8vIGNvcnJlY3Qgc2l6ZSB3aWxsIGJlIHNldCBieSBsYXlvdXRcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgMSwgMSwge1xuICAgICAgbGluZVdpZHRoOiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgIHBpY2thYmxlOiBvcHRpb25zLmJhY2tncm91bmRQaWNrYWJsZSxcbiAgICAgIGxpbmVEYXNoOiBvcHRpb25zLmxpbmVEYXNoLFxuICAgICAgY29ybmVyUmFkaXVzOiBvcHRpb25zLmNvcm5lclJhZGl1c1xuICAgIH0gKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgZmlsbCBhbmQgc3Ryb2tlIChiZWZvcmUgbGF5b3V0KVxuICAgIHRoaXMuc2V0U3Ryb2tlKCBvcHRpb25zLnN0cm9rZSApO1xuICAgIHRoaXMuc2V0RmlsbCggb3B0aW9ucy5maWxsICk7XG5cbiAgICB0aGlzLmFkZENoaWxkKCB0aGlzLl9iYWNrZ3JvdW5kQ29udGFpbmVyICk7XG4gICAgdGhpcy5hZGRDaGlsZCggY29udGVudCApO1xuXG4gICAgLy8gT25seSBkbyB0aGlzIEFGVEVSIGFkZGluZyBhcyBhIGNoaWxkXG4gICAgdGhpcy5jb25zdHJhaW50ID0gbmV3IFBhbmVsQ29uc3RyYWludCggdGhpcywgb3B0aW9ucyApO1xuICAgIHRoaXMuY29uc3RyYWludC51cGRhdGVMYXlvdXQoKTtcblxuICAgIC8vIERvbid0IHVwZGF0ZSBhdXRvbWF0aWNhbGx5IGlmIHJlc2l6ZTpmYWxzZVxuICAgIHRoaXMuY29uc3RyYWludC5lbmFibGVkID0gb3B0aW9ucy5yZXNpemU7XG5cbiAgICAvLyBBcHBseSBvcHRpb25zIGFmdGVyIHRoZSBsYXlvdXQgaXMgZG9uZSwgc28gdGhhdCBvcHRpb25zIHRoYXQgdXNlIHRoZSBib3VuZHMgd2lsbCB3b3JrIHByb3Blcmx5LlxuICAgIHRoaXMubXV0YXRlKCBvcHRpb25zICk7XG5cbiAgICAvLyBEZWNvcmF0aW5nIHdpdGggYWRkaXRpb25hbCBjb250ZW50IGlzIGFuIGFudGktcGF0dGVybiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzg2MFxuICAgIGFzc2VydCAmJiBhc3NlcnROb0FkZGl0aW9uYWxDaGlsZHJlbiggdGhpcyApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmFja2dyb3VuZCByZWN0YW5nbGUncyBzdHJva2UgKGNhbiBiZSBvdmVycmlkZGVuKVxuICAgKi9cbiAgcHVibGljIGdldFN0cm9rZSgpOiBUUGFpbnQge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kLnN0cm9rZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3Ryb2tlKCk6IFRQYWludCB7IHJldHVybiB0aGlzLmdldFN0cm9rZSgpOyB9XG5cbiAgcHVibGljIHNldCBzdHJva2UoIHZhbHVlOiBUUGFpbnQgKSB7IHRoaXMuc2V0U3Ryb2tlKCB2YWx1ZSApOyB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgYmFja2dyb3VuZCByZWN0YW5nbGUncyBzdHJva2UgKGNhbiBiZSBvdmVycmlkZGVuKVxuICAgKi9cbiAgcHVibGljIHNldFN0cm9rZSggc3Ryb2tlOiBUUGFpbnQgKTogdm9pZCB7XG4gICAgdGhpcy5fYmFja2dyb3VuZC5zdHJva2UgPSBzdHJva2U7XG5cbiAgICAvLyBTaW5jZSBpdCBkZXBlbmRzIG9uIHRoZSBzdHJva2UgKGlmIGl0J3MgbnVsbCwgb3VyIG1pbmltdW0gYm91bmRzIGdldCByZWR1Y2VkKVxuICAgIHRoaXMuY29uc3RyYWludCAmJiB0aGlzLmNvbnN0cmFpbnQudXBkYXRlTGF5b3V0QXV0b21hdGljYWxseSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmFja2dyb3VuZCByZWN0YW5nbGUncyBmaWxsIChjYW4gYmUgb3ZlcnJpZGRlbilcbiAgICovXG4gIHB1YmxpYyBnZXRGaWxsKCk6IFRQYWludCB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmQuZmlsbDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZmlsbCgpOiBUUGFpbnQgeyByZXR1cm4gdGhpcy5nZXRGaWxsKCk7IH1cblxuICBwdWJsaWMgc2V0IGZpbGwoIHZhbHVlOiBUUGFpbnQgKSB7IHRoaXMuc2V0RmlsbCggdmFsdWUgKTsgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGJhY2tncm91bmQgcmVjdGFuZ2xlJ3MgZmlsbCAoY2FuIGJlIG92ZXJyaWRkZW4pXG4gICAqL1xuICBwdWJsaWMgc2V0RmlsbCggZmlsbDogVFBhaW50ICk6IHZvaWQge1xuICAgIHRoaXMuX2JhY2tncm91bmQuZmlsbCA9IGZpbGw7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgc2V0RXhjbHVkZUludmlzaWJsZUNoaWxkcmVuRnJvbUJvdW5kcyggZXhjbHVkZUludmlzaWJsZUNoaWxkcmVuRnJvbUJvdW5kczogYm9vbGVhbiApOiB2b2lkIHtcbiAgICBzdXBlci5zZXRFeGNsdWRlSW52aXNpYmxlQ2hpbGRyZW5Gcm9tQm91bmRzKCBleGNsdWRlSW52aXNpYmxlQ2hpbGRyZW5Gcm9tQm91bmRzICk7XG4gICAgdGhpcy5jb25zdHJhaW50LnVwZGF0ZUxheW91dEF1dG9tYXRpY2FsbHkoKTtcbiAgfVxufVxuXG5jbGFzcyBQYW5lbENvbnN0cmFpbnQgZXh0ZW5kcyBMYXlvdXRDb25zdHJhaW50IHtcblxuICBwcml2YXRlIHJlYWRvbmx5IHBhbmVsOiBQYW5lbDtcbiAgcHJpdmF0ZSByZWFkb25seSBtaW5XaWR0aDogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHhNYXJnaW46IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSB5TWFyZ2luOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbGluZVdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWxpZ246IFBhbmVsQWxpZ247XG4gIHByaXZhdGUgcmVhZG9ubHkgbWluSGVpZ2h0OiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwYW5lbDogUGFuZWwsIG9wdGlvbnM6IFJlcXVpcmVkPFNlbGZPcHRpb25zPiApIHtcbiAgICBzdXBlciggcGFuZWwgKTtcblxuICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLm1pbldpZHRoID09PSAnbnVtYmVyJywgJ1BhbmVsIG1pbldpZHRoIHNob3VsZCBiZSBhIG51bWJlcicgKTtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2Ygb3B0aW9ucy54TWFyZ2luID09PSAnbnVtYmVyJywgJ1BhbmVsIHhNYXJnaW4gc2hvdWxkIGJlIGEgbnVtYmVyJyApO1xuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLnlNYXJnaW4gPT09ICdudW1iZXInLCAnUGFuZWwgeU1hcmdpbiBzaG91bGQgYmUgYSBudW1iZXInICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIG9wdGlvbnMubGluZVdpZHRoID09PSAnbnVtYmVyJywgJ1BhbmVsIGxpbmVXaWR0aCBzaG91bGQgYmUgYSBudW1iZXInICk7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggQUxJR05fVkFMVUVTLmluY2x1ZGVzKCBvcHRpb25zLmFsaWduICksIGBQYW5lbCBhbGlnbiBzaG91bGQgYmUgb25lIG9mICR7QUxJR05fVkFMVUVTfWAgKTtcblxuICAgIHRoaXMubWluV2lkdGggPSBvcHRpb25zLm1pbldpZHRoO1xuICAgIHRoaXMubWluSGVpZ2h0ID0gb3B0aW9ucy5taW5IZWlnaHQ7XG4gICAgdGhpcy54TWFyZ2luID0gb3B0aW9ucy54TWFyZ2luO1xuICAgIHRoaXMueU1hcmdpbiA9IG9wdGlvbnMueU1hcmdpbjtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoO1xuICAgIHRoaXMuYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuXG4gICAgdGhpcy5wYW5lbC5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxheW91dExpc3RlbmVyICk7XG4gICAgdGhpcy5wYW5lbC5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuXG4gICAgdGhpcy5hZGROb2RlKCBwYW5lbC5fY29udGVudCApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGxheW91dCgpOiB2b2lkIHtcbiAgICBzdXBlci5sYXlvdXQoKTtcblxuICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYW5lbDtcbiAgICBjb25zdCBjb250ZW50ID0gcGFuZWwuX2NvbnRlbnQ7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHBhbmVsLl9iYWNrZ3JvdW5kO1xuXG4gICAgY29uc3QgaGFzVmFsaWRDb250ZW50ID0gcGFuZWwuaXNDaGlsZEluY2x1ZGVkSW5MYXlvdXQoIGNvbnRlbnQgKTtcblxuICAgIC8vIEJhaWwgb3V0IChhbmQgbWFrZSB0aGUgYmFja2dyb3VuZCBpbnZpc2libGUpIGlmIG91ciBib3VuZHMgYXJlIGludmFsaWRcbiAgICBwYW5lbC5fYmFja2dyb3VuZENvbnRhaW5lci5jaGlsZHJlbiA9IGhhc1ZhbGlkQ29udGVudCA/IFsgYmFja2dyb3VuZCBdIDogW107XG4gICAgaWYgKCAhaGFzVmFsaWRDb250ZW50ICkge1xuICAgICAgcGFuZWwubG9jYWxNaW5pbXVtV2lkdGggPSBudWxsO1xuICAgICAgcGFuZWwubG9jYWxNaW5pbXVtSGVpZ2h0ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50UHJveHkgPSB0aGlzLmNyZWF0ZUxheW91dFByb3h5KCBjb250ZW50ICk7XG5cbiAgICAvLyBTaG91bGQgb25seSBoYXBwZW4gd2hlbiB3ZSBhcmUgZGlzY29ubmVjdGVkIGR1cmluZyBkaXNwb3NhbFxuICAgIGlmICggIWNvbnRlbnRQcm94eSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBvbmx5IGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlIGxpbmVXaWR0aCBpbiBvdXIgbGF5b3V0IGlmIHdlIGhhdmUgYSBzdHJva2VcbiAgICBjb25zdCBsaW5lV2lkdGggPSBwYW5lbC5zdHJva2UgPT09IG51bGwgPyAwIDogdGhpcy5saW5lV2lkdGg7XG5cbiAgICBjb25zdCBtaW5pbXVtQ29udGVudFdpZHRoID0gY29udGVudFByb3h5Lm1pbmltdW1XaWR0aDtcbiAgICBjb25zdCBtaW5pbXVtQ29udGVudEhlaWdodCA9IGNvbnRlbnRQcm94eS5taW5pbXVtSGVpZ2h0O1xuXG4gICAgLy8gT3VyIG1pbmltdW0gZGltZW5zaW9ucyBhcmUgZGlyZWN0bHkgZGV0ZXJtaW5lZCBieSB0aGUgY29udGVudCwgbWFyZ2lucyBhbmQgbGluZVdpZHRoXG4gICAgLy8gTk9URTogb3B0aW9ucy5taW5XaWR0aCBkb2VzIE5PVCBpbmNsdWRlIHRoZSBzdHJva2UgKGUuZy4gbGluZVdpZHRoKSwgbGVmdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICBjb25zdCBtaW5pbXVtV2lkdGggPSBNYXRoLm1heCggdGhpcy5taW5XaWR0aCwgbWluaW11bUNvbnRlbnRXaWR0aCArICggMiAqIHRoaXMueE1hcmdpbiApICkgKyBsaW5lV2lkdGg7XG4gICAgY29uc3QgbWluaW11bUhlaWdodCA9IE1hdGgubWF4KCB0aGlzLm1pbkhlaWdodCwgbWluaW11bUNvbnRlbnRIZWlnaHQgKyAoIDIgKiB0aGlzLnlNYXJnaW4gKSApICsgbGluZVdpZHRoO1xuXG4gICAgLy8gT3VyIHJlc3VsdGluZyBzaXplcyAoYWxsb3cgc2V0dGluZyBwcmVmZXJyZWQgd2lkdGgvaGVpZ2h0IG9uIHRoZSBwYW5lbClcbiAgICBjb25zdCBwcmVmZXJyZWRXaWR0aDogbnVtYmVyID0gTWF0aC5tYXgoIG1pbmltdW1XaWR0aCwgcGFuZWwubG9jYWxQcmVmZXJyZWRXaWR0aCB8fCAwICk7XG4gICAgY29uc3QgcHJlZmVycmVkSGVpZ2h0OiBudW1iZXIgPSBNYXRoLm1heCggbWluaW11bUhlaWdodCwgcGFuZWwubG9jYWxQcmVmZXJyZWRIZWlnaHQgfHwgMCApO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIGF2YWlsYWJsZSB0byBvdXIgY29udGVudFxuICAgIGNvbnRlbnRQcm94eS5wcmVmZXJyZWRXaWR0aCA9IHByZWZlcnJlZFdpZHRoIC0gbGluZVdpZHRoIC0gMiAqIHRoaXMueE1hcmdpbjtcbiAgICBjb250ZW50UHJveHkucHJlZmVycmVkSGVpZ2h0ID0gcHJlZmVycmVkSGVpZ2h0IC0gbGluZVdpZHRoIC0gMiAqIHRoaXMueU1hcmdpbjtcblxuICAgIGJhY2tncm91bmQuc2V0UmVjdCggMCwgMCwgcHJlZmVycmVkV2lkdGggLSBsaW5lV2lkdGgsIHByZWZlcnJlZEhlaWdodCAtIGxpbmVXaWR0aCApO1xuXG4gICAgLy8gQWxpZ24gdGhlIGNvbnRlbnQgd2l0aGluIHRoZSBiYWNrZ3JvdW5kLiBJZiB0aGUgY29udGVudCB3aWR0aCA+PSBtaW5XaWR0aCwgdGhlbiBhbGwgYWxpZ25tZW50cyBhcmUgZXF1aXZhbGVudC5cbiAgICBpZiAoIHRoaXMuYWxpZ24gPT09ICdjZW50ZXInICkge1xuICAgICAgY29udGVudFByb3h5LmNlbnRlciA9IGJhY2tncm91bmQuY2VudGVyO1xuICAgIH1cbiAgICBlbHNlIGlmICggdGhpcy5hbGlnbiA9PT0gJ2xlZnQnICkge1xuXG4gICAgICAvLyBVc2UgYmFja2dyb3VuZC5yZWN0V2lkdGggaW5zdGVhZCBvZiBiYWNrZ3JvdW5kLndpZHRoIGJlY2F1c2UgdGhleSBkaWZmZXIgYnkgdGhlIGJhY2tncm91bmQgbGluZVdpZHRoXG4gICAgICBjb250ZW50UHJveHkubGVmdCA9IGJhY2tncm91bmQuY2VudGVyWCAtIGJhY2tncm91bmQucmVjdFdpZHRoIC8gMiArIHRoaXMueE1hcmdpbjtcbiAgICAgIGNvbnRlbnRQcm94eS5jZW50ZXJZID0gYmFja2dyb3VuZC5jZW50ZXJZO1xuICAgIH1cbiAgICBlbHNlIHsgLyogcmlnaHQgKi9cblxuICAgICAgLy8gVXNlIGJhY2tncm91bmQucmVjdFdpZHRoIGluc3RlYWQgb2YgYmFja2dyb3VuZC53aWR0aCBiZWNhdXNlIHRoZXkgZGlmZmVyIGJ5IHRoZSBiYWNrZ3JvdW5kIGxpbmVXaWR0aFxuICAgICAgY29udGVudFByb3h5LnJpZ2h0ID0gYmFja2dyb3VuZC5jZW50ZXJYICsgYmFja2dyb3VuZC5yZWN0V2lkdGggLyAyIC0gdGhpcy54TWFyZ2luO1xuICAgICAgY29udGVudFByb3h5LmNlbnRlclkgPSBiYWNrZ3JvdW5kLmNlbnRlclk7XG4gICAgfVxuXG4gICAgLy8gU2V0IG1pbmltdW1zIGF0IHRoZSBlbmRcbiAgICBwYW5lbC5sb2NhbE1pbmltdW1XaWR0aCA9IG1pbmltdW1XaWR0aDtcbiAgICBwYW5lbC5sb2NhbE1pbmltdW1IZWlnaHQgPSBtaW5pbXVtSGVpZ2h0O1xuXG4gICAgY29udGVudFByb3h5LmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHB1YmxpYyBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucGFuZWwubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnVubGluayggdGhpcy5fdXBkYXRlTGF5b3V0TGlzdGVuZXIgKTtcbiAgICB0aGlzLnBhbmVsLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbnN1bi5yZWdpc3RlciggJ1BhbmVsJywgUGFuZWwgKTsiXSwibmFtZXMiOlsib3B0aW9uaXplMyIsImFzc2VydE5vQWRkaXRpb25hbENoaWxkcmVuIiwiTGF5b3V0Q29uc3RyYWludCIsIk5vZGUiLCJQYXJhbGxlbERPTSIsIlJlY3RhbmdsZSIsIlNpemFibGUiLCJzdW4iLCJBTElHTl9WQUxVRVMiLCJERUZBVUxUX09QVElPTlMiLCJmaWxsIiwic3Ryb2tlIiwibGluZVdpZHRoIiwibGluZURhc2giLCJ4TWFyZ2luIiwieU1hcmdpbiIsImNvcm5lclJhZGl1cyIsInJlc2l6ZSIsImJhY2tncm91bmRQaWNrYWJsZSIsImV4Y2x1ZGVJbnZpc2libGVDaGlsZHJlbkZyb21Cb3VuZHMiLCJhbGlnbiIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibGFiZWxUYWdOYW1lIiwiaGVscFRleHRCZWhhdmlvciIsIkhFTFBfVEVYVF9CRUZPUkVfQ09OVEVOVCIsImFzc2VydCIsIk9iamVjdCIsImZyZWV6ZSIsIlBhbmVsIiwiZ2V0U3Ryb2tlIiwiX2JhY2tncm91bmQiLCJ2YWx1ZSIsInNldFN0cm9rZSIsImNvbnN0cmFpbnQiLCJ1cGRhdGVMYXlvdXRBdXRvbWF0aWNhbGx5IiwiZ2V0RmlsbCIsInNldEZpbGwiLCJzZXRFeGNsdWRlSW52aXNpYmxlQ2hpbGRyZW5Gcm9tQm91bmRzIiwiY29udGVudCIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJfIiwiaW5jbHVkZXMiLCJfY29udGVudCIsIl9iYWNrZ3JvdW5kQ29udGFpbmVyIiwicGlja2FibGUiLCJhZGRDaGlsZCIsIlBhbmVsQ29uc3RyYWludCIsInVwZGF0ZUxheW91dCIsImVuYWJsZWQiLCJtdXRhdGUiLCJERUZBVUxUX1BBTkVMX09QVElPTlMiLCJsYXlvdXQiLCJwYW5lbCIsImJhY2tncm91bmQiLCJoYXNWYWxpZENvbnRlbnQiLCJpc0NoaWxkSW5jbHVkZWRJbkxheW91dCIsImNoaWxkcmVuIiwibG9jYWxNaW5pbXVtV2lkdGgiLCJsb2NhbE1pbmltdW1IZWlnaHQiLCJjb250ZW50UHJveHkiLCJjcmVhdGVMYXlvdXRQcm94eSIsIm1pbmltdW1Db250ZW50V2lkdGgiLCJtaW5pbXVtV2lkdGgiLCJtaW5pbXVtQ29udGVudEhlaWdodCIsIm1pbmltdW1IZWlnaHQiLCJNYXRoIiwibWF4IiwicHJlZmVycmVkV2lkdGgiLCJsb2NhbFByZWZlcnJlZFdpZHRoIiwicHJlZmVycmVkSGVpZ2h0IiwibG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJzZXRSZWN0IiwiY2VudGVyIiwibGVmdCIsImNlbnRlclgiLCJyZWN0V2lkdGgiLCJjZW50ZXJZIiwicmlnaHQiLCJkaXNwb3NlIiwibG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5IiwidW5saW5rIiwiX3VwZGF0ZUxheW91dExpc3RlbmVyIiwibG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eSIsImxhenlMaW5rIiwiYWRkTm9kZSIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7Ozs7Q0FPQyxHQUVELFNBQVNBLFVBQVUsUUFBMkIsa0NBQWtDO0FBQ2hGLFNBQVNDLDBCQUEwQixFQUFFQyxnQkFBZ0IsRUFBRUMsSUFBSSxFQUFlQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsT0FBTyxRQUFnQyw4QkFBOEI7QUFDdkssT0FBT0MsU0FBUyxXQUFXO0FBRTNCLGlDQUFpQztBQUNqQyxNQUFNQyxlQUFlO0lBQUU7SUFBUTtJQUFVO0NBQVM7QUFvQ2xELE1BQU1DLGtCQUFnRTtJQUNwRUMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFdBQVc7SUFDWEMsVUFBVSxFQUFFO0lB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