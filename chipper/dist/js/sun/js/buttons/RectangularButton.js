// Copyright 2014-2024, University of Colorado Boulder
/**
 * RectangularButton is the base class for rectangular buttons.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */ import DerivedProperty from '../../../axon/js/DerivedProperty.js';
import Dimension2 from '../../../dot/js/Dimension2.js';
import { Shape } from '../../../kite/js/imports.js';
import optionize from '../../../phet-core/js/optionize.js';
import { Color, LayoutConstraint, LinearGradient, Node, PaintColorProperty, Path } from '../../../scenery/js/imports.js';
import sun from '../sun.js';
import ButtonInteractionState from './ButtonInteractionState.js';
import ButtonNode from './ButtonNode.js';
// constants
const VERTICAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
const HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
const SHADE_GRADIENT_LENGTH = 3; // In screen coords, which are roughly pixels.
let RectangularButton = class RectangularButton extends ButtonNode {
    /**
   * @param buttonModel - Model that defines the button's behavior.
   * @param interactionStateProperty - a Property that is used to drive the visual appearance of the button
   * @param providedOptions
   */ constructor(buttonModel, interactionStateProperty, providedOptions){
        let options = optionize()({
            size: null,
            minWidth: HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH,
            minHeight: VERTICAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH,
            xMargin: 8,
            yMargin: 5,
            touchAreaXDilation: 0,
            touchAreaYDilation: 0,
            mouseAreaXDilation: 0,
            mouseAreaYDilation: 0,
            touchAreaXShift: 0,
            touchAreaYShift: 0,
            mouseAreaXShift: 0,
            mouseAreaYShift: 0,
            stroke: null,
            lineWidth: 0.5,
            cornerRadius: 4,
            leftTopCornerRadius: null,
            rightTopCornerRadius: null,
            leftBottomCornerRadius: null,
            rightBottomCornerRadius: null,
            // Class that determines the button's appearance for the values of interactionStateProperty.
            // See RectangularButton.ThreeDAppearanceStrategy for an example of the interface required.
            buttonAppearanceStrategy: RectangularButton.ThreeDAppearanceStrategy
        }, providedOptions);
        if (!options.content) {
            assert && assert(options.size !== undefined, 'button dimensions needed if no content is supplied.');
        }
        if (options.size) {
            assert && assert(options.xMargin < options.size.width, 'xMargin cannot be larger than width');
            assert && assert(options.yMargin < options.size.height, 'yMargin cannot be larger than height');
        }
        // If no options were explicitly passed in for the button appearance strategy, pass through the general appearance
        // options.
        if (!options.buttonAppearanceStrategyOptions) {
            options.buttonAppearanceStrategyOptions = {
                stroke: options.stroke,
                lineWidth: options.lineWidth
            };
        }
        // Create the rectangular part of the button.
        const buttonBackground = new Path(null);
        const boundsRequiredOptionKeys = _.pick(options, Node.REQUIRES_BOUNDS_OPTION_KEYS);
        options = _.omit(options, Node.REQUIRES_BOUNDS_OPTION_KEYS);
        super(buttonModel, buttonBackground, interactionStateProperty, options);
        var _options_content;
        this.buttonNodeConstraint = new RectangularButtonNodeConstraint(this, this.layoutSizeProperty, {
            content: (_options_content = options.content) != null ? _options_content : null,
            size: options.size,
            buttonBackground: buttonBackground,
            buttonBackgroundOptions: options,
            minWidth: options.minWidth,
            minHeight: options.minHeight,
            xMargin: options.xMargin,
            yMargin: options.yMargin,
            maxLineWidth: this.maxLineWidth,
            touchAreaXDilation: options.touchAreaXDilation,
            touchAreaYDilation: options.touchAreaYDilation,
            touchAreaXShift: options.touchAreaXShift,
            touchAreaYShift: options.touchAreaYShift,
            mouseAreaXDilation: options.mouseAreaXDilation,
            mouseAreaYDilation: options.mouseAreaYDilation,
            mouseAreaXShift: options.mouseAreaXShift,
            mouseAreaYShift: options.mouseAreaYShift
        });
        this.disposeEmitter.addListener(()=>this.buttonNodeConstraint.dispose());
        this.mutate(boundsRequiredOptionKeys);
    }
};
export { RectangularButton as default };
/**
 * Convenience function for creating the shape of the button, done to avoid code duplication
 * @param width
 * @param height
 * @param config - RectangularButton config, containing values related to radii of button corners
 */ function createButtonShape(width, height, config) {
    // Don't allow a corner radius that is larger than half the width or height, see
    // https://github.com/phetsims/under-pressure/issues/151
    const maxCorner = Math.min(width / 2, height / 2);
    return Shape.roundedRectangleWithRadii(0, 0, width, height, {
        topLeft: Math.min(maxCorner, config.leftTopCornerRadius !== null ? config.leftTopCornerRadius : config.cornerRadius),
        topRight: Math.min(maxCorner, config.rightTopCornerRadius !== null ? config.rightTopCornerRadius : config.cornerRadius),
        bottomLeft: Math.min(maxCorner, config.leftBottomCornerRadius !== null ? config.leftBottomCornerRadius : config.cornerRadius),
        bottomRight: Math.min(maxCorner, config.rightBottomCornerRadius !== null ? config.rightBottomCornerRadius : config.cornerRadius)
    });
}
/**
 * ThreeDAppearanceStrategy is a value for RectangularButton options.buttonAppearanceStrategy. It makes a rectangular
 * button look 3D-ish by using gradients that create the appearance of highlighted and shaded edges. The gradients are
 * set up to make the light source appear to be in the upper left.
 */ let ThreeDAppearanceStrategy = class ThreeDAppearanceStrategy {
    dispose() {
        this.disposeThreeDAppearanceStrategy();
    }
    /**
   * @param buttonBackground - the Node for the button's background, sans content
   * @param interactionStateProperty
   * @param baseColorProperty
   * @param [providedOptions]
   */ constructor(buttonBackground, interactionStateProperty, baseColorProperty, providedOptions){
        // If stroke and lineWidth exist in the provided options, they become the default for all strokes and line widths.
        // If not, defaults are created.
        const defaultStroke = providedOptions && providedOptions.stroke ? providedOptions.stroke : new PaintColorProperty(baseColorProperty, {
            luminanceFactor: -0.4
        });
        const defaultLineWidth = providedOptions && providedOptions.lineWidth !== undefined ? providedOptions.lineWidth : 0.5;
        const options = optionize()({
            stroke: defaultStroke,
            lineWidth: defaultLineWidth,
            overStroke: defaultStroke,
            overLineWidth: defaultLineWidth,
            overFill: baseColorProperty,
            overButtonOpacity: 1,
            selectedStroke: defaultStroke,
            selectedLineWidth: defaultLineWidth,
            selectedButtonOpacity: 1,
            deselectedStroke: defaultStroke,
            deselectedFill: null,
            deselectedLineWidth: defaultLineWidth,
            deselectedButtonOpacity: 1
        }, providedOptions);
        // Create the colors that will be used to produce the gradients and shading needed for the 3D appearance.
        const baseBrighter7Property = new PaintColorProperty(baseColorProperty, {
            luminanceFactor: 0.7
        });
        const baseBrighter5Property = new PaintColorProperty(baseColorProperty, {
            luminanceFactor: 0.5
        });
        const baseBrighter2Property = new PaintColorProperty(baseColorProperty, {
            luminanceFactor: 0.2
        });
        const baseDarker3Property = new PaintColorProperty(baseColorProperty, {
            luminanceFactor: -0.3
        });
        const baseDarker4Property = new PaintColorProperty(baseColorProperty, {
            luminanceFactor: -0.4
        });
        const baseDarker5Property = new PaintColorProperty(baseColorProperty, {
            luminanceFactor: -0.5
        });
        const baseTransparentProperty = new DerivedProperty([
            baseColorProperty
        ], (color)=>color.withAlpha(0));
        const transparentWhite = new Color(255, 255, 255, 0.7);
        // Adds shading to left and right edges of the button.
        const horizontalShadingPath = new Path(null, {
            stroke: options.stroke,
            lineWidth: options.lineWidth,
            pickable: false
        });
        buttonBackground.addChild(horizontalShadingPath);
        this.maxLineWidth = typeof options.lineWidth === 'number' ? options.lineWidth : 0;
        let interactionStateListener;
        // We'll need to listen to the shape changes in order to update our appearance.
        const listener = ()=>{
            // We will be called properly later once we have a shape
            if (!buttonBackground.shape) {
                return;
            }
            // Handle our gradients based on the path's actual shape, NOT including the stroked part
            const buttonWidth = buttonBackground.shape.bounds.width;
            const buttonHeight = buttonBackground.shape.bounds.height;
            horizontalShadingPath.shape = buttonBackground.shape;
            // compute color stops for gradient, see issue #148
            assert && assert(buttonWidth >= HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH);
            assert && assert(buttonHeight >= VERTICAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH);
            const verticalHighlightStop = Math.min(VERTICAL_HIGHLIGHT_GRADIENT_LENGTH / buttonHeight, 1);
            const verticalShadowStop = Math.max(1 - SHADE_GRADIENT_LENGTH / buttonHeight, 0);
            const horizontalHighlightStop = Math.min(HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH / buttonWidth, 1);
            const horizontalShadowStop = Math.max(1 - SHADE_GRADIENT_LENGTH / buttonWidth, 0);
            // Gradient fills for button states
            const upFillVertical = new LinearGradient(0, 0, 0, buttonHeight).addColorStop(0, baseBrighter7Property).addColorStop(verticalHighlightStop, baseColorProperty).addColorStop(verticalShadowStop, baseColorProperty).addColorStop(1, baseDarker5Property);
            const upFillHorizontal = new LinearGradient(0, 0, buttonWidth, 0).addColorStop(0, transparentWhite).addColorStop(horizontalHighlightStop, baseTransparentProperty).addColorStop(horizontalShadowStop, baseTransparentProperty).addColorStop(1, baseDarker5Property);
            const overFillVertical = new LinearGradient(0, 0, 0, buttonHeight).addColorStop(0, baseBrighter7Property).addColorStop(verticalHighlightStop, baseBrighter5Property).addColorStop(verticalShadowStop, baseBrighter5Property).addColorStop(1, baseDarker5Property);
            const overFillHorizontal = new LinearGradient(0, 0, buttonWidth, 0).addColorStop(0, transparentWhite).addColorStop(horizontalHighlightStop / 2, new Color(255, 255, 255, 0)).addColorStop(horizontalShadowStop, baseTransparentProperty).addColorStop(1, baseDarker3Property);
            const downFillVertical = new LinearGradient(0, 0, 0, buttonHeight).addColorStop(0, baseBrighter7Property).addColorStop(verticalHighlightStop * 0.67, baseDarker3Property).addColorStop(verticalShadowStop, baseBrighter2Property).addColorStop(1, baseDarker5Property);
            // Cache gradients
            buttonBackground.cachedPaints = [
                upFillVertical,
                overFillVertical,
                downFillVertical
            ];
            horizontalShadingPath.cachedPaints = [
                upFillHorizontal,
                overFillHorizontal
            ];
            interactionStateListener && interactionStateProperty.unlink(interactionStateListener);
            // Change colors to match interactionState
            interactionStateListener = (interactionState)=>{
                switch(interactionState){
                    case ButtonInteractionState.IDLE:
                        buttonBackground.fill = options.deselectedFill || upFillVertical;
                        buttonBackground.stroke = options.deselectedStroke;
                        buttonBackground.lineWidth = options.deselectedLineWidth;
                        buttonBackground.opacity = options.deselectedButtonOpacity;
                        horizontalShadingPath.fill = upFillHorizontal;
                        horizontalShadingPath.opacity = options.deselectedButtonOpacity;
                        break;
                    case ButtonInteractionState.OVER:
                        buttonBackground.fill = overFillVertical;
                        buttonBackground.stroke = options.overStroke;
                        buttonBackground.lineWidth = options.overLineWidth;
                        buttonBackground.opacity = options.overButtonOpacity;
                        horizontalShadingPath.fill = overFillHorizontal;
                        horizontalShadingPath.opacity = options.overButtonOpacity;
                        break;
                    case ButtonInteractionState.PRESSED:
                        buttonBackground.fill = downFillVertical;
                        buttonBackground.stroke = options.selectedStroke;
                        buttonBackground.lineWidth = options.selectedLineWidth;
                        buttonBackground.opacity = options.selectedButtonOpacity;
                        horizontalShadingPath.fill = overFillHorizontal;
                        horizontalShadingPath.opacity = options.selectedButtonOpacity;
                        break;
                    default:
                        throw new Error(`unsupported interactionState: ${interactionState}`);
                }
            };
            interactionStateProperty.link(interactionStateListener);
        };
        buttonBackground.selfBoundsProperty.link(listener);
        this.disposeThreeDAppearanceStrategy = ()=>{
            buttonBackground.selfBoundsProperty.unlink(listener);
            if (interactionStateProperty.hasListener(interactionStateListener)) {
                interactionStateProperty.unlink(interactionStateListener);
            }
            baseBrighter7Property.dispose();
            baseBrighter5Property.dispose();
            baseBrighter2Property.dispose();
            baseDarker3Property.dispose();
            baseDarker4Property.dispose();
            baseDarker5Property.dispose();
            baseTransparentProperty.dispose();
        };
    }
};
RectangularButton.ThreeDAppearanceStrategy = ThreeDAppearanceStrategy;
let RectangularButtonNodeConstraint = class RectangularButtonNodeConstraint extends LayoutConstraint {
    layout() {
        super.layout();
        const buttonNode = this.buttonNode;
        const content = this.options.content;
        const contentProxy = content ? this.createLayoutProxy(content) : null;
        // Should only happen when we are disconnected during disposal
        if (!!content !== !!contentProxy) {
            return;
        }
        const widthSizable = buttonNode.widthSizable;
        const heightSizable = buttonNode.heightSizable;
        let contentMinimumWidthWithMargins = contentProxy ? contentProxy.minimumWidth + this.options.xMargin * 2 : 0;
        let contentMinimumHeightWithMargins = contentProxy ? contentProxy.minimumHeight + this.options.yMargin * 2 : 0;
        // If a initial (minimum) size is specified, use this as an override (and we will scale the content down to fit)
        if (this.options.size) {
            contentMinimumWidthWithMargins = this.options.size.width;
            contentMinimumHeightWithMargins = this.options.size.height;
        }
        // Apply minWidth/minHeight
        if (this.options.minWidth) {
            contentMinimumWidthWithMargins = Math.max(this.options.minWidth + this.options.maxLineWidth, contentMinimumWidthWithMargins);
        }
        if (this.options.minHeight) {
            contentMinimumHeightWithMargins = Math.max(this.options.minHeight + this.options.maxLineWidth, contentMinimumHeightWithMargins);
        }
        // Only allow an initial update if we are not sizable in that dimension
        const minimumWidth = this.isFirstLayout || widthSizable ? contentMinimumWidthWithMargins : buttonNode.localMinimumWidth;
        const minimumHeight = this.isFirstLayout || heightSizable ? contentMinimumHeightWithMargins : buttonNode.localMinimumHeight;
        var _buttonNode_localPreferredWidth;
        // Our resulting sizes (allow setting preferred width/height on the buttonNode)
        this.lastLocalWidth = this.isFirstLayout || widthSizable ? Math.max(minimumWidth, widthSizable ? (_buttonNode_localPreferredWidth = buttonNode.localPreferredWidth) != null ? _buttonNode_localPreferredWidth : 0 : 0) : this.lastLocalWidth;
        var _buttonNode_localPreferredHeight;
        this.lastLocalHeight = this.isFirstLayout || heightSizable ? Math.max(minimumHeight, heightSizable ? (_buttonNode_localPreferredHeight = buttonNode.localPreferredHeight) != null ? _buttonNode_localPreferredHeight : 0 : 0) : this.lastLocalHeight;
        if (this.isFirstLayout || widthSizable || heightSizable) {
            this.options.buttonBackground.shape = createButtonShape((widthSizable ? this.lastLocalWidth : minimumWidth) - this.options.maxLineWidth, (heightSizable ? this.lastLocalHeight : minimumHeight) - this.options.maxLineWidth, this.options.buttonBackgroundOptions);
            // Set pointer areas.
            this.buttonNode.touchArea = this.options.buttonBackground.localBounds.dilatedXY(this.options.touchAreaXDilation, this.options.touchAreaYDilation).shiftedXY(this.options.touchAreaXShift, this.options.touchAreaYShift);
            this.buttonNode.mouseArea = this.options.buttonBackground.localBounds.dilatedXY(this.options.mouseAreaXDilation, this.options.mouseAreaYDilation).shiftedXY(this.options.mouseAreaXShift, this.options.mouseAreaYShift);
        }
        if (contentProxy) {
            const preferredContentWidth = this.lastLocalWidth - this.options.xMargin * 2;
            const preferredContentHeight = this.lastLocalHeight - this.options.yMargin * 2;
            contentProxy.preferredWidth = preferredContentWidth;
            contentProxy.preferredHeight = preferredContentHeight;
            // Only apply max sizes if a size is specified in the button, see https://github.com/phetsims/sun/issues/889
            if (this.options.size) {
                const contentContainer = this.buttonNode.contentContainer;
                assert && assert(contentContainer);
                contentContainer.maxWidth = preferredContentWidth;
                contentContainer.maxHeight = preferredContentHeight;
            }
        }
        this.isFirstLayout = false;
        this.layoutSizeProperty.value = new Dimension2(this.lastLocalWidth, this.lastLocalHeight);
        // Set minimums at the end
        buttonNode.localMinimumWidth = minimumWidth;
        buttonNode.localMinimumHeight = minimumHeight;
        contentProxy && contentProxy.dispose();
    }
    dispose() {
        this.buttonNode.localPreferredWidthProperty.unlink(this._updateLayoutListener);
        this.buttonNode.localPreferredHeightProperty.unlink(this._updateLayoutListener);
        super.dispose();
    }
    constructor(buttonNode, layoutSizeProperty, options){
        super(buttonNode), this.buttonNode = buttonNode, this.layoutSizeProperty = layoutSizeProperty, this.isFirstLayout = true, this.lastLocalWidth = 0, this.lastLocalHeight = 0;
        this.options = options;
        this.buttonNode.localPreferredWidthProperty.lazyLink(this._updateLayoutListener);
        this.buttonNode.localPreferredHeightProperty.lazyLink(this._updateLayoutListener);
        if (this.options.content) {
            this.addNode(this.options.content);
        }
        this.layout();
    }
};
sun.register('RectangularButton', RectangularButton);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3N1bi9qcy9idXR0b25zL1JlY3Rhbmd1bGFyQnV0dG9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE0LTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIFJlY3Rhbmd1bGFyQnV0dG9uIGlzIHRoZSBiYXNlIGNsYXNzIGZvciByZWN0YW5ndWxhciBidXR0b25zLlxuICpcbiAqIEBhdXRob3IgSm9obiBCbGFuY28gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICovXG5cbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xuaW1wb3J0IFRpbnlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1RpbnlQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgRGltZW5zaW9uMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvRGltZW5zaW9uMi5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xuaW1wb3J0IFBpY2tSZXF1aXJlZCBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvUGlja1JlcXVpcmVkLmpzJztcbmltcG9ydCB7IENvbG9yLCBMYXlvdXRDb25zdHJhaW50LCBMaW5lYXJHcmFkaWVudCwgTm9kZSwgUGFpbnRDb2xvclByb3BlcnR5LCBQYXRoLCBUUGFpbnQgfSBmcm9tICcuLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xuaW1wb3J0IHN1biBmcm9tICcuLi9zdW4uanMnO1xuaW1wb3J0IEJ1dHRvbkludGVyYWN0aW9uU3RhdGUgZnJvbSAnLi9CdXR0b25JbnRlcmFjdGlvblN0YXRlLmpzJztcbmltcG9ydCBCdXR0b25Nb2RlbCBmcm9tICcuL0J1dHRvbk1vZGVsLmpzJztcbmltcG9ydCBCdXR0b25Ob2RlLCB7IEJ1dHRvbk5vZGVPcHRpb25zIH0gZnJvbSAnLi9CdXR0b25Ob2RlLmpzJztcbmltcG9ydCBSYWRpb0J1dHRvbkludGVyYWN0aW9uU3RhdGUgZnJvbSAnLi9SYWRpb0J1dHRvbkludGVyYWN0aW9uU3RhdGUuanMnO1xuaW1wb3J0IFRCdXR0b25BcHBlYXJhbmNlU3RyYXRlZ3ksIHsgVEJ1dHRvbkFwcGVhcmFuY2VTdHJhdGVneU9wdGlvbnMgfSBmcm9tICcuL1RCdXR0b25BcHBlYXJhbmNlU3RyYXRlZ3kuanMnO1xuXG4vLyBjb25zdGFudHNcbmNvbnN0IFZFUlRJQ0FMX0hJR0hMSUdIVF9HUkFESUVOVF9MRU5HVEggPSA3OyAvLyBJbiBzY3JlZW4gY29vcmRzLCB3aGljaCBhcmUgcm91Z2hseSBwaXhlbHMuXG5jb25zdCBIT1JJWk9OVEFMX0hJR0hMSUdIVF9HUkFESUVOVF9MRU5HVEggPSA3OyAvLyBJbiBzY3JlZW4gY29vcmRzLCB3aGljaCBhcmUgcm91Z2hseSBwaXhlbHMuXG5jb25zdCBTSEFERV9HUkFESUVOVF9MRU5HVEggPSAzOyAvLyBJbiBzY3JlZW4gY29vcmRzLCB3aGljaCBhcmUgcm91Z2hseSBwaXhlbHMuXG5cbnR5cGUgU2VsZk9wdGlvbnMgPSB7XG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYmUgdGhlIHNpemUgb2YgdGhlIGJ1dHRvbi4gbWluV2lkdGggYW5kIG1pbkhlaWdodCB3aWxsIGJlIGlnbm9yZWQsIGFuZFxuICAvLyBjb250ZW50IHdpbGwgYmUgc2NhbGVkIGRvd24gdG8gZml0IGluc2lkZSwgYWNjb3VudGluZyBmb3IgbWFyZ2lucy5cbiAgLy8gTk9URTogVGhpcyB3aWxsIE5PVCBiZSB0aGUgc2l6ZSBvZiB0aGUgYnV0dG9uLiBJdCBkb2VzIE5PVCBhY2NvdW50IGZvciB0aGUgc3Ryb2tlL2xpbmVXaWR0aCwgc28gdGhlIGJ1dHRvbiB3aWxsXG4gIC8vIEFMV0FZUyBiZSBsYXJnZXIgdGhhbiB0aGlzLlxuICAvLyBBRERJVElPTkFMTFk6IFRoZSBidXR0b24gY2FuIGJlIGxhcmdlciwgaWYgdGhlIGNvbnRlbnQgZG9lc24ndCBmaXQuXG4gIHNpemU/OiBEaW1lbnNpb24yIHwgbnVsbDtcblxuICAvLyBJZiB5b3Ugd2FudCBjb21wbGV0ZSBjb250cm9sIG9mIGEgYnV0dG9uJ3MgZGltZW5zaW9ucywgdXNlIG9wdGlvbnMuc2l6ZS4gSWYgeW91IHdhbnQgdG8gc3BlY2lmeVxuICAvLyBvbmUgZGltZW5zaW9ucyB3aGlsZSBoYXZpbmcgdGhlIG90aGVyIGRpbWVuc2lvbiBkZXRlcm1pbmVkIGJ5IGNvbnRlbnQgYW5kIG1hcmdpbiwgdGhlbiB1c2Ugb25lIG9mIHRoZXNlXG4gIC8vIG9wdGlvbnMuXG4gIC8vIE5PVEU6IFRoaXMgbWluV2lkdGgvbWluSGVpZ2h0IGRvZXMgTk9UIGluY2x1ZGUgdGhlIHN0cm9rZVxuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgbWluSGVpZ2h0PzogbnVtYmVyO1xuXG4gIC8vIHBvaW50ZXIgYXJlYSBkaWxhdGlvblxuICB0b3VjaEFyZWFYRGlsYXRpb24/OiBudW1iZXI7XG4gIHRvdWNoQXJlYVlEaWxhdGlvbj86IG51bWJlcjtcbiAgbW91c2VBcmVhWERpbGF0aW9uPzogbnVtYmVyO1xuICBtb3VzZUFyZWFZRGlsYXRpb24/OiBudW1iZXI7XG5cbiAgLy8gcG9pbnRlciBhcmVhIHNoaWZ0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNTAwXG4gIHRvdWNoQXJlYVhTaGlmdD86IG51bWJlcjtcbiAgdG91Y2hBcmVhWVNoaWZ0PzogbnVtYmVyO1xuICBtb3VzZUFyZWFYU2hpZnQ/OiBudW1iZXI7XG4gIG1vdXNlQXJlYVlTaGlmdD86IG51bWJlcjtcblxuICBzdHJva2U/OiBUUGFpbnQgfCBudWxsOyAvLyB3aGVuIG51bGwsIGEgc3Ryb2tlIHdpbGwgYmUgZGVyaXZlZCBmcm9tIHRoZSBiYXNlIGNvbG9yXG4gIGxpbmVXaWR0aD86IG51bWJlcjsgLy8gT25seSBtZWFuaW5nZnVsIGlmIHN0cm9rZSBpcyBub24tbnVsbFxuXG4gIC8vIHJhZGl1cyBhcHBsaWVkIHRvIGFsbCBjb3JuZXJzIHVubGVzcyBhIGNvcm5lci1zcGVjaWZpYyB2YWx1ZSBpcyBwcm92aWRlZFxuICBjb3JuZXJSYWRpdXM/OiBudW1iZXI7XG5cbiAgLy8ge251bWJlcnxudWxsfSBjb3JuZXItc3BlY2lmaWMgcmFkaWlcbiAgLy8gSWYgbnVsbCwgdGhlIG9wdGlvbiBpcyBpZ25vcmVkLlxuICAvLyBJZiBub24tbnVsbCwgaXQgb3ZlcnJpZGVzIGNvcm5lclJhZGl1cyBmb3IgdGhlIGFzc29jaWF0ZWQgY29ybmVyIG9mIHRoZSBidXR0b24uXG4gIGxlZnRUb3BDb3JuZXJSYWRpdXM/OiBudW1iZXIgfCBudWxsO1xuICByaWdodFRvcENvcm5lclJhZGl1cz86IG51bWJlciB8IG51bGw7XG4gIGxlZnRCb3R0b21Db3JuZXJSYWRpdXM/OiBudW1iZXIgfCBudWxsO1xuICByaWdodEJvdHRvbUNvcm5lclJhZGl1cz86IG51bWJlciB8IG51bGw7XG59O1xuXG5leHBvcnQgdHlwZSBSZWN0YW5ndWxhckJ1dHRvbk9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIEJ1dHRvbk5vZGVPcHRpb25zO1xuXG50eXBlIEJ1dHRvblNoYXBlT3B0aW9ucyA9IFBpY2tSZXF1aXJlZDxSZWN0YW5ndWxhckJ1dHRvbk9wdGlvbnMsICdjb3JuZXJSYWRpdXMnIHwgJ2xlZnRUb3BDb3JuZXJSYWRpdXMnIHwgJ3JpZ2h0VG9wQ29ybmVyUmFkaXVzJyB8ICdsZWZ0Qm90dG9tQ29ybmVyUmFkaXVzJyB8ICdyaWdodEJvdHRvbUNvcm5lclJhZGl1cyc+O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5ndWxhckJ1dHRvbiBleHRlbmRzIEJ1dHRvbk5vZGUge1xuXG4gIHB1YmxpYyBzdGF0aWMgVGhyZWVEQXBwZWFyYW5jZVN0cmF0ZWd5OiBUQnV0dG9uQXBwZWFyYW5jZVN0cmF0ZWd5O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYnV0dG9uTm9kZUNvbnN0cmFpbnQ6IFJlY3Rhbmd1bGFyQnV0dG9uTm9kZUNvbnN0cmFpbnQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBidXR0b25Nb2RlbCAtIE1vZGVsIHRoYXQgZGVmaW5lcyB0aGUgYnV0dG9uJ3MgYmVoYXZpb3IuXG4gICAqIEBwYXJhbSBpbnRlcmFjdGlvblN0YXRlUHJvcGVydHkgLSBhIFByb3BlcnR5IHRoYXQgaXMgdXNlZCB0byBkcml2ZSB0aGUgdmlzdWFsIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0gcHJvdmlkZWRPcHRpb25zXG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoIGJ1dHRvbk1vZGVsOiBCdXR0b25Nb2RlbCwgaW50ZXJhY3Rpb25TdGF0ZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxCdXR0b25JbnRlcmFjdGlvblN0YXRlPixcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBSZWN0YW5ndWxhckJ1dHRvbk9wdGlvbnMgKSB7XG5cbiAgICBsZXQgb3B0aW9ucyA9IG9wdGlvbml6ZTxSZWN0YW5ndWxhckJ1dHRvbk9wdGlvbnMsIFNlbGZPcHRpb25zLCBCdXR0b25Ob2RlT3B0aW9ucz4oKSgge1xuICAgICAgc2l6ZTogbnVsbCxcblxuICAgICAgbWluV2lkdGg6IEhPUklaT05UQUxfSElHSExJR0hUX0dSQURJRU5UX0xFTkdUSCArIFNIQURFX0dSQURJRU5UX0xFTkdUSCxcbiAgICAgIG1pbkhlaWdodDogVkVSVElDQUxfSElHSExJR0hUX0dSQURJRU5UX0xFTkdUSCArIFNIQURFX0dSQURJRU5UX0xFTkdUSCxcblxuICAgICAgeE1hcmdpbjogOCwgLy8gc2hvdWxkIGJlIHZpc2libHkgZ3JlYXRlciB0aGFuIHlNYXJnaW4sIHNlZSBpc3N1ZSAjMTA5XG4gICAgICB5TWFyZ2luOiA1LFxuXG4gICAgICB0b3VjaEFyZWFYRGlsYXRpb246IDAsXG4gICAgICB0b3VjaEFyZWFZRGlsYXRpb246IDAsXG4gICAgICBtb3VzZUFyZWFYRGlsYXRpb246IDAsXG4gICAgICBtb3VzZUFyZWFZRGlsYXRpb246IDAsXG5cbiAgICAgIHRvdWNoQXJlYVhTaGlmdDogMCxcbiAgICAgIHRvdWNoQXJlYVlTaGlmdDogMCxcbiAgICAgIG1vdXNlQXJlYVhTaGlmdDogMCxcbiAgICAgIG1vdXNlQXJlYVlTaGlmdDogMCxcblxuICAgICAgc3Ryb2tlOiBudWxsLCAvLyBudWxsIGJ5IGRlZmF1bHQsIHdoaWNoIHdpbGwgY2F1c2UgYSBzdHJva2UgdG8gYmUgZGVyaXZlZCBmcm9tIHRoZSBiYXNlIGNvbG9yXG4gICAgICBsaW5lV2lkdGg6IDAuNSxcbiAgICAgIGNvcm5lclJhZGl1czogNCxcblxuICAgICAgbGVmdFRvcENvcm5lclJhZGl1czogbnVsbCxcbiAgICAgIHJpZ2h0VG9wQ29ybmVyUmFkaXVzOiBudWxsLFxuICAgICAgbGVmdEJvdHRvbUNvcm5lclJhZGl1czogbnVsbCxcbiAgICAgIHJpZ2h0Qm90dG9tQ29ybmVyUmFkaXVzOiBudWxsLFxuXG4gICAgICAvLyBDbGFzcyB0aGF0IGRldGVybWluZXMgdGhlIGJ1dHRvbidzIGFwcGVhcmFuY2UgZm9yIHRoZSB2YWx1ZXMgb2YgaW50ZXJhY3Rpb25TdGF0ZVByb3BlcnR5LlxuICAgICAgLy8gU2VlIFJlY3Rhbmd1bGFyQnV0dG9uLlRocmVlREFwcGVhcmFuY2VTdHJhdGVneSBmb3IgYW4gZXhhbXBsZSBvZiB0aGUgaW50ZXJmYWNlIHJlcXVpcmVkLlxuICAgICAgYnV0dG9uQXBwZWFyYW5jZVN0cmF0ZWd5OiBSZWN0YW5ndWxhckJ1dHRvbi5UaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3lcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcblxuICAgIGlmICggIW9wdGlvbnMuY29udGVudCApIHtcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkLCAnYnV0dG9uIGRpbWVuc2lvbnMgbmVlZGVkIGlmIG5vIGNvbnRlbnQgaXMgc3VwcGxpZWQuJyApO1xuICAgIH1cblxuICAgIGlmICggb3B0aW9ucy5zaXplICkge1xuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy54TWFyZ2luIDwgb3B0aW9ucy5zaXplLndpZHRoLCAneE1hcmdpbiBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGgnICk7XG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLnlNYXJnaW4gPCBvcHRpb25zLnNpemUuaGVpZ2h0LCAneU1hcmdpbiBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gaGVpZ2h0JyApO1xuICAgIH1cblxuICAgIC8vIElmIG5vIG9wdGlvbnMgd2VyZSBleHBsaWNpdGx5IHBhc3NlZCBpbiBmb3IgdGhlIGJ1dHRvbiBhcHBlYXJhbmNlIHN0cmF0ZWd5LCBwYXNzIHRocm91Z2ggdGhlIGdlbmVyYWwgYXBwZWFyYW5jZVxuICAgIC8vIG9wdGlvbnMuXG4gICAgaWYgKCAhb3B0aW9ucy5idXR0b25BcHBlYXJhbmNlU3RyYXRlZ3lPcHRpb25zICkge1xuICAgICAgb3B0aW9ucy5idXR0b25BcHBlYXJhbmNlU3RyYXRlZ3lPcHRpb25zID0ge1xuICAgICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxuICAgICAgICBsaW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVjdGFuZ3VsYXIgcGFydCBvZiB0aGUgYnV0dG9uLlxuICAgIGNvbnN0IGJ1dHRvbkJhY2tncm91bmQgPSBuZXcgUGF0aCggbnVsbCApO1xuXG4gICAgY29uc3QgYm91bmRzUmVxdWlyZWRPcHRpb25LZXlzID0gXy5waWNrKCBvcHRpb25zLCBOb2RlLlJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUyApO1xuICAgIG9wdGlvbnMgPSBfLm9taXQoIG9wdGlvbnMsIE5vZGUuUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTICkgYXMgdHlwZW9mIG9wdGlvbnM7XG5cbiAgICBzdXBlciggYnV0dG9uTW9kZWwsIGJ1dHRvbkJhY2tncm91bmQsIGludGVyYWN0aW9uU3RhdGVQcm9wZXJ0eSwgb3B0aW9ucyApO1xuXG4gICAgdGhpcy5idXR0b25Ob2RlQ29uc3RyYWludCA9IG5ldyBSZWN0YW5ndWxhckJ1dHRvbk5vZGVDb25zdHJhaW50KCB0aGlzLCB0aGlzLmxheW91dFNpemVQcm9wZXJ0eSwge1xuICAgICAgY29udGVudDogb3B0aW9ucy5jb250ZW50ID8/IG51bGwsXG4gICAgICBzaXplOiBvcHRpb25zLnNpemUsXG4gICAgICBidXR0b25CYWNrZ3JvdW5kOiBidXR0b25CYWNrZ3JvdW5kLFxuICAgICAgYnV0dG9uQmFja2dyb3VuZE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtaW5XaWR0aDogb3B0aW9ucy5taW5XaWR0aCxcbiAgICAgIG1pbkhlaWdodDogb3B0aW9ucy5taW5IZWlnaHQsXG4gICAgICB4TWFyZ2luOiBvcHRpb25zLnhNYXJnaW4sXG4gICAgICB5TWFyZ2luOiBvcHRpb25zLnlNYXJnaW4sXG4gICAgICBtYXhMaW5lV2lkdGg6IHRoaXMubWF4TGluZVdpZHRoLFxuICAgICAgdG91Y2hBcmVhWERpbGF0aW9uOiBvcHRpb25zLnRvdWNoQXJlYVhEaWxhdGlvbixcbiAgICAgIHRvdWNoQXJlYVlEaWxhdGlvbjogb3B0aW9ucy50b3VjaEFyZWFZRGlsYXRpb24sXG4gICAgICB0b3VjaEFyZWFYU2hpZnQ6IG9wdGlvbnMudG91Y2hBcmVhWFNoaWZ0LFxuICAgICAgdG91Y2hBcmVhWVNoaWZ0OiBvcHRpb25zLnRvdWNoQXJlYVlTaGlmdCxcbiAgICAgIG1vdXNlQXJlYVhEaWxhdGlvbjogb3B0aW9ucy5tb3VzZUFyZWFYRGlsYXRpb24sXG4gICAgICBtb3VzZUFyZWFZRGlsYXRpb246IG9wdGlvbnMubW91c2VBcmVhWURpbGF0aW9uLFxuICAgICAgbW91c2VBcmVhWFNoaWZ0OiBvcHRpb25zLm1vdXNlQXJlYVhTaGlmdCxcbiAgICAgIG1vdXNlQXJlYVlTaGlmdDogb3B0aW9ucy5tb3VzZUFyZWFZU2hpZnRcbiAgICB9ICk7XG4gICAgdGhpcy5kaXNwb3NlRW1pdHRlci5hZGRMaXN0ZW5lciggKCkgPT4gdGhpcy5idXR0b25Ob2RlQ29uc3RyYWludC5kaXNwb3NlKCkgKTtcblxuICAgIHRoaXMubXV0YXRlKCBib3VuZHNSZXF1aXJlZE9wdGlvbktleXMgKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjcmVhdGluZyB0aGUgc2hhcGUgb2YgdGhlIGJ1dHRvbiwgZG9uZSB0byBhdm9pZCBjb2RlIGR1cGxpY2F0aW9uXG4gKiBAcGFyYW0gd2lkdGhcbiAqIEBwYXJhbSBoZWlnaHRcbiAqIEBwYXJhbSBjb25maWcgLSBSZWN0YW5ndWxhckJ1dHRvbiBjb25maWcsIGNvbnRhaW5pbmcgdmFsdWVzIHJlbGF0ZWQgdG8gcmFkaWkgb2YgYnV0dG9uIGNvcm5lcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uU2hhcGUoIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogQnV0dG9uU2hhcGVPcHRpb25zICk6IFNoYXBlIHtcblxuICAvLyBEb24ndCBhbGxvdyBhIGNvcm5lciByYWRpdXMgdGhhdCBpcyBsYXJnZXIgdGhhbiBoYWxmIHRoZSB3aWR0aCBvciBoZWlnaHQsIHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdW5kZXItcHJlc3N1cmUvaXNzdWVzLzE1MVxuICBjb25zdCBtYXhDb3JuZXIgPSBNYXRoLm1pbiggd2lkdGggLyAyLCBoZWlnaHQgLyAyICk7XG5cbiAgcmV0dXJuIFNoYXBlLnJvdW5kZWRSZWN0YW5nbGVXaXRoUmFkaWkoIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHtcbiAgICB0b3BMZWZ0OiBNYXRoLm1pbiggbWF4Q29ybmVyLCBjb25maWcubGVmdFRvcENvcm5lclJhZGl1cyAhPT0gbnVsbCA/IGNvbmZpZy5sZWZ0VG9wQ29ybmVyUmFkaXVzIDogY29uZmlnLmNvcm5lclJhZGl1cyApLFxuICAgIHRvcFJpZ2h0OiBNYXRoLm1pbiggbWF4Q29ybmVyLCBjb25maWcucmlnaHRUb3BDb3JuZXJSYWRpdXMgIT09IG51bGwgPyBjb25maWcucmlnaHRUb3BDb3JuZXJSYWRpdXMgOiBjb25maWcuY29ybmVyUmFkaXVzICksXG4gICAgYm90dG9tTGVmdDogTWF0aC5taW4oIG1heENvcm5lciwgY29uZmlnLmxlZnRCb3R0b21Db3JuZXJSYWRpdXMgIT09IG51bGwgPyBjb25maWcubGVmdEJvdHRvbUNvcm5lclJhZGl1cyA6IGNvbmZpZy5jb3JuZXJSYWRpdXMgKSxcbiAgICBib3R0b21SaWdodDogTWF0aC5taW4oIG1heENvcm5lciwgY29uZmlnLnJpZ2h0Qm90dG9tQ29ybmVyUmFkaXVzICE9PSBudWxsID8gY29uZmlnLnJpZ2h0Qm90dG9tQ29ybmVyUmFkaXVzIDogY29uZmlnLmNvcm5lclJhZGl1cyApXG4gIH0gKTtcbn1cblxuLyoqXG4gKiBUaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3kgaXMgYSB2YWx1ZSBmb3IgUmVjdGFuZ3VsYXJCdXR0b24gb3B0aW9ucy5idXR0b25BcHBlYXJhbmNlU3RyYXRlZ3kuIEl0IG1ha2VzIGEgcmVjdGFuZ3VsYXJcbiAqIGJ1dHRvbiBsb29rIDNELWlzaCBieSB1c2luZyBncmFkaWVudHMgdGhhdCBjcmVhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgaGlnaGxpZ2h0ZWQgYW5kIHNoYWRlZCBlZGdlcy4gVGhlIGdyYWRpZW50cyBhcmVcbiAqIHNldCB1cCB0byBtYWtlIHRoZSBsaWdodCBzb3VyY2UgYXBwZWFyIHRvIGJlIGluIHRoZSB1cHBlciBsZWZ0LlxuICovXG5jbGFzcyBUaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3kge1xuXG4gIHB1YmxpYyByZWFkb25seSBtYXhMaW5lV2lkdGg6IG51bWJlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VUaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3k6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBidXR0b25CYWNrZ3JvdW5kIC0gdGhlIE5vZGUgZm9yIHRoZSBidXR0b24ncyBiYWNrZ3JvdW5kLCBzYW5zIGNvbnRlbnRcbiAgICogQHBhcmFtIGludGVyYWN0aW9uU3RhdGVQcm9wZXJ0eVxuICAgKiBAcGFyYW0gYmFzZUNvbG9yUHJvcGVydHlcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoIGJ1dHRvbkJhY2tncm91bmQ6IFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGF0ZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxCdXR0b25JbnRlcmFjdGlvblN0YXRlIHwgUmFkaW9CdXR0b25JbnRlcmFjdGlvblN0YXRlPixcbiAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sb3JQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Q29sb3I+LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkT3B0aW9ucz86IFRCdXR0b25BcHBlYXJhbmNlU3RyYXRlZ3lPcHRpb25zICkge1xuXG4gICAgLy8gSWYgc3Ryb2tlIGFuZCBsaW5lV2lkdGggZXhpc3QgaW4gdGhlIHByb3ZpZGVkIG9wdGlvbnMsIHRoZXkgYmVjb21lIHRoZSBkZWZhdWx0IGZvciBhbGwgc3Ryb2tlcyBhbmQgbGluZSB3aWR0aHMuXG4gICAgLy8gSWYgbm90LCBkZWZhdWx0cyBhcmUgY3JlYXRlZC5cbiAgICBjb25zdCBkZWZhdWx0U3Ryb2tlID0gKCBwcm92aWRlZE9wdGlvbnMgJiYgcHJvdmlkZWRPcHRpb25zLnN0cm9rZSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRPcHRpb25zLnN0cm9rZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWludENvbG9yUHJvcGVydHkoIGJhc2VDb2xvclByb3BlcnR5LCB7IGx1bWluYW5jZUZhY3RvcjogLTAuNCB9ICk7XG4gICAgY29uc3QgZGVmYXVsdExpbmVXaWR0aCA9ICggcHJvdmlkZWRPcHRpb25zICYmIHByb3ZpZGVkT3B0aW9ucy5saW5lV2lkdGggIT09IHVuZGVmaW5lZCApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRPcHRpb25zLmxpbmVXaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuNTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8VEJ1dHRvbkFwcGVhcmFuY2VTdHJhdGVneU9wdGlvbnM+KCkoIHtcbiAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgIGxpbmVXaWR0aDogZGVmYXVsdExpbmVXaWR0aCxcbiAgICAgIG92ZXJTdHJva2U6IGRlZmF1bHRTdHJva2UsXG4gICAgICBvdmVyTGluZVdpZHRoOiBkZWZhdWx0TGluZVdpZHRoLFxuICAgICAgb3ZlckZpbGw6IGJhc2VDb2xvclByb3BlcnR5LFxuICAgICAgb3ZlckJ1dHRvbk9wYWNpdHk6IDEsXG4gICAgICBzZWxlY3RlZFN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgIHNlbGVjdGVkTGluZVdpZHRoOiBkZWZhdWx0TGluZVdpZHRoLFxuICAgICAgc2VsZWN0ZWRCdXR0b25PcGFjaXR5OiAxLFxuICAgICAgZGVzZWxlY3RlZFN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgIGRlc2VsZWN0ZWRGaWxsOiBudWxsLFxuICAgICAgZGVzZWxlY3RlZExpbmVXaWR0aDogZGVmYXVsdExpbmVXaWR0aCxcbiAgICAgIGRlc2VsZWN0ZWRCdXR0b25PcGFjaXR5OiAxXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNvbG9ycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBwcm9kdWNlIHRoZSBncmFkaWVudHMgYW5kIHNoYWRpbmcgbmVlZGVkIGZvciB0aGUgM0QgYXBwZWFyYW5jZS5cbiAgICBjb25zdCBiYXNlQnJpZ2h0ZXI3UHJvcGVydHkgPSBuZXcgUGFpbnRDb2xvclByb3BlcnR5KCBiYXNlQ29sb3JQcm9wZXJ0eSwgeyBsdW1pbmFuY2VGYWN0b3I6IDAuNyB9ICk7XG4gICAgY29uc3QgYmFzZUJyaWdodGVyNVByb3BlcnR5ID0gbmV3IFBhaW50Q29sb3JQcm9wZXJ0eSggYmFzZUNvbG9yUHJvcGVydHksIHsgbHVtaW5hbmNlRmFjdG9yOiAwLjUgfSApO1xuICAgIGNvbnN0IGJhc2VCcmlnaHRlcjJQcm9wZXJ0eSA9IG5ldyBQYWludENvbG9yUHJvcGVydHkoIGJhc2VDb2xvclByb3BlcnR5LCB7IGx1bWluYW5jZUZhY3RvcjogMC4yIH0gKTtcbiAgICBjb25zdCBiYXNlRGFya2VyM1Byb3BlcnR5ID0gbmV3IFBhaW50Q29sb3JQcm9wZXJ0eSggYmFzZUNvbG9yUHJvcGVydHksIHsgbHVtaW5hbmNlRmFjdG9yOiAtMC4zIH0gKTtcbiAgICBjb25zdCBiYXNlRGFya2VyNFByb3BlcnR5ID0gbmV3IFBhaW50Q29sb3JQcm9wZXJ0eSggYmFzZUNvbG9yUHJvcGVydHksIHsgbHVtaW5hbmNlRmFjdG9yOiAtMC40IH0gKTtcbiAgICBjb25zdCBiYXNlRGFya2VyNVByb3BlcnR5ID0gbmV3IFBhaW50Q29sb3JQcm9wZXJ0eSggYmFzZUNvbG9yUHJvcGVydHksIHsgbHVtaW5hbmNlRmFjdG9yOiAtMC41IH0gKTtcbiAgICBjb25zdCBiYXNlVHJhbnNwYXJlbnRQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoIFsgYmFzZUNvbG9yUHJvcGVydHkgXSwgY29sb3IgPT4gY29sb3Iud2l0aEFscGhhKCAwICkgKTtcbiAgICBjb25zdCB0cmFuc3BhcmVudFdoaXRlID0gbmV3IENvbG9yKCAyNTUsIDI1NSwgMjU1LCAwLjcgKTtcblxuICAgIC8vIEFkZHMgc2hhZGluZyB0byBsZWZ0IGFuZCByaWdodCBlZGdlcyBvZiB0aGUgYnV0dG9uLlxuICAgIGNvbnN0IGhvcml6b250YWxTaGFkaW5nUGF0aCA9IG5ldyBQYXRoKCBudWxsLCB7XG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxuICAgICAgbGluZVdpZHRoOiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgIHBpY2thYmxlOiBmYWxzZVxuICAgIH0gKTtcbiAgICBidXR0b25CYWNrZ3JvdW5kLmFkZENoaWxkKCBob3Jpem9udGFsU2hhZGluZ1BhdGggKTtcblxuICAgIHRoaXMubWF4TGluZVdpZHRoID0gdHlwZW9mIG9wdGlvbnMubGluZVdpZHRoID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZVdpZHRoIDogMDtcblxuICAgIGxldCBpbnRlcmFjdGlvblN0YXRlTGlzdGVuZXI6ICggaW50ZXJhY3Rpb25TdGF0ZTogQnV0dG9uSW50ZXJhY3Rpb25TdGF0ZSApID0+IHZvaWQ7XG5cbiAgICAvLyBXZSdsbCBuZWVkIHRvIGxpc3RlbiB0byB0aGUgc2hhcGUgY2hhbmdlcyBpbiBvcmRlciB0byB1cGRhdGUgb3VyIGFwcGVhcmFuY2UuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG5cbiAgICAgIC8vIFdlIHdpbGwgYmUgY2FsbGVkIHByb3Blcmx5IGxhdGVyIG9uY2Ugd2UgaGF2ZSBhIHNoYXBlXG4gICAgICBpZiAoICFidXR0b25CYWNrZ3JvdW5kLnNoYXBlICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBvdXIgZ3JhZGllbnRzIGJhc2VkIG9uIHRoZSBwYXRoJ3MgYWN0dWFsIHNoYXBlLCBOT1QgaW5jbHVkaW5nIHRoZSBzdHJva2VkIHBhcnRcbiAgICAgIGNvbnN0IGJ1dHRvbldpZHRoID0gYnV0dG9uQmFja2dyb3VuZC5zaGFwZS5ib3VuZHMud2lkdGg7XG4gICAgICBjb25zdCBidXR0b25IZWlnaHQgPSBidXR0b25CYWNrZ3JvdW5kLnNoYXBlLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgIGhvcml6b250YWxTaGFkaW5nUGF0aC5zaGFwZSA9IGJ1dHRvbkJhY2tncm91bmQuc2hhcGU7XG5cbiAgICAgIC8vIGNvbXB1dGUgY29sb3Igc3RvcHMgZm9yIGdyYWRpZW50LCBzZWUgaXNzdWUgIzE0OFxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggYnV0dG9uV2lkdGggPj0gSE9SSVpPTlRBTF9ISUdITElHSFRfR1JBRElFTlRfTEVOR1RIICsgU0hBREVfR1JBRElFTlRfTEVOR1RIICk7XG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBidXR0b25IZWlnaHQgPj0gVkVSVElDQUxfSElHSExJR0hUX0dSQURJRU5UX0xFTkdUSCArIFNIQURFX0dSQURJRU5UX0xFTkdUSCApO1xuICAgICAgY29uc3QgdmVydGljYWxIaWdobGlnaHRTdG9wID0gTWF0aC5taW4oIFZFUlRJQ0FMX0hJR0hMSUdIVF9HUkFESUVOVF9MRU5HVEggLyBidXR0b25IZWlnaHQsIDEgKTtcbiAgICAgIGNvbnN0IHZlcnRpY2FsU2hhZG93U3RvcCA9IE1hdGgubWF4KCAxIC0gU0hBREVfR1JBRElFTlRfTEVOR1RIIC8gYnV0dG9uSGVpZ2h0LCAwICk7XG4gICAgICBjb25zdCBob3Jpem9udGFsSGlnaGxpZ2h0U3RvcCA9IE1hdGgubWluKCBIT1JJWk9OVEFMX0hJR0hMSUdIVF9HUkFESUVOVF9MRU5HVEggLyBidXR0b25XaWR0aCwgMSApO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFNoYWRvd1N0b3AgPSBNYXRoLm1heCggMSAtIFNIQURFX0dSQURJRU5UX0xFTkdUSCAvIGJ1dHRvbldpZHRoLCAwICk7XG5cbiAgICAgIC8vIEdyYWRpZW50IGZpbGxzIGZvciBidXR0b24gc3RhdGVzXG4gICAgICBjb25zdCB1cEZpbGxWZXJ0aWNhbCA9IG5ldyBMaW5lYXJHcmFkaWVudCggMCwgMCwgMCwgYnV0dG9uSGVpZ2h0IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMCwgYmFzZUJyaWdodGVyN1Byb3BlcnR5IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggdmVydGljYWxIaWdobGlnaHRTdG9wLCBiYXNlQ29sb3JQcm9wZXJ0eSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIHZlcnRpY2FsU2hhZG93U3RvcCwgYmFzZUNvbG9yUHJvcGVydHkgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAxLCBiYXNlRGFya2VyNVByb3BlcnR5ICk7XG5cbiAgICAgIGNvbnN0IHVwRmlsbEhvcml6b250YWwgPSBuZXcgTGluZWFyR3JhZGllbnQoIDAsIDAsIGJ1dHRvbldpZHRoLCAwIClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMCwgdHJhbnNwYXJlbnRXaGl0ZSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIGhvcml6b250YWxIaWdobGlnaHRTdG9wLCBiYXNlVHJhbnNwYXJlbnRQcm9wZXJ0eSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIGhvcml6b250YWxTaGFkb3dTdG9wLCBiYXNlVHJhbnNwYXJlbnRQcm9wZXJ0eSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDEsIGJhc2VEYXJrZXI1UHJvcGVydHkgKTtcblxuICAgICAgY29uc3Qgb3ZlckZpbGxWZXJ0aWNhbCA9IG5ldyBMaW5lYXJHcmFkaWVudCggMCwgMCwgMCwgYnV0dG9uSGVpZ2h0IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMCwgYmFzZUJyaWdodGVyN1Byb3BlcnR5IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggdmVydGljYWxIaWdobGlnaHRTdG9wLCBiYXNlQnJpZ2h0ZXI1UHJvcGVydHkgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCB2ZXJ0aWNhbFNoYWRvd1N0b3AsIGJhc2VCcmlnaHRlcjVQcm9wZXJ0eSApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDEsIGJhc2VEYXJrZXI1UHJvcGVydHkgKTtcblxuICAgICAgY29uc3Qgb3ZlckZpbGxIb3Jpem9udGFsID0gbmV3IExpbmVhckdyYWRpZW50KCAwLCAwLCBidXR0b25XaWR0aCwgMCApXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAsIHRyYW5zcGFyZW50V2hpdGUgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCBob3Jpem9udGFsSGlnaGxpZ2h0U3RvcCAvIDIsIG5ldyBDb2xvciggMjU1LCAyNTUsIDI1NSwgMCApIClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggaG9yaXpvbnRhbFNoYWRvd1N0b3AsIGJhc2VUcmFuc3BhcmVudFByb3BlcnR5IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMSwgYmFzZURhcmtlcjNQcm9wZXJ0eSApO1xuXG4gICAgICBjb25zdCBkb3duRmlsbFZlcnRpY2FsID0gbmV3IExpbmVhckdyYWRpZW50KCAwLCAwLCAwLCBidXR0b25IZWlnaHQgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLCBiYXNlQnJpZ2h0ZXI3UHJvcGVydHkgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCB2ZXJ0aWNhbEhpZ2hsaWdodFN0b3AgKiAwLjY3LCBiYXNlRGFya2VyM1Byb3BlcnR5IClcbiAgICAgICAgLmFkZENvbG9yU3RvcCggdmVydGljYWxTaGFkb3dTdG9wLCBiYXNlQnJpZ2h0ZXIyUHJvcGVydHkgKVxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAxLCBiYXNlRGFya2VyNVByb3BlcnR5ICk7XG5cbiAgICAgIC8vIENhY2hlIGdyYWRpZW50c1xuICAgICAgYnV0dG9uQmFja2dyb3VuZC5jYWNoZWRQYWludHMgPSBbIHVwRmlsbFZlcnRpY2FsLCBvdmVyRmlsbFZlcnRpY2FsLCBkb3duRmlsbFZlcnRpY2FsIF07XG4gICAgICBob3Jpem9udGFsU2hhZGluZ1BhdGguY2FjaGVkUGFpbnRzID0gWyB1cEZpbGxIb3Jpem9udGFsLCBvdmVyRmlsbEhvcml6b250YWwgXTtcblxuICAgICAgaW50ZXJhY3Rpb25TdGF0ZUxpc3RlbmVyICYmIGludGVyYWN0aW9uU3RhdGVQcm9wZXJ0eS51bmxpbmsoIGludGVyYWN0aW9uU3RhdGVMaXN0ZW5lciApO1xuXG4gICAgICAvLyBDaGFuZ2UgY29sb3JzIHRvIG1hdGNoIGludGVyYWN0aW9uU3RhdGVcbiAgICAgIGludGVyYWN0aW9uU3RhdGVMaXN0ZW5lciA9ICggaW50ZXJhY3Rpb25TdGF0ZTogQnV0dG9uSW50ZXJhY3Rpb25TdGF0ZSApID0+IHtcblxuICAgICAgICBzd2l0Y2goIGludGVyYWN0aW9uU3RhdGUgKSB7XG5cbiAgICAgICAgICBjYXNlIEJ1dHRvbkludGVyYWN0aW9uU3RhdGUuSURMRTpcbiAgICAgICAgICAgIGJ1dHRvbkJhY2tncm91bmQuZmlsbCA9IG9wdGlvbnMuZGVzZWxlY3RlZEZpbGwgfHwgdXBGaWxsVmVydGljYWw7XG4gICAgICAgICAgICBidXR0b25CYWNrZ3JvdW5kLnN0cm9rZSA9IG9wdGlvbnMuZGVzZWxlY3RlZFN0cm9rZTtcbiAgICAgICAgICAgIGJ1dHRvbkJhY2tncm91bmQubGluZVdpZHRoID0gb3B0aW9ucy5kZXNlbGVjdGVkTGluZVdpZHRoO1xuICAgICAgICAgICAgYnV0dG9uQmFja2dyb3VuZC5vcGFjaXR5ID0gb3B0aW9ucy5kZXNlbGVjdGVkQnV0dG9uT3BhY2l0eTtcbiAgICAgICAgICAgIGhvcml6b250YWxTaGFkaW5nUGF0aC5maWxsID0gdXBGaWxsSG9yaXpvbnRhbDtcbiAgICAgICAgICAgIGhvcml6b250YWxTaGFkaW5nUGF0aC5vcGFjaXR5ID0gb3B0aW9ucy5kZXNlbGVjdGVkQnV0dG9uT3BhY2l0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBCdXR0b25JbnRlcmFjdGlvblN0YXRlLk9WRVI6XG4gICAgICAgICAgICBidXR0b25CYWNrZ3JvdW5kLmZpbGwgPSBvdmVyRmlsbFZlcnRpY2FsO1xuICAgICAgICAgICAgYnV0dG9uQmFja2dyb3VuZC5zdHJva2UgPSBvcHRpb25zLm92ZXJTdHJva2U7XG4gICAgICAgICAgICBidXR0b25CYWNrZ3JvdW5kLmxpbmVXaWR0aCA9IG9wdGlvbnMub3ZlckxpbmVXaWR0aDtcbiAgICAgICAgICAgIGJ1dHRvbkJhY2tncm91bmQub3BhY2l0eSA9IG9wdGlvbnMub3ZlckJ1dHRvbk9wYWNpdHk7XG4gICAgICAgICAgICBob3Jpem9udGFsU2hhZGluZ1BhdGguZmlsbCA9IG92ZXJGaWxsSG9yaXpvbnRhbDtcbiAgICAgICAgICAgIGhvcml6b250YWxTaGFkaW5nUGF0aC5vcGFjaXR5ID0gb3B0aW9ucy5vdmVyQnV0dG9uT3BhY2l0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBCdXR0b25JbnRlcmFjdGlvblN0YXRlLlBSRVNTRUQ6XG4gICAgICAgICAgICBidXR0b25CYWNrZ3JvdW5kLmZpbGwgPSBkb3duRmlsbFZlcnRpY2FsO1xuICAgICAgICAgICAgYnV0dG9uQmFja2dyb3VuZC5zdHJva2UgPSBvcHRpb25zLnNlbGVjdGVkU3Ryb2tlO1xuICAgICAgICAgICAgYnV0dG9uQmFja2dyb3VuZC5saW5lV2lkdGggPSBvcHRpb25zLnNlbGVjdGVkTGluZVdpZHRoO1xuICAgICAgICAgICAgYnV0dG9uQmFja2dyb3VuZC5vcGFjaXR5ID0gb3B0aW9ucy5zZWxlY3RlZEJ1dHRvbk9wYWNpdHk7XG4gICAgICAgICAgICBob3Jpem9udGFsU2hhZGluZ1BhdGguZmlsbCA9IG92ZXJGaWxsSG9yaXpvbnRhbDtcbiAgICAgICAgICAgIGhvcml6b250YWxTaGFkaW5nUGF0aC5vcGFjaXR5ID0gb3B0aW9ucy5zZWxlY3RlZEJ1dHRvbk9wYWNpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIGB1bnN1cHBvcnRlZCBpbnRlcmFjdGlvblN0YXRlOiAke2ludGVyYWN0aW9uU3RhdGV9YCApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaW50ZXJhY3Rpb25TdGF0ZVByb3BlcnR5LmxpbmsoIGludGVyYWN0aW9uU3RhdGVMaXN0ZW5lciApO1xuXG4gICAgfTtcbiAgICBidXR0b25CYWNrZ3JvdW5kLnNlbGZCb3VuZHNQcm9wZXJ0eS5saW5rKCBsaXN0ZW5lciApO1xuXG4gICAgdGhpcy5kaXNwb3NlVGhyZWVEQXBwZWFyYW5jZVN0cmF0ZWd5ID0gKCkgPT4ge1xuICAgICAgYnV0dG9uQmFja2dyb3VuZC5zZWxmQm91bmRzUHJvcGVydHkudW5saW5rKCBsaXN0ZW5lciApO1xuICAgICAgaWYgKCBpbnRlcmFjdGlvblN0YXRlUHJvcGVydHkuaGFzTGlzdGVuZXIoIGludGVyYWN0aW9uU3RhdGVMaXN0ZW5lciApICkge1xuICAgICAgICBpbnRlcmFjdGlvblN0YXRlUHJvcGVydHkudW5saW5rKCBpbnRlcmFjdGlvblN0YXRlTGlzdGVuZXIgKTtcbiAgICAgIH1cblxuICAgICAgYmFzZUJyaWdodGVyN1Byb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICAgIGJhc2VCcmlnaHRlcjVQcm9wZXJ0eS5kaXNwb3NlKCk7XG4gICAgICBiYXNlQnJpZ2h0ZXIyUHJvcGVydHkuZGlzcG9zZSgpO1xuICAgICAgYmFzZURhcmtlcjNQcm9wZXJ0eS5kaXNwb3NlKCk7XG4gICAgICBiYXNlRGFya2VyNFByb3BlcnR5LmRpc3Bvc2UoKTtcbiAgICAgIGJhc2VEYXJrZXI1UHJvcGVydHkuZGlzcG9zZSgpO1xuICAgICAgYmFzZVRyYW5zcGFyZW50UHJvcGVydHkuZGlzcG9zZSgpO1xuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpc3Bvc2VUaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3koKTtcbiAgfVxufVxuXG5SZWN0YW5ndWxhckJ1dHRvbi5UaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3kgPSBUaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3k7XG5cbnR5cGUgUmVjdGFuZ3VsYXJCdXR0b25Ob2RlQ29uc3RyYWludE9wdGlvbnMgPSB7XG4gIGJ1dHRvbkJhY2tncm91bmQ6IFBhdGg7XG4gIGJ1dHRvbkJhY2tncm91bmRPcHRpb25zOiBCdXR0b25TaGFwZU9wdGlvbnM7XG4gIG1heExpbmVXaWR0aDogbnVtYmVyO1xufSAmIFJlcXVpcmVkPFBpY2s8UmVjdGFuZ3VsYXJCdXR0b25PcHRpb25zLFxuICAnY29udGVudCcgfCAnc2l6ZScgfCAneE1hcmdpbicgfCAneU1hcmdpbicgfCAnbWluV2lkdGgnIHwgJ21pbkhlaWdodCcgfFxuICAndG91Y2hBcmVhWERpbGF0aW9uJyB8ICd0b3VjaEFyZWFZRGlsYXRpb24nIHwgJ3RvdWNoQXJlYVhTaGlmdCcgfCAndG91Y2hBcmVhWVNoaWZ0JyB8XG4gICdtb3VzZUFyZWFYRGlsYXRpb24nIHwgJ21vdXNlQXJlYVlEaWxhdGlvbicgfCAnbW91c2VBcmVhWFNoaWZ0JyB8ICdtb3VzZUFyZWFZU2hpZnQnXG4+PjtcblxuY2xhc3MgUmVjdGFuZ3VsYXJCdXR0b25Ob2RlQ29uc3RyYWludCBleHRlbmRzIExheW91dENvbnN0cmFpbnQge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUmVjdGFuZ3VsYXJCdXR0b25Ob2RlQ29uc3RyYWludE9wdGlvbnM7XG5cbiAgcHJpdmF0ZSBpc0ZpcnN0TGF5b3V0ID0gdHJ1ZTtcblxuICAvLyBTdG9yZWQgc28gdGhhdCB3ZSBjYW4gcHJldmVudCB1cGRhdGVzIGlmIHdlJ3JlIG5vdCBtYXJrZWQgc2l6YWJsZSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uXG4gIHByaXZhdGUgbGFzdExvY2FsV2lkdGggPSAwO1xuICBwcml2YXRlIGxhc3RMb2NhbEhlaWdodCA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBidXR0b25Ob2RlOiBCdXR0b25Ob2RlLFxuICAgIHB1YmxpYyByZWFkb25seSBsYXlvdXRTaXplUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxEaW1lbnNpb24yPixcbiAgICBvcHRpb25zOiBSZWN0YW5ndWxhckJ1dHRvbk5vZGVDb25zdHJhaW50T3B0aW9uc1xuICApIHtcblxuICAgIHN1cGVyKCBidXR0b25Ob2RlICk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5idXR0b25Ob2RlLmxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTGF5b3V0TGlzdGVuZXIgKTtcbiAgICB0aGlzLmJ1dHRvbk5vZGUubG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTGF5b3V0TGlzdGVuZXIgKTtcblxuICAgIGlmICggdGhpcy5vcHRpb25zLmNvbnRlbnQgKSB7XG4gICAgICB0aGlzLmFkZE5vZGUoIHRoaXMub3B0aW9ucy5jb250ZW50ICk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBsYXlvdXQoKTogdm9pZCB7XG4gICAgc3VwZXIubGF5b3V0KCk7XG5cbiAgICBjb25zdCBidXR0b25Ob2RlID0gdGhpcy5idXR0b25Ob2RlO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMuY29udGVudDtcbiAgICBjb25zdCBjb250ZW50UHJveHkgPSBjb250ZW50ID8gdGhpcy5jcmVhdGVMYXlvdXRQcm94eSggY29udGVudCApISA6IG51bGw7XG5cbiAgICAvLyBTaG91bGQgb25seSBoYXBwZW4gd2hlbiB3ZSBhcmUgZGlzY29ubmVjdGVkIGR1cmluZyBkaXNwb3NhbFxuICAgIGlmICggISFjb250ZW50ICE9PSAhIWNvbnRlbnRQcm94eSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3aWR0aFNpemFibGUgPSBidXR0b25Ob2RlLndpZHRoU2l6YWJsZTtcbiAgICBjb25zdCBoZWlnaHRTaXphYmxlID0gYnV0dG9uTm9kZS5oZWlnaHRTaXphYmxlO1xuXG4gICAgbGV0IGNvbnRlbnRNaW5pbXVtV2lkdGhXaXRoTWFyZ2lucyA9IGNvbnRlbnRQcm94eSA/IGNvbnRlbnRQcm94eS5taW5pbXVtV2lkdGggKyB0aGlzLm9wdGlvbnMueE1hcmdpbiAqIDIgOiAwO1xuICAgIGxldCBjb250ZW50TWluaW11bUhlaWdodFdpdGhNYXJnaW5zID0gY29udGVudFByb3h5ID8gY29udGVudFByb3h5Lm1pbmltdW1IZWlnaHQgKyB0aGlzLm9wdGlvbnMueU1hcmdpbiAqIDIgOiAwO1xuXG4gICAgLy8gSWYgYSBpbml0aWFsIChtaW5pbXVtKSBzaXplIGlzIHNwZWNpZmllZCwgdXNlIHRoaXMgYXMgYW4gb3ZlcnJpZGUgKGFuZCB3ZSB3aWxsIHNjYWxlIHRoZSBjb250ZW50IGRvd24gdG8gZml0KVxuICAgIGlmICggdGhpcy5vcHRpb25zLnNpemUgKSB7XG4gICAgICBjb250ZW50TWluaW11bVdpZHRoV2l0aE1hcmdpbnMgPSB0aGlzLm9wdGlvbnMuc2l6ZS53aWR0aDtcbiAgICAgIGNvbnRlbnRNaW5pbXVtSGVpZ2h0V2l0aE1hcmdpbnMgPSB0aGlzLm9wdGlvbnMuc2l6ZS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgbWluV2lkdGgvbWluSGVpZ2h0XG4gICAgaWYgKCB0aGlzLm9wdGlvbnMubWluV2lkdGggKSB7XG4gICAgICBjb250ZW50TWluaW11bVdpZHRoV2l0aE1hcmdpbnMgPSBNYXRoLm1heCggdGhpcy5vcHRpb25zLm1pbldpZHRoICsgdGhpcy5vcHRpb25zLm1heExpbmVXaWR0aCwgY29udGVudE1pbmltdW1XaWR0aFdpdGhNYXJnaW5zICk7XG4gICAgfVxuICAgIGlmICggdGhpcy5vcHRpb25zLm1pbkhlaWdodCApIHtcbiAgICAgIGNvbnRlbnRNaW5pbXVtSGVpZ2h0V2l0aE1hcmdpbnMgPSBNYXRoLm1heCggdGhpcy5vcHRpb25zLm1pbkhlaWdodCArIHRoaXMub3B0aW9ucy5tYXhMaW5lV2lkdGgsIGNvbnRlbnRNaW5pbXVtSGVpZ2h0V2l0aE1hcmdpbnMgKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGFsbG93IGFuIGluaXRpYWwgdXBkYXRlIGlmIHdlIGFyZSBub3Qgc2l6YWJsZSBpbiB0aGF0IGRpbWVuc2lvblxuICAgIGNvbnN0IG1pbmltdW1XaWR0aCA9XG4gICAgICAoIHRoaXMuaXNGaXJzdExheW91dCB8fCB3aWR0aFNpemFibGUgKVxuICAgICAgPyBjb250ZW50TWluaW11bVdpZHRoV2l0aE1hcmdpbnNcbiAgICAgIDogYnV0dG9uTm9kZS5sb2NhbE1pbmltdW1XaWR0aCE7XG4gICAgY29uc3QgbWluaW11bUhlaWdodCA9ICggdGhpcy5pc0ZpcnN0TGF5b3V0IHx8IGhlaWdodFNpemFibGUgKVxuICAgICAgPyBjb250ZW50TWluaW11bUhlaWdodFdpdGhNYXJnaW5zXG4gICAgICA6IGJ1dHRvbk5vZGUubG9jYWxNaW5pbXVtSGVpZ2h0ITtcblxuICAgIC8vIE91ciByZXN1bHRpbmcgc2l6ZXMgKGFsbG93IHNldHRpbmcgcHJlZmVycmVkIHdpZHRoL2hlaWdodCBvbiB0aGUgYnV0dG9uTm9kZSlcbiAgICB0aGlzLmxhc3RMb2NhbFdpZHRoID0gdGhpcy5pc0ZpcnN0TGF5b3V0IHx8IHdpZHRoU2l6YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KCBtaW5pbXVtV2lkdGgsIHdpZHRoU2l6YWJsZSA/IGJ1dHRvbk5vZGUubG9jYWxQcmVmZXJyZWRXaWR0aCA/PyAwIDogMCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5sYXN0TG9jYWxXaWR0aDtcbiAgICB0aGlzLmxhc3RMb2NhbEhlaWdodCA9IHRoaXMuaXNGaXJzdExheW91dCB8fCBoZWlnaHRTaXphYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KCBtaW5pbXVtSGVpZ2h0LCBoZWlnaHRTaXphYmxlID8gYnV0dG9uTm9kZS5sb2NhbFByZWZlcnJlZEhlaWdodCA/PyAwIDogMCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMubGFzdExvY2FsSGVpZ2h0O1xuXG4gICAgaWYgKCB0aGlzLmlzRmlyc3RMYXlvdXQgfHwgd2lkdGhTaXphYmxlIHx8IGhlaWdodFNpemFibGUgKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuYnV0dG9uQmFja2dyb3VuZC5zaGFwZSA9IGNyZWF0ZUJ1dHRvblNoYXBlKFxuICAgICAgICAoIHdpZHRoU2l6YWJsZSA/IHRoaXMubGFzdExvY2FsV2lkdGggOiBtaW5pbXVtV2lkdGggKSAtIHRoaXMub3B0aW9ucy5tYXhMaW5lV2lkdGgsXG4gICAgICAgICggaGVpZ2h0U2l6YWJsZSA/IHRoaXMubGFzdExvY2FsSGVpZ2h0IDogbWluaW11bUhlaWdodCApIC0gdGhpcy5vcHRpb25zLm1heExpbmVXaWR0aCxcbiAgICAgICAgdGhpcy5vcHRpb25zLmJ1dHRvbkJhY2tncm91bmRPcHRpb25zICk7XG5cbiAgICAgIC8vIFNldCBwb2ludGVyIGFyZWFzLlxuICAgICAgdGhpcy5idXR0b25Ob2RlLnRvdWNoQXJlYSA9IHRoaXMub3B0aW9ucy5idXR0b25CYWNrZ3JvdW5kLmxvY2FsQm91bmRzXG4gICAgICAgIC5kaWxhdGVkWFkoIHRoaXMub3B0aW9ucy50b3VjaEFyZWFYRGlsYXRpb24sIHRoaXMub3B0aW9ucy50b3VjaEFyZWFZRGlsYXRpb24gKVxuICAgICAgICAuc2hpZnRlZFhZKCB0aGlzLm9wdGlvbnMudG91Y2hBcmVhWFNoaWZ0LCB0aGlzLm9wdGlvbnMudG91Y2hBcmVhWVNoaWZ0ICk7XG4gICAgICB0aGlzLmJ1dHRvbk5vZGUubW91c2VBcmVhID0gdGhpcy5vcHRpb25zLmJ1dHRvbkJhY2tncm91bmQubG9jYWxCb3VuZHNcbiAgICAgICAgLmRpbGF0ZWRYWSggdGhpcy5vcHRpb25zLm1vdXNlQXJlYVhEaWxhdGlvbiwgdGhpcy5vcHRpb25zLm1vdXNlQXJlYVlEaWxhdGlvbiApXG4gICAgICAgIC5zaGlmdGVkWFkoIHRoaXMub3B0aW9ucy5tb3VzZUFyZWFYU2hpZnQsIHRoaXMub3B0aW9ucy5tb3VzZUFyZWFZU2hpZnQgKTtcbiAgICB9XG5cbiAgICBpZiAoIGNvbnRlbnRQcm94eSApIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZENvbnRlbnRXaWR0aCA9IHRoaXMubGFzdExvY2FsV2lkdGggLSB0aGlzLm9wdGlvbnMueE1hcmdpbiAqIDI7XG4gICAgICBjb25zdCBwcmVmZXJyZWRDb250ZW50SGVpZ2h0ID0gdGhpcy5sYXN0TG9jYWxIZWlnaHQgLSB0aGlzLm9wdGlvbnMueU1hcmdpbiAqIDI7XG5cbiAgICAgIGNvbnRlbnRQcm94eS5wcmVmZXJyZWRXaWR0aCA9IHByZWZlcnJlZENvbnRlbnRXaWR0aDtcbiAgICAgIGNvbnRlbnRQcm94eS5wcmVmZXJyZWRIZWlnaHQgPSBwcmVmZXJyZWRDb250ZW50SGVpZ2h0O1xuXG4gICAgICAvLyBPbmx5IGFwcGx5IG1heCBzaXplcyBpZiBhIHNpemUgaXMgc3BlY2lmaWVkIGluIHRoZSBidXR0b24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy84ODlcbiAgICAgIGlmICggdGhpcy5vcHRpb25zLnNpemUgKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSB0aGlzLmJ1dHRvbk5vZGUuY29udGVudENvbnRhaW5lciE7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGNvbnRlbnRDb250YWluZXIgKTtcblxuICAgICAgICBjb250ZW50Q29udGFpbmVyLm1heFdpZHRoID0gcHJlZmVycmVkQ29udGVudFdpZHRoO1xuICAgICAgICBjb250ZW50Q29udGFpbmVyLm1heEhlaWdodCA9IHByZWZlcnJlZENvbnRlbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc0ZpcnN0TGF5b3V0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmxheW91dFNpemVQcm9wZXJ0eS52YWx1ZSA9IG5ldyBEaW1lbnNpb24yKCB0aGlzLmxhc3RMb2NhbFdpZHRoLCB0aGlzLmxhc3RMb2NhbEhlaWdodCApO1xuXG4gICAgLy8gU2V0IG1pbmltdW1zIGF0IHRoZSBlbmRcbiAgICBidXR0b25Ob2RlLmxvY2FsTWluaW11bVdpZHRoID0gbWluaW11bVdpZHRoO1xuICAgIGJ1dHRvbk5vZGUubG9jYWxNaW5pbXVtSGVpZ2h0ID0gbWluaW11bUhlaWdodDtcblxuICAgIGNvbnRlbnRQcm94eSAmJiBjb250ZW50UHJveHkuZGlzcG9zZSgpO1xuICB9XG5cbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5idXR0b25Ob2RlLmxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eS51bmxpbmsoIHRoaXMuX3VwZGF0ZUxheW91dExpc3RlbmVyICk7XG4gICAgdGhpcy5idXR0b25Ob2RlLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbnN1bi5yZWdpc3RlciggJ1JlY3Rhbmd1bGFyQnV0dG9uJywgUmVjdGFuZ3VsYXJCdXR0b24gKTsiXSwibmFtZXMiOlsiRGVyaXZlZFByb3BlcnR5IiwiRGltZW5zaW9uMiIsIlNoYXBlIiwib3B0aW9uaXplIiwiQ29sb3IiLCJMYXlvdXRDb25zdHJhaW50IiwiTGluZWFyR3JhZGllbnQiLCJOb2RlIiwiUGFpbnRDb2xvclByb3BlcnR5IiwiUGF0aCIsInN1biIsIkJ1dHRvbkludGVyYWN0aW9uU3RhdGUiLCJCdXR0b25Ob2RlIiwiVkVSVElDQUxfSElHSExJR0hUX0dSQURJRU5UX0xFTkdUSCIsIkhPUklaT05UQUxfSElHSExJR0hUX0dSQURJRU5UX0xFTkdUSCIsIlNIQURFX0dSQURJRU5UX0xFTkdUSCIsIlJlY3Rhbmd1bGFyQnV0dG9uIiwiYnV0dG9uTW9kZWwiLCJpbnRlcmFjdGlvblN0YXRlUHJvcGVydHkiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwic2l6ZSIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwieE1hcmdpbiIsInlNYXJnaW4iLCJ0b3VjaEFyZWFYRGlsYXRpb24iLCJ0b3VjaEFyZWFZRGlsYXRpb24iLCJtb3VzZUFyZWFYRGlsYXRpb24iLCJtb3VzZUFyZWFZRGlsYXRpb24iLCJ0b3VjaEFyZWFYU2hpZnQiLCJ0b3VjaEFyZWFZU2hpZnQiLCJtb3VzZUFyZWFYU2hpZnQiLCJtb3VzZUFyZWFZU2hpZnQiLCJzdHJva2UiLCJsaW5lV2lkdGgiLCJjb3JuZXJSYWRpdXMiLCJsZWZ0VG9wQ29ybmVyUmFkaXVzIiwicmlnaHRUb3BDb3JuZXJSYWRpdXMiLCJsZWZ0Qm90dG9tQ29ybmVyUmFkaXVzIiwicmlnaHRCb3R0b21Db3JuZXJSYWRpdXMiLCJidXR0b25BcHBlYXJhbmNlU3RyYXRlZ3kiLCJUaHJlZURBcHBlYXJhbmNlU3RyYXRlZ3kiLCJjb250ZW50IiwiYXNzZXJ0IiwidW5kZWZpbmVkIiwid2lkdGgiLCJoZWlnaHQiLCJidXR0b25BcHBlYXJhbmNlU3RyYXRlZ3lPcHRpb25zIiwiYnV0dG9uQmFja2dyb3VuZCIsImJvdW5kc1JlcXVpcmVkT3B0aW9uS2V5cyIsIl8iLCJwaWNrIiwiUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTIiwib21pdCIsImJ1dHRvbk5vZGVDb25zdHJhaW50IiwiUmVjdGFuZ3VsYXJCdXR0b25Ob2RlQ29uc3RyYWludCIsImxheW91dFNpemVQcm9wZXJ0eSIsImJ1dHRvbkJhY2tncm91bmRPcHRpb25zIiwibWF4TGluZVdpZHRoIiwiZGlzcG9zZUVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsImRpc3Bvc2UiLCJtdXRhdGUiLCJjcmVhdGVCdXR0b25TaGFwZSIsImNvbmZpZyIsIm1heENvcm5lciIsIk1hdGgiLCJtaW4iLCJyb3VuZGVkUmVjdGFuZ2xlV2l0aFJhZGlpIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiZGlzcG9zZVRocmVlREFwcGVhcmFuY2VTdHJhdGVneSIsImJhc2VDb2xvclByb3BlcnR5IiwiZGVmYXVsdFN0cm9rZSIsImx1bWluYW5jZUZhY3RvciIsImRlZmF1bHRMaW5lV2lkdGgiLCJvdmVyU3Ryb2tlIiwib3ZlckxpbmVXaWR0aCIsIm92ZXJGaWxsIiwib3ZlckJ1dHRvbk9wYWNpdHkiLCJzZWxlY3RlZFN0cm9rZSIsInNlbGVjdGVkTGluZVdpZHRoIiwic2VsZWN0ZWRCdXR0b25PcGFjaXR5IiwiZGVzZWxlY3RlZFN0cm9rZSIsImRlc2VsZWN0ZWRGaWxsIiwiZGVzZWxlY3RlZExpbmVXaWR0aCIsImRlc2VsZWN0ZWRCdXR0b25PcGFjaXR5IiwiYmFzZUJyaWdodGVyN1Byb3BlcnR5IiwiYmFzZUJyaWdodGVyNVByb3BlcnR5IiwiYmFzZUJyaWdodGVyMlByb3BlcnR5IiwiYmFzZURhcmtlcjNQcm9wZXJ0eSIsImJhc2VEYXJrZXI0UHJvcGVydHkiLCJiYXNlRGFya2VyNVByb3BlcnR5IiwiYmFzZVRyYW5zcGFyZW50UHJvcGVydHkiLCJjb2xvciIsIndpdGhBbHBoYSIsInRyYW5zcGFyZW50V2hpdGUiLCJob3Jpem9udGFsU2hhZGluZ1BhdGgiLCJwaWNrYWJsZSIsImFkZENoaWxkIiwiaW50ZXJhY3Rpb25TdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJzaGFwZSIsImJ1dHRvbldpZHRoIiwiYm91bmRzIiwiYnV0dG9uSGVpZ2h0IiwidmVydGljYWxIaWdobGlnaHRTdG9wIiwidmVydGljYWxTaGFkb3dTdG9wIiwibWF4IiwiaG9yaXpvbnRhbEhpZ2hsaWdodFN0b3AiLCJob3Jpem9udGFsU2hhZG93U3RvcCIsInVwRmlsbFZlcnRpY2FsIiwiYWRkQ29sb3JTdG9wIiwidXBGaWxsSG9yaXpvbnRhbCIsIm92ZXJGaWxsVmVydGljYWwiLCJvdmVyRmlsbEhvcml6b250YWwiLCJkb3duRmlsbFZlcnRpY2FsIiwiY2FjaGVkUGFpbnRzIiwidW5saW5rIiwiaW50ZXJhY3Rpb25TdGF0ZSIsIklETEUiLCJmaWxsIiwib3BhY2l0eSIsIk9WRVIiLCJQUkVTU0VEIiwiRXJyb3IiLCJsaW5rIiwic2VsZkJvdW5kc1Byb3BlcnR5IiwiaGFzTGlzdGVuZXIiLCJsYXlvdXQiLCJidXR0b25Ob2RlIiwiY29udGVudFByb3h5IiwiY3JlYXRlTGF5b3V0UHJveHkiLCJ3aWR0aFNpemFibGUiLCJoZWlnaHRTaXphYmxlIiwiY29udGVudE1pbmltdW1XaWR0aFdpdGhNYXJnaW5zIiwibWluaW11bVdpZHRoIiwiY29udGVudE1pbmltdW1IZWlnaHRXaXRoTWFyZ2lucyIsIm1pbmltdW1IZWlnaHQiLCJpc0ZpcnN0TGF5b3V0IiwibG9jYWxNaW5pbXVtV2lkdGgiLCJsb2NhbE1pbmltdW1IZWlnaHQiLCJsYXN0TG9jYWxXaWR0aCIsImxvY2FsUHJlZmVycmVkV2lkdGgiLCJsYXN0TG9jYWxIZWlnaHQiLCJsb2NhbFByZWZlcnJlZEhlaWdodCIsInRvdWNoQXJlYSIsImxvY2FsQm91bmRzIiwiZGlsYXRlZFhZIiwic2hpZnRlZFhZIiwibW91c2VBcmVhIiwicHJlZmVycmVkQ29udGVudFdpZHRoIiwicHJlZmVycmVkQ29udGVudEhlaWdodCIsInByZWZlcnJlZFdpZHRoIiwicHJlZmVycmVkSGVpZ2h0IiwiY29udGVudENvbnRhaW5lciIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwidmFsdWUiLCJsb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkiLCJfdXBkYXRlTGF5b3V0TGlzdGVuZXIiLCJsb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5IiwibGF6eUxpbmsiLCJhZGROb2RlIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7Q0FLQyxHQUVELE9BQU9BLHFCQUFxQixzQ0FBc0M7QUFHbEUsT0FBT0MsZ0JBQWdCLGdDQUFnQztBQUN2RCxTQUFTQyxLQUFLLFFBQVEsOEJBQThCO0FBQ3BELE9BQU9DLGVBQWUscUNBQXFDO0FBRTNELFNBQVNDLEtBQUssRUFBRUMsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRUMsSUFBSSxFQUFFQyxrQkFBa0IsRUFBRUMsSUFBSSxRQUFnQixpQ0FBaUM7QUFDakksT0FBT0MsU0FBUyxZQUFZO0FBQzVCLE9BQU9DLDRC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