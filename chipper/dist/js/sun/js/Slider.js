// Copyright 2013-2024, University of Colorado Boulder
/**
 * Slider, with support for horizontal and vertical orientations. By default, the slider is constructed in the
 * horizontal orientation, then adjusted if the vertical orientation was specified.
 *
 * Note: This type was originally named HSlider, renamed in https://github.com/phetsims/sun/issues/380.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */ import createObservableArray from '../../axon/js/createObservableArray.js';
import Multilink from '../../axon/js/Multilink.js';
import Property from '../../axon/js/Property.js';
import ReadOnlyProperty from '../../axon/js/ReadOnlyProperty.js';
import TinyProperty from '../../axon/js/TinyProperty.js';
import CompletePiecewiseLinearFunction from '../../dot/js/CompletePiecewiseLinearFunction.js';
import Dimension2 from '../../dot/js/Dimension2.js';
import Range from '../../dot/js/Range.js';
import Utils from '../../dot/js/Utils.js';
import Vector2 from '../../dot/js/Vector2.js';
import assertMutuallyExclusiveOptions from '../../phet-core/js/assertMutuallyExclusiveOptions.js';
import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import optionize, { combineOptions } from '../../phet-core/js/optionize.js';
import Orientation from '../../phet-core/js/Orientation.js';
import swapObjectKeys from '../../phet-core/js/swapObjectKeys.js';
import { assertNoAdditionalChildren, DragListener, HighlightFromNode, LayoutConstraint, Node, SceneryConstants, Sizable } from '../../scenery/js/imports.js';
import ValueChangeSoundPlayer from '../../tambo/js/sound-generators/ValueChangeSoundPlayer.js';
import isSettingPhetioStateProperty from '../../tandem/js/isSettingPhetioStateProperty.js';
import Tandem from '../../tandem/js/Tandem.js';
import IOType from '../../tandem/js/types/IOType.js';
import AccessibleSlider from './accessibility/AccessibleSlider.js';
import DefaultSliderTrack from './DefaultSliderTrack.js';
import SliderThumb from './SliderThumb.js';
import SliderTick from './SliderTick.js';
import sun from './sun.js';
import SunConstants from './SunConstants.js';
// constants
const DEFAULT_HORIZONTAL_TRACK_SIZE = new Dimension2(100, 5);
const DEFAULT_HORIZONTAL_THUMB_SIZE = new Dimension2(17, 34);
let Slider = class Slider extends Sizable(AccessibleSlider(Node, 0)) {
    get majorTicksVisible() {
        return this.getMajorTicksVisible();
    }
    set majorTicksVisible(value) {
        this.setMajorTicksVisible(value);
    }
    get minorTicksVisible() {
        return this.getMinorTicksVisible();
    }
    set minorTicksVisible(value) {
        this.setMinorTicksVisible(value);
    }
    dispose() {
        this.disposeSlider();
        this.ticks.forEach((tick)=>{
            tick.dispose();
        });
        super.dispose();
    }
    /**
   * Adds a major tick mark.
   */ addMajorTick(value, label) {
        this.addTick(this.majorTicksParent, value, label, this.tickOptions.majorTickLength, this.tickOptions.majorTickStroke, this.tickOptions.majorTickLineWidth);
    }
    /**
   * Adds a minor tick mark.
   */ addMinorTick(value, label) {
        this.addTick(this.minorTicksParent, value, label, this.tickOptions.minorTickLength, this.tickOptions.minorTickStroke, this.tickOptions.minorTickLineWidth);
    }
    /**
   * Adds a tick mark above the track.
   */ addTick(parent, value, label, length, stroke, lineWidth) {
        this.ticks.push(new SliderTick(parent, value, label, length, stroke, lineWidth, this.tickOptions, this.orientation, this.track));
    }
    // Sets visibility of major ticks.
    setMajorTicksVisible(visible) {
        this.majorTicksParent.visible = visible;
    }
    // Gets visibility of major ticks.
    getMajorTicksVisible() {
        return this.majorTicksParent.visible;
    }
    // Sets visibility of minor ticks.
    setMinorTicksVisible(visible) {
        this.minorTicksParent.visible = visible;
    }
    // Gets visibility of minor ticks.
    getMinorTicksVisible() {
        return this.minorTicksParent.visible;
    }
    constructor(valueProperty, range, providedOptions){
        var _window_phet_chipper_queryParameters, _window_phet_chipper, _window_phet;
        // Guard against mutually exclusive options before defaults are filled in.
        assert && assertMutuallyExclusiveOptions(providedOptions, [
            'thumbNode'
        ], [
            'thumbSize',
            'thumbFill',
            'thumbFillHighlighted',
            'thumbStroke',
            'thumbLineWidth',
            'thumbCenterLineStroke',
            'thumbTouchAreaXDilation',
            'thumbTouchAreaYDilation',
            'thumbMouseAreaXDilation',
            'thumbMouseAreaYDilation'
        ]);
        assert && assertMutuallyExclusiveOptions(providedOptions, [
            'trackNode'
        ], [
            'trackSize',
            'trackFillEnabled',
            'trackFillDisabled',
            'trackStroke',
            'trackLineWidth',
            'trackCornerRadius'
        ]);
        const options = optionize()({
            orientation: Orientation.HORIZONTAL,
            trackNode: null,
            trackSize: null,
            trackFillEnabled: 'white',
            trackFillDisabled: 'gray',
            trackStroke: 'black',
            trackLineWidth: 1,
            trackCornerRadius: 0,
            trackPickable: true,
            thumbNode: null,
            thumbSize: null,
            thumbFill: 'rgb(50,145,184)',
            thumbFillHighlighted: 'rgb(71,207,255)',
            thumbStroke: 'black',
            thumbLineWidth: 1,
            thumbCenterLineStroke: 'white',
            thumbTouchAreaXDilation: 11,
            thumbTouchAreaYDilation: 11,
            thumbMouseAreaXDilation: 0,
            thumbMouseAreaYDilation: 0,
            thumbYOffset: 0,
            tickLabelSpacing: 6,
            positionLabel: (label, tickBounds)=>{
                label.centerX = tickBounds.centerX;
                label.bottom = tickBounds.top - options.tickLabelSpacing;
            },
            majorTickLength: 25,
            majorTickStroke: 'black',
            majorTickLineWidth: 1,
            minorTickLength: 10,
            minorTickStroke: 'black',
            minorTickLineWidth: 1,
            setTickInitialPoint: (trackBounds, tickLength)=>new Vector2(0, trackBounds.top),
            cursor: 'pointer',
            startDrag: _.noop,
            drag: _.noop,
            endDrag: _.noop,
            constrainValue: _.identity,
            disabledOpacity: SceneryConstants.DISABLED_OPACITY,
            soundGenerator: Slider.DEFAULT_SOUND_GENERATOR,
            valueChangeSoundGeneratorOptions: {},
            // phet-io
            phetioLinkedProperty: null,
            // Supertype options
            tandem: Tandem.REQUIRED,
            tandemNameSuffix: 'Slider',
            phetioType: Slider.SliderIO,
            phetioFeatured: true,
            visiblePropertyOptions: {
                phetioFeatured: true
            },
            phetioEnabledPropertyInstrumented: true // opt into default PhET-iO instrumented enabledProperty
        }, providedOptions);
        const rangeProperty = range instanceof Range ? new TinyProperty(range) : range;
        assert && assert(options.soundGenerator === Slider.DEFAULT_SOUND_GENERATOR || _.isEmpty(options.valueChangeSoundGeneratorOptions), 'options should only be supplied when using default sound generator');
        // If no sound generator was provided, create the default.
        if (options.soundGenerator === Slider.DEFAULT_SOUND_GENERATOR) {
            options.soundGenerator = new ValueChangeSoundPlayer(rangeProperty.value, options.valueChangeSoundGeneratorOptions || {});
        } else if (options.soundGenerator === null) {
            options.soundGenerator = ValueChangeSoundPlayer.NO_SOUND;
        }
        // Set up the drag handler to generate sound when drag events cause changes.
        if (options.soundGenerator !== ValueChangeSoundPlayer.NO_SOUND) {
            // variable to keep track of the value at the start of user drag interactions
            let previousValue = valueProperty.value;
            // Enhance the drag handler to perform sound generation.
            const providedDrag = options.drag;
            options.drag = (event)=>{
                if (event.isFromPDOM()) {
                    options.soundGenerator.playSoundForValueChange(valueProperty.value, previousValue);
                } else {
                    options.soundGenerator.playSoundIfThresholdReached(valueProperty.value, previousValue);
                }
                providedDrag(event);
                previousValue = valueProperty.value;
            };
        }
        if (options.orientation === Orientation.VERTICAL) {
            // For a vertical slider, the client should provide dimensions that are specific to a vertical slider.
            // But Slider expects dimensions for a horizontal slider, and then creates the vertical orientation using rotation.
            // So if the client provides any dimensions for a vertical slider, swap those dimensions to horizontal.
            if (options.trackSize) {
                options.trackSize = options.trackSize.swapped();
            }
            if (options.thumbSize) {
                options.thumbSize = options.thumbSize.swapped();
            }
            swapObjectKeys(options, 'thumbTouchAreaXDilation', 'thumbTouchAreaYDilation');
            swapObjectKeys(options, 'thumbMouseAreaXDilation', 'thumbMouseAreaYDilation');
        }
        options.trackSize = options.trackSize || DEFAULT_HORIZONTAL_TRACK_SIZE;
        options.thumbSize = options.thumbSize || DEFAULT_HORIZONTAL_THUMB_SIZE;
        const thumbTandem = options.tandem.createTandem(Slider.THUMB_NODE_TANDEM_NAME);
        if (Tandem.VALIDATION && options.thumbNode) {
            assert && assert(options.thumbNode.tandem.equals(thumbTandem), `Passed-in thumbNode must have the correct tandem. Expected: ${thumbTandem.phetioID}, actual: ${options.thumbNode.tandem.phetioID}`);
        }
        // The thumb of the slider
        const thumb = options.thumbNode || new SliderThumb({
            // propagate options that are specific to SliderThumb
            size: options.thumbSize,
            fill: options.thumbFill,
            fillHighlighted: options.thumbFillHighlighted,
            stroke: options.thumbStroke,
            lineWidth: options.thumbLineWidth,
            centerLineStroke: options.thumbCenterLineStroke,
            tandem: thumbTandem
        });
        const ownsEnabledRangeProperty = !options.enabledRangeProperty;
        const boundsRequiredOptionKeys = _.pick(options, Node.REQUIRES_BOUNDS_OPTION_KEYS);
        // Now add in the required options when passing to the super type
        const superOptions = combineOptions({
            ariaOrientation: options.orientation,
            valueProperty: valueProperty,
            panTargetNode: thumb,
            // controls the portion of the slider that is enabled
            enabledRangeProperty: options.enabledRangeProperty || (range instanceof Range ? new Property(range, {
                valueType: Range,
                isValidValue: (value)=>value.min >= range.min && value.max <= range.max,
                tandem: options.tandem.createTandem('enabledRangeProperty'),
                valueComparisonStrategy: 'equalsFunction',
                phetioValueType: Range.RangeIO,
                phetioDocumentation: 'Sliders support two ranges: the outer range which specifies the min and max of the track and ' + 'the enabledRangeProperty, which determines how low and high the thumb can be dragged within the track.'
            }) : range)
        }, options);
        super(superOptions), this.ticks = createObservableArray(), // If the user is holding down the thumb outside of the enabled range, and the enabled range expands, the value should
        // adjust to the new extremum of the range, see https://github.com/phetsims/mean-share-and-balance/issues/29
        // This value is set during thumb drag, or null if not currently being dragged.
        this.proposedValue = null;
        this.orientation = superOptions.orientation;
        this.enabledRangeProperty = superOptions.enabledRangeProperty;
        this.tickOptions = _.pick(options, 'tickLabelSpacing', 'majorTickLength', 'majorTickStroke', 'majorTickLineWidth', 'minorTickLength', 'minorTickStroke', 'minorTickLineWidth', 'setTickInitialPoint', 'positionLabel');
        const sliderParts = [];
        // ticks are added to these parents, so they are behind the knob
        this.majorTicksParent = new Node();
        this.minorTicksParent = new Node();
        sliderParts.push(this.majorTicksParent);
        sliderParts.push(this.minorTicksParent);
        const trackTandem = options.tandem.createTandem(Slider.TRACK_NODE_TANDEM_NAME);
        if (Tandem.VALIDATION && options.trackNode) {
            assert && assert(options.trackNode.tandem.equals(trackTandem), `Passed-in trackNode must have the correct tandem. Expected: ${trackTandem.phetioID}, actual: ${options.trackNode.tandem.phetioID}`);
        }
        const trackSpacer = new Node();
        sliderParts.push(trackSpacer);
        // Assertion to get around mutating the null-default based on the slider orientation.
        assert && assert(superOptions.trackSize, 'trackSize should not be null');
        this.track = options.trackNode || new DefaultSliderTrack(valueProperty, range, {
            // propagate options that are specific to SliderTrack
            size: superOptions.trackSize,
            fillEnabled: superOptions.trackFillEnabled,
            fillDisabled: superOptions.trackFillDisabled,
            stroke: superOptions.trackStroke,
            lineWidth: superOptions.trackLineWidth,
            cornerRadius: superOptions.trackCornerRadius,
            startDrag: superOptions.startDrag,
            drag: superOptions.drag,
            endDrag: superOptions.endDrag,
            constrainValue: superOptions.constrainValue,
            enabledRangeProperty: this.enabledRangeProperty,
            soundGenerator: options.soundGenerator,
            pickable: superOptions.trackPickable,
            voicingOnEndResponse: this.voicingOnEndResponse.bind(this),
            // phet-io
            tandem: trackTandem
        });
        // Add the track
        sliderParts.push(this.track);
        // Position the thumb vertically.
        thumb.setCenterY(this.track.centerY + options.thumbYOffset);
        sliderParts.push(thumb);
        // Wrap all of the slider parts in a Node, and set the orientation of that Node.
        // This allows us to still decorate the Slider with additional children.
        // See https://github.com/phetsims/sun/issues/406
        const sliderPartsNode = new Node({
            children: sliderParts
        });
        if (options.orientation === Orientation.VERTICAL) {
            sliderPartsNode.rotation = SunConstants.SLIDER_VERTICAL_ROTATION;
        }
        this.addChild(sliderPartsNode);
        // touchArea for the default thumb. If a custom thumb is provided, the client is responsible for its touchArea.
        if (!options.thumbNode && (options.thumbTouchAreaXDilation || options.thumbTouchAreaYDilation)) {
            thumb.touchArea = thumb.localBounds.dilatedXY(options.thumbTouchAreaXDilation, options.thumbTouchAreaYDilation);
        }
        // mouseArea for the default thumb. If a custom thumb is provided, the client is responsible for its mouseArea.
        if (!options.thumbNode && (options.thumbMouseAreaXDilation || options.thumbMouseAreaYDilation)) {
            thumb.mouseArea = thumb.localBounds.dilatedXY(options.thumbMouseAreaXDilation, options.thumbMouseAreaYDilation);
        }
        // update value when thumb is dragged
        let clickXOffset = 0; // x-offset between initial click and thumb's origin
        let valueOnStart = valueProperty.value; // For description so we can describe value changes between interactions
        const thumbDragListener = new DragListener({
            // Deviate from the variable name because we will nest this tandem under the thumb directly
            tandem: thumb.tandem.createTandem('dragListener'),
            start: (event, listener)=>{
                if (this.enabledProperty.get()) {
                    valueOnStart = valueProperty.value;
                    options.startDrag(event);
                    const transform = listener.pressedTrail.subtrailTo(sliderPartsNode).getTransform();
                    // Determine the offset relative to the center of the thumb
                    clickXOffset = transform.inversePosition2(event.pointer.point).x - thumb.centerX;
                }
            },
            drag: (event, listener)=>{
                if (this.enabledProperty.get()) {
                    const transform = listener.pressedTrail.subtrailTo(sliderPartsNode).getTransform(); // we only want the transform to our parent
                    const x = transform.inversePosition2(event.pointer.point).x - clickXOffset;
                    this.proposedValue = this.track.valueToPositionProperty.value.inverse(x);
                    const valueInRange = this.enabledRangeProperty.get().constrainValue(this.proposedValue);
                    valueProperty.set(options.constrainValue(valueInRange));
                    // after valueProperty is set so listener can use the new value
                    options.drag(event);
                }
            },
            end: (event)=>{
                if (this.enabledProperty.get()) {
                    options.endDrag(event);
                    // voicing - Default behavior is to speak the new object response at the end of interaction. If you want to
                    // customize this response, you can modify supertype options VoicingOnEndResponseOptions.
                    this.voicingOnEndResponse(valueOnStart);
                }
                this.proposedValue = null;
            }
        });
        thumb.addInputListener(thumbDragListener);
        this.thumbDragListener = thumbDragListener;
        this.trackDragListener = this.track.dragListener;
        // update thumb position when value changes
        const valueMultilink = Multilink.multilink([
            valueProperty,
            this.track.valueToPositionProperty
        ], (value, valueToPosition)=>{
            thumb.centerX = valueToPosition.evaluate(value);
        });
        // when the enabled range changes, the value to position linear function must change as well
        const enabledRangeObserver = (enabledRange)=>{
            // When restoring PhET-iO state, prevent the clamp from setting a stale, incorrect value to a deferred Property
            // (which may have already restored the correct value from phet-io state), see https://github.com/phetsims/mean-share-and-balance/issues/21
            if (!valueProperty.isPhetioInstrumented() || !isSettingPhetioStateProperty.value) {
                if (this.proposedValue === null) {
                    // clamp the current value to the enabled range if it changes
                    valueProperty.set(Utils.clamp(valueProperty.value, enabledRange.min, enabledRange.max));
                } else {
                    // The user is holding the thumb, which may be outside the enabledRange.  In that case, expanding the range
                    // could accommodate the outer value
                    const proposedValueInEnabledRange = Utils.clamp(this.proposedValue, enabledRange.min, enabledRange.max);
                    const proposedValueInConstrainedRange = options.constrainValue(proposedValueInEnabledRange);
                    valueProperty.set(proposedValueInConstrainedRange);
                }
            }
        };
        this.enabledRangeProperty.link(enabledRangeObserver); // needs to be unlinked in dispose function
        const constraint = new SliderConstraint(this, this.track, thumb, sliderPartsNode, options.orientation, trackSpacer, this.ticks);
        this.disposeSlider = ()=>{
            constraint.dispose();
            thumb.dispose && thumb.dispose(); // in case a custom thumb is provided via options.thumbNode that doesn't implement dispose
            this.track.dispose && this.track.dispose();
            if (ownsEnabledRangeProperty) {
                this.enabledRangeProperty.dispose();
            } else {
                this.enabledRangeProperty.unlink(enabledRangeObserver);
            }
            valueMultilink.dispose();
            thumbDragListener.dispose();
        };
        // pdom - custom focus highlight that surrounds and moves with the thumb
        this.focusHighlight = new HighlightFromNode(thumb);
        assert && Tandem.VALIDATION && assert(!options.phetioLinkedProperty || options.phetioLinkedProperty.isPhetioInstrumented(), 'If provided, phetioLinkedProperty should be PhET-iO instrumented');
        // Must happen after instrumentation (in super call)
        const linkedProperty = options.phetioLinkedProperty || (valueProperty instanceof ReadOnlyProperty ? valueProperty : null);
        if (linkedProperty) {
            this.addLinkedElement(linkedProperty, {
                tandemName: 'valueProperty'
            });
        }
        // must be after the button is instrumented
        // assert && assert( !this.isPhetioInstrumented() || this.enabledRangeProperty.isPhetioInstrumented() );
        !ownsEnabledRangeProperty && this.enabledRangeProperty instanceof ReadOnlyProperty && this.addLinkedElement(this.enabledRangeProperty, {
            tandemName: 'enabledRangeProperty'
        });
        this.mutate(boundsRequiredOptionKeys);
        // Decorating the with additional content is bad for dynamic layout, see https://github.com/phetsims/sun/issues/860
        assert && assertNoAdditionalChildren(this);
        // support for binder documentation, stripped out in builds and only runs when ?binder is specified
        assert && ((_window_phet = window.phet) == null ? void 0 : (_window_phet_chipper = _window_phet.chipper) == null ? void 0 : (_window_phet_chipper_queryParameters = _window_phet_chipper.queryParameters) == null ? void 0 : _window_phet_chipper_queryParameters.binder) && InstanceRegistry.registerDataURL('sun', 'Slider', this);
    }
};
// The default sound used if options.soundGenerator is not set.
Slider.DEFAULT_SOUND_GENERATOR = new ValueChangeSoundPlayer(new Range(0, 1));
// standardized tandem names, see https://github.com/phetsims/sun/issues/694
Slider.THUMB_NODE_TANDEM_NAME = 'thumbNode';
Slider.TRACK_NODE_TANDEM_NAME = 'trackNode';
Slider.SliderIO = new IOType('SliderIO', {
    valueType: Slider,
    documentation: 'A traditional slider component, with a knob and possibly tick marks',
    supertype: Node.NodeIO
});
export { Slider as default };
let SliderConstraint = class SliderConstraint extends LayoutConstraint {
    layout() {
        super.layout();
        const slider = this.slider;
        const track = this.track;
        const thumb = this.thumb;
        // Dilate the local bounds horizontally so that it extends beyond where the thumb can reach.  This prevents layout
        // asymmetry when the slider thumb is off the edges of the track.  See https://github.com/phetsims/sun/issues/282
        this.trackSpacer.localBounds = track.localBounds.dilatedX(thumb.width / 2);
        assert && assert(track.minimumWidth !== null);
        // Our track's (exterior) minimum width will INCLUDE "visual overflow" e.g. stroke. The actual range used for
        // computation of where the thumb/ticks go will be the "interior" width (excluding the visual overflow), e.g.
        // without the stroke. We'll need to track and handle these separately, and only handle tick positioning based on
        // the interior width.
        const totalOverflow = track.leftVisualOverflow + track.rightVisualOverflow;
        const trackMinimumExteriorWidth = track.minimumWidth;
        const trackMinimumInteriorWidth = trackMinimumExteriorWidth - totalOverflow;
        // Takes a tick's value into the [0,1] range. This should be multiplied times the potential INTERIOR track width
        // in order to get the position the tick should be at.
        const normalizeTickValue = (value)=>{
            return Utils.linear(track.rangeProperty.value.min, track.rangeProperty.value.max, 0, 1, value);
        };
        // NOTE: Due to visual overflow, our track's range (including the thumb extension) will actually go from
        // ( -thumb.width / 2 - track.leftVisualOverflow ) on the left to
        // ( trackExteriorWidth + thumb.width / 2 + track.rightVisualOverflow ) on the right.
        // This is because our track's width is reduced to account for stroke, but the logical rectangle is still located
        // at x=0, meaning the stroke (with lineWidth=1) will typically go out to -0.5 (negative left visual overflow).
        // Our horizontal bounds are thus effectively offset by this left visual overflow amount.
        // NOTE: This actually goes PAST where the thumb should go when there is visual overflow, but we also
        // included this "imprecision" in the past (localBounds INCLUDING the stroke was dilated by the thumb width), so we
        // will have a slight bit of additional padding included here.
        // NOTE: Documentation was added before dynamic layout integration (noting the extension BEYOND the bounds):
        // > Dilate the local bounds horizontally so that it extends beyond where the thumb can reach.  This prevents layout
        // > asymmetry when the slider thumb is off the edges of the track.  See https://github.com/phetsims/sun/issues/282
        const leftExteriorOffset = -thumb.width / 2 - track.leftVisualOverflow;
        const rightExteriorOffset = thumb.width / 2 - track.leftVisualOverflow;
        // Start with the size our minimum track would be WITH the added spacing for the thumb
        // NOTE: will be mutated below
        const minimumRange = new Range(leftExteriorOffset, trackMinimumExteriorWidth + rightExteriorOffset);
        // We'll need to consider where the ticks would be IF we had our minimum size (since the ticks would potentially
        // be spaced closer together). So we'll check the bounds of each tick if it was at that location, and
        // ensure that ticks are included in our minimum range (since tick labels may stick out past the track).
        this.ticks.forEach((tick)=>{
            // Where the tick will be if we have our minimum size
            const tickMinimumPosition = trackMinimumInteriorWidth * normalizeTickValue(tick.value);
            // Adjust the minimum range to include the tick.
            const halfTickWidth = tick.tickNode.width / 2;
            // The tick will be centered
            minimumRange.includeRange(new Range(-halfTickWidth, halfTickWidth).shifted(tickMinimumPosition));
        });
        if (slider.widthSizable && this.preferredProperty.value !== null) {
            // Here's where things get complicated! Above, it's fairly easy to go from "track exterior width" => "slider width",
            // however we need to do the opposite (when our horizontal slider has a preferred width, we need to compute what
            // track width we'll have to make that happen). As I noted in the issue for this work:
            // There's a fun linear optimization problem hiding in plain sight (perhaps a high-performance iterative solution will work):
            // - We can compute a minimum size (given the minimum track size, see where the tick labels go, and include those).
            // - HOWEVER adjusting the track size ALSO adjusts how much the tick labels stick out to the sides (the expansion
            //   of the track will push the tick labels away from the edges).
            // - Different ticks will be the limiting factor for the bounds at different track sizes (a tick label on the very
            //   end should not vary the bounds offset, but a tick label that's larger but slightly offset from the edge WILL
            //   vary the offset)
            // - So it's easy to compute the resulting size from the track size, BUT the inverse problem is more difficult.
            //   Essentially we have a convex piecewise-linear function mapping track size to output size (implicitly defined
            //   by where tick labels swap being the limiting factor), and we need to invert it.
            // Effectively the "track width" => "slider width" is a piecewise-linear function, where the breakpoints occur
            // where ONE tick either becomes the limiting factor or stops being the limiting factor. Mathematically, this works
            // out to be based on the following formulas:
            // The LEFT x is the minimum of all the following:
            //   -thumb.width / 2 - track.leftVisualOverflow
            //   FOR EVERY TICK: -tickWidth / 2 + ( trackWidth - overflow ) * normalizedTickValue
            // The RIGHT x is the maximum of all the following:
            //   trackWidth + thumb.width / 2 - track.leftVisualOverflow
            //   (for every tick) tickWidth / 2 + ( trackWidth - overflow ) * normalizedTickValue
            // NOTE: the "trackWidth - overflow" is the INTERNAL width (not including the stroke) that we use for tick
            // computation
            // This effectively computes how far everything "sticks out" and would affect the bounds.
            //
            // The TOTAL width of the slider will simply be the above RIGHT - LEFT.
            // Instead of using numerical solutions, we're able to solve this analytically with piecewise-linear functions that
            // implement the above functions. We'll consider each of those individual functions as a linear function where
            // the input is the exterior track length, e.g. f(trackLength) = A * trackLength + B, for given A,B values.
            // By min/max-ing these together and then taking the difference, we'll have an accurate function of
            // f(trackLength) = sliderWidth. Then we'll invert that function, e.g. f^-1(sliderWidth) = trackLength, and then
            // we'll be able to pass in our preferred slider width in order to compute the preferred track length.
            // We'll need to factor the trackWidth out for the tick functions, so:
            // LEFT tick computations:
            //   -tickWidth / 2 + ( trackWidth - overflow ) * normalizedTickValue
            // = -tickWidth / 2 + trackWidth * normalizedTickValue - overflow * normalizedTickValue
            // = normalizedTickValue * trackWidth + ( -tickWidth / 2 - overflow * normalizedTickValue )
            // So when we put it in the form of A * trackWidth + B, we get:
            //   A = normalizedTickValue, B = -tickWidth / 2 - overflow * normalizedTickValue
            // Similarly happens for the RIGHT tick computation.
            const trackWidthToFullWidthFunction = CompletePiecewiseLinearFunction.max(// Right side (track/thumb)
            CompletePiecewiseLinearFunction.linear(1, rightExteriorOffset), // Right side (ticks)
            ...this.ticks.map((tick)=>{
                const normalizedTickValue = normalizeTickValue(tick.value);
                return CompletePiecewiseLinearFunction.linear(normalizedTickValue, tick.tickNode.width / 2 - totalOverflow * normalizedTickValue);
            })).minus(CompletePiecewiseLinearFunction.min(// Left side (track/thumb)
            CompletePiecewiseLinearFunction.constant(leftExteriorOffset), // Left side (ticks)
            ...this.ticks.map((tick)=>{
                const normalizedTickValue = normalizeTickValue(tick.value);
                return CompletePiecewiseLinearFunction.linear(normalizedTickValue, -tick.tickNode.width / 2 - totalOverflow * normalizedTickValue);
            })));
            // NOTE: This function is only monotonically increasing when trackWidth is positive! We'll drop the values
            // underneath our minimum track width (they won't be needed), but we'll need to add an extra point below to ensure
            // that the slope is maintained (due to how CompletePiecewiseLinearFunction works).
            const fullWidthToTrackWidthFunction = trackWidthToFullWidthFunction.withXValues([
                trackMinimumExteriorWidth - 1,
                trackMinimumExteriorWidth,
                ...trackWidthToFullWidthFunction.points.map((point)=>point.x).filter((x)=>x > trackMinimumExteriorWidth + 1e-10)
            ]).inverted();
            track.preferredWidth = Math.max(// Ensure we're NOT dipping below the minimum track width (for some reason).
            trackMinimumExteriorWidth, fullWidthToTrackWidthFunction.evaluate(this.preferredProperty.value));
        } else {
            track.preferredWidth = track.minimumWidth;
        }
        const minimumWidth = minimumRange.getLength();
        // Set minimums at the end
        if (this.orientation === Orientation.HORIZONTAL) {
            slider.localMinimumWidth = minimumWidth;
        } else {
            slider.localMinimumHeight = minimumWidth;
        }
    }
    dispose() {
        this.disposeSliderConstraint();
        super.dispose();
    }
    constructor(slider, track, thumb, sliderPartsNode, orientation, trackSpacer, ticks){
        super(slider), this.slider = slider, this.track = track, this.thumb = thumb, this.sliderPartsNode = sliderPartsNode, this.orientation = orientation, this.trackSpacer = trackSpacer, this.ticks = ticks;
        // We need to make it sizable in both dimensions (VSlider vs HSlider), but we'll still want to make the opposite
        // axis non-sizable (since it won't be sizable in both orientations at once).
        if (orientation === Orientation.HORIZONTAL) {
            slider.heightSizable = false;
            this.preferredProperty = this.slider.localPreferredWidthProperty;
        } else {
            slider.widthSizable = false;
            this.preferredProperty = this.slider.localPreferredHeightProperty;
        }
        this.preferredProperty.lazyLink(this._updateLayoutListener);
        // So range changes or minimum changes will trigger layouts (since they can move ticks)
        this.track.rangeProperty.lazyLink(this._updateLayoutListener);
        // Thumb size changes should trigger layout, since we check the width of the thumb
        // NOTE: This is ignoring thumb scale changing, but for performance/correctness it makes sense to avoid that for now
        // so we can rule out infinite loops of thumb movement.
        this.thumb.localBoundsProperty.lazyLink(this._updateLayoutListener);
        // As ticks are added, add a listener to each that will update the layout if the tick's bounds changes.
        const tickAddedListener = (addedTick)=>{
            addedTick.tickNode.localBoundsProperty.lazyLink(this._updateLayoutListener);
            ticks.addItemRemovedListener((removedTick)=>{
                if (removedTick === addedTick && removedTick.tickNode.localBoundsProperty.hasListener(this._updateLayoutListener)) {
                    addedTick.tickNode.localBoundsProperty.unlink(this._updateLayoutListener);
                }
            });
        };
        ticks.addItemAddedListener(tickAddedListener);
        this.addNode(track);
        this.layout();
        this.disposeSliderConstraint = ()=>{
            ticks.removeItemAddedListener(tickAddedListener);
            this.preferredProperty.unlink(this._updateLayoutListener);
            this.track.rangeProperty.unlink(this._updateLayoutListener);
            this.thumb.localBoundsProperty.unlink(this._updateLayoutListener);
        };
    }
};
sun.register('Slider', Slider);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3N1bi9qcy9TbGlkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogU2xpZGVyLCB3aXRoIHN1cHBvcnQgZm9yIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG9yaWVudGF0aW9ucy4gQnkgZGVmYXVsdCwgdGhlIHNsaWRlciBpcyBjb25zdHJ1Y3RlZCBpbiB0aGVcbiAqIGhvcml6b250YWwgb3JpZW50YXRpb24sIHRoZW4gYWRqdXN0ZWQgaWYgdGhlIHZlcnRpY2FsIG9yaWVudGF0aW9uIHdhcyBzcGVjaWZpZWQuXG4gKlxuICogTm90ZTogVGhpcyB0eXBlIHdhcyBvcmlnaW5hbGx5IG5hbWVkIEhTbGlkZXIsIHJlbmFtZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvMzgwLlxuICpcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXG4gKi9cblxuaW1wb3J0IGNyZWF0ZU9ic2VydmFibGVBcnJheSwgeyBPYnNlcnZhYmxlQXJyYXkgfSBmcm9tICcuLi8uLi9heG9uL2pzL2NyZWF0ZU9ic2VydmFibGVBcnJheS5qcyc7XG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcbmltcG9ydCBQaGV0aW9Qcm9wZXJ0eSBmcm9tICcuLi8uLi9heG9uL2pzL1BoZXRpb1Byb3BlcnR5LmpzJztcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcbmltcG9ydCBSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgVGlueVByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvVGlueVByb3BlcnR5LmpzJztcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xuaW1wb3J0IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24gZnJvbSAnLi4vLi4vZG90L2pzL0NvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24uanMnO1xuaW1wb3J0IERpbWVuc2lvbjIgZnJvbSAnLi4vLi4vZG90L2pzL0RpbWVuc2lvbjIuanMnO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcbmltcG9ydCBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL2Fzc2VydE11dHVhbGx5RXhjbHVzaXZlT3B0aW9ucy5qcyc7XG5pbXBvcnQgSW5zdGFuY2VSZWdpc3RyeSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvZG9jdW1lbnRhdGlvbi9JbnN0YW5jZVJlZ2lzdHJ5LmpzJztcbmltcG9ydCBvcHRpb25pemUsIHsgY29tYmluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xuaW1wb3J0IHN3YXBPYmplY3RLZXlzIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9zd2FwT2JqZWN0S2V5cy5qcyc7XG5pbXBvcnQgUGlja09wdGlvbmFsIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9QaWNrT3B0aW9uYWwuanMnO1xuaW1wb3J0IFBpY2tSZXF1aXJlZCBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvUGlja1JlcXVpcmVkLmpzJztcbmltcG9ydCBTdHJpY3RPbWl0IGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9TdHJpY3RPbWl0LmpzJztcbmltcG9ydCB7IGFzc2VydE5vQWRkaXRpb25hbENoaWxkcmVuLCBEcmFnTGlzdGVuZXIsIEhpZ2hsaWdodEZyb21Ob2RlLCBMYXlvdXRDb25zdHJhaW50LCBOb2RlLCBOb2RlT3B0aW9ucywgU2NlbmVyeUNvbnN0YW50cywgU2l6YWJsZSwgU2l6YWJsZU9wdGlvbnMsIFRQYWludCB9IGZyb20gJy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XG5pbXBvcnQgVmFsdWVDaGFuZ2VTb3VuZFBsYXllciwgeyBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL3RhbWJvL2pzL3NvdW5kLWdlbmVyYXRvcnMvVmFsdWVDaGFuZ2VTb3VuZFBsYXllci5qcyc7XG5pbXBvcnQgaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eSBmcm9tICcuLi8uLi90YW5kZW0vanMvaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgUGhldGlvT2JqZWN0IGZyb20gJy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XG5pbXBvcnQgQWNjZXNzaWJsZVNsaWRlciwgeyBBY2Nlc3NpYmxlU2xpZGVyT3B0aW9ucyB9IGZyb20gJy4vYWNjZXNzaWJpbGl0eS9BY2Nlc3NpYmxlU2xpZGVyLmpzJztcbmltcG9ydCBEZWZhdWx0U2xpZGVyVHJhY2sgZnJvbSAnLi9EZWZhdWx0U2xpZGVyVHJhY2suanMnO1xuaW1wb3J0IFNsaWRlclRodW1iIGZyb20gJy4vU2xpZGVyVGh1bWIuanMnO1xuaW1wb3J0IFNsaWRlclRpY2ssIHsgU2xpZGVyVGlja09wdGlvbnMgfSBmcm9tICcuL1NsaWRlclRpY2suanMnO1xuaW1wb3J0IFNsaWRlclRyYWNrIGZyb20gJy4vU2xpZGVyVHJhY2suanMnO1xuaW1wb3J0IHN1biBmcm9tICcuL3N1bi5qcyc7XG5pbXBvcnQgU3VuQ29uc3RhbnRzIGZyb20gJy4vU3VuQ29uc3RhbnRzLmpzJztcblxuLy8gY29uc3RhbnRzXG5jb25zdCBERUZBVUxUX0hPUklaT05UQUxfVFJBQ0tfU0laRSA9IG5ldyBEaW1lbnNpb24yKCAxMDAsIDUgKTtcbmNvbnN0IERFRkFVTFRfSE9SSVpPTlRBTF9USFVNQl9TSVpFID0gbmV3IERpbWVuc2lvbjIoIDE3LCAzNCApO1xuXG50eXBlIFNlbGZPcHRpb25zID0ge1xuICBvcmllbnRhdGlvbj86IE9yaWVudGF0aW9uO1xuXG4gIC8vIG9wdGlvbmFsIHRyYWNrLCByZXBsYWNlcyB0aGUgZGVmYXVsdC5cbiAgLy8gQ2xpZW50IGlzIHJlc3BvbnNpYmxlIGZvciBoaWdobGlnaHRpbmcsIGRpc2FibGUgYW5kIHBvaW50ZXIgYXJlYXMuXG4gIC8vIEZvciBpbnN0cnVtZW50ZWQgU2xpZGVycywgYSBzdXBwbGllZCB0cmFja05vZGUgbXVzdCBiZSBpbnN0cnVtZW50ZWQuXG4gIC8vIFRoZSB0YW5kZW0gY29tcG9uZW50IG5hbWUgbXVzdCBiZSBTbGlkZXIuVFJBQ0tfTk9ERV9UQU5ERU1fTkFNRSBhbmQgaXQgbXVzdCBiZSBuZXN0ZWQgdW5kZXIgdGhlIFNsaWRlciB0YW5kZW0uXG4gIHRyYWNrTm9kZT86IFNsaWRlclRyYWNrIHwgbnVsbDtcblxuICAvLyB0cmFjayAtIG9wdGlvbnMgdG8gY3JlYXRlIGEgU2xpZGVyVHJhY2sgaWYgdHJhY2tOb2RlIG5vdCBzdXBwbGllZFxuICB0cmFja1NpemU/OiBEaW1lbnNpb24yIHwgbnVsbDsgLy8gc3BlY2lmaWMgdG8gb3JpZW50YXRpb24sIHdpbGwgYmUgZmlsbGVkIGluIHdpdGggYSBkZWZhdWx0IGlmIG5vdCBwcm92aWRlZFxuICB0cmFja0ZpbGxFbmFibGVkPzogVFBhaW50O1xuICB0cmFja0ZpbGxEaXNhYmxlZD86IFRQYWludDtcbiAgdHJhY2tTdHJva2U/OiBUUGFpbnQ7XG4gIHRyYWNrTGluZVdpZHRoPzogbnVtYmVyO1xuICB0cmFja0Nvcm5lclJhZGl1cz86IG51bWJlcjtcbiAgdHJhY2tQaWNrYWJsZT86IGJvb2xlYW47IC8vIE1heSBiZSBzZXQgdG8gZmFsc2UgaWYgYSBzbGlkZXIgdHJhY2sgaXMgbm90IHZpc2libGUgYW5kIHVzZXIgaW50ZXJhY3Rpb24gaXMgdGhlcmVmb3JlIHVuZGVzaXJhYmxlLlxuXG4gIC8vIG9wdGlvbmFsIHRodW1iLCByZXBsYWNlcyB0aGUgZGVmYXVsdC5cbiAgLy8gQ2xpZW50IGlzIHJlc3BvbnNpYmxlIGZvciBoaWdobGlnaHRpbmcsIGRpc2FibGluZyBhbmQgcG9pbnRlciBhcmVhcy5cbiAgLy8gVGhlIHRodW1iIGlzIHBvc2l0aW9uZWQgYmFzZWQgb24gaXRzIGNlbnRlciBhbmQgaGVuY2UgY2FuIGhhdmUgaXRzIG9yaWdpbiBhbnl3aGVyZVxuICAvLyBOb3RlIGZvciBQaEVULUlPOiBUaGlzIHRodW1iTm9kZSBzaG91bGQgYmUgaW5zdHJ1bWVudGVkLiBUaGUgdGh1bWIncyBkcmFnTGlzdGVuZXIgaXMgaW5zdHJ1bWVudGVkIHVuZGVybmVhdGhcbiAgLy8gdGhpcyB0aHVtYk5vZGUuIFRoZSB0YW5kZW0gY29tcG9uZW50IG5hbWUgbXVzdCBiZSBTbGlkZXIuVEhVTUJfTk9ERV9UQU5ERU1fTkFNRSBhbmQgaXQgbXVzdCBiZSBuZXN0ZWQgdW5kZXJcbiAgLy8gdGhlIFNsaWRlciB0YW5kZW0uXG4gIHRodW1iTm9kZT86IE5vZGUgfCBudWxsO1xuXG4gIC8vIE9wdGlvbnMgZm9yIHRoZSBkZWZhdWx0IHRodW1iLCBpZ25vcmVkIGlmIHRodW1iTm9kZSBpcyBzZXRcbiAgdGh1bWJTaXplPzogRGltZW5zaW9uMiB8IG51bGw7IC8vIHNwZWNpZmljIHRvIG9yaWVudGF0aW9uLCB3aWxsIGJlIGZpbGxlZCBpbiB3aXRoIGEgZGVmYXVsdCBpZiBub3QgcHJvdmlkZWRcbiAgdGh1bWJGaWxsPzogVFBhaW50O1xuICB0aHVtYkZpbGxIaWdobGlnaHRlZD86IFRQYWludDtcbiAgdGh1bWJTdHJva2U/OiBUUGFpbnQ7XG4gIHRodW1iTGluZVdpZHRoPzogbnVtYmVyO1xuICB0aHVtYkNlbnRlckxpbmVTdHJva2U/OiBUUGFpbnQ7XG5cbiAgLy8gZGlsYXRpb25zIGFyZSBzcGVjaWZpYyB0byBvcmllbnRhdGlvblxuICB0aHVtYlRvdWNoQXJlYVhEaWxhdGlvbj86IG51bWJlcjtcbiAgdGh1bWJUb3VjaEFyZWFZRGlsYXRpb24/OiBudW1iZXI7XG4gIHRodW1iTW91c2VBcmVhWERpbGF0aW9uPzogbnVtYmVyO1xuICB0aHVtYk1vdXNlQXJlYVlEaWxhdGlvbj86IG51bWJlcjtcblxuICAvLyBBcHBsaWVkIHRvIGRlZmF1bHQgb3Igc3VwcGxpZWQgdGh1bWJcbiAgdGh1bWJZT2Zmc2V0PzogbnVtYmVyOyAvLyBjZW50ZXIgb2YgdGhlIHRodW1iIGlzIHZlcnRpY2FsbHkgb2Zmc2V0IGJ5IHRoaXMgYW1vdW50IGZyb20gdGhlIGNlbnRlciBvZiB0aGUgdHJhY2tcblxuICBjdXJzb3I/OiBzdHJpbmc7XG5cbiAgLy8gb3BhY2l0eSBhcHBsaWVkIHRvIHRoZSBlbnRpcmUgU2xpZGVyIHdoZW4gZGlzYWJsZWRcbiAgZGlzYWJsZWRPcGFjaXR5PzogbnVtYmVyO1xuXG4gIC8vIElmIHByb3ZpZGVkLCBjcmVhdGUgYSBMaW5rZWRFbGVtZW50IGZvciB0aGlzIFBoRVQtaU8gaW5zdHJ1bWVudGVkIFByb3BlcnR5LCBpbnN0ZWFkXG4gIC8vIG9mIHVzaW5nIHRoZSBwYXNzZWQgaW4gUHJvcGVydHkuIFRoaXMgb3B0aW9uIHdhcyBjcmVhdGVkIHRvIHN1cHBvcnQgcGFzc2luZyBEeW5hbWljUHJvcGVydHkgb3IgXCJ3cmFwcGluZ1wiXG4gIC8vIFByb3BlcnR5IHRoYXQgYXJlIFwiaW1wbGVtZW50YXRpb24gIGRldGFpbHNcIiB0byB0aGUgUGhFVC1pTyBBUEksIGFuZCBzdGlsbCBzdXBwb3J0IGhhdmluZyBhIExpbmtlZEVsZW1lbnQgdGhhdFxuICAvLyBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgbW9kZWwgUHJvcGVydHkuXG4gIHBoZXRpb0xpbmtlZFByb3BlcnR5PzogUGhldGlvT2JqZWN0IHwgbnVsbDtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8gZ2VuZXJhdGUgc291bmRzIGFzIHRoZSBzbGlkZXIgaXMgbW92ZWQgYnkgdGhlIHVzZXIuICBJZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNvdW5kIGdlbmVyYXRvclxuICAvLyB3aWxsIGJlIGNyZWF0ZWQuIElmIHNldCB0byBudWxsLCB0aGUgc2xpZGVyIHdpbGwgZ2VuZXJhdGUgbm8gc291bmQuXG4gIHNvdW5kR2VuZXJhdG9yPzogVmFsdWVDaGFuZ2VTb3VuZFBsYXllciB8IG51bGw7XG5cbiAgLy8gT3B0aW9ucyBmb3IgdGhlIGRlZmF1bHQgc291bmQgZ2VuZXJhdG9yLiAgVGhlc2Ugc2hvdWxkIG9ubHkgYmUgcHJvdmlkZWQgd2hlbiB1c2luZyB0aGUgZGVmYXVsdC5cbiAgdmFsdWVDaGFuZ2VTb3VuZEdlbmVyYXRvck9wdGlvbnM/OiBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucztcbn0gJiBTbGlkZXJUaWNrT3B0aW9ucztcblxudHlwZSBQYXJlbnRPcHRpb25zID0gQWNjZXNzaWJsZVNsaWRlck9wdGlvbnMgJiBOb2RlT3B0aW9ucyAmIFNpemFibGVPcHRpb25zO1xuXG50eXBlIFJlcXVpcmVkUGFyZW50T3B0aW9uc1N1cHBsaWVkQnlTbGlkZXIgPSAncGFuVGFyZ2V0Tm9kZScgfCAndmFsdWVQcm9wZXJ0eScgfCAnZW5hYmxlZFJhbmdlUHJvcGVydHknIHwgJ2FyaWFPcmllbnRhdGlvbic7XG50eXBlIE9wdGlvbmFsUGFyZW50T3B0aW9ucyA9IFN0cmljdE9taXQ8UGFyZW50T3B0aW9ucywgUmVxdWlyZWRQYXJlbnRPcHRpb25zU3VwcGxpZWRCeVNsaWRlcj47XG5cbi8vIFdlIHByb3ZpZGUgdGhlc2Ugb3B0aW9ucyB0byB0aGUgc3VwZXIsIGFsc28gZW5hYmxlZFJhbmdlUHJvcGVydHkgaXMgdHVybmVkIGZyb20gcmVxdWlyZWQgdG8gb3B0aW9uYWxcbmV4cG9ydCB0eXBlIFNsaWRlck9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIE9wdGlvbmFsUGFyZW50T3B0aW9ucyAmIFBpY2tPcHRpb25hbDxQYXJlbnRPcHRpb25zLCAnZW5hYmxlZFJhbmdlUHJvcGVydHknPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgU2l6YWJsZSggQWNjZXNzaWJsZVNsaWRlciggTm9kZSwgMCApICkge1xuXG4gIHB1YmxpYyByZWFkb25seSBlbmFibGVkUmFuZ2VQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+O1xuXG4gIC8vIHB1YmxpYyBzbyB0aGF0IGNsaWVudHMgY2FuIGFjY2VzcyBQcm9wZXJ0aWVzIG9mIHRoZXNlIERyYWdMaXN0ZW5lcnMgdGhhdCB0ZWxsIHVzIGFib3V0IGl0cyBzdGF0ZVxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjgwXG4gIHB1YmxpYyByZWFkb25seSB0aHVtYkRyYWdMaXN0ZW5lcjogRHJhZ0xpc3RlbmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgdHJhY2tEcmFnTGlzdGVuZXI6IERyYWdMaXN0ZW5lcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbjtcblxuICAvLyBvcHRpb25zIG5lZWRlZCBieSBwcm90b3R5cGUgZnVuY3Rpb25zIHRoYXQgYWRkIHRpY2tzXG4gIHByaXZhdGUgcmVhZG9ubHkgdGlja09wdGlvbnM6IFJlcXVpcmVkPFNsaWRlclRpY2tPcHRpb25zPjtcblxuICAvLyB0aWNrcyBhcmUgYWRkZWQgdG8gdGhlc2UgcGFyZW50cywgc28gdGhleSBhcmUgYmVoaW5kIHRoZSBrbm9iXG4gIHByaXZhdGUgcmVhZG9ubHkgbWFqb3JUaWNrc1BhcmVudDogTm9kZTtcbiAgcHJpdmF0ZSByZWFkb25seSBtaW5vclRpY2tzUGFyZW50OiBOb2RlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhY2s6IFNsaWRlclRyYWNrO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgZGlzcG9zZVNsaWRlcjogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IHRpY2tzOiBPYnNlcnZhYmxlQXJyYXk8U2xpZGVyVGljaz4gPSBjcmVhdGVPYnNlcnZhYmxlQXJyYXkoKTtcblxuICAvLyBUaGUgZGVmYXVsdCBzb3VuZCB1c2VkIGlmIG9wdGlvbnMuc291bmRHZW5lcmF0b3IgaXMgbm90IHNldC5cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX1NPVU5EX0dFTkVSQVRPUiA9IG5ldyBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyKCBuZXcgUmFuZ2UoIDAsIDEgKSApO1xuXG4gIC8vIElmIHRoZSB1c2VyIGlzIGhvbGRpbmcgZG93biB0aGUgdGh1bWIgb3V0c2lkZSBvZiB0aGUgZW5hYmxlZCByYW5nZSwgYW5kIHRoZSBlbmFibGVkIHJhbmdlIGV4cGFuZHMsIHRoZSB2YWx1ZSBzaG91bGRcbiAgLy8gYWRqdXN0IHRvIHRoZSBuZXcgZXh0cmVtdW0gb2YgdGhlIHJhbmdlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL21lYW4tc2hhcmUtYW5kLWJhbGFuY2UvaXNzdWVzLzI5XG4gIC8vIFRoaXMgdmFsdWUgaXMgc2V0IGR1cmluZyB0aHVtYiBkcmFnLCBvciBudWxsIGlmIG5vdCBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZC5cbiAgcHJpdmF0ZSBwcm9wb3NlZFZhbHVlOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIHZhbHVlUHJvcGVydHk6IFBoZXRpb1Byb3BlcnR5PG51bWJlcj4sXG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlIHwgVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkT3B0aW9ucz86IFNsaWRlck9wdGlvbnMgKSB7XG5cbiAgICAvLyBHdWFyZCBhZ2FpbnN0IG11dHVhbGx5IGV4Y2x1c2l2ZSBvcHRpb25zIGJlZm9yZSBkZWZhdWx0cyBhcmUgZmlsbGVkIGluLlxuICAgIGFzc2VydCAmJiBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMoIHByb3ZpZGVkT3B0aW9ucywgWyAndGh1bWJOb2RlJyBdLCBbXG4gICAgICAndGh1bWJTaXplJywgJ3RodW1iRmlsbCcsICd0aHVtYkZpbGxIaWdobGlnaHRlZCcsICd0aHVtYlN0cm9rZScsICd0aHVtYkxpbmVXaWR0aCcsICd0aHVtYkNlbnRlckxpbmVTdHJva2UnLFxuICAgICAgJ3RodW1iVG91Y2hBcmVhWERpbGF0aW9uJywgJ3RodW1iVG91Y2hBcmVhWURpbGF0aW9uJywgJ3RodW1iTW91c2VBcmVhWERpbGF0aW9uJywgJ3RodW1iTW91c2VBcmVhWURpbGF0aW9uJ1xuICAgIF0gKTtcblxuICAgIGFzc2VydCAmJiBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMoIHByb3ZpZGVkT3B0aW9ucywgWyAndHJhY2tOb2RlJyBdLCBbXG4gICAgICAndHJhY2tTaXplJywgJ3RyYWNrRmlsbEVuYWJsZWQnLCAndHJhY2tGaWxsRGlzYWJsZWQnLCAndHJhY2tTdHJva2UnLCAndHJhY2tMaW5lV2lkdGgnLCAndHJhY2tDb3JuZXJSYWRpdXMnIF0gKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8U2xpZGVyT3B0aW9ucywgU2VsZk9wdGlvbnMsIE9wdGlvbmFsUGFyZW50T3B0aW9ucz4oKSgge1xuXG4gICAgICBvcmllbnRhdGlvbjogT3JpZW50YXRpb24uSE9SSVpPTlRBTCxcbiAgICAgIHRyYWNrTm9kZTogbnVsbCxcblxuICAgICAgdHJhY2tTaXplOiBudWxsLFxuICAgICAgdHJhY2tGaWxsRW5hYmxlZDogJ3doaXRlJyxcbiAgICAgIHRyYWNrRmlsbERpc2FibGVkOiAnZ3JheScsXG4gICAgICB0cmFja1N0cm9rZTogJ2JsYWNrJyxcbiAgICAgIHRyYWNrTGluZVdpZHRoOiAxLFxuICAgICAgdHJhY2tDb3JuZXJSYWRpdXM6IDAsXG4gICAgICB0cmFja1BpY2thYmxlOiB0cnVlLFxuXG4gICAgICB0aHVtYk5vZGU6IG51bGwsXG5cbiAgICAgIHRodW1iU2l6ZTogbnVsbCxcbiAgICAgIHRodW1iRmlsbDogJ3JnYig1MCwxNDUsMTg0KScsXG4gICAgICB0aHVtYkZpbGxIaWdobGlnaHRlZDogJ3JnYig3MSwyMDcsMjU1KScsXG4gICAgICB0aHVtYlN0cm9rZTogJ2JsYWNrJyxcbiAgICAgIHRodW1iTGluZVdpZHRoOiAxLFxuICAgICAgdGh1bWJDZW50ZXJMaW5lU3Ryb2tlOiAnd2hpdGUnLFxuXG4gICAgICB0aHVtYlRvdWNoQXJlYVhEaWxhdGlvbjogMTEsXG4gICAgICB0aHVtYlRvdWNoQXJlYVlEaWxhdGlvbjogMTEsXG4gICAgICB0aHVtYk1vdXNlQXJlYVhEaWxhdGlvbjogMCxcbiAgICAgIHRodW1iTW91c2VBcmVhWURpbGF0aW9uOiAwLFxuXG4gICAgICB0aHVtYllPZmZzZXQ6IDAsXG5cbiAgICAgIHRpY2tMYWJlbFNwYWNpbmc6IDYsXG4gICAgICBwb3NpdGlvbkxhYmVsOiAoIGxhYmVsLCB0aWNrQm91bmRzICkgPT4ge1xuICAgICAgICBsYWJlbC5jZW50ZXJYID0gdGlja0JvdW5kcy5jZW50ZXJYO1xuICAgICAgICBsYWJlbC5ib3R0b20gPSB0aWNrQm91bmRzLnRvcCAtIG9wdGlvbnMudGlja0xhYmVsU3BhY2luZztcbiAgICAgIH0sXG4gICAgICBtYWpvclRpY2tMZW5ndGg6IDI1LFxuICAgICAgbWFqb3JUaWNrU3Ryb2tlOiAnYmxhY2snLFxuICAgICAgbWFqb3JUaWNrTGluZVdpZHRoOiAxLFxuICAgICAgbWlub3JUaWNrTGVuZ3RoOiAxMCxcbiAgICAgIG1pbm9yVGlja1N0cm9rZTogJ2JsYWNrJyxcbiAgICAgIG1pbm9yVGlja0xpbmVXaWR0aDogMSxcbiAgICAgIHNldFRpY2tJbml0aWFsUG9pbnQ6ICggdHJhY2tCb3VuZHMsIHRpY2tMZW5ndGggKSA9PiBuZXcgVmVjdG9yMiggMCwgdHJhY2tCb3VuZHMudG9wICksXG5cbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgc3RhcnREcmFnOiBfLm5vb3AsXG4gICAgICBkcmFnOiBfLm5vb3AsXG4gICAgICBlbmREcmFnOiBfLm5vb3AsXG4gICAgICBjb25zdHJhaW5WYWx1ZTogXy5pZGVudGl0eSxcblxuICAgICAgZGlzYWJsZWRPcGFjaXR5OiBTY2VuZXJ5Q29uc3RhbnRzLkRJU0FCTEVEX09QQUNJVFksXG5cbiAgICAgIHNvdW5kR2VuZXJhdG9yOiBTbGlkZXIuREVGQVVMVF9TT1VORF9HRU5FUkFUT1IsXG4gICAgICB2YWx1ZUNoYW5nZVNvdW5kR2VuZXJhdG9yT3B0aW9uczoge30sXG5cbiAgICAgIC8vIHBoZXQtaW9cbiAgICAgIHBoZXRpb0xpbmtlZFByb3BlcnR5OiBudWxsLFxuXG4gICAgICAvLyBTdXBlcnR5cGUgb3B0aW9uc1xuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRUQsXG4gICAgICB0YW5kZW1OYW1lU3VmZml4OiAnU2xpZGVyJyxcbiAgICAgIHBoZXRpb1R5cGU6IFNsaWRlci5TbGlkZXJJTyxcbiAgICAgIHBoZXRpb0ZlYXR1cmVkOiB0cnVlLFxuICAgICAgdmlzaWJsZVByb3BlcnR5T3B0aW9uczogeyBwaGV0aW9GZWF0dXJlZDogdHJ1ZSB9LFxuICAgICAgcGhldGlvRW5hYmxlZFByb3BlcnR5SW5zdHJ1bWVudGVkOiB0cnVlIC8vIG9wdCBpbnRvIGRlZmF1bHQgUGhFVC1pTyBpbnN0cnVtZW50ZWQgZW5hYmxlZFByb3BlcnR5XG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XG5cbiAgICBjb25zdCByYW5nZVByb3BlcnR5ID0gcmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSA/IG5ldyBUaW55UHJvcGVydHkoIHJhbmdlICkgOiByYW5nZTtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMuc291bmRHZW5lcmF0b3IgPT09IFNsaWRlci5ERUZBVUxUX1NPVU5EX0dFTkVSQVRPUiB8fCBfLmlzRW1wdHkoIG9wdGlvbnMudmFsdWVDaGFuZ2VTb3VuZEdlbmVyYXRvck9wdGlvbnMgKSxcbiAgICAgICdvcHRpb25zIHNob3VsZCBvbmx5IGJlIHN1cHBsaWVkIHdoZW4gdXNpbmcgZGVmYXVsdCBzb3VuZCBnZW5lcmF0b3InICk7XG5cbiAgICAvLyBJZiBubyBzb3VuZCBnZW5lcmF0b3Igd2FzIHByb3ZpZGVkLCBjcmVhdGUgdGhlIGRlZmF1bHQuXG4gICAgaWYgKCBvcHRpb25zLnNvdW5kR2VuZXJhdG9yID09PSBTbGlkZXIuREVGQVVMVF9TT1VORF9HRU5FUkFUT1IgKSB7XG4gICAgICBvcHRpb25zLnNvdW5kR2VuZXJhdG9yID0gbmV3IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXIoIHJhbmdlUHJvcGVydHkudmFsdWUsIG9wdGlvbnMudmFsdWVDaGFuZ2VTb3VuZEdlbmVyYXRvck9wdGlvbnMgfHwge30gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIG9wdGlvbnMuc291bmRHZW5lcmF0b3IgPT09IG51bGwgKSB7XG4gICAgICBvcHRpb25zLnNvdW5kR2VuZXJhdG9yID0gVmFsdWVDaGFuZ2VTb3VuZFBsYXllci5OT19TT1VORDtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgdGhlIGRyYWcgaGFuZGxlciB0byBnZW5lcmF0ZSBzb3VuZCB3aGVuIGRyYWcgZXZlbnRzIGNhdXNlIGNoYW5nZXMuXG4gICAgaWYgKCBvcHRpb25zLnNvdW5kR2VuZXJhdG9yICE9PSBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyLk5PX1NPVU5EICkge1xuXG4gICAgICAvLyB2YXJpYWJsZSB0byBrZWVwIHRyYWNrIG9mIHRoZSB2YWx1ZSBhdCB0aGUgc3RhcnQgb2YgdXNlciBkcmFnIGludGVyYWN0aW9uc1xuICAgICAgbGV0IHByZXZpb3VzVmFsdWUgPSB2YWx1ZVByb3BlcnR5LnZhbHVlO1xuXG4gICAgICAvLyBFbmhhbmNlIHRoZSBkcmFnIGhhbmRsZXIgdG8gcGVyZm9ybSBzb3VuZCBnZW5lcmF0aW9uLlxuICAgICAgY29uc3QgcHJvdmlkZWREcmFnID0gb3B0aW9ucy5kcmFnO1xuICAgICAgb3B0aW9ucy5kcmFnID0gZXZlbnQgPT4ge1xuICAgICAgICBpZiAoIGV2ZW50LmlzRnJvbVBET00oKSApIHtcbiAgICAgICAgICBvcHRpb25zLnNvdW5kR2VuZXJhdG9yIS5wbGF5U291bmRGb3JWYWx1ZUNoYW5nZSggdmFsdWVQcm9wZXJ0eS52YWx1ZSwgcHJldmlvdXNWYWx1ZSApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMuc291bmRHZW5lcmF0b3IhLnBsYXlTb3VuZElmVGhyZXNob2xkUmVhY2hlZCggdmFsdWVQcm9wZXJ0eS52YWx1ZSwgcHJldmlvdXNWYWx1ZSApO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVkRHJhZyggZXZlbnQgKTtcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHZhbHVlUHJvcGVydHkudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICggb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uVkVSVElDQUwgKSB7XG5cbiAgICAgIC8vIEZvciBhIHZlcnRpY2FsIHNsaWRlciwgdGhlIGNsaWVudCBzaG91bGQgcHJvdmlkZSBkaW1lbnNpb25zIHRoYXQgYXJlIHNwZWNpZmljIHRvIGEgdmVydGljYWwgc2xpZGVyLlxuICAgICAgLy8gQnV0IFNsaWRlciBleHBlY3RzIGRpbWVuc2lvbnMgZm9yIGEgaG9yaXpvbnRhbCBzbGlkZXIsIGFuZCB0aGVuIGNyZWF0ZXMgdGhlIHZlcnRpY2FsIG9yaWVudGF0aW9uIHVzaW5nIHJvdGF0aW9uLlxuICAgICAgLy8gU28gaWYgdGhlIGNsaWVudCBwcm92aWRlcyBhbnkgZGltZW5zaW9ucyBmb3IgYSB2ZXJ0aWNhbCBzbGlkZXIsIHN3YXAgdGhvc2UgZGltZW5zaW9ucyB0byBob3Jpem9udGFsLlxuICAgICAgaWYgKCBvcHRpb25zLnRyYWNrU2l6ZSApIHtcbiAgICAgICAgb3B0aW9ucy50cmFja1NpemUgPSBvcHRpb25zLnRyYWNrU2l6ZS5zd2FwcGVkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIG9wdGlvbnMudGh1bWJTaXplICkge1xuICAgICAgICBvcHRpb25zLnRodW1iU2l6ZSA9IG9wdGlvbnMudGh1bWJTaXplLnN3YXBwZWQoKTtcbiAgICAgIH1cbiAgICAgIHN3YXBPYmplY3RLZXlzKCBvcHRpb25zLCAndGh1bWJUb3VjaEFyZWFYRGlsYXRpb24nLCAndGh1bWJUb3VjaEFyZWFZRGlsYXRpb24nICk7XG4gICAgICBzd2FwT2JqZWN0S2V5cyggb3B0aW9ucywgJ3RodW1iTW91c2VBcmVhWERpbGF0aW9uJywgJ3RodW1iTW91c2VBcmVhWURpbGF0aW9uJyApO1xuICAgIH1cbiAgICBvcHRpb25zLnRyYWNrU2l6ZSA9IG9wdGlvbnMudHJhY2tTaXplIHx8IERFRkFVTFRfSE9SSVpPTlRBTF9UUkFDS19TSVpFO1xuICAgIG9wdGlvbnMudGh1bWJTaXplID0gb3B0aW9ucy50aHVtYlNpemUgfHwgREVGQVVMVF9IT1JJWk9OVEFMX1RIVU1CX1NJWkU7XG5cbiAgICBjb25zdCB0aHVtYlRhbmRlbSA9IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggU2xpZGVyLlRIVU1CX05PREVfVEFOREVNX05BTUUgKTtcbiAgICBpZiAoIFRhbmRlbS5WQUxJREFUSU9OICYmIG9wdGlvbnMudGh1bWJOb2RlICkge1xuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy50aHVtYk5vZGUudGFuZGVtLmVxdWFscyggdGh1bWJUYW5kZW0gKSxcbiAgICAgICAgYFBhc3NlZC1pbiB0aHVtYk5vZGUgbXVzdCBoYXZlIHRoZSBjb3JyZWN0IHRhbmRlbS4gRXhwZWN0ZWQ6ICR7dGh1bWJUYW5kZW0ucGhldGlvSUR9LCBhY3R1YWw6ICR7b3B0aW9ucy50aHVtYk5vZGUudGFuZGVtLnBoZXRpb0lEfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRodW1iIG9mIHRoZSBzbGlkZXJcbiAgICBjb25zdCB0aHVtYiA9IG9wdGlvbnMudGh1bWJOb2RlIHx8IG5ldyBTbGlkZXJUaHVtYigge1xuXG4gICAgICAvLyBwcm9wYWdhdGUgb3B0aW9ucyB0aGF0IGFyZSBzcGVjaWZpYyB0byBTbGlkZXJUaHVtYlxuICAgICAgc2l6ZTogb3B0aW9ucy50aHVtYlNpemUsXG4gICAgICBmaWxsOiBvcHRpb25zLnRodW1iRmlsbCxcbiAgICAgIGZpbGxIaWdobGlnaHRlZDogb3B0aW9ucy50aHVtYkZpbGxIaWdobGlnaHRlZCxcbiAgICAgIHN0cm9rZTogb3B0aW9ucy50aHVtYlN0cm9rZSxcbiAgICAgIGxpbmVXaWR0aDogb3B0aW9ucy50aHVtYkxpbmVXaWR0aCxcbiAgICAgIGNlbnRlckxpbmVTdHJva2U6IG9wdGlvbnMudGh1bWJDZW50ZXJMaW5lU3Ryb2tlLFxuICAgICAgdGFuZGVtOiB0aHVtYlRhbmRlbVxuICAgIH0gKTtcblxuICAgIGNvbnN0IG93bnNFbmFibGVkUmFuZ2VQcm9wZXJ0eSA9ICFvcHRpb25zLmVuYWJsZWRSYW5nZVByb3BlcnR5O1xuXG4gICAgY29uc3QgYm91bmRzUmVxdWlyZWRPcHRpb25LZXlzID0gXy5waWNrKCBvcHRpb25zLCBOb2RlLlJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUyApO1xuXG4gICAgLy8gTm93IGFkZCBpbiB0aGUgcmVxdWlyZWQgb3B0aW9ucyB3aGVuIHBhc3NpbmcgdG8gdGhlIHN1cGVyIHR5cGVcbiAgICBjb25zdCBzdXBlck9wdGlvbnMgPSBjb21iaW5lT3B0aW9uczx0eXBlb2Ygb3B0aW9ucyAmIFBpY2tSZXF1aXJlZDxQYXJlbnRPcHRpb25zLCBSZXF1aXJlZFBhcmVudE9wdGlvbnNTdXBwbGllZEJ5U2xpZGVyPj4oIHtcblxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBvcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgdmFsdWVQcm9wZXJ0eTogdmFsdWVQcm9wZXJ0eSxcbiAgICAgIHBhblRhcmdldE5vZGU6IHRodW1iLFxuXG4gICAgICAvLyBjb250cm9scyB0aGUgcG9ydGlvbiBvZiB0aGUgc2xpZGVyIHRoYXQgaXMgZW5hYmxlZFxuICAgICAgZW5hYmxlZFJhbmdlUHJvcGVydHk6IG9wdGlvbnMuZW5hYmxlZFJhbmdlUHJvcGVydHkgfHwgKCByYW5nZSBpbnN0YW5jZW9mIFJhbmdlID8gbmV3IFByb3BlcnR5KCByYW5nZSwge1xuICAgICAgICB2YWx1ZVR5cGU6IFJhbmdlLFxuICAgICAgICBpc1ZhbGlkVmFsdWU6ICggdmFsdWU6IFJhbmdlICkgPT4gKCB2YWx1ZS5taW4gPj0gcmFuZ2UubWluICYmIHZhbHVlLm1heCA8PSByYW5nZS5tYXggKSxcbiAgICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdlbmFibGVkUmFuZ2VQcm9wZXJ0eScgKSxcbiAgICAgICAgdmFsdWVDb21wYXJpc29uU3RyYXRlZ3k6ICdlcXVhbHNGdW5jdGlvbicsIC8vIE9ubHkgZmlyZSBsaXN0ZW5lcnMgaWYgdGhlIHJhbmdlICB2YWx1ZSBkaWZmZXJzLCBub3QgdGhlIGluc3RhbmNlLCBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZGVuc2l0eS1idW95YW5jeS1jb21tb24vaXNzdWVzLzIwM1xuICAgICAgICBwaGV0aW9WYWx1ZVR5cGU6IFJhbmdlLlJhbmdlSU8sXG4gICAgICAgIHBoZXRpb0RvY3VtZW50YXRpb246ICdTbGlkZXJzIHN1cHBvcnQgdHdvIHJhbmdlczogdGhlIG91dGVyIHJhbmdlIHdoaWNoIHNwZWNpZmllcyB0aGUgbWluIGFuZCBtYXggb2YgdGhlIHRyYWNrIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSBlbmFibGVkUmFuZ2VQcm9wZXJ0eSwgd2hpY2ggZGV0ZXJtaW5lcyBob3cgbG93IGFuZCBoaWdoIHRoZSB0aHVtYiBjYW4gYmUgZHJhZ2dlZCB3aXRoaW4gdGhlIHRyYWNrLidcbiAgICAgIH0gKSA6IHJhbmdlIClcbiAgICB9LCBvcHRpb25zICk7XG5cbiAgICBzdXBlciggc3VwZXJPcHRpb25zICk7XG5cbiAgICB0aGlzLm9yaWVudGF0aW9uID0gc3VwZXJPcHRpb25zLm9yaWVudGF0aW9uITtcbiAgICB0aGlzLmVuYWJsZWRSYW5nZVByb3BlcnR5ID0gc3VwZXJPcHRpb25zLmVuYWJsZWRSYW5nZVByb3BlcnR5O1xuXG4gICAgdGhpcy50aWNrT3B0aW9ucyA9IF8ucGljayggb3B0aW9ucywgJ3RpY2tMYWJlbFNwYWNpbmcnLFxuICAgICAgJ21ham9yVGlja0xlbmd0aCcsICdtYWpvclRpY2tTdHJva2UnLCAnbWFqb3JUaWNrTGluZVdpZHRoJyxcbiAgICAgICdtaW5vclRpY2tMZW5ndGgnLCAnbWlub3JUaWNrU3Ryb2tlJywgJ21pbm9yVGlja0xpbmVXaWR0aCcsXG4gICAgICAnc2V0VGlja0luaXRpYWxQb2ludCcsICdwb3NpdGlvbkxhYmVsJyApO1xuXG4gICAgY29uc3Qgc2xpZGVyUGFydHMgPSBbXTtcblxuICAgIC8vIHRpY2tzIGFyZSBhZGRlZCB0byB0aGVzZSBwYXJlbnRzLCBzbyB0aGV5IGFyZSBiZWhpbmQgdGhlIGtub2JcbiAgICB0aGlzLm1ham9yVGlja3NQYXJlbnQgPSBuZXcgTm9kZSgpO1xuICAgIHRoaXMubWlub3JUaWNrc1BhcmVudCA9IG5ldyBOb2RlKCk7XG4gICAgc2xpZGVyUGFydHMucHVzaCggdGhpcy5tYWpvclRpY2tzUGFyZW50ICk7XG4gICAgc2xpZGVyUGFydHMucHVzaCggdGhpcy5taW5vclRpY2tzUGFyZW50ICk7XG5cbiAgICBjb25zdCB0cmFja1RhbmRlbSA9IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggU2xpZGVyLlRSQUNLX05PREVfVEFOREVNX05BTUUgKTtcblxuICAgIGlmICggVGFuZGVtLlZBTElEQVRJT04gJiYgb3B0aW9ucy50cmFja05vZGUgKSB7XG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLnRyYWNrTm9kZS50YW5kZW0uZXF1YWxzKCB0cmFja1RhbmRlbSApLFxuICAgICAgICBgUGFzc2VkLWluIHRyYWNrTm9kZSBtdXN0IGhhdmUgdGhlIGNvcnJlY3QgdGFuZGVtLiBFeHBlY3RlZDogJHt0cmFja1RhbmRlbS5waGV0aW9JRH0sIGFjdHVhbDogJHtvcHRpb25zLnRyYWNrTm9kZS50YW5kZW0ucGhldGlvSUR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFja1NwYWNlciA9IG5ldyBOb2RlKCk7XG4gICAgc2xpZGVyUGFydHMucHVzaCggdHJhY2tTcGFjZXIgKTtcblxuICAgIC8vIEFzc2VydGlvbiB0byBnZXQgYXJvdW5kIG11dGF0aW5nIHRoZSBudWxsLWRlZmF1bHQgYmFzZWQgb24gdGhlIHNsaWRlciBvcmllbnRhdGlvbi5cbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBzdXBlck9wdGlvbnMudHJhY2tTaXplLCAndHJhY2tTaXplIHNob3VsZCBub3QgYmUgbnVsbCcgKTtcblxuICAgIHRoaXMudHJhY2sgPSBvcHRpb25zLnRyYWNrTm9kZSB8fCBuZXcgRGVmYXVsdFNsaWRlclRyYWNrKCB2YWx1ZVByb3BlcnR5LCByYW5nZSwge1xuXG4gICAgICAvLyBwcm9wYWdhdGUgb3B0aW9ucyB0aGF0IGFyZSBzcGVjaWZpYyB0byBTbGlkZXJUcmFja1xuICAgICAgc2l6ZTogc3VwZXJPcHRpb25zLnRyYWNrU2l6ZSEsXG4gICAgICBmaWxsRW5hYmxlZDogc3VwZXJPcHRpb25zLnRyYWNrRmlsbEVuYWJsZWQsXG4gICAgICBmaWxsRGlzYWJsZWQ6IHN1cGVyT3B0aW9ucy50cmFja0ZpbGxEaXNhYmxlZCxcbiAgICAgIHN0cm9rZTogc3VwZXJPcHRpb25zLnRyYWNrU3Ryb2tlLFxuICAgICAgbGluZVdpZHRoOiBzdXBlck9wdGlvbnMudHJhY2tMaW5lV2lkdGgsXG4gICAgICBjb3JuZXJSYWRpdXM6IHN1cGVyT3B0aW9ucy50cmFja0Nvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0RHJhZzogc3VwZXJPcHRpb25zLnN0YXJ0RHJhZyxcbiAgICAgIGRyYWc6IHN1cGVyT3B0aW9ucy5kcmFnLFxuICAgICAgZW5kRHJhZzogc3VwZXJPcHRpb25zLmVuZERyYWcsXG4gICAgICBjb25zdHJhaW5WYWx1ZTogc3VwZXJPcHRpb25zLmNvbnN0cmFpblZhbHVlLFxuICAgICAgZW5hYmxlZFJhbmdlUHJvcGVydHk6IHRoaXMuZW5hYmxlZFJhbmdlUHJvcGVydHksXG4gICAgICBzb3VuZEdlbmVyYXRvcjogb3B0aW9ucy5zb3VuZEdlbmVyYXRvcixcbiAgICAgIHBpY2thYmxlOiBzdXBlck9wdGlvbnMudHJhY2tQaWNrYWJsZSxcbiAgICAgIHZvaWNpbmdPbkVuZFJlc3BvbnNlOiB0aGlzLnZvaWNpbmdPbkVuZFJlc3BvbnNlLmJpbmQoIHRoaXMgKSxcblxuICAgICAgLy8gcGhldC1pb1xuICAgICAgdGFuZGVtOiB0cmFja1RhbmRlbVxuICAgIH0gKTtcblxuICAgIC8vIEFkZCB0aGUgdHJhY2tcbiAgICBzbGlkZXJQYXJ0cy5wdXNoKCB0aGlzLnRyYWNrICk7XG5cbiAgICAvLyBQb3NpdGlvbiB0aGUgdGh1bWIgdmVydGljYWxseS5cbiAgICB0aHVtYi5zZXRDZW50ZXJZKCB0aGlzLnRyYWNrLmNlbnRlclkgKyBvcHRpb25zLnRodW1iWU9mZnNldCApO1xuXG4gICAgc2xpZGVyUGFydHMucHVzaCggdGh1bWIgKTtcblxuICAgIC8vIFdyYXAgYWxsIG9mIHRoZSBzbGlkZXIgcGFydHMgaW4gYSBOb2RlLCBhbmQgc2V0IHRoZSBvcmllbnRhdGlvbiBvZiB0aGF0IE5vZGUuXG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gc3RpbGwgZGVjb3JhdGUgdGhlIFNsaWRlciB3aXRoIGFkZGl0aW9uYWwgY2hpbGRyZW4uXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzQwNlxuICAgIGNvbnN0IHNsaWRlclBhcnRzTm9kZSA9IG5ldyBOb2RlKCB7IGNoaWxkcmVuOiBzbGlkZXJQYXJ0cyB9ICk7XG4gICAgaWYgKCBvcHRpb25zLm9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5WRVJUSUNBTCApIHtcbiAgICAgIHNsaWRlclBhcnRzTm9kZS5yb3RhdGlvbiA9IFN1bkNvbnN0YW50cy5TTElERVJfVkVSVElDQUxfUk9UQVRJT047XG4gICAgfVxuICAgIHRoaXMuYWRkQ2hpbGQoIHNsaWRlclBhcnRzTm9kZSApO1xuXG4gICAgLy8gdG91Y2hBcmVhIGZvciB0aGUgZGVmYXVsdCB0aHVtYi4gSWYgYSBjdXN0b20gdGh1bWIgaXMgcHJvdmlkZWQsIHRoZSBjbGllbnQgaXMgcmVzcG9uc2libGUgZm9yIGl0cyB0b3VjaEFyZWEuXG4gICAgaWYgKCAhb3B0aW9ucy50aHVtYk5vZGUgJiYgKCBvcHRpb25zLnRodW1iVG91Y2hBcmVhWERpbGF0aW9uIHx8IG9wdGlvbnMudGh1bWJUb3VjaEFyZWFZRGlsYXRpb24gKSApIHtcbiAgICAgIHRodW1iLnRvdWNoQXJlYSA9IHRodW1iLmxvY2FsQm91bmRzLmRpbGF0ZWRYWSggb3B0aW9ucy50aHVtYlRvdWNoQXJlYVhEaWxhdGlvbiwgb3B0aW9ucy50aHVtYlRvdWNoQXJlYVlEaWxhdGlvbiApO1xuICAgIH1cblxuICAgIC8vIG1vdXNlQXJlYSBmb3IgdGhlIGRlZmF1bHQgdGh1bWIuIElmIGEgY3VzdG9tIHRodW1iIGlzIHByb3ZpZGVkLCB0aGUgY2xpZW50IGlzIHJlc3BvbnNpYmxlIGZvciBpdHMgbW91c2VBcmVhLlxuICAgIGlmICggIW9wdGlvbnMudGh1bWJOb2RlICYmICggb3B0aW9ucy50aHVtYk1vdXNlQXJlYVhEaWxhdGlvbiB8fCBvcHRpb25zLnRodW1iTW91c2VBcmVhWURpbGF0aW9uICkgKSB7XG4gICAgICB0aHVtYi5tb3VzZUFyZWEgPSB0aHVtYi5sb2NhbEJvdW5kcy5kaWxhdGVkWFkoIG9wdGlvbnMudGh1bWJNb3VzZUFyZWFYRGlsYXRpb24sIG9wdGlvbnMudGh1bWJNb3VzZUFyZWFZRGlsYXRpb24gKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdmFsdWUgd2hlbiB0aHVtYiBpcyBkcmFnZ2VkXG4gICAgbGV0IGNsaWNrWE9mZnNldCA9IDA7IC8vIHgtb2Zmc2V0IGJldHdlZW4gaW5pdGlhbCBjbGljayBhbmQgdGh1bWIncyBvcmlnaW5cbiAgICBsZXQgdmFsdWVPblN0YXJ0ID0gdmFsdWVQcm9wZXJ0eS52YWx1ZTsgLy8gRm9yIGRlc2NyaXB0aW9uIHNvIHdlIGNhbiBkZXNjcmliZSB2YWx1ZSBjaGFuZ2VzIGJldHdlZW4gaW50ZXJhY3Rpb25zXG4gICAgY29uc3QgdGh1bWJEcmFnTGlzdGVuZXIgPSBuZXcgRHJhZ0xpc3RlbmVyKCB7XG5cbiAgICAgIC8vIERldmlhdGUgZnJvbSB0aGUgdmFyaWFibGUgbmFtZSBiZWNhdXNlIHdlIHdpbGwgbmVzdCB0aGlzIHRhbmRlbSB1bmRlciB0aGUgdGh1bWIgZGlyZWN0bHlcbiAgICAgIHRhbmRlbTogdGh1bWIudGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2RyYWdMaXN0ZW5lcicgKSxcblxuICAgICAgc3RhcnQ6ICggZXZlbnQsIGxpc3RlbmVyICkgPT4ge1xuICAgICAgICBpZiAoIHRoaXMuZW5hYmxlZFByb3BlcnR5LmdldCgpICkge1xuICAgICAgICAgIHZhbHVlT25TdGFydCA9IHZhbHVlUHJvcGVydHkudmFsdWU7XG5cbiAgICAgICAgICBvcHRpb25zLnN0YXJ0RHJhZyggZXZlbnQgKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBsaXN0ZW5lci5wcmVzc2VkVHJhaWwuc3VidHJhaWxUbyggc2xpZGVyUGFydHNOb2RlICkuZ2V0VHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIHRoZSB0aHVtYlxuICAgICAgICAgIGNsaWNrWE9mZnNldCA9IHRyYW5zZm9ybS5pbnZlcnNlUG9zaXRpb24yKCBldmVudC5wb2ludGVyLnBvaW50ICkueCAtIHRodW1iLmNlbnRlclg7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRyYWc6ICggZXZlbnQsIGxpc3RlbmVyICkgPT4ge1xuICAgICAgICBpZiAoIHRoaXMuZW5hYmxlZFByb3BlcnR5LmdldCgpICkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGxpc3RlbmVyLnByZXNzZWRUcmFpbC5zdWJ0cmFpbFRvKCBzbGlkZXJQYXJ0c05vZGUgKS5nZXRUcmFuc2Zvcm0oKTsgLy8gd2Ugb25seSB3YW50IHRoZSB0cmFuc2Zvcm0gdG8gb3VyIHBhcmVudFxuICAgICAgICAgIGNvbnN0IHggPSB0cmFuc2Zvcm0uaW52ZXJzZVBvc2l0aW9uMiggZXZlbnQucG9pbnRlci5wb2ludCApLnggLSBjbGlja1hPZmZzZXQ7XG4gICAgICAgICAgdGhpcy5wcm9wb3NlZFZhbHVlID0gdGhpcy50cmFjay52YWx1ZVRvUG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS5pbnZlcnNlKCB4ICk7XG5cbiAgICAgICAgICBjb25zdCB2YWx1ZUluUmFuZ2UgPSB0aGlzLmVuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLmNvbnN0cmFpblZhbHVlKCB0aGlzLnByb3Bvc2VkVmFsdWUgKTtcbiAgICAgICAgICB2YWx1ZVByb3BlcnR5LnNldCggb3B0aW9ucy5jb25zdHJhaW5WYWx1ZSggdmFsdWVJblJhbmdlICkgKTtcblxuICAgICAgICAgIC8vIGFmdGVyIHZhbHVlUHJvcGVydHkgaXMgc2V0IHNvIGxpc3RlbmVyIGNhbiB1c2UgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgIG9wdGlvbnMuZHJhZyggZXZlbnQgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZW5kOiBldmVudCA9PiB7XG4gICAgICAgIGlmICggdGhpcy5lbmFibGVkUHJvcGVydHkuZ2V0KCkgKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmREcmFnKCBldmVudCApO1xuXG4gICAgICAgICAgLy8gdm9pY2luZyAtIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gc3BlYWsgdGhlIG5ldyBvYmplY3QgcmVzcG9uc2UgYXQgdGhlIGVuZCBvZiBpbnRlcmFjdGlvbi4gSWYgeW91IHdhbnQgdG9cbiAgICAgICAgICAvLyBjdXN0b21pemUgdGhpcyByZXNwb25zZSwgeW91IGNhbiBtb2RpZnkgc3VwZXJ0eXBlIG9wdGlvbnMgVm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zLlxuICAgICAgICAgIHRoaXMudm9pY2luZ09uRW5kUmVzcG9uc2UoIHZhbHVlT25TdGFydCApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcG9zZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSApO1xuICAgIHRodW1iLmFkZElucHV0TGlzdGVuZXIoIHRodW1iRHJhZ0xpc3RlbmVyICk7XG5cbiAgICB0aGlzLnRodW1iRHJhZ0xpc3RlbmVyID0gdGh1bWJEcmFnTGlzdGVuZXI7XG4gICAgdGhpcy50cmFja0RyYWdMaXN0ZW5lciA9IHRoaXMudHJhY2suZHJhZ0xpc3RlbmVyO1xuXG4gICAgLy8gdXBkYXRlIHRodW1iIHBvc2l0aW9uIHdoZW4gdmFsdWUgY2hhbmdlc1xuICAgIGNvbnN0IHZhbHVlTXVsdGlsaW5rID0gTXVsdGlsaW5rLm11bHRpbGluayggWyB2YWx1ZVByb3BlcnR5LCB0aGlzLnRyYWNrLnZhbHVlVG9Qb3NpdGlvblByb3BlcnR5IF0sICggdmFsdWUsIHZhbHVlVG9Qb3NpdGlvbiApID0+IHtcbiAgICAgIHRodW1iLmNlbnRlclggPSB2YWx1ZVRvUG9zaXRpb24uZXZhbHVhdGUoIHZhbHVlICk7XG4gICAgfSApO1xuXG4gICAgLy8gd2hlbiB0aGUgZW5hYmxlZCByYW5nZSBjaGFuZ2VzLCB0aGUgdmFsdWUgdG8gcG9zaXRpb24gbGluZWFyIGZ1bmN0aW9uIG11c3QgY2hhbmdlIGFzIHdlbGxcbiAgICBjb25zdCBlbmFibGVkUmFuZ2VPYnNlcnZlciA9ICggZW5hYmxlZFJhbmdlOiBSYW5nZSApID0+IHtcblxuICAgICAgLy8gV2hlbiByZXN0b3JpbmcgUGhFVC1pTyBzdGF0ZSwgcHJldmVudCB0aGUgY2xhbXAgZnJvbSBzZXR0aW5nIGEgc3RhbGUsIGluY29ycmVjdCB2YWx1ZSB0byBhIGRlZmVycmVkIFByb3BlcnR5XG4gICAgICAvLyAod2hpY2ggbWF5IGhhdmUgYWxyZWFkeSByZXN0b3JlZCB0aGUgY29ycmVjdCB2YWx1ZSBmcm9tIHBoZXQtaW8gc3RhdGUpLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL21lYW4tc2hhcmUtYW5kLWJhbGFuY2UvaXNzdWVzLzIxXG4gICAgICBpZiAoICF2YWx1ZVByb3BlcnR5LmlzUGhldGlvSW5zdHJ1bWVudGVkKCkgfHwgIWlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkudmFsdWUgKSB7XG5cblxuICAgICAgICBpZiAoIHRoaXMucHJvcG9zZWRWYWx1ZSA9PT0gbnVsbCApIHtcblxuICAgICAgICAgIC8vIGNsYW1wIHRoZSBjdXJyZW50IHZhbHVlIHRvIHRoZSBlbmFibGVkIHJhbmdlIGlmIGl0IGNoYW5nZXNcbiAgICAgICAgICB2YWx1ZVByb3BlcnR5LnNldCggVXRpbHMuY2xhbXAoIHZhbHVlUHJvcGVydHkudmFsdWUsIGVuYWJsZWRSYW5nZS5taW4sIGVuYWJsZWRSYW5nZS5tYXggKSApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgLy8gVGhlIHVzZXIgaXMgaG9sZGluZyB0aGUgdGh1bWIsIHdoaWNoIG1heSBiZSBvdXRzaWRlIHRoZSBlbmFibGVkUmFuZ2UuICBJbiB0aGF0IGNhc2UsIGV4cGFuZGluZyB0aGUgcmFuZ2VcbiAgICAgICAgICAvLyBjb3VsZCBhY2NvbW1vZGF0ZSB0aGUgb3V0ZXIgdmFsdWVcbiAgICAgICAgICBjb25zdCBwcm9wb3NlZFZhbHVlSW5FbmFibGVkUmFuZ2UgPSBVdGlscy5jbGFtcCggdGhpcy5wcm9wb3NlZFZhbHVlLCBlbmFibGVkUmFuZ2UubWluLCBlbmFibGVkUmFuZ2UubWF4ICk7XG4gICAgICAgICAgY29uc3QgcHJvcG9zZWRWYWx1ZUluQ29uc3RyYWluZWRSYW5nZSA9IG9wdGlvbnMuY29uc3RyYWluVmFsdWUoIHByb3Bvc2VkVmFsdWVJbkVuYWJsZWRSYW5nZSApO1xuICAgICAgICAgIHZhbHVlUHJvcGVydHkuc2V0KCBwcm9wb3NlZFZhbHVlSW5Db25zdHJhaW5lZFJhbmdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZW5hYmxlZFJhbmdlUHJvcGVydHkubGluayggZW5hYmxlZFJhbmdlT2JzZXJ2ZXIgKTsgLy8gbmVlZHMgdG8gYmUgdW5saW5rZWQgaW4gZGlzcG9zZSBmdW5jdGlvblxuXG4gICAgY29uc3QgY29uc3RyYWludCA9IG5ldyBTbGlkZXJDb25zdHJhaW50KCB0aGlzLCB0aGlzLnRyYWNrLCB0aHVtYiwgc2xpZGVyUGFydHNOb2RlLCBvcHRpb25zLm9yaWVudGF0aW9uLCB0cmFja1NwYWNlciwgdGhpcy50aWNrcyApO1xuXG4gICAgdGhpcy5kaXNwb3NlU2xpZGVyID0gKCkgPT4ge1xuICAgICAgY29uc3RyYWludC5kaXNwb3NlKCk7XG5cbiAgICAgIHRodW1iLmRpc3Bvc2UgJiYgdGh1bWIuZGlzcG9zZSgpOyAvLyBpbiBjYXNlIGEgY3VzdG9tIHRodW1iIGlzIHByb3ZpZGVkIHZpYSBvcHRpb25zLnRodW1iTm9kZSB0aGF0IGRvZXNuJ3QgaW1wbGVtZW50IGRpc3Bvc2VcbiAgICAgIHRoaXMudHJhY2suZGlzcG9zZSAmJiB0aGlzLnRyYWNrLmRpc3Bvc2UoKTtcblxuICAgICAgaWYgKCBvd25zRW5hYmxlZFJhbmdlUHJvcGVydHkgKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZFJhbmdlUHJvcGVydHkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZFJhbmdlUHJvcGVydHkudW5saW5rKCBlbmFibGVkUmFuZ2VPYnNlcnZlciApO1xuICAgICAgfVxuICAgICAgdmFsdWVNdWx0aWxpbmsuZGlzcG9zZSgpO1xuICAgICAgdGh1bWJEcmFnTGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICAvLyBwZG9tIC0gY3VzdG9tIGZvY3VzIGhpZ2hsaWdodCB0aGF0IHN1cnJvdW5kcyBhbmQgbW92ZXMgd2l0aCB0aGUgdGh1bWJcbiAgICB0aGlzLmZvY3VzSGlnaGxpZ2h0ID0gbmV3IEhpZ2hsaWdodEZyb21Ob2RlKCB0aHVtYiApO1xuXG4gICAgYXNzZXJ0ICYmIFRhbmRlbS5WQUxJREFUSU9OICYmIGFzc2VydCggIW9wdGlvbnMucGhldGlvTGlua2VkUHJvcGVydHkgfHwgb3B0aW9ucy5waGV0aW9MaW5rZWRQcm9wZXJ0eS5pc1BoZXRpb0luc3RydW1lbnRlZCgpLFxuICAgICAgJ0lmIHByb3ZpZGVkLCBwaGV0aW9MaW5rZWRQcm9wZXJ0eSBzaG91bGQgYmUgUGhFVC1pTyBpbnN0cnVtZW50ZWQnICk7XG5cbiAgICAvLyBNdXN0IGhhcHBlbiBhZnRlciBpbnN0cnVtZW50YXRpb24gKGluIHN1cGVyIGNhbGwpXG4gICAgY29uc3QgbGlua2VkUHJvcGVydHkgPSBvcHRpb25zLnBoZXRpb0xpbmtlZFByb3BlcnR5IHx8ICggdmFsdWVQcm9wZXJ0eSBpbnN0YW5jZW9mIFJlYWRPbmx5UHJvcGVydHkgPyB2YWx1ZVByb3BlcnR5IDogbnVsbCApO1xuICAgIGlmICggbGlua2VkUHJvcGVydHkgKSB7XG4gICAgICB0aGlzLmFkZExpbmtlZEVsZW1lbnQoIGxpbmtlZFByb3BlcnR5LCB7XG4gICAgICAgIHRhbmRlbU5hbWU6ICd2YWx1ZVByb3BlcnR5J1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIC8vIG11c3QgYmUgYWZ0ZXIgdGhlIGJ1dHRvbiBpcyBpbnN0cnVtZW50ZWRcbiAgICAvLyBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy5pc1BoZXRpb0luc3RydW1lbnRlZCgpIHx8IHRoaXMuZW5hYmxlZFJhbmdlUHJvcGVydHkuaXNQaGV0aW9JbnN0cnVtZW50ZWQoKSApO1xuICAgICFvd25zRW5hYmxlZFJhbmdlUHJvcGVydHkgJiYgdGhpcy5lbmFibGVkUmFuZ2VQcm9wZXJ0eSBpbnN0YW5jZW9mIFJlYWRPbmx5UHJvcGVydHkgJiYgdGhpcy5hZGRMaW5rZWRFbGVtZW50KCB0aGlzLmVuYWJsZWRSYW5nZVByb3BlcnR5LCB7XG4gICAgICB0YW5kZW1OYW1lOiAnZW5hYmxlZFJhbmdlUHJvcGVydHknXG4gICAgfSApO1xuXG4gICAgdGhpcy5tdXRhdGUoIGJvdW5kc1JlcXVpcmVkT3B0aW9uS2V5cyApO1xuXG4gICAgLy8gRGVjb3JhdGluZyB0aGUgd2l0aCBhZGRpdGlvbmFsIGNvbnRlbnQgaXMgYmFkIGZvciBkeW5hbWljIGxheW91dCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzg2MFxuICAgIGFzc2VydCAmJiBhc3NlcnROb0FkZGl0aW9uYWxDaGlsZHJlbiggdGhpcyApO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYmluZGVyIGRvY3VtZW50YXRpb24sIHN0cmlwcGVkIG91dCBpbiBidWlsZHMgYW5kIG9ubHkgcnVucyB3aGVuID9iaW5kZXIgaXMgc3BlY2lmaWVkXG4gICAgYXNzZXJ0ICYmIHdpbmRvdy5waGV0Py5jaGlwcGVyPy5xdWVyeVBhcmFtZXRlcnM/LmJpbmRlciAmJiBJbnN0YW5jZVJlZ2lzdHJ5LnJlZ2lzdGVyRGF0YVVSTCggJ3N1bicsICdTbGlkZXInLCB0aGlzICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1ham9yVGlja3NWaXNpYmxlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5nZXRNYWpvclRpY2tzVmlzaWJsZSgpOyB9XG5cbiAgcHVibGljIHNldCBtYWpvclRpY2tzVmlzaWJsZSggdmFsdWU6IGJvb2xlYW4gKSB7IHRoaXMuc2V0TWFqb3JUaWNrc1Zpc2libGUoIHZhbHVlICk7IH1cblxuICBwdWJsaWMgZ2V0IG1pbm9yVGlja3NWaXNpYmxlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5nZXRNaW5vclRpY2tzVmlzaWJsZSgpOyB9XG5cbiAgcHVibGljIHNldCBtaW5vclRpY2tzVmlzaWJsZSggdmFsdWU6IGJvb2xlYW4gKSB7IHRoaXMuc2V0TWlub3JUaWNrc1Zpc2libGUoIHZhbHVlICk7IH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpc3Bvc2VTbGlkZXIoKTtcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCggdGljayA9PiB7XG4gICAgICB0aWNrLmRpc3Bvc2UoKTtcbiAgICB9ICk7XG5cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG1ham9yIHRpY2sgbWFyay5cbiAgICovXG4gIHB1YmxpYyBhZGRNYWpvclRpY2soIHZhbHVlOiBudW1iZXIsIGxhYmVsPzogTm9kZSApOiB2b2lkIHtcbiAgICB0aGlzLmFkZFRpY2soIHRoaXMubWFqb3JUaWNrc1BhcmVudCwgdmFsdWUsIGxhYmVsLFxuICAgICAgdGhpcy50aWNrT3B0aW9ucy5tYWpvclRpY2tMZW5ndGgsIHRoaXMudGlja09wdGlvbnMubWFqb3JUaWNrU3Ryb2tlLCB0aGlzLnRpY2tPcHRpb25zLm1ham9yVGlja0xpbmVXaWR0aCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBtaW5vciB0aWNrIG1hcmsuXG4gICAqL1xuICBwdWJsaWMgYWRkTWlub3JUaWNrKCB2YWx1ZTogbnVtYmVyLCBsYWJlbD86IE5vZGUgKTogdm9pZCB7XG4gICAgdGhpcy5hZGRUaWNrKCB0aGlzLm1pbm9yVGlja3NQYXJlbnQsIHZhbHVlLCBsYWJlbCxcbiAgICAgIHRoaXMudGlja09wdGlvbnMubWlub3JUaWNrTGVuZ3RoLCB0aGlzLnRpY2tPcHRpb25zLm1pbm9yVGlja1N0cm9rZSwgdGhpcy50aWNrT3B0aW9ucy5taW5vclRpY2tMaW5lV2lkdGggKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdGljayBtYXJrIGFib3ZlIHRoZSB0cmFjay5cbiAgICovXG4gIHByaXZhdGUgYWRkVGljayggcGFyZW50OiBOb2RlLCB2YWx1ZTogbnVtYmVyLCBsYWJlbDogTm9kZSB8IHVuZGVmaW5lZCwgbGVuZ3RoOiBudW1iZXIsIHN0cm9rZTogVFBhaW50LCBsaW5lV2lkdGg6IG51bWJlciApOiB2b2lkIHtcbiAgICB0aGlzLnRpY2tzLnB1c2goIG5ldyBTbGlkZXJUaWNrKCBwYXJlbnQsIHZhbHVlLCBsYWJlbCwgbGVuZ3RoLCBzdHJva2UsIGxpbmVXaWR0aCwgdGhpcy50aWNrT3B0aW9ucywgdGhpcy5vcmllbnRhdGlvbiwgdGhpcy50cmFjayApICk7XG4gIH1cblxuICAvLyBTZXRzIHZpc2liaWxpdHkgb2YgbWFqb3IgdGlja3MuXG4gIHB1YmxpYyBzZXRNYWpvclRpY2tzVmlzaWJsZSggdmlzaWJsZTogYm9vbGVhbiApOiB2b2lkIHtcbiAgICB0aGlzLm1ham9yVGlja3NQYXJlbnQudmlzaWJsZSA9IHZpc2libGU7XG4gIH1cblxuICAvLyBHZXRzIHZpc2liaWxpdHkgb2YgbWFqb3IgdGlja3MuXG4gIHB1YmxpYyBnZXRNYWpvclRpY2tzVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tYWpvclRpY2tzUGFyZW50LnZpc2libGU7XG4gIH1cblxuICAvLyBTZXRzIHZpc2liaWxpdHkgb2YgbWlub3IgdGlja3MuXG4gIHB1YmxpYyBzZXRNaW5vclRpY2tzVmlzaWJsZSggdmlzaWJsZTogYm9vbGVhbiApOiB2b2lkIHtcbiAgICB0aGlzLm1pbm9yVGlja3NQYXJlbnQudmlzaWJsZSA9IHZpc2libGU7XG4gIH1cblxuICAvLyBHZXRzIHZpc2liaWxpdHkgb2YgbWlub3IgdGlja3MuXG4gIHB1YmxpYyBnZXRNaW5vclRpY2tzVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5taW5vclRpY2tzUGFyZW50LnZpc2libGU7XG4gIH1cblxuICAvLyBzdGFuZGFyZGl6ZWQgdGFuZGVtIG5hbWVzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk0XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVEhVTUJfTk9ERV9UQU5ERU1fTkFNRSA9ICd0aHVtYk5vZGUnIGFzIGNvbnN0O1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFRSQUNLX05PREVfVEFOREVNX05BTUUgPSAndHJhY2tOb2RlJyBhcyBjb25zdDtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNsaWRlcklPID0gbmV3IElPVHlwZSggJ1NsaWRlcklPJywge1xuICAgIHZhbHVlVHlwZTogU2xpZGVyLFxuICAgIGRvY3VtZW50YXRpb246ICdBIHRyYWRpdGlvbmFsIHNsaWRlciBjb21wb25lbnQsIHdpdGggYSBrbm9iIGFuZCBwb3NzaWJseSB0aWNrIG1hcmtzJyxcbiAgICBzdXBlcnR5cGU6IE5vZGUuTm9kZUlPXG4gIH0gKTtcbn1cblxuY2xhc3MgU2xpZGVyQ29uc3RyYWludCBleHRlbmRzIExheW91dENvbnN0cmFpbnQge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgcHJlZmVycmVkUHJvcGVydHk6IFRQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNwb3NlU2xpZGVyQ29uc3RyYWludDogKCkgPT4gdm9pZDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzbGlkZXI6IFNsaWRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRyYWNrOiBTbGlkZXJUcmFjayxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRodW1iOiBOb2RlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyUGFydHNOb2RlOiBOb2RlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3JpZW50YXRpb246IE9yaWVudGF0aW9uLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHJhY2tTcGFjZXI6IE5vZGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0aWNrczogT2JzZXJ2YWJsZUFycmF5PFNsaWRlclRpY2s+XG4gICkge1xuXG4gICAgc3VwZXIoIHNsaWRlciApO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIGl0IHNpemFibGUgaW4gYm90aCBkaW1lbnNpb25zIChWU2xpZGVyIHZzIEhTbGlkZXIpLCBidXQgd2UnbGwgc3RpbGwgd2FudCB0byBtYWtlIHRoZSBvcHBvc2l0ZVxuICAgIC8vIGF4aXMgbm9uLXNpemFibGUgKHNpbmNlIGl0IHdvbid0IGJlIHNpemFibGUgaW4gYm90aCBvcmllbnRhdGlvbnMgYXQgb25jZSkuXG4gICAgaWYgKCBvcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCApIHtcbiAgICAgIHNsaWRlci5oZWlnaHRTaXphYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLnByZWZlcnJlZFByb3BlcnR5ID0gdGhpcy5zbGlkZXIubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNsaWRlci53aWR0aFNpemFibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJlZmVycmVkUHJvcGVydHkgPSB0aGlzLnNsaWRlci5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5O1xuICAgIH1cbiAgICB0aGlzLnByZWZlcnJlZFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuXG4gICAgLy8gU28gcmFuZ2UgY2hhbmdlcyBvciBtaW5pbXVtIGNoYW5nZXMgd2lsbCB0cmlnZ2VyIGxheW91dHMgKHNpbmNlIHRoZXkgY2FuIG1vdmUgdGlja3MpXG4gICAgdGhpcy50cmFjay5yYW5nZVByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuXG4gICAgLy8gVGh1bWIgc2l6ZSBjaGFuZ2VzIHNob3VsZCB0cmlnZ2VyIGxheW91dCwgc2luY2Ugd2UgY2hlY2sgdGhlIHdpZHRoIG9mIHRoZSB0aHVtYlxuICAgIC8vIE5PVEU6IFRoaXMgaXMgaWdub3JpbmcgdGh1bWIgc2NhbGUgY2hhbmdpbmcsIGJ1dCBmb3IgcGVyZm9ybWFuY2UvY29ycmVjdG5lc3MgaXQgbWFrZXMgc2Vuc2UgdG8gYXZvaWQgdGhhdCBmb3Igbm93XG4gICAgLy8gc28gd2UgY2FuIHJ1bGUgb3V0IGluZmluaXRlIGxvb3BzIG9mIHRodW1iIG1vdmVtZW50LlxuICAgIHRoaXMudGh1bWIubG9jYWxCb3VuZHNQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTGF5b3V0TGlzdGVuZXIgKTtcblxuICAgIC8vIEFzIHRpY2tzIGFyZSBhZGRlZCwgYWRkIGEgbGlzdGVuZXIgdG8gZWFjaCB0aGF0IHdpbGwgdXBkYXRlIHRoZSBsYXlvdXQgaWYgdGhlIHRpY2sncyBib3VuZHMgY2hhbmdlcy5cbiAgICBjb25zdCB0aWNrQWRkZWRMaXN0ZW5lciA9ICggYWRkZWRUaWNrOiBTbGlkZXJUaWNrICkgPT4ge1xuICAgICAgYWRkZWRUaWNrLnRpY2tOb2RlLmxvY2FsQm91bmRzUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxheW91dExpc3RlbmVyICk7XG4gICAgICB0aWNrcy5hZGRJdGVtUmVtb3ZlZExpc3RlbmVyKCByZW1vdmVkVGljayA9PiB7XG4gICAgICAgIGlmICggcmVtb3ZlZFRpY2sgPT09IGFkZGVkVGljayAmJlxuICAgICAgICAgICAgIHJlbW92ZWRUaWNrLnRpY2tOb2RlLmxvY2FsQm91bmRzUHJvcGVydHkuaGFzTGlzdGVuZXIoIHRoaXMuX3VwZGF0ZUxheW91dExpc3RlbmVyICkgKSB7XG4gICAgICAgICAgYWRkZWRUaWNrLnRpY2tOb2RlLmxvY2FsQm91bmRzUHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfTtcbiAgICB0aWNrcy5hZGRJdGVtQWRkZWRMaXN0ZW5lciggdGlja0FkZGVkTGlzdGVuZXIgKTtcblxuICAgIHRoaXMuYWRkTm9kZSggdHJhY2sgKTtcblxuICAgIHRoaXMubGF5b3V0KCk7XG5cbiAgICB0aGlzLmRpc3Bvc2VTbGlkZXJDb25zdHJhaW50ID0gKCkgPT4ge1xuICAgICAgdGlja3MucmVtb3ZlSXRlbUFkZGVkTGlzdGVuZXIoIHRpY2tBZGRlZExpc3RlbmVyICk7XG4gICAgICB0aGlzLnByZWZlcnJlZFByb3BlcnR5LnVubGluayggdGhpcy5fdXBkYXRlTGF5b3V0TGlzdGVuZXIgKTtcbiAgICAgIHRoaXMudHJhY2sucmFuZ2VQcm9wZXJ0eS51bmxpbmsoIHRoaXMuX3VwZGF0ZUxheW91dExpc3RlbmVyICk7XG4gICAgICB0aGlzLnRodW1iLmxvY2FsQm91bmRzUHJvcGVydHkudW5saW5rKCB0aGlzLl91cGRhdGVMYXlvdXRMaXN0ZW5lciApO1xuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgbGF5b3V0KCk6IHZvaWQge1xuICAgIHN1cGVyLmxheW91dCgpO1xuXG4gICAgY29uc3Qgc2xpZGVyID0gdGhpcy5zbGlkZXI7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrO1xuICAgIGNvbnN0IHRodW1iID0gdGhpcy50aHVtYjtcblxuICAgIC8vIERpbGF0ZSB0aGUgbG9jYWwgYm91bmRzIGhvcml6b250YWxseSBzbyB0aGF0IGl0IGV4dGVuZHMgYmV5b25kIHdoZXJlIHRoZSB0aHVtYiBjYW4gcmVhY2guICBUaGlzIHByZXZlbnRzIGxheW91dFxuICAgIC8vIGFzeW1tZXRyeSB3aGVuIHRoZSBzbGlkZXIgdGh1bWIgaXMgb2ZmIHRoZSBlZGdlcyBvZiB0aGUgdHJhY2suICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvMjgyXG4gICAgdGhpcy50cmFja1NwYWNlci5sb2NhbEJvdW5kcyA9IHRyYWNrLmxvY2FsQm91bmRzLmRpbGF0ZWRYKCB0aHVtYi53aWR0aCAvIDIgKTtcblxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRyYWNrLm1pbmltdW1XaWR0aCAhPT0gbnVsbCApO1xuXG4gICAgLy8gT3VyIHRyYWNrJ3MgKGV4dGVyaW9yKSBtaW5pbXVtIHdpZHRoIHdpbGwgSU5DTFVERSBcInZpc3VhbCBvdmVyZmxvd1wiIGUuZy4gc3Ryb2tlLiBUaGUgYWN0dWFsIHJhbmdlIHVzZWQgZm9yXG4gICAgLy8gY29tcHV0YXRpb24gb2Ygd2hlcmUgdGhlIHRodW1iL3RpY2tzIGdvIHdpbGwgYmUgdGhlIFwiaW50ZXJpb3JcIiB3aWR0aCAoZXhjbHVkaW5nIHRoZSB2aXN1YWwgb3ZlcmZsb3cpLCBlLmcuXG4gICAgLy8gd2l0aG91dCB0aGUgc3Ryb2tlLiBXZSdsbCBuZWVkIHRvIHRyYWNrIGFuZCBoYW5kbGUgdGhlc2Ugc2VwYXJhdGVseSwgYW5kIG9ubHkgaGFuZGxlIHRpY2sgcG9zaXRpb25pbmcgYmFzZWQgb25cbiAgICAvLyB0aGUgaW50ZXJpb3Igd2lkdGguXG4gICAgY29uc3QgdG90YWxPdmVyZmxvdyA9IHRyYWNrLmxlZnRWaXN1YWxPdmVyZmxvdyArIHRyYWNrLnJpZ2h0VmlzdWFsT3ZlcmZsb3c7XG4gICAgY29uc3QgdHJhY2tNaW5pbXVtRXh0ZXJpb3JXaWR0aCA9IHRyYWNrLm1pbmltdW1XaWR0aCE7XG4gICAgY29uc3QgdHJhY2tNaW5pbXVtSW50ZXJpb3JXaWR0aCA9IHRyYWNrTWluaW11bUV4dGVyaW9yV2lkdGggLSB0b3RhbE92ZXJmbG93O1xuXG4gICAgLy8gVGFrZXMgYSB0aWNrJ3MgdmFsdWUgaW50byB0aGUgWzAsMV0gcmFuZ2UuIFRoaXMgc2hvdWxkIGJlIG11bHRpcGxpZWQgdGltZXMgdGhlIHBvdGVudGlhbCBJTlRFUklPUiB0cmFjayB3aWR0aFxuICAgIC8vIGluIG9yZGVyIHRvIGdldCB0aGUgcG9zaXRpb24gdGhlIHRpY2sgc2hvdWxkIGJlIGF0LlxuICAgIGNvbnN0IG5vcm1hbGl6ZVRpY2tWYWx1ZSA9ICggdmFsdWU6IG51bWJlciApID0+IHtcbiAgICAgIHJldHVybiBVdGlscy5saW5lYXIoIHRyYWNrLnJhbmdlUHJvcGVydHkudmFsdWUubWluLCB0cmFjay5yYW5nZVByb3BlcnR5LnZhbHVlLm1heCwgMCwgMSwgdmFsdWUgKTtcbiAgICB9O1xuXG4gICAgLy8gTk9URTogRHVlIHRvIHZpc3VhbCBvdmVyZmxvdywgb3VyIHRyYWNrJ3MgcmFuZ2UgKGluY2x1ZGluZyB0aGUgdGh1bWIgZXh0ZW5zaW9uKSB3aWxsIGFjdHVhbGx5IGdvIGZyb21cbiAgICAvLyAoIC10aHVtYi53aWR0aCAvIDIgLSB0cmFjay5sZWZ0VmlzdWFsT3ZlcmZsb3cgKSBvbiB0aGUgbGVmdCB0b1xuICAgIC8vICggdHJhY2tFeHRlcmlvcldpZHRoICsgdGh1bWIud2lkdGggLyAyICsgdHJhY2sucmlnaHRWaXN1YWxPdmVyZmxvdyApIG9uIHRoZSByaWdodC5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugb3VyIHRyYWNrJ3Mgd2lkdGggaXMgcmVkdWNlZCB0byBhY2NvdW50IGZvciBzdHJva2UsIGJ1dCB0aGUgbG9naWNhbCByZWN0YW5nbGUgaXMgc3RpbGwgbG9jYXRlZFxuICAgIC8vIGF0IHg9MCwgbWVhbmluZyB0aGUgc3Ryb2tlICh3aXRoIGxpbmVXaWR0aD0xKSB3aWxsIHR5cGljYWxseSBnbyBvdXQgdG8gLTAuNSAobmVnYXRpdmUgbGVmdCB2aXN1YWwgb3ZlcmZsb3cpLlxuICAgIC8vIE91ciBob3Jpem9udGFsIGJvdW5kcyBhcmUgdGh1cyBlZmZlY3RpdmVseSBvZmZzZXQgYnkgdGhpcyBsZWZ0IHZpc3VhbCBvdmVyZmxvdyBhbW91bnQuXG5cbiAgICAvLyBOT1RFOiBUaGlzIGFjdHVhbGx5IGdvZXMgUEFTVCB3aGVyZSB0aGUgdGh1bWIgc2hvdWxkIGdvIHdoZW4gdGhlcmUgaXMgdmlzdWFsIG92ZXJmbG93LCBidXQgd2UgYWxzb1xuICAgIC8vIGluY2x1ZGVkIHRoaXMgXCJpbXByZWNpc2lvblwiIGluIHRoZSBwYXN0IChsb2NhbEJvdW5kcyBJTkNMVURJTkcgdGhlIHN0cm9rZSB3YXMgZGlsYXRlZCBieSB0aGUgdGh1bWIgd2lkdGgpLCBzbyB3ZVxuICAgIC8vIHdpbGwgaGF2ZSBhIHNsaWdodCBiaXQgb2YgYWRkaXRpb25hbCBwYWRkaW5nIGluY2x1ZGVkIGhlcmUuXG5cbiAgICAvLyBOT1RFOiBEb2N1bWVudGF0aW9uIHdhcyBhZGRlZCBiZWZvcmUgZHluYW1pYyBsYXlvdXQgaW50ZWdyYXRpb24gKG5vdGluZyB0aGUgZXh0ZW5zaW9uIEJFWU9ORCB0aGUgYm91bmRzKTpcbiAgICAvLyA+IERpbGF0ZSB0aGUgbG9jYWwgYm91bmRzIGhvcml6b250YWxseSBzbyB0aGF0IGl0IGV4dGVuZHMgYmV5b25kIHdoZXJlIHRoZSB0aHVtYiBjYW4gcmVhY2guICBUaGlzIHByZXZlbnRzIGxheW91dFxuICAgIC8vID4gYXN5bW1ldHJ5IHdoZW4gdGhlIHNsaWRlciB0aHVtYiBpcyBvZmYgdGhlIGVkZ2VzIG9mIHRoZSB0cmFjay4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy8yODJcbiAgICBjb25zdCBsZWZ0RXh0ZXJpb3JPZmZzZXQgPSAtdGh1bWIud2lkdGggLyAyIC0gdHJhY2subGVmdFZpc3VhbE92ZXJmbG93O1xuICAgIGNvbnN0IHJpZ2h0RXh0ZXJpb3JPZmZzZXQgPSB0aHVtYi53aWR0aCAvIDIgLSB0cmFjay5sZWZ0VmlzdWFsT3ZlcmZsb3c7XG5cbiAgICAvLyBTdGFydCB3aXRoIHRoZSBzaXplIG91ciBtaW5pbXVtIHRyYWNrIHdvdWxkIGJlIFdJVEggdGhlIGFkZGVkIHNwYWNpbmcgZm9yIHRoZSB0aHVtYlxuICAgIC8vIE5PVEU6IHdpbGwgYmUgbXV0YXRlZCBiZWxvd1xuICAgIGNvbnN0IG1pbmltdW1SYW5nZSA9IG5ldyBSYW5nZSggbGVmdEV4dGVyaW9yT2Zmc2V0LCB0cmFja01pbmltdW1FeHRlcmlvcldpZHRoICsgcmlnaHRFeHRlcmlvck9mZnNldCApO1xuXG4gICAgLy8gV2UnbGwgbmVlZCB0byBjb25zaWRlciB3aGVyZSB0aGUgdGlja3Mgd291bGQgYmUgSUYgd2UgaGFkIG91ciBtaW5pbXVtIHNpemUgKHNpbmNlIHRoZSB0aWNrcyB3b3VsZCBwb3RlbnRpYWxseVxuICAgIC8vIGJlIHNwYWNlZCBjbG9zZXIgdG9nZXRoZXIpLiBTbyB3ZSdsbCBjaGVjayB0aGUgYm91bmRzIG9mIGVhY2ggdGljayBpZiBpdCB3YXMgYXQgdGhhdCBsb2NhdGlvbiwgYW5kXG4gICAgLy8gZW5zdXJlIHRoYXQgdGlja3MgYXJlIGluY2x1ZGVkIGluIG91ciBtaW5pbXVtIHJhbmdlIChzaW5jZSB0aWNrIGxhYmVscyBtYXkgc3RpY2sgb3V0IHBhc3QgdGhlIHRyYWNrKS5cbiAgICB0aGlzLnRpY2tzLmZvckVhY2goIHRpY2sgPT4ge1xuXG4gICAgICAvLyBXaGVyZSB0aGUgdGljayB3aWxsIGJlIGlmIHdlIGhhdmUgb3VyIG1pbmltdW0gc2l6ZVxuICAgICAgY29uc3QgdGlja01pbmltdW1Qb3NpdGlvbiA9IHRyYWNrTWluaW11bUludGVyaW9yV2lkdGggKiBub3JtYWxpemVUaWNrVmFsdWUoIHRpY2sudmFsdWUgKTtcblxuICAgICAgLy8gQWRqdXN0IHRoZSBtaW5pbXVtIHJhbmdlIHRvIGluY2x1ZGUgdGhlIHRpY2suXG4gICAgICBjb25zdCBoYWxmVGlja1dpZHRoID0gdGljay50aWNrTm9kZS53aWR0aCAvIDI7XG5cbiAgICAgIC8vIFRoZSB0aWNrIHdpbGwgYmUgY2VudGVyZWRcbiAgICAgIG1pbmltdW1SYW5nZS5pbmNsdWRlUmFuZ2UoIG5ldyBSYW5nZSggLWhhbGZUaWNrV2lkdGgsIGhhbGZUaWNrV2lkdGggKS5zaGlmdGVkKCB0aWNrTWluaW11bVBvc2l0aW9uICkgKTtcbiAgICB9ICk7XG5cbiAgICBpZiAoIHNsaWRlci53aWR0aFNpemFibGUgJiYgdGhpcy5wcmVmZXJyZWRQcm9wZXJ0eS52YWx1ZSAhPT0gbnVsbCApIHtcbiAgICAgIC8vIEhlcmUncyB3aGVyZSB0aGluZ3MgZ2V0IGNvbXBsaWNhdGVkISBBYm92ZSwgaXQncyBmYWlybHkgZWFzeSB0byBnbyBmcm9tIFwidHJhY2sgZXh0ZXJpb3Igd2lkdGhcIiA9PiBcInNsaWRlciB3aWR0aFwiLFxuICAgICAgLy8gaG93ZXZlciB3ZSBuZWVkIHRvIGRvIHRoZSBvcHBvc2l0ZSAod2hlbiBvdXIgaG9yaXpvbnRhbCBzbGlkZXIgaGFzIGEgcHJlZmVycmVkIHdpZHRoLCB3ZSBuZWVkIHRvIGNvbXB1dGUgd2hhdFxuICAgICAgLy8gdHJhY2sgd2lkdGggd2UnbGwgaGF2ZSB0byBtYWtlIHRoYXQgaGFwcGVuKS4gQXMgSSBub3RlZCBpbiB0aGUgaXNzdWUgZm9yIHRoaXMgd29yazpcblxuICAgICAgLy8gVGhlcmUncyBhIGZ1biBsaW5lYXIgb3B0aW1pemF0aW9uIHByb2JsZW0gaGlkaW5nIGluIHBsYWluIHNpZ2h0IChwZXJoYXBzIGEgaGlnaC1wZXJmb3JtYW5jZSBpdGVyYXRpdmUgc29sdXRpb24gd2lsbCB3b3JrKTpcbiAgICAgIC8vIC0gV2UgY2FuIGNvbXB1dGUgYSBtaW5pbXVtIHNpemUgKGdpdmVuIHRoZSBtaW5pbXVtIHRyYWNrIHNpemUsIHNlZSB3aGVyZSB0aGUgdGljayBsYWJlbHMgZ28sIGFuZCBpbmNsdWRlIHRob3NlKS5cbiAgICAgIC8vIC0gSE9XRVZFUiBhZGp1c3RpbmcgdGhlIHRyYWNrIHNpemUgQUxTTyBhZGp1c3RzIGhvdyBtdWNoIHRoZSB0aWNrIGxhYmVscyBzdGljayBvdXQgdG8gdGhlIHNpZGVzICh0aGUgZXhwYW5zaW9uXG4gICAgICAvLyAgIG9mIHRoZSB0cmFjayB3aWxsIHB1c2ggdGhlIHRpY2sgbGFiZWxzIGF3YXkgZnJvbSB0aGUgZWRnZXMpLlxuICAgICAgLy8gLSBEaWZmZXJlbnQgdGlja3Mgd2lsbCBiZSB0aGUgbGltaXRpbmcgZmFjdG9yIGZvciB0aGUgYm91bmRzIGF0IGRpZmZlcmVudCB0cmFjayBzaXplcyAoYSB0aWNrIGxhYmVsIG9uIHRoZSB2ZXJ5XG4gICAgICAvLyAgIGVuZCBzaG91bGQgbm90IHZhcnkgdGhlIGJvdW5kcyBvZmZzZXQsIGJ1dCBhIHRpY2sgbGFiZWwgdGhhdCdzIGxhcmdlciBidXQgc2xpZ2h0bHkgb2Zmc2V0IGZyb20gdGhlIGVkZ2UgV0lMTFxuICAgICAgLy8gICB2YXJ5IHRoZSBvZmZzZXQpXG4gICAgICAvLyAtIFNvIGl0J3MgZWFzeSB0byBjb21wdXRlIHRoZSByZXN1bHRpbmcgc2l6ZSBmcm9tIHRoZSB0cmFjayBzaXplLCBCVVQgdGhlIGludmVyc2UgcHJvYmxlbSBpcyBtb3JlIGRpZmZpY3VsdC5cbiAgICAgIC8vICAgRXNzZW50aWFsbHkgd2UgaGF2ZSBhIGNvbnZleCBwaWVjZXdpc2UtbGluZWFyIGZ1bmN0aW9uIG1hcHBpbmcgdHJhY2sgc2l6ZSB0byBvdXRwdXQgc2l6ZSAoaW1wbGljaXRseSBkZWZpbmVkXG4gICAgICAvLyAgIGJ5IHdoZXJlIHRpY2sgbGFiZWxzIHN3YXAgYmVpbmcgdGhlIGxpbWl0aW5nIGZhY3RvciksIGFuZCB3ZSBuZWVkIHRvIGludmVydCBpdC5cblxuICAgICAgLy8gRWZmZWN0aXZlbHkgdGhlIFwidHJhY2sgd2lkdGhcIiA9PiBcInNsaWRlciB3aWR0aFwiIGlzIGEgcGllY2V3aXNlLWxpbmVhciBmdW5jdGlvbiwgd2hlcmUgdGhlIGJyZWFrcG9pbnRzIG9jY3VyXG4gICAgICAvLyB3aGVyZSBPTkUgdGljayBlaXRoZXIgYmVjb21lcyB0aGUgbGltaXRpbmcgZmFjdG9yIG9yIHN0b3BzIGJlaW5nIHRoZSBsaW1pdGluZyBmYWN0b3IuIE1hdGhlbWF0aWNhbGx5LCB0aGlzIHdvcmtzXG4gICAgICAvLyBvdXQgdG8gYmUgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBmb3JtdWxhczpcblxuICAgICAgLy8gVGhlIExFRlQgeCBpcyB0aGUgbWluaW11bSBvZiBhbGwgdGhlIGZvbGxvd2luZzpcbiAgICAgIC8vICAgLXRodW1iLndpZHRoIC8gMiAtIHRyYWNrLmxlZnRWaXN1YWxPdmVyZmxvd1xuICAgICAgLy8gICBGT1IgRVZFUlkgVElDSzogLXRpY2tXaWR0aCAvIDIgKyAoIHRyYWNrV2lkdGggLSBvdmVyZmxvdyApICogbm9ybWFsaXplZFRpY2tWYWx1ZVxuICAgICAgLy8gVGhlIFJJR0hUIHggaXMgdGhlIG1heGltdW0gb2YgYWxsIHRoZSBmb2xsb3dpbmc6XG4gICAgICAvLyAgIHRyYWNrV2lkdGggKyB0aHVtYi53aWR0aCAvIDIgLSB0cmFjay5sZWZ0VmlzdWFsT3ZlcmZsb3dcbiAgICAgIC8vICAgKGZvciBldmVyeSB0aWNrKSB0aWNrV2lkdGggLyAyICsgKCB0cmFja1dpZHRoIC0gb3ZlcmZsb3cgKSAqIG5vcm1hbGl6ZWRUaWNrVmFsdWVcbiAgICAgIC8vIE5PVEU6IHRoZSBcInRyYWNrV2lkdGggLSBvdmVyZmxvd1wiIGlzIHRoZSBJTlRFUk5BTCB3aWR0aCAobm90IGluY2x1ZGluZyB0aGUgc3Ryb2tlKSB0aGF0IHdlIHVzZSBmb3IgdGlja1xuICAgICAgLy8gY29tcHV0YXRpb25cbiAgICAgIC8vIFRoaXMgZWZmZWN0aXZlbHkgY29tcHV0ZXMgaG93IGZhciBldmVyeXRoaW5nIFwic3RpY2tzIG91dFwiIGFuZCB3b3VsZCBhZmZlY3QgdGhlIGJvdW5kcy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgVE9UQUwgd2lkdGggb2YgdGhlIHNsaWRlciB3aWxsIHNpbXBseSBiZSB0aGUgYWJvdmUgUklHSFQgLSBMRUZULlxuXG4gICAgICAvLyBJbnN0ZWFkIG9mIHVzaW5nIG51bWVyaWNhbCBzb2x1dGlvbnMsIHdlJ3JlIGFibGUgdG8gc29sdmUgdGhpcyBhbmFseXRpY2FsbHkgd2l0aCBwaWVjZXdpc2UtbGluZWFyIGZ1bmN0aW9ucyB0aGF0XG4gICAgICAvLyBpbXBsZW1lbnQgdGhlIGFib3ZlIGZ1bmN0aW9ucy4gV2UnbGwgY29uc2lkZXIgZWFjaCBvZiB0aG9zZSBpbmRpdmlkdWFsIGZ1bmN0aW9ucyBhcyBhIGxpbmVhciBmdW5jdGlvbiB3aGVyZVxuICAgICAgLy8gdGhlIGlucHV0IGlzIHRoZSBleHRlcmlvciB0cmFjayBsZW5ndGgsIGUuZy4gZih0cmFja0xlbmd0aCkgPSBBICogdHJhY2tMZW5ndGggKyBCLCBmb3IgZ2l2ZW4gQSxCIHZhbHVlcy5cbiAgICAgIC8vIEJ5IG1pbi9tYXgtaW5nIHRoZXNlIHRvZ2V0aGVyIGFuZCB0aGVuIHRha2luZyB0aGUgZGlmZmVyZW5jZSwgd2UnbGwgaGF2ZSBhbiBhY2N1cmF0ZSBmdW5jdGlvbiBvZlxuICAgICAgLy8gZih0cmFja0xlbmd0aCkgPSBzbGlkZXJXaWR0aC4gVGhlbiB3ZSdsbCBpbnZlcnQgdGhhdCBmdW5jdGlvbiwgZS5nLiBmXi0xKHNsaWRlcldpZHRoKSA9IHRyYWNrTGVuZ3RoLCBhbmQgdGhlblxuICAgICAgLy8gd2UnbGwgYmUgYWJsZSB0byBwYXNzIGluIG91ciBwcmVmZXJyZWQgc2xpZGVyIHdpZHRoIGluIG9yZGVyIHRvIGNvbXB1dGUgdGhlIHByZWZlcnJlZCB0cmFjayBsZW5ndGguXG5cbiAgICAgIC8vIFdlJ2xsIG5lZWQgdG8gZmFjdG9yIHRoZSB0cmFja1dpZHRoIG91dCBmb3IgdGhlIHRpY2sgZnVuY3Rpb25zLCBzbzpcbiAgICAgIC8vIExFRlQgdGljayBjb21wdXRhdGlvbnM6XG4gICAgICAvLyAgIC10aWNrV2lkdGggLyAyICsgKCB0cmFja1dpZHRoIC0gb3ZlcmZsb3cgKSAqIG5vcm1hbGl6ZWRUaWNrVmFsdWVcbiAgICAgIC8vID0gLXRpY2tXaWR0aCAvIDIgKyB0cmFja1dpZHRoICogbm9ybWFsaXplZFRpY2tWYWx1ZSAtIG92ZXJmbG93ICogbm9ybWFsaXplZFRpY2tWYWx1ZVxuICAgICAgLy8gPSBub3JtYWxpemVkVGlja1ZhbHVlICogdHJhY2tXaWR0aCArICggLXRpY2tXaWR0aCAvIDIgLSBvdmVyZmxvdyAqIG5vcm1hbGl6ZWRUaWNrVmFsdWUgKVxuICAgICAgLy8gU28gd2hlbiB3ZSBwdXQgaXQgaW4gdGhlIGZvcm0gb2YgQSAqIHRyYWNrV2lkdGggKyBCLCB3ZSBnZXQ6XG4gICAgICAvLyAgIEEgPSBub3JtYWxpemVkVGlja1ZhbHVlLCBCID0gLXRpY2tXaWR0aCAvIDIgLSBvdmVyZmxvdyAqIG5vcm1hbGl6ZWRUaWNrVmFsdWVcbiAgICAgIC8vIFNpbWlsYXJseSBoYXBwZW5zIGZvciB0aGUgUklHSFQgdGljayBjb21wdXRhdGlvbi5cblxuICAgICAgY29uc3QgdHJhY2tXaWR0aFRvRnVsbFdpZHRoRnVuY3Rpb24gPSBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uLm1heChcbiAgICAgICAgLy8gUmlnaHQgc2lkZSAodHJhY2svdGh1bWIpXG4gICAgICAgIENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ubGluZWFyKCAxLCByaWdodEV4dGVyaW9yT2Zmc2V0ICksXG4gICAgICAgIC8vIFJpZ2h0IHNpZGUgKHRpY2tzKVxuICAgICAgICAuLi50aGlzLnRpY2tzLm1hcCggdGljayA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFRpY2tWYWx1ZSA9IG5vcm1hbGl6ZVRpY2tWYWx1ZSggdGljay52YWx1ZSApO1xuICAgICAgICAgIHJldHVybiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uLmxpbmVhciggbm9ybWFsaXplZFRpY2tWYWx1ZSwgdGljay50aWNrTm9kZS53aWR0aCAvIDIgLSB0b3RhbE92ZXJmbG93ICogbm9ybWFsaXplZFRpY2tWYWx1ZSApO1xuICAgICAgICB9IClcbiAgICAgICkubWludXMoIENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ubWluKFxuICAgICAgICAvLyBMZWZ0IHNpZGUgKHRyYWNrL3RodW1iKVxuICAgICAgICBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uLmNvbnN0YW50KCBsZWZ0RXh0ZXJpb3JPZmZzZXQgKSxcbiAgICAgICAgLy8gTGVmdCBzaWRlICh0aWNrcylcbiAgICAgICAgLi4udGhpcy50aWNrcy5tYXAoIHRpY2sgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFRpY2tWYWx1ZSA9IG5vcm1hbGl6ZVRpY2tWYWx1ZSggdGljay52YWx1ZSApO1xuICAgICAgICAgICAgcmV0dXJuIENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ubGluZWFyKCBub3JtYWxpemVkVGlja1ZhbHVlLCAtdGljay50aWNrTm9kZS53aWR0aCAvIDIgLSB0b3RhbE92ZXJmbG93ICogbm9ybWFsaXplZFRpY2tWYWx1ZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgKSApICk7XG5cbiAgICAgIC8vIE5PVEU6IFRoaXMgZnVuY3Rpb24gaXMgb25seSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgd2hlbiB0cmFja1dpZHRoIGlzIHBvc2l0aXZlISBXZSdsbCBkcm9wIHRoZSB2YWx1ZXNcbiAgICAgIC8vIHVuZGVybmVhdGggb3VyIG1pbmltdW0gdHJhY2sgd2lkdGggKHRoZXkgd29uJ3QgYmUgbmVlZGVkKSwgYnV0IHdlJ2xsIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHBvaW50IGJlbG93IHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgc2xvcGUgaXMgbWFpbnRhaW5lZCAoZHVlIHRvIGhvdyBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHdvcmtzKS5cbiAgICAgIGNvbnN0IGZ1bGxXaWR0aFRvVHJhY2tXaWR0aEZ1bmN0aW9uID0gdHJhY2tXaWR0aFRvRnVsbFdpZHRoRnVuY3Rpb24ud2l0aFhWYWx1ZXMoIFtcbiAgICAgICAgdHJhY2tNaW5pbXVtRXh0ZXJpb3JXaWR0aCAtIDEsXG4gICAgICAgIHRyYWNrTWluaW11bUV4dGVyaW9yV2lkdGgsXG4gICAgICAgIC4uLnRyYWNrV2lkdGhUb0Z1bGxXaWR0aEZ1bmN0aW9uLnBvaW50cy5tYXAoIHBvaW50ID0+IHBvaW50LnggKS5maWx0ZXIoIHggPT4geCA+IHRyYWNrTWluaW11bUV4dGVyaW9yV2lkdGggKyAxZS0xMCApXG4gICAgICBdICkuaW52ZXJ0ZWQoKTtcblxuICAgICAgdHJhY2sucHJlZmVycmVkV2lkdGggPSBNYXRoLm1heChcbiAgICAgICAgLy8gRW5zdXJlIHdlJ3JlIE5PVCBkaXBwaW5nIGJlbG93IHRoZSBtaW5pbXVtIHRyYWNrIHdpZHRoIChmb3Igc29tZSByZWFzb24pLlxuICAgICAgICB0cmFja01pbmltdW1FeHRlcmlvcldpZHRoLFxuICAgICAgICBmdWxsV2lkdGhUb1RyYWNrV2lkdGhGdW5jdGlvbi5ldmFsdWF0ZSggdGhpcy5wcmVmZXJyZWRQcm9wZXJ0eS52YWx1ZSApXG4gICAgICApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRyYWNrLnByZWZlcnJlZFdpZHRoID0gdHJhY2subWluaW11bVdpZHRoO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbmltdW1XaWR0aCA9IG1pbmltdW1SYW5nZS5nZXRMZW5ndGgoKTtcblxuICAgIC8vIFNldCBtaW5pbXVtcyBhdCB0aGUgZW5kXG4gICAgaWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMICkge1xuICAgICAgc2xpZGVyLmxvY2FsTWluaW11bVdpZHRoID0gbWluaW11bVdpZHRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNsaWRlci5sb2NhbE1pbmltdW1IZWlnaHQgPSBtaW5pbXVtV2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlU2xpZGVyQ29uc3RyYWludCgpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG5zdW4ucmVnaXN0ZXIoICdTbGlkZXInLCBTbGlkZXIgKTsiXSwibmFtZXMiOlsiY3JlYXRlT2JzZXJ2YWJsZUFycmF5IiwiTXVsdGlsaW5rIiwiUHJvcGVydHkiLCJSZWFkT25seVByb3BlcnR5IiwiVGlueVByb3BlcnR5IiwiQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiIsIkRpbWVuc2lvbjIiLCJSYW5nZSIsIlV0aWxzIiwiVmVjdG9yMiIsImFzc2VydE11dHVhbGx5RXhjbHVzaXZlT3B0aW9ucyIsIkluc3RhbmNlUmVnaXN0cnkiLCJvcHRpb25pemUiLCJjb21iaW5lT3B0aW9ucyIsIk9yaWVudGF0aW9uIiwic3dhcE9iamVjdEtleXMiLCJhc3NlcnROb0FkZGl0aW9uYWxDaGlsZHJlbiIsIkRyYWdMaXN0ZW5lciIsIkhpZ2hsaWdodEZyb21Ob2RlIiwiTGF5b3V0Q29uc3RyYWludCIsIk5vZGUiLCJTY2VuZXJ5Q29uc3RhbnRzIiwiU2l6YWJsZSIsIlZhbHVlQ2hhbmdlU291bmRQbGF5ZXIiLCJpc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5IiwiVGFuZGVtIiwiSU9UeXBlIiwiQWNjZXNzaWJsZVNsaWRlciIsIkRlZmF1bHRTbGlkZXJUcmFjayIsIlNsaWRlclRodW1iIiwiU2xpZGVyVGljayIsInN1biIsIlN1bkNvbnN0YW50cyIsIkRFRkFVTFRfSE9SSVpPTlRBTF9UUkFDS19TSVpFIiwiREVGQVVMVF9IT1JJWk9OVEFMX1RIVU1CX1NJWkUiLCJTbGlkZXIiLCJtYWpvclRpY2tzVmlzaWJsZSIsImdldE1ham9yVGlja3NWaXNpYmxlIiwidmFsdWUiLCJzZXRNYWpvclRpY2tzVmlzaWJsZSIsIm1pbm9yVGlja3NWaXNpYmxlIiwiZ2V0TWlub3JUaWNrc1Zpc2libGUiLCJzZXRNaW5vclRpY2tzVmlzaWJsZSIsImRpc3Bvc2UiLCJkaXNwb3NlU2xpZGVyIiwidGlja3MiLCJmb3JFYWNoIiwidGljayIsImFkZE1ham9yVGljayIsImxhYmVsIiwiYWRkVGljayIsIm1ham9yVGlja3NQYXJlbnQiLCJ0aWNrT3B0aW9ucyIsIm1ham9yVGlja0xlbmd0aCIsIm1ham9yVGlja1N0cm9rZSIsIm1ham9yVGlja0xpbmVXaWR0aCIsImFkZE1pbm9yVGljayIsIm1pbm9yVGlja3NQYXJlbnQiLCJtaW5vclRpY2tMZW5ndGgiLCJtaW5vclRpY2tTdHJva2UiLCJtaW5vclRpY2tMaW5lV2lkdGgiLCJwYXJlbnQiLCJsZW5ndGgiLCJzdHJva2UiLCJsaW5lV2lkdGgiLCJwdXNoIiwib3JpZW50YXRpb24iLCJ0cmFjayIsInZpc2libGUiLCJ2YWx1ZVByb3BlcnR5IiwicmFuZ2UiLCJwcm92aWRlZE9wdGlvbnMiLCJ3aW5kb3ciLCJhc3NlcnQiLCJvcHRpb25zIiwiSE9SSVpPTlRBTCIsInRyYWNrTm9kZSIsInRyYWNrU2l6ZSIsInRyYWNrRmlsbEVuYWJsZWQiLCJ0cmFja0ZpbGxEaXNhYmxlZCIsInRyYWNrU3Ryb2tlIiwidHJhY2tMaW5lV2lkdGgiLCJ0cmFja0Nvcm5lclJhZGl1cyIsInRyYWNrUGlja2FibGUiLCJ0aHVtYk5vZGUiLCJ0aHVtYlNpemUiLCJ0aHVtYkZpbGwiLCJ0aHVtYkZpbGxIaWdobGlnaHRlZCIsInRodW1iU3Ryb2tlIiwidGh1bWJMaW5lV2lkdGgiLCJ0aHVtYkNlbnRlckxpbmVTdHJva2UiLCJ0aHVtYlRvdWNoQXJlYVhEaWxhdGlvbiIsInRodW1iVG91Y2hBcmVhWURpbGF0aW9uIiwidGh1bWJNb3VzZUFyZWFYRGlsYXRpb24iLCJ0aHVtYk1vdXNlQXJlYVlEaWxhdGlvbiIsInRodW1iWU9mZnNldCIsInRpY2tMYWJlbFNwYWNpbmciLCJwb3NpdGlvbkxhYmVsIiwidGlja0JvdW5kcyIsImNlbnRlclgiLCJib3R0b20iLCJ0b3AiLCJzZXRUaWNrSW5pdGlhbFBvaW50IiwidHJhY2tCb3VuZHMiLCJ0aWNrTGVuZ3RoIiwiY3Vyc29yIiwic3RhcnREcmFnIiwiXyIsIm5vb3AiLCJkcmFnIiwiZW5kRHJhZyIsImNvbnN0cmFpblZhbHVlIiwiaWRlbnRpdHkiLCJkaXNhYmxlZE9wYWNpdHkiLCJESVNBQkxFRF9PUEFDSVRZIiwic291bmRHZW5lcmF0b3IiLCJERUZBVUxUX1NPVU5EX0dFTkVSQVRPUiIsInZhbHVlQ2hhbmdlU291bmRHZW5lcmF0b3JPcHRpb25zIiwicGhldGlvTGlua2VkUHJvcGVydHkiLCJ0YW5kZW0iLCJSRVFVSVJFRCIsInRhbmRlbU5hbWVTdWZmaXgiLCJwaGV0aW9UeXBlIiwiU2xpZGVySU8iLCJwaGV0aW9GZWF0dXJlZCIsInZpc2libGVQcm9wZXJ0eU9wdGlvbnMiLCJwaGV0aW9FbmFibGVkUHJvcGVydHlJbnN0cnVtZW50ZWQiLCJyYW5nZVByb3BlcnR5IiwiaXNFbXB0eSIsIk5PX1NPVU5EIiwicHJldmlvdXNWYWx1ZSIsInByb3ZpZGVkRHJhZyIsImV2ZW50IiwiaXNGcm9tUERPTSIsInBsYXlTb3VuZEZvclZhbHVlQ2hhbmdlIiwicGxheVNvdW5kSWZUaHJlc2hvbGRSZWFjaGVkIiwiVkVSVElDQUwiLCJzd2FwcGVkIiwidGh1bWJUYW5kZW0iLCJjcmVhdGVUYW5kZW0iLCJUSFVNQl9OT0RFX1RBTkRFTV9OQU1FIiwiVkFMSURBVElPTiIsImVxdWFscyIsInBoZXRpb0lEIiwidGh1bWIiLCJzaXplIiwiZmlsbCIsImZpbGxIaWdobGlnaHRlZCIsImNlbnRlckxpbmVTdHJva2UiLCJvd25zRW5hYmxlZFJhbmdlUHJvcGVydHkiLCJlbmFibGVkUmFuZ2VQcm9wZXJ0eSIsImJvdW5kc1JlcXVpcmVkT3B0aW9uS2V5cyIsInBpY2siLCJSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVMiLCJzdXBlck9wdGlvbnMiLCJhcmlhT3JpZW50YXRpb24iLCJwYW5UYXJnZXROb2RlIiwidmFsdWVUeXBlIiwiaXNWYWxpZFZhbHVlIiwibWluIiwibWF4IiwidmFsdWVDb21wYXJpc29uU3RyYXRlZ3kiLCJwaGV0aW9WYWx1ZVR5cGUiLCJSYW5nZUlPIiwicGhldGlvRG9jdW1lbnRhdGlvbiIsInByb3Bvc2VkVmFsdWUiLCJzbGlkZXJQYXJ0cyIsInRyYWNrVGFuZGVtIiwiVFJBQ0tfTk9ERV9UQU5ERU1fTkFNRSIsInRyYWNrU3BhY2VyIiwiZmlsbEVuYWJsZWQiLCJmaWxsRGlzYWJsZWQiLCJjb3JuZXJSYWRpdXMiLCJwaWNrYWJsZSIsInZvaWNpbmdPbkVuZFJlc3BvbnNlIiwiYmluZCIsInNldENlbnRlclkiLCJjZW50ZXJZIiwic2xpZGVyUGFydHNOb2RlIiwiY2hpbGRyZW4iLCJyb3RhdGlvbiIsIlNMSURFUl9WRVJUSUNBTF9ST1RBVElPTiIsImFkZENoaWxkIiwidG91Y2hBcmVhIiwibG9jYWxCb3VuZHMiLCJkaWxhdGVkWFkiLCJtb3VzZUFyZWEiLCJjbGlja1hPZmZzZXQiLCJ2YWx1ZU9uU3RhcnQiLCJ0aHVtYkRyYWdMaXN0ZW5lciIsInN0YXJ0IiwibGlzdGVuZXIiLCJlbmFibGVkUHJvcGVydHkiLCJnZXQiLCJ0cmFuc2Zvcm0iLCJwcmVzc2VkVHJhaWwiLCJzdWJ0cmFpbFRvIiwiZ2V0VHJhbnNmb3JtIiwiaW52ZXJzZVBvc2l0aW9uMiIsInBvaW50ZXIiLCJwb2ludCIsIngiLCJ2YWx1ZVRvUG9zaXRpb25Qcm9wZXJ0eSIsImludmVyc2UiLCJ2YWx1ZUluUmFuZ2UiLCJzZXQiLCJlbmQiLCJhZGRJbnB1dExpc3RlbmVyIiwidHJhY2tEcmFnTGlzdGVuZXIiLCJkcmFnTGlzdGVuZXIiLCJ2YWx1ZU11bHRpbGluayIsIm11bHRpbGluayIsInZhbHVlVG9Qb3NpdGlvbiIsImV2YWx1YXRlIiwiZW5hYmxlZFJhbmdlT2JzZXJ2ZXIiLCJlbmFibGVkUmFuZ2UiLCJpc1BoZXRpb0luc3RydW1lbnRlZCIsImNsYW1wIiwicHJvcG9zZWRWYWx1ZUluRW5hYmxlZFJhbmdlIiwicHJvcG9zZWRWYWx1ZUluQ29uc3RyYWluZWRSYW5nZSIsImxpbmsiLCJjb25zdHJhaW50IiwiU2xpZGVyQ29uc3RyYWludCIsInVubGluayIsImZvY3VzSGlnaGxpZ2h0IiwibGlua2VkUHJvcGVydHkiLCJhZGRMaW5rZWRFbGVtZW50IiwidGFuZGVtTmFtZSIsIm11dGF0ZSIsInBoZXQiLCJjaGlwcGVyIiwicXVlcnlQYXJhbWV0ZXJzIiwiYmluZGVyIiwicmVnaXN0ZXJEYXRhVVJMIiwiZG9jdW1lbnRhdGlvbiIsInN1cGVydHlwZSIsIk5vZGVJTyIsImxheW91dCIsInNsaWRlciIsImRpbGF0ZWRYIiwid2lkdGgiLCJtaW5pbXVtV2lkdGgiLCJ0b3RhbE92ZXJmbG93IiwibGVmdFZpc3VhbE92ZXJmbG93IiwicmlnaHRWaXN1YWxPdmVyZmxvdyIsInRyYWNrTWluaW11bUV4dGVyaW9yV2lkdGgiLCJ0cmFja01pbmltdW1JbnRlcmlvcldpZHRoIiwibm9ybWFsaXplVGlja1ZhbHVlIiwibGluZWFyIiwibGVmdEV4dGVyaW9yT2Zmc2V0IiwicmlnaHRFeHRlcmlvck9mZnNldCIsIm1pbmltdW1SYW5nZSIsInRpY2tNaW5pbXVtUG9zaXRpb24iLCJoYWxmVGlja1dpZHRoIiwidGlja05vZGUiLCJpbmNsdWRlUmFuZ2UiLCJzaGlmdGVkIiwid2lkdGhTaXphYmxlIiwicHJlZmVycmVkUHJvcGVydHkiLCJ0cmFja1dpZHRoVG9GdWxsV2lkdGhGdW5jdGlvbiIsIm1hcCIsIm5vcm1hbGl6ZWRUaWNrVmFsdWUiLCJtaW51cyIsImNvbnN0YW50IiwiZnVsbFdpZHRoVG9UcmFja1dpZHRoRnVuY3Rpb24iLCJ3aXRoWFZhbHVlcyIsInBvaW50cyIsImZpbHRlciIsImludmVydGVkIiwicHJlZmVycmVkV2lkdGgiLCJNYXRoIiwiZ2V0TGVuZ3RoIiwibG9jYWxNaW5pbXVtV2lkdGgiLCJsb2NhbE1pbmltdW1IZWlnaHQiLCJkaXNwb3NlU2xpZGVyQ29uc3RyYWludCIsImhlaWdodFNpemFibGUiLCJsb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkiLCJsb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5IiwibGF6eUxpbmsiLCJfdXBkYXRlTGF5b3V0TGlzdGVuZXIiLCJsb2NhbEJvdW5kc1Byb3BlcnR5IiwidGlja0FkZGVkTGlzdGVuZXIiLCJhZGRlZFRpY2siLCJhZGRJdGVtUmVtb3ZlZExpc3RlbmVyIiwicmVtb3ZlZFRpY2siLCJoYXNMaXN0ZW5lciIsImFkZEl0ZW1BZGRlZExpc3RlbmVyIiwiYWRkTm9kZSIsInJlbW92ZUl0ZW1BZGRlZExpc3RlbmVyIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7OztDQU9DLEdBRUQsT0FBT0EsMkJBQWdELHlDQUF5QztBQUNoRyxPQUFPQyxlQUFlLDZCQUE2QjtBQUVuRCxPQUFPQyxjQUFjLDRCQUE0QjtBQUNqRCxPQUFPQyxzQkFBc0Isb0NBQW9DO0FBQ2pFLE9BQU9DLGtCQUFrQixnQ0FBZ0M7QUFHekQsT0FBT0MscUNBQXFDLGtEQUFrRDtBQUM5RixPQUFPQyxnQkFBZ0IsNkJBQTZCO0FBQ3BELE9BQU9DLFdBQVcsd0JBQXdCO0FBQzFDLE9BQU9D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