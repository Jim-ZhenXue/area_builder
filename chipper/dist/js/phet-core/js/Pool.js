// Copyright 2022-2024, University of Colorado Boulder
/**
 * PROTOTYPE version for better support
 *
 * Object pooling mixin, for cases where creating new objects is expensive, and we'd rather mark some objects as able
 * to be reused (i.e. 'in the pool'). This provides a pool of objects for each type it is invoked on. It allows for
 * getting "new" objects that can either be constructed OR pulled in from a pool, and requires that the objects are
 * essentially able to "re-run" the constructor. Then when putting the object back in the pool, references should be
 * released, so memory isn't leaked.
 *
 * With this style of pooling, the following should be standard boilerplate within the class:

 public freeToPool(): void {
 MyType.pool.freeToPool( this );
 }

 public static readonly pool = new Pool( MyType );

 * and can additionally implement TPoolable to make it clear that the type is pooled
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */ import optionize from './optionize.js';
import phetCore from './phetCore.js';
let Pool = class Pool {
    createDefaultObject() {
        return new this.DefaultConstructor();
    }
    /**
   * Returns an object with arbitrary state (possibly constructed with the default arguments).
   */ fetch() {
        return this.objects.length ? this.objects.pop() : this.createDefaultObject();
    }
    /**
   * Returns an object that behaves as if it was constructed with the given arguments. May result in a new object
   * being created (if the pool is empty), or it may use the constructor to mutate an object from the pool.
   */ create(...args) {
        let result;
        if (this.objects.length) {
            result = this.objects.pop();
            this.initialize.apply(result, args);
        } else if (this.useDefaultConstruction) {
            result = this.createDefaultObject();
            this.initialize.apply(result, args);
        } else {
            result = new (this.partialConstructor(...args))();
        }
        return result;
    }
    /**
   * Returns the current size of the pool.
   */ get poolSize() {
        return this.objects.length;
    }
    /**
   * Sets the maximum pool size.
   */ set maxPoolSize(value) {
        assert && assert(value === Number.POSITIVE_INFINITY || Number.isInteger(value) && value >= 0, 'maxPoolSize should be a non-negative integer or infinity');
        this._maxPoolSize = value;
    }
    /**
   * Returns the maximum pool size.
   */ get maxPoolSize() {
        return this._maxPoolSize;
    }
    freeToPool(object) {
        if (this.objects.length < this.maxPoolSize) {
            this.objects.push(object);
        }
    }
    forEach(callback) {
        this.objects.forEach(callback);
    }
    // The `initialize` option is required if the type doesn't have a correctly-typed initialize method. Therefore, we
    // do some Typescript magic to require providedOptions if that's the case (otherwise providedOptions is optional).
    constructor(type, ...providedOptionsSpread){
        this.objects = [];
        const options = optionize()({
            defaultArguments: [],
            initialize: type.prototype.initialize,
            maxSize: 100,
            initialSize: 0,
            useDefaultConstruction: false
        }, providedOptionsSpread[0]);
        assert && assert(options.maxSize >= 0);
        assert && assert(options.initialSize >= 0);
        this._maxPoolSize = options.maxSize;
        // There is a madness to this craziness. We'd want to use the method noted at
        // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible, but the type is
        // not provided in the arguments array below. By calling bind on itself, we're able to get a version of bind that
        // inserts the constructor as the first argument of the .apply called later so we don't create garbage by having
        // to pack `arguments` into an array AND THEN concatenate it with a new first element (the type itself).
        this.partialConstructor = Function.prototype.bind.bind(type, type);
        // Basically our type constructor, but with the default arguments included already.
        this.DefaultConstructor = this.partialConstructor(...options.defaultArguments); // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion
        this.initialize = options.initialize;
        assert && assert(this.initialize, 'Either pass in an initialize option, or provide a method named initialize on the type with the proper signature');
        this.useDefaultConstruction = options.useDefaultConstruction;
        // Initialize the pool (if it should have objects)
        while(this.objects.length < options.initialSize){
            this.objects.push(this.createDefaultObject());
        }
    }
};
export { Pool as default };
phetCore.register('Pool', Pool);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9Qb29sLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIyLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIFBST1RPVFlQRSB2ZXJzaW9uIGZvciBiZXR0ZXIgc3VwcG9ydFxuICpcbiAqIE9iamVjdCBwb29saW5nIG1peGluLCBmb3IgY2FzZXMgd2hlcmUgY3JlYXRpbmcgbmV3IG9iamVjdHMgaXMgZXhwZW5zaXZlLCBhbmQgd2UnZCByYXRoZXIgbWFyayBzb21lIG9iamVjdHMgYXMgYWJsZVxuICogdG8gYmUgcmV1c2VkIChpLmUuICdpbiB0aGUgcG9vbCcpLiBUaGlzIHByb3ZpZGVzIGEgcG9vbCBvZiBvYmplY3RzIGZvciBlYWNoIHR5cGUgaXQgaXMgaW52b2tlZCBvbi4gSXQgYWxsb3dzIGZvclxuICogZ2V0dGluZyBcIm5ld1wiIG9iamVjdHMgdGhhdCBjYW4gZWl0aGVyIGJlIGNvbnN0cnVjdGVkIE9SIHB1bGxlZCBpbiBmcm9tIGEgcG9vbCwgYW5kIHJlcXVpcmVzIHRoYXQgdGhlIG9iamVjdHMgYXJlXG4gKiBlc3NlbnRpYWxseSBhYmxlIHRvIFwicmUtcnVuXCIgdGhlIGNvbnN0cnVjdG9yLiBUaGVuIHdoZW4gcHV0dGluZyB0aGUgb2JqZWN0IGJhY2sgaW4gdGhlIHBvb2wsIHJlZmVyZW5jZXMgc2hvdWxkIGJlXG4gKiByZWxlYXNlZCwgc28gbWVtb3J5IGlzbid0IGxlYWtlZC5cbiAqXG4gKiBXaXRoIHRoaXMgc3R5bGUgb2YgcG9vbGluZywgdGhlIGZvbGxvd2luZyBzaG91bGQgYmUgc3RhbmRhcmQgYm9pbGVycGxhdGUgd2l0aGluIHRoZSBjbGFzczpcblxuIHB1YmxpYyBmcmVlVG9Qb29sKCk6IHZvaWQge1xuIE15VHlwZS5wb29sLmZyZWVUb1Bvb2woIHRoaXMgKTtcbiB9XG5cbiBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHBvb2wgPSBuZXcgUG9vbCggTXlUeXBlICk7XG5cbiAqIGFuZCBjYW4gYWRkaXRpb25hbGx5IGltcGxlbWVudCBUUG9vbGFibGUgdG8gbWFrZSBpdCBjbGVhciB0aGF0IHRoZSB0eXBlIGlzIHBvb2xlZFxuICpcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cbiAqL1xuXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4vb3B0aW9uaXplLmpzJztcbmltcG9ydCBwaGV0Q29yZSBmcm9tICcuL3BoZXRDb3JlLmpzJztcbmltcG9ydCBDb25zdHJ1Y3RvciBmcm9tICcuL3R5cGVzL0NvbnN0cnVjdG9yLmpzJztcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcblxudHlwZSBTZWxmUG9vbGFibGVPcHRpb25zPFQgZXh0ZW5kcyBDb25zdHJ1Y3Rvcj4gPSB7XG4gIC8vIElmIGFuIG9iamVjdCBuZWVkcyB0byBiZSBjcmVhdGVkIHdpdGhvdXQgYSBkaXJlY3QgY2FsbCAoc2F5LCB0byBmaWxsIHRoZSBwb29sIGluaXRpYWxseSksIHRoZXNlIGFyZSB0aGUgYXJndW1lbnRzXG4gIC8vIHRoYXQgd2lsbCBiZSBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3JcbiAgZGVmYXVsdEFyZ3VtZW50cz86IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPjtcblxuICAvLyBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiB0aGUgb2JqZWN0cyB0byByZWluaXRpYWxpemUgdGhlbSAodGhhdCBpcyBlaXRoZXIgdGhlIGNvbnN0cnVjdG9yLCBvciBhY3RzIGxpa2UgdGhlXG4gIC8vIGNvbnN0cnVjdG9yKS4gTk9URTogVGhpcyBzaG91bGQgcmV0dXJuIHRoZSBvYmplY3QgaXRzZWxmIVxuICBpbml0aWFsaXplPzogUG9vbGFibGVJbml0aWFsaXplcjxUPjtcblxuICAvLyBBIGxpbWl0IGZvciB0aGUgcG9vbCBzaXplIChzbyB3ZSBkb24ndCBsZWFrIG1lbW9yeSBieSBncm93aW5nIHRoZSBwb29sIGZhc3RlciB0aGFuIHdlIHRha2UgdGhpbmdzIGZyb20gaXQpLiBDYW4gYmVcbiAgLy8gY3VzdG9taXplZCBieSBzZXR0aW5nIFR5cGUubWF4UG9vbFNpemVcbiAgbWF4U2l6ZT86IG51bWJlcjtcblxuICAvLyBUaGUgaW5pdGlhbCBzaXplIG9mIHRoZSBwb29sLiBUbyBmaWxsIGl0LCBvYmplY3RzIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZSBkZWZhdWx0IGFyZ3VtZW50cy5cbiAgaW5pdGlhbFNpemU/OiBudW1iZXI7XG5cbiAgLy8gSWYgdHJ1ZSwgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGRlZmF1bHQgYXJndW1lbnRzIHdpbGwgYWx3YXlzIGJlIHVzZWQgKGFuZCB0aGVuIGluaXRpYWxpemVkIHdpdGggdGhlIGluaXRpYWxpemVyKVxuICAvLyBpbnN0ZWFkIG9mIGp1c3QgcHJvdmlkaW5nIHRoZSBhcmd1bWVudHMgc3RyYWlnaHQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICB1c2VEZWZhdWx0Q29uc3RydWN0aW9uPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFBvb2xhYmxlT3B0aW9uczxUIGV4dGVuZHMgQ29uc3RydWN0b3I+ID1cbiAgU2VsZlBvb2xhYmxlT3B0aW9uczxUPiAmICggSW5zdGFuY2VUeXBlPFQ+IGV4dGVuZHMgeyBpbml0aWFsaXplOiBQb29sYWJsZUluaXRpYWxpemVyPFQ+IH0gPyB1bmtub3duIDoge1xuICAvLyBSZXF1aXJlIGluaXRpYWxpemUgaWYgb3VyIHR5cGUgZG9lc24ndCBoYXZlIGEgY29tcGF0aWJsZSBpbml0aWFsaXplIG1ldGhvZC5cbiAgaW5pdGlhbGl6ZTogUG9vbGFibGVJbml0aWFsaXplcjxUPjtcbn0gKTtcbnR5cGUgUG9vbGFibGVJbml0aWFsaXplcjxUIGV4dGVuZHMgQ29uc3RydWN0b3I+ID0gKCAuLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gKSA9PiBJbnN0YW5jZVR5cGU8VD47XG5cbmV4cG9ydCB0eXBlIFRQb29sYWJsZSA9IHtcblxuICAvLyBBZGRzIHRoaXMgb2JqZWN0IGludG8gdGhlIHBvb2wsIHNvIHRoYXQgaXQgY2FuIGJlIHJldXNlZCBlbHNld2hlcmUuIEdlbmVyYWxseSB3aGVuIHRoaXMgaXMgZG9uZSwgbm8gb3RoZXJcbiAgLy8gcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0IHNob3VsZCBiZSBoZWxkIChzaW5jZSB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBhdCBhbGwpLlxuICBmcmVlVG9Qb29sOiAoKSA9PiB2b2lkO1xufTtcblxuLy8gT3VyIGxpbnRlciBjb21wbGFpbnMgdGhhdCB7fSBzaG91bGQgYmUgZWl0aGVyIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCB1bmtub3duLCBvciBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4uIEhvd2V2ZXIgaW5cbi8vIHRoaXMgY2FzZSwgd2UgYWN0dWFsbHkgd2FudCBpdCB0byBiZSBhbnkgdHlwZSBvZiBub24tbnVsbGlzaCBzdHJ1Y3R1cmFsIHR5cGUsIHRvIHNlZSBpZiB0aGVyZSBpcyBhbnl0aGluZyByZXF1aXJlZC5cbmV4cG9ydCB0eXBlIFBvc3NpYmx5UmVxdWlyZWRQYXJhbWV0ZXJTcHJlYWQ8VD4gPSAoIHt9IGV4dGVuZHMgVCA/IFsgVD8gXSA6IFsgVCBdICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlc3RyaWN0ZWQtdHlwZXNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9vbDxUIGV4dGVuZHMgQ29uc3RydWN0b3I+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBvYmplY3RzOiBJbnN0YW5jZVR5cGU8VD5bXSA9IFtdO1xuXG4gIHByaXZhdGUgX21heFBvb2xTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGFydGlhbENvbnN0cnVjdG9yOiAoIC4uLmFyZ3M6IEludGVudGlvbmFsQW55W10gKSA9PiBJbnRlbnRpb25hbEFueTtcbiAgcHJpdmF0ZSByZWFkb25seSBEZWZhdWx0Q29uc3RydWN0b3I6IEludGVudGlvbmFsQW55O1xuICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxpemU6IFBvb2xhYmxlSW5pdGlhbGl6ZXI8VD47XG4gIHByaXZhdGUgcmVhZG9ubHkgdXNlRGVmYXVsdENvbnN0cnVjdGlvbjogYm9vbGVhbjtcblxuICAvLyBUaGUgYGluaXRpYWxpemVgIG9wdGlvbiBpcyByZXF1aXJlZCBpZiB0aGUgdHlwZSBkb2Vzbid0IGhhdmUgYSBjb3JyZWN0bHktdHlwZWQgaW5pdGlhbGl6ZSBtZXRob2QuIFRoZXJlZm9yZSwgd2VcbiAgLy8gZG8gc29tZSBUeXBlc2NyaXB0IG1hZ2ljIHRvIHJlcXVpcmUgcHJvdmlkZWRPcHRpb25zIGlmIHRoYXQncyB0aGUgY2FzZSAob3RoZXJ3aXNlIHByb3ZpZGVkT3B0aW9ucyBpcyBvcHRpb25hbCkuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdHlwZTogVCwgLi4ucHJvdmlkZWRPcHRpb25zU3ByZWFkOiBQb3NzaWJseVJlcXVpcmVkUGFyYW1ldGVyU3ByZWFkPFBvb2xhYmxlT3B0aW9uczxUPj4gKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxTZWxmUG9vbGFibGVPcHRpb25zPFQ+LCBTZWxmUG9vbGFibGVPcHRpb25zPFQ+PigpKCB7XG5cbiAgICAgIGRlZmF1bHRBcmd1bWVudHM6IFtdIGFzIHVua25vd24gYXMgQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgICAgaW5pdGlhbGl6ZTogKCB0eXBlLnByb3RvdHlwZSBhcyB1bmtub3duIGFzIHsgaW5pdGlhbGl6ZTogUG9vbGFibGVJbml0aWFsaXplcjxUPiB9ICkuaW5pdGlhbGl6ZSxcbiAgICAgIG1heFNpemU6IDEwMCxcbiAgICAgIGluaXRpYWxTaXplOiAwLFxuICAgICAgdXNlRGVmYXVsdENvbnN0cnVjdGlvbjogZmFsc2VcbiAgICB9LCBwcm92aWRlZE9wdGlvbnNTcHJlYWRbIDAgXSApO1xuXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy5tYXhTaXplID49IDAgKTtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLmluaXRpYWxTaXplID49IDAgKTtcblxuICAgIHRoaXMuX21heFBvb2xTaXplID0gb3B0aW9ucy5tYXhTaXplO1xuXG4gICAgLy8gVGhlcmUgaXMgYSBtYWRuZXNzIHRvIHRoaXMgY3JhemluZXNzLiBXZSdkIHdhbnQgdG8gdXNlIHRoZSBtZXRob2Qgbm90ZWQgYXRcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjA2Nzk3L3VzZS1vZi1hcHBseS13aXRoLW5ldy1vcGVyYXRvci1pcy10aGlzLXBvc3NpYmxlLCBidXQgdGhlIHR5cGUgaXNcbiAgICAvLyBub3QgcHJvdmlkZWQgaW4gdGhlIGFyZ3VtZW50cyBhcnJheSBiZWxvdy4gQnkgY2FsbGluZyBiaW5kIG9uIGl0c2VsZiwgd2UncmUgYWJsZSB0byBnZXQgYSB2ZXJzaW9uIG9mIGJpbmQgdGhhdFxuICAgIC8vIGluc2VydHMgdGhlIGNvbnN0cnVjdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgLmFwcGx5IGNhbGxlZCBsYXRlciBzbyB3ZSBkb24ndCBjcmVhdGUgZ2FyYmFnZSBieSBoYXZpbmdcbiAgICAvLyB0byBwYWNrIGBhcmd1bWVudHNgIGludG8gYW4gYXJyYXkgQU5EIFRIRU4gY29uY2F0ZW5hdGUgaXQgd2l0aCBhIG5ldyBmaXJzdCBlbGVtZW50ICh0aGUgdHlwZSBpdHNlbGYpLlxuICAgIHRoaXMucGFydGlhbENvbnN0cnVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYmluZCggdHlwZSwgdHlwZSApO1xuXG4gICAgLy8gQmFzaWNhbGx5IG91ciB0eXBlIGNvbnN0cnVjdG9yLCBidXQgd2l0aCB0aGUgZGVmYXVsdCBhcmd1bWVudHMgaW5jbHVkZWQgYWxyZWFkeS5cbiAgICB0aGlzLkRlZmF1bHRDb25zdHJ1Y3RvciA9IHRoaXMucGFydGlhbENvbnN0cnVjdG9yKCAuLi5vcHRpb25zLmRlZmF1bHRBcmd1bWVudHMhICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG5cbiAgICB0aGlzLmluaXRpYWxpemUgPSBvcHRpb25zLmluaXRpYWxpemU7XG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5pbml0aWFsaXplLCAnRWl0aGVyIHBhc3MgaW4gYW4gaW5pdGlhbGl6ZSBvcHRpb24sIG9yIHByb3ZpZGUgYSBtZXRob2QgbmFtZWQgaW5pdGlhbGl6ZSBvbiB0aGUgdHlwZSB3aXRoIHRoZSBwcm9wZXIgc2lnbmF0dXJlJyApO1xuXG4gICAgdGhpcy51c2VEZWZhdWx0Q29uc3RydWN0aW9uID0gb3B0aW9ucy51c2VEZWZhdWx0Q29uc3RydWN0aW9uO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcG9vbCAoaWYgaXQgc2hvdWxkIGhhdmUgb2JqZWN0cylcbiAgICB3aGlsZSAoIHRoaXMub2JqZWN0cy5sZW5ndGggPCBvcHRpb25zLmluaXRpYWxTaXplICkge1xuICAgICAgdGhpcy5vYmplY3RzLnB1c2goIHRoaXMuY3JlYXRlRGVmYXVsdE9iamVjdCgpICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0T2JqZWN0KCk6IEluc3RhbmNlVHlwZTxUPiB7XG4gICAgcmV0dXJuIG5ldyAoIHRoaXMuRGVmYXVsdENvbnN0cnVjdG9yICkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFyYml0cmFyeSBzdGF0ZSAocG9zc2libHkgY29uc3RydWN0ZWQgd2l0aCB0aGUgZGVmYXVsdCBhcmd1bWVudHMpLlxuICAgKi9cbiAgcHVibGljIGZldGNoKCk6IEluc3RhbmNlVHlwZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0cy5sZW5ndGggPyB0aGlzLm9iamVjdHMucG9wKCkhIDogdGhpcy5jcmVhdGVEZWZhdWx0T2JqZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBiZWhhdmVzIGFzIGlmIGl0IHdhcyBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMuIE1heSByZXN1bHQgaW4gYSBuZXcgb2JqZWN0XG4gICAqIGJlaW5nIGNyZWF0ZWQgKGlmIHRoZSBwb29sIGlzIGVtcHR5KSwgb3IgaXQgbWF5IHVzZSB0aGUgY29uc3RydWN0b3IgdG8gbXV0YXRlIGFuIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgcHVibGljIGNyZWF0ZSggLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+ICk6IEluc3RhbmNlVHlwZTxUPiB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGlmICggdGhpcy5vYmplY3RzLmxlbmd0aCApIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMub2JqZWN0cy5wb3AoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSggcmVzdWx0LCBhcmdzICk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCB0aGlzLnVzZURlZmF1bHRDb25zdHJ1Y3Rpb24gKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmNyZWF0ZURlZmF1bHRPYmplY3QoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSggcmVzdWx0LCBhcmdzICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3ICggdGhpcy5wYXJ0aWFsQ29uc3RydWN0b3IoIC4uLmFyZ3MgKSApKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHBvb2wuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBvb2xTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0cy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBwb29sIHNpemUuXG4gICAqL1xuICBwdWJsaWMgc2V0IG1heFBvb2xTaXplKCB2YWx1ZTogbnVtYmVyICkge1xuICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgKCBOdW1iZXIuaXNJbnRlZ2VyKCB2YWx1ZSApICYmIHZhbHVlID49IDAgKSwgJ21heFBvb2xTaXplIHNob3VsZCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG9yIGluZmluaXR5JyApO1xuXG4gICAgdGhpcy5fbWF4UG9vbFNpemUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHBvb2wgc2l6ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWF4UG9vbFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4UG9vbFNpemU7XG4gIH1cblxuICBwdWJsaWMgZnJlZVRvUG9vbCggb2JqZWN0OiBJbnN0YW5jZVR5cGU8VD4gKTogdm9pZCB7XG4gICAgaWYgKCB0aGlzLm9iamVjdHMubGVuZ3RoIDwgdGhpcy5tYXhQb29sU2l6ZSApIHtcbiAgICAgIHRoaXMub2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZm9yRWFjaCggY2FsbGJhY2s6ICggb2JqZWN0OiBJbnN0YW5jZVR5cGU8VD4gKSA9PiB2b2lkICk6IHZvaWQge1xuICAgIHRoaXMub2JqZWN0cy5mb3JFYWNoKCBjYWxsYmFjayApO1xuICB9XG59XG5cbnBoZXRDb3JlLnJlZ2lzdGVyKCAnUG9vbCcsIFBvb2wgKTsiXSwibmFtZXMiOlsib3B0aW9uaXplIiwicGhldENvcmUiLCJQb29sIiwiY3JlYXRlRGVmYXVsdE9iamVjdCIsIkRlZmF1bHRDb25zdHJ1Y3RvciIsImZldGNoIiwib2JqZWN0cyIsImxlbmd0aCIsInBvcCIsImNyZWF0ZSIsImFyZ3MiLCJyZXN1bHQiLCJpbml0aWFsaXplIiwiYXBwbHkiLCJ1c2VEZWZhdWx0Q29uc3RydWN0aW9uIiwicGFydGlhbENvbnN0cnVjdG9yIiwicG9vbFNpemUiLCJtYXhQb29sU2l6ZSIsInZhbHVlIiwiYXNzZXJ0IiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJpc0ludGVnZXIiLCJfbWF4UG9vbFNpemUiLCJmcmVlVG9Qb29sIiwib2JqZWN0IiwicHVzaCIsImZvckVhY2giLCJjYWxsYmFjayIsInR5cGUiLCJwcm92aWRlZE9wdGlvbnNTcHJlYWQiLCJvcHRpb25zIiwiZGVmYXVsdEFyZ3VtZW50cyIsInByb3RvdHlwZSIsIm1heFNpemUiLCJpbml0aWFsU2l6ZSIsIkZ1bmN0aW9uIiwiYmluZCIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUQsT0FBT0EsZUFBZSxpQkFBaUI7QUFDdkMsT0FBT0MsY0FBYyxnQkFBZ0I7QUEyQ3RCLElBQUEsQUFBTUMsT0FBTixNQUFNQTtJQStDWEMsc0JBQXVDO1FBQzdDLE9BQU8sSUFBTSxJQUFJLENBQUNDLGtCQUFrQjtJQUN0QztJQUVBOztHQUVDLEdBQ0QsQUFBT0MsUUFBeUI7UUFDOUIsT0FBTyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0QsT0FBTyxDQUFDRSxHQUFHLEtBQU0sSUFBSSxDQUFDTCxtQkFBbUI7SUFDN0U7SUFFQTs7O0dBR0MsR0FDRCxBQUFPTSxPQUFRLEdBQUdDLElBQThCLEVBQW9CO1FBQ2xFLElBQUlDO1FBRUosSUFBSyxJQUFJLENBQUNMLE9BQU8sQ0FBQ0MsTUFBTSxFQUFHO1lBQ3pCSSxTQUFTLElBQUksQ0FBQ0wsT0FBTyxDQUFDRSxHQUFHO1lBQ3pCLElBQUksQ0FBQ0ksVUFBVSxDQUFDQyxLQUFLLENBQUVGLFFBQVFEO1FBQ2pDLE9BQ0ssSUFBSyxJQUFJLENBQUNJLHNCQUFzQixFQUFHO1lBQ3RDSCxTQUFTLElBQUksQ0FBQ1IsbUJBQW1CO1lBQ2pDLElBQUksQ0FBQ1MsVUFBVSxDQUFDQyxLQUFLLENBQUVGLFFBQVFEO1FBQ2pDLE9BQ0s7WUFDSEMsU0FBUyxJQUFNLENBQUEsSUFBSSxDQUFDSSxrQkFBa0IsSUFBS0wsS0FBSztRQUNsRDtRQUVBLE9BQU9DO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELElBQVdLLFdBQW1CO1FBQzVCLE9BQU8sSUFBSSxDQUFDVixPQUFPLENBQUNDLE1BQU07SUFDNUI7SUFFQTs7R0FFQyxHQUNELElBQVdVLFlBQWFDLEtBQWEsRUFBRztRQUN0Q0MsVUFBVUEsT0FBUUQsVUFBVUUsT0FBT0MsaUJBQWlCLElBQU1ELE9BQU9FLFNBQVMsQ0FBRUosVUFBV0EsU0FBUyxHQUFLO1FBRXJHLElBQUksQ0FBQ0ssWUFBWSxHQUFHTDtJQUN0QjtJQUVBOztHQUVDLEdBQ0QsSUFBV0QsY0FBc0I7UUFDL0IsT0FBTyxJQUFJLENBQUNNLFlBQVk7SUFDMUI7SUFFT0MsV0FBWUMsTUFBdUIsRUFBUztRQUNqRCxJQUFLLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ1UsV0FBVyxFQUFHO1lBQzVDLElBQUksQ0FBQ1gsT0FBTyxDQUFDb0IsSUFBSSxDQUFFRDtRQUNyQjtJQUNGO0lBRU9FLFFBQVNDLFFBQTZDLEVBQVM7UUFDcEUsSUFBSSxDQUFDdEIsT0FBTyxDQUFDcUIsT0FBTyxDQUFFQztJQUN4QjtJQXRHQSxrSEFBa0g7SUFDbEgsa0hBQWtIO0lBQ2xILFlBQW9CQyxJQUFPLEVBQUUsR0FBR0MscUJBQTBFLENBQUc7YUFWNUZ4QixVQUE2QixFQUFFO1FBVzlDLE1BQU15QixVQUFVL0IsWUFBNkQ7WUFFM0VnQyxrQkFBa0IsRUFBRTtZQUNwQnBCLFlBQVksQUFBRWlCLEtBQUtJLFNBQVMsQ0FBd0RyQixVQUFVO1lBQzlGc0IsU0FBUztZQUNUQyxhQUFhO1lBQ2JyQix3QkFBd0I7UUFDMUIsR0FBR2dCLHFCQUFxQixDQUFFLEVBQUc7UUFFN0JYLFVBQVVBLE9BQVFZLFFBQVFHLE9BQU8sSUFBSTtRQUNyQ2YsVUFBVUEsT0FBUVksUUFBUUksV0FBVyxJQUFJO1FBRXpDLElBQUksQ0FBQ1osWUFBWSxHQUFHUSxRQUFRRyxPQUFPO1FBRW5DLDZFQUE2RTtRQUM3RSwrR0FBK0c7UUFDL0csaUhBQWlIO1FBQ2pILGdIQUFnSDtRQUNoSCx3R0FBd0c7UUFDeEcsSUFBSSxDQUFDbkIsa0JBQWtCLEdBQUdxQixTQUFTSCxTQUFTLENBQUNJLElBQUksQ0FBQ0EsSUFBSSxDQUFFUixNQUFNQTtRQUU5RCxtRkFBbUY7UUFDbkYsSUFBSSxDQUFDekIsa0JBQWtCLEdBQUcsSUFBSSxDQUFDVyxrQkFBa0IsSUFBS2dCLFFBQVFDLGdCQUFnQixHQUFLLHVFQUF1RTtRQUUxSixJQUFJLENBQUNwQixVQUFVLEdBQUdtQixRQUFRbkIsVUFBVTtRQUNwQ08sVUFBVUEsT0FBUSxJQUFJLENBQUNQLFVBQVUsRUFBRTtRQUVuQyxJQUFJLENBQUNFLHNCQUFzQixHQUFHaUIsUUFBUWpCLHNCQUFzQjtRQUU1RCxrREFBa0Q7UUFDbEQsTUFBUSxJQUFJLENBQUNSLE9BQU8sQ0FBQ0MsTUFBTSxHQUFHd0IsUUFBUUksV0FBVyxDQUFHO1lBQ2xELElBQUksQ0FBQzdCLE9BQU8sQ0FBQ29CLElBQUksQ0FBRSxJQUFJLENBQUN2QixtQkFBbUI7UUFDN0M7SUFDRjtBQW1FRjtBQWhIQSxTQUFxQkQsa0JBZ0hwQjtBQUVERCxTQUFTcUMsUUFBUSxDQUFFLFFBQVFwQyJ9