// Copyright 2022-2024, University of Colorado Boulder
/**
 * ValueChangeSoundPlayer plays sounds based on changes to a numerical value.  It was initially created for supporting
 * sound generation in PhET's Slider class and variations thereof, but it may have other applications.
 *
 * This class does not extend SoundGenerator and is not itself added to the sound manager.  It is instead a player of
 * a set of sounds, each of which should be registered with the sound manager elsewhere.
 *
 * Because the sounds should only be produced when users directly change a value, and not in side-effect-ish situations
 * (such as a reset), this class does not monitor a Property.  Instead, it provides methods that can be used to evaluate
 * changes in a value and potentially play sounds (or not, if the change doesn't warrant sound generation), and it is
 * the client's responsibility to know the situations in which these methods should be called.  Often these methods will
 * be called in drag handlers and other code that handles user input.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */ import Disposable from '../../../axon/js/Disposable.js';
import TinyProperty from '../../../axon/js/TinyProperty.js';
import Range from '../../../dot/js/Range.js';
import Utils from '../../../dot/js/Utils.js';
import optionize from '../../../phet-core/js/optionize.js';
import generalBoundaryBoop_mp3 from '../../sounds/generalBoundaryBoop_mp3.js';
import generalSoftClick_mp3 from '../../sounds/generalSoftClick_mp3.js';
import nullSoundPlayer from '../nullSoundPlayer.js';
import phetAudioContext from '../phetAudioContext.js';
import sharedSoundPlayers from '../sharedSoundPlayers.js';
import tambo from '../tambo.js';
import SoundClip from './SoundClip.js';
import SoundClipPlayer from './SoundClipPlayer.js';
// constants
const DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS = 5; // fairly arbitrary
const DEFAULT_MIN_SOUND_PLAYER = new SoundClipPlayer(generalBoundaryBoop_mp3, {
    soundClipOptions: {
        initialOutputLevel: 0.2,
        initialPlaybackRate: 1 / Math.pow(2, 1 / 6) // a major second lower
    },
    soundManagerOptions: {
        categoryName: 'user-interface'
    }
});
const DEFAULT_MIDDLE_MOVING_DOWN_SOUND_PLAYER = new SoundClipPlayer(generalSoftClick_mp3, {
    soundClipOptions: {
        initialOutputLevel: 0.2,
        initialPlaybackRate: 1 / Math.pow(2, 1 / 6) // a major second lower
    },
    soundManagerOptions: {
        categoryName: 'user-interface'
    }
});
// Define a default constraint function.  See the docs for the associated option for more info.  The interval value used
// here was empirically determined.
const DEFAULT_VALUE_CONSTRAINT = (value)=>Utils.roundToInterval(value, 0.000000001);
// A "no-op" function for mapping pitch values.  Always returns one, which signifies no change to the playback rate.
const NO_PLAYBACK_RATE_CHANGE = ()=>1;
// A function for a stubbed sound player, see usage.
const STUB_SOUND_PLAYER_FUNCTION = ()=>{
    assert && assert(false, 'Code error: This is a stubbed function and should never be invoked.');
};
let ValueChangeSoundPlayer = class ValueChangeSoundPlayer extends Disposable {
    /**
   * Check if the new value has reached or crossed a threshold and, if so, play the appropriate sound.  If no threshold
   * has been reached or crossed and the new value is not at the min or max, no sound will be played.
   */ playSoundIfThresholdReached(newValue, oldValue) {
        if (newValue !== oldValue) {
            const constrainedNewValue = this.constrainValue(newValue);
            const constrainedOldValue = this.constrainValue(oldValue);
            const oldValueSurroundingThresholds = this.getSurroundingThresholds(constrainedOldValue);
            const newValueSurroundingThresholds = this.getSurroundingThresholds(constrainedNewValue);
            const thresholdCrossed = oldValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds.length === 1 && Math.abs(oldValueSurroundingThresholds[0] - newValueSurroundingThresholds[0]) > this.interThresholdDistance || oldValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds.length === 2 && oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[0] && oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[1] || oldValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[0] && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[1] || oldValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[0];
            const thresholdReached = newValueSurroundingThresholds.length === 1 && (oldValueSurroundingThresholds.length === 2 || oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[0]);
            if (thresholdCrossed || thresholdReached || constrainedNewValue === this.valueRangeProperty.value.min || constrainedNewValue === this.valueRangeProperty.value.max) {
                this.playSoundForValueChange(newValue, oldValue);
            }
        }
    }
    /**
   * Play the appropriate sound for the change in value indicated by the provided new and old values.  This will almost
   * always play a sound, but there are some exceptions.  See the code and comments for details.
   */ playSoundForValueChange(newValue, oldValue) {
        const constrainedNewValue = this.constrainValue(newValue);
        const constrainedOldValue = this.constrainValue(oldValue);
        if (constrainedNewValue !== constrainedOldValue || oldValue !== newValue && (newValue === this.valueRangeProperty.value.min || newValue === this.valueRangeProperty.value.max)) {
            if (newValue === this.valueRangeProperty.value.min && this.minSoundPlayer !== ValueChangeSoundPlayer.USE_MIDDLE_SOUND) {
                this.minSoundPlayer.play();
            } else if (newValue === this.valueRangeProperty.value.max && this.maxSoundPlayer !== ValueChangeSoundPlayer.USE_MIDDLE_SOUND) {
                this.maxSoundPlayer.play();
            } else {
                // Play a middle-range sound, but only if enough time has passed since the last one was played.
                const now = phetAudioContext.currentTime;
                if (now - this.timeOfMostRecentMiddleSound > this.minimumInterMiddleSoundTime) {
                    let playbackRateMapper;
                    let soundPlayer;
                    if (constrainedNewValue > constrainedOldValue) {
                        playbackRateMapper = this.middleMovingUpPlaybackRateMapper;
                        soundPlayer = this.middleMovingUpSoundPlayer;
                    } else {
                        playbackRateMapper = this.middleMovingDownPlaybackRateMapper;
                        soundPlayer = this.middleMovingDownSoundPlayer;
                    }
                    if (playbackRateMapper !== NO_PLAYBACK_RATE_CHANGE) {
                        // Adjust the playback rate based on the provided new value.  It should be safe to cast this here because of
                        // the assertion checks that occur during construction.
                        soundPlayer.setPlaybackRate(playbackRateMapper(newValue));
                    }
                    soundPlayer.play();
                    this.timeOfMostRecentMiddleSound = now;
                }
            }
        }
    }
    /**
   * Get an array that contains the next lowest and next highest thresholds for the provided value.  If the provided
   * value is exactly equal to a threshold, only the single threshold value is returned in the array.
   */ getSurroundingThresholds(value) {
        // A note to future maintainers: JavaScript's floating point implementation was causing all manner of problems with
        // this method.  For instance, when the inter-threshold distance was 0.1 and the provided value was 0.3, JS says
        // that 0.3/0.1 is 2.9999999999999996, so it was tricky to tell that the value was at a threshold and not below it.
        // Therefore, the code below does rounding to intervals that were empirically determined to correct for the floating
        // point problems.  This worked in all test cases, but may not stand the test of time if some unusual slider
        // configurations are needed.  One idea might be to make the rounding interval for this calculation an option to the
        // class, but that felt like overkill at the time of this writing.
        const roundingInterval = 1E-7;
        const segment = Math.floor(Utils.roundToInterval((value - this.valueRangeProperty.value.min) / this.interThresholdDistance, roundingInterval));
        const lowerThreshold = Utils.roundToInterval(segment * this.interThresholdDistance + this.valueRangeProperty.value.min, roundingInterval);
        const thresholdArray = [
            lowerThreshold
        ];
        if (lowerThreshold !== value) {
            // The provided value wasn't exactly at a threshold.  Since the preceding calculation provided the lower
            // threshold, add the upper one now.
            const upperThreshold = Math.min(Utils.roundToInterval(lowerThreshold + this.interThresholdDistance, roundingInterval), this.valueRangeProperty.value.max);
            // This may seem like an odd test, so here's the story: There are some rare but possible cases where the
            // calculation above doesn't actually yield a higher value due to floating point errors.  When testing in Dec
            // 2022, this was only seen on the Wave Packet Center slider in Fourier Making Waves.  So, only add the upper
            // threshold if it's actually higher than the lower one.  If the upper threshold isn't added, this essentially
            // says that the lower threshold was an exact match for one of the crossing thresholds, which is approximately
            // true and has worked fine in all test cases thus far.
            if (upperThreshold > lowerThreshold) {
                thresholdArray.push(upperThreshold);
            }
        }
        return thresholdArray;
    }
    /**
   * @param valueRange - the range of values expected and over which sounds will be played
   * @param [providedOptions]
   */ constructor(valueRange, providedOptions){
        const options = optionize()({
            middleMovingUpSoundPlayer: sharedSoundPlayers.get('generalSoftClick'),
            middleMovingDownSoundPlayer: DEFAULT_MIDDLE_MOVING_DOWN_SOUND_PLAYER,
            middleMovingUpPlaybackRateMapper: NO_PLAYBACK_RATE_CHANGE,
            middleMovingDownPlaybackRateMapper: NO_PLAYBACK_RATE_CHANGE,
            numberOfMiddleThresholds: null,
            interThresholdDelta: null,
            constrainValue: DEFAULT_VALUE_CONSTRAINT,
            minSoundPlayer: DEFAULT_MIN_SOUND_PLAYER,
            maxSoundPlayer: sharedSoundPlayers.get('generalBoundaryBoop'),
            minimumInterMiddleSoundTime: 0.035 // empirically determined
        }, providedOptions);
        // option validity checks
        assert && assert(options.minimumInterMiddleSoundTime >= 0 && options.minimumInterMiddleSoundTime < 1, `unreasonable value for minimumInterMiddleSoundTime: ${options.minimumInterMiddleSoundTime}`);
        assert && assert(options.numberOfMiddleThresholds === null || options.interThresholdDelta === null, 'cannot specify both the number of middle thresholds and the inter-threshold delta');
        assert && assert(options.numberOfMiddleThresholds === null || Number.isInteger(options.numberOfMiddleThresholds), 'numberOfMiddleThresholds must be an integer if specified');
        // If a playback rate mapper is provided for a middle threshold sound, the provided sound player must support
        // setting a different playback rate.  It should NOT be a SoundClipPlayer, since those are designed to be shared, so
        // the playback rate should never be changed.  The following assertions are intended to verify that these options
        // are set in a compatible way.
        assert && assert(options.middleMovingUpPlaybackRateMapper === NO_PLAYBACK_RATE_CHANGE || options.middleMovingUpSoundPlayer instanceof SoundClip, 'a sound player that supports playback rate changes is required when a playback rate mapper is used');
        assert && assert(options.middleMovingDownPlaybackRateMapper === NO_PLAYBACK_RATE_CHANGE || options.middleMovingDownSoundPlayer instanceof SoundClip, 'a sound player that supports playback rate changes is required when a playback rate mapper is used');
        // Set default number of middle thresholds if necessary.
        if (options.numberOfMiddleThresholds === null && options.interThresholdDelta === null) {
            options.numberOfMiddleThresholds = DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS;
        }
        super(options), // The distance between the threshold values at which sounds will be played.
        this.interThresholdDistance = DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS;
        this.valueRangeProperty = valueRange instanceof Range ? new TinyProperty(valueRange) : valueRange;
        this.middleMovingUpSoundPlayer = options.middleMovingUpSoundPlayer;
        this.middleMovingDownSoundPlayer = options.middleMovingDownSoundPlayer;
        this.middleMovingUpPlaybackRateMapper = options.middleMovingUpPlaybackRateMapper;
        this.middleMovingDownPlaybackRateMapper = options.middleMovingDownPlaybackRateMapper;
        this.minSoundPlayer = options.minSoundPlayer;
        this.maxSoundPlayer = options.maxSoundPlayer;
        this.minimumInterMiddleSoundTime = options.minimumInterMiddleSoundTime;
        this.timeOfMostRecentMiddleSound = 0;
        this.constrainValue = options.constrainValue;
        const rangeChangeListener = (valueRange)=>{
            if (options.numberOfMiddleThresholds !== null) {
                this.interThresholdDistance = valueRange.getLength() / (options.numberOfMiddleThresholds + 1);
            } else if (options.interThresholdDelta !== null) {
                this.interThresholdDistance = options.interThresholdDelta;
            } else {
                assert && assert(false, 'should never get here, it is a logic error if we do');
                this.interThresholdDistance = valueRange.getLength() / 2; // avoid uninitialized compile-time error
            }
        };
        this.valueRangeProperty.link(rangeChangeListener);
        this.disposeEmitter.addListener(()=>{
            this.valueRangeProperty.unlink(rangeChangeListener);
        });
    }
};
/**
   * A static instance that makes no sound.  This is generally used as an option value to turn off sound generation.
   */ ValueChangeSoundPlayer.NO_SOUND = new ValueChangeSoundPlayer(new Range(0, 1), {
    middleMovingUpSoundPlayer: nullSoundPlayer,
    minSoundPlayer: nullSoundPlayer,
    maxSoundPlayer: nullSoundPlayer
});
/**
   * A static TSoundPlayer instance that is intended to be used as a flag for the min and max sound players to
   * indicate that the middle sound player should be used.
   */ ValueChangeSoundPlayer.USE_MIDDLE_SOUND = {
    play: STUB_SOUND_PLAYER_FUNCTION,
    stop: STUB_SOUND_PLAYER_FUNCTION
};
tambo.register('ValueChangeSoundPlayer', ValueChangeSoundPlayer);
export default ValueChangeSoundPlayer;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RhbWJvL2pzL3NvdW5kLWdlbmVyYXRvcnMvVmFsdWVDaGFuZ2VTb3VuZFBsYXllci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMi0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcblxuLyoqXG4gKiBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyIHBsYXlzIHNvdW5kcyBiYXNlZCBvbiBjaGFuZ2VzIHRvIGEgbnVtZXJpY2FsIHZhbHVlLiAgSXQgd2FzIGluaXRpYWxseSBjcmVhdGVkIGZvciBzdXBwb3J0aW5nXG4gKiBzb3VuZCBnZW5lcmF0aW9uIGluIFBoRVQncyBTbGlkZXIgY2xhc3MgYW5kIHZhcmlhdGlvbnMgdGhlcmVvZiwgYnV0IGl0IG1heSBoYXZlIG90aGVyIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBUaGlzIGNsYXNzIGRvZXMgbm90IGV4dGVuZCBTb3VuZEdlbmVyYXRvciBhbmQgaXMgbm90IGl0c2VsZiBhZGRlZCB0byB0aGUgc291bmQgbWFuYWdlci4gIEl0IGlzIGluc3RlYWQgYSBwbGF5ZXIgb2ZcbiAqIGEgc2V0IG9mIHNvdW5kcywgZWFjaCBvZiB3aGljaCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBzb3VuZCBtYW5hZ2VyIGVsc2V3aGVyZS5cbiAqXG4gKiBCZWNhdXNlIHRoZSBzb3VuZHMgc2hvdWxkIG9ubHkgYmUgcHJvZHVjZWQgd2hlbiB1c2VycyBkaXJlY3RseSBjaGFuZ2UgYSB2YWx1ZSwgYW5kIG5vdCBpbiBzaWRlLWVmZmVjdC1pc2ggc2l0dWF0aW9uc1xuICogKHN1Y2ggYXMgYSByZXNldCksIHRoaXMgY2xhc3MgZG9lcyBub3QgbW9uaXRvciBhIFByb3BlcnR5LiAgSW5zdGVhZCwgaXQgcHJvdmlkZXMgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGV2YWx1YXRlXG4gKiBjaGFuZ2VzIGluIGEgdmFsdWUgYW5kIHBvdGVudGlhbGx5IHBsYXkgc291bmRzIChvciBub3QsIGlmIHRoZSBjaGFuZ2UgZG9lc24ndCB3YXJyYW50IHNvdW5kIGdlbmVyYXRpb24pLCBhbmQgaXQgaXNcbiAqIHRoZSBjbGllbnQncyByZXNwb25zaWJpbGl0eSB0byBrbm93IHRoZSBzaXR1YXRpb25zIGluIHdoaWNoIHRoZXNlIG1ldGhvZHMgc2hvdWxkIGJlIGNhbGxlZC4gIE9mdGVuIHRoZXNlIG1ldGhvZHMgd2lsbFxuICogYmUgY2FsbGVkIGluIGRyYWcgaGFuZGxlcnMgYW5kIG90aGVyIGNvZGUgdGhhdCBoYW5kbGVzIHVzZXIgaW5wdXQuXG4gKlxuICogQGF1dGhvciBKb2huIEJsYW5jbyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcbiAqL1xuXG5pbXBvcnQgRGlzcG9zYWJsZSwgeyBEaXNwb3NhYmxlT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgVGlueVByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVGlueVByb3BlcnR5LmpzJztcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcbmltcG9ydCBSYW5nZSBmcm9tICcuLi8uLi8uLi9kb3QvanMvUmFuZ2UuanMnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xuaW1wb3J0IGdlbmVyYWxCb3VuZGFyeUJvb3BfbXAzIGZyb20gJy4uLy4uL3NvdW5kcy9nZW5lcmFsQm91bmRhcnlCb29wX21wMy5qcyc7XG5pbXBvcnQgZ2VuZXJhbFNvZnRDbGlja19tcDMgZnJvbSAnLi4vLi4vc291bmRzL2dlbmVyYWxTb2Z0Q2xpY2tfbXAzLmpzJztcbmltcG9ydCBudWxsU291bmRQbGF5ZXIgZnJvbSAnLi4vbnVsbFNvdW5kUGxheWVyLmpzJztcbmltcG9ydCBwaGV0QXVkaW9Db250ZXh0IGZyb20gJy4uL3BoZXRBdWRpb0NvbnRleHQuanMnO1xuaW1wb3J0IHNoYXJlZFNvdW5kUGxheWVycyBmcm9tICcuLi9zaGFyZWRTb3VuZFBsYXllcnMuanMnO1xuaW1wb3J0IHRhbWJvIGZyb20gJy4uL3RhbWJvLmpzJztcbmltcG9ydCBUU291bmRQbGF5ZXIgZnJvbSAnLi4vVFNvdW5kUGxheWVyLmpzJztcbmltcG9ydCBTb3VuZENsaXAgZnJvbSAnLi9Tb3VuZENsaXAuanMnO1xuaW1wb3J0IFNvdW5kQ2xpcFBsYXllciBmcm9tICcuL1NvdW5kQ2xpcFBsYXllci5qcyc7XG5cbi8vIGNvbnN0YW50c1xuY29uc3QgREVGQVVMVF9OVU1CRVJfT0ZfTUlERExFX1RIUkVTSE9MRFMgPSA1OyAvLyBmYWlybHkgYXJiaXRyYXJ5XG5jb25zdCBERUZBVUxUX01JTl9TT1VORF9QTEFZRVIgPSBuZXcgU291bmRDbGlwUGxheWVyKCBnZW5lcmFsQm91bmRhcnlCb29wX21wMywge1xuICBzb3VuZENsaXBPcHRpb25zOiB7XG4gICAgaW5pdGlhbE91dHB1dExldmVsOiAwLjIsXG4gICAgaW5pdGlhbFBsYXliYWNrUmF0ZTogMSAvIE1hdGgucG93KCAyLCAxIC8gNiApIC8vIGEgbWFqb3Igc2Vjb25kIGxvd2VyXG4gIH0sXG4gIHNvdW5kTWFuYWdlck9wdGlvbnM6IHsgY2F0ZWdvcnlOYW1lOiAndXNlci1pbnRlcmZhY2UnIH1cbn0gKTtcbmNvbnN0IERFRkFVTFRfTUlERExFX01PVklOR19ET1dOX1NPVU5EX1BMQVlFUiA9IG5ldyBTb3VuZENsaXBQbGF5ZXIoIGdlbmVyYWxTb2Z0Q2xpY2tfbXAzLCB7XG4gIHNvdW5kQ2xpcE9wdGlvbnM6IHtcbiAgICBpbml0aWFsT3V0cHV0TGV2ZWw6IDAuMixcbiAgICBpbml0aWFsUGxheWJhY2tSYXRlOiAxIC8gTWF0aC5wb3coIDIsIDEgLyA2ICkgLy8gYSBtYWpvciBzZWNvbmQgbG93ZXJcbiAgfSxcbiAgc291bmRNYW5hZ2VyT3B0aW9uczogeyBjYXRlZ29yeU5hbWU6ICd1c2VyLWludGVyZmFjZScgfVxufSApO1xuXG4vLyBEZWZpbmUgYSBkZWZhdWx0IGNvbnN0cmFpbnQgZnVuY3Rpb24uICBTZWUgdGhlIGRvY3MgZm9yIHRoZSBhc3NvY2lhdGVkIG9wdGlvbiBmb3IgbW9yZSBpbmZvLiAgVGhlIGludGVydmFsIHZhbHVlIHVzZWRcbi8vIGhlcmUgd2FzIGVtcGlyaWNhbGx5IGRldGVybWluZWQuXG5jb25zdCBERUZBVUxUX1ZBTFVFX0NPTlNUUkFJTlQgPSAoIHZhbHVlOiBudW1iZXIgKSA9PiBVdGlscy5yb3VuZFRvSW50ZXJ2YWwoIHZhbHVlLCAwLjAwMDAwMDAwMSApO1xuXG4vLyBBIFwibm8tb3BcIiBmdW5jdGlvbiBmb3IgbWFwcGluZyBwaXRjaCB2YWx1ZXMuICBBbHdheXMgcmV0dXJucyBvbmUsIHdoaWNoIHNpZ25pZmllcyBubyBjaGFuZ2UgdG8gdGhlIHBsYXliYWNrIHJhdGUuXG5jb25zdCBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSA9ICgpID0+IDE7XG5cbi8vIEEgZnVuY3Rpb24gZm9yIGEgc3R1YmJlZCBzb3VuZCBwbGF5ZXIsIHNlZSB1c2FnZS5cbmNvbnN0IFNUVUJfU09VTkRfUExBWUVSX0ZVTkNUSU9OID0gKCk6IHZvaWQgPT4ge1xuICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ0NvZGUgZXJyb3I6IFRoaXMgaXMgYSBzdHViYmVkIGZ1bmN0aW9uIGFuZCBzaG91bGQgbmV2ZXIgYmUgaW52b2tlZC4nICk7XG59O1xuXG50eXBlIFNlbGZPcHRpb25zID0ge1xuXG4gIC8vIFRoZSBzb3VuZCBwbGF5ZXIgZm9yIG1vdmVtZW50IGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlIGluIHRoZSB1cCBkaXJlY3Rpb24uXG4gIG1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI/OiBUU291bmRQbGF5ZXIgfCBTb3VuZENsaXA7XG5cbiAgLy8gVGhlIHNvdW5kIHBsYXllciBmb3IgbW92ZW1lbnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2UgaW4gdGhlIGRvd24gZGlyZWN0aW9uLlxuICBtaWRkbGVNb3ZpbmdEb3duU291bmRQbGF5ZXI/OiBUU291bmRQbGF5ZXIgfCBTb3VuZENsaXA7XG5cbiAgLy8gRnVuY3Rpb25zIHRoYXQsIGlmIHByb3ZpZGVkLCB3aWxsIGFsdGVyIHRoZSBwbGF5YmFjayByYXRlcyBvZiB0aGUgbWlkZGxlIHNvdW5kcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gIG1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xuICBtaWRkbGVNb3ZpbmdEb3duUGxheWJhY2tSYXRlTWFwcGVyPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xuXG4gIC8vIFRoZSBudW1iZXIgb2YgdGhyZXNob2xkcyB0aGF0LCB3aGVuIHJlYWNoZWQgb3IgY3Jvc3NlZCwgd2lsbCBjYXVzZSBhIHNvdW5kIHRvIGJlIHBsYXllZCB3aGVuIGNoZWNraW5nIHZhbHVlIGNoYW5nZXNcbiAgLy8gYWdhaW5zdCB0aHJlc2hvbGRzLiAgSW4gb3RoZXIgd29yZHMsIHRoaXMgaXMgdGhlIG51bWJlciBvZiB0aHJlc2hvbGRzIHRoYXQgZXhpc3QgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzLlxuICAvLyBUaGlzIGFzc3VtZXMgc3ltbWV0cmljIHNwYWNpbmcgb2YgdGhlIHRocmVzaG9sZHMsIGFuZCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGV4cGxpY2l0bHkgc2V0dGluZyBvZiB0aGUgJ2RlbHRhJ1xuICAvLyB2YWx1ZS5cbiAgbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzPzogbnVtYmVyIHwgbnVsbDtcblxuICAvLyBUaGUgZGVsdGEgdmFsdWUgYmV0d2VlbiB0aHJlc2hvbGRzIHRoYXQgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gc291bmRzIGFyZSBwbGF5ZWQuICBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHdheVxuICAvLyB0byBzcGVjaWZ5IHRoZSB0aHJlc2hvbGRzIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzIGNhbid0LCB3aGljaCBpcyBnZW5lcmFsbHkgd2hlbiBhXG4gIC8vIHZlcnkgc3BlY2lmaWMgZGVsdGEgaXMgcmVxdWlyZWQgYW5kIGhhdmluZyBwZXJmZWN0bHkgZXZlbiB0aHJlc2hvbGRzIGlzbid0IGNvbXBsZXRlbHkgZGVzaXJhYmxlLiAgTm90ZSB0aGF0IHRoaXNcbiAgLy8gYXBwcm9hY2ggd2lsbCBvZnRlbiBsZWFkIHRvIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsYXN0IHRocmVzaG9sZCBhbmQgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcbiAgLy8gaXNuJ3QgdGhlIHNhbWUgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYWxsIHRoZSBvdGhlciB0aHJlc2hvbGRzLiAgVGhpcyB3YXMgaW5pdGlhbGx5IGFkZGVkIHRvIHN1cHBvcnRcbiAgLy8gTnVtYmVyQ29udHJvbCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzY5Ny4gIFRoaXMgaXMgaW5jb21wYXRpYmxlIHdpdGggc3BlY2lmeWluZ1xuICAvLyBudW1iZXJPZk1pZGRsZVRocmVzaG9sZHMuXG4gIGludGVyVGhyZXNob2xkRGVsdGE/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb25zdHJhaW4gdGhlIHZhbHVlcyB1c2VkIGZvciB0aHJlc2hvbGRzIGFuZCB2YWx1ZSBjb21wYXJpc29ucy4gIFdpdGhvdXQgdGhpcywgdGhlcmUgY2FuXG4gIC8vIHNvbWV0aW1lcyBiZSBjYXNlcyB3aGVyZSBzbGlnaHQgdmFsdWUgZGlmZmVyZW5jZXMsIHN1Y2ggYXMgdGhvc2UgY2F1c2VkIGJ5IGZsb2F0aW5nIHBvaW50IGluYWNjdXJhY2llcywgY2FuIGNhdXNlXG4gIC8vIHNvdW5kcyBub3QgdG8gYmUgZ2VuZXJhdGVkIHdoZW4gdGhleSBzaG91bGQuICBVc2UgXy5pZGVudGl0eSBmb3IgYSBcIm5vLW9wXCIgaWYgbm8gY29uc3RyYWludCBpcyBuZWVkZWQuICBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIG11bHRpcGxlIHZhbHVlcywgYnV0IGlzIGNhbGxlZCBcImNvbnN0cmFpblZhbHVlXCIgcmF0aGVyIHRoYW4gXCJjb25zdHJhaW5WYWx1ZXNcIiB0byBtYXRjaCB0aGUgcHJlLWV4aXN0aW5nXG4gIC8vIG9wdGlvbiBuYW1lIGluIHRoZSBTbGlkZXIgY2xhc3MuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk3I2lzc3VlY29tbWVudC0xMDY2ODUwMTgxLlxuICBjb25zdHJhaW5WYWx1ZT86ICggbjogbnVtYmVyICkgPT4gbnVtYmVyO1xuXG4gIC8vIFRoZSBzb3VuZCBwbGF5ZXIgdGhhdCBpcyB1c2VkIHRvIGluZGljYXRlIHRoZSBtaW5pbXVtIHZhbHVlLlxuICBtaW5Tb3VuZFBsYXllcj86IFRTb3VuZFBsYXllcjtcblxuICAvLyBUaGUgc291bmQgcGxheWVyIHRoYXQgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgbWF4U291bmRQbGF5ZXI/OiBUU291bmRQbGF5ZXI7XG5cbiAgLy8gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgdGhhdCBtdXN0IHBhc3MgYWZ0ZXIgYSBtaWRkbGUgc291bmQgaXMgcGxheWVkIGJlZm9yZSBhbm90aGVyIGNhbiBiZSBwbGF5ZWQuICBUaGlzIGlzXG4gIC8vIGhlbHBmdWwgd2hlbiBhIGxvdCBvZiB2YWx1ZSBjaGFuZ2VzIGNhbiBvY2N1ciByYXBpZGx5IGFuZCB0aHVzIGNyZWF0ZSBhbiBvdmVyd2hlbG1pbmcgYW1vdW50IG9mIHNvdW5kLlxuICBtaW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWU/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgRGlzcG9zYWJsZU9wdGlvbnM7XG5cbmNsYXNzIFZhbHVlQ2hhbmdlU291bmRQbGF5ZXIgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblxuICAvLyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdGhyZXNob2xkIHZhbHVlcyBhdCB3aGljaCBzb3VuZHMgd2lsbCBiZSBwbGF5ZWQuXG4gIHByaXZhdGUgaW50ZXJUaHJlc2hvbGREaXN0YW5jZTogbnVtYmVyID0gREVGQVVMVF9OVU1CRVJfT0ZfTUlERExFX1RIUkVTSE9MRFM7XG5cbiAgLy8gcmFuZ2Ugb2YgdmFsdWVzIHRoYXQgdGhpcyBzaG91bGQgZXhwZWN0IHRvIGhhbmRsZVxuICBwcml2YXRlIHJlYWRvbmx5IHZhbHVlUmFuZ2VQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+O1xuXG4gIC8vIHNvdW5kIHBsYXllciBmb3IgbW92ZW1lbnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2UgKGkuZS4gbm90IGF0IG1pbiBvciBtYXgpIGFuZCBtb3ZpbmcgdXBcbiAgcHJpdmF0ZSByZWFkb25seSBtaWRkbGVNb3ZpbmdVcFNvdW5kUGxheWVyOiBUU291bmRQbGF5ZXIgfCBTb3VuZENsaXA7XG5cbiAgLy8gc291bmQgcGxheWVyIGZvciBtb3ZlbWVudCBpbiB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZSAoaS5lLiBub3QgYXQgbWluIG9yIG1heCkgYW5kIG1vdmluZyBkb3duXG4gIHByaXZhdGUgcmVhZG9ubHkgbWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyOiBUU291bmRQbGF5ZXIgfCBTb3VuZENsaXA7XG5cbiAgLy8gcGxheWJhY2sgcmF0ZSBtYXBwZXIgZm9yIG1pZGRsZSBzb3VuZHMgYW5kIHVwd2FyZCB2YWx1ZSBjaGFuZ2VzXG4gIHByaXZhdGUgcmVhZG9ubHkgbWlkZGxlTW92aW5nVXBQbGF5YmFja1JhdGVNYXBwZXI6ICggdmFsdWU6IG51bWJlciApID0+IG51bWJlcjtcblxuICAvLyBwbGF5YmFjayByYXRlIG1hcHBlciBmb3IgbWlkZGxlIHNvdW5kcyBhbmQgZG93bndhcmQgdmFsdWUgY2hhbmdlc1xuICBwcml2YXRlIHJlYWRvbmx5IG1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI6ICggdmFsdWU6IG51bWJlciApID0+IG51bWJlcjtcblxuICAvLyBTb3VuZCBwbGF5ZXJzIGZvciB0aGUgbWluIGFuZCBtYXggdmFsdWVzLiAgSWYgbm90aGluZyBpcyBwcm92aWRlZCBhIGRlZmF1bHQgd2lsbCBiZSB1c2VkLiAgSWYgdGhlIGZsYWdcbiAgLy8gVVNFX01JRERMRV9TT1VORCBpcyBwcm92aWRlZCwgdGhlIHNvdW5kIHBsYXllciBmb3IgdGhlIG1pZGRsZSByYW5nZSB3aWxsIGJlIHVzZWQuXG4gIHByaXZhdGUgcmVhZG9ubHkgbWluU291bmRQbGF5ZXI6IFRTb3VuZFBsYXllcjtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTb3VuZFBsYXllcjogVFNvdW5kUGxheWVyO1xuXG4gIC8vIG1pbiB0aW1lIGJldHdlZW4gcGxheWluZyBvbmUgbWlkZGxlIHNvdW5kIGFuZCB0aGUgbmV4dFxuICBwcml2YXRlIHJlYWRvbmx5IG1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTogbnVtYmVyO1xuXG4gIC8vIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiB0aGUgdmFsdWVzIHVzZWQgZm9yIHRocmVzaG9sZHMgYW5kIGNvbXBhcmlzb25zXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uc3RyYWluVmFsdWU6ICggbjogbnVtYmVyICkgPT4gbnVtYmVyO1xuXG4gIC8vIHRpbWUgb2YgbW9zdCByZWNlbnRseSBwbGF5ZWQgbWlkZGxlIHNvdW5kLCB1c2VkIHRvIG1vZGVyYXRlIHRoZSByYXRlIGF0IHdoaWNoIHRoZXNlIHNvdW5kcyBhcmUgcGxheWVkXG4gIHByaXZhdGUgdGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB2YWx1ZVJhbmdlIC0gdGhlIHJhbmdlIG9mIHZhbHVlcyBleHBlY3RlZCBhbmQgb3ZlciB3aGljaCBzb3VuZHMgd2lsbCBiZSBwbGF5ZWRcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoIHZhbHVlUmFuZ2U6IFJhbmdlIHwgVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+LCBwcm92aWRlZE9wdGlvbnM/OiBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucyApIHtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8VmFsdWVDaGFuZ2VTb3VuZFBsYXllck9wdGlvbnMsIFNlbGZPcHRpb25zLCBEaXNwb3NhYmxlT3B0aW9ucz4oKSgge1xuICAgICAgbWlkZGxlTW92aW5nVXBTb3VuZFBsYXllcjogc2hhcmVkU291bmRQbGF5ZXJzLmdldCggJ2dlbmVyYWxTb2Z0Q2xpY2snICksXG4gICAgICBtaWRkbGVNb3ZpbmdEb3duU291bmRQbGF5ZXI6IERFRkFVTFRfTUlERExFX01PVklOR19ET1dOX1NPVU5EX1BMQVlFUixcbiAgICAgIG1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyOiBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSxcbiAgICAgIG1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI6IE5PX1BMQVlCQUNLX1JBVEVfQ0hBTkdFLFxuICAgICAgbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzOiBudWxsLFxuICAgICAgaW50ZXJUaHJlc2hvbGREZWx0YTogbnVsbCxcbiAgICAgIGNvbnN0cmFpblZhbHVlOiBERUZBVUxUX1ZBTFVFX0NPTlNUUkFJTlQsXG4gICAgICBtaW5Tb3VuZFBsYXllcjogREVGQVVMVF9NSU5fU09VTkRfUExBWUVSLFxuICAgICAgbWF4U291bmRQbGF5ZXI6IHNoYXJlZFNvdW5kUGxheWVycy5nZXQoICdnZW5lcmFsQm91bmRhcnlCb29wJyApLFxuICAgICAgbWluaW11bUludGVyTWlkZGxlU291bmRUaW1lOiAwLjAzNSAvLyBlbXBpcmljYWxseSBkZXRlcm1pbmVkXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XG5cbiAgICAvLyBvcHRpb24gdmFsaWRpdHkgY2hlY2tzXG4gICAgYXNzZXJ0ICYmIGFzc2VydChcbiAgICBvcHRpb25zLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZSA+PSAwICYmIG9wdGlvbnMubWluaW11bUludGVyTWlkZGxlU291bmRUaW1lIDwgMSxcbiAgICAgIGB1bnJlYXNvbmFibGUgdmFsdWUgZm9yIG1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTogJHtvcHRpb25zLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZX1gXG4gICAgKTtcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxuICAgICAgb3B0aW9ucy5udW1iZXJPZk1pZGRsZVRocmVzaG9sZHMgPT09IG51bGwgfHwgb3B0aW9ucy5pbnRlclRocmVzaG9sZERlbHRhID09PSBudWxsLFxuICAgICAgJ2Nhbm5vdCBzcGVjaWZ5IGJvdGggdGhlIG51bWJlciBvZiBtaWRkbGUgdGhyZXNob2xkcyBhbmQgdGhlIGludGVyLXRocmVzaG9sZCBkZWx0YSdcbiAgICApO1xuICAgIGFzc2VydCAmJiBhc3NlcnQoXG4gICAgICBvcHRpb25zLm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyA9PT0gbnVsbCB8fCBOdW1iZXIuaXNJbnRlZ2VyKCBvcHRpb25zLm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyApLFxuICAgICAgJ251bWJlck9mTWlkZGxlVGhyZXNob2xkcyBtdXN0IGJlIGFuIGludGVnZXIgaWYgc3BlY2lmaWVkJ1xuICAgICk7XG5cbiAgICAvLyBJZiBhIHBsYXliYWNrIHJhdGUgbWFwcGVyIGlzIHByb3ZpZGVkIGZvciBhIG1pZGRsZSB0aHJlc2hvbGQgc291bmQsIHRoZSBwcm92aWRlZCBzb3VuZCBwbGF5ZXIgbXVzdCBzdXBwb3J0XG4gICAgLy8gc2V0dGluZyBhIGRpZmZlcmVudCBwbGF5YmFjayByYXRlLiAgSXQgc2hvdWxkIE5PVCBiZSBhIFNvdW5kQ2xpcFBsYXllciwgc2luY2UgdGhvc2UgYXJlIGRlc2lnbmVkIHRvIGJlIHNoYXJlZCwgc29cbiAgICAvLyB0aGUgcGxheWJhY2sgcmF0ZSBzaG91bGQgbmV2ZXIgYmUgY2hhbmdlZC4gIFRoZSBmb2xsb3dpbmcgYXNzZXJ0aW9ucyBhcmUgaW50ZW5kZWQgdG8gdmVyaWZ5IHRoYXQgdGhlc2Ugb3B0aW9uc1xuICAgIC8vIGFyZSBzZXQgaW4gYSBjb21wYXRpYmxlIHdheS5cbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxuICAgICAgb3B0aW9ucy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlciA9PT0gTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UgfHxcbiAgICAgIG9wdGlvbnMubWlkZGxlTW92aW5nVXBTb3VuZFBsYXllciBpbnN0YW5jZW9mIFNvdW5kQ2xpcCxcbiAgICAgICdhIHNvdW5kIHBsYXllciB0aGF0IHN1cHBvcnRzIHBsYXliYWNrIHJhdGUgY2hhbmdlcyBpcyByZXF1aXJlZCB3aGVuIGEgcGxheWJhY2sgcmF0ZSBtYXBwZXIgaXMgdXNlZCdcbiAgICApO1xuICAgIGFzc2VydCAmJiBhc3NlcnQoXG4gICAgICBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXIgPT09IE5PX1BMQVlCQUNLX1JBVEVfQ0hBTkdFIHx8XG4gICAgICBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllciBpbnN0YW5jZW9mIFNvdW5kQ2xpcCxcbiAgICAgICdhIHNvdW5kIHBsYXllciB0aGF0IHN1cHBvcnRzIHBsYXliYWNrIHJhdGUgY2hhbmdlcyBpcyByZXF1aXJlZCB3aGVuIGEgcGxheWJhY2sgcmF0ZSBtYXBwZXIgaXMgdXNlZCdcbiAgICApO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgbnVtYmVyIG9mIG1pZGRsZSB0aHJlc2hvbGRzIGlmIG5lY2Vzc2FyeS5cbiAgICBpZiAoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzID09PSBudWxsICYmIG9wdGlvbnMuaW50ZXJUaHJlc2hvbGREZWx0YSA9PT0gbnVsbCApIHtcbiAgICAgIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzID0gREVGQVVMVF9OVU1CRVJfT0ZfTUlERExFX1RIUkVTSE9MRFM7XG4gICAgfVxuXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcblxuICAgIHRoaXMudmFsdWVSYW5nZVByb3BlcnR5ID0gdmFsdWVSYW5nZSBpbnN0YW5jZW9mIFJhbmdlID8gbmV3IFRpbnlQcm9wZXJ0eSggdmFsdWVSYW5nZSApIDogdmFsdWVSYW5nZTtcbiAgICB0aGlzLm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXIgPSBvcHRpb25zLm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI7XG4gICAgdGhpcy5taWRkbGVNb3ZpbmdEb3duU291bmRQbGF5ZXIgPSBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllcjtcbiAgICB0aGlzLm1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyID0gb3B0aW9ucy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcjtcbiAgICB0aGlzLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXIgPSBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI7XG4gICAgdGhpcy5taW5Tb3VuZFBsYXllciA9IG9wdGlvbnMubWluU291bmRQbGF5ZXI7XG4gICAgdGhpcy5tYXhTb3VuZFBsYXllciA9IG9wdGlvbnMubWF4U291bmRQbGF5ZXI7XG4gICAgdGhpcy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUgPSBvcHRpb25zLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTtcbiAgICB0aGlzLnRpbWVPZk1vc3RSZWNlbnRNaWRkbGVTb3VuZCA9IDA7XG4gICAgdGhpcy5jb25zdHJhaW5WYWx1ZSA9IG9wdGlvbnMuY29uc3RyYWluVmFsdWU7XG5cbiAgICBjb25zdCByYW5nZUNoYW5nZUxpc3RlbmVyID0gKCB2YWx1ZVJhbmdlOiBSYW5nZSApID0+IHtcbiAgICAgIGlmICggb3B0aW9ucy5udW1iZXJPZk1pZGRsZVRocmVzaG9sZHMgIT09IG51bGwgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJUaHJlc2hvbGREaXN0YW5jZSA9IHZhbHVlUmFuZ2UuZ2V0TGVuZ3RoKCkgLyAoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzICsgMSApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIG9wdGlvbnMuaW50ZXJUaHJlc2hvbGREZWx0YSAhPT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlID0gb3B0aW9ucy5pbnRlclRocmVzaG9sZERlbHRhO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnc2hvdWxkIG5ldmVyIGdldCBoZXJlLCBpdCBpcyBhIGxvZ2ljIGVycm9yIGlmIHdlIGRvJyApO1xuICAgICAgICB0aGlzLmludGVyVGhyZXNob2xkRGlzdGFuY2UgPSB2YWx1ZVJhbmdlLmdldExlbmd0aCgpIC8gMjsgLy8gYXZvaWQgdW5pbml0aWFsaXplZCBjb21waWxlLXRpbWUgZXJyb3JcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LmxpbmsoIHJhbmdlQ2hhbmdlTGlzdGVuZXIgKTtcblxuICAgIHRoaXMuZGlzcG9zZUVtaXR0ZXIuYWRkTGlzdGVuZXIoICgpID0+IHtcbiAgICAgIHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnVubGluayggcmFuZ2VDaGFuZ2VMaXN0ZW5lciApO1xuICAgIH0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgbmV3IHZhbHVlIGhhcyByZWFjaGVkIG9yIGNyb3NzZWQgYSB0aHJlc2hvbGQgYW5kLCBpZiBzbywgcGxheSB0aGUgYXBwcm9wcmlhdGUgc291bmQuICBJZiBubyB0aHJlc2hvbGRcbiAgICogaGFzIGJlZW4gcmVhY2hlZCBvciBjcm9zc2VkIGFuZCB0aGUgbmV3IHZhbHVlIGlzIG5vdCBhdCB0aGUgbWluIG9yIG1heCwgbm8gc291bmQgd2lsbCBiZSBwbGF5ZWQuXG4gICAqL1xuICBwdWJsaWMgcGxheVNvdW5kSWZUaHJlc2hvbGRSZWFjaGVkKCBuZXdWYWx1ZTogbnVtYmVyLCBvbGRWYWx1ZTogbnVtYmVyICk6IHZvaWQge1xuXG4gICAgaWYgKCBuZXdWYWx1ZSAhPT0gb2xkVmFsdWUgKSB7XG5cbiAgICAgIGNvbnN0IGNvbnN0cmFpbmVkTmV3VmFsdWUgPSB0aGlzLmNvbnN0cmFpblZhbHVlKCBuZXdWYWx1ZSApO1xuICAgICAgY29uc3QgY29uc3RyYWluZWRPbGRWYWx1ZSA9IHRoaXMuY29uc3RyYWluVmFsdWUoIG9sZFZhbHVlICk7XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzID0gdGhpcy5nZXRTdXJyb3VuZGluZ1RocmVzaG9sZHMoIGNvbnN0cmFpbmVkT2xkVmFsdWUgKTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzID0gdGhpcy5nZXRTdXJyb3VuZGluZ1RocmVzaG9sZHMoIGNvbnN0cmFpbmVkTmV3VmFsdWUgKTtcblxuICAgICAgY29uc3QgdGhyZXNob2xkQ3Jvc3NlZCA9ICggb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdIC0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSApID4gdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gIT09IG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gIT09IG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAxIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gIT09IG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gIT09IG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAxIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF0gIT09IG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzWyAwIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgY29uc3QgdGhyZXNob2xkUmVhY2hlZCA9IG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdICE9PSBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdICk7XG5cbiAgICAgIGlmICggdGhyZXNob2xkQ3Jvc3NlZCB8fFxuICAgICAgICAgICB0aHJlc2hvbGRSZWFjaGVkIHx8XG4gICAgICAgICAgIGNvbnN0cmFpbmVkTmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1pbiB8fFxuICAgICAgICAgICBjb25zdHJhaW5lZE5ld1ZhbHVlID09PSB0aGlzLnZhbHVlUmFuZ2VQcm9wZXJ0eS52YWx1ZS5tYXhcbiAgICAgICkge1xuICAgICAgICB0aGlzLnBsYXlTb3VuZEZvclZhbHVlQ2hhbmdlKCBuZXdWYWx1ZSwgb2xkVmFsdWUgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGxheSB0aGUgYXBwcm9wcmlhdGUgc291bmQgZm9yIHRoZSBjaGFuZ2UgaW4gdmFsdWUgaW5kaWNhdGVkIGJ5IHRoZSBwcm92aWRlZCBuZXcgYW5kIG9sZCB2YWx1ZXMuICBUaGlzIHdpbGwgYWxtb3N0XG4gICAqIGFsd2F5cyBwbGF5IGEgc291bmQsIGJ1dCB0aGVyZSBhcmUgc29tZSBleGNlcHRpb25zLiAgU2VlIHRoZSBjb2RlIGFuZCBjb21tZW50cyBmb3IgZGV0YWlscy5cbiAgICovXG4gIHB1YmxpYyBwbGF5U291bmRGb3JWYWx1ZUNoYW5nZSggbmV3VmFsdWU6IG51bWJlciwgb2xkVmFsdWU6IG51bWJlciApOiB2b2lkIHtcbiAgICBjb25zdCBjb25zdHJhaW5lZE5ld1ZhbHVlID0gdGhpcy5jb25zdHJhaW5WYWx1ZSggbmV3VmFsdWUgKTtcbiAgICBjb25zdCBjb25zdHJhaW5lZE9sZFZhbHVlID0gdGhpcy5jb25zdHJhaW5WYWx1ZSggb2xkVmFsdWUgKTtcbiAgICBpZiAoIGNvbnN0cmFpbmVkTmV3VmFsdWUgIT09IGNvbnN0cmFpbmVkT2xkVmFsdWUgfHxcbiAgICAgICAgICggb2xkVmFsdWUgIT09IG5ld1ZhbHVlICYmICggbmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1pbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9PT0gdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkudmFsdWUubWF4ICkgKSApIHtcblxuICAgICAgaWYgKCBuZXdWYWx1ZSA9PT0gdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkudmFsdWUubWluICYmXG4gICAgICAgICAgIHRoaXMubWluU291bmRQbGF5ZXIgIT09IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXIuVVNFX01JRERMRV9TT1VORCApIHtcbiAgICAgICAgdGhpcy5taW5Tb3VuZFBsYXllci5wbGF5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICggbmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1heCAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWF4U291bmRQbGF5ZXIgIT09IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXIuVVNFX01JRERMRV9TT1VORCApIHtcbiAgICAgICAgdGhpcy5tYXhTb3VuZFBsYXllci5wbGF5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICAvLyBQbGF5IGEgbWlkZGxlLXJhbmdlIHNvdW5kLCBidXQgb25seSBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IG9uZSB3YXMgcGxheWVkLlxuICAgICAgICBjb25zdCBub3cgPSBwaGV0QXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoIG5vdyAtIHRoaXMudGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kID4gdGhpcy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUgKSB7XG4gICAgICAgICAgbGV0IHBsYXliYWNrUmF0ZU1hcHBlcjtcbiAgICAgICAgICBsZXQgc291bmRQbGF5ZXI7XG4gICAgICAgICAgaWYgKCBjb25zdHJhaW5lZE5ld1ZhbHVlID4gY29uc3RyYWluZWRPbGRWYWx1ZSApIHtcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZU1hcHBlciA9IHRoaXMubWlkZGxlTW92aW5nVXBQbGF5YmFja1JhdGVNYXBwZXI7XG4gICAgICAgICAgICBzb3VuZFBsYXllciA9IHRoaXMubWlkZGxlTW92aW5nVXBTb3VuZFBsYXllcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbGF5YmFja1JhdGVNYXBwZXIgPSB0aGlzLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI7XG4gICAgICAgICAgICBzb3VuZFBsYXllciA9IHRoaXMubWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggcGxheWJhY2tSYXRlTWFwcGVyICE9PSBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSApIHtcblxuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBwbGF5YmFjayByYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBuZXcgdmFsdWUuICBJdCBzaG91bGQgYmUgc2FmZSB0byBjYXN0IHRoaXMgaGVyZSBiZWNhdXNlIG9mXG4gICAgICAgICAgICAvLyB0aGUgYXNzZXJ0aW9uIGNoZWNrcyB0aGF0IG9jY3VyIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG4gICAgICAgICAgICAoIHNvdW5kUGxheWVyIGFzIFNvdW5kQ2xpcCApLnNldFBsYXliYWNrUmF0ZSggcGxheWJhY2tSYXRlTWFwcGVyKCBuZXdWYWx1ZSApICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdW5kUGxheWVyLnBsYXkoKTtcbiAgICAgICAgICB0aGlzLnRpbWVPZk1vc3RSZWNlbnRNaWRkbGVTb3VuZCA9IG5vdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgbmV4dCBsb3dlc3QgYW5kIG5leHQgaGlnaGVzdCB0aHJlc2hvbGRzIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUuICBJZiB0aGUgcHJvdmlkZWRcbiAgICogdmFsdWUgaXMgZXhhY3RseSBlcXVhbCB0byBhIHRocmVzaG9sZCwgb25seSB0aGUgc2luZ2xlIHRocmVzaG9sZCB2YWx1ZSBpcyByZXR1cm5lZCBpbiB0aGUgYXJyYXkuXG4gICAqL1xuICBwcml2YXRlIGdldFN1cnJvdW5kaW5nVGhyZXNob2xkcyggdmFsdWU6IG51bWJlciApOiBudW1iZXJbXSB7XG5cbiAgICAvLyBBIG5vdGUgdG8gZnV0dXJlIG1haW50YWluZXJzOiBKYXZhU2NyaXB0J3MgZmxvYXRpbmcgcG9pbnQgaW1wbGVtZW50YXRpb24gd2FzIGNhdXNpbmcgYWxsIG1hbm5lciBvZiBwcm9ibGVtcyB3aXRoXG4gICAgLy8gdGhpcyBtZXRob2QuICBGb3IgaW5zdGFuY2UsIHdoZW4gdGhlIGludGVyLXRocmVzaG9sZCBkaXN0YW5jZSB3YXMgMC4xIGFuZCB0aGUgcHJvdmlkZWQgdmFsdWUgd2FzIDAuMywgSlMgc2F5c1xuICAgIC8vIHRoYXQgMC4zLzAuMSBpcyAyLjk5OTk5OTk5OTk5OTk5OTYsIHNvIGl0IHdhcyB0cmlja3kgdG8gdGVsbCB0aGF0IHRoZSB2YWx1ZSB3YXMgYXQgYSB0aHJlc2hvbGQgYW5kIG5vdCBiZWxvdyBpdC5cbiAgICAvLyBUaGVyZWZvcmUsIHRoZSBjb2RlIGJlbG93IGRvZXMgcm91bmRpbmcgdG8gaW50ZXJ2YWxzIHRoYXQgd2VyZSBlbXBpcmljYWxseSBkZXRlcm1pbmVkIHRvIGNvcnJlY3QgZm9yIHRoZSBmbG9hdGluZ1xuICAgIC8vIHBvaW50IHByb2JsZW1zLiAgVGhpcyB3b3JrZWQgaW4gYWxsIHRlc3QgY2FzZXMsIGJ1dCBtYXkgbm90IHN0YW5kIHRoZSB0ZXN0IG9mIHRpbWUgaWYgc29tZSB1bnVzdWFsIHNsaWRlclxuICAgIC8vIGNvbmZpZ3VyYXRpb25zIGFyZSBuZWVkZWQuICBPbmUgaWRlYSBtaWdodCBiZSB0byBtYWtlIHRoZSByb3VuZGluZyBpbnRlcnZhbCBmb3IgdGhpcyBjYWxjdWxhdGlvbiBhbiBvcHRpb24gdG8gdGhlXG4gICAgLy8gY2xhc3MsIGJ1dCB0aGF0IGZlbHQgbGlrZSBvdmVya2lsbCBhdCB0aGUgdGltZSBvZiB0aGlzIHdyaXRpbmcuXG4gICAgY29uc3Qgcm91bmRpbmdJbnRlcnZhbCA9IDFFLTc7XG5cbiAgICBjb25zdCBzZWdtZW50ID0gTWF0aC5mbG9vcihcbiAgICAgIFV0aWxzLnJvdW5kVG9JbnRlcnZhbCggKCB2YWx1ZSAtIHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1pbiApIC8gdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlLFxuICAgICAgICByb3VuZGluZ0ludGVydmFsIClcbiAgICApO1xuXG4gICAgY29uc3QgbG93ZXJUaHJlc2hvbGQgPSBVdGlscy5yb3VuZFRvSW50ZXJ2YWwoXG4gICAgICBzZWdtZW50ICogdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlICsgdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkudmFsdWUubWluLFxuICAgICAgcm91bmRpbmdJbnRlcnZhbFxuICAgICk7XG4gICAgY29uc3QgdGhyZXNob2xkQXJyYXkgPSBbIGxvd2VyVGhyZXNob2xkIF07XG4gICAgaWYgKCBsb3dlclRocmVzaG9sZCAhPT0gdmFsdWUgKSB7XG5cbiAgICAgIC8vIFRoZSBwcm92aWRlZCB2YWx1ZSB3YXNuJ3QgZXhhY3RseSBhdCBhIHRocmVzaG9sZC4gIFNpbmNlIHRoZSBwcmVjZWRpbmcgY2FsY3VsYXRpb24gcHJvdmlkZWQgdGhlIGxvd2VyXG4gICAgICAvLyB0aHJlc2hvbGQsIGFkZCB0aGUgdXBwZXIgb25lIG5vdy5cbiAgICAgIGNvbnN0IHVwcGVyVGhyZXNob2xkID0gTWF0aC5taW4oXG4gICAgICAgIFV0aWxzLnJvdW5kVG9JbnRlcnZhbCggbG93ZXJUaHJlc2hvbGQgKyB0aGlzLmludGVyVGhyZXNob2xkRGlzdGFuY2UsIHJvdW5kaW5nSW50ZXJ2YWwgKSxcbiAgICAgICAgdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkudmFsdWUubWF4XG4gICAgICApO1xuXG4gICAgICAvLyBUaGlzIG1heSBzZWVtIGxpa2UgYW4gb2RkIHRlc3QsIHNvIGhlcmUncyB0aGUgc3Rvcnk6IFRoZXJlIGFyZSBzb21lIHJhcmUgYnV0IHBvc3NpYmxlIGNhc2VzIHdoZXJlIHRoZVxuICAgICAgLy8gY2FsY3VsYXRpb24gYWJvdmUgZG9lc24ndCBhY3R1YWxseSB5aWVsZCBhIGhpZ2hlciB2YWx1ZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAgV2hlbiB0ZXN0aW5nIGluIERlY1xuICAgICAgLy8gMjAyMiwgdGhpcyB3YXMgb25seSBzZWVuIG9uIHRoZSBXYXZlIFBhY2tldCBDZW50ZXIgc2xpZGVyIGluIEZvdXJpZXIgTWFraW5nIFdhdmVzLiAgU28sIG9ubHkgYWRkIHRoZSB1cHBlclxuICAgICAgLy8gdGhyZXNob2xkIGlmIGl0J3MgYWN0dWFsbHkgaGlnaGVyIHRoYW4gdGhlIGxvd2VyIG9uZS4gIElmIHRoZSB1cHBlciB0aHJlc2hvbGQgaXNuJ3QgYWRkZWQsIHRoaXMgZXNzZW50aWFsbHlcbiAgICAgIC8vIHNheXMgdGhhdCB0aGUgbG93ZXIgdGhyZXNob2xkIHdhcyBhbiBleGFjdCBtYXRjaCBmb3Igb25lIG9mIHRoZSBjcm9zc2luZyB0aHJlc2hvbGRzLCB3aGljaCBpcyBhcHByb3hpbWF0ZWx5XG4gICAgICAvLyB0cnVlIGFuZCBoYXMgd29ya2VkIGZpbmUgaW4gYWxsIHRlc3QgY2FzZXMgdGh1cyBmYXIuXG4gICAgICBpZiAoIHVwcGVyVGhyZXNob2xkID4gbG93ZXJUaHJlc2hvbGQgKSB7XG4gICAgICAgIHRocmVzaG9sZEFycmF5LnB1c2goIHVwcGVyVGhyZXNob2xkICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aHJlc2hvbGRBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0YXRpYyBpbnN0YW5jZSB0aGF0IG1ha2VzIG5vIHNvdW5kLiAgVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCBhcyBhbiBvcHRpb24gdmFsdWUgdG8gdHVybiBvZmYgc291bmQgZ2VuZXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTk9fU09VTkQgPSBuZXcgVmFsdWVDaGFuZ2VTb3VuZFBsYXllciggbmV3IFJhbmdlKCAwLCAxICksIHtcbiAgICBtaWRkbGVNb3ZpbmdVcFNvdW5kUGxheWVyOiBudWxsU291bmRQbGF5ZXIsXG4gICAgbWluU291bmRQbGF5ZXI6IG51bGxTb3VuZFBsYXllcixcbiAgICBtYXhTb3VuZFBsYXllcjogbnVsbFNvdW5kUGxheWVyXG4gIH0gKTtcblxuICAvKipcbiAgICogQSBzdGF0aWMgVFNvdW5kUGxheWVyIGluc3RhbmNlIHRoYXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIGZsYWcgZm9yIHRoZSBtaW4gYW5kIG1heCBzb3VuZCBwbGF5ZXJzIHRvXG4gICAqIGluZGljYXRlIHRoYXQgdGhlIG1pZGRsZSBzb3VuZCBwbGF5ZXIgc2hvdWxkIGJlIHVzZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFVTRV9NSURETEVfU09VTkQ6IFRTb3VuZFBsYXllciA9IHtcbiAgICBwbGF5OiBTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTixcbiAgICBzdG9wOiBTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTlxuICB9O1xufVxuXG50YW1iby5yZWdpc3RlciggJ1ZhbHVlQ2hhbmdlU291bmRQbGF5ZXInLCBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyICk7XG5cbmV4cG9ydCBkZWZhdWx0IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXI7Il0sIm5hbWVzIjpbIkRpc3Bvc2FibGUiLCJUaW55UHJvcGVydHkiLCJSYW5nZSIsIlV0aWxzIiwib3B0aW9uaXplIiwiZ2VuZXJhbEJvdW5kYXJ5Qm9vcF9tcDMiLCJnZW5lcmFsU29mdENsaWNrX21wMyIsIm51bGxTb3VuZFBsYXllciIsInBoZXRBdWRpb0NvbnRleHQiLCJzaGFyZWRTb3VuZFBsYXllcnMiLCJ0YW1ibyIsIlNvdW5kQ2xpcCIsIlNvdW5kQ2xpcFBsYXllciIsIkRFRkFVTFRfTlVNQkVSX09GX01JRERMRV9USFJFU0hPTERTIiwiREVGQVVMVF9NSU5fU09VTkRfUExBWUVSIiwic291bmRDbGlwT3B0aW9ucyIsImluaXRpYWxPdXRwdXRMZXZlbCIsImluaXRpYWxQbGF5YmFja1JhdGUiLCJNYXRoIiwicG93Iiwic291bmRNYW5hZ2VyT3B0aW9ucyIsImNhdGVnb3J5TmFtZSIsIkRFRkFVTFRfTUlERExFX01PVklOR19ET1dOX1NPVU5EX1BMQVlFUiIsIkRFRkFVTFRfVkFMVUVfQ09OU1RSQUlOVCIsInZhbHVlIiwicm91bmRUb0ludGVydmFsIiwiTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UiLCJTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTiIsImFzc2VydCIsIlZhbHVlQ2hhbmdlU291bmRQbGF5ZXIiLCJwbGF5U291bmRJZlRocmVzaG9sZFJlYWNoZWQiLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwiY29uc3RyYWluZWROZXdWYWx1ZSIsImNvbnN0cmFpblZhbHVlIiwiY29uc3RyYWluZWRPbGRWYWx1ZSIsIm9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzIiwiZ2V0U3Vycm91bmRpbmdUaHJlc2hvbGRzIiwibmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMiLCJ0aHJlc2hvbGRDcm9zc2VkIiwibGVuZ3RoIiwiYWJzIiwiaW50ZXJUaHJlc2hvbGREaXN0YW5jZSIsInRocmVzaG9sZFJlYWNoZWQiLCJ2YWx1ZVJhbmdlUHJvcGVydHkiLCJtaW4iLCJtYXgiLCJwbGF5U291bmRGb3JWYWx1ZUNoYW5nZSIsIm1pblNvdW5kUGxheWVyIiwiVVNFX01JRERMRV9TT1VORCIsInBsYXkiLCJtYXhTb3VuZFBsYXllciIsIm5vdyIsImN1cnJlbnRUaW1lIiwidGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kIiwibWluaW11bUludGVyTWlkZGxlU291bmRUaW1lIiwicGxheWJhY2tSYXRlTWFwcGVyIiwic291bmRQbGF5ZXIiLCJtaWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlciIsIm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXIiLCJtaWRkbGVNb3ZpbmdEb3duUGxheWJhY2tSYXRlTWFwcGVyIiwibWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyIiwic2V0UGxheWJhY2tSYXRlIiwicm91bmRpbmdJbnRlcnZhbCIsInNlZ21lbnQiLCJmbG9vciIsImxvd2VyVGhyZXNob2xkIiwidGhyZXNob2xkQXJyYXkiLCJ1cHBlclRocmVzaG9sZCIsInB1c2giLCJ2YWx1ZVJhbmdlIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImdldCIsIm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyIsImludGVyVGhyZXNob2xkRGVsdGEiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJyYW5nZUNoYW5nZUxpc3RlbmVyIiwiZ2V0TGVuZ3RoIiwibGluayIsImRpc3Bvc2VFbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJ1bmxpbmsiLCJOT19TT1VORCIsInN0b3AiLCJyZWdpc3RlciJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBRXREOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBRUQsT0FBT0EsZ0JBQXVDLGlDQUFpQztBQUMvRSxPQUFPQyxrQkFBa0IsbUNBQW1DO0FBRTVELE9BQU9DLFdBQVcsMkJBQTJCO0FBQzdDLE9BQU9DLFdBQVcsMkJBQTJCO0FBQzdDLE9BQU9DLGVBQWUscUNBQXFDO0FBQzNELE9BQU9DLDZCQUE2QiwwQ0FBMEM7QUFDOUUsT0FBT0MsMEJBQTBCLHVDQUF1QztBQUN4RSxPQUFPQyxxQkFBcUIsd0JBQXdCO0FBQ3BELE9BQU9DLHNCQUFzQix5QkFBeUI7QUFDdEQsT0FBT0Msd0JBQXdCLDJCQUEyQjtBQUMxRCxPQUFPQyxXQUFXLGNBQWM7QUFFaEMsT0FBT0MsZUFBZSxpQkFBaUI7QUFDdkMsT0FBT0MscUJBQXFCLHVCQUF1QjtBQUVuRCxZQUFZO0FBQ1osTUFBTUMsc0NBQXNDLEdBQUcsbUJBQW1CO0FBQ2xFLE1BQU1DLDJCQUEyQixJQUFJRixnQkFBaUJQLHlCQUF5QjtJQUM3RVUsa0JBQWtCO1FBQ2hCQyxvQkFBb0I7UUFDcEJDLHFCQUFxQixJQUFJQyxLQUFLQyxHQUFHLENBQUUsR0FBRyxJQUFJLEdBQUksdUJBQXVCO0lBQ3ZFO0lBQ0FDLHFCQUFxQjtRQUFFQyxjQUFjO0lBQWlCO0FBQ3hEO0FBQ0EsTUFBTUMsMENBQTBDLElBQUlWLGdCQUFpQk4sc0JBQXNCO0lBQ3pGUyxrQkFBa0I7UUFDaEJDLG9CQUFvQjtRQUNwQkMscUJBQXFCLElBQUlDLEtBQUtDLEdBQUcsQ0FBRSxHQUFHLElBQUksR0FBSSx1QkFBdUI7SUFDdkU7SUFDQUMscUJBQXFCO1FBQUVDLGNBQWM7SUFBaUI7QUFDeEQ7QUFFQSx3SEFBd0g7QUFDeEgsbUNBQW1DO0FBQ25DLE1BQU1FLDJCQUEyQixDQUFFQyxR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