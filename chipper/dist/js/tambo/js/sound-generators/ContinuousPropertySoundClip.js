// Copyright 2019-2024, University of Colorado Boulder
/**
 * ContinuousPropertySoundClip is a sound generator that alters the playback rate of a sound clip based on the
 * value of a continuous numerical Property.  It is specifically designed to work with sound clips and does not support
 * other types of sound production, such as oscillators.  It is implemented such that the sound fades in when changes
 * occur in the Property's value and fades out when the value doesn't change for some (configurable) amount of time.
 * This was generalized from GRAVITY_FORCE_LAB_BASICS/ForceSoundGenerator, see
 * https://github.com/phetsims/tambo/issues/76.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */ import stepTimer from '../../../axon/js/stepTimer.js';
import Range from '../../../dot/js/Range.js';
import optionize from '../../../phet-core/js/optionize.js';
import isSettingPhetioStateProperty from '../../../tandem/js/isSettingPhetioStateProperty.js';
import soundConstants from '../soundConstants.js';
import tambo from '../tambo.js';
import SoundClip from './SoundClip.js';
let ContinuousPropertySoundClip = class ContinuousPropertySoundClip extends SoundClip {
    /**
   * Step this sound generator, used for fading out the sound in the absence of change.
   * @param dt - change in time (i.e. delta time) in seconds
   */ step(dt) {
        if (this.remainingFadeTime > 0) {
            this.remainingFadeTime = Math.max(this.remainingFadeTime - dt, 0);
            if (this.remainingFadeTime < this.fadeTime + this.delayBeforeStop && this.outputLevel > 0) {
                // the sound is fading out, adjust the output level
                const outputLevel = Math.max((this.remainingFadeTime - this.delayBeforeStop) / this.fadeTime, 0);
                this.setOutputLevel(outputLevel * this.nonFadedOutputLevel);
            }
            // fade out complete, stop playback
            if (this.remainingFadeTime === 0 && this.isPlaying) {
                this.stop(0);
            }
        }
    }
    /**
   * stop any in-progress sound generation
   */ reset() {
        this.stop(0);
        this.remainingFadeTime = 0;
    }
    /**
   * @param property
   * @param range - the range of values that the provided property can take on
   * @param sound - returned by the import directive, should be optimized for good continuous looping, which
   *   may require it to be a .wav file, since .mp3 files generally have a bit of silence at the beginning.
   * @param [providedOptions]
   */ constructor(property, range, sound, providedOptions){
        assert && assert(!providedOptions || !providedOptions.loop, 'loop option should be supplied by ContinuousPropertySoundClip');
        const options = optionize()({
            initialOutputLevel: 0.7,
            loop: true,
            trimSilence: true,
            fadeStartDelay: 0.2,
            fadeTime: 0.15,
            delayBeforeStop: 0.1,
            playbackRateRange: new Range(0.5, 2),
            normalizationMappingExponent: 1,
            stopOnDisabled: false,
            stepEmitter: stepTimer
        }, providedOptions);
        super(sound, options);
        this.fadeTime = options.fadeTime;
        this.delayBeforeStop = options.delayBeforeStop;
        this.nonFadedOutputLevel = options.initialOutputLevel === undefined ? 1 : options.initialOutputLevel;
        this.remainingFadeTime = 0;
        // start with the output level at zero so that the initial sound generation has a bit of fade in
        this.setOutputLevel(0, 0);
        // function for starting the sound or adjusting the volume
        const listener = (value)=>{
            // Update the sound generation when the value changes, but only if we enabled. This prevents the play() from
            // occurring at all.
            if (this.fullyEnabled) {
                // Calculate the playback rate.  This is done by first normalizing the value over the provided range, then
                // mapping that value using an exponential function that can be used to create a non-linear mapping to emphasize
                // certain portions of the range.
                const normalizedValue = range.getNormalizedValue(value);
                const mappedNormalizedValueNew = Math.pow(normalizedValue, options.normalizationMappingExponent);
                const playbackRate = options.playbackRateRange.expandNormalizedValue(mappedNormalizedValueNew);
                // Update the parameters of the sound clip based on the new value.
                this.setPlaybackRate(playbackRate);
                this.setOutputLevel(this.nonFadedOutputLevel);
                if (!this.isPlaying && !isSettingPhetioStateProperty.value) {
                    this.play();
                }
                // reset the fade countdown
                this.remainingFadeTime = options.fadeStartDelay + options.fadeTime + this.delayBeforeStop;
            }
        };
        property.lazyLink(listener);
        this.disposeEmitter.addListener(()=>property.unlink(listener));
        if (options.stopOnDisabled) {
            this.fullyEnabledProperty.lazyLink((enabled)=>{
                !enabled && this.stop(soundConstants.DEFAULT_LINEAR_GAIN_CHANGE_TIME);
            });
        }
        // Hook up the time-driven behavior.
        if (options.stepEmitter) {
            const stepEmitterListener = (dt)=>this.step(dt);
            options.stepEmitter.addListener(stepEmitterListener);
            // Remove step emitter listener on disposal.
            this.disposeEmitter.addListener(()=>{
                var _options_stepEmitter;
                return (_options_stepEmitter = options.stepEmitter) == null ? void 0 : _options_stepEmitter.removeListener(stepEmitterListener);
            });
        }
    }
};
tambo.register('ContinuousPropertySoundClip', ContinuousPropertySoundClip);
export default ContinuousPropertySoundClip;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RhbWJvL2pzL3NvdW5kLWdlbmVyYXRvcnMvQ29udGludW91c1Byb3BlcnR5U291bmRDbGlwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxuXG4vKipcbiAqIENvbnRpbnVvdXNQcm9wZXJ0eVNvdW5kQ2xpcCBpcyBhIHNvdW5kIGdlbmVyYXRvciB0aGF0IGFsdGVycyB0aGUgcGxheWJhY2sgcmF0ZSBvZiBhIHNvdW5kIGNsaXAgYmFzZWQgb24gdGhlXG4gKiB2YWx1ZSBvZiBhIGNvbnRpbnVvdXMgbnVtZXJpY2FsIFByb3BlcnR5LiAgSXQgaXMgc3BlY2lmaWNhbGx5IGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBzb3VuZCBjbGlwcyBhbmQgZG9lcyBub3Qgc3VwcG9ydFxuICogb3RoZXIgdHlwZXMgb2Ygc291bmQgcHJvZHVjdGlvbiwgc3VjaCBhcyBvc2NpbGxhdG9ycy4gIEl0IGlzIGltcGxlbWVudGVkIHN1Y2ggdGhhdCB0aGUgc291bmQgZmFkZXMgaW4gd2hlbiBjaGFuZ2VzXG4gKiBvY2N1ciBpbiB0aGUgUHJvcGVydHkncyB2YWx1ZSBhbmQgZmFkZXMgb3V0IHdoZW4gdGhlIHZhbHVlIGRvZXNuJ3QgY2hhbmdlIGZvciBzb21lIChjb25maWd1cmFibGUpIGFtb3VudCBvZiB0aW1lLlxuICogVGhpcyB3YXMgZ2VuZXJhbGl6ZWQgZnJvbSBHUkFWSVRZX0ZPUkNFX0xBQl9CQVNJQ1MvRm9yY2VTb3VuZEdlbmVyYXRvciwgc2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdGFtYm8vaXNzdWVzLzc2LlxuICpcbiAqIEBhdXRob3IgSm9obiBCbGFuY28gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICovXG5cbmltcG9ydCBzdGVwVGltZXIgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9zdGVwVGltZXIuanMnO1xuaW1wb3J0IHsgVFJlYWRPbmx5RW1pdHRlciB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVEVtaXR0ZXIuanMnO1xuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xuaW1wb3J0IGlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL2lzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkuanMnO1xuaW1wb3J0IHNvdW5kQ29uc3RhbnRzIGZyb20gJy4uL3NvdW5kQ29uc3RhbnRzLmpzJztcbmltcG9ydCB0YW1ibyBmcm9tICcuLi90YW1iby5qcyc7XG5pbXBvcnQgV3JhcHBlZEF1ZGlvQnVmZmVyIGZyb20gJy4uL1dyYXBwZWRBdWRpb0J1ZmZlci5qcyc7XG5pbXBvcnQgU291bmRDbGlwLCB7IFNvdW5kQ2xpcE9wdGlvbnMgfSBmcm9tICcuL1NvdW5kQ2xpcC5qcyc7XG5cbnR5cGUgU2VsZk9wdGlvbnMgPSB7XG5cbiAgLy8gdGltZSB0byB3YWl0IGJlZm9yZSBzdGFydGluZyBmYWRlIG91dCBpZiBubyBhY3Rpdml0eSwgaW4gc2Vjb25kc1xuICBmYWRlU3RhcnREZWxheT86IG51bWJlcjtcblxuICAvLyBkdXJhdGlvbiBvZiBmYWRlIG91dCwgaW4gc2Vjb25kc1xuICBmYWRlVGltZT86IG51bWJlcjtcblxuICAvLyBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIGZyb20gZnVsbCBmYWRlIHRvIHN0b3Agb2Ygc291bmQsIGRvbmUgdG8gYXZvaWQgc29uaWMgZ2xpdGNoZXNcbiAgZGVsYXlCZWZvcmVTdG9wPzogbnVtYmVyO1xuXG4gIC8vIFRoaXMgb3B0aW9uIGRlZmluZXMgdGhlIHJhbmdlIG9mIHBsYXliYWNrIHJhdGVzIHVzZWQgd2hlbiBtYXBwaW5nIHRoZSBwcm92aWRlZCBQcm9wZXJ0eSB2YWx1ZSB0byBhIHBpdGNoLiAgQSB2YWx1ZVxuICAvLyBvZiAxIGluZGljYXRlcyB0aGUgbm9taW5hbCBwbGF5YmFjayByYXRlLCAwLjUgaXMgaGFsZiBzcGVlZCAoYW4gb2N0YXZlIGxvd2VyKSwgMiBpcyBkb3VibGUgc3BlZWQgKGFuIG9jdGF2ZVxuICAvLyBoaWdoZXIpLiAgU28sIGEgcmFuZ2Ugb2YgMSB0byAyIHdvdWxkIGdvIGZyb20gdGhlIG5vbWluYWwgcGxheWJhY2sgcmF0ZSBvZiB0aGUgc291bmQgdG8gb25lIG9jdGF2ZSBoaWdoZXIuICBWYWx1ZXNcbiAgLy8gb2YgMCBvciBsZXNzIGFyZSBpbnZhbGlkLlxuICBwbGF5YmFja1JhdGVSYW5nZT86IFJhbmdlO1xuXG4gIC8vIFRoZSBleHBvbmVudCB1c2VkIHdoZW4gbWFwcGluZyBhIG5vcm1hbGl6ZWQgdmFsdWUgdG8gYSBwbGF5YmFjayByYXRlLiAgU2VlIGNvZGUgZm9yIGV4YWN0bHkgaG93IHRoaXMgaXMgdXNlZCwgYnV0XG4gIC8vIHRoZSBiYXNpYyBpZGVhIGlzIHRoYXQgYSB2YWx1ZSBvZiAxICh0aGUgZGVmYXVsdCkgc2hvdWxkIGJlIHVzZWQgZm9yIGEgbGluZWFyIG1hcHBpbmcgYWNyb3NzIHRoZSByYW5nZSwgYSB2YWx1ZVxuICAvLyBhYm92ZSAxIGZvciBzbWFsbGVyIGNoYW5nZXMgYXQgdGhlIGxvd2VyIHBvcnRpb24gb2YgdGhlIHJhbmdlIGFuZCBncmVhdGVyIGNoYW5nZXMgdG93YXJkcyB0aGUgdG9wLCBhbmQgYSB2YWx1ZVxuICAvLyBiZWxvdyAxIGZvciBncmVhdGVyIGNoYW5nZXMgaW4gdGhlIGxvd2VyIHBvcnRpb24gb2YgdGhlIHJhbmdlIGFuZCBzbWFsbGVyIGNoYW5nZXMgdG93YXJkcyB0aGUgdG9wLlxuICBub3JtYWxpemF0aW9uTWFwcGluZ0V4cG9uZW50PzogbnVtYmVyO1xuXG4gIC8vIElmIHRydWUsIHdlIHdpbGwgc3RvcCgpIHdoZW4gdGhlIHNvdW5kIGlzIGRpc2FibGVkLiBUaGUgc3RvcCB1c2VzIHRoZSBERUZBVUxUX0xJTkVBUl9HQUlOX0NIQU5HRV9USU1FIGFzIGl0cyBkZWxheVxuICAvLyB0byBtYXRjaCB0aGUgZnVsbHlFbmFibGVkUHJvcGVydHkgbGluayBsb2dpYyBpbiBTb3VuZEdlbmVyYXRvci5cbiAgc3RvcE9uRGlzYWJsZWQ/OiBib29sZWFuO1xuXG4gIC8vIEFuIGVtaXR0ZXIgdGhhdCBjYW4gYmUgcHJvdmlkZWQgdG8gc3RlcCB0aGUgdGltZS1kcml2ZW4gYmVoYXZpb3Igb2YgdGhpcyBzb3VuZCBnZW5lcmF0b3IuICBCeSBkZWZhdWx0LCB0aGlzIHVzZXNcbiAgLy8gdGhlIGdsb2JhbGx5IGF2YWlsYWJsZSBzdGVwVGltZXIgaW5zdGFuY2UuICBJZiBzZXQgdG8gbnVsbCwgbm90aGluZyB3aWxsIGJlIGhvb2tlZCB1cCwgYW5kIGl0IHdpbGwgYmUgdXAgdG8gdGhlXG4gIC8vIGNsaWVudCB0byBzdGVwIHRoZSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgc3RlcEVtaXR0ZXI/OiBUUmVhZE9ubHlFbWl0dGVyPFsgbnVtYmVyIF0+IHwgbnVsbDtcbn07XG5leHBvcnQgdHlwZSBDb250aW51b3VzUHJvcGVydHlTb3VuZENsaXBPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBTb3VuZENsaXBPcHRpb25zO1xuXG5jbGFzcyBDb250aW51b3VzUHJvcGVydHlTb3VuZENsaXAgZXh0ZW5kcyBTb3VuZENsaXAge1xuXG4gIC8vIGR1cmF0aW9uIG9mIGluYWN0aXZpdHkgZmFkZSBvdXRcbiAgcHJpdmF0ZSByZWFkb25seSBmYWRlVGltZTogbnVtYmVyO1xuXG4gIC8vIHNlZSBkb2NzIGluIG9wdGlvbnMgdHlwZSBkZWNsYXJhdGlvblxuICBwcml2YXRlIHJlYWRvbmx5IGRlbGF5QmVmb3JlU3RvcDogbnVtYmVyO1xuXG4gIC8vIHRoZSBvdXRwdXQgbGV2ZWwgYmVmb3JlIGZhZGUgb3V0IHN0YXJ0c1xuICBwcml2YXRlIHJlYWRvbmx5IG5vbkZhZGVkT3V0cHV0TGV2ZWw6IG51bWJlcjtcblxuICAvLyBjb3VudGRvd24gdGltZSB1c2VkIGZvciBmYWRlIG91dFxuICBwcml2YXRlIHJlbWFpbmluZ0ZhZGVUaW1lOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gcmFuZ2UgLSB0aGUgcmFuZ2Ugb2YgdmFsdWVzIHRoYXQgdGhlIHByb3ZpZGVkIHByb3BlcnR5IGNhbiB0YWtlIG9uXG4gICAqIEBwYXJhbSBzb3VuZCAtIHJldHVybmVkIGJ5IHRoZSBpbXBvcnQgZGlyZWN0aXZlLCBzaG91bGQgYmUgb3B0aW1pemVkIGZvciBnb29kIGNvbnRpbnVvdXMgbG9vcGluZywgd2hpY2hcbiAgICogICBtYXkgcmVxdWlyZSBpdCB0byBiZSBhIC53YXYgZmlsZSwgc2luY2UgLm1wMyBmaWxlcyBnZW5lcmFsbHkgaGF2ZSBhIGJpdCBvZiBzaWxlbmNlIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAqIEBwYXJhbSBbcHJvdmlkZWRPcHRpb25zXVxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPixcbiAgICAgICAgICAgICAgICAgICAgICByYW5nZTogUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgc291bmQ6IFdyYXBwZWRBdWRpb0J1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBDb250aW51b3VzUHJvcGVydHlTb3VuZENsaXBPcHRpb25zICkge1xuXG4gICAgYXNzZXJ0ICYmIGFzc2VydChcbiAgICAgICFwcm92aWRlZE9wdGlvbnMgfHwgIXByb3ZpZGVkT3B0aW9ucy5sb29wLFxuICAgICAgJ2xvb3Agb3B0aW9uIHNob3VsZCBiZSBzdXBwbGllZCBieSBDb250aW51b3VzUHJvcGVydHlTb3VuZENsaXAnXG4gICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8Q29udGludW91c1Byb3BlcnR5U291bmRDbGlwT3B0aW9ucywgU2VsZk9wdGlvbnMsIFNvdW5kQ2xpcE9wdGlvbnM+KCkoIHtcbiAgICAgIGluaXRpYWxPdXRwdXRMZXZlbDogMC43LFxuICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgIHRyaW1TaWxlbmNlOiB0cnVlLFxuICAgICAgZmFkZVN0YXJ0RGVsYXk6IDAuMixcbiAgICAgIGZhZGVUaW1lOiAwLjE1LFxuICAgICAgZGVsYXlCZWZvcmVTdG9wOiAwLjEsXG4gICAgICBwbGF5YmFja1JhdGVSYW5nZTogbmV3IFJhbmdlKCAwLjUsIDIgKSwgLy8gMiBvY3RhdmVzLCBvbmUgYmVsb3cgYW5kIG9uZSBhYm92ZSB0aGUgcHJvdmlkZWQgc291bmQncyBpbmhlcmVudCBwaXRjaFxuICAgICAgbm9ybWFsaXphdGlvbk1hcHBpbmdFeHBvbmVudDogMSwgLy8gbGluZWFyIG1hcHBpbmcgYnkgZGVmYXVsdFxuICAgICAgc3RvcE9uRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgc3RlcEVtaXR0ZXI6IHN0ZXBUaW1lclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xuXG4gICAgc3VwZXIoIHNvdW5kLCBvcHRpb25zICk7XG5cbiAgICB0aGlzLmZhZGVUaW1lID0gb3B0aW9ucy5mYWRlVGltZTtcbiAgICB0aGlzLmRlbGF5QmVmb3JlU3RvcCA9IG9wdGlvbnMuZGVsYXlCZWZvcmVTdG9wO1xuICAgIHRoaXMubm9uRmFkZWRPdXRwdXRMZXZlbCA9IG9wdGlvbnMuaW5pdGlhbE91dHB1dExldmVsID09PSB1bmRlZmluZWQgPyAxIDogb3B0aW9ucy5pbml0aWFsT3V0cHV0TGV2ZWw7XG4gICAgdGhpcy5yZW1haW5pbmdGYWRlVGltZSA9IDA7XG5cbiAgICAvLyBzdGFydCB3aXRoIHRoZSBvdXRwdXQgbGV2ZWwgYXQgemVybyBzbyB0aGF0IHRoZSBpbml0aWFsIHNvdW5kIGdlbmVyYXRpb24gaGFzIGEgYml0IG9mIGZhZGUgaW5cbiAgICB0aGlzLnNldE91dHB1dExldmVsKCAwLCAwICk7XG5cbiAgICAvLyBmdW5jdGlvbiBmb3Igc3RhcnRpbmcgdGhlIHNvdW5kIG9yIGFkanVzdGluZyB0aGUgdm9sdW1lXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoIHZhbHVlOiBudW1iZXIgKSA9PiB7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgc291bmQgZ2VuZXJhdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLCBidXQgb25seSBpZiB3ZSBlbmFibGVkLiBUaGlzIHByZXZlbnRzIHRoZSBwbGF5KCkgZnJvbVxuICAgICAgLy8gb2NjdXJyaW5nIGF0IGFsbC5cbiAgICAgIGlmICggdGhpcy5mdWxseUVuYWJsZWQgKSB7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwbGF5YmFjayByYXRlLiAgVGhpcyBpcyBkb25lIGJ5IGZpcnN0IG5vcm1hbGl6aW5nIHRoZSB2YWx1ZSBvdmVyIHRoZSBwcm92aWRlZCByYW5nZSwgdGhlblxuICAgICAgICAvLyBtYXBwaW5nIHRoYXQgdmFsdWUgdXNpbmcgYW4gZXhwb25lbnRpYWwgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBub24tbGluZWFyIG1hcHBpbmcgdG8gZW1waGFzaXplXG4gICAgICAgIC8vIGNlcnRhaW4gcG9ydGlvbnMgb2YgdGhlIHJhbmdlLlxuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSByYW5nZS5nZXROb3JtYWxpemVkVmFsdWUoIHZhbHVlICk7XG4gICAgICAgIGNvbnN0IG1hcHBlZE5vcm1hbGl6ZWRWYWx1ZU5ldyA9IE1hdGgucG93KCBub3JtYWxpemVkVmFsdWUsIG9wdGlvbnMubm9ybWFsaXphdGlvbk1hcHBpbmdFeHBvbmVudCApO1xuICAgICAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZVJhbmdlLmV4cGFuZE5vcm1hbGl6ZWRWYWx1ZSggbWFwcGVkTm9ybWFsaXplZFZhbHVlTmV3ICk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBzb3VuZCBjbGlwIGJhc2VkIG9uIHRoZSBuZXcgdmFsdWUuXG4gICAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKCBwbGF5YmFja1JhdGUgKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRMZXZlbCggdGhpcy5ub25GYWRlZE91dHB1dExldmVsICk7XG4gICAgICAgIGlmICggIXRoaXMuaXNQbGF5aW5nICYmICFpc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5LnZhbHVlICkge1xuICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIGZhZGUgY291bnRkb3duXG4gICAgICAgIHRoaXMucmVtYWluaW5nRmFkZVRpbWUgPSBvcHRpb25zLmZhZGVTdGFydERlbGF5ICsgb3B0aW9ucy5mYWRlVGltZSArIHRoaXMuZGVsYXlCZWZvcmVTdG9wO1xuICAgICAgfVxuICAgIH07XG4gICAgcHJvcGVydHkubGF6eUxpbmsoIGxpc3RlbmVyICk7XG4gICAgdGhpcy5kaXNwb3NlRW1pdHRlci5hZGRMaXN0ZW5lciggKCkgPT4gcHJvcGVydHkudW5saW5rKCBsaXN0ZW5lciApICk7XG5cbiAgICBpZiAoIG9wdGlvbnMuc3RvcE9uRGlzYWJsZWQgKSB7XG4gICAgICB0aGlzLmZ1bGx5RW5hYmxlZFByb3BlcnR5LmxhenlMaW5rKCBlbmFibGVkID0+IHtcbiAgICAgICAgIWVuYWJsZWQgJiYgdGhpcy5zdG9wKCBzb3VuZENvbnN0YW50cy5ERUZBVUxUX0xJTkVBUl9HQUlOX0NIQU5HRV9USU1FICk7XG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgLy8gSG9vayB1cCB0aGUgdGltZS1kcml2ZW4gYmVoYXZpb3IuXG4gICAgaWYgKCBvcHRpb25zLnN0ZXBFbWl0dGVyICkge1xuICAgICAgY29uc3Qgc3RlcEVtaXR0ZXJMaXN0ZW5lciA9ICggZHQ6IG51bWJlciApID0+IHRoaXMuc3RlcCggZHQgKTtcbiAgICAgIG9wdGlvbnMuc3RlcEVtaXR0ZXIuYWRkTGlzdGVuZXIoIHN0ZXBFbWl0dGVyTGlzdGVuZXIgKTtcblxuICAgICAgLy8gUmVtb3ZlIHN0ZXAgZW1pdHRlciBsaXN0ZW5lciBvbiBkaXNwb3NhbC5cbiAgICAgIHRoaXMuZGlzcG9zZUVtaXR0ZXIuYWRkTGlzdGVuZXIoICgpID0+IG9wdGlvbnMuc3RlcEVtaXR0ZXI/LnJlbW92ZUxpc3RlbmVyKCBzdGVwRW1pdHRlckxpc3RlbmVyICkgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RlcCB0aGlzIHNvdW5kIGdlbmVyYXRvciwgdXNlZCBmb3IgZmFkaW5nIG91dCB0aGUgc291bmQgaW4gdGhlIGFic2VuY2Ugb2YgY2hhbmdlLlxuICAgKiBAcGFyYW0gZHQgLSBjaGFuZ2UgaW4gdGltZSAoaS5lLiBkZWx0YSB0aW1lKSBpbiBzZWNvbmRzXG4gICAqL1xuICBwdWJsaWMgc3RlcCggZHQ6IG51bWJlciApOiB2b2lkIHtcbiAgICBpZiAoIHRoaXMucmVtYWluaW5nRmFkZVRpbWUgPiAwICkge1xuICAgICAgdGhpcy5yZW1haW5pbmdGYWRlVGltZSA9IE1hdGgubWF4KCB0aGlzLnJlbWFpbmluZ0ZhZGVUaW1lIC0gZHQsIDAgKTtcblxuICAgICAgaWYgKCAoIHRoaXMucmVtYWluaW5nRmFkZVRpbWUgPCB0aGlzLmZhZGVUaW1lICsgdGhpcy5kZWxheUJlZm9yZVN0b3AgKSAmJiB0aGlzLm91dHB1dExldmVsID4gMCApIHtcblxuICAgICAgICAvLyB0aGUgc291bmQgaXMgZmFkaW5nIG91dCwgYWRqdXN0IHRoZSBvdXRwdXQgbGV2ZWxcbiAgICAgICAgY29uc3Qgb3V0cHV0TGV2ZWwgPSBNYXRoLm1heCggKCB0aGlzLnJlbWFpbmluZ0ZhZGVUaW1lIC0gdGhpcy5kZWxheUJlZm9yZVN0b3AgKSAvIHRoaXMuZmFkZVRpbWUsIDAgKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRMZXZlbCggb3V0cHV0TGV2ZWwgKiB0aGlzLm5vbkZhZGVkT3V0cHV0TGV2ZWwgKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmFkZSBvdXQgY29tcGxldGUsIHN0b3AgcGxheWJhY2tcbiAgICAgIGlmICggdGhpcy5yZW1haW5pbmdGYWRlVGltZSA9PT0gMCAmJiB0aGlzLmlzUGxheWluZyApIHtcbiAgICAgICAgdGhpcy5zdG9wKCAwICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHN0b3AgYW55IGluLXByb2dyZXNzIHNvdW5kIGdlbmVyYXRpb25cbiAgICovXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3AoIDAgKTtcbiAgICB0aGlzLnJlbWFpbmluZ0ZhZGVUaW1lID0gMDtcbiAgfVxufVxuXG50YW1iby5yZWdpc3RlciggJ0NvbnRpbnVvdXNQcm9wZXJ0eVNvdW5kQ2xpcCcsIENvbnRpbnVvdXNQcm9wZXJ0eVNvdW5kQ2xpcCApO1xuXG5leHBvcnQgZGVmYXVsdCBDb250aW51b3VzUHJvcGVydHlTb3VuZENsaXA7Il0sIm5hbWVzIjpbInN0ZXBUaW1lciIsIlJhbmdlIiwib3B0aW9uaXplIiwiaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eSIsInNvdW5kQ29uc3RhbnRzIiwidGFtYm8iLCJTb3VuZENsaXAiLCJDb250aW51b3VzUHJvcGVydHlTb3VuZENsaXAiLCJzdGVwIiwiZHQiLCJyZW1haW5pbmdGYWRlVGltZSIsIk1hdGgiLCJtYXgiLCJmYWRlVGltZSIsImRlbGF5QmVmb3JlU3RvcCIsIm91dHB1dExldmVsIiwic2V0T3V0cHV0TGV2ZWwiLCJub25GYWRlZE91dHB1dExldmVsIiwiaXNQbGF5aW5nIiwic3RvcCIsInJlc2V0IiwicHJvcGVydHkiLCJyYW5nZSIsInNvdW5kIiwicHJvdmlkZWRPcHRpb25zIiwiYXNzZXJ0IiwibG9vcCIsIm9wdGlvbnMiLCJpbml0aWFsT3V0cHV0TGV2ZWwiLCJ0cmltU2lsZW5jZSIsImZhZGVTdGFydERlbGF5IiwicGxheWJhY2tSYXRlUmFuZ2UiLCJub3JtYWxpemF0aW9uTWFwcGluZ0V4cG9uZW50Iiwic3RvcE9uRGlzYWJsZWQiLCJzdGVwRW1pdHRlciIsInVuZGVmaW5lZCIsImxpc3RlbmVyIiwidmFsdWUiLCJmdWxseUVuYWJsZWQiLCJub3JtYWxpemVkVmFsdWUiLCJnZXROb3JtYWxpemVkVmFsdWUiLCJtYXBwZWROb3JtYWxpemVkVmFsdWVOZXciLCJwb3ciLCJwbGF5YmFja1JhdGUiLCJleHBhbmROb3JtYWxpemVkVmFsdWUiLCJzZXRQbGF5YmFja1JhdGUiLCJwbGF5IiwibGF6eUxpbmsiLCJkaXNwb3NlRW1pdHRlciIsImFkZExpc3RlbmVyIiwidW5saW5rIiwiZnVsbHlFbmFibGVkUHJvcGVydHkiLCJlbmFibGVkIiwiREVGQVVMVF9MSU5FQVJfR0FJTl9DSEFOR0VfVElNRSIsInN0ZXBFbWl0dGVyTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlZ2lzdGVyIl0sIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFFdEQ7Ozs7Ozs7Ozs7Q0FVQyxHQUVELE9BQU9BLGVBQWUsZ0NBQWdDO0FBR3RELE9BQU9DLFdBQVcsMkJBQTJCO0FBQzdDLE9BQU9DLGVBQWUscUNBQXFDO0FBQzNELE9BQU9DLGtDQUFrQyxxREFBcUQ7QUFDOUYsT0FBT0Msb0JBQW9CLHVCQUF1QjtBQUNsRCxPQUFPQyxXQUFXLGNBQWM7QUFFaEMsT0FBT0MsZUFBcUMsaUJBQWlCO0FBb0M3RCxJQUFBLEFBQU1DLDhCQUFOLE1BQU1BLG9DQUFvQ0Q7SUFrR3hDOzs7R0FHQyxHQUNELEFBQU9FLEtBQU1DLEVBQVUsRUFBUztRQUM5QixJQUFLLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsR0FBSTtZQUNoQyxJQUFJLENBQUNBLGlCQUFpQixHQUFHQyxLQUFLQyxHQUFHLENBQUUsSUFBSSxDQUFDRixpQkFBaUIsR0FBR0QsSUFBSTtZQUVoRSxJQUFLLEFBQUUsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJLENBQUNH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