// Copyright 2017-2024, University of Colorado Boulder
/**
 * Bounds2 tests
 *
 * @author Jonathan Olson (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */ import Matrix3, { m3, Matrix3Type } from './Matrix3.js';
import Vector2 from './Vector2.js';
QUnit.module('Matrix3');
function approximateEquals(assert, a, b, msg) {
    assert.ok(Math.abs(a - b) < 0.00000001, `${msg} expected: ${b}, result: ${a}`);
}
const epsilon = 0.00001;
function approximateEqual(assert, a, b, msg) {
    assert.ok(Math.abs(a - b) < epsilon, `${msg} expected: ${b}, got: ${a}`);
}
function approximateMatrixEqual(assert, a, b, msg) {
    assert.ok(a.equalsEpsilon(b, epsilon), `${msg} expected: ${b.toString()}, got: ${a.toString()}`);
}
// test matrices, randomly generated
function A() {
    return m3(0.216673, -0.455249, -0.0897734, -0.261922, -0.208968, -0.0790977, -0.0689069, -0.620147, 0.275399);
}
function B() {
    return m3(0.366511, -0.872824, 0.490591, 0.0543773, 0.610759, 0.961396, 0.880586, 0.991026, -0.358927);
}
function C() {
    return m3(0.521806, 0.523286, -0.275077, 0.270099, 0.135544, 0.614202, 0, 0, 1);
}
// test vectors, randomly generated
function V2() {
    return new Vector2(0.739498, 0.827537);
}
QUnit.test('Affine detection', (assert)=>{
    assert.equal(A().type, Matrix3Type.OTHER);
    assert.equal(B().type, Matrix3Type.OTHER);
    assert.equal(C().type, Matrix3Type.AFFINE);
});
QUnit.test('Row-major', (assert)=>{
    const m = m3(1, 2, 3, 4, 5, 6, 7, 8, 9);
    assert.equal(m.m00(), 1, 'm00');
    assert.equal(m.m01(), 2, 'm01');
    assert.equal(m.m02(), 3, 'm02');
    assert.equal(m.m10(), 4, 'm10');
    assert.equal(m.m11(), 5, 'm11');
    assert.equal(m.m12(), 6, 'm12');
    assert.equal(m.m20(), 7, 'm20');
    assert.equal(m.m21(), 8, 'm21');
    assert.equal(m.m22(), 9, 'm22');
});
QUnit.test('Column-major', (assert)=>{
    const m = m3();
    m.columnMajor(1, 4, 7, 2, 5, 8, 3, 6, 9);
    assert.equal(m.m00(), 1, 'm00');
    assert.equal(m.m01(), 2, 'm01');
    assert.equal(m.m02(), 3, 'm02');
    assert.equal(m.m10(), 4, 'm10');
    assert.equal(m.m11(), 5, 'm11');
    assert.equal(m.m12(), 6, 'm12');
    assert.equal(m.m20(), 7, 'm20');
    assert.equal(m.m21(), 8, 'm21');
    assert.equal(m.m22(), 9, 'm22');
});
QUnit.test('Determinant', (assert)=>{
    approximateEqual(assert, A().getDeterminant(), -0.0717069, 'A');
    approximateEqual(assert, B().getDeterminant(), -1.42292, 'B');
});
QUnit.test('Rotation', (assert)=>{
    const angle = Math.PI / 6 + 0.2543;
    approximateEqual(assert, Matrix3.rotation2(angle).getRotation(), angle);
});
QUnit.test('plus / add', (assert)=>{
    const a = A();
    const b = B();
    const result = m3(0.583184, -1.32807, 0.400818, -0.207545, 0.401791, 0.882298, 0.81168, 0.370878, -0.0835274);
    approximateMatrixEqual(assert, a.plus(b), result, 'plus');
    approximateMatrixEqual(assert, a, A(), 'verifying immutability');
    approximateMatrixEqual(assert, a.add(b), result, 'add');
    approximateMatrixEqual(assert, a, result, 'verifying mutability');
});
QUnit.test('minus / subtract', (assert)=>{
    const a = A();
    const b = B();
    const result = m3(-0.149837, 0.417574, -0.580365, -0.3163, -0.819726, -1.04049, -0.949493, -1.61117, 0.634326);
    approximateMatrixEqual(assert, a.minus(b), result, 'minus');
    approximateMatrixEqual(assert, a, A(), 'verifying immutability');
    approximateMatrixEqual(assert, a.subtract(b), result, 'subtract');
    approximateMatrixEqual(assert, a, result, 'verifying mutability');
});
QUnit.test('transposed / transpose', (assert)=>{
    const a = A();
    const result = m3(0.216673, -0.261922, -0.0689069, -0.455249, -0.208968, -0.620147, -0.0897734, -0.0790977, 0.275399);
    approximateMatrixEqual(assert, a.transposed(), result, 'transposed');
    approximateMatrixEqual(assert, a, A(), 'verifying immutability');
    approximateMatrixEqual(assert, a.transpose(), result, 'transpose');
    approximateMatrixEqual(assert, a, result, 'verifying mutability');
});
QUnit.test('negated / negate', (assert)=>{
    const a = A();
    const result = m3(-0.216673, 0.455249, 0.0897734, 0.261922, 0.208968, 0.0790977, 0.0689069, 0.620147, -0.275399);
    approximateMatrixEqual(assert, a.negated(), result, 'negated');
    approximateMatrixEqual(assert, a, A(), 'verifying immutability');
    approximateMatrixEqual(assert, a.negate(), result, 'negate');
    approximateMatrixEqual(assert, a, result, 'verifying mutability');
});
QUnit.test('inverted / invert', (assert)=>{
    const a = A();
    const result = m3(1.48663, -2.52483, -0.240555, -1.08195, -0.745893, -0.566919, -2.06439, -2.31134, 2.29431);
    approximateMatrixEqual(assert, a.inverted(), result, 'inverted');
    approximateMatrixEqual(assert, a, A(), 'verifying immutability');
    approximateMatrixEqual(assert, a.invert(), result, 'invert');
    approximateMatrixEqual(assert, a, result, 'verifying mutability');
});
QUnit.test('timesMatrix / multiplyMatrix', (assert)=>{
    const a = A();
    const b = B();
    const result = m3(-0.0243954, -0.556133, -0.299155, -0.177013, 0.0225954, -0.301007, 0.183536, -0.0456892, -0.72886);
    approximateMatrixEqual(assert, a.timesMatrix(b), result, 'timesMatrix');
    approximateMatrixEqual(assert, a, A(), 'verifying immutability');
    approximateMatrixEqual(assert, a.multiplyMatrix(b), result, 'multiplyMatrix');
    approximateMatrixEqual(assert, a, result, 'verifying mutability');
});
QUnit.test('timesVector2 / multiplyVector2', (assert)=>{
    const c = C();
    const v = V2();
    const result = new Vector2(0.543836, 0.926107);
    approximateMatrixEqual(assert, c.timesVector2(v), result, 'timesVector2');
    approximateMatrixEqual(assert, v, V2(), 'verifying immutability');
    approximateMatrixEqual(assert, c.multiplyVector2(v), result, 'multiplyVector2');
    approximateMatrixEqual(assert, v, result, 'verifying mutability');
});
QUnit.test('timesTransposeVector2 / multiplyTransposeVector2', (assert)=>{
    const c = C();
    const v = V2();
    c.timesTransposeVector2(v);
    approximateMatrixEqual(assert, v, V2(), 'verifying immutability');
    approximateMatrixEqual(assert, c.multiplyTransposeVector2(v), c.timesTransposeVector2(V2()), 'multiplyTransposeVector2');
    approximateMatrixEqual(assert, v, c.timesTransposeVector2(V2()), 'verifying mutability');
});
QUnit.test('timesRelativeVector2 / multiplyRelativeVector2', (assert)=>{
    const c = C();
    const v = V2();
    c.timesRelativeVector2(v);
    approximateMatrixEqual(assert, v, V2(), 'verifying immutability');
    approximateMatrixEqual(assert, c.multiplyRelativeVector2(v), c.timesRelativeVector2(V2()), 'multiplyRelativeVector2');
    approximateMatrixEqual(assert, v, c.timesRelativeVector2(V2()), 'verifying mutability');
});
QUnit.test('Inverse / Multiplication tests', (assert)=>{
    approximateMatrixEqual(assert, Matrix3.IDENTITY.inverted(), Matrix3.IDENTITY, 'I * I = I');
    approximateMatrixEqual(assert, Matrix3.IDENTITY.timesMatrix(A()), A(), 'I * A = A');
    approximateMatrixEqual(assert, A().timesMatrix(Matrix3.IDENTITY), A(), 'A * I = A');
    const translation = Matrix3.translation(2, -5);
    const rotation = Matrix3.rotation2(Math.PI / 6);
    const scale = Matrix3.scale(2, 3);
    approximateMatrixEqual(assert, translation.timesMatrix(translation.inverted()), Matrix3.IDENTITY, 'translation inverse check');
    approximateMatrixEqual(assert, rotation.timesMatrix(rotation.inverted()), Matrix3.IDENTITY, 'rotation inverse check');
    approximateMatrixEqual(assert, scale.timesMatrix(scale.inverted()), Matrix3.IDENTITY, 'scale inverse check');
    approximateMatrixEqual(assert, A().timesMatrix(A().inverted()), Matrix3.IDENTITY, 'A inverse check');
    approximateMatrixEqual(assert, B().timesMatrix(B().inverted()), Matrix3.IDENTITY, 'B inverse check');
    approximateMatrixEqual(assert, C().timesMatrix(C().inverted()), Matrix3.IDENTITY, 'C inverse check');
});
QUnit.test('Matrix Scaling Tests', (assert)=>{
    const scale = Matrix3.scale(-2, 3);
    const scaleVector = scale.getScaleVector();
    approximateEqual(assert, scaleVector.x, 2, 'Scale X should be -2');
    approximateEqual(assert, scaleVector.y, 3, 'Scale Y should be 3');
    const beforeScale = scale.timesMatrix(Matrix3.rotation2(Math.PI / 2));
    approximateEqual(assert, beforeScale.getScaleVector().x, 3, 'before pi/2 rotation x');
    approximateEqual(assert, beforeScale.getScaleVector().y, 2, 'before pi/2 rotation y');
    const afterScale = Matrix3.rotation2(Math.PI / 2).timesMatrix(scale);
    approximateEqual(assert, afterScale.getScaleVector().x, 2, 'after pi/2 rotation x');
    approximateEqual(assert, afterScale.getScaleVector().y, 3, 'after pi/2 rotation y');
    const rotation = Matrix3.rotation2(0.35264);
    approximateEqual(assert, rotation.getScaleVector().x, 1, 'rotation x');
    approximateEqual(assert, rotation.getScaleVector().y, 1, 'rotation x');
});
QUnit.test('Matrix scaling()', (assert)=>{
    const rotation = Matrix3.rotation2(Math.PI / 4);
    const translation = Matrix3.translation(20, 30);
    const scale2 = Matrix3.scaling(2);
    const scale2x3y = Matrix3.scaling(2, 3);
    // the basics, just to make sure it is working
    assert.equal(scale2.getScaleVector().x, 2, 'normal x scale');
    assert.equal(scale2.getScaleVector().y, 2, 'normal y scale');
    assert.equal(scale2x3y.getScaleVector().x, 2, 'normal x scale');
    assert.equal(scale2x3y.getScaleVector().y, 3, 'normal y scale');
    const combination = rotation.timesMatrix(scale2).timesMatrix(translation);
    approximateEquals(assert, combination.getScaleVector().x, 2, 'rotated x scale');
    approximateEquals(assert, combination.getScaleVector().y, 2, 'rotated x scale');
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2RvdC9qcy9NYXRyaXgzVGVzdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTctMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXG5cbi8qKlxuICogQm91bmRzMiB0ZXN0c1xuICpcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxuICovXG5cbmltcG9ydCBNYXRyaXgzLCB7IG0zLCBNYXRyaXgzVHlwZSB9IGZyb20gJy4vTWF0cml4My5qcyc7XG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuL1ZlY3RvcjIuanMnO1xuXG5RVW5pdC5tb2R1bGUoICdNYXRyaXgzJyApO1xuXG5mdW5jdGlvbiBhcHByb3hpbWF0ZUVxdWFscyggYXNzZXJ0LCBhLCBiLCBtc2cgKSB7XG4gIGFzc2VydC5vayggTWF0aC5hYnMoIGEgLSBiICkgPCAwLjAwMDAwMDAxLCBgJHttc2d9IGV4cGVjdGVkOiAke2J9LCByZXN1bHQ6ICR7YX1gICk7XG59XG5cbmNvbnN0IGVwc2lsb24gPSAwLjAwMDAxO1xuXG5mdW5jdGlvbiBhcHByb3hpbWF0ZUVxdWFsKCBhc3NlcnQsIGEsIGIsIG1zZyApIHtcbiAgYXNzZXJ0Lm9rKCBNYXRoLmFicyggYSAtIGIgKSA8IGVwc2lsb24sIGAke21zZ30gZXhwZWN0ZWQ6ICR7Yn0sIGdvdDogJHthfWAgKTtcbn1cblxuZnVuY3Rpb24gYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCBiLCBtc2cgKSB7XG4gIGFzc2VydC5vayggYS5lcXVhbHNFcHNpbG9uKCBiLCBlcHNpbG9uICksIGAke21zZ30gZXhwZWN0ZWQ6ICR7Yi50b1N0cmluZygpfSwgZ290OiAke2EudG9TdHJpbmcoKX1gICk7XG59XG5cbi8vIHRlc3QgbWF0cmljZXMsIHJhbmRvbWx5IGdlbmVyYXRlZFxuZnVuY3Rpb24gQSgpIHtcbiAgcmV0dXJuIG0zKFxuICAgIDAuMjE2NjczLCAtMC40NTUyNDksIC0wLjA4OTc3MzQsXG4gICAgLTAuMjYxOTIyLCAtMC4yMDg5NjgsIC0wLjA3OTA5NzcsXG4gICAgLTAuMDY4OTA2OSwgLTAuNjIwMTQ3LCAwLjI3NTM5OVxuICApO1xufVxuXG5mdW5jdGlvbiBCKCkge1xuICByZXR1cm4gbTMoXG4gICAgMC4zNjY1MTEsIC0wLjg3MjgyNCwgMC40OTA1OTEsXG4gICAgMC4wNTQzNzczLCAwLjYxMDc1OSwgMC45NjEzOTYsXG4gICAgMC44ODA1ODYsIDAuOTkxMDI2LCAtMC4zNTg5MjdcbiAgKTtcbn1cblxuZnVuY3Rpb24gQygpIHtcbiAgcmV0dXJuIG0zKFxuICAgIDAuNTIxODA2LCAwLjUyMzI4NiwgLTAuMjc1MDc3LFxuICAgIDAuMjcwMDk5LCAwLjEzNTU0NCwgMC42MTQyMDIsXG4gICAgMCwgMCwgMVxuICApO1xufVxuXG4vLyB0ZXN0IHZlY3RvcnMsIHJhbmRvbWx5IGdlbmVyYXRlZFxuZnVuY3Rpb24gVjIoKSB7XG4gIHJldHVybiBuZXcgVmVjdG9yMiggMC43Mzk0OTgsIDAuODI3NTM3ICk7XG59XG5cblFVbml0LnRlc3QoICdBZmZpbmUgZGV0ZWN0aW9uJywgYXNzZXJ0ID0+IHtcbiAgYXNzZXJ0LmVxdWFsKCBBKCkudHlwZSwgTWF0cml4M1R5cGUuT1RIRVIgKTtcbiAgYXNzZXJ0LmVxdWFsKCBCKCkudHlwZSwgTWF0cml4M1R5cGUuT1RIRVIgKTtcbiAgYXNzZXJ0LmVxdWFsKCBDKCkudHlwZSwgTWF0cml4M1R5cGUuQUZGSU5FICk7XG59ICk7XG5cblFVbml0LnRlc3QoICdSb3ctbWFqb3InLCBhc3NlcnQgPT4ge1xuICBjb25zdCBtID0gbTMoIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDkgKTtcbiAgYXNzZXJ0LmVxdWFsKCBtLm0wMCgpLCAxLCAnbTAwJyApO1xuICBhc3NlcnQuZXF1YWwoIG0ubTAxKCksIDIsICdtMDEnICk7XG4gIGFzc2VydC5lcXVhbCggbS5tMDIoKSwgMywgJ20wMicgKTtcbiAgYXNzZXJ0LmVxdWFsKCBtLm0xMCgpLCA0LCAnbTEwJyApO1xuICBhc3NlcnQuZXF1YWwoIG0ubTExKCksIDUsICdtMTEnICk7XG4gIGFzc2VydC5lcXVhbCggbS5tMTIoKSwgNiwgJ20xMicgKTtcbiAgYXNzZXJ0LmVxdWFsKCBtLm0yMCgpLCA3LCAnbTIwJyApO1xuICBhc3NlcnQuZXF1YWwoIG0ubTIxKCksIDgsICdtMjEnICk7XG4gIGFzc2VydC5lcXVhbCggbS5tMjIoKSwgOSwgJ20yMicgKTtcbn0gKTtcblxuUVVuaXQudGVzdCggJ0NvbHVtbi1tYWpvcicsIGFzc2VydCA9PiB7XG4gIGNvbnN0IG0gPSBtMygpO1xuICBtLmNvbHVtbk1ham9yKCAxLCA0LCA3LCAyLCA1LCA4LCAzLCA2LCA5ICk7XG4gIGFzc2VydC5lcXVhbCggbS5tMDAoKSwgMSwgJ20wMCcgKTtcbiAgYXNzZXJ0LmVxdWFsKCBtLm0wMSgpLCAyLCAnbTAxJyApO1xuICBhc3NlcnQuZXF1YWwoIG0ubTAyKCksIDMsICdtMDInICk7XG4gIGFzc2VydC5lcXVhbCggbS5tMTAoKSwgNCwgJ20xMCcgKTtcbiAgYXNzZXJ0LmVxdWFsKCBtLm0xMSgpLCA1LCAnbTExJyApO1xuICBhc3NlcnQuZXF1YWwoIG0ubTEyKCksIDYsICdtMTInICk7XG4gIGFzc2VydC5lcXVhbCggbS5tMjAoKSwgNywgJ20yMCcgKTtcbiAgYXNzZXJ0LmVxdWFsKCBtLm0yMSgpLCA4LCAnbTIxJyApO1xuICBhc3NlcnQuZXF1YWwoIG0ubTIyKCksIDksICdtMjInICk7XG59ICk7XG5cblFVbml0LnRlc3QoICdEZXRlcm1pbmFudCcsIGFzc2VydCA9PiB7XG4gIGFwcHJveGltYXRlRXF1YWwoIGFzc2VydCwgQSgpLmdldERldGVybWluYW50KCksIC0wLjA3MTcwNjksICdBJyApO1xuICBhcHByb3hpbWF0ZUVxdWFsKCBhc3NlcnQsIEIoKS5nZXREZXRlcm1pbmFudCgpLCAtMS40MjI5MiwgJ0InICk7XG59ICk7XG5cblFVbml0LnRlc3QoICdSb3RhdGlvbicsIGFzc2VydCA9PiB7XG4gIGNvbnN0IGFuZ2xlID0gTWF0aC5QSSAvIDYgKyAwLjI1NDM7XG4gIGFwcHJveGltYXRlRXF1YWwoIGFzc2VydCwgTWF0cml4My5yb3RhdGlvbjIoIGFuZ2xlICkuZ2V0Um90YXRpb24oKSwgYW5nbGUgKTtcbn0gKTtcblxuUVVuaXQudGVzdCggJ3BsdXMgLyBhZGQnLCBhc3NlcnQgPT4ge1xuICBjb25zdCBhID0gQSgpO1xuICBjb25zdCBiID0gQigpO1xuICBjb25zdCByZXN1bHQgPSBtMyggMC41ODMxODQsIC0xLjMyODA3LCAwLjQwMDgxOCwgLTAuMjA3NTQ1LCAwLjQwMTc5MSwgMC44ODIyOTgsIDAuODExNjgsIDAuMzcwODc4LCAtMC4wODM1Mjc0ICk7XG5cbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLnBsdXMoIGIgKSwgcmVzdWx0LCAncGx1cycgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCBBKCksICd2ZXJpZnlpbmcgaW1tdXRhYmlsaXR5JyApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYS5hZGQoIGIgKSwgcmVzdWx0LCAnYWRkJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEsIHJlc3VsdCwgJ3ZlcmlmeWluZyBtdXRhYmlsaXR5JyApO1xufSApO1xuXG5RVW5pdC50ZXN0KCAnbWludXMgLyBzdWJ0cmFjdCcsIGFzc2VydCA9PiB7XG4gIGNvbnN0IGEgPSBBKCk7XG4gIGNvbnN0IGIgPSBCKCk7XG4gIGNvbnN0IHJlc3VsdCA9IG0zKCAtMC4xNDk4MzcsIDAuNDE3NTc0LCAtMC41ODAzNjUsIC0wLjMxNjMsIC0wLjgxOTcyNiwgLTEuMDQwNDksIC0wLjk0OTQ5MywgLTEuNjExMTcsIDAuNjM0MzI2ICk7XG5cbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLm1pbnVzKCBiICksIHJlc3VsdCwgJ21pbnVzJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEsIEEoKSwgJ3ZlcmlmeWluZyBpbW11dGFiaWxpdHknICk7XG5cbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLnN1YnRyYWN0KCBiICksIHJlc3VsdCwgJ3N1YnRyYWN0JyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEsIHJlc3VsdCwgJ3ZlcmlmeWluZyBtdXRhYmlsaXR5JyApO1xufSApO1xuXG5RVW5pdC50ZXN0KCAndHJhbnNwb3NlZCAvIHRyYW5zcG9zZScsIGFzc2VydCA9PiB7XG4gIGNvbnN0IGEgPSBBKCk7XG4gIGNvbnN0IHJlc3VsdCA9IG0zKCAwLjIxNjY3MywgLTAuMjYxOTIyLCAtMC4wNjg5MDY5LCAtMC40NTUyNDksIC0wLjIwODk2OCwgLTAuNjIwMTQ3LCAtMC4wODk3NzM0LCAtMC4wNzkwOTc3LCAwLjI3NTM5OSApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYS50cmFuc3Bvc2VkKCksIHJlc3VsdCwgJ3RyYW5zcG9zZWQnICk7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYSwgQSgpLCAndmVyaWZ5aW5nIGltbXV0YWJpbGl0eScgKTtcblxuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEudHJhbnNwb3NlKCksIHJlc3VsdCwgJ3RyYW5zcG9zZScgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCByZXN1bHQsICd2ZXJpZnlpbmcgbXV0YWJpbGl0eScgKTtcbn0gKTtcblxuUVVuaXQudGVzdCggJ25lZ2F0ZWQgLyBuZWdhdGUnLCBhc3NlcnQgPT4ge1xuICBjb25zdCBhID0gQSgpO1xuICBjb25zdCByZXN1bHQgPSBtMyggLTAuMjE2NjczLCAwLjQ1NTI0OSwgMC4wODk3NzM0LCAwLjI2MTkyMiwgMC4yMDg5NjgsIDAuMDc5MDk3NywgMC4wNjg5MDY5LCAwLjYyMDE0NywgLTAuMjc1Mzk5ICk7XG5cbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLm5lZ2F0ZWQoKSwgcmVzdWx0LCAnbmVnYXRlZCcgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCBBKCksICd2ZXJpZnlpbmcgaW1tdXRhYmlsaXR5JyApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYS5uZWdhdGUoKSwgcmVzdWx0LCAnbmVnYXRlJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEsIHJlc3VsdCwgJ3ZlcmlmeWluZyBtdXRhYmlsaXR5JyApO1xufSApO1xuXG5RVW5pdC50ZXN0KCAnaW52ZXJ0ZWQgLyBpbnZlcnQnLCBhc3NlcnQgPT4ge1xuICBjb25zdCBhID0gQSgpO1xuICBjb25zdCByZXN1bHQgPSBtMyggMS40ODY2MywgLTIuNTI0ODMsIC0wLjI0MDU1NSwgLTEuMDgxOTUsIC0wLjc0NTg5MywgLTAuNTY2OTE5LCAtMi4wNjQzOSwgLTIuMzExMzQsIDIuMjk0MzEgKTtcblxuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEuaW52ZXJ0ZWQoKSwgcmVzdWx0LCAnaW52ZXJ0ZWQnICk7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYSwgQSgpLCAndmVyaWZ5aW5nIGltbXV0YWJpbGl0eScgKTtcblxuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIGEuaW52ZXJ0KCksIHJlc3VsdCwgJ2ludmVydCcgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCByZXN1bHQsICd2ZXJpZnlpbmcgbXV0YWJpbGl0eScgKTtcbn0gKTtcblxuUVVuaXQudGVzdCggJ3RpbWVzTWF0cml4IC8gbXVsdGlwbHlNYXRyaXgnLCBhc3NlcnQgPT4ge1xuICBjb25zdCBhID0gQSgpO1xuICBjb25zdCBiID0gQigpO1xuICBjb25zdCByZXN1bHQgPSBtMyggLTAuMDI0Mzk1NCwgLTAuNTU2MTMzLCAtMC4yOTkxNTUsIC0wLjE3NzAxMywgMC4wMjI1OTU0LCAtMC4zMDEwMDcsIDAuMTgzNTM2LCAtMC4wNDU2ODkyLCAtMC43Mjg4NiApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYS50aW1lc01hdHJpeCggYiApLCByZXN1bHQsICd0aW1lc01hdHJpeCcgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCBBKCksICd2ZXJpZnlpbmcgaW1tdXRhYmlsaXR5JyApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYS5tdWx0aXBseU1hdHJpeCggYiApLCByZXN1bHQsICdtdWx0aXBseU1hdHJpeCcgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBhLCByZXN1bHQsICd2ZXJpZnlpbmcgbXV0YWJpbGl0eScgKTtcbn0gKTtcblxuUVVuaXQudGVzdCggJ3RpbWVzVmVjdG9yMiAvIG11bHRpcGx5VmVjdG9yMicsIGFzc2VydCA9PiB7XG4gIGNvbnN0IGMgPSBDKCk7XG4gIGNvbnN0IHYgPSBWMigpO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVmVjdG9yMiggMC41NDM4MzYsIDAuOTI2MTA3ICk7XG5cbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBjLnRpbWVzVmVjdG9yMiggdiApLCByZXN1bHQsICd0aW1lc1ZlY3RvcjInICk7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgdiwgVjIoKSwgJ3ZlcmlmeWluZyBpbW11dGFiaWxpdHknICk7XG5cbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBjLm11bHRpcGx5VmVjdG9yMiggdiApLCByZXN1bHQsICdtdWx0aXBseVZlY3RvcjInICk7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgdiwgcmVzdWx0LCAndmVyaWZ5aW5nIG11dGFiaWxpdHknICk7XG59ICk7XG5cblFVbml0LnRlc3QoICd0aW1lc1RyYW5zcG9zZVZlY3RvcjIgLyBtdWx0aXBseVRyYW5zcG9zZVZlY3RvcjInLCBhc3NlcnQgPT4ge1xuICBjb25zdCBjID0gQygpO1xuICBjb25zdCB2ID0gVjIoKTtcblxuICBjLnRpbWVzVHJhbnNwb3NlVmVjdG9yMiggdiApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIHYsIFYyKCksICd2ZXJpZnlpbmcgaW1tdXRhYmlsaXR5JyApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYy5tdWx0aXBseVRyYW5zcG9zZVZlY3RvcjIoIHYgKSwgYy50aW1lc1RyYW5zcG9zZVZlY3RvcjIoIFYyKCkgKSwgJ211bHRpcGx5VHJhbnNwb3NlVmVjdG9yMicgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCB2LCBjLnRpbWVzVHJhbnNwb3NlVmVjdG9yMiggVjIoKSApLCAndmVyaWZ5aW5nIG11dGFiaWxpdHknICk7XG59ICk7XG5cblFVbml0LnRlc3QoICd0aW1lc1JlbGF0aXZlVmVjdG9yMiAvIG11bHRpcGx5UmVsYXRpdmVWZWN0b3IyJywgYXNzZXJ0ID0+IHtcbiAgY29uc3QgYyA9IEMoKTtcbiAgY29uc3QgdiA9IFYyKCk7XG5cbiAgYy50aW1lc1JlbGF0aXZlVmVjdG9yMiggdiApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIHYsIFYyKCksICd2ZXJpZnlpbmcgaW1tdXRhYmlsaXR5JyApO1xuXG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgYy5tdWx0aXBseVJlbGF0aXZlVmVjdG9yMiggdiApLCBjLnRpbWVzUmVsYXRpdmVWZWN0b3IyKCBWMigpICksICdtdWx0aXBseVJlbGF0aXZlVmVjdG9yMicgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCB2LCBjLnRpbWVzUmVsYXRpdmVWZWN0b3IyKCBWMigpICksICd2ZXJpZnlpbmcgbXV0YWJpbGl0eScgKTtcbn0gKTtcblxuUVVuaXQudGVzdCggJ0ludmVyc2UgLyBNdWx0aXBsaWNhdGlvbiB0ZXN0cycsIGFzc2VydCA9PiB7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgTWF0cml4My5JREVOVElUWS5pbnZlcnRlZCgpLCBNYXRyaXgzLklERU5USVRZLCAnSSAqIEkgPSBJJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIE1hdHJpeDMuSURFTlRJVFkudGltZXNNYXRyaXgoIEEoKSApLCBBKCksICdJICogQSA9IEEnICk7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgQSgpLnRpbWVzTWF0cml4KCBNYXRyaXgzLklERU5USVRZICksIEEoKSwgJ0EgKiBJID0gQScgKTtcblxuICBjb25zdCB0cmFuc2xhdGlvbiA9IE1hdHJpeDMudHJhbnNsYXRpb24oIDIsIC01ICk7XG4gIGNvbnN0IHJvdGF0aW9uID0gTWF0cml4My5yb3RhdGlvbjIoIE1hdGguUEkgLyA2ICk7XG4gIGNvbnN0IHNjYWxlID0gTWF0cml4My5zY2FsZSggMiwgMyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIHRyYW5zbGF0aW9uLnRpbWVzTWF0cml4KCB0cmFuc2xhdGlvbi5pbnZlcnRlZCgpICksIE1hdHJpeDMuSURFTlRJVFksICd0cmFuc2xhdGlvbiBpbnZlcnNlIGNoZWNrJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIHJvdGF0aW9uLnRpbWVzTWF0cml4KCByb3RhdGlvbi5pbnZlcnRlZCgpICksIE1hdHJpeDMuSURFTlRJVFksICdyb3RhdGlvbiBpbnZlcnNlIGNoZWNrJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIHNjYWxlLnRpbWVzTWF0cml4KCBzY2FsZS5pbnZlcnRlZCgpICksIE1hdHJpeDMuSURFTlRJVFksICdzY2FsZSBpbnZlcnNlIGNoZWNrJyApO1xuICBhcHByb3hpbWF0ZU1hdHJpeEVxdWFsKCBhc3NlcnQsIEEoKS50aW1lc01hdHJpeCggQSgpLmludmVydGVkKCkgKSwgTWF0cml4My5JREVOVElUWSwgJ0EgaW52ZXJzZSBjaGVjaycgKTtcbiAgYXBwcm94aW1hdGVNYXRyaXhFcXVhbCggYXNzZXJ0LCBCKCkudGltZXNNYXRyaXgoIEIoKS5pbnZlcnRlZCgpICksIE1hdHJpeDMuSURFTlRJVFksICdCIGludmVyc2UgY2hlY2snICk7XG4gIGFwcHJveGltYXRlTWF0cml4RXF1YWwoIGFzc2VydCwgQygpLnRpbWVzTWF0cml4KCBDKCkuaW52ZXJ0ZWQoKSApLCBNYXRyaXgzLklERU5USVRZLCAnQyBpbnZlcnNlIGNoZWNrJyApO1xufSApO1xuXG5RVW5pdC50ZXN0KCAnTWF0cml4IFNjYWxpbmcgVGVzdHMnLCBhc3NlcnQgPT4ge1xuICBjb25zdCBzY2FsZSA9IE1hdHJpeDMuc2NhbGUoIC0yLCAzICk7XG4gIGNvbnN0IHNjYWxlVmVjdG9yID0gc2NhbGUuZ2V0U2NhbGVWZWN0b3IoKTtcbiAgYXBwcm94aW1hdGVFcXVhbCggYXNzZXJ0LCBzY2FsZVZlY3Rvci54LCAyLCAnU2NhbGUgWCBzaG91bGQgYmUgLTInICk7XG4gIGFwcHJveGltYXRlRXF1YWwoIGFzc2VydCwgc2NhbGVWZWN0b3IueSwgMywgJ1NjYWxlIFkgc2hvdWxkIGJlIDMnICk7XG5cbiAgY29uc3QgYmVmb3JlU2NhbGUgPSBzY2FsZS50aW1lc01hdHJpeCggTWF0cml4My5yb3RhdGlvbjIoIE1hdGguUEkgLyAyICkgKTtcbiAgYXBwcm94aW1hdGVFcXVhbCggYXNzZXJ0LCBiZWZvcmVTY2FsZS5nZXRTY2FsZVZlY3RvcigpLngsIDMsICdiZWZvcmUgcGkvMiByb3RhdGlvbiB4JyApO1xuICBhcHByb3hpbWF0ZUVxdWFsKCBhc3NlcnQsIGJlZm9yZVNjYWxlLmdldFNjYWxlVmVjdG9yKCkueSwgMiwgJ2JlZm9yZSBwaS8yIHJvdGF0aW9uIHknICk7XG5cbiAgY29uc3QgYWZ0ZXJTY2FsZSA9IE1hdHJpeDMucm90YXRpb24yKCBNYXRoLlBJIC8gMiApLnRpbWVzTWF0cml4KCBzY2FsZSApO1xuICBhcHByb3hpbWF0ZUVxdWFsKCBhc3NlcnQsIGFmdGVyU2NhbGUuZ2V0U2NhbGVWZWN0b3IoKS54LCAyLCAnYWZ0ZXIgcGkvMiByb3RhdGlvbiB4JyApO1xuICBhcHByb3hpbWF0ZUVxdWFsKCBhc3NlcnQsIGFmdGVyU2NhbGUuZ2V0U2NhbGVWZWN0b3IoKS55LCAzLCAnYWZ0ZXIgcGkvMiByb3RhdGlvbiB5JyApO1xuXG4gIGNvbnN0IHJvdGF0aW9uID0gTWF0cml4My5yb3RhdGlvbjIoIDAuMzUyNjQgKTtcbiAgYXBwcm94aW1hdGVFcXVhbCggYXNzZXJ0LCByb3RhdGlvbi5nZXRTY2FsZVZlY3RvcigpLngsIDEsICdyb3RhdGlvbiB4JyApO1xuICBhcHByb3hpbWF0ZUVxdWFsKCBhc3NlcnQsIHJvdGF0aW9uLmdldFNjYWxlVmVjdG9yKCkueSwgMSwgJ3JvdGF0aW9uIHgnICk7XG59ICk7XG5cblFVbml0LnRlc3QoICdNYXRyaXggc2NhbGluZygpJywgYXNzZXJ0ID0+IHtcbiAgY29uc3Qgcm90YXRpb24gPSBNYXRyaXgzLnJvdGF0aW9uMiggTWF0aC5QSSAvIDQgKTtcbiAgY29uc3QgdHJhbnNsYXRpb24gPSBNYXRyaXgzLnRyYW5zbGF0aW9uKCAyMCwgMzAgKTtcbiAgY29uc3Qgc2NhbGUyID0gTWF0cml4My5zY2FsaW5nKCAyICk7XG4gIGNvbnN0IHNjYWxlMngzeSA9IE1hdHJpeDMuc2NhbGluZyggMiwgMyApO1xuXG4gIC8vIHRoZSBiYXNpY3MsIGp1c3QgdG8gbWFrZSBzdXJlIGl0IGlzIHdvcmtpbmdcbiAgYXNzZXJ0LmVxdWFsKCBzY2FsZTIuZ2V0U2NhbGVWZWN0b3IoKS54LCAyLCAnbm9ybWFsIHggc2NhbGUnICk7XG4gIGFzc2VydC5lcXVhbCggc2NhbGUyLmdldFNjYWxlVmVjdG9yKCkueSwgMiwgJ25vcm1hbCB5IHNjYWxlJyApO1xuICBhc3NlcnQuZXF1YWwoIHNjYWxlMngzeS5nZXRTY2FsZVZlY3RvcigpLngsIDIsICdub3JtYWwgeCBzY2FsZScgKTtcbiAgYXNzZXJ0LmVxdWFsKCBzY2FsZTJ4M3kuZ2V0U2NhbGVWZWN0b3IoKS55LCAzLCAnbm9ybWFsIHkgc2NhbGUnICk7XG5cbiAgY29uc3QgY29tYmluYXRpb24gPSByb3RhdGlvbi50aW1lc01hdHJpeCggc2NhbGUyICkudGltZXNNYXRyaXgoIHRyYW5zbGF0aW9uICk7XG5cbiAgYXBwcm94aW1hdGVFcXVhbHMoIGFzc2VydCwgY29tYmluYXRpb24uZ2V0U2NhbGVWZWN0b3IoKS54LCAyLCAncm90YXRlZCB4IHNjYWxlJyApO1xuICBhcHByb3hpbWF0ZUVxdWFscyggYXNzZXJ0LCBjb21iaW5hdGlvbi5nZXRTY2FsZVZlY3RvcigpLnksIDIsICdyb3RhdGVkIHggc2NhbGUnICk7XG59ICk7Il0sIm5hbWVzIjpbIk1hdHJpeDMiLCJtMyIsIk1hdHJpeDNUeXBlIiwiVmVjdG9yMiIsIlFVbml0IiwibW9kdWxlIiwiYXBwcm94aW1hdGVFcXVhbHMiLCJhc3NlcnQiLCJhIiwiYiIsIm1zZyIsIm9rIiwiTWF0aCIsImFicyIsImVwc2lsb24iLCJhcHByb3hpbWF0ZUVxdWFsIiwiYXBwcm94aW1hdGVNYXRyaXhFcXVhbCIsImVxdWFsc0Vwc2lsb24iLCJ0b1N0cmluZyIsIkEiLCJCIiwiQyIsIlYyIiwidGVzdCIsImVxdWFsIiwidHlwZSIsIk9USEVSIiwiQUZGSU5FIiwibSIsIm0wMCIsIm0wMSIsIm0wMiIsIm0xMCIsIm0xMSIsIm0xMiIsIm0yMCIsIm0yMSIsIm0yMiIsImNvbHVtbk1ham9yIiwiZ2V0RGV0ZXJtaW5hbnQiLCJhbmdsZSIsIlBJIiwicm90YXRpb24yIiwiZ2V0Um90YXRpb24iLCJyZXN1bHQiLCJwbHVzIiwiYWRkIiwibWludXMiLCJzdWJ0cmFjdCIsInRyYW5zcG9zZWQiLCJ0cmFuc3Bvc2UiLCJuZWdhdGVkIiwibmVnYXRlIiwiaW52ZXJ0ZWQiLCJpbnZlcnQiLCJ0aW1lc01hdHJpeCIsIm11bHRpcGx5TWF0cml4IiwiYyIsInYiLCJ0aW1lc1ZlY3RvcjIiLCJtdWx0aXBseVZlY3RvcjIiLCJ0aW1lc1RyYW5zcG9zZVZlY3RvcjIiLCJtdWx0aXBseVRyYW5zcG9zZVZlY3RvcjIiLCJ0aW1lc1JlbGF0aXZlVmVjdG9yMiIsIm11bHRpcGx5UmVsYXRpdmVWZWN0b3IyIiwiSURFTlRJVFkiLCJ0cmFuc2xhdGlvbiIsInJvdGF0aW9uIiwic2NhbGUiLCJzY2FsZVZlY3RvciIsImdldFNjYWxlVmVjdG9yIiwieCIsInkiLCJiZWZvcmVTY2FsZSIsImFmdGVyU2NhbGUiLCJzY2FsZTIiLCJzY2FsaW5nIiwic2NhbGUyeDN5IiwiY29tYmluYXRpb24iXSwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUV0RDs7Ozs7Q0FLQyxHQUVELE9BQU9BLFdBQVdDLEVBQUUsRUFBRUMsV0FBVyxRQUFRLGVBQWU7QUFDeEQsT0FBT0MsYUFBYSxlQUFlO0FBRW5DQyxNQUFNQyxNQUFNLENBQUU7QUFFZCxTQUFTQyxrQkFBbUJDLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUc7SUFDM0NILE9BQU9JLEVBQUUsQ0FBRUMsS0FBS0MsR0FBRyxDQUFFTCxJQUFJQyxLQUFNLFlBQVksR0FBR0MsSUFBSSxXQUFXLEVBQUVELEVBQUUsVUFBVSxFQUFFRCxHQUFHO0FBQ2xGO0FBRUEsTUFBTU0sVUFBVTtBQUVoQixTQUFTQyxpQkFBa0JSLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUc7SUFDMUNILE9BQU9JLEVBQUUsQ0FBRUMsS0FBS0MsR0FBRyxDQUFFTCxJQUFJQyxLQUFNSyxTQUFTLEdBQUdKLElBQUksV0FBVyxFQUFFRCxFQUFFLE9BQU8sRUFBRUQsR0FBRztBQUM1RTtBQUVBLFNBQVNRLHVCQUF3QlQsTUFBTSxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRztJQUNoREgsT0FBT0ksRUFBRSxDQUFFSCxFQUFFUyxhQUFhLENBQUVSLEdBQUdLLFVBQVcsR0FBR0osSUFBSSxXQUFX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